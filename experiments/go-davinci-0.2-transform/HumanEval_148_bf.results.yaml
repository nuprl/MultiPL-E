language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya1jipa0_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        result = planets[start+1:end]\n    } else {\n  \
    \      result = planets[end+1:start]\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bs3daqi_test.go:40:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmp0bs3daqi_test.go:42:25: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var ret []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return ret\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        ret = append(ret, planets[i])\n    }\n    return ret\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpl0ocfcxe_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpl0ocfcxe_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzrxjzsmw_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzrxjzsmw_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2e84wbbk_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp93gp7efq_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmps09yrt8k_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmps09yrt8k_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rrchcqt_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == p2 {\n        return []interface{}{}\n\
    \    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n    return planets[p1+1:p2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoam6g91h_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpxqvh5xzk_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpxqvh5xzk_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa91bszu5_test.go:38:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7hjz8ac__test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    var result []interface{}\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp9bow220h_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp9bow220h_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    var result []interface{}\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp74yx6t82_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp74yx6t82_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp49xjfe4b_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp49xjfe4b_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzrxjzsmw_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        }\n     \
    \   if planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == 0 || index2 == 0 {\n        return []interface{}{}\n    }\n    if index1\
    \ > index2 {\n        index1, index2 = index2, index1\n    }\n    return planets[index1+1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_od2sxk_test.go:41:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start > end {\n        start,\
    \ end = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_87hoje_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp49xjfe4b_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp49xjfe4b_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpecx8s5dg_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpecx8s5dg_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_ftwqbd_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2e84wbbk_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            i1 = i\n        }\n        if planet\
    \ == planet2 {\n            i2 = i\n        }\n    }\n    if i1 > i2 {\n     \
    \   i1, i2 = i2, i1\n    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpheljmmz3_test.go:38:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    if planet1 == planet2 {\n  \
    \      return result\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Venus\"\
    \ {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n\
    \    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        return []interface{}{\"\
    Venus\", \"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Venus\"\
    \ {\n        return []interface{}{\"Venus\", \"Earth\"}\n    }\n    if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        return []interface{}{\"Venus\"\
    , \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Earth\"\
    \ {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n   \
    \ if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Jupiter\"\
    \ && planet2 == \"Mars\" {\n        return []interface{}{\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"\
    Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n\
    \        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n  \
    \      return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"}\n    }\n    if planet1 == \"Uran\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeese4tpd_test.go:63:19: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1_idx, planet2_idx int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1_idx = i\n   \
    \     }\n        if planet == planet2 {\n            planet2_idx = i\n       \
    \ }\n    }\n    if planet1_idx == 0 || planet2_idx == 0 {\n        return []interface{}{}\n\
    \    }\n    if planet1_idx < planet2_idx {\n        return planets[planet1_idx+1:planet2_idx]\n\
    \    } else {\n        return planets[planet2_idx+1:planet1_idx]\n    }\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxup1ock_test.go:39:23: cannot use planets[planet1_idx + 1:planet2_idx]
    (value of type []string) as type []interface{} in return statement

    /tmp/tmpjxup1ock_test.go:41:23: cannot use planets[planet2_idx + 1:planet1_idx]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp49xjfe4b_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp49xjfe4b_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmps09yrt8k_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmps09yrt8k_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        result = planets[start+1:end]\n    } else {\n  \
    \      result = planets[end+1:start]\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bs3daqi_test.go:40:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmp0bs3daqi_test.go:42:25: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        }\n     \
    \   if planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == 0 || index2 == 0 {\n        return []interface{}{}\n    }\n    if index1\
    \ > index2 {\n        index1, index2 = index2, index1\n    }\n    return planets[index1+1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_od2sxk_test.go:41:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var p1, p2 int\n    for i, v\
    \ := range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 >\
    \ p2 {\n        p1, p2 = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n \
    \       result = append(result, planets[i])\n    }\n    return result\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmplax6ygzi_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp93gp7efq_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index int\n    var planet2Index int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcm_gu2ao_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        for i := start + 1; i < end; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    } else {\n        for i\
    \ := start - 1; i > end; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpper9lfga_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpper9lfga_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpper9lfga_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_ftwqbd_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        result = planets[start+1:end]\n    } else {\n  \
    \      result = planets[end+1:start]\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptxfvfkkt_test.go:40:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmptxfvfkkt_test.go:42:25: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpecx8s5dg_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpecx8s5dg_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start > end {\n        start, end = end, start\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpgzudjlbi_test.go:65: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe6vtcsm_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx89ow0m9_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpenaqr0cw_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == p2 {\n        return []interface{}{}\n\
    \    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n    return planets[p1+1:p2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcrsidlu1_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var i1, i2 int\n    for i, p\
    \ := range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ i2 {\n        return result\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    for i := i1 + 1; i < i2; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptvfvpl27_test.go:67: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe6vtcsm_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp49xjfe4b_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp49xjfe4b_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp2exqg7f6_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp2exqg7f6_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpje7zjeti_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpdslezoke_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpc777ihrx_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n \
    \           i2 = i\n        }\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpilvfb66w_test.go:38:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    i1, i2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n\
    \            i2 = i\n        }\n    }\n    if i1 == -1 || i2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n \
    \   }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf5eiz5_o_test.go:41:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2e84wbbk_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    var result []interface{}\n    if planet1Index\
    \ < planet2Index {\n        result = planets[planet1Index+1:planet2Index]\n  \
    \  } else {\n        result = planets[planet2Index+1:planet1Index]\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_j0ugm3n_test.go:41:25: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in assignment

    /tmp/tmp_j0ugm3n_test.go:43:25: cannot use planets[planet2Index + 1:planet1Index]
    (value of type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_ftwqbd_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp49xjfe4b_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp49xjfe4b_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    var result []interface{}\n   \
    \ for i, planet := range planets {\n        if planet == planet1 {\n         \
    \   index1 = i\n        }\n        if planet == planet2 {\n            index2\
    \ = i\n        }\n    }\n    if index1 == 0 || index2 == 0 {\n        return result\n\
    \    }\n    if index1 > index2 {\n        index1, index2 = index2, index1\n  \
    \  }\n    for i := index1 + 1; i < index2; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpi948bxb3_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpi948bxb3_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rrchcqt_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := map[string]int{\n\
    \        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n     \
    \   \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"\
    Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    var result []interface{}\n \
    \   if _, ok := planets[planet1]; !ok {\n        return result\n    }\n    if\
    \ _, ok := planets[planet2]; !ok {\n        return result\n    }\n    if planets[planet1]\
    \ > planets[planet2] {\n        for i := planets[planet2]; i < planets[planet1];\
    \ i++ {\n            for planet, index := range planets {\n                if\
    \ index == i {\n                    result = append(result, planet)\n        \
    \        }\n            }\n        }\n    } else {\n        for i := planets[planet1];\
    \ i < planets[planet2]; i++ {\n            for planet, index := range planets\
    \ {\n                if index == i {\n                    result = append(result,\
    \ planet)\n                }\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpspdxrvxt_test.go:81: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpspdxrvxt_test.go:81:\
    \ expected '[Venus]', got '[Mercury Venus]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpspdxrvxt_test.go:81: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mercury Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpspdxrvxt_test.go:81: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__5\
    \ (0.00s)\n        tmpspdxrvxt_test.go:81: expected '[]', got '[Earth]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz4wpjbmg_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var ret []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        ret = append(ret, planets[i])\n    }\n    return\
    \ ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz3tfqh8__test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe6vtcsm_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2e84wbbk_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_ftwqbd_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_ftwqbd_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2e84wbbk_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1_index, planet2_index int\n    var result []interface{}\n\
    \n    for i, planet := range planets {\n        if planet == planet1 {\n     \
    \       planet1_index = i\n        }\n        if planet == planet2 {\n       \
    \     planet2_index = i\n        }\n    }\n\n    if planet1_index == 0 || planet2_index\
    \ == 0 {\n        return result\n    }\n\n    if planet1_index < planet2_index\
    \ {\n        result = planets[planet1_index+1:planet2_index]\n    } else {\n \
    \       result = planets[planet2_index+1:planet1_index]\n    }\n\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnra_f12i_test.go:43:25: cannot use planets[planet1_index + 1:planet2_index]
    (value of type []string) as type []interface{} in assignment

    /tmp/tmpnra_f12i_test.go:45:25: cannot use planets[planet2_index + 1:planet1_index]
    (value of type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya1jipa0_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya1jipa0_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya1jipa0_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var result []interface{}\n    for i, p\
    \ := range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return result\n    }\n    if p1 > p2 {\n        p1,\
    \ p2 = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0dsq3kv5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0dsq3kv5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n \
    \           i2 = i\n        }\n    }\n    if i1 == 0 || i2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n    }\n \
    \   return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7y6xjbiu_test.go:41:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe6vtcsm_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmplff1z5z6_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmplff1z5z6_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmplff1z5z6_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmplff1z5z6_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var pos1, pos2 int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            pos1 = i\n        }\n        if p == planet2\
    \ {\n            pos2 = i\n        }\n    }\n    if pos1 == 0 || pos2 == 0 {\n\
    \        return []interface{}{}\n    }\n    if pos1 > pos2 {\n        pos1, pos2\
    \ = pos2, pos1\n    }\n    return planets[pos1+1:pos2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoiakf177_test.go:41:19: cannot use planets[pos1 + 1:pos2] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya1jipa0_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var result []interface{}\n    for i, p\
    \ := range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return result\n    }\n    if p1 > p2 {\n        p1,\
    \ p2 = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0dsq3kv5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0dsq3kv5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp93gp7efq_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            planet1Index = i\n \
    \       }\n        if p == planet2 {\n            planet2Index = i\n        }\n\
    \    }\n    if planet1Index == -1 || planet2Index == -1 {\n        return []interface{}{}\n\
    \    }\n    if planet1Index > planet2Index {\n        planet1Index, planet2Index\
    \ = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi4bc87cz_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbn2xqz__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var result []interface{}\n    for i, v\
    \ := range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return result\n    }\n    if p1 < p2 {\n        for\
    \ i := p1 + 1; i < p2; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    } else {\n        for i := p2 + 1; i < p1; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    }\n    return result\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp9d9llhyd_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp9d9llhyd_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start < end {\n        result = planets[start+1:end]\n   \
    \ } else {\n        result = planets[end+1:start]\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq2x_zwmc_test.go:37:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmpq2x_zwmc_test.go:39:25: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya1jipa0_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index + 1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8jzlfbye_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        }\n     \
    \   if planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == 0 || index2 == 0 {\n        return []interface{}{}\n    }\n    if index1\
    \ > index2 {\n        index1, index2 = index2, index1\n    }\n    var result []interface{}\n\
    \    for i := index1 + 1; i < index2; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpggkhzaaf_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpggkhzaaf_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            i1 = i\n        }\n        if planet\
    \ == planet2 {\n            i2 = i\n        }\n    }\n    if i1 == 0 || i2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo74mje___test.go:41:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11mo2_k5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11mo2_k5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp93gp7efq_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyho09bjv_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyho09bjv_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz10dzdba_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpqrftevvv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpqrftevvv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpqrftevvv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpqrftevvv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpqrftevvv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpqrftevvv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, v := range planets {\n    \
    \    if v == planet1 {\n            start = i\n        }\n        if v == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4kjgsnxv_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n \
    \           i2 = i\n        }\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpilvfb66w_test.go:38:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpqrftevvv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpqrftevvv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpqrftevvv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpqrftevvv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpqrftevvv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpqrftevvv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074227
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start == 0 || end == 0 {\n        return result\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0ai5uneo_test.go:68: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0ai5uneo_test.go:68: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kwoiysh_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmga0z7ek_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2e84wbbk_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpklyaarnn_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpklyaarnn_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074227
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkueo_c51_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074222
