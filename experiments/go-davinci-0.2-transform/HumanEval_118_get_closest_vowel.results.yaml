language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_consonant_index\
    \ int\n    var last_vowel_index int\n    var last_vowel string\n    var last_consonant\
    \ string\n    var last_vowel_distance int\n    var last_consonant_distance int\n\
    \    for i, letter := range word {\n        for _, vowel := range vowels {\n \
    \           if string(letter) == vowel {\n                last_vowel_index = i\n\
    \                last_vowel = string(letter)\n            }\n        }\n     \
    \   for _, consonant := range consonants {\n            if string(letter) == consonant\
    \ {\n                last_consonant_index = i\n                last_consonant\
    \ = string(letter)\n            }\n        }\n    }\n    last_vowel_distance =\
    \ len(word) - last_vowel_index\n    last_consonant_distance = len(word) - last_consonant_index\n\
    \    if last_vowel_distance > last_consonant_distance {\n        result = last_vowel\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi22hdq6u_test.go:29:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result = \"\"\n    var last_consonant = \"\"\
    \n    var last_vowel = \"\"\n    var last_vowel_index = 0\n    var last_consonant_index\
    \ = 0\n    var last_consonant_found = false\n    var last_vowel_found = false\n\
    \    for i, c := range word {\n        if last_consonant_found && last_vowel_found\
    \ {\n            break\n        }\n        if last_consonant_found && !last_vowel_found\
    \ {\n            for _, v := range vowels {\n                if string(c) == v\
    \ {\n                    last_vowel = string(c)\n                    last_vowel_index\
    \ = i\n                    last_vowel_found = true\n                    break\n\
    \                }\n            }\n        }\n        if !last_consonant_found\
    \ {\n            for _, v := range consonants {\n                if string(c)\
    \ == v {\n                    last_consonant = string(c)\n                   \
    \ last_consonant_index = i\n                    last_consonant_found = true\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    if last_consonant_found && last_vowel_found {\n        result = last_vowel\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz0x7qeuv_test.go:26:9: last_consonant declared but not used

    /tmp/tmpz0x7qeuv_test.go:28:9: last_vowel_index declared but not used

    /tmp/tmpz0x7qeuv_test.go:29:9: last_consonant_index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    var closest_vowel_index int\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            closest_vowel = string(word[i])\n            closest_vowel_index\
    \ = i\n            break\n        }\n    }\n    if closest_vowel_index == 0 {\n\
    \        return \"\"\n    }\n    for i := closest_vowel_index - 1; i >= 0; i--\
    \ {\n        if !vowels[string(word[i])] {\n            return closest_vowel\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp665wtdjr_test.go:75: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp665wtdjr_test.go:75: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp665wtdjr_test.go:75: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp665wtdjr_test.go:75: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp665wtdjr_test.go:75:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp665wtdjr_test.go:75: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\n        \"a\": 1,\n       \
    \ \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n       \
    \ \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n       \
    \ \"U\": 1,\n    }\n    var prev_consonant bool\n    var closest_vowel string\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if prev_consonant {\n                closest_vowel = string(word[i])\n\
    \                break\n            }\n        } else {\n            prev_consonant\
    \ = true\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpy2pzndiu_test.go:75: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpy2pzndiu_test.go:75: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpy2pzndiu_test.go:75: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpy2pzndiu_test.go:75: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpy2pzndiu_test.go:75: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmpy2pzndiu_test.go:75: expected '', got 'A'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtscxlpe_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    continue\n                } else {\n                \
    \    return string(word[i])\n                }\n            }\n        }\n   \
    \ }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpma74tgew_test.go:23:5: vowels declared but not used

    /tmp/tmpma74tgew_test.go:25:12: undefined: is_vowel

    /tmp/tmpma74tgew_test.go:27:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n    \
    \        return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78e0o1n1_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i+1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw0vfrzx0_test.go:25:12: undefined: is_vowel

    /tmp/tmpw0vfrzx0_test.go:29:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074333
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var is_vowel bool\n    var\
    \ is_consonant bool\n    var is_vowel_found bool\n    var is_consonant_found bool\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        is_vowel = false\n       \
    \ is_consonant = false\n        for _, v := range vowels {\n            if word[i]\
    \ == v[0] {\n                is_vowel = true\n                break\n        \
    \    }\n        }\n        for _, c := range consonants {\n            if word[i]\
    \ == c[0] {\n                is_consonant = true\n                break\n    \
    \        }\n        }\n        if is_vowel {\n            if is_consonant_found\
    \ {\n                result = string(word[i])\n                break\n       \
    \     } else {\n                is_vowel_found = true\n            }\n       \
    \ } else if is_consonant {\n            if is_vowel_found {\n                result\
    \ = string(word[i])\n                break\n            } else {\n           \
    \     is_consonant_found = true\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmppay0tu2u_test.go:89: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmppay0tu2u_test.go:89: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmppay0tu2u_test.go:89: expected '', got 'l'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmppay0tu2u_test.go:89: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmppay0tu2u_test.go:89: expected\
    \ '', got 'b'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmppay0tu2u_test.go:89: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmppay0tu2u_test.go:89: expected 'i', got 'm'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmppay0tu2u_test.go:89:\
    \ expected '', got 's'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppay0tu2u_test.go:89: expected 'o', got 'v'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                for _, v :=\
    \ range vowels {\n                    if string(word[j]) == v {\n            \
    \            return string(word[j])\n                    }\n                }\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8v0lsw94_test.go:25:12: undefined: is_vowel

    /tmp/tmp8v0lsw94_test.go:27:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1,\
    \ \"o\": 1, \"u\": 1, \"A\": 1, \"E\": 1, \"I\": 1, \"O\": 1, \"U\": 1}\n    var\
    \ prev_vowel string\n    for i := len(word) - 1; i >= 0; i-- {\n        if _,\
    \ ok := vowels[string(word[i])]; ok {\n            prev_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if _, ok := vowels[string(word[i])]; ok {\n            if prev_vowel\
    \ != string(word[i]) {\n                return string(word[i])\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmptc9bafcw_test.go:66: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmptc9bafcw_test.go:66: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n     \
    \   tmptc9bafcw_test.go:66: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmptc9bafcw_test.go:66: expected '', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmptc9bafcw_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmptc9bafcw_test.go:66: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmptc9bafcw_test.go:66: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmptc9bafcw_test.go:66: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmptc9bafcw_test.go:66: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var distance int\n    var\
    \ minDistance int = len(word)\n    for i, c := range word {\n        if i == 0\
    \ || i == len(word) - 1 {\n            continue\n        }\n        if contains(vowels,\
    \ string(c)) {\n            if contains(consonants, string(word[i-1])) && contains(consonants,\
    \ string(word[i+1])) {\n                distance = i\n                if distance\
    \ < minDistance {\n                    minDistance = distance\n              \
    \      result = string(c)\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprve1e_7m_test.go:32:12: undefined: contains

    /tmp/tmprve1e_7m_test.go:33:16: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      } else if !is_vowel(word[i + 1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppwcu452g_test.go:25:12: undefined: is_vowel

    /tmp/tmppwcu452g_test.go:28:24: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, vowel := range vowels\
    \ {\n            if word[i] == vowel[0] {\n                return vowel\n    \
    \        }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_hbqqae5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp_hbqqae5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp_hbqqae5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp_hbqqae5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp_hbqqae5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp_hbqqae5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp_hbqqae5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp_hbqqae5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp_hbqqae5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var res string\n    var word_len = len(word)\n\
    \    for i := word_len - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if string(word[i]) == v {\n                res = string(word[i])\n\
    \                break\n            }\n        }\n        if res != \"\" {\n \
    \           break\n        }\n    }\n    if res == \"\" {\n        return res\n\
    \    }\n    var left_consonant_index int\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        for _, v := range consonants {\n            if string(word[i])\
    \ == v {\n                left_consonant_index = i\n                break\n  \
    \          }\n        }\n        if left_consonant_index != 0 {\n            break\n\
    \        }\n    }\n    if left_consonant_index == 0 {\n        return \"\"\n \
    \   }\n    var right_consonant_index int\n    for i := left_consonant_index -\
    \ 1; i >= 0; i-- {\n        for _, v := range consonants {\n            if string(word[i])\
    \ == v {\n                right_consonant_index = i\n                break\n \
    \           }\n        }\n        if right_consonant_index != 0 {\n          \
    \  break\n        }\n    }\n    if right_consonant_index == 0 {\n        return\
    \ \"\"\n    }\n    return res\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsl52s4d3_test.go:99: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsl52s4d3_test.go:99: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpsl52s4d3_test.go:99: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpsl52s4d3_test.go:99: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpsl52s4d3_test.go:99:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsl52s4d3_test.go:99: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n    \
    \        return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78e0o1n1_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var word_len = len(word)\n    var vowel_index =\
    \ -1\n    var consonant_index = -1\n    var vowel_index_list = []int{}\n    var\
    \ consonant_index_list = []int{}\n    for i := 0; i < word_len; i++ {\n      \
    \  for _, v := range vowels {\n            if string(word[i]) == v {\n       \
    \         vowel_index_list = append(vowel_index_list, i)\n            }\n    \
    \    }\n        for _, v := range consonants {\n            if string(word[i])\
    \ == v {\n                consonant_index_list = append(consonant_index_list,\
    \ i)\n            }\n        }\n    }\n    if len(vowel_index_list) == 0 || len(consonant_index_list)\
    \ == 0 {\n        return \"\"\n    }\n    for i := len(consonant_index_list) -\
    \ 1; i >= 0; i-- {\n        for j := len(vowel_index_list) - 1; j >= 0; j-- {\n\
    \            if vowel_index_list[j] < consonant_index_list[i] {\n            \
    \    return string(word[vowel_index_list[j]])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpylg2qe3n_test.go:26:9: vowel_index declared but not used

    /tmp/tmpylg2qe3n_test.go:27:9: consonant_index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    var closest_vowel string\n\
    \    for _, char := range word {\n        if vowels[string(char)] {\n        \
    \    if last_consonant != \"\" {\n                return string(char)\n      \
    \      }\n            closest_vowel = string(char)\n        } else {\n       \
    \     last_consonant = string(char)\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp2s3gait3_test.go:70: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp2s3gait3_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp2s3gait3_test.go:70: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp2s3gait3_test.go:70: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp2s3gait3_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp2s3gait3_test.go:70: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp2s3gait3_test.go:70: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp2s3gait3_test.go:70:\
    \ expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n    \
    \        return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78e0o1n1_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_count int\n    var consonant_count int\n\
    \    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n \
    \   var n int\n    var o int\n    var p int\n    var q int\n    var r int\n  \
    \  var s int\n    var t int\n    var u int\n    var v int\n    var w int\n   \
    \ var x int\n    var y int\n    var z int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var vowel_consonant_found bool\n    var vowel_consonant_distance int\n\
    \    var vowel_consonant_distance_min int\n    var vowel_consonant_distance_min_index\
    \ int\n    var vowel_consonant_distance_min_found bool\n    var vowel_consonant_distance_min_found_index\
    \ int\n    var vowel_consonant_distance_min_found_index_found bool\n    var vowel_consonant_distance_min_found_index_found_index\
    \ int\n    var vowel_consonant_distance_min_found_index_found_index_found bool\n\
    \    var vowel_consonant_distance_min_found_index_found_index_found_index int\n\
    \    var vowel_consonant_distance_min_found_index_found_index_found_index_found\
    \ bool\n    var vowel_consonant_distance_min_found_index_found_index_found_index_found_index\
    \ int\n    var vowel_consonant_distance_min_found_index_found_index_found_index_found_index_found\
    \ bool\n    var vowel_consonant_distance_min_found_index_found_index_\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpufu7zrlq_test.go:63:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074443
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var found bool\n    var\
    \ last_vowel_index int\n    var last_consonant_index int\n    var last_vowel string\n\
    \    var last_consonant string\n    var last_vowel_found bool\n    var last_consonant_found\
    \ bool\n    for i := len(word) - 1; i >= 0; i-- {\n        if !found {\n     \
    \       for _, v := range vowels {\n                if string(word[i]) == v {\n\
    \                    last_vowel_index = i\n                    last_vowel = string(word[i])\n\
    \                    last_vowel_found = true\n                    break\n    \
    \            }\n            }\n            for _, c := range consonants {\n  \
    \              if string(word[i]) == c {\n                    last_consonant_index\
    \ = i\n                    last_consonant = string(word[i])\n                \
    \    last_consonant_found = true\n                    break\n                }\n\
    \            }\n            if last_vowel_found && last_consonant_found {\n  \
    \              if last_vowel_index > last_consonant_index {\n                \
    \    result = last_vowel\n                    found = true\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpelcbjjj6_test.go:30:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var closest_vowel string\n  \
    \  for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels,\
    \ string(word[i])) {\n            closest_vowel = string(word[i])\n          \
    \  break\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp62il6svn_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]int{\n        \"a\": 1,\n    \
    \    \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    \
    \    \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n    \
    \    \"U\": 1,\n    }\n    var result string\n    var last_vowel_index int\n \
    \   for i, c := range word {\n        if _, ok := vowels[string(c)]; ok {\n  \
    \          last_vowel_index = i\n        }\n    }\n    for i := last_vowel_index;\
    \ i >= 0; i-- {\n        if _, ok := vowels[string(word[i])]; ok {\n         \
    \   if i == 0 {\n                break\n            }\n            if _, ok :=\
    \ vowels[string(word[i-1])]; !ok {\n                result = string(word[i])\n\
    \                break\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpl9jc0_mw_test.go:81: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpl9jc0_mw_test.go:81: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpl9jc0_mw_test.go:81: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpl9jc0_mw_test.go:81: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpl9jc0_mw_test.go:81:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpl9jc0_mw_test.go:81: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n    \
    \        return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78e0o1n1_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var closest_vowel string\n    var closest_vowel_index int\n    var closest_vowel_distance\
    \ int\n    for i, char := range word {\n        if char == 'a' || char == 'e'\
    \ || char == 'i' || char == 'o' || char == 'u' {\n            if closest_vowel_index\
    \ == 0 {\n                closest_vowel_index = i\n                closest_vowel\
    \ = string(char)\n            } else {\n                if i - closest_vowel_index\
    \ > closest_vowel_distance {\n                    closest_vowel_index = i\n  \
    \                  closest_vowel = string(char)\n                }\n         \
    \   }\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqdm7stts_test.go:23:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074337
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] !=\
    \ \"\" {\n            if i + 1 < len(word) && vowels[strings.Index(vowels, string(word[i\
    \ + 1]))] == \"\" {\n                return string(word[i])\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprpv24yta_test.go:25:19: undefined: strings

    /tmp/tmprpv24yta_test.go:25:62: invalid operation: vowels[strings.Index(vowels,
    string(word[i]))] != "" (mismatched types byte and untyped string)

    /tmp/tmprpv24yta_test.go:26:44: undefined: strings

    /tmp/tmprpv24yta_test.go:26:91: invalid operation: vowels[strings.Index(vowels,
    string(word[i + 1]))] == "" (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var vowel_distance int\n    var consonant_distance int\n    var distance\
    \ int\n    var min_distance int\n    var min_vowel_index int\n    var min_consonant_index\
    \ int\n    var min_vowel_distance int\n    var min_consonant_distance int\n  \
    \  var min_distance_index int\n    var min_distance_vowel_index int\n    var min_distance_consonant_index\
    \ int\n    var min_distance_vowel_distance int\n    var min_distance_consonant_distance\
    \ int\n    var min_distance_vowel_found bool\n    var min_distance_consonant_found\
    \ bool\n    var min_distance_vowel string\n    var min_distance_consonant string\n\
    \    var min_distance_vowel_char string\n    var min_distance_consonant_char string\n\
    \    var min_distance_vowel_char_index int\n    var min_distance_consonant_char_index\
    \ int\n    var min_distance_vowel_char_distance int\n    var min_distance_consonant_char_distance\
    \ int\n    var min_distance_vowel_char_found bool\n    var min_distance_consonant_char_found\
    \ bool\n    var min_distance_vowel_char_string string\n    var min_distance_consonant_char_string\
    \ string\n    var min_distance_vowel_char_string_index int\n    var min_distance_consonant_char_string_index\
    \ int\n    var min_distance_vowel_char_string_distance int\n    var min_distance\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7g6de3j8_test.go:60:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074443
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if i > 0 && vowels[i] == word[i] {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of\
    \ range [5] with length 5\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc0000fa000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc0000fa000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel(...)\n\t/tmp/tmp_0fk7nrx_test.go:25\n\
    command-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmp_0fk7nrx_test.go:39\
    \ +0xe89\ntesting.tRunner(0xc00009b6c0, 0x528fa0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowels_map := make(map[string]bool)\n    for _, v := range vowels {\n   \
    \     vowels_map[v] = true\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if vowels_map[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels_map[string(word[i\
    \ + 1])] {\n                return string(word[i])\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpp49chy5a_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpp49chy5a_test.go:66: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpp49chy5a_test.go:66: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpp49chy5a_test.go:66: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpp49chy5a_test.go:66:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpp49chy5a_test.go:66: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result string\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ is_vowel(word[i]) {\n            result = string(word[i])\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxfdrpyg2_test.go:23:5: vowels declared but not used

    /tmp/tmpxfdrpyg2_test.go:26:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_a1got_x_test.go:25:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var result string\n    var last_consonant string\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          result = string(word[i])\n        } else {\n            if last_consonant\
    \ != \"\" {\n                break\n            }\n            last_consonant\
    \ = string(word[i])\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpc9vzhkhk_test.go:70: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpc9vzhkhk_test.go:70: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpc9vzhkhk_test.go:70: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpc9vzhkhk_test.go:70: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpc9vzhkhk_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpc9vzhkhk_test.go:70: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpc9vzhkhk_test.go:70: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if is_vowel(word[i + 1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8fcjl2a_test.go:25:12: undefined: is_vowel

    /tmp/tmpi8fcjl2a_test.go:29:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]int{\n        \"a\": 1,\n    \
    \    \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    \
    \    \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n    \
    \    \"U\": 1,\n    }\n    var result string\n    var prev_is_vowel bool\n   \
    \ var prev_is_consonant bool\n    for _, char := range word {\n        if _, ok\
    \ := vowels[string(char)]; ok {\n            if prev_is_consonant {\n        \
    \        result = string(char)\n                break\n            }\n       \
    \     prev_is_vowel = true\n        } else {\n            if prev_is_vowel {\n\
    \                prev_is_consonant = true\n            }\n        }\n    }\n \
    \   return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__1\
    \ (0.00s)\n        tmpvmxxdlio_test.go:79: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpvmxxdlio_test.go:79: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvmxxdlio_test.go:79: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvmxxdlio_test.go:79: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpvmxxdlio_test.go:79:\
    \ expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_consonant(word[i]) {\n\
    \            for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return string(word[j])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04vohk17_test.go:23:5: vowels declared but not used

    /tmp/tmp04vohk17_test.go:25:12: undefined: is_consonant

    /tmp/tmp04vohk17_test.go:27:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != \"\"\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp99v_6cdc_test.go:25:19: undefined: strings

    /tmp/tmp99v_6cdc_test.go:25:62: invalid operation: vowels[strings.Index(vowels,
    string(word[i]))] != "" (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var closest_vowel string\n    var closest_vowel_index\
    \ int\n    var closest_consonant_index int\n    var closest_consonant string\n\
    \    var word_length int = len(word)\n    var i int\n    var j int\n    var k\
    \ int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n\
    \    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n \
    \   var v int\n    var w int\n    var x int\n    var y int\n    var z int\n  \
    \  var a int\n    var e int\n    var i_ int\n    var o_ int\n    var u_ int\n\
    \    var found_vowel bool = false\n    var found_consonant bool = false\n    var\
    \ found_closest_vowel bool = false\n    var found_closest_consonant bool = false\n\
    \    var found_closest_vowel_index bool = false\n    var found_closest_consonant_index\
    \ bool = false\n    var found_closest_vowel_index_after_consonant bool = false\n\
    \    var found_closest_consonant_index_before_vowel bool = false\n    var found_closest_vowel_index_after_consonant_and_closest_consonant_index_before_vowel\
    \ bool = false\n    var found_closest_vowel_index_after_consonant_and_closest_consonant_index_before_vowel_and_closest_vowel\
    \ bool = false\n    var found_closest_vowel_index_after_consonant_and_cl\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwbewcl90_test.go:63:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074445
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var distance int\n    var min_distance int\n    var min_distance_vowel\
    \ string\n    var min_distance_consonant string\n    var min_distance_vowel_index\
    \ int\n    var min_distance_consonant_index int\n    var min_distance_vowel_found\
    \ bool\n    var min_distance_consonant_found bool\n    var min_distance_set bool\n\
    \n    for i, c := range word {\n        for _, v := range vowels {\n         \
    \   if string(c) == v {\n                vowel_index = i\n                vowel_found\
    \ = true\n                break\n            }\n        }\n        if vowel_found\
    \ {\n            for _, v := range consonants {\n                if string(c)\
    \ == v {\n                    consonant_index = i\n                    consonant_found\
    \ = true\n                    break\n                }\n            }\n      \
    \      if consonant_found {\n                distance = consonant_index - vowel_index\n\
    \                if !min_distance_set {\n                    min_distance = distance\n\
    \                    min_distance_vowel = string(c)\n                    min_distance_consonant\
    \ = string(c)\n                    min_distance_vowel_index = vowel_index\n  \
    \                  min_distance_consonant_index = consonant_index\n          \
    \          min_distance_vowel_found = vowel_found\n                    min_distance_consonant_found\
    \ = consonant_found\n                    min_distance_set = true\n           \
    \     } else {\n                    if distance < min_distance {\n           \
    \             min_distance = distance\n                        min_distance_vowel\
    \ = string(c)\n                        min_distance_consonant =\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpznc0nsnb_test.go:72:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if i == 0 {\n            return \"\"\n        }\n   \
    \     if word[i] == ' ' {\n            continue\n        }\n        if strings.Contains(vowels,\
    \ string(word[i])) {\n            if strings.Contains(vowels, string(word[i -\
    \ 1])) {\n                continue\n            }\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmo7siehu_test.go:31:12: undefined: strings

    /tmp/tmpmo7siehu_test.go:32:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] !=\
    \ 0 {\n            return string(word[i])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4tmljdm_test.go:25:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var closest_vowel string\n    var closest_vowel_index int\n    var closest_vowel_distance\
    \ int\n    var vowel_index int\n    var vowel_distance int\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            vowel_index\
    \ = i\n            for _, vowel := range vowels {\n                if word[i]\
    \ == vowel[0] {\n                    vowel_distance = len(word) - i\n        \
    \            if closest_vowel_distance == 0 || vowel_distance < closest_vowel_distance\
    \ {\n                        closest_vowel_distance = vowel_distance\n       \
    \                 closest_vowel_index = vowel_index\n                        closest_vowel\
    \ = string(word[i])\n                    }\n                }\n            }\n\
    \        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyla6pg7b_test.go:25:9: closest_vowel_index declared but not used

    /tmp/tmpyla6pg7b_test.go:30:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] == string(word[i])\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if vowels[strings.Index(vowels, string(word[i+1]))] != string(word[i+1])\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpckq2xpmn_test.go:25:19: undefined: strings

    /tmp/tmpckq2xpmn_test.go:25:62: invalid operation: vowels[strings.Index(vowels,
    string(word[i]))] == string(word[i]) (mismatched types byte and string)

    /tmp/tmpckq2xpmn_test.go:29:23: undefined: strings

    /tmp/tmpckq2xpmn_test.go:29:68: invalid operation: vowels[strings.Index(vowels,
    string(word[i + 1]))] != string(word[i + 1]) (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var last_vowel string\n    var\
    \ last_consonant string\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ strings.Contains(vowels, string(word[i])) {\n            last_vowel = string(word[i])\n\
    \        } else {\n            last_consonant = string(word[i])\n            break\n\
    \        }\n    }\n    if last_vowel == \"\" || last_consonant == \"\" {\n   \
    \     return \"\"\n    }\n    return last_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rkhnpm2_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = \"aeiou\"\n    var consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n    var result = \"\"\n    var last_vowel = \"\"\n    var last_consonant = \"\
    \"\n    for i := len(word) - 1; i >= 0; i-- {\n        var c = string(word[i])\n\
    \        if vowels[0:5].contains(c) {\n            last_vowel = c\n        } else\
    \ if consonants[0:21].contains(c) {\n            last_consonant = c\n        }\n\
    \        if last_vowel != \"\" && last_consonant != \"\" {\n            result\
    \ = last_vowel\n            break\n        }\n    }\n    return result\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3utk7kf_test.go:30:24: vowels[0:5].contains undefined (type string has
    no field or method contains)

    /tmp/tmph3utk7kf_test.go:32:36: consonants[0:21].contains undefined (type string
    has no field or method contains)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result string\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ is_vowel(word[i]) {\n            result = string(word[i])\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxfdrpyg2_test.go:23:5: vowels declared but not used

    /tmp/tmpxfdrpyg2_test.go:26:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] !=\
    \ 0 {\n            if i == len(word) - 1 {\n                return string(word[i])\n\
    \            } else if vowels[strings.Index(vowels, string(word[i+1]))] == 0 {\n\
    \                return string(word[i])\n            }\n        }\n    }\n   \
    \ return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt6kb8hwn_test.go:25:19: undefined: strings

    /tmp/tmpt6kb8hwn_test.go:28:30: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtscxlpe_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if string(word[i]) == v {\n                if i == len(word) - 1\
    \ {\n                    return \"\"\n                }\n                if i\
    \ == 0 {\n                    return \"\"\n                }\n               \
    \ for _, v := range vowels {\n                    if string(word[i-1]) == v {\n\
    \                        return \"\"\n                    }\n                \
    \    if string(word[i+1]) == v {\n                        return \"\"\n      \
    \              }\n                }\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpfqm0cqpd_test.go:73: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpfqm0cqpd_test.go:73:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var prev_char, curr_char, next_char\
    \ rune\n    var prev_char_is_vowel, curr_char_is_vowel, next_char_is_vowel bool\n\
    \    var prev_char_is_consonant, curr_char_is_consonant, next_char_is_consonant\
    \ bool\n    var prev_char_is_letter, curr_char_is_letter, next_char_is_letter\
    \ bool\n    var prev_char_is_space, curr_char_is_space, next_char_is_space bool\n\
    \    var prev_char_is_punctuation, curr_char_is_punctuation, next_char_is_punctuation\
    \ bool\n    var prev_char_is_number, curr_char_is_number, next_char_is_number\
    \ bool\n    var prev_char_is_symbol, curr_char_is_symbol, next_char_is_symbol\
    \ bool\n    var prev_char_is_mark, curr_char_is_mark, next_char_is_mark bool\n\
    \    var prev_char_is_separator, curr_char_is_separator, next_char_is_separator\
    \ bool\n    var prev_char_is_other, curr_char_is_other, next_char_is_other bool\n\
    \    var prev_char_is_control, curr_char_is_control, next_char_is_control bool\n\
    \    var prev_char_is_graphic, curr_char_is_graphic, next_char_is_graphic bool\n\
    \    var prev_char_is_print, curr_char_is_print, next_char_is_print bool\n   \
    \ var prev_char_is_title, curr_char_is_title, next_char_is_title bool\n    var\
    \ prev_char_is_upper, curr_char_is_upper, next_char_is_upper bool\n    var prev_char_is_lower,\
    \ curr_char_is_lower, next_char_is_lower bool\n    var prev_char_is_digit,\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfjnbnwwg_test.go:42:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074446
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      } else if is_vowel(word[i+1], vowels) {\n                continue\n   \
    \         } else {\n                return string(word[i])\n            }\n  \
    \      }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_ekz07fa_test.go:25:12: undefined: is_vowel

    /tmp/tmp_ekz07fa_test.go:28:23: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if i == 0 {\n            return \"\"\n        }\n   \
    \     if word[i] == ' ' {\n            continue\n        }\n        if word[i-1]\
    \ == ' ' {\n            return \"\"\n        }\n        if vowels[strings.Index(vowels,\
    \ string(word[i]))] != 0 {\n            return string(word[i])\n        }\n  \
    \  }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaiskecaz_test.go:34:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if is_vowel(word[i + 1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp20jgomzh_test.go:25:12: undefined: is_vowel

    /tmp/tmp20jgomzh_test.go:29:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO: implement this function\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp7gr3xiq9_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp7gr3xiq9_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp7gr3xiq9_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp7gr3xiq9_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp7gr3xiq9_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp7gr3xiq9_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074448
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    var closest_vowel_index int\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            closest_vowel = string(word[i])\n            closest_vowel_index\
    \ = i\n            break\n        }\n    }\n    if closest_vowel_index == 0 {\n\
    \        return \"\"\n    }\n    for i := closest_vowel_index - 1; i >= 0; i--\
    \ {\n        if !vowels[string(word[i])] {\n            return closest_vowel\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp665wtdjr_test.go:75: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp665wtdjr_test.go:75: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp665wtdjr_test.go:75: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp665wtdjr_test.go:75: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp665wtdjr_test.go:75:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp665wtdjr_test.go:75: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074445
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_vowel_index int\n\
    \    var last_consonant_index int\n    for i, c := range word {\n        if string(c)\
    \ == \"a\" || string(c) == \"e\" || string(c) == \"i\" || string(c) == \"o\" ||\
    \ string(c) == \"u\" {\n            last_vowel_index = i\n        }\n        if\
    \ string(c) == \"b\" || string(c) == \"c\" || string(c) == \"d\" || string(c)\
    \ == \"f\" || string(c) == \"g\" || string(c) == \"h\" || string(c) == \"j\" ||\
    \ string(c) == \"k\" || string(c) == \"l\" || string(c) == \"m\" || string(c)\
    \ == \"n\" || string(c) == \"p\" || string(c) == \"q\" || string(c) == \"r\" ||\
    \ string(c) == \"s\" || string(c) == \"t\" || string(c) == \"v\" || string(c)\
    \ == \"w\" || string(c) == \"x\" || string(c) == \"y\" || string(c) == \"z\" {\n\
    \            last_consonant_index = i\n        }\n    }\n    if last_vowel_index\
    \ > last_consonant_index {\n        result = string(word[last_vowel_index])\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph40f8uck_test.go:23:9: vowels declared but not used

    /tmp/tmph40f8uck_test.go:24:9: consonants declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    for _, v := range vowels {\n                        if\
    \ string(word[i]) == v {\n                            return string(word[i])\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpil3nooae_test.go:25:12: undefined: is_vowel

    /tmp/tmpil3nooae_test.go:27:20: undefined: is_vowel

    /tmp/tmpil3nooae_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] !=\
    \ 0 {\n            return string(word[i])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4tmljdm_test.go:25:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var found bool\n    var closest_vowel string\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n    \
    \        if found {\n                return closest_vowel\n            }\n   \
    \         closest_vowel = string(word[i])\n        } else {\n            found\
    \ = true\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpnk4yh2lk_test.go:70: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpnk4yh2lk_test.go:70: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpnk4yh2lk_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpnk4yh2lk_test.go:70: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpnk4yh2lk_test.go:70: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmpnk4yh2lk_test.go:70: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpnk4yh2lk_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074448
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                if i == len(word) - 1 {\n \
    \                   return \"\"\n                }\n                if i == 0\
    \ {\n                    return \"\"\n                }\n                for _,\
    \ v := range vowels {\n                    if word[i + 1] == v[0] {\n        \
    \                return \"\"\n                    }\n                    if word[i\
    \ - 1] == v[0] {\n                        return \"\"\n                    }\n\
    \                }\n                return string(word[i])\n            }\n  \
    \      }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpq01ns1va_test.go:73: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpq01ns1va_test.go:73:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074448
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var vowels_map = make(map[string]bool)\n    var\
    \ consonants_map = make(map[string]bool)\n    for _, v := range vowels {\n   \
    \     vowels_map[v] = true\n    }\n    for _, v := range consonants {\n      \
    \  consonants_map[v] = true\n    }\n    var result string\n    var last_char string\n\
    \    var last_char_is_consonant bool\n    for _, v := range word {\n        if\
    \ last_char_is_consonant && vowels_map[string(v)] {\n            result = string(v)\n\
    \            break\n        }\n        if consonants_map[string(v)] {\n      \
    \      last_char_is_consonant = true\n        } else {\n            last_char_is_consonant\
    \ = false\n        }\n        last_char = string(v)\n    }\n    return result\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj5h3q7rr_test.go:34:9: last_char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var last_vowel string\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            last_vowel = string(word[i])\n            break\n        }\n\
    \    }\n    if last_vowel == \"\" {\n        return \"\"\n    }\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            continue\n        }\n        if strings.Contains(vowels, string(word[i-1]))\
    \ {\n            return string(word[i-1])\n        }\n    }\n    return last_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsypyx_z3_test.go:26:12: undefined: strings

    /tmp/tmpsypyx_z3_test.go:35:12: undefined: strings

    /tmp/tmpsypyx_z3_test.go:38:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    for _, v := range vowels {\n                        if\
    \ v == string(word[i]) {\n                            return v\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncbb6j_k_test.go:25:12: undefined: is_vowel

    /tmp/tmpncbb6j_k_test.go:27:20: undefined: is_vowel

    /tmp/tmpncbb6j_k_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074447
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if i == 0 {\n            return \"\"\n        }\n   \
    \     if vowels[i] != 0 {\n            if vowels[i-1] != 0 {\n               \
    \ return string(vowels[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp8wir6ljt_test.go:62: expected 'u', got 'A'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp8wir6ljt_test.go:62: expected\
    \ 'u', got 'o'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmp8wir6ljt_test.go:62: expected '', got 'o'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmp8wir6ljt_test.go:62: expected '', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp8wir6ljt_test.go:62: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp8wir6ljt_test.go:62: expected 'a', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp8wir6ljt_test.go:62: expected '', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp8wir6ljt_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp8wir6ljt_test.go:62: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp8wir6ljt_test.go:62: expected 'i', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp8wir6ljt_test.go:62:\
    \ expected '', got 'o'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp8wir6ljt_test.go:62: expected 'o', got 'u'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074448
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpxhylecop_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpxhylecop_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpxhylecop_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpxhylecop_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpxhylecop_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpxhylecop_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var closest_vowel string\n    var closest_vowel_index int\n    var closest_vowel_distance\
    \ int\n    var word_length int = len(word)\n    var word_index int\n    var vowel_index\
    \ int\n    var vowel_distance int\n    var vowel_found bool\n    var vowel_found_before\
    \ bool\n    var vowel_found_after bool\n    var vowel_found_before_index int\n\
    \    var vowel_found_after_index int\n    var vowel_found_before_distance int\n\
    \    var vowel_found_after_distance int\n    for word_index = 0; word_index <\
    \ word_length; word_index++ {\n        for vowel_index = 0; vowel_index < len(vowels);\
    \ vowel_index++ {\n            if string(word[word_index]) == vowels[vowel_index]\
    \ {\n                vowel_found = true\n                break\n            }\n\
    \        }\n        if vowel_found {\n            vowel_found = false\n      \
    \      vowel_found_before = false\n            vowel_found_after = false\n   \
    \         vowel_found_before_index = word_index - 1\n            vowel_found_after_index\
    \ = word_index + 1\n            vowel_found_before_distance = word_index\n   \
    \         vowel_found_after_distance = word_length - word_index\n            for\
    \ vowel_found_before_index >= 0 {\n                for vowel_index = 0; vowel_index\
    \ < len(vowels); vowel_index++ {\n                    if string(word[vowel_found_before_index])\
    \ == vowels[vowel_index] {\n                        vowel_found_before = true\n\
    \                        break\n                    }\n                }\n   \
    \             if vowel_found_before {\n                    break\n           \
    \     }\n                vowel_found_before_index--\n                vowel_found_before_distance--\n\
    \            }\n            for vowel_found_after_index < word_length {\n    \
    \            for vowel_index = 0; vowel_index < len(vowels); vowel_index++ {\n\
    \                    if string(word[vowel_found_after_index]) == vowels[\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyjtmu7tp_test.go:69:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var i int\n    var j int\n    var k int\n    var l int\n    var m\
    \ int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n\
    \    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n \
    \   var x int\n    var y int\n    var z int\n    var index int\n    var closest_vowel\
    \ string\n    var closest_vowel_index int\n    var closest_consonant string\n\
    \    var closest_consonant_index int\n    var closest_vowel_found bool\n    var\
    \ closest_consonant_found bool\n    var closest_vowel_distance int\n    var closest_consonant_distance\
    \ int\n    var closest_vowel_distance_found bool\n    var closest_consonant_distance_found\
    \ bool\n    var distance int\n    var distance_found bool\n    var distance_index\
    \ int\n    var distance_index_found bool\n    var distance_index_list []int\n\
    \    var distance_list []int\n    var distance_list_found bool\n    var distance_list_index\
    \ int\n    var distance_list_index_found bool\n    var distance_list_index_list\
    \ []int\n    var distance_list_index_list_found bool\n    var distance_list_index_list_index\
    \ int\n    var distance_list_index_list_index_found bool\n    var distance_list_index_list_index_list\
    \ []int\n    var distance_list_index_list_index_list_found bool\n    var distance_list_index_list_index_list_index\
    \ int\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo2cc_a0d_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074446
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var result string\n    var prev_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n       \
    \     prev_vowel = string(word[i])\n            continue\n        }\n        if\
    \ prev_vowel != \"\" {\n            result = prev_vowel\n            break\n \
    \       }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpvhzq23pr_test.go:70: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpvhzq23pr_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpvhzq23pr_test.go:70: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpvhzq23pr_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpvhzq23pr_test.go:70:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvhzq23pr_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result string\n    var last_vowel_index int\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i]\
    \ == v[0] {\n                last_vowel_index = i\n                break\n   \
    \         }\n        }\n        if last_vowel_index != 0 {\n            break\n\
    \        }\n    }\n    if last_vowel_index == 0 {\n        return result\n   \
    \ }\n    for i := last_vowel_index; i >= 0; i-- {\n        for _, v := range vowels\
    \ {\n            if word[i] == v[0] {\n                result = string(word[i])\n\
    \                break\n            }\n        }\n        if result != \"\" {\n\
    \            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpt2ntju00_test.go:79: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpt2ntju00_test.go:79: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpt2ntju00_test.go:79: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpt2ntju00_test.go:79: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpt2ntju00_test.go:79:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpt2ntju00_test.go:79: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpt2ntju00_test.go:79: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                if i == len(word) - 1 {\n \
    \                   return \"\"\n                }\n                for j := i\
    \ + 1; j < len(word); j++ {\n                    for _, v := range vowels {\n\
    \                        if word[j] == v[0] {\n                            return\
    \ \"\"\n                        }\n                    }\n                   \
    \ return string(word[i])\n                }\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp8fu7idfj_test.go:69: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp8fu7idfj_test.go:69: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp8fu7idfj_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp8fu7idfj_test.go:69: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp8fu7idfj_test.go:69:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp8fu7idfj_test.go:69: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowels_map := make(map[string]bool)\n    for _, v := range vowels {\n   \
    \     vowels_map[v] = true\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if vowels_map[string(word[i])] {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpyqd497_9_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpyqd497_9_test.go:61: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpyqd497_9_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpyqd497_9_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpyqd497_9_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpyqd497_9_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpyqd497_9_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpyqd497_9_test.go:61:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpyqd497_9_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var index int\n    var found\
    \ bool\n    for i := len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(consonants);\
    \ j++ {\n            if word[i] == consonants[j][0] {\n                for k :=\
    \ 0; k < len(vowels); k++ {\n                    if word[i-1] == vowels[k][0]\
    \ {\n                        result = string(word[i-1])\n                    \
    \    index = i-1\n                        found = true\n                     \
    \   break\n                    }\n                }\n                if found\
    \ {\n                    break\n                }\n            }\n        }\n\
    \        if found {\n            break\n        }\n    }\n    if found {\n   \
    \     for i := index-1; i >= 0; i-- {\n            for j := 0; j < len(consonants);\
    \ j++ {\n                if word[i] == consonants[j][0] {\n                  \
    \  return result\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel({0x51e265, 0x2})\n\t/tmp/tmpjul7ioc2_test.go:32\
    \ +0x271\ncommand-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmpjul7ioc2_test.go:75\
    \ +0x19e\ntesting.tRunner(0xc0000cc340, 0x528fb0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp588r7pw3_test.go:25:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074335
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var prev_char string\n \
    \   var prev_char_is_vowel bool\n    var prev_char_is_consonant bool\n    var\
    \ prev_char_is_empty bool\n    var curr_char string\n    var curr_char_is_vowel\
    \ bool\n    var curr_char_is_consonant bool\n    var curr_char_is_empty bool\n\
    \    var next_char string\n    var next_char_is_vowel bool\n    var next_char_is_consonant\
    \ bool\n    var next_char_is_empty bool\n    var i int\n    var j int\n    var\
    \ k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p\
    \ int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n\
    \    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n \
    \   var a int\n    var e int\n    var i_ int\n    var o_ int\n    var u_ int\n\
    \    var b int\n    var c int\n    var d int\n    var f int\n    var g int\n \
    \   var h int\n    var j_ int\n    var k_ int\n    var l_ int\n    var m_ int\n\
    \    var n_ int\n    var p_ int\n    var q_ int\n    var r_ int\n    var s_ int\n\
    \    var t_ int\n    var v_ int\n    var w_ int\n    var x_ int\n    var y_ int\n\
    \    var z_ int\n    var prev_char_is_vowel_ bool\n    var prev_char_is_consonant_\
    \ bool\n    var prev_char_is_empty_\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzsixxu__test.go:84:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074448
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            closest_vowel =\
    \ string(word[i])\n            break\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplqejmvqt_test.go:65: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplqejmvqt_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmplqejmvqt_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmplqejmvqt_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmplqejmvqt_test.go:65:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmplqejmvqt_test.go:65: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            closest_vowel =\
    \ string(word[i])\n            break\n        }\n    }\n    if closest_vowel ==\
    \ \"\" {\n        return closest_vowel\n    }\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            continue\n     \
    \   }\n        if closest_vowel == string(word[i]) {\n            return \"\"\n\
    \        }\n        return closest_vowel\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpjuf480ei_test.go:77: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpjuf480ei_test.go:77: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpjuf480ei_test.go:77: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpjuf480ei_test.go:77: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpjuf480ei_test.go:77: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpjuf480ei_test.go:77: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpjuf480ei_test.go:77: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpjuf480ei_test.go:77:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpjuf480ei_test.go:77: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var last_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n       \
    \     last_vowel = string(word[i])\n            break\n        }\n    }\n    if\
    \ last_vowel == \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if !vowels[string(word[i])] {\n            return last_vowel\n\
    \        }\n        last_vowel = string(word[i])\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp14bzcxaa_test.go:68: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp14bzcxaa_test.go:68: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp14bzcxaa_test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp14bzcxaa_test.go:68: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp14bzcxaa_test.go:68: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp14bzcxaa_test.go:68: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp14bzcxaa_test.go:68: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp14bzcxaa_test.go:68:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp14bzcxaa_test.go:68: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074333
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            closest_vowel =\
    \ string(word[i])\n            break\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplqejmvqt_test.go:65: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplqejmvqt_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmplqejmvqt_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmplqejmvqt_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmplqejmvqt_test.go:65:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmplqejmvqt_test.go:65: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if is_vowel(word[i + 1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8fcjl2a_test.go:25:12: undefined: is_vowel

    /tmp/tmpi8fcjl2a_test.go:29:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result string\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ is_vowel(word[i]) {\n            result = string(word[i])\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxfdrpyg2_test.go:23:5: vowels declared but not used

    /tmp/tmpxfdrpyg2_test.go:26:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] !=\
    \ 0 {\n            if i == len(word) - 1 {\n                return \"\"\n    \
    \        }\n            if vowels[strings.Index(vowels, string(word[i + 1]))]\
    \ == 0 {\n                return string(word[i])\n            }\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvt3zd5w__test.go:25:19: undefined: strings

    /tmp/tmpvt3zd5w__test.go:29:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var vowel_index int\n  \
    \  var consonant_index int\n    var vowel_found bool\n    var consonant_found\
    \ bool\n    var vowel_found_index int\n    var consonant_found_index int\n   \
    \ var distance int\n    var min_distance int\n    var min_distance_index int\n\
    \    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n \
    \   var n int\n    var o int\n    var p int\n    var q int\n    var r int\n  \
    \  var s int\n    var t int\n    var u int\n    var v int\n    var w int\n   \
    \ var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var\
    \ c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h\
    \ int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n\
    \    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n \
    \   var s int\n    var t int\n    var u int\n    var v int\n    var w int\n  \
    \  var x int\n    var y int\n    var z int\n    var a int\n    var b int\n   \
    \ var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var\
    \ h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m\
    \ int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n\
    \    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n \
    \   var x int\n    var\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpws1fjcxb_test.go:104:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074448
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != \"\"\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if vowels[strings.Index(vowels, string(word[i+1]))] == \"\
    \" {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcxopjhkj_test.go:25:19: undefined: strings

    /tmp/tmpcxopjhkj_test.go:25:62: invalid operation: vowels[strings.Index(vowels,
    string(word[i]))] != "" (mismatched types byte and untyped string)

    /tmp/tmpcxopjhkj_test.go:29:23: undefined: strings

    /tmp/tmpcxopjhkj_test.go:29:68: invalid operation: vowels[strings.Index(vowels,
    string(word[i + 1]))] == "" (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp588r7pw3_test.go:25:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074335
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            closest_vowel =\
    \ string(word[i])\n            break\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplqejmvqt_test.go:65: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplqejmvqt_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmplqejmvqt_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmplqejmvqt_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmplqejmvqt_test.go:65: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmplqejmvqt_test.go:65:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmplqejmvqt_test.go:65: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if i == 0 {\n            return \"\"\n        }\n   \
    \     if vowels[strings.Index(vowels, string(word[i]))] != 0 {\n            if\
    \ vowels[strings.Index(vowels, string(word[i-1]))] == 0 {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsgyal7wc_test.go:28:19: undefined: strings

    /tmp/tmpsgyal7wc_test.go:29:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_a1got_x_test.go:25:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3zayxwnr_test.go:25:12: undefined: is_vowel

    /tmp/tmp3zayxwnr_test.go:29:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_a1got_x_test.go:25:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074444
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\n        \"a\": 1,\n       \
    \ \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n       \
    \ \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n       \
    \ \"U\": 1,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok\
    \ := vowels[string(word[i])]; ok {\n            if i + 1 < len(word) && _, ok\
    \ := vowels[string(word[i + 1])]; !ok {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsb6h0w4h_test.go:37:16: expected identifier on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074448
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtscxlpe_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO: Implement me\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvzj_wcje_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvzj_wcje_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvzj_wcje_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvzj_wcje_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvzj_wcje_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvzj_wcje_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_consonant_index\
    \ int\n    var last_vowel_index int\n    var last_vowel string\n    var last_consonant\
    \ string\n    var word_length int = len(word)\n    var i int\n    var j int\n\
    \    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n \
    \   var p int\n    var q int\n    var r int\n    var s int\n    var t int\n  \
    \  var u int\n    var v int\n    var w int\n    var x int\n    var y int\n   \
    \ var z int\n    var a int\n    var e int\n    var i_ int\n    var o_ int\n  \
    \  var u_ int\n    var b int\n    var c int\n    var d int\n    var f int\n  \
    \  var g int\n    var h int\n    var j_ int\n    var k_ int\n    var l_ int\n\
    \    var m_ int\n    var n_ int\n    var p_ int\n    var q_ int\n    var r_ int\n\
    \    var s_ int\n    var t_ int\n    var v_ int\n    var w_ int\n    var x_ int\n\
    \    var y_ int\n    var z_ int\n    for i = 0; i < word_length; i++ {\n     \
    \   for j = 0; j < len(vowels); j++ {\n            if string(word[i]) == vowels[j]\
    \ {\n                last_vowel_index = i\n                last_vowel = vowels[j]\n\
    \            }\n        }\n        for k = 0; k < len(consonants); k++ {\n   \
    \         if string(word[i]) == consonants[k] {\n                last_consonant_index\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiqdcg7ip_test.go:85:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            for j := i - 1; j >= 0; j-- {\n                if contains(vowels,\
    \ string(word[j])) {\n                    break\n                }\n         \
    \       if j == 0 {\n                    return string(word[i])\n            \
    \    }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4cf85p44_test.go:25:12: undefined: contains

    /tmp/tmp4cf85p44_test.go:27:20: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                if i == len(word) - 1 {\n \
    \                   return \"\"\n                }\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpxr674spp_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpxr674spp_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpxr674spp_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpxr674spp_test.go:62: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpxr674spp_test.go:62:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpxr674spp_test.go:62: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var result string\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            result = string(word[i])\n            break\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprgg1htzx_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i+1])]\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpj_xn_4hu_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpj_xn_4hu_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpj_xn_4hu_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpj_xn_4hu_test.go:62: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpj_xn_4hu_test.go:62:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpj_xn_4hu_test.go:62: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = \"aeiou\"\n    var closest_vowel string\n\
    \    var closest_vowel_index int\n    var closest_vowel_distance int\n    var\
    \ word_length int = len(word)\n    var i int\n    var j int\n    var vowel_index\
    \ int\n    var vowel_distance int\n    var vowel_found bool\n    for i = word_length\
    \ - 1; i > 0; i-- {\n        if vowels.Index(word[i]) == -1 {\n            for\
    \ j = i - 1; j >= 0; j-- {\n                if vowels.Index(word[j]) != -1 {\n\
    \                    vowel_index = j\n                    vowel_distance = i -\
    \ j\n                    vowel_found = true\n                    break\n     \
    \           }\n            }\n            if vowel_found {\n                if\
    \ closest_vowel_distance == 0 || vowel_distance < closest_vowel_distance {\n \
    \                   closest_vowel_distance = vowel_distance\n                \
    \    closest_vowel_index = vowel_index\n                }\n            }\n   \
    \     }\n    }\n    if closest_vowel_index != 0 {\n        closest_vowel = string(word[closest_vowel_index])\n\
    \    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimn4pikd_test.go:34:19: vowels.Index undefined (type string has no field
    or method Index)

    /tmp/tmpimn4pikd_test.go:36:27: vowels.Index undefined (type string has no field
    or method Index)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpxhylecop_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpxhylecop_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpxhylecop_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpxhylecop_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpxhylecop_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpxhylecop_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var result string\n    var last_vowel_index int\n    for\
    \ i, c := range word {\n        if vowels[string(c)] {\n            last_vowel_index\
    \ = i\n        }\n    }\n    for i := last_vowel_index; i >= 0; i-- {\n      \
    \  if vowels[string(word[i])] {\n            result = string(word[i])\n      \
    \      break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpmrsx4r1b_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpmrsx4r1b_test.go:71: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpmrsx4r1b_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpmrsx4r1b_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpmrsx4r1b_test.go:71: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpmrsx4r1b_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpmrsx4r1b_test.go:71: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpmrsx4r1b_test.go:71:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpmrsx4r1b_test.go:71: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] ==\
    \ v[0] {\n                if i == len(word) - 1 {\n                    return\
    \ \"\"\n                }\n                if i == 0 {\n                    return\
    \ \"\"\n                }\n                if word[i-1] == ' ' {\n           \
    \         return \"\"\n                }\n                if word[i+1] == ' '\
    \ {\n                    return \"\"\n                }\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpth0w19or_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpth0w19or_test.go:74: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmpth0w19or_test.go:74: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpth0w19or_test.go:74: expected 'o', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var prev_char string\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            if prev_char\
    \ != \"\" && !vowels[prev_char] {\n                return string(word[i])\n  \
    \          }\n        }\n        prev_char = string(word[i])\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsbrxcmo5_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsbrxcmo5_test.go:61: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsbrxcmo5_test.go:61: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsbrxcmo5_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpsbrxcmo5_test.go:61: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[i] == word[i] {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpxku1igim_test.go:57: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpxku1igim_test.go:57: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpxku1igim_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpxku1igim_test.go:57: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpxku1igim_test.go:57: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpxku1igim_test.go:57: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpxku1igim_test.go:57: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpxku1igim_test.go:57:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpxku1igim_test.go:57: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074333
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    break\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhqcvplc_test.go:23:5: vowels declared but not used

    /tmp/tmpjhqcvplc_test.go:25:12: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:27:20: undefined: is_vowel

    /tmp/tmpjhqcvplc_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result string\n    var distance int\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if stringInSlice(string(word[i]), vowels) {\n            for\
    \ j := i - 1; j >= 0; j-- {\n                if stringInSlice(string(word[j]),\
    \ vowels) {\n                    break\n                }\n                if\
    \ j == 0 {\n                    if distance == 0 || distance > i {\n         \
    \               distance = i\n                        result = string(word[i])\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdcajk2l_test.go:27:12: undefined: stringInSlice

    /tmp/tmphdcajk2l_test.go:29:20: undefined: stringInSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return \"\"\n                }\n                if is_consonant(word[j])\
    \ {\n                    return string(word[i])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35ws7u3q_test.go:23:5: vowels declared but not used

    /tmp/tmp35ws7u3q_test.go:25:12: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:27:20: undefined: is_vowel

    /tmp/tmp35ws7u3q_test.go:30:20: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    word_len := len(word)\n    for i := word_len - 1; i > 0; i-- {\n        if\
    \ !is_vowel(word[i]) && is_vowel(word[i-1]) {\n            return string(word[i-1])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb9lk35a_test.go:23:5: vowels declared but not used

    /tmp/tmpxb9lk35a_test.go:26:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpxhylecop_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpxhylecop_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpxhylecop_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpxhylecop_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpxhylecop_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpxhylecop_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpxhylecop_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if is_vowel(word[i + 1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8fcjl2a_test.go:25:12: undefined: is_vowel

    /tmp/tmpi8fcjl2a_test.go:29:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var found bool\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v[0]\
    \ {\n                result = string(word[i])\n                found = true\n\
    \                break\n            }\n        }\n        if found {\n       \
    \     break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpa9o5xhit_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpa9o5xhit_test.go:66: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpa9o5xhit_test.go:66: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpa9o5xhit_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpa9o5xhit_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpa9o5xhit_test.go:66: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpa9o5xhit_test.go:66: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpa9o5xhit_test.go:66:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpa9o5xhit_test.go:66: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074449
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3zayxwnr_test.go:25:12: undefined: is_vowel

    /tmp/tmp3zayxwnr_test.go:29:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074329
