language: go_test.go
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // Write your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpze3lygfs_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpze3lygfs_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpze3lygfs_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpze3lygfs_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    if capacity == 1 {\n    \
    \    count := 0\n        for _, row := range grid {\n            for _, cell :=\
    \ range row {\n                if cell == 1 {\n                    count++\n \
    \               }\n            }\n        }\n        return count\n    }\n   \
    \ // find max row\n    max_row := 0\n    max_row_count := 0\n    for _, row :=\
    \ range grid {\n        count := 0\n        for _, cell := range row {\n     \
    \       if cell == 1 {\n                count++\n            }\n        }\n  \
    \      if count > max_row_count {\n            max_row_count = count\n       \
    \     max_row = len(grid) - 1\n        }\n    }\n    // find max col\n    max_col\
    \ := 0\n    max_col_count := 0\n    for col := 0; col < len(grid[0]); col++ {\n\
    \        count := 0\n        for row := 0; row < len(grid); row++ {\n        \
    \    if grid[row][col] == 1 {\n                count++\n            }\n      \
    \  }\n        if count > max_col_count {\n            max_col_count = count\n\
    \            max_col = len(grid[0]) - 1\n        }\n    }\n    // fill max row\n\
    \    for col := 0; col < len(grid[0]); col++ {\n        if grid[max_row][col]\
    \ == 1 {\n            grid[max_row][col] = 0\n            capacity--\n       \
    \ }\n        if capacity == 0 {\n            break\n        }\n    }\n    // fill\
    \ max col\n    for row := 0; row < len(grid); row++ {\n        if grid[row][max_col]\
    \ == 1 {\n            grid[row][max_col] = 0\n            capacity--\n       \
    \ }\n        if capacity == 0 {\n            break\n        }\n    }\n    // fill\
    \ remaining\n    for row := 0; row < len(grid); row++ {\n        for col := 0;\
    \ col < len(grid[\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpag2aikjd_test.go:103:6: expected ''('', found TestMax_Fill

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    if capacity > len(grid[0])\
    \ {\n        capacity = len(grid[0])\n    }\n    var count int\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 1 {\n                count++\n            }\n        }\n\
    \    }\n    return count / capacity\n}\n\nfunc TestMax_Fill(t *testing.T) {\n\
    \  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__1\
    \ (0.00s)\n        tmpmljh7wc6_test.go:70: expected '%!s(int=5)', got '%!s(int=4)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    // fill the first row\n \
    \   var count int\n    for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i]\
    \ == 1 {\n            count++\n        }\n    }\n    // fill the rest of the rows\n\
    \    for i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                if grid[i-1][j] == 0 {\n\
    \                    count++\n                }\n            }\n        }\n  \
    \  }\n    return count * capacity\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate\
    \ := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0},\
    \ []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp5j49zl3y_test.go:76: expected '%!s(int=6)', got '%!s(int=5)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp5j49zl3y_test.go:76:\
    \ expected '%!s(int=5)', got '%!s(int=12)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp5j49zl3y_test.go:76: expected '%!s(int=4)', got '%!s(int=8)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp5j49zl3y_test.go:76:\
    \ expected '%!s(int=2)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // Your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement the solution\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // Your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement the solution\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    var count int\n    for i\
    \ := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n  \
    \          if grid[i][j] == 1 {\n                count++\n            }\n    \
    \    }\n    }\n    return count\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate\
    \ := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0},\
    \ []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__1\
    \ (0.00s)\n        tmp6c9vt4n1_test.go:58: expected '%!s(int=5)', got '%!s(int=9)'\n\
    \    --- FAIL: TestMax_Fill/test_num__3 (0.00s)\n        tmp6c9vt4n1_test.go:58:\
    \ expected '%!s(int=4)', got '%!s(int=8)'\n    --- FAIL: TestMax_Fill/test_num__4\
    \ (0.00s)\n        tmp6c9vt4n1_test.go:58: expected '%!s(int=2)', got '%!s(int=8)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 2
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    // create a new grid\n  \
    \  new_grid := make([][]int, len(grid))\n    for i := 0; i < len(grid); i++ {\n\
    \        new_grid[i] = make([]int, len(grid[i]))\n    }\n    // fill the new grid\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                new_grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // fill the wells\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if new_grid[i][j]\
    \ == 0 {\n                fill_well(new_grid, i, j, capacity)\n            }\n\
    \        }\n    }\n    // count the number of times we filled the wells\n    count\
    \ := 0\n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]);\
    \ j++ {\n            if new_grid[i][j] > 0 {\n                count += new_grid[i][j]\n\
    \            }\n        }\n    }\n    return count\n}\n\nfunc TestMax_Fill(t *testing.T)\
    \ {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps2kbnw4w_test.go:56:17: undefined: fill_well

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement this function\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpe9ykz8wo_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpe9ykz8wo_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpe9ykz8wo_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpe9ykz8wo_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement the solution\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // Your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    // Initialize the grid\n\
    \    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = capacity\n\
    \            }\n        }\n    }\n    // Fill the grid\n    for i := 0; i < len(grid);\
    \ i++ {\n        for j := 0; j < len(grid[i]); j++ {\n            if grid[i][j]\
    \ > 0 {\n                // Fill the current cell\n                grid[i][j]\
    \ -= 1\n                // Fill the cell above\n                if i > 0 {\n \
    \                   if grid[i-1][j] > 0 {\n                        grid[i-1][j]\
    \ -= 1\n                    }\n                }\n                // Fill the\
    \ cell below\n                if i < len(grid)-1 {\n                    if grid[i+1][j]\
    \ > 0 {\n                        grid[i+1][j] -= 1\n                    }\n  \
    \              }\n                // Fill the cell to the left\n             \
    \   if j > 0 {\n                    if grid[i][j-1] > 0 {\n                  \
    \      grid[i][j-1] -= 1\n                    }\n                }\n         \
    \       // Fill the cell to the right\n                if j < len(grid[i])-1 {\n\
    \                    if grid[i][j+1] > 0 {\n                        grid[i][j+1]\
    \ -= 1\n                    }\n                }\n            }\n        }\n \
    \   }\n    // Count the number of filled cells\n    count := 0\n    for i := 0;\
    \ i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n        \
    \    if grid[i][j] == 0 {\n                count += 1\n            }\n       \
    \ }\n    }\n    return count\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate\
    \ := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0},\
    \ []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpp2okza1w_test.go:109: expected '%!s(int=6)', got '%!s(int=12)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpp2okza1w_test.go:109:\
    \ expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestMax_Fill/test_num__2\
    \ (0.00s)\n        tmpp2okza1w_test.go:109: expected '%!s(int=0)', got '%!s(int=6)'\n\
    \    --- FAIL: TestMax_Fill/test_num__3 (0.00s)\n        tmpp2okza1w_test.go:109:\
    \ expected '%!s(int=4)', got '%!s(int=8)'\n    --- FAIL: TestMax_Fill/test_num__4\
    \ (0.00s)\n        tmpp2okza1w_test.go:109: expected '%!s(int=2)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073240
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me!\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpd61i38eb_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpd61i38eb_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpd61i38eb_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpd61i38eb_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
