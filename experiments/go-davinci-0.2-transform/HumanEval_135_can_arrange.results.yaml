language: go_test.go
name: HumanEval_135_can_arrange
results:
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[max_index] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpe8fs9ce9_test.go:60: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpe8fs9ce9_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpe8fs9ce9_test.go:60: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpe8fs9ce9_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] >= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    maxIndex := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           maxIndex = i\n        }\n    }\n    if maxIndex == 0 {\n        return\
    \ -1\n    }\n    for i := maxIndex - 1; i >= 0; i-- {\n        if arr[i] <= max\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpkwwoab_9_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpkwwoab_9_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpkwwoab_9_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] >= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[max_index] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpe8fs9ce9_test.go:60: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpe8fs9ce9_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpe8fs9ce9_test.go:60: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpe8fs9ce9_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    var result int = -1\n    for i := 1; i < len(arr); i++ {\n        if\
    \ arr[i] <= arr[i-1] {\n            result = i-1\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpqr1yfpe6_test.go:44: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpqr1yfpe6_test.go:44:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpqr1yfpe6_test.go:44: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_idx\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n     \
    \       max = arr[i]\n            max_idx = i\n        }\n    }\n    for i :=\
    \ 0; i < max_idx; i++ {\n        if arr[i] > arr[i+1] {\n            return -1\n\
    \        }\n    }\n    return max_idx\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpa0wym44t_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpa0wym44t_test.go:54:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpa0wym44t_test.go:54: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpa0wym44t_test.go:54:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n            max_index = i\n        }\n    }\n \
    \   if max_index == 0 {\n        return -1\n    }\n    for i := max_index - 1;\
    \ i >= 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return -1\n   \
    \     }\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpi44wk6l7_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpi44wk6l7_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpi44wk6l7_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpi44wk6l7_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] <= arr[i -\
    \ 1] {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] <= arr[i -\
    \ 1] {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    max := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] >=\
    \ arr[i-1] {\n            if i > max {\n                max = i\n            }\n\
    \        }\n    }\n    if max == 0 {\n        return -1\n    }\n    return max\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmph794l6ae_test.go:62: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmph794l6ae_test.go:62:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmph794l6ae_test.go:62: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmph794l6ae_test.go:62:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < max\
    \ {\n            return max_index\n        }\n        if arr[i] > max {\n    \
    \        max = arr[i]\n            max_index = i\n        }\n    }\n    return\
    \ -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz0yqzzjz_test.go:52: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz0yqzzjz_test.go:52:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz0yqzzjz_test.go:52: expected '%!s(int=4)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max_index := 0\n    for i := 1; i < len(arr); i++\
    \ {\n        if arr[i] <= arr[max_index] {\n            max_index = i\n      \
    \  }\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpzxm2wzm8_test.go:50: expected '%!s(int=3)', got '%!s(int=0)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpzxm2wzm8_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpzxm2wzm8_test.go:50: expected '%!s(int=2)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_index\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n     \
    \       max = arr[i]\n            max_index = i\n        }\n    }\n    if max_index\
    \ == 0 {\n        return -1\n    }\n    for i := 0; i < max_index; i++ {\n   \
    \     if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n\
    \    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp_f7wus9g_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp_f7wus9g_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp_f7wus9g_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_f7wus9g_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] >= arr[i -\
    \ 1] {\n            continue\n        } else {\n            return i\n       \
    \ }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] >= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    max := -1\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i]\
    \ >= max {\n            max = arr[i]\n        } else {\n            return i\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpv53h4eqg_test.go:46: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpv53h4eqg_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpv53h4eqg_test.go:46: expected '%!s(int=4)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i, v := range arr {\n        if v > max {\n        \
    \    max = v\n            max_index = i\n        }\n    }\n    for i := max_index\
    \ - 1; i >= 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp0refhibe_test.go:54: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp0refhibe_test.go:54:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmp0refhibe_test.go:54: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    var max int\n    for i := len(arr) - 1; i >= 0;\
    \ i-- {\n        if arr[i] >= max {\n            max = arr[i]\n        } else\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmp92wynlzm_test.go:52: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp92wynlzm_test.go:52:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmp92wynlzm_test.go:52: expected '%!s(int=4)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ maxIndex := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n            maxIndex = i\n        }\n    }\n  \
    \  if maxIndex == 0 {\n        return -1\n    }\n    for i := maxIndex - 1; i\
    \ >= 0; i-- {\n        if arr[i] <= arr[i + 1] {\n            return i\n     \
    \   }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpafim14j0_test.go:57: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpafim14j0_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpafim14j0_test.go:57: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpht41h5y4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_idx := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] <= max\
    \ {\n            max = arr[i]\n            max_idx = i\n        }\n    }\n   \
    \ return max_idx\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp68m3_kje_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp68m3_kje_test.go:49:\
    \ expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp68m3_kje_test.go:49: expected '%!s(int=2)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpht41h5y4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    maxIndex := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           maxIndex = i\n        }\n    }\n    if maxIndex == 0 {\n        return\
    \ -1\n    }\n    for i := 0; i < maxIndex; i++ {\n        if arr[i] > arr[maxIndex]\
    \ {\n            return -1\n        }\n    }\n    return maxIndex\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpa2ujccew_test.go:60: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpa2ujccew_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpa2ujccew_test.go:60: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpa2ujccew_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i, v := range arr {\n        if v > max {\n        \
    \    max = v\n            max_index = i\n        }\n    }\n    if max_index ==\
    \ 0 {\n        return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n \
    \       if arr[i] <= max {\n            return i\n        }\n    }\n    return\
    \ -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsror6dsr_test.go:57: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsror6dsr_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsror6dsr_test.go:57: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := 0; i < max_index; i++\
    \ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n\
    \    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpv5zjf97x_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpv5zjf97x_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpv5zjf97x_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpv5zjf97x_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    // TODO: Implement this function\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpd82w6xso_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpd82w6xso_test.go:39:\
    \ expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpd82w6xso_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] >= arr[1]\
    \ {\n            return -1\n        }\n        return 1\n    }\n    max := arr[0]\n\
    \    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] >\
    \ max {\n            max = arr[i]\n            max_index = i\n        }\n    }\n\
    \    if max_index == 0 {\n        return -1\n    }\n    for i := max_index - 1;\
    \ i >= 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return -1\n   \
    \     }\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpydslvm_a_test.go:66: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpydslvm_a_test.go:66:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpydslvm_a_test.go:66: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpydslvm_a_test.go:66:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    maxIndex := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           maxIndex = i\n        }\n    }\n    for i := maxIndex - 1; i >= 0;\
    \ i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n \
    \   }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate :=\
    \ can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpp8gnzah7_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpp8gnzah7_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpp8gnzah7_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] >= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp98j52xt7_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp98j52xt7_test.go:49:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp98j52xt7_test.go:49: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp98j52xt7_test.go:49:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := 0; i < max_index; i++\
    \ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n\
    \    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpv5zjf97x_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpv5zjf97x_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpv5zjf97x_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpv5zjf97x_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := 0\n    for i := 1; i < len(arr); i++ {\n\
    \        if arr[i] <= arr[i-1] {\n            if i > max {\n                max\
    \ = i\n            }\n        }\n    }\n    if max == 0 {\n        return -1\n\
    \    }\n    return max\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] >= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] >= arr[i -\
    \ 1] {\n            continue\n        } else {\n            return i\n       \
    \ }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n            max_index = i\n        }\n    }\n \
    \   if max_index == 0 {\n        return -1\n    }\n    for i := max_index - 1;\
    \ i >= 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return -1\n   \
    \     }\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpi44wk6l7_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpi44wk6l7_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpi44wk6l7_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpi44wk6l7_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] <= arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpr1r3zkgz_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpr1r3zkgz_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpr1r3zkgz_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpht41h5y4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpht41h5y4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    var max int\n    var max_index int\n    for i, v := range arr {\n   \
    \     if i == 0 {\n            max = v\n            max_index = i\n        } else\
    \ {\n            if v > max {\n                max = v\n                max_index\
    \ = i\n            }\n        }\n    }\n    if max_index == len(arr) - 1 {\n \
    \       return -1\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpv9dna47c_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpv9dna47c_test.go:54:\
    \ expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpv9dna47c_test.go:54: expected '%!s(int=4)', got '%!s(int=1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__4 (0.00s)\n        tmpv9dna47c_test.go:54:\
    \ expected '%!s(int=-1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] <= arr[i - 1] {\n            continue\n \
    \       }\n        return i\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp1ei7os2a_test.go:47: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp1ei7os2a_test.go:47:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp1ei7os2a_test.go:47: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp1ei7os2a_test.go:47:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpf5zhbn8i_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpf5zhbn8i_test.go:55:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpf5zhbn8i_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpf5zhbn8i_test.go:55:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_index\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n     \
    \       max = arr[i]\n            max_index = i\n        }\n    }\n    if max_index\
    \ == 0 {\n        return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n\
    \        if arr[i] > arr[i + 1] {\n            return -1\n        }\n    }\n \
    \   return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate :=\
    \ can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpcwimet62_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpcwimet62_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpcwimet62_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpcwimet62_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n            max_index = i\n        }\n    }\n \
    \   if max_index == 0 {\n        return -1\n    }\n    for i := 0; i < max_index;\
    \ i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n       \
    \ }\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp_kx2e57a_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp_kx2e57a_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp_kx2e57a_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_kx2e57a_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_idx := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           max_idx = i\n        }\n    }\n    for i := 0; i < max_idx; i++ {\n\
    \        if arr[i] > arr[i+1] {\n            return -1\n        }\n    }\n   \
    \ return max_idx\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp018t511f_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp018t511f_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp018t511f_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp018t511f_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max_index := 0\n   \
    \ for i := 1; i < len(arr); i++ {\n        if arr[i] <= arr[i-1] {\n         \
    \   continue\n        }\n        if arr[i] > arr[max_index] {\n            max_index\
    \ = i\n        }\n    }\n    if arr[max_index] <= arr[max_index-1] {\n       \
    \ return -1\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpt64hekvq_test.go:53: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpt64hekvq_test.go:53:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpt64hekvq_test.go:53: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpt64hekvq_test.go:53:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpsnt0ytjk_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsnt0ytjk_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsnt0ytjk_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    // Your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpa3er4ubc_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpa3er4ubc_test.go:39:\
    \ expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpa3er4ubc_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n\
    \            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz8jp20dy_test.go:43:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpz8jp20dy_test.go:43: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_index\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n     \
    \       max = arr[i]\n            max_index = i\n        }\n    }\n    if max_index\
    \ == 0 {\n        return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n\
    \        if arr[i] > arr[i + 1] {\n            return -1\n        }\n    }\n \
    \   return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate :=\
    \ can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpcwimet62_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpcwimet62_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpcwimet62_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpcwimet62_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_index\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n     \
    \       max = arr[i]\n            max_index = i\n        }\n    }\n    if max_index\
    \ == 0 {\n        return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n\
    \        if arr[i] > arr[i + 1] {\n            return -1\n        }\n    }\n \
    \   return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate :=\
    \ can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpcwimet62_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpcwimet62_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpcwimet62_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpcwimet62_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_index\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n     \
    \       max = arr[i]\n            max_index = i\n        }\n    }\n    for i :=\
    \ max_index - 1; i >= 0; i-- {\n        if arr[i] > arr[i + 1] {\n           \
    \ return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp2cmz9adl_test.go:54: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp2cmz9adl_test.go:54:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmp2cmz9adl_test.go:54: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpht41h5y4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    max := arr[0]\n   \
    \ max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n            max_index = i\n        }\n    }\n \
    \   if max_index == 0 {\n        return -1\n    }\n    for i := max_index - 1;\
    \ i >= 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return -1\n   \
    \     }\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpi44wk6l7_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpi44wk6l7_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpi44wk6l7_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpi44wk6l7_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_idx := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           max_idx = i\n        }\n    }\n    for i := 0; i < max_idx; i++ {\n\
    \        if arr[i] > arr[i+1] {\n            return -1\n        }\n    }\n   \
    \ return max_idx\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp018t511f_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp018t511f_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp018t511f_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp018t511f_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpf5zhbn8i_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpf5zhbn8i_test.go:55:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpf5zhbn8i_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpf5zhbn8i_test.go:55:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := -1\n    for i := len(arr) - 1; i > 0; i--\
    \ {\n        if arr[i] >= arr[i-1] {\n            if i > max {\n             \
    \   max = i\n            }\n        }\n    }\n    return max\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpm3dje2_0_test.go:52: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpm3dje2_0_test.go:52:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpm3dje2_0_test.go:52: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpm3dje2_0_test.go:52:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    var max int\n    for i := len(arr) - 1; i >= 0;\
    \ i-- {\n        if arr[i] >= max {\n            max = arr[i]\n        } else\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmp92wynlzm_test.go:52: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp92wynlzm_test.go:52:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmp92wynlzm_test.go:52: expected '%!s(int=4)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := 0\n    for i := 1; i < len(arr); i++ {\n\
    \        if arr[i] <= arr[i-1] {\n            continue\n        }\n        if\
    \ arr[i] > arr[max] {\n            max = i\n        }\n    }\n    if max == 0\
    \ {\n        return -1\n    }\n    return max\n}\n\nfunc TestCan_Arrange(t *testing.T)\
    \ {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmps_asjt5s_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmps_asjt5s_test.go:56:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmps_asjt5s_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmps_asjt5s_test.go:56:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_idx := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           max_idx = i\n        }\n    }\n    for i := 0; i < max_idx; i++ {\n\
    \        if arr[i] > arr[i+1] {\n            return -1\n        }\n    }\n   \
    \ return max_idx\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected:\
    \ 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp018t511f_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp018t511f_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp018t511f_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp018t511f_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] <= arr[i -\
    \ 1] {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] <= arr[i -\
    \ 1] {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max_index := 0\n    for i := 1; i < len(arr); i++\
    \ {\n        if arr[i] <= arr[i-1] {\n            continue\n        }\n      \
    \  if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n\
    \    if max_index == 0 {\n        return -1\n    }\n    return max_index\n}\n\n\
    func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpzztqwh9a_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpzztqwh9a_test.go:56:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpzztqwh9a_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpzztqwh9a_test.go:56:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] <= arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpr1r3zkgz_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpr1r3zkgz_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpr1r3zkgz_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            continue\n        }\n        return i\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpweuuhnhv_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpweuuhnhv_test.go:50:\
    \ expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] >= arr[i -\
    \ 1] {\n            continue\n        } else {\n            return i\n       \
    \ }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] <= arr[i -\
    \ 1] {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    max := arr[0]\n    max_index\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < max {\n     \
    \       return max_index\n        }\n        if arr[i] > max {\n            max\
    \ = arr[i]\n            max_index = i\n        }\n    }\n    return -1\n}\n\n\
    func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmplvl6ot3d_test.go:52: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplvl6ot3d_test.go:52:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmplvl6ot3d_test.go:52: expected '%!s(int=4)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ <= max {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsc7j_522_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsc7j_522_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    maxIndex := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           maxIndex = i\n        }\n    }\n    if maxIndex == 0 {\n        return\
    \ -1\n    }\n    for i := 0; i < maxIndex; i++ {\n        if arr[i] > arr[maxIndex]\
    \ {\n            return -1\n        }\n    }\n    return maxIndex\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpa2ujccew_test.go:60: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpa2ujccew_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpa2ujccew_test.go:60: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpa2ujccew_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    if max_index == 0 {\n      \
    \  return -1\n    }\n    for i := max_index - 1; i >= 0; i-- {\n        if arr[i]\
    \ > arr[i + 1] {\n            return -1\n        }\n    }\n    return max_index\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp05dlmuk8_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp05dlmuk8_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpsnt0ytjk_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsnt0ytjk_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsnt0ytjk_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_index := 0\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            max_index = i\n        }\n    }\n    for i := max_index - 1; i >=\
    \ 0; i-- {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n\
    \    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbe_95o33_test.go:57:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpbe_95o33_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpsnt0ytjk_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsnt0ytjk_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpsnt0ytjk_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    var max int\n    for i := len(arr) - 1; i >= 0;\
    \ i-- {\n        if arr[i] >= max {\n            max = arr[i]\n        } else\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmp92wynlzm_test.go:52: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp92wynlzm_test.go:52:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmp92wynlzm_test.go:52: expected '%!s(int=4)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    var max int = -1\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] >= arr[i - 1] {\n            max = i\n        }\n    }\n    return max\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmp58au1xyd_test.go:44: expected '%!s(int=3)', got '%!s(int=1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp58au1xyd_test.go:44:\
    \ expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmp58au1xyd_test.go:44: expected '%!s(int=2)', got '%!s(int=1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp58au1xyd_test.go:44:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] <= arr[1]\
    \ {\n            return 0\n        } else {\n            return -1\n        }\n\
    \    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            return i - 1\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t\
    \ *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1,\
    \ 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7,\
    \ 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}),\
    \ expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpht41h5y4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpht41h5y4_test.go:56: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    maxIndex := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           maxIndex = i\n        }\n    }\n    for i := 0; i < maxIndex; i++\
    \ {\n        if arr[i] > arr[maxIndex] {\n            return -1\n        }\n \
    \   }\n    return maxIndex\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate\
    \ := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpa3vxhoky_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpa3vxhoky_test.go:57:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpa3vxhoky_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpa3vxhoky_test.go:57:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    var max int\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i]\
    \ >= max {\n            max = arr[i]\n        } else {\n            return i\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1\
    \ (0.00s)\n        tmpl1ru72kk_test.go:46: expected '%!s(int=-1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpl1ru72kk_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpl1ru72kk_test.go:46: expected '%!s(int=4)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    max := arr[0]\n    max_idx := 0\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \           max_idx = i\n        }\n    }\n    if max_idx == 0 {\n        return\
    \ -1\n    }\n    for i := max_idx - 1; i >= 0; i-- {\n        if arr[i] > arr[i\
    \ + 1] {\n            return -1\n        }\n    }\n    return max_idx\n}\n\nfunc\
    \ TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual:\
    \ candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4,\
    \ 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpobnciqg5_test.go:60: expected '%!s(int=3)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpobnciqg5_test.go:60:\
    \ expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2\
    \ (0.00s)\n        tmpobnciqg5_test.go:60: expected '%!s(int=2)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpobnciqg5_test.go:60:\
    \ expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073249
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) < 2 {\n        return -1\n    }\n    for i := len(arr) -\
    \ 1; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n\
    \        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n\
    \  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected:\
    \ -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected:\
    \ 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     {\
    \ actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=3)', got '%!s(int=2)'\n\
    \    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpldx12nsm_test.go:46:\
    \ expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3\
    \ (0.00s)\n        tmpldx12nsm_test.go:46: expected '%!s(int=4)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073245
- exit_code: 0
  program: "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Create a function which returns the largest index of an element which\n//\
    \ is not greater than or equal to the element immediately preceding it. If\n//\
    \ no such element exists then return -1. The given array will not contain\n//\
    \ duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n\
    // 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int\
    \ {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n\
    \        return 0\n    }\n    for i := len(arr) - 1; i > 0; i-- {\n        if\
    \ arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n\
    \     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual:\
    \ candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual:\
    \ candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}),\
    \ expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073245
