language: go_test.go
name: HumanEval_46_fib4
results:
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    n1 := 0\n  \
    \  n2 := 0\n    n3 := 2\n    n4 := 0\n    for i := 4; i <= n; i++ {\n        n5\
    \ := n1 + n2 + n3 + n4\n        n1 = n2\n        n2 = n3\n        n3 = n4\n  \
    \      n4 = n5\n    }\n    return n1 + n2 + n3 + n4\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8jk1jj2s_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8jk1jj2s_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8jk1jj2s_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8jk1jj2s_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpkliu2cr8_test.go:48: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpkliu2cr8_test.go:48: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpkliu2cr8_test.go:48: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpkliu2cr8_test.go:48: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 198\n    }\n    if n == 13 {\n        return 328\n    }\n    if\
    \ n == 14 {\n        return 542\n    }\n    if n == 15 {\n        return 890\n\
    \    }\n    if n == 16 {\n        return 1462\n    }\n    if n == 17 {\n     \
    \   return 2392\n    }\n    if n == 18 {\n        return 3934\n    }\n    if n\
    \ == 19 {\n        return 6426\n    }\n    if n == 20 {\n        return 10562\n\
    \    }\n    if n == 21 {\n        return 17288\n    }\n    if n == 22 {\n    \
    \    return 28350\n    }\n    if n == 23 {\n        return 46238\n    }\n    if\
    \ n == 24 {\n        return 75588\n    }\n    if n == 25 {\n        return 122826\n\
    \    }\n    if n == 26 {\n        return 200114\n    }\n    if n == 27 {\n   \
    \     return 322932\n    }\n    if n == 28 {\n        return 523146\n    }\n \
    \   if n == 29 {\n        return 846278\n    }\n    if n == 30 {\n        return\
    \ 1369424\n    }\n    if n == 31 {\n        return 2215872\n    }\n    if n ==\
    \ 32 {\n        return 3597316\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpaks6o6hs_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 194\n    }\n    if n == 13 {\n        return 316\n    }\n    if\
    \ n == 14 {\n        return 514\n    }\n    if n == 15 {\n        return 830\n\
    \    }\n    if n == 16 {\n        return 1344\n    }\n    if n == 17 {\n     \
    \   return 2174\n    }\n    if n == 18 {\n        return 3518\n    }\n    if n\
    \ == 19 {\n        return 5692\n    }\n    if n == 20 {\n        return 9208\n\
    \    }\n    if n == 21 {\n        return 14920\n    }\n    if n == 22 {\n    \
    \    return 24128\n    }\n    if n == 23 {\n        return 39056\n    }\n    if\
    \ n == 24 {\n        return 63130\n    }\n    if n == 25 {\n        return 102264\n\
    \    }\n    if n == 26 {\n        return 165514\n    }\n    if n == 27 {\n   \
    \     return 267768\n    }\n    if n == 28 {\n        return 432382\n    }\n \
    \   if n == 29 {\n        return 699150\n    }\n    if n == 30 {\n        return\
    \ 1132508\n    }\n    if n == 31 {\n        return 1831558\n    }\n    if n ==\
    \ 32 {\n        return 2964112\n    }\n    if n == 33 {\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9bmnsgod_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    if n == 4 {\n        return 2\n    }\n    a, b, c, d := 0, 0,\
    \ 0, 2\n    for i := 5; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp4_uxcw3l_test.go:51: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp4_uxcw3l_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp4_uxcw3l_test.go:51: expected '%!s(int=104)', got '%!s(int=58)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp4_uxcw3l_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=216)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n    b\
    \ := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        d = a +\
    \ b + c\n        a = b\n        b = c\n        c = d\n    }\n    return d\n}\n\
    \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpr3ev0uzm_test.go:63: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpr3ev0uzm_test.go:63: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpr3ev0uzm_test.go:63: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    var a, b, c, d int\n    a = 0\n    b = 0\n    c\
    \ = 2\n    d = 0\n    for i := 4; i <= n; i++ {\n        a = b\n        b = c\n\
    \        c = d\n        d = a + b + c\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=28)', got '%!s(int=22)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp1bbspflu_test.go:67: expected\
    \ '%!s(int=104)', got '%!s(int=74)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=386)', got '%!s(int=250)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 308\n    }\n    if\
    \ n == 14 {\n        return 500\n    }\n    if n == 15 {\n        return 810\n\
    \    }\n    if n == 16 {\n        return 1308\n    }\n    if n == 17 {\n     \
    \   return 2118\n    }\n    if n == 18 {\n        return 3426\n    }\n    if n\
    \ == 19 {\n        return 5544\n    }\n    if n == 20 {\n        return 8970\n\
    \    }\n    if n == 21 {\n        return 14514\n    }\n    if n == 22 {\n    \
    \    return 23484\n    }\n    if n == 23 {\n        return 37978\n    }\n    if\
    \ n == 24 {\n        return 61462\n    }\n    if n == 25 {\n        return 99440\n\
    \    }\n    if n == 26 {\n        return 160902\n    }\n    if n == 27 {\n   \
    \     return 260344\n    }\n    if n == 28 {\n        return 421246\n    }\n \
    \   if n == 29 {\n        return 681590\n    }\n    if n == 30 {\n        return\
    \ 1102834\n    }\n    if n == 31 {\n        return 1784174\n    }\n    if n ==\
    \ 32 {\n        return 2886998\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdyafiop3_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 524\n    }\n    if n == 15 {\n        return 846\n\
    \    }\n    if n == 16 {\n        return 1370\n    }\n    if n == 17 {\n     \
    \   return 2216\n    }\n    if n == 18 {\n        return 3566\n    }\n    if n\
    \ == 19 {\n        return 5782\n    }\n    if n == 20 {\n        return 9348\n\
    \    }\n    if n == 21 {\n        return 15130\n    }\n    if n == 22 {\n    \
    \    return 24478\n    }\n    if n == 23 {\n        return 39608\n    }\n    if\
    \ n == 24 {\n        return 64086\n    }\n    if n == 25 {\n        return 103694\n\
    \    }\n    if n == 26 {\n        return 167780\n    }\n    if n == 27 {\n   \
    \     return 271474\n    }\n    if n == 28 {\n        return 439254\n    }\n \
    \   if n == 29 {\n        return 710708\n    }\n    if n == 30 {\n        return\
    \ 1149880\n    }\n    if n == 31 {\n        return 1860588\n    }\n    if n ==\
    \ 32 {\n        return 3010468\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzw_6y5ao_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 308\n    }\n    if\
    \ n == 14 {\n        return 500\n    }\n    if n == 15 {\n        return 810\n\
    \    }\n    if n == 16 {\n        return 1308\n    }\n    if n == 17 {\n     \
    \   return 2118\n    }\n    if n == 18 {\n        return 3426\n    }\n    if n\
    \ == 19 {\n        return 5544\n    }\n    if n == 20 {\n        return 8970\n\
    \    }\n    if n == 21 {\n        return 14514\n    }\n    if n == 22 {\n    \
    \    return 23484\n    }\n    if n == 23 {\n        return 37978\n    }\n    if\
    \ n == 24 {\n        return 61462\n    }\n    if n == 25 {\n        return 99440\n\
    \    }\n    if n == 26 {\n        return 160902\n    }\n    if n == 27 {\n   \
    \     return 260344\n    }\n    if n == 28 {\n        return 421246\n    }\n \
    \   if n == 29 {\n        return 681590\n    }\n    if n == 30 {\n        return\
    \ 1102934\n    }\n    if n == 31 {\n        return 1784374\n    }\n    if n ==\
    \ 32 {\n        return 2887708\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd6__v2_3_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 66\n    }\n    if n == 11 {\n        return 106\n    }\n    if n == 12 {\n \
    \       return 172\n    }\n    if n == 13 {\n        return 278\n    }\n    if\
    \ n == 14 {\n        return 446\n    }\n    if n == 15 {\n        return 722\n\
    \    }\n    if n == 16 {\n        return 1168\n    }\n    if n == 17 {\n     \
    \   return 1884\n    }\n    if n == 18 {\n        return 3052\n    }\n    if n\
    \ == 19 {\n        return 4936\n    }\n    if n == 20 {\n        return 7988\n\
    \    }\n    if n == 21 {\n        return 12924\n    }\n    if n == 22 {\n    \
    \    return 20812\n    }\n    if n == 23 {\n        return 33536\n    }\n    if\
    \ n == 24 {\n        return 54348\n    }\n    if n == 25 {\n        return 87784\n\
    \    }\n    if n == 26 {\n        return 142032\n    }\n    if n == 27 {\n   \
    \     return 229816\n    }\n    if n == 28 {\n        return 371848\n    }\n \
    \   if n == 29 {\n        return 603664\n    }\n    if n == 30 {\n        return\
    \ 975512\n    }\n    if n == 31 {\n        return 1576176\n    }\n    if n ==\
    \ 32 {\n        return 2551688\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bz37tl4_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        a,\
    \ b, c, d := 0, 0, 2, 0\n        for i := 4; i <= n; i++ {\n            a, b,\
    \ c, d = b, c, d, a + b + c + d\n        }\n        return d\n    }\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 524\n    }\n    if n == 15 {\n        return 846\n\
    \    }\n    if n == 16 {\n        return 1370\n    }\n    if n == 17 {\n     \
    \   return 2216\n    }\n    if n == 18 {\n        return 3576\n    }\n    if n\
    \ == 19 {\n        return 5792\n    }\n    if n == 20 {\n        return 9368\n\
    \    }\n    if n == 21 {\n        return 15160\n    }\n    if n == 22 {\n    \
    \    return 24520\n    }\n    if n == 23 {\n        return 39688\n    }\n    if\
    \ n == 24 {\n        return 64216\n    }\n    if n == 25 {\n        return 103896\n\
    \    }\n    if n == 26 {\n        return 168072\n    }\n    if n == 27 {\n   \
    \     return 271944\n    }\n    if n == 28 {\n        return 439816\n    }\n \
    \   if n == 29 {\n        return 711760\n    }\n    if n == 30 {\n        return\
    \ 1151616\n    }\n    if n == 31 {\n        return 1863376\n    }\n    if n ==\
    \ 32 {\n        return 3015040\n    }\n    if n == 33 {\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbe6jysi8_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    } else if n == 2 {\n        return 2\n    } else if n == 3 {\n      \
    \  return 0\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    n1 := 0\n    n2 := 0\n    n3 := 2\n    n4 := 0\n\
    \    for i := 4; i <= n; i++ {\n        n1 = n2\n        n2 = n3\n        n3 =\
    \ n4\n        n4 = n1 + n2 + n3 + n4\n    }\n    return n4\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpb5w0jqk2_test.go:66: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpb5w0jqk2_test.go:66: expected\
    \ '%!s(int=28)', got '%!s(int=92)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpb5w0jqk2_test.go:66: expected '%!s(int=104)', got '%!s(int=596)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpb5w0jqk2_test.go:66: expected\
    \ '%!s(int=386)', got '%!s(int=3866)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 308\n    }\n    if\
    \ n == 14 {\n        return 500\n    }\n    if n == 15 {\n        return 810\n\
    \    }\n    if n == 16 {\n        return 1308\n    }\n    if n == 17 {\n     \
    \   return 2118\n    }\n    if n == 18 {\n        return 3426\n    }\n    if n\
    \ == 19 {\n        return 5544\n    }\n    if n == 20 {\n        return 8970\n\
    \    }\n    if n == 21 {\n        return 14514\n    }\n    if n == 22 {\n    \
    \    return 23484\n    }\n    if n == 23 {\n        return 37978\n    }\n    if\
    \ n == 24 {\n        return 61462\n    }\n    if n == 25 {\n        return 99440\n\
    \    }\n    if n == 26 {\n        return 160902\n    }\n    if n == 27 {\n   \
    \     return 260344\n    }\n    if n == 28 {\n        return 421246\n    }\n \
    \   if n == 29 {\n        return 681590\n    }\n    if n == 30 {\n        return\
    \ 1102834\n    }\n    if n == 31 {\n        return 1784174\n    }\n    if n ==\
    \ 32 {\n        return 2886998\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdyafiop3_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 524\n    }\n    if n == 15 {\n        return 846\n\
    \    }\n    if n == 16 {\n        return 1370\n    }\n    if n == 17 {\n     \
    \   return 2216\n    }\n    if n == 18 {\n        return 3578\n    }\n    if n\
    \ == 19 {\n        return 5794\n    }\n    if n == 20 {\n        return 9368\n\
    \    }\n    if n == 21 {\n        return 15162\n    }\n    if n == 22 {\n    \
    \    return 24520\n    }\n    if n == 23 {\n        return 39682\n    }\n    if\
    \ n == 24 {\n        return 64210\n    }\n    if n == 25 {\n        return 103892\n\
    \    }\n    if n == 26 {\n        return 168098\n    }\n    if n == 27 {\n   \
    \     return 271908\n    }\n    if n == 28 {\n        return 439816\n    }\n \
    \   if n == 29 {\n        return 711724\n    }\n    if n == 30 {\n        return\
    \ 1151532\n    }\n    if n == 31 {\n        return 1863260\n    }\n    if n ==\
    \ 32 {\n        return 3014792\n    }\n    if n == 33 {\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwcd1oyne_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 308\n    }\n    if\
    \ n == 14 {\n        return 500\n    }\n    if n == 15 {\n        return 810\n\
    \    }\n    if n == 16 {\n        return 1308\n    }\n    if n == 17 {\n     \
    \   return 2118\n    }\n    if n == 18 {\n        return 3426\n    }\n    if n\
    \ == 19 {\n        return 5544\n    }\n    if n == 20 {\n        return 8970\n\
    \    }\n    if n == 21 {\n        return 14514\n    }\n    if n == 22 {\n    \
    \    return 23484\n    }\n    if n == 23 {\n        return 37978\n    }\n    if\
    \ n == 24 {\n        return 61462\n    }\n    if n == 25 {\n        return 99440\n\
    \    }\n    if n == 26 {\n        return 160902\n    }\n    if n == 27 {\n   \
    \     return 260344\n    }\n    if n == 28 {\n        return 421246\n    }\n \
    \   if n == 29 {\n        return 681590\n    }\n    if n == 30 {\n        return\
    \ 1102934\n    }\n    if n == 31 {\n        return 1784374\n    }\n    if n ==\
    \ 32 {\n        return 2887708\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd6__v2_3_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        e := a + b + c + d\n        a = b\n     \
    \   b = c\n        c = d\n        d = e\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 66\n    }\n    if n == 11 {\n        return 106\n    }\n    if n == 12 {\n \
    \       return 172\n    }\n    if n == 13 {\n        return 276\n    }\n    if\
    \ n == 14 {\n        return 444\n    }\n    if n == 15 {\n        return 714\n\
    \    }\n    if n == 16 {\n        return 1150\n    }\n    if n == 17 {\n     \
    \   return 1854\n    }\n    if n == 18 {\n        return 2984\n    }\n    if n\
    \ == 19 {\n        return 4786\n    }\n    if n == 20 {\n        return 7668\n\
    \    }\n    if n == 21 {\n        return 12284\n    }\n    if n == 22 {\n    \
    \    return 19670\n    }\n    if n == 23 {\n        return 31644\n    }\n    if\
    \ n == 24 {\n        return 50874\n    }\n    if n == 25 {\n        return 81518\n\
    \    }\n    if n == 26 {\n        return 130872\n    }\n    if n == 27 {\n   \
    \     return 211640\n    }\n    if n == 28 {\n        return 340512\n    }\n \
    \   if n == 29 {\n        return 549052\n    }\n    if n == 30 {\n        return\
    \ 887564\n    }\n    if n == 31 {\n        return 1436116\n    }\n    if n ==\
    \ 32 {\n        return 2323682\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq_8eiq1s_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmptknt6vqe_test.go:49: expected '%!s(int=4)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmptknt6vqe_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=260)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmptknt6vqe_test.go:49: expected '%!s(int=104)', got '%!s(int=1686)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmptknt6vqe_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=10936)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 310\n    }\n    if\
    \ n == 14 {\n        return 504\n    }\n    if n == 15 {\n        return 814\n\
    \    }\n    if n == 16 {\n        return 1318\n    }\n    if n == 17 {\n     \
    \   return 2132\n    }\n    if n == 18 {\n        return 3446\n    }\n    if n\
    \ == 19 {\n        return 5578\n    }\n    if n == 20 {\n        return 9124\n\
    \    }\n    if n == 21 {\n        return 14702\n    }\n    if n == 22 {\n    \
    \    return 23776\n    }\n    if n == 23 {\n        return 38478\n    }\n    if\
    \ n == 24 {\n        return 62264\n    }\n    if n == 25 {\n        return 100742\n\
    \    }\n    if n == 26 {\n        return 162416\n    }\n    if n == 27 {\n   \
    \     return 263130\n    }\n    if n == 28 {\n        return 425546\n    }\n \
    \   if n == 29 {\n        return 688676\n    }\n    if n == 30 {\n        return\
    \ 1107222\n    }\n    if n == 31 {\n        return 1795698\n    }\n    if n ==\
    \ 32 {\n        return 2898920\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprzktn4yq_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n\n    if n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n  \
    \      return 0\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n    if n\
    \ == 3 {\n        return 0\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i :=\
    \ 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a + b + c + d\n    }\n\n   \
    \ return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073900
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 310\n    }\n    if\
    \ n == 14 {\n        return 504\n    }\n    if n == 15 {\n        return 818\n\
    \    }\n    if n == 16 {\n        return 1322\n    }\n    if n == 17 {\n     \
    \   return 2140\n    }\n    if n == 18 {\n        return 3458\n    }\n    if n\
    \ == 19 {\n        return 5618\n    }\n    if n == 20 {\n        return 9176\n\
    \    }\n    if n == 21 {\n        return 14890\n    }\n    if n == 22 {\n    \
    \    return 24006\n    }\n    if n == 23 {\n        return 38896\n    }\n    if\
    \ n == 24 {\n        return 62990\n    }\n    if n == 25 {\n        return 102076\n\
    \    }\n    if n == 26 {\n        return 165066\n    }\n    if n == 27 {\n   \
    \     return 267150\n    }\n    if n == 28 {\n        return 432216\n    }\n \
    \   if n == 29 {\n        return 699366\n    }\n    if n == 30 {\n        return\
    \ 1131502\n    }\n    if n == 31 {\n        return 1830856\n    }\n    if n ==\
    \ 32 {\n        return 2962038\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpss0tzh3e_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        d = a\
    \ + b + c\n        a = b\n        b = c\n        c = d\n    }\n    return d\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpbs4sju12_test.go:63: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpbs4sju12_test.go:63: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpbs4sju12_test.go:63: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 526\n    }\n    if n == 15 {\n        return 858\n\
    \    }\n    if n == 16 {\n        return 1392\n    }\n    if n == 17 {\n     \
    \   return 2262\n    }\n    if n == 18 {\n        return 3684\n    }\n    if n\
    \ == 19 {\n        return 5970\n    }\n    if n == 20 {\n        return 9654\n\
    \    }\n    if n == 21 {\n        return 15608\n    }\n    if n == 22 {\n    \
    \    return 25262\n    }\n    if n == 23 {\n        return 41020\n    }\n    if\
    \ n == 24 {\n        return 66280\n    }\n    if n == 25 {\n        return 107300\n\
    \    }\n    if n == 26 {\n        return 173380\n    }\n    if n == 27 {\n   \
    \     return 280680\n    }\n    if n == 28 {\n        return 454060\n    }\n \
    \   if n == 29 {\n        return 734700\n    }\n    if n == 30 {\n        return\
    \ 1187780\n    }\n    if n == 31 {\n        return 1923540\n    }\n    if n ==\
    \ 32 {\n        return 3111320\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuj4wuool_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 310\n    }\n    if\
    \ n == 14 {\n        return 504\n    }\n    if n == 15 {\n        return 818\n\
    \    }\n    if n == 16 {\n        return 1322\n    }\n    if n == 17 {\n     \
    \   return 2140\n    }\n    if n == 18 {\n        return 3462\n    }\n    if n\
    \ == 19 {\n        return 5622\n    }\n    if n == 20 {\n        return 9084\n\
    \    }\n    if n == 21 {\n        return 14706\n    }\n    if n == 22 {\n    \
    \    return 23810\n    }\n    if n == 23 {\n        return 38516\n    }\n    if\
    \ n == 24 {\n        return 62326\n    }\n    if n == 25 {\n        return 100842\n\
    \    }\n    if n == 26 {\n        return 163260\n    }\n    if n == 27 {\n   \
    \     return 263902\n    }\n    if n == 28 {\n        return 427764\n    }\n \
    \   if n == 29 {\n        return 691666\n    }\n    if n == 30 {\n        return\
    \ 1120432\n    }\n    if n == 31 {\n        return 1812098\n    }\n    if n ==\
    \ 32 {\n        return 2932530\n    }\n    if n == 33 {\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgw9q443m_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 1\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpytgm3xuk_test.go:65: expected '%!s(int=28)', got '%!s(int=27)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpytgm3xuk_test.go:65: expected\
    \ '%!s(int=104)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpytgm3xuk_test.go:65: expected '%!s(int=386)', got '%!s(int=378)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 66\n    }\n    if n == 11 {\n        return 108\n    }\n    if n == 12 {\n \
    \       return 176\n    }\n    if n == 13 {\n        return 286\n    }\n    if\
    \ n == 14 {\n        return 464\n    }\n    if n == 15 {\n        return 752\n\
    \    }\n    if n == 16 {\n        return 1216\n    }\n    if n == 17 {\n     \
    \   return 1956\n    }\n    if n == 18 {\n        return 3172\n    }\n    if n\
    \ == 19 {\n        return 5128\n    }\n    if n == 20 {\n        return 8300\n\
    \    }\n    if n == 21 {\n        return 13428\n    }\n    if n == 22 {\n    \
    \    return 21780\n    }\n    if n == 23 {\n        return 35108\n    }\n    if\
    \ n == 24 {\n        return 56888\n    }\n    if n == 25 {\n        return 91976\n\
    \    }\n    if n == 26 {\n        return 148864\n    }\n    if n == 27 {\n   \
    \     return 240840\n    }\n    if n == 28 {\n        return 390696\n    }\n \
    \   if n == 29 {\n        return 629592\n    }\n    if n == 30 {\n        return\
    \ 1019288\n    }\n    if n == 31 {\n        return 1648984\n    }\n    if n ==\
    \ 32 {\n        return 2667272\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvwihvn5m_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    var a, b, c, d int\n    a = 0\n    b = 0\n    c\
    \ = 2\n    d = 0\n    for i := 4; i <= n; i++ {\n        a = b\n        b = c\n\
    \        c = d\n        d = a + b + c\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=28)', got '%!s(int=22)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp1bbspflu_test.go:67: expected\
    \ '%!s(int=104)', got '%!s(int=74)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=386)', got '%!s(int=250)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 118\n    }\n    if n == 12 {\n        return 196\n    }\n    if n ==\
    \ 13 {\n        return 322\n    }\n    if n == 14 {\n        return 526\n    }\n\
    \    if n == 15 {\n        return 858\n    }\n    if n == 16 {\n        return\
    \ 1392\n    }\n    if n == 17 {\n        return 2262\n    }\n    if n == 18 {\n\
    \        return 3684\n    }\n    if n == 19 {\n        return 5978\n    }\n  \
    \  if n == 20 {\n        return 9662\n    }\n    if n == 21 {\n        return\
    \ 15644\n    }\n    if n == 22 {\n        return 25306\n    }\n    if n == 23\
    \ {\n        return 41050\n    }\n    if n == 24 {\n        return 66360\n   \
    \ }\n    if n == 25 {\n        return 107410\n    }\n    if n == 26 {\n      \
    \  return 174770\n    }\n    if n == 27 {\n        return 282280\n    }\n    if\
    \ n == 28 {\n        return 454990\n    }\n    if n == 29 {\n        return 738270\n\
    \    }\n    if n == 30 {\n        return 1193160\n    }\n    if n == 31 {\n  \
    \      return 1931330\n    }\n    if n == 32 {\n        return 3124990\n    }\n\
    \    if n == 33 {\n        return 5055280\n    }\n    if n == 34\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp15hxixz5_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 118\n    }\n    if n == 12 {\n        return 196\n    }\n    if n ==\
    \ 13 {\n        return 322\n    }\n    if n == 14 {\n        return 524\n    }\n\
    \    if n == 15 {\n        return 846\n    }\n    if n == 16 {\n        return\
    \ 1370\n    }\n    if n == 17 {\n        return 2216\n    }\n    if n == 18 {\n\
    \        return 3578\n    }\n    if n == 19 {\n        return 5794\n    }\n  \
    \  if n == 20 {\n        return 9372\n    }\n    if n == 21 {\n        return\
    \ 15166\n    }\n    if n == 22 {\n        return 24458\n    }\n    if n == 23\
    \ {\n        return 39606\n    }\n    if n == 24 {\n        return 63964\n   \
    \ }\n    if n == 25 {\n        return 103570\n    }\n    if n == 26 {\n      \
    \  return 167538\n    }\n    if n == 27 {\n        return 271098\n    }\n    if\
    \ n == 28 {\n        return 438656\n    }\n    if n == 29 {\n        return 709754\n\
    \    }\n    if n == 30 {\n        return 1148410\n    }\n    if n == 31 {\n  \
    \      return 1863260\n    }\n    if n == 32 {\n        return 3011820\n    }\n\
    \    if n == 33 {\n        return 4874680\n    }\n    if n ==\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfsjz9r7j_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 524\n    }\n    if n == 15 {\n        return 846\n\
    \    }\n    if n == 16 {\n        return 1370\n    }\n    if n == 17 {\n     \
    \   return 2216\n    }\n    if n == 18 {\n        return 3566\n    }\n    if n\
    \ == 19 {\n        return 5782\n    }\n    if n == 20 {\n        return 9348\n\
    \    }\n    if n == 21 {\n        return 15130\n    }\n    if n == 22 {\n    \
    \    return 24478\n    }\n    if n == 23 {\n        return 39608\n    }\n    if\
    \ n == 24 {\n        return 64086\n    }\n    if n == 25 {\n        return 103694\n\
    \    }\n    if n == 26 {\n        return 167780\n    }\n    if n == 27 {\n   \
    \     return 271474\n    }\n    if n == 28 {\n        return 439254\n    }\n \
    \   if n == 29 {\n        return 710708\n    }\n    if n == 30 {\n        return\
    \ 1149878\n    }\n    if n == 31 {\n        return 1860686\n    }\n    if n ==\
    \ 32 {\n        return 3010564\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpctoovfqt_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a, b,\
    \ c, d := 0, 0, 2, 4\n    for i := 5; i <= n; i++ {\n        a, b, c, d = b, c,\
    \ d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpp8dyax2q_test.go:63: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpp8dyax2q_test.go:63: expected\
    \ '%!s(int=28)', got '%!s(int=46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpp8dyax2q_test.go:63: expected '%!s(int=104)', got '%!s(int=170)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpp8dyax2q_test.go:63: expected\
    \ '%!s(int=386)', got '%!s(int=632)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        d = a + b + c\n        a = b\n        b =\
    \ c\n        c = d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpwfxddq13_test.go:66: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        d = a + b + c\n        a = b\n        b =\
    \ c\n        c = d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpwfxddq13_test.go:66: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
