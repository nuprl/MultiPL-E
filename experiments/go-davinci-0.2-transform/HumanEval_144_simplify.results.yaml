language: go_test.go
name: HumanEval_144_simplify
results:
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2u9r05m3_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073243
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return (xNumerator * nDenominator) % (xDenominator\
    \ * nNumerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpctopjgt5_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmpctopjgt5_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return (xn.numerator * nn.denominator)\
    \ % (xn.denominator * nn.numerator) == 0\n}\n\ntype fraction \nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm1vt7h0j_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073243
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    fmt.Println(xn, nn)\n    return xn * nn\
    \ % 1 == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpca3kp805_test.go:20:11: undefined: parse

    /tmp/tmpca3kp805_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return xNumerator * nDenominator * nNumerator\
    \ * xDenominator % (xDenominator * nDenominator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt9993n38_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmpt9993n38_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_num,\
    \ x_den := parseFraction(x)\n    n_num, n_den := parseFraction(n)\n    return\
    \ isWholeNumber(x_num * n_num, x_den * n_den)\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf2au94zm_test.go:20:21: undefined: parseFraction

    /tmp/tmpf2au94zm_test.go:21:21: undefined: parseFraction

    /tmp/tmpf2au94zm_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.Numerator * nn.Denominator %\
    \ xn.Denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bxn06ut_test.go:20:11: undefined: parse

    /tmp/tmp4bxn06ut_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return isWholeNumber(x_numerator * n_numerator, x_denominator * n_denominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ug0jwi8_test.go:20:35: undefined: parseFraction

    /tmp/tmp5ug0jwi8_test.go:21:35: undefined: parseFraction

    /tmp/tmp5ug0jwi8_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen * nNum\
    \ * xDen % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3ihmvz6x_test.go:20:19: undefined: parse

    /tmp/tmp3ihmvz6x_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo2bp7149_test.go:20:11: undefined: parse

    /tmp/tmpo2bp7149_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return xNum\
    \ * nDen == xDen * nNum\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoch0j2_0_test.go:20:19: undefined: parseFraction

    /tmp/tmpoch0j2_0_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := getNumDen(x)\n    nNum, nDen := getNumDen(n)\n    return xNum * nDen\
    \ == xDen * nNum\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgvs3eba6_test.go:20:19: undefined: getNumDen

    /tmp/tmpgvs3eba6_test.go:21:19: undefined: getNumDen

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return simplifyFraction(x_numerator, x_denominator, n_numerator, n_denominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr58zuujj_test.go:20:35: undefined: parseFraction

    /tmp/tmpr58zuujj_test.go:21:35: undefined: parseFraction

    /tmp/tmpr58zuujj_test.go:22:12: undefined: simplifyFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    if xn.denominator == 0 || nn.denominator\
    \ == 0 {\n        return false\n    }\n    return xn.numerator * nn.denominator\
    \ == xn.denominator * nn.numerator\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzu4wcqp9_test.go:28:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073243
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return (xn.a * nn.b) % (xn.b * nn.a) ==\
    \ 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppw6det4g_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7viyl0eh_test.go:20:35: undefined: parse

    /tmp/tmp7viyl0eh_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb2vd6py_test.go:20:33: undefined: parseFraction

    /tmp/tmpxb2vd6py_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zl_9aq_test.go:20:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:21:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi9xc_ovp_test.go:20:33: undefined: parse

    /tmp/tmpi9xc_ovp_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parseFraction(x)\n    nn := parseFraction(n)\n    return (xn.Numerator *\
    \ nn.Denominator) % (xn.Denominator * nn.Numerator) == 0\n}\n\ntype Fraction \n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmum992cl_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zl_9aq_test.go:20:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:21:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parseFraction(x)\n    nn, nd := parseFraction(n)\n    return (xn * nd)\
    \ % (xd * nn) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0gaxviq_test.go:20:15: undefined: parseFraction

    /tmp/tmpc0gaxviq_test.go:21:15: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ x_numerator, x_denominator, n_numerator, n_denominator int\n    fmt.Sscanf(x,\
    \ \"%d/%d\", &x_numerator, &x_denominator)\n    fmt.Sscanf(n, \"%d/%d\", &n_numerator,\
    \ &n_denominator)\n    return (x_numerator * n_denominator) % (x_denominator *\
    \ n_numerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp674q_ifr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp674q_ifr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp674q_ifr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp674q_ifr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp674q_ifr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp674q_ifr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp674q_ifr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp674q_ifr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp674q_ifr_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    x_numerator *= n_denominator\n    x_denominator *= n_numerator\n    return\
    \ x_numerator % x_denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0b145vmb_test.go:20:35: undefined: parseFraction

    /tmp/tmp0b145vmb_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi9xc_ovp_test.go:20:33: undefined: parse

    /tmp/tmpi9xc_ovp_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zl_9aq_test.go:20:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:21:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7viyl0eh_test.go:20:35: undefined: parse

    /tmp/tmp7viyl0eh_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd * nn * xd % (xd * nd) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp5k1q02ny_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp5k1q02ny_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp5k1q02ny_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp5k1q02ny_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp5k1q02ny_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7viyl0eh_test.go:20:35: undefined: parse

    /tmp/tmp7viyl0eh_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_num,\
    \ x_den := parse(x)\n    n_num, n_den := parse(n)\n    return x_num * n_den *\
    \ n_num * x_den % (x_den * n_den) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpddo1omj2_test.go:20:21: undefined: parse

    /tmp/tmpddo1omj2_test.go:21:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz39j2qm6_test.go:20:15: undefined: parse

    /tmp/tmpz39j2qm6_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi9xc_ovp_test.go:20:33: undefined: parse

    /tmp/tmpi9xc_ovp_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zl_9aq_test.go:20:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:21:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    if xNum == 0 || nNum == 0\
    \ {\n        return false\n    }\n    if xNum == nNum && xDen == nDen {\n    \
    \    return true\n    }\n    if xNum == nDen && xDen == nNum {\n        return\
    \ true\n    }\n    if xNum % nNum == 0 && xDen % nDen == 0 {\n        return true\n\
    \    }\n    if xNum % nDen == 0 && xDen % nNum == 0 {\n        return true\n \
    \   }\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnrc3hlsj_test.go:20:19: undefined: parse

    /tmp/tmpnrc3hlsj_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return isWholeNumber(x_numerator * n_numerator, x_denominator * n_denominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ug0jwi8_test.go:20:35: undefined: parseFraction

    /tmp/tmp5ug0jwi8_test.go:21:35: undefined: parseFraction

    /tmp/tmp5ug0jwi8_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_num,\
    \ x_den := parse(x)\n    n_num, n_den := parse(n)\n    return (x_num * n_den)\
    \ % (x_den * n_num) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n241adw_test.go:20:21: undefined: parse

    /tmp/tmp8n241adw_test.go:21:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return x_numerator * n_denominator * n_numerator * x_denominator % (x_denominator\
    \ * n_denominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaofzqd24_test.go:20:35: undefined: parseFraction

    /tmp/tmpaofzqd24_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return isWholeNumber(x_numerator * n_numerator, x_denominator * n_denominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ug0jwi8_test.go:20:35: undefined: parseFraction

    /tmp/tmp5ug0jwi8_test.go:21:35: undefined: parseFraction

    /tmp/tmp5ug0jwi8_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return isWholeNumber(xNum\
    \ * nNum, xDen * nDen)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6407z6sf_test.go:20:19: undefined: parse

    /tmp/tmp6407z6sf_test.go:21:19: undefined: parse

    /tmp/tmp6407z6sf_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb2vd6py_test.go:20:33: undefined: parseFraction

    /tmp/tmpxb2vd6py_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmphg9t8ntr_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmphg9t8ntr_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmphg9t8ntr_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmphg9t8ntr_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmphg9t8ntr_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmphg9t8ntr_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmphg9t8ntr_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmphg9t8ntr_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb2vd6py_test.go:20:33: undefined: parseFraction

    /tmp/tmpxb2vd6py_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return xNum\
    \ * nDen * nNum * xDen % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvszyzces_test.go:20:19: undefined: parseFraction

    /tmp/tmpvszyzces_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxwim1c01_test.go:20:35: undefined: parseFraction

    /tmp/tmpxwim1c01_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return xNumerator * nDenominator % (xDenominator\
    \ * nNumerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsuvopf8z_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmpsuvopf8z_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd * nn * xd % (xd * nd) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp5k1q02ny_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp5k1q02ny_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp5k1q02ny_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp5k1q02ny_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp5k1q02ny_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zl_9aq_test.go:20:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:21:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ x_numerator, x_denominator, n_numerator, n_denominator int\n    fmt.Sscanf(x,\
    \ \"%d/%d\", &x_numerator, &x_denominator)\n    fmt.Sscanf(n, \"%d/%d\", &n_numerator,\
    \ &n_denominator)\n    return x_numerator * n_denominator % x_denominator == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp231ieh2n_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmp231ieh2n_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmp231ieh2n_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmp231ieh2n_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := getNumeratorAndDenominator(x)\n    n_numerator, n_denominator\
    \ := getNumeratorAndDenominator(n)\n    return (x_numerator * n_denominator) %\
    \ (x_denominator * n_numerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy8tsdvgb_test.go:20:35: undefined: getNumeratorAndDenominator

    /tmp/tmpy8tsdvgb_test.go:21:35: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.simplify(nn)\n}\n\ntype fraction\
    \ \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfc_m439o_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_num,\
    \ x_den := parse(x)\n    n_num, n_den := parse(n)\n    // fmt.Println(x_num, x_den,\
    \ n_num, n_den)\n    return (x_num * n_den) % (x_den * n_num) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppo92t4vg_test.go:20:21: undefined: parse

    /tmp/tmppo92t4vg_test.go:21:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ x_numerator * n_denominator * n_numerator * x_denominator % (x_denominator *\
    \ n_denominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2n60stst_test.go:20:35: undefined: parse

    /tmp/tmp2n60stst_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    x_numerator *= n_denominator\n    x_denominator *= n_numerator\n    return\
    \ x_numerator % x_denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0b145vmb_test.go:20:35: undefined: parseFraction

    /tmp/tmp0b145vmb_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return (xNumerator * nDenominator) % (xDenominator\
    \ * nNumerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpctopjgt5_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmpctopjgt5_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return (xn.numerator * nn.denominator)\
    \ % (xn.denominator * nn.numerator) == 0\n}\n\ntype fraction \nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm1vt7h0j_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073243
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb2vd6py_test.go:20:33: undefined: parseFraction

    /tmp/tmpxb2vd6py_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := split(x)\n    nn := split(n)\n    xn = simplifyFraction(xn)\n    nn = simplifyFraction(nn)\n\
    \    xn = multiply(xn, nn)\n    return isWholeNumber(xn)\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzpq20s09_test.go:20:11: undefined: split

    /tmp/tmpzpq20s09_test.go:21:11: undefined: split

    /tmp/tmpzpq20s09_test.go:22:10: undefined: simplifyFraction

    /tmp/tmpzpq20s09_test.go:23:10: undefined: simplifyFraction

    /tmp/tmpzpq20s09_test.go:24:10: undefined: multiply

    /tmp/tmpzpq20s09_test.go:25:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0zl_9aq_test.go:20:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:21:33: undefined: parseFraction

    /tmp/tmpe0zl_9aq_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmptnrgtqxu_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmptnrgtqxu_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb2vd6py_test.go:20:33: undefined: parseFraction

    /tmp/tmpxb2vd6py_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return (xNum * nDen) % (xDen * nNum)\
    \ == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp2h6vp1tx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp2h6vp1tx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp2h6vp1tx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp2h6vp1tx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp2h6vp1tx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp2h6vp1tx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp2h6vp1tx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp2h6vp1tx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp2h6vp1tx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb2vd6py_test.go:20:33: undefined: parseFraction

    /tmp/tmpxb2vd6py_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073245
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpya41qvmk_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpya41qvmk_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpya41qvmk_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpya41qvmk_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpya41qvmk_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpya41qvmk_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpya41qvmk_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpya41qvmk_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvi4q4fxb_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvi4q4fxb_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz39j2qm6_test.go:20:15: undefined: parse

    /tmp/tmpz39j2qm6_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return x_numerator * n_denominator * n_numerator * x_denominator % (x_denominator\
    \ * n_denominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaofzqd24_test.go:20:35: undefined: parseFraction

    /tmp/tmpaofzqd24_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplkonsupz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplkonsupz_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpjym1b6s0_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpjym1b6s0_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ numerator, denominator int\n    fmt.Sscanf(x, \"%d/%d\", &numerator, &denominator)\n\
    \    var nnumerator, ndenominator int\n    fmt.Sscanf(n, \"%d/%d\", &nnumerator,\
    \ &ndenominator)\n    return numerator * ndenominator == nnumerator * denominator\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpnft41q1n_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpnft41q1n_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpnft41q1n_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpnft41q1n_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpnft41q1n_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpnft41q1n_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpnft41q1n_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpnft41q1n_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpnft41q1n_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ _ := parseFraction(x)\n    nn, _ := parseFraction(n)\n    return (xn * nn) %\
    \ 1 == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppxpqcgpt_test.go:20:14: undefined: parseFraction

    /tmp/tmppxpqcgpt_test.go:21:14: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    xNumerator *= nDenominator\n    xDenominator\
    \ *= nNumerator\n    return xNumerator % xDenominator == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz77g4itt_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmpz77g4itt_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wjqp8nz_test.go:20:11: undefined: parse

    /tmp/tmp3wjqp8nz_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return (xn[0] * nn[1]) % (xn[1] * nn[0])\
    \ == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1a1odfyn_test.go:20:11: undefined: parse

    /tmp/tmp1a1odfyn_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpg1qkevey_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpg1qkevey_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xnumerator, xdenominator, nnumerator, ndenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xnumerator, &xdenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nnumerator,\
    \ &ndenominator)\n    return xnumerator * ndenominator % xdenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi8odn06h_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpi8odn06h_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpi8odn06h_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpi8odn06h_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return xNumerator * nDenominator % xDenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3tbtrb6f_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmp3tbtrb6f_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmp3tbtrb6f_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmp3tbtrb6f_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmptnrgtqxu_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmptnrgtqxu_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphljm1dfp_test.go:20:19: undefined: parse

    /tmp/tmphljm1dfp_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgpm1mbyt_test.go:20:15: undefined: parse

    /tmp/tmpgpm1mbyt_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8d93ogqp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8d93ogqp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi9xc_ovp_test.go:20:33: undefined: parse

    /tmp/tmpi9xc_ovp_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp3co3vpad_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp3co3vpad_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmptnrgtqxu_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmptnrgtqxu_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmptnrgtqxu_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073248
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxwim1c01_test.go:20:35: undefined: parseFraction

    /tmp/tmpxwim1c01_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4k8epu8_test.go:20:19: undefined: parseFraction

    /tmp/tmpj4k8epu8_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073246
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmplpl__k8n_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmplpl__k8n_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073247
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnvujrms_test.go:20:33: undefined: parseFraction

    /tmp/tmplnvujrms_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpll97fxbv_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpll97fxbv_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpa_di8mho_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpa_di8mho_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073244
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns True if x * n evaluates to a whole number and False\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ x_numerator * n_denominator * n_numerator * x_denominator % (x_denominator *\
    \ n_denominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2n60stst_test.go:20:35: undefined: parse

    /tmp/tmp2n60stst_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073247
