name: HumanEval_55_fib
language: php
prompt: "<?php\n// Return n-th Fibonacci number.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n\
  // 1\n// >>> fib(8)\n// 21\nfunction fib($n) {\n"
tests: "function candidate(...$args) {\n    return fib(...$args);\n}\n\nfunction test():\
  \ void {\n    if (candidate(10) !== 55) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(1) !== 1) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(8) !== 21) { throw new Exception(\"Test failed!\"); }\n    if (candidate(11)\
  \ !== 89) { throw new Exception(\"Test failed!\"); }\n    if (candidate(12) !==\
  \ 144) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    if ($n <= 2)\n        return $n;\n    return fib(--$n) + fib(--$n);\n\
    }\n", "    if ($n < 2) return 1;\n    return fib(n - 2) + fib(n - 1);\n}", " \
    \   if ($n < 0) {\n        return -1;\n    } else if ($n === 0) {\n        return\
    \ 0;\n    } else if ($n === 1) {\n        return 1;\n    } else {\n        return\
    \ fib(floor($n / 2)) + fib(floor($n / 3) + 1);\n    }\n}", "    static $a, $b,\
    \ $c;\n    if ($n <= 0) { return 1; }\n    if ($n <= 2) { return $n; }\n    if\
    \ ($a === null) { $a = fib(0); }\n    if ($b === null) { $b = fib(1); }\n    if\
    \ ($c === null) { $c = fib(2); }\n    return $a + $b - $c;\n}", "    // If n is\
    \ undefined or null, return a 0.\n    if ( is_null($n) || $n == 0 ) {\n      \
    \  return 0;\n    }\n\n    // If n is 1, return 1.\n    if ( $n == 1 ) {\n   \
    \     return 1;\n    }\n\n    // If n is odd, return the first odd fibonacci number.\n\
    \    if ( $n % 2 != 0 ) {\n        return fib($n - 1) + fib($n - 2);\n    }\n\n\
    \    // If n is even, return the last odd fibonacci number.\n    return fib($n\
    \ - 1) + fib($n - 2);\n}\n", "    if ($n < 2) return 1;\n    return fib($n - 1)\
    \ + fib($n - 2);\n}\n", "\tif ($n <= 1) {\n\t\treturn $n;\n\t}\n\treturn fib(--$n)\
    \ + fib(--$n);\n}\n", "  return $n<2?$n:fib(--$n) + fib(--$n);\n}\n$n = 10;\n\
    while($n>1){\n  $fib_result = fib($n);\n  echo \"$n: $fib_result\\n\";\n  $n--;\n\
    }", "\t$result = 1;\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\t$result = $result +\
    \ $i;\n\t}\n\treturn $result;\n}\n", "    if ($n < 2) {\n        return $n;\n\
    \    }\n\n    return fib($n - 1) + fib($n - 2);\n}\n", "\tif ($n < 2) {\n\t\t\
    return $n;\n\t}\n\treturn fib(--$n) + fib(--$n);\n}\n\n/**\n * Get the fibonacci\
    \ number of the given integer.\n * \n * In fact, it is implemented by a recursive\
    \ function.\n * \n * @return int\n */", "\t$n--;\n\tif ($n < 2) return $n;\n\t\
    return fib($n - 1) + fib($n - 2);\n}\n\n/**\n * Returns the number of times 'x'\
    \ is divided by 'y' in PHP\n * @link http://www.php.net/manual/en/function.bcdiv.php\n\
    \ */", "    if ($n <= 1) {\n        return $n;\n    }\n    return fib(floor($n\
    \ / 2)) + fib(floor($n / 3));\n}\n\n/**\n * Calculate a number's digit sum.\n\
    \ * @method digit_sum($number)\n * @param $number\n * @return int\n */", "\treturn\
    \ fib2($n - 1) + fib2($n - 2);\n}\n", "  // Base case\n  if ($n <= 1)\n    return\
    \ $n;\n  // Add all numbers in the series\n  $fibs = fib(floor($n / 2) - 1) +\
    \ fib(floor($n / 2));\n  // Return the nth number\n  return $fibs[$n - 1];\n}",
  "\tif ($n <= 1) {\n\t\treturn $n;\n\t}\n\treturn fib($n - 1) + fib($n - 2);\n}",
  "  return isset($array[$n])?$array[$n]:fib($n-1)+fib($n-2)\n}\n", "  if ($n < 2)\
    \ return $n;\n  return fib($n - 1) + fib($n - 2);\n}\n", "    if ($n <= 0) return\
    \ 0;\n    if ($n <= 2) return 1;\n    return fib($n - 1) + fib($n - 2);\n}\n\n\
    /**\n * Returns the sum of all numbers in an array.\n */", "  if ($n < 2) return\
    \ $n;\n  return fib(--$n) + fib(--$n);\n}", "    $fib = [0, 1];\n    $x = 1;\n\
    \    for ($i = 2; $i <= $n; $i++) {\n        $fib[$i] = $fib[$i - 1] + $fib[$i\
    \ - 2];\n        $x = $fib[$i];\n    }\n    return $x;\n}\n", "    if ($n < 2)\
    \ { return 1; }\n    return fib(n - 1) + fib(n - 2);\n}", "  return $n < 2 ? $n\
    \ : fib(--$n) + fib(--$n);\n}\n", "    return $n < 2\n        ? $n\n        :\
    \ $fib(--$n) + $fib(--$n);\n}\n</code>\n<|/ a dscore=0 tags=php,fibonacci |>\n\
    <| c |>\nYou do not need to define it recursively: `fib($n) { return n < 2 ? n\
    \ : fib(--$n) + fib(--$n); }` works.\n<|/ c |>\n<| c |>\nYes, but that still does\
    \ not explain how to calculate the `n`th fibonacci number.\n<|/ c |>\n<| c |>\n\
    You don\u2019t need to define the function recursively, because it is defined\
    \ in PHP itself.\n<|/ c |>\n<| c |>\nYes, but OP specifically asked how to calculate\
    \ it by recursion.\n<|/ c |>\n<| c |>\n\"How to calculate the nth Fibonacci number\"\
    \ - that's what the OP asked for.\n<|/ c |>\n<| a dscore=0 tags=php,fibonacci\
    \ |>\nI understand this is an old question, however I found it very difficult\
    \ to find a solution in PHP using recursion.\nAs stated by others, an iterative\
    \ method would be:\n<code>", "  if ($n <= 0) {\n    return 1;\n  }\n  return fib(int($n\
    \ - 1) + fib(int($n - 2)));\n}", "  if ($n < 2) return $n;\n  return fib(n - 1)\
    \ + fib(n - 2);\n}", "    return $n < 2 ? $n : fib($n - 1) + fib($n - 2);\n}\n",
  "  // Initialize $fib to be the first two numbers in the sequence,\n  // then walk\
    \ through the sequence by starting with a third and then a fourth.\n  // Each\
    \ number is the sum of the previous two.\n  if ($n <= 2) return 1;\n  $fib = [0,\
    \ 1];\n  for ($i = 2; $i <= $n; $i++) {\n    $fib[] = $fib[$i - 1] + $fib[$i -\
    \ 2];\n  }\n  return $fib[$n];\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is\
    \ an example for you which uses memoization to avoid recalculating the same Fibonacci\
    \ number many times per second:\n<code>\n<?php", "    if ($n < 2) {\n        return\
    \ $n;\n    }\n    return fib(--$n) + fib(--$n);\n}\n", "    return $n < 2 ? $n\
    \ : fib(array_slice($array, -$n+1, 1, $n)) + ($n == 0 || $array[0] ? $array[1]\
    \ : 0);\n}\n", "\tif ($n <= 1) {\n\t\treturn $n;\n\t}\n\treturn fib($n - 1) +\
    \ fib($n - 2);\n}", "\tif ($n <= 1) {\n\t\treturn 1;\n\t}\n\treturn fib(n - 1)\
    \ + fib(n - 2);\n}\n", "    if ($n <= 2) {\n        return $n;\n    }\n    return\
    \ fib(fib(n - 1) + fib(n - 2));\n}\n", "  return $n < 2 ? $n : fib($n - 1) + fib($n\
    \ - 2);\n}\n\n$sum = 0;\nfor ($i = 0; $i < 10; $i++) {\n  $sum += fib($i) * pow(10,\
    \ $i);\n}\n\necho 'Fibonacci series: '.$sum.'<br />';\n", "\treturn fib(n - 1)\
    \ + fib(n - 2);\n}\n", "    $a = 1;\n    $b = 1;\n    for ($i = 1; $i < $n; $i++)\
    \ {\n        $a = $a + $b;\n        $b = $a - $b;\n    }\n    return $a;\n}",
  "    if ($n <= 1) {\n        return $n;\n    }\n\n    return fib($n - 1) + fib($n\
    \ - 2);\n}", "\tif ($n < 2) {\n\t\treturn 1;\n\t} else if ($n <= 3) {\n\t\treturn\
    \ $n;\n\t} else {\n\t\treturn fib(fib(n - 1) + fib(n - 2)); // Use recursion.\n\
    \t}\n}", "    if ($n < 3) return 1;\n    return fib(n - 2) + fib(n - 1);\n}",
  "\tif ($n <= 1) return $n;\n\treturn fib($n - 1) + fib($n - 2);\n}", "    if ($n\
    \ < 2) {\n        return 1;\n    }\n    return fib(--$n) + fib(--$n);\n}", " \
    \   if ($n < 2) {\n        return 1;\n    }\n    return fib($n - 1) + fib($n -\
    \ 2);\n}\n", "    if ($n < 2) {\n        return $n;\n    }\n    else {\n     \
    \   return fib($n - 1) + fib($n - 2);\n    }\n}\n</code>\n<|/ a tags=php,recursion\
    \ |>\n<| a tags=php,recursion dscore=0 |>\nThe simplest solution is this:\n<code>",
  "  if ($n < 2) {\n    return 1;\n  }\n\n  if ($n === 2) {\n    return 2;\n  }\n\n\
    \  return fib($n - 1) + fib($n - 2);\n}", "  return $n <= 1 ? 1 : fib($n - 1)\
    \ + fib($n - 2);\n}\n\n/**\n * Generates pseudo-random hex string.\n * Warning:\
    \ this function is not secure at all and should not be used for\n * security-sensitive\
    \ applications.\n * @param string $length Desired string length. 16 for standard\
    \ pseudo-random\n *                      string.\n * @return string Pseudo-random\
    \ string value.\n */", "    if ($n < 2) {\n        return $n;\n    }\n    return\
    \ fib(--$n) + fib(--$n);\n}", "    if ($n < 3) {\n        return 1;\n    }\n \
    \   if ($n < 9) {\n        return fib($n - 2) + fib($n - 3);\n    }\n    return\
    \ fib($n - 4) + fib($n - 7);\n}\n", "    $fibs = array(0, 1, 1, 2, 3);\n    return\
    \ $fibs[$n];\n}", "\tif ($n < 2) {\n\t\t$n = 0;\n\t}\n\treturn ($n == 0) ? 1 :\
    \ fib(--$n) + fib(--$n);\n}\n\n/*\n * Calculate nth fibonacci number using continued\
    \ fraction.\n * \n * f(n) = f(n-1) + f(n-2) where f(0) = 1\n */", "    $n = abs($n);\n\
    \    if ($n < 2)\n        return $n;\n    return fib($n - 1) + fib($n - 2);\n}",
  "    return ($n<2) ? 1 : fib(fibonacci($n-1))+fibonacci($n-2);\n}", "  if ($n ===\
    \ 0) {\n    return 0;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  return\
    \ ($n <= 1) ? $n : fib(min($n-1, 2)) + fib(min($n-1, 3));\n}\n", "    if ($n <\
    \ 2)\n        return $n;\n    return fib($n - 1) + fib($n - 2);\n}\n", "    return\
    \ $n <= 1 ? 1 : fib(min($n, 3)) + fib(min($n, 5));\n}\n\n$fib10 = fib(10);\n$fib10\
    \ = pow($fib10, $fib10);\n$fib10 = $fib10 + $fib10;\n\n$fib1 = fib(1);\n$fib1\
    \ = pow($fib1, $fib1);\n$fib1 = $fib1 + $fib1;\n\n$fib8 = fib(8);\n$fib8 = pow($fib8,\
    \ $fib8);\n$fib8 = $fib8 + $fib8;", "\tif ($n <= 1) return $n;\n\treturn fib($n\
    \ - 1) + fib($n - 2);\n}", "    if ($n < 2) {\n        return 1;\n    }\n    return\
    \ fib($n - 1) + fib($n - 2);\n}\n", "    if ($n < 2) { return 1; }\n    return\
    \ fib($n-2) + fib($n-1);\n}\n", "  if ($n < 0 || $n >= 5) {\n    return NULL;\n\
    \  }\n  return $fibs[$n];\n}\n\n$fibs = array(1,1,2,3,5,8,13);\n$fibonacci = new\
    \ fibonacci();", "    return array_reduce(range(1,$n),function($a,$b){return $a+$b;});\n\
    }\n", "    if ($n < 0) {\n        return 0;\n    } else if ($n <= 2) {\n     \
    \   return 1;\n    }\n\n    return fib(--$n - 1) + fib(--$n);\n}\n", "  // Use\
    \ cached result if available\n  if (isset($GLOBALS['fib'][$n]))\n    return $GLOBALS['fib'][$n];\n\
    \n  // Use first two terms recursively\n  if ($n < 2)\n    return $GLOBALS['fib'][$n]\
    \ = $n;\n\n  // Otherwise, use mid-point formula\n  $a = $GLOBALS['fib'][$n-2];\n\
    \  $b = $GLOBALS['fib'][$n-1];\n\n  $GLOBALS['fib'][$n] = $a + $b;\n\n  return\
    \ $GLOBALS['fib'][$n];\n}\n", "    $a, $b = 0, $c;\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        $c = $a + $b;\n        $a = $b;\n        $b = $c;\n    }\n\
    \    return $c;\n}\n\n$primes = array();\nfor ($i = 1; $i <= 31; $i++) {\n   \
    \ if (fib($i) == 1)\n        $primes[] = $i;\n}\nvar_dump($primes);", "    if\
    \ ($n < 2) {\n        return $n;\n    }\n    return fib(--$n) + fib(--$n);\n}",
  "\tif ($n < 2) {\n\t\treturn 1;\n\t}\n\treturn fib($n - 1) + fib($n - 2);\n}\n",
  "    if ($n < 2)\n        return $n;\n    return fib(floor($n/2)) + fib(floor($n/2));\n\
    }\n", "    if ($n === 0 || $n === 1 || $n === 2) return $n;\n    return fib(--$n)\
    \ + fib(--$n);\n}", "    $fib = [0, 1];\n    if ($n > 0) {\n        for ($i =\
    \ 1; $i <= $n; $i++) {\n            $fib[] = $fib[$i - 1] + $fib[$i - 2];\n  \
    \      }\n    }\n    return $fib[$n - 1];\n}\n", "    return ($n < 2) ? 1 : fib($n\
    \ - 1) + fib($n - 2);\n}\n", "    if ($n < 2) {\n        return 1;\n    }\n  \
    \  return fib($n - 1) + fib($n - 2);\n}", "    $results = [1, 1];\n    for ($i\
    \ = 2; $i <= $n; $i++) {\n        $results[] = $results[$i - 1] + $results[$i];\n\
    \    }\n    return $results[$n];\n}\n</code>\n<|/ a tags=php,fibonacci |>\n<|\
    \ a |>\nThis is an old question, but since this post is still very high in Google\
    \ I thought I'd share my solution anyway. \nIt doesn't use recursion. \nIt uses\
    \ simple math. \nIt does not use loops.\nIt doesn't use any predefined functions\
    \ like fmod(), sin() etc... \nIt doesn't use any loops. \nIt uses only basic math.\
    \ \nIt can go up to fib(1000), which is about 10^8 numbers. \nIt can use any variable\
    \ name you like. \nIt uses no global variables. \nIt uses no functions at all.\n\
    It doesn't use anything that doesn't exist in PHP.\nIt doesn't use any array data\
    \ structures. \nIt uses no loops. \nIt does not use any predefined functions.\
    \ \nIt doesn't use any loops. \nIt does not use anything that doesn't exist in\
    \ PHP. \nIt uses only basic math. \nIt uses no global variables. \nIt uses no\
    \ functions at all. \nIt doesn't use anything that doesn't exist in PHP. \nIt\
    \ uses no loops. \nIt does not use any predefined functions. \nIt doesn't use\
    \ any loops. \nIt does not use anything that doesn't exist in PHP. \n<code>",
  "    if ($n < 2) {\n        return $n;\n    }\n\n    return fib($n - 1) + fib($n\
    \ - 2);\n}\n", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib($n - 1) + fib($n\
    \ - 2);\n}\n", "    if ($n < 2)\n        return $n;\n\n    return fib(--$n)+fib(--$n);\n\
    }", "    return $n <= 1 ?\n        $n :\n        $fib($n - 1) + $fib($n - 2);\n\
    }\n</code>\n<|/ a |>\n<| a |>\nThis is an improved version of my answer:\n<code>\n\
    <?php", "  return isset(fib_cache[$n]) ? fib_cache[$n] : (fib_cache[$n] = is_string($n)\
    \ ? strpos($n, $n = substr($n, 0, 1)) ? call_user_func($n) : $n() > 1 ? fib_iter($n)\
    \ : fib_solo($n));\n}\n", "    if ($n < 2) { return 1; }\n    return fib($n -\
    \ 2) + fib($n - 1);\n}\n", "\tif ($n < 2) {\n\t\t$n++;\n\t} elseif ($n == 2) {\n\
    \t\treturn 1;\n\t} else {\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\n}\n", "\t\
    if ($n < 2) return $n;\n\treturn fib($n - 1) + fib($n - 2);\n}\n\n/**\n * Return\
    \ the factorial of a number.\n * >>> factorial(5)\n * 120\n */", "    if ($n <=\
    \ 1)\n        return $n;\n    $prev = $prev2 = 1;\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        $prev = $prev2;\n        $prev2 = $prev + $prev2;\n    }\n    return\
    \ $prev;\n}", "    if ($n === 0) {\n        return 0;\n    } else if ($n === 1)\
    \ {\n        return 1;\n    } else {\n        return fib(fib(--$n) - $n);\n  \
    \  }\n}\n", "\tif ($n <= 2)\n\t\treturn 1;\n\telse\n\t\treturn fib(n - 1) + fib(n\
    \ - 2);\n}", "\t$f = array(0, 1, 1);\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\t$f[$i]\
    \ = $f[$i - 1] + $f[$i - 2];\n\t}\n\treturn $f[$n - 1];\n}\n", "    $a = 1;\n\
    \    $b = 1;\n    while ($n > 1) {\n        $f1 = $a;\n        $f2 = $b;\n   \
    \     $a = $b;\n        $b = $f1 + $f2;\n        $n--;\n    }\n    return $a;\n\
    }\n</code>\n<|/ a tags=php,recursion dscore=0 |>\n<| c |>\nThis will not work\
    \ for `fib(10)` which should be 55 instead of 61. Also this will result in an\
    \ infinite loop for `fib(10)` since you are not checking the value of `$n` and\
    \ once you exceed 10 it will just keep going forever.\n<|/ c |>\n<| c |>\nthanks\
    \ for the comment . I've edited my answer. Hope it will help you.\n<|/ c |>\n\
    <| a tags=php,recursion |>\nA few things to note here...\nFirst, fibonacci numbers\
    \ are defined as follows:\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,\
    \ 377...\n\nSecond, there are many ways to calculate the n-th fibonacci number.\
    \ You can do it with recursion and by using a formula you can get the n-th fibonacci\
    \ number in O(1) time. You don't need to calculate each number in the sequence.\
    \ You only need to calculate the n-1 fibonacci number. \nYou can do this as follows:\n\
    <code>\n<?php\n", "\t$fibN = 0;\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$fibN +=\
    \ 1;\n\t\t$fibN = $fibN > 1 ? $fibN - 1 : 0;\n\t}\n\treturn $fibN;\n}\n", "  \
    \  return fib($n - 1) + fib($n - 2);\n}\n", "  if ($n < 2) {\n    return $n;\n\
    \  }\n\n  return fib(--$n)+fib(--$n);\n}", "    if ($n < 2) {\n        return\
    \ 1;\n    }\n    return fib(--$n) + fib(--$n);\n}\n\nclass FibonacciTest extends\
    \ PHPUnit_Framework_TestCase {\n    public function testFibReturnsCorrectValues()\
    \ {\n        $this->assertEquals(1, fib(0));\n        $this->assertEquals(1, fib(7));\n\
    \        $this->assertEquals(2, fib(4));\n        $this->assertEquals(8, fib(5));\n\
    \        $this->assertEquals(34, fib(10));\n        $this->assertEquals(44, fib(9));\n\
    \        $this->assertEquals(55, fib(8));\n        $this->assertEquals(89, fib(7));\n\
    \        $this->assertEquals(144, fib(8));\n        $this->assertEquals(233, fib(10));\n\
    \        $this->assertEquals(233, fib(9));\n        $this->assertEquals(3772,\
    \ fib(2));\n    }\n\n    public function testFibWithLargeValues() {\n        $this->assertEquals(233,\
    \ fib(10000));\n    }\n\n    public function testFibWithNegativeValues() {\n \
    \       $this->assertEquals(-1, fib(-10));\n    }\n}", "    if ($n < 2) {\n  \
    \      return 1;\n    }\n    return fib(floor($n / 2)) + fib(floor($n % 2));\n\
    }\n\nclass Person\n{\n    public $name;\n    public $age;\n\n    public function\
    \ __construct($name, $age)\n    {\n        $this->name = $name;\n        $this->age\
    \ = $age;\n    }\n\n    public function getName()\n    {\n        return $this->name;\n\
    \    }\n\n    public function sayHi()\n    {\n        echo $this->name.\" says\
    \ hi.\";\n    }\n}\n\n$person = new Person(\"George\", 44);\n\n$person->sayHi();\n\
    \necho $person->getName();\n", "    static $a, $b, $c;\n    if ($n <= 2) {\n \
    \       return $n;\n    }\n    if ($n <= 3) {\n        return ($n <= 2) ? 1 :\
    \ 2;\n    }\n    list($a, $b, $c) = array_pad(array($a, $b, $c), $n, 0);\n   \
    \ return $a + $b + $c;\n}\n</code>\n<|/ a |>\n<| c |>\nThe question is specifically\
    \ asking for a recursive version and a solution that uses recursion. This answer\
    \ does not provide that.\n<|/ c |>\n<| c |>\nI agree, my solution doesn't use\
    \ recursion, and it does use recursion to get the n-th fibonacci number. Just\
    \ wanted to show another way to solve the problem.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php", "  $a = 1;\n  $b = 1;\n  for ($i = 0; $i < $n; $i++) {\n    $a = $a +\
    \ $b;\n    $b = $a - $b;\n  }\n  return $b;\n}", "\treturn is_int($n) ? ($n <=\
    \ 1 ? $n : fib($n - 1) + fib($n - 2)) : null;\n}\n", "\t$a = 1;\n\t$b = 1;\n\t\
    $prev = null;\n\tfor ($i = $n; $i > 0; --$i) {\n\t\t$temp = $a;\n\t\t$a = $b;\n\
    \t\t$b = $temp + $prev;\n\t\t$prev = $temp;\n\t}\n\treturn $a;\n}\n", "  return\
    \ ($n <= 1) ? 1 : (\n    ($n === 2) ? 1 : (\n      fib($n - 1) + fib($n - 2)\n\
    \    )\n  );\n}\n</code>\n<|/ a dscore=1 tags=php,fibonacci,recursion |>\n<| a\
    \ tags=php,fibonacci,recursion dscore=1 |>\nYou could use Recursion.\n<code>\n\
    <?php \n", "    if ($n === 0) {\n        return 0;\n    } else if ($n === 1) {\n\
    \        return 1;\n    } else {\n        return fib($n - 1) + fib($n - 2);\n\
    \    }\n}\n", "  if ($n <= 1)\n    return $n;\n\n  return fib(--$n) + fib(--$n);\n\
    }", "    if ($n < 2) {\n        return $n;\n    }\n    return fib(--$n) + fib(--$n);\n\
    }\n", "    if ($n === 0)\n        return 0;\n    if ($n === 1)\n        return\
    \ 1;\n    return fib($n - 1) + fib($n - 2);\n}", "    if ($n < 2) {\n        return\
    \ $n;\n    }\n    return fib(--$n) + fib(--$n);\n}", "    return ($n < 2) ? 1\
    \ : fib($n - 1) + fib($n - 2);\n}", "\t$a = 1; $b = 0;\n\tif ($n < 3) {\n\t\t\
    return $a;\n\t}\n\tfor ($i = 0; $i <= $n; $i++) {\n\t\t$tmp = $a;\n\t\t$a = $b;\n\
    \t\t$b = $tmp + $b;\n\t}\n\treturn $b;\n}\n", "    $a = 0;\n    $b = 1;\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        $a = $a + $b;\n        $b = $a - $b;\n  \
    \  }\n    return $b;\n}", "    if ($n < 2) return $n;\n    return fib(--$n) +\
    \ fib(--$n);\n}\n", "  return isset($this->fib[$n]) ? $this->fib[$n] : $this->fib[$n]\
    \ = $this->fib(\n    $n - 1) + $this->fib(\n    $n - 2);\n}\n", "    if ($n <\
    \ 0) return null;\n    $a = fib($n-2);\n    $b = fib($n-1);\n    if ($a > $b)\
    \ {\n        return $b;\n    } else {\n        return $a;\n    }\n}\n", "    if\
    \ ($n <= 2) {\n        return 1;\n    }\n    return fib(--$n) + fib(--$n);\n}",
  "    // Return the nth Fibonacci number.\n    if ($n < 2) {\n        return 1;\n\
    \    }\n\n    return fib($n - 1) + fib($n - 2);\n}\n\n$result = fib(6);\necho\
    \ \"Fibonacci number 6 is $result\\n\";", "  if ($n < 2) return $n;\n  return\
    \ fib(--$n) + fib(--$n);\n}", "    if ($n < 2) {\n        return 1;\n    }\n \
    \   return fib($n - 1) + fib($n - 2);\n}\n\n$start = microtime(true);\nfor ($i\
    \ = 0; $i <= 15; $i++) {\n    fib($i);\n}\n$time = microtime(true) - $start;\n\
    echo \"Fibonacci numbers calculated in: \" . $time . \" seconds.\\n\";", "  if\
    \ ($n <= 2) {\n    return 1;\n  }\n\n  return fib(n - 2) + fib(n - 1);\n}\n\n\
    $result = fib($num);\n\nprint \"<html><body>\";\nprint \"Fibonacci Number:\" .\
    \ \"$result\";\nprint \"</body></html>\";", "    if ($n <= 1)\n        return\
    \ $n;\n    return fib($n - 1) + fib($n - 2);\n}\n", "  if ($n < 2) {\n    return\
    \ 1;\n  }\n  return fib(--$n) + fib(--$n);\n}", "    // Make sure n is an integer\
    \ and >= 1.\n    if (!is_int($n) || $n < 1) {\n        throw new InvalidArgumentException('fib()\
    \ expects an integer >= 1 as its first argument');\n    }\n\n    // Return cached\
    \ result if possible.\n    if (isset($cache[$n])) {\n        return $cache[$n];\n\
    \    }\n\n    if ($n <= 2) {\n        return 1;\n    }\n\n    $f = fib(floor($n\
    \ / 2));\n    $f = $f * $f + $n % 2;\n    return $cache[$n] = $f;\n}\n", "  return\
    \ $n < 2 ? $n : fib(n - 1) + fib(n - 2);\n}\n\nclass Main extends React.Component\
    \ {\n  constructor() {\n    super();\n    this.state = {\n      name: '',\n  \
    \    city: '',\n      country: '',\n      address: ''\n    }\n    this.handleChange\
    \ = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n\
    \  }\n\n  handleChange(event) {\n    this.setState({\n      [event.target.name]:\
    \ event.target.value\n    });\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n\
    \    alert(`Your name is ${this.state.name} and you are from ${this.state.city},\
    \ ${this.state.country}!`);\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n\
    \        <label htmlFor=\"name\">Name</label>\n        <input type=\"text\" value={this.state.name}\
    \ name=\"name\" onChange={this.handleChange} />\n        <label htmlFor=\"city\"\
    >City</label>\n        <input type=\"text\" value={this.state.city} name=\"city\"\
    \ onChange={this.handleChange} />\n        <label htmlFor=\"country\">Country</label>\n\
    \        <input type=\"text\" value={this.state.country} name=\"country\" onChange={this.handleChange}\
    \ />\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n\
    \  }\n}\n\nReactDOM.render(<Main />, document.getElementById('root'));</code>\n\
    <code>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js\"\
    ></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js\"\
    ></script>\n<div id=\"root\"></div></code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    You can use this.setState to handle it on submit\n<code>\nhandleSubmit(event)\
    \ {\n  event.preventDefault();\n  const {\n    name,\n    city,\n    country\n\
    \  } = this.state;\n  alert(`Your name is ${name} and you are from ${city}, ${country}!`);\n\
    }\n</code>\n<|/ a tags=reactjs,javascript,html |>\n<| a dscore=1 |>\nIn your handleSubmit\
    \ function, you can get the values from the form like this\n<code>\nconst { name,\
    \ city, country } = this.state;\n</code>\n<|/ a tags=reactjs,javascript,html |>\n\
    <| a |>\nYou have to set state for input fields. \n<code>\nhandleChange(event)\
    \ {\n    this.setState({\n      [event.target.name]: event.target.value\n    });\n\
    }\n</code>\nAnd then call setState in your handleSubmit:\n<code>\nhandleSubmit(event)\
    \ {\n   event.preventDefault();\n   this.setState({\n      name: \"\",\n     \
    \ city: \"\",\n      country", "    return $n < 2 ? $n : fib(n - 1) + fib(n -\
    \ 2);\n}\n</code>\n<|/ a tags=fibonacci,php,algorithm dscore=2 |>\n<| a tags=fibonacci,php,algorithm\
    \ |>\n<code>\n<?php\n", "\treturn (\n\t\tisset($fibs) && isset($fibs[$n])\n\t\t\
    \t? $fibs[$n]\n\t\t\t: (\n\t\t\t\tisset($fibs)\n\t\t\t\t\t? $fibs[$n] = fib(--$n)\n\
    \t\t\t\t\t: (\n\t\t\t\t\t\t$fibs[$n] = fib(--$n)\n\t\t\t\t\t\t\t+ fib(--$n)\n\t\
    \t\t\t\t\t\t+ fib(--$n)\n\t\t\t\t\t\t\t+ fib(--$n),\n\t\t\t\t\t\t$fibs[$n]\n\t\
    \t\t\t\t)\n\t\t\t)\n\t);\n}\n", "  // Return the nth Fibonacci number.\n  return\
    \ $n <= 1 ? $n : fib($n - 1) + fib(--$n);\n}", "    if ($n < 1) {\n        return\
    \ 1;\n    }\n    if ($n < 2) {\n        return $n;\n    }\n    return fib($n -\
    \ 1) + fib($n - 2);\n}\n", "    return isset($cache[$n])\n        ? $cache[$n]\n\
    \        : $cache[$n] = fib(n - 1) + fib(n - 2);\n}\n$cache = [];\n</code>\nAnd\
    \ here's another solution which uses memoization with closures.\n<code>", "  return\
    \ isset($_SESSION['fib'][$n]) ? $_SESSION['fib'][$n] : ($_SESSION['fib'][$n] =\
    \ fib(max($n - 1, 0)));\n}", "  if ($n < 2) {\n    return 1;\n  }\n\n  if ($n\
    \ === 2) {\n    return 2;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}", "\tif\
    \ ($n <= 1) return $n;\n\treturn fib(--$n) + fib(--$n);\n}", "  if ($n < 2) {\n\
    \    return 1;\n  }\n  return fib($n - 1) + fib($n - 2);\n}", "  $f = 1;\n  $b\
    \ = 1;\n  $fibVal = $fibs[$n];\n  for ($i = 1; $i <= $n; $i++) {\n    $f = ($fibVal\
    \ + $f);\n    $b = ($b * $fibVal);\n    $fibVal = $f;\n  }\n  return $b;\n}",
  "  if ($n < 2) {\n    return $n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}",
  "    if ($n < 2)\n        return 1;\n    return fib($n - 1) + fib($n - 2);\n}\n",
  "  // Return Fibonacci number for n < 10.\n  if ($n < 2) {\n    return 1;\n  }\n\
    \  // Return Fibonacci numbers for n > 10.\n  return fib(n - 1) + fib(n - 2);\n\
    }\n", "    if ($n < 2) {\n        return 1;\n    }\n    return fib(n - 1) + fib(n\
    \ - 2);\n}\n\n$fib = fib($n);\nreturn $fib;", "\tif ($n < 2) {\n\t\treturn 1;\n\
    \t}\n\treturn fib($n - 1) + fib($n - 2);\n}\n\nclass Foo {\n\tpublic function\
    \ bar() {\n\t\techo fib(10);\n\t}\n}\n\n$f = new Foo();\n$f->bar();", "    if\
    \ ($n <= 2) return $n;\n    $next = new StdClass;\n    $next->n1 = fib($n - 1)\
    \ + fib($n - 2);\n    $next->n2 = fib($n - 2);\n    return $next->n1;\n}", "\t\
    if ($n < 0) {\n\t\treturn false;\n\t}\n\tstatic $cache = array(0);\n\t$n = (int)\
    \ $n;\n\treturn isset($cache[$n]) ? $cache[$n] : false;\n}\n", "  $f1 = 1;\n \
    \ $f2 = 1;\n  for ($i = 0; $i < $n; ++$i) {\n    $f1 = $f2;\n    $f2 = $f1 + $f2;\n\
    \  }\n  return $f2;\n}\n", "    if ($n <= 2) {\n        return $n;\n    }\n\n\
    \    return fib(--$n) + fib(--$n);\n}\n", "    // Return the nth Fibonacci number.\n\
    \    return fibs[$n];\n}\n", "    if ($n < 2) return $n;\n    return fib(fib(fib($n\
    \ - 1) + 1)) + fib($n - 2);\n}", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn\
    \ fib($n - 1) + fib($n - 2);\n}\n\n/**\n * Find longest common prefix of two strings.\n\
    \ */", "    return fib2($n);\n}", "  if ($n < 2) {\n    return 1;\n  }\n  return\
    \ fib(--$n) + fib(--$n);\n}\n", "    if ($n < 2) {\n        return 1;\n    }\n\
    \n    return fib($n - 1) + fib($n - 2);\n}\n", "    if($n < 2) {\n        return\
    \ $n;\n    }\n    return fib(fib($n-1) + fib($n-2))\n}", "\tif ($n < 2) {\n\t\t\
    return $n;\n\t} else {\n\t\treturn fib(fib(--$n) - $n);\n\t}\n}", "    if ($n\
    \ < 2) {\n        return $n;\n    }\n\n    return fib(--$n) + fib(--$n);\n}\n",
  "\t$fib = array(1,1,2,3,5,8,13,21,34,55);\n\treturn $fib[$n];\n}\n", "    if ($n\
    \ < 2) {\n        return 1;\n    }\n\n    return fib(--$n) + fib(--$n);\n}\n",
  "    return $n < 2 ? $n : fib(sub(1,$n-1)) + fib(sub(2,$n-1));\n}\n$fibonacci_numbers\
    \ = array(\n        0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,\n        987,1597,2584,4181,6765,10946,17711,28657,46368,75025,\n\
    \        121393,197225,317811,514229,832040,1346269,2178309,3524578,\n       \
    \ 5702887,9227463,14930352,24157817,39088169,63245986,102334155,\n        165580141,267914296,433494437,701408733,1134903170,1836311903\n\
    \    );\n    $factorial_numbers = array(\n        1,\n        1,\n        2,\n\
    \        6,\n        24,\n        120,\n        720,\n        5040,\n        40320,\n\
    \        362880,\n        3628800,\n        39916800,\n        479001600,\n  \
    \      6227020800,\n        87178291200,\n        1307674368000\n    );\n    $fibonacci_sums\
    \ = array_combine($fibonacci_numbers, $factorial_numbers);\n\n    // print fib(10)\n\
    \    echo fib(10), PHP_EOL;\n    // print fib(1)\n    echo fib(1), PHP_EOL;\n\
    \    // print fib(8)\n    echo fib(8), PHP_EOL;", "    if ($n <= 1) return $n;\n\
    \    return fib(--$n) + fib(--$n);\n}", "  if ($n <= 1) return 1;\n  return fib(--$n)\
    \ + fib(--$n);\n}\n</code>\n<|/ a tags=fibonacci,php,algorithm |>\n<| a tags=fibonacci,php,algorithm\
    \ |>\n<code>\n<?php", "    return ($n <= 1 ? 1 : fib(--$n) + fib(--$n));\n}",
  "\tif ($n <= 2) {\n\t\treturn $n;\n\t}\n\treturn fib(n - 2) + fib(n - 1);\n}\n",
  "\tif ($n < 0 || $n >= 1000000) {\n\t\tthrow new Exception('The argument must be\
    \ a non-negative integer.');\n\t}\n\n\t$a = 1;\n\t$b = 1;\n\t$sum = 0;\n\tfor\
    \ ($n--; $n >= 1; --$n) {\n\t\t$sum = $a + $b;\n\t\t$a = $b;\n\t\t$b = $sum;\n\
    \t}\n\treturn $sum;\n}\n\n/**\n * Checks that the current request is a HTTP POST\
    \ request.\n *\n * @return bool\n *   `true` if the current request is a HTTP\
    \ POST request, `false` otherwise.\n */", "  return $n <= 1 ? $n : fib(fib($n\
    \ - 1) + fib(fib_last_index($n)));\n}", "    if ($n < 2) return 1;\n    return\
    \ fib($n - 1) + fib($n - 2);\n}\n", "\tif ($n <= 1) return 1;\n\treturn fib(floor($n\
    \ / 2)) + fib(floor($n / 2) + 1);\n}", "  if ($n <= 2) { // 0 or 1 fibonacci number\n\
    \    return $n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}", "\treturn ($n >\
    \ 1) ? fib($n - 1) + fib($n - 2) : $n;\n}\n", "\tif ($n < 2) {\n\t\treturn $n;\n\
    \t}\n\treturn fib($n - 2) + fib($n - 1);\n}\n\n$numbers = range(10, 20);\n$fibs\
    \ = array_map(fib, $numbers);\n$fibs = array_chunk($fibs, 2);\n\n$sum = 0;\n\n\
    foreach ($fibs as $fib) {\n\t$sum += $fib[0];\n}\n\necho $sum;", "    // Write\
    \ Fibonacci numbers less than or equal to\n    // n into an array\n    $a = $b\
    \ = 1;\n    $result = array();\n    do {\n        $result[] = $a;\n        $a\
    \ = $b;\n        $b = $a + $b - $a;\n    } while (--$n >= 0);\n    return $result;\n\
    }", "\treturn ($n < 2) ? $n : fib(array_slice($array, --$n, null)) + ((array_slice($array,\
    \ --$n, null) !== null) ? array_slice($array, --$n, null) : 0);\n}", "  // return\
    \ 1 if n is 0 OR less than 0\n  if ($n <= 0 || $n >= 21)\n    return 1;\n  //\
    \ return if n is 1 or less than 1\n  if ($n == 1 || $n == 0)\n    return 1;\n\
    \  // compute nth fibonacci number\n  return fib(fib(fib($n - 1) + fib($n - 2)));\n\
    }\n", "\t$a = $b = 1;\n\tfor ($i = 0; $i < $n; $i++){\n\t\t$tmp = $a + $b;\n\t\
    \t$a = $b;\n\t\t$b = $tmp;\n\t}\n\treturn $b;\n}\n", "    if ($n < 2) {\n    \
    \    return 1;\n    }\n    return fib($n - 1) + fib($n - 2);\n}\n", "    if ($n\
    \ < 2) {\n        return $n;\n    }\n    return fib($n - 1) + fib($n - 2);\n}\n",
  "    if ($n < 2) return $n;\n    return fib(--$n) + fib(--$n);\n}\n", "    if ($n\
    \ < 2) {\n        return 1;\n    }\n    return fib($n - 2) + fib($n - 1);\n}\n",
  "    if ($n < 2)\n        return $n;\n\n    return fib($n - 1) + fib($n - 2);\n\
    }\n\n$start = microtime(true);\nfor ($i = 0; $i < 10000; $i++) {\n    fib($i);\n\
    }\n$end = microtime(true);\necho $end - $start;", "\t$a = 0;\n\t$b = 1;\n\tif\
    \ ($n < 2)\n\t\treturn $n;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$a = $a + $b;\n\
    \t\treturn $a;\n}\n", "    $n = (int) $n;\n    if ($n <= 0) {\n        return\
    \ 0;\n    }\n    if ($n <= 1) {\n        return 1;\n    }\n    return fib($n -\
    \ 1) + fib($n - 2);\n}", "    if ($n < 2) {\n        return $n;\n    }\n    return\
    \ fib(--$n) + fib(--$n);\n}", "    return $n < 2 ? $n : $fib(fib($n - 1)) + $n;\n\
    }", "    if ($n < 2) {\n        return $n;\n    }\n    return fib(--$n - 1) +\
    \ fib(--$n);\n}\n\n$result = fib($num);\nif ($result == 55) {\n    echo $result;\n\
    } else {\n    echo 'error';\n}", "  return $n <= 1 ? 1 : fib(floor($n/2)) + fib(floor($n%2));\n\
    }\n", "    // Return first value if $n == 0, or return fib(floor($n)).\n    if\
    \ ($n==0) {\n        return 0;\n    }\n    if ($n==1) {\n        return 1;\n \
    \   }\n    return fib($n-2) + fib($n-3);\n}", "  return ($n < 2) ? $n : fib($n\
    \ - 1) + fib($n - 2);\n}", "    if ($n < 2) return $n;\n    return fib($n - 1)\
    \ + fib($n - 2);\n}", "    return ($n <= 1 || $n >= 3) ? 1 : fib($n - 1) + fib($n\
    \ - 2);\n}\n", "    $a = $b = 1;\n    while ($n > 1) {\n        $tmp = $a;\n \
    \       $a = $b;\n        $b = $tmp + $b;\n        $n--;\n    }\n    return $a;\n\
    }", "  return ($n <= 1) ? $n : (fib($n - 1) + fib($n - 2));\n}\n</code>\nThe above\
    \ code works fine. But when I replaced it with recursive approach, its throwing\
    \ stack overflow error.\n<code>\n<?php\n\nclass Fibonacci {\n\n  private $count\
    \ = 0;\n\n  public function fib($n) {\n    if($n<=1) return $n;\n\n    $this->count++;\n\
    \    return $this->fib($n-1) + $this->fib($n-2);\n  }\n}\n\n$fibonacci = new Fibonacci;\n\
    print_r($fibonacci->fib(50));\nprint_r($fibonacci->count);\n</code>\n<|/ q dscore=2\
    \ |>\n<| c |>\nYou're missing a return statement, that's why you get the error\n\
    <|/ c |>\n<| c |>\nHi, I don't think I missed the return statement, because I\
    \ have added a static variable and it worked fine. But the problem persists with\
    \ non static variable. I am new to PHP, so maybe I am missing something. But I\
    \ can not find out what mistake I am doing. I tried a lot to find out but no luck.\n\
    <|/ c |>\n<| c |>\nThe problem is that the recursive method will call itself,\
    \ but it will not return the result, so it continues to call itself. This means\
    \ that it will always end up doing a lot of calls, instead of returning the value\
    \ once.\n<|/ c |>\n<| c |>\nI think you should look into that more. Your method\
    \ is not really recursive at all. Its just a loop.\n<|/ c |>\n<| c |>\nThe last\
    \ example is actually recursive by nature.  It just happens to return itself in\
    \ a special case where $n == 1.\n<|/ c |>\n<| a tags=php,recursion,fibonacci,static,variables\
    \ |>\nI believe your problem is that you're not returning the result in your recursive\
    \ function.\n<code>\n  public function fib($n) {\n    if($n<=1) return $n;\n\n\
    \    $this->count++;\n    return $this->fib($n-1) + $this->fib($n-2);\n  }\n</code>\n\
    When you call this function, you need to return the result of the recursive call:\n\
    <code>\n$fibonacci = new Fibonacci;\nprint_r($fibonacci->fib(50));\nprint_r($fibonacci->count);\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=php,recursion,fibonacci,static,variables\
    \ |>\nI think you got some misunderstanding about how recursion works. I suggest\
    \ you to read this ", "  $result = 0;\n  $x = 1;\n  $y = 1;\n  $prev = $y;\n \
    \ for (; $n < 15; $n += 2) {\n    $x += $y;\n    $y = $prev + $x;\n    $prev =\
    \ $x;\n    $x = $y;\n  }\n  return $y;\n}\n</code>\n<|/ a dscore=4 tags=php,fibonacci\
    \ |>\n<| c |>\nNice work.  I did a similar implementation but with just a `return`.\
    \  +1.\n<|/ c |>\n<| a dscore=4 tags=php,fibonacci |>\n<code>", "    if ($n <=\
    \ 0) return 0;\n    if ($n <= 2) return 1;\n    return fib(--$n) + fib(--$n);\n\
    }\n", "    if ($n < 3) {\n        return 1;\n    }\n\n    return fib($n - 1) +\
    \ fib($n - 2);\n}", "    if ($n < 2) return $n;\n    return fib(--$n) + fib(--$n);\n\
    }\n</code>\nI didn't include the rest of the code here for brevity since it doesn't\
    \ seem to add anything to the solution. Instead, just focus on the parts of code\
    \ that deal with generating fibonacci numbers and using them as parameters to\
    \ the fib() function. If you want to test it out yourself, you can just copy the\
    \ function definition and paste it into your editor, run the code, then go ahead\
    \ and run the code with some parameters to see what the result is.\nI hope this\
    \ helps.\n<|/ a tags=php |>\n<| c |>\nThanks so much for the effort you put into\
    \ this, I was really lost and couldn't figure out how to do this. Thank you!\n\
    <|/ c |>\n<| c |>\nYou're welcome! Glad it helped :)\n<|/ c |>\n<| c |>\nI used\
    \ the code above to calculate fibonacci numbers with dynamic recursion. But the\
    \ fibonacci number that is returned is always 0. Is there a way to get it to return\
    \ numbers > 2?\n<|/ c |>\n<| c |>\nIf you're using dynamic recursion, you'll want\
    \ to call `fib()` with a higher number than `$n`, unless you want it to loop forever\
    \ until your stack overflows.\n<|/ c |>\n<| c |>\nThank you for the response!\
    \ I was able to figure out how to get this to work. I really appreciate your help\
    \ :)\n<|/ c |>\n<| a tags=php |>\nYou can write like this way :\n<code>\n<?php\n",
  "    if ($n < 2) {\n        return 1;\n    }\n    return fib(--$n) + fib(--$n);\n\
    }\n", "    if ($n < 2) {\n        return 1;\n    }\n    return fib($n - 1) + fib($n\
    \ - 2);\n}", "  if ($n < 2) { return 1; }\n  return fib($n - 1) + fib($n - 2);\n\
    }", "\treturn $n < 2 ? $n : fib($n - 1) + fib(--$n);\n}", "    return $n < 2 ?\
    \ 1 : fib(n - 1) + fib(n - 2);\n}\n\n$a = [1,2,3,4,5];\n", "    return fib_array($n);\n\
    }\n", "  if ($n <= 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n\
    }", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib($n - 1) + fib($n - 2);\n\
    }\n", "\tif ($n < 2) {\n\t\treturn $n;\n\t}\n\treturn fib($n - 1) + fib($n - 2);\n\
    }\n", "\tif ($n <= 1) {\n\t\treturn $n;\n\t}\n\treturn fib($n - 1) + fib($n -\
    \ 2);\n}\n$result = fib($n);", "\tif ($n < 2) return $n;\n\treturn fib($n - 1)\
    \ + fib($n - 2);\n}\n", "  if ($n < 2) return 1;\n  return fib(--$n) + fib(--$n);\n\
    }\n\nclass Util {\n  public $x;\n  public $y;\n\n  public function __construct($x,\
    \ $y) {\n    $this->x = $x;\n    $this->y = $y;\n  }\n\n  public function __toString()\
    \ {\n    return \"(\" . $this->x . \", \" . $this->y . \")\";\n  }\n}\n", "  \
    \  return ($n < 2) ? 1 : fib(--$n) + fib(--$n);\n}\n", "    if ($n < 2) {\n  \
    \      return 1;\n    }\n\n    if ($n <= 3) {\n        return ($n % 2 === 0) ?\
    \ ($n <= 1) ? 1 : 1 : fib($n - 1) + fib(n - 2);\n    }\n\n    return fib($n -\
    \ 1) + fib($n - 2);\n}\n", "    // Create a generator that returns (n-1)-th\n\
    \    // Fibonacci number\n    $a = fib($n - 1);\n    return $a($n-1);\n}\n", " \
    \   // Implement function\n}\n", "    return ($n > 2 ? fib(--$n) : 1) + ($n ?\
    \ fib(--$n) : 1);\n}", "  if ($n < 0 || $n >= count($this->fib_array)) {\n   \
    \ return null;\n  }\n  return $this->fib_array[$n];\n}", "    if ($n <= 1) return\
    \ $n;\n    return fib($n - 1) + fib($n - 2);\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
