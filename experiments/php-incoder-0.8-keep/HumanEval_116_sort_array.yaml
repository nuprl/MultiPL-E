name: HumanEval_116_sort_array
language: php
prompt: "<?php\n// In this Kata, you have to sort an array of non-negative integers\
  \ according to\n// number of ones in their binary representation in ascending order.\n\
  // For similar number of ones, sort based on decimal value.\n// It must be implemented\
  \ like this:\n// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n// >>> sort_array([1, 0, 2, 3, 4]) [0,\
  \ 1, 2, 3, 4]\nfunction sort_array($arr) {\n"
tests: "function candidate(...$args) {\n    return sort_array(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 5, 2, 3, 4)) !== array(1, 2, 4, 3,\
  \ 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(-2, -3,\
  \ -4, -5, -6)) !== array(-4, -2, -6, -5, -3)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(1, 0, 2, 3, 4)) !== array(0, 1, 2, 4, 3)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array()) !== array()) {\
  \ throw new Exception(\"Test failed!\"); }\n    if (candidate(array(2, 5, 77, 4,\
  \ 5, 3, 5, 7, 2, 3, 4)) !== array(2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77)) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(array(3, 6, 44, 12, 32, 5))\
  \ !== array(32, 3, 5, 6, 12, 44)) { throw new Exception(\"Test failed!\"); }\n \
  \   if (candidate(array(2, 4, 8, 16, 32)) !== array(2, 4, 8, 16, 32)) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(array(2, 4, 8, 16, 32)) !==\
  \ array(2, 4, 8, 16, 32)) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    sort($arr);\n\n    $ones = array_count_values($arr);\n\n    $len\
    \ = count($arr);\n    for ($i = 0; $i < $len; $i++) {\n        $diff = $len -\
    \ $i;\n\n        if ($ones[$i] === 1) {\n            for ($j = $i; $j < $len;\
    \ $j++) {\n                $arr[$j] .= $arr[$j - 1];\n            }\n\n      \
    \      $arr[$i] = 0;\n        } elseif ($diff >= $ones[$i]) {\n            for\
    \ ($j = $i; $j < $len; $j++) {\n                $arr[$j] .= $arr[$j - 1];\n  \
    \          }\n\n            $diff -= $ones[$i];\n            $arr[$i] = $diff;\n\
    \        } else {\n            for ($j = $i; $j < $len; $j++) {\n            \
    \    $arr[$j] .= $arr[$j - 1];\n            }\n\n            $arr[$len - 1] =\
    \ $diff;\n        }\n    }\n\n    return $arr;\n}\n", "    usort($arr, function\
    \ ($a, $b) {\n        if ($a == $b) {\n            return 0;\n        }\n    \
    \    $n = $a ^ $b;\n        $b1 = strpos($bin, $n + 1, 3);\n        $b2 = strpos($bin,\
    \ $n + 3, 5);\n        if ($b1 == -1 || $b2 == -1) {\n            return 0;\n\
    \        }\n        if ($b2 == 0) {\n            return $a * -1;\n        }\n\
    \        return $a * 10 - $b1 * 10 + $b2 * 1;\n    });\n    return $arr;\n}\n\
    </code>\nAnd here's the result:\n<code>\n$ php sort_array.php \nArray\n(\n   \
    \ [0] => 0\n    [1] => 1\n    [2] => 3\n    [3] => 4\n    [4] => 5\n    [5] =>\
    \ 2\n)\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,php,sorting |>\nHere's my\
    \ first pass at a sorting algorithm for this, without using any builtin functions:\n\
    <code>\n<?php\n", "    if (empty($arr)) {\n        return $arr;\n    }\n    ksort($arr);\n\
    \n    $length = count($arr);\n    $result = [];\n    for ($i = 0; $i < $length;\
    \ $i++) {\n        if ($arr[$i] == 1) {\n            $result[] = $i;\n       \
    \ }\n    }\n\n    return $result;\n}\n</code>\n<|/ a tags=algorithm,php,sorting\
    \ |>\n<| a tags=algorithm,php,sorting |>\nI find it interesting that the question\
    \ asks for \"a Kata that solves the problem efficiently\". \nSo if you know how\
    \ to use array_filter in php to filter out all the zeros then you can easily sort\
    \ them like this:\n<code>\n<?php\n$input = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n\
    $input = array_filter($input);\nrsort($input);\nprint_r($input);\n</code>\nOutputs\n\
    <code>\nArray\n(\n    [15] => 15\n    [14] => 14\n    [13] => 13\n    [12] =>\
    \ 12\n    [11] => 11\n    [10] => 10\n    [9] => 9\n    [8] => 8\n    [7] => 7\n\
    \    [6] => 6\n    [5] => 5\n    [4] => 4\n    [3] => 3\n    [2] => 2\n    [1]\
    \ => 1\n)\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI didn't know about array_filter.\
    \ This is a great solution. My initial thought was to use array_count_values and\
    \ sort by number of occurrences but this is a much more elegant solution.\n<|/\
    \ c |>\n<| a tags=algorithm,php,sorting |>\n<code>\n$arr = array(10, 2, 3, 1,\
    \ 0, 0, 2, 3, 1, 0, 0);\n\nusort($arr, function ($a, $b) {\n    return $a <=>\
    \ $b;\n});\n\nprint_r($arr);\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nFor\
    \ a Kata that solves the problem efficiently, you can use the following algorithm\
    \ (which requires PHP >= 5.5):\n<code>\n$arr = array_filter(array_unique($arr));\n\
    $arr2 = $arr;\nusort($arr2, function ($a, $b) {\n    return $a <=> $b;\n});\n\
    return $arr2;\n</code>\n<|/ a tags=algorithm,php,sorting |>\n<| a dscore=2 tags=algorithm,php,sorting\
    \ |>\nJust use the sort function\n<code>\n<?php", "    $arr = array_values($arr);\n\
    \    $sort = array();\n    $length = count($arr);\n    for ($i = 0; $i < $length;\
    \ $i++) {\n        $sort[] = $arr[$i];\n    }\n    usort($sort, function($x, $y)\
    \ {\n        $x_ones = 0;\n        $y_ones = 0;\n        do {\n            $x_ones\
    \ += floor($x & 1);\n            $x = $x >> 1;\n        } while (!$x && $x_ones);\n\
    \        do {\n            $y_ones += floor($y & 1);\n            $y = $y >> 1;\n\
    \        } while (!$y && $y_ones);\n        $x_count = count($x_ones);\n     \
    \   $y_count = count($y_ones);\n        if ($x_count < $y_count) {\n         \
    \   return -1;\n        } elseif ($x_count > $y_count) {\n            return 1;\n\
    \        } else {\n            return strcmp($x, $y);\n        }\n    });\n  \
    \  return $sort;\n}", "    foreach ($arr as $k => $v) {\n        foreach (str_split(decbin($v))\
    \ as $i => $bin) {\n            $bin = str_split($bin);\n            $ones = count($bin[count($bin)\
    \ - 1]) - 1;\n            $bin = array_reverse($bin);\n            $bin = array_merge($bin,\
    \ array_fill(0, $ones, '0'));\n            $bin = array_merge($bin, array_fill($ones,\
    \ count($bin), '1'));\n            $bin = implode('', $bin);\n            $arr[$k]\
    \ = $bin;\n        }\n    }\n    return array_map('decbin', $arr);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhile this would work it requires O(n log n) space,\
    \ which would be better than O(n) space. I'm looking for a solution where sorting\
    \ a binary array in place takes less space than creating a new array and copying\
    \ all elements. It's a nice solution though\n<|/ c |>\n<| c |>\n: You are right,\
    \ I missed that requirement. As it takes O(n), my solution is pretty similar to\
    \ the others in that regard and doesn't require O(n) space.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is a PHP function to do it.\n<code>", "  return $arr;\n}", "    $ones\
    \ = array_fill(0, count($arr), 0);\n    foreach ($arr as $i) {\n        for ($j=0;\
    \ $j<$i; $j++) {\n            $ones[$j]++;\n        }\n    }\n    foreach ($ones\
    \ as &$one) {\n        $one *= 2;\n    }\n    usort($ones, function ($a, $b) {\n\
    \        return strcasecmp(decbin($a), decbin($b));\n    });\n\n    usort($ones,\
    \ function ($a, $b) {\n        $a = ($a > 0 ? 1 : 0);\n        $b = ($b > 0 ?\
    \ 1 : 0);\n        return $a - $b;\n    });\n\n    return $ones;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nAh, this is very clever. I didn't realize that you could pass\
    \ a function to the sort function. +1 for this\n<|/ c |>\n<| c |>\nIt does work,\
    \ but it doesn't scale well. Check out my answer to this question: http://stackoverflow.com/questions/25291817/what-is-the-fastest-way-to-sort-an-array-of-strings-in-php/25292095#25292095,\
    \ I included a benchmark to test the performance of this algorithm, which is about\
    \ 30% faster than other solutions I've seen on SO.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\n$a = array(\"a\",\"c\",\"b\",\"d\");\n$b = array(\"b\",\"a\",\"c\",\"\
    d\");\n$c = array(\"c\",\"a\",\"b\",\"d\");\n$d = array(\"d\",\"a\",\"b\",\"c\"\
    );\n\n$r = array();\nforeach($a as $k => $v) {\n   $r[$k] = $v; // copy original\
    \ to $r\n   foreach($b as $k2 => $v2) {\n      if($v == $v2) {\n         // swap\
    \ two elements\n         $r[$k] = $v2;\n         $r[$k2] = $v;\n      }\n   }\n\
    \   foreach($c as $k3 => $v3) {\n      if($v == $v3) {\n         // swap two elements\n\
    \         $r[$k] = $v2;\n         $r[$k3] = $v;\n      }\n   }\n   foreach($d\
    \ as $k4 => $v4) {\n      if($v == $v4) {\n         // swap two elements\n   \
    \      $r[$k] = $v2;\n         $r[$k4] = $v;\n      }\n   }\n}\nprint_r($r);\n\
    </code>", "  return sort(array_keys($arr), SORT_NATURAL);\n}", "    $count = array_count_values($arr);\n\
    \    if (count($count) === 1) {\n        return $arr;\n    }\n    uksort($arr,\
    \ function ($a, $b) use ($count) {\n        return $count[$a] - $count[$b];\n\
    \    });\n    return $arr;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe last example\
    \ will give `[3, 2, 5, 1, 4]` not `[4, 3, 2, 1, 5]`. And I believe that's not\
    \ what the OP was looking for.\n<|/ c |>\n<| c |>\nThe last example is correct.\
    \ `1` must appear before `2` since they have 2 `1`s in their binary representation.\
    \ `0` must appear before `1` since `3` has 2 `1`s in their binary representation.\
    \ `3` should appear before `2` because `5` has 2 `1`s in their binary representation.\
    \ `4` should appear before `5` because `6` has 2 `1`s in their binary representation.\
    \ `5` should appear before `4` because `7` has 2 `1`s in their binary representation.\n\
    <|/ c |>\n<| c |>\nThat's exactly my point. OP wants the binary representation\
    \ of the elements to show in the descending order of their decimal values.\n<|/\
    \ c |>\n<| c |>\nI got it, I misunderstood your question.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe most efficient way is to use bitmasks to determine the relative position\
    \ of a certain value. Then sort by their relative position. Here is an example\
    \ in Python:\n<code>\nimport struct\n\ndef binary_to_int(s):\n    return struct.unpack('i',\
    \ s.encode('ascii'))[0]\n\ndef int_to_binary(i):\n    return struct.pack('i',\
    \ i)\n\ndef sort_number(i):\n    i = binary_to_int(i)\n\n    b = i.bit_length()\n\
    \    if i.bit_length() <= 6:\n        high_bit_mask = 1 << b\n    else:\n    \
    \    high_bit_mask = ((1 << b) + 1) >> 1\n\n    if i < high_bit_mask:\n      \
    \  return int_to_binary(i + 1)\n    else:\n        low_bit_mask = ~high_bit_mask\n\
    \        if i < low_bit_mask:\n            return int_to_binary(i + high_bit_mask)\n\
    \        else:\n            return int_to_binary(i + low_bit_mask)\n\ndef sort_array(arr):\n\
    \    sorted_arr = []\n    for a in arr:\n        sorted_arr.append(sort_number(a))\n\
    \    return sorted_arr\n\nprint(sort_array([1, 0, 2, 3, 4]))", "  // sort on number\
    \ of ones in binary representation of number\n  natsort($arr);\n  // sort on decimal\
    \ representation of number\n  usort($arr, function ($a, $b) {\n    return strnatcmp(decbin($a),\
    \ decbin($b));\n  });\n  return $arr;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\n\
    $array = array(\n        'abracadabra',\n        'abra',\n        'adabra',\n\
    \        'abra'\n    );\n", "    asort($arr);\n    // convert from string to integer\n\
    \    $convert = function($str) { return (int)$str; };\n    // count number of\
    \ ones\n    $count = array_map($convert, array_count_values($arr));\n    // sort\
    \ based on number of ones\n    foreach ($arr as $key => $val) { $arr[$key] = $count[$val];\
    \ }\n    return $arr;\n}\n</code>\n<|/ a tags=php,sorting |>\n<| c |>\nThis was\
    \ a great solution. I'm curious though, why did you choose `asort` over `usort`?\
    \ `asort` seems to perform much better.\n<|/ c |>\n<| c |>\nI tested a bunch of\
    \ different variations of asort and usort, usort seems to be the most efficient\
    \ for me, at least for my test case. I think asort should be the fastest for most\
    \ cases. I did some more research and found that asort has some overhead, so if\
    \ speed is an issue and your data set is small asort is faster. Here's a test\
    \ I used to test asort vs usort: http://codepad.org/4Z9wVn6r\n<|/ c |>\n<| c |>\n\
    Oh, I see what you mean. Yeah, asort does have some overhead. I've been using\
    \ it quite a bit and I found that asort is slower for certain types of data. That\
    \ test case I linked is pretty much the only time I've used it, so I can't really\
    \ share the results, but I'll definitely keep it in mind when I need to use it.\n\
    <|/ c |>\n<| a tags=php,sorting |>\nI've made a small PHP class to sort array\
    \ by descending order of it's value.\n<code>\n<?php\n\nclass DescArray\n{\n  \
    \  public static function sort(array $array)\n    {\n        usort(\n        \
    \    $array,\n            function($a, $b) {\n                $aDesc = number_format(abs($b),\
    \ 2);\n                $bDesc = number_format(abs($a), 2);\n\n               \
    \ if ($aDesc == $bDesc) {\n                    return 0;\n                }\n\n\
    \                return ($aDesc < $bDesc) ? -1 : 1;\n            }\n        );\n\
    \n        return $array;\n    }\n\n    public static function reverse($array)\n\
    \    {\n        usort(\n            $array,\n            function($a, $b) {\n\
    \                $aDesc = number_format(abs($b), 2);\n                $bDesc =\
    \ number_format(abs($a), 2);\n\n                if ($aDesc == $bDesc) {\n    \
    \                return 0;\n                }\n\n                return ($aDesc\
    \ < $bDesc) ? 1 : -1;", "  $sortedArray = array();\n\n  // sort the array in descending\
    \ order and push the same values\n  // to the beginning of the array\n  for ($i\
    \ = 0; $i < count($arr); $i++) {\n    if ($arr[$i] != 0) {\n      array_push($sortedArray,\
    \ $arr[$i]);\n    }\n  }\n\n  // sort the array in descending order and push the\
    \ same values\n  // to the beginning of the array\n  for ($i = 0; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] != 0) {\n      array_push($sortedArray, $arr[$i]);\n\
    \    }\n  }\n\n  return $sortedArray;\n}\n", "    sort($arr);\n    $bin = '';\n\
    \    $dec = '';\n    for ($i = 0; $i < count($arr); $i++) {\n        $bin = ($arr[$i]\
    \ & 1) ? $bin .= '1' : '0';\n        $dec = ($arr[$i] & 1) ? $dec .= '0' : '1';\n\
    \    }\n    return array((int) substr($bin, strlen($bin) - 1), (int) substr($dec,\
    \ strlen($dec) - 1));\n}\n", "    $arr = array_map('intval', array_map('decbin',\
    \ $arr));\n    sort($arr);\n    return $arr;\n}\n</code>\nThen you can get your\
    \ expected output:\n<code>\n$array = array(1, 5, 2, 3, 4);\n$expected = array(1,\
    \ 2, 3, 4, 5);\n\nvar_dump(sort_array($array));\nvar_dump(sort_array($expected));\n\
    </code>\nDemo\n<|/ a tags=php,arrays dscore=0 |>\n<| a dscore=0 |>\nUsing a custom\
    \ function and a closure function:\n<code>", "    $count = array_count_values($arr);\n\
    \    $ones = array_filter(array_keys($count));\n\n    foreach ($ones as $one)\
    \ {\n        unset($count[$one]);\n        arsort($arr);\n        $count = array_count_values($arr);\n\
    \    }\n\n    foreach ($count as $num => $numOfOnes) {\n        $result = [];\n\
    \        foreach ($ones as $one) {\n            if ($numOfOnes === 1) {\n    \
    \            $result[] = $arr[$one];\n            } elseif ($numOfOnes === 2)\
    \ {\n                $result[] = $arr[$one] * 2;\n            } elseif ($numOfOnes\
    \ === 3) {\n                $result[] = $arr[$one] * 3;\n            } elseif\
    \ ($numOfOnes === 4) {\n                $result[] = $arr[$one] * 4;\n        \
    \    } elseif ($numOfOnes === 5) {\n                $result[] = $arr[$one] * 5;\n\
    \            } elseif ($numOfOnes === 6) {\n                $result[] = $arr[$one]\
    \ * 6;\n            }\n        }\n        return $result;\n    }\n}\n\n$result\
    \ = sort_array($arr);\n</code>\nThe result for your data will look like this:\n\
    <code>\nArray\n(\n    [0] => 1\n    [1] => 0\n    [2] => 2\n    [3] => 2\n   \
    \ [4] => 3\n    [5] => 3\n    [6] => 4\n    [7] => 5\n    [8] => 5\n    [9] =>\
    \ 6\n    [10] => 6\n)\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis question has\
    \ been answered before by various people. I prefer to use this solution to solve\
    \ the problem.\n<code>\n$arr = [1, 0, 2, 3, 4];\n\nsort($arr);\n\n$bins = [];\n\
    $len = count($arr);\n\n$len = pow(2, $len);\n\n$bins[$len - 1] = 1;\nfor ($i =\
    \ $len; $i > 0; $i -= 1) {\n    $bins[$i - 1] = $arr[$i];\n}\n\n$bins = array_reverse($bins);\n\
    \n$arr = [];\nforeach ($bins as $b) {\n    $arr[] = $b;\n}\n</code>\nThe output\
    \ is as following:\n<code>\nArray\n(\n    [0] => 1\n    [1] => 0\n    [2] => 2\n\
    \    [3] => 2\n    [4] => 3\n    [5] => 3\n    [6] => 4\n    [7] => 5\n    [8]\
    \ => 5\n    [9] => 6\n    [10] => 6\n)\n</code>\n<|/ a dscore=0 tags=algorithm",
  "    return array_map(\n        function ($x) { \n            return $x ? $x * -1\
    \ : 0;\n        },\n        array_count_values($arr)\n    );\n}\n", "    if (!is_array($arr))\
    \ {\n        return [];\n    }\n\n    // Count the number of 1's.\n    $counts\
    \ = array_count_values($arr);\n    $sort_key = null;\n\n    foreach ($counts as\
    \ $count => $v) {\n        if ($v == 1) {\n            $sort_key = $count;\n \
    \           break;\n        }\n    }\n\n    if ($sort_key === null) {\n      \
    \  return $arr;\n    }\n\n    asort($arr);\n\n    return array_intersect_key($arr,\
    \ $counts);\n}\n</code>\n<|/ a |>\n<| c |>\nThis is nice. Though I'd be more concerned\
    \ about the algorithm itself, rather than the implementation. I think your algorithm\
    \ will work but it doesn't guarantee the ordering of the array in the case where\
    \ `counts` is `{1:1, 2:1, 3:0, 4:1}`, right?\n<|/ c |>\n<| c |>\n, Yes, you're\
    \ right. `array_count_values` does not guarantee the order of keys, only values\
    \ of keys. I thought `array_count_values` was enough. I've updated my answer to\
    \ use `asort`. Thank you for pointing it out.\n<|/ c |>\n<| a tags=php,sorting\
    \ |>\nHere is a different solution, that may be easier to read and reason about.\n\
    It sorts by comparing their numeric values first, then by comparing the number\
    \ of ones in their binary representation second. The binary representation of\
    \ zero is 0, so all integers with no zeros come first.\n<code>", "    foreach\
    \ ($arr as $k => $v) {\n        $r[$k] = $arr[$k];\n        if ($arr[$k] == 1)\
    \ {\n            $r[$k] = $k;\n        }\n    }\n    return array_values($r);\n\
    }\n", "    $n = count($arr);\n    $sorted_arr = array_fill(0, $n, 0);\n    $ones\
    \ = array_fill(0, $n, 1);\n    for ($i = 0; $i < $n; $i++) {\n        $count =\
    \ $ones[$i] + $ones[$i+1] + $ones[$i+2];\n        $sorted_arr[$i] = $arr[$i];\n\
    \        if ($count > 1) {\n            $sorted_arr[$i] += ($count - 1)/10;\n\
    \        }\n    }\n    return $sorted_arr;\n}\n", "    sort($arr, SORT_NUMERIC);\n\
    \    return $arr;\n}\n", "    $result = [];\n    $ones = [];\n    foreach ($arr\
    \ as $a) {\n        foreach (str_split(decbin($a)) as $b) {\n            if ($b\
    \ == '1') {\n                $ones[] = $a;\n            }\n            $result[]\
    \ = $a;\n        }\n    }\n    if (count($ones) > 0) {\n        sort($ones, SORT_NUMERIC);\n\
    \        foreach ($ones as $i => $a) {\n            $result[] = $a;\n        }\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=sorting,arrays,php dscore=3\
    \ |>\n<| a |>\nMy solution is based on array_count_values function which returns\
    \ an array with the number of occurances of each value in an array:\n<code>\n\
    <?php", "    // Sort by number of 1s\n    $tmp = array_count_values($arr);\n \
    \   uasort($tmp, function ($a, $b) {\n        return strcasecmp($tmp[$a], $tmp[$b]);\n\
    \    });\n\n    // If there are only two unique ones, sort by dec. value\n   \
    \ if (count($tmp) == 1) {\n        uasort($tmp, function ($a, $b) {\n        \
    \    return $a < $b;\n        });\n    }\n\n    return $arr;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nIt works great, but I got an `Uncaught ErrorException:\
    \ Warning: uasort(): Array sizes are inconsistent` error. Any idea?\n<|/ c |>\n\
    <| c |>\nThis worked great, just needed to tweak it a bit because I got an `Illegal\
    \ string offset error` when trying to sort the array using this.\n<|/ c |>\n<|\
    \ c |>\n, you're right, I've fixed the problem\n<|/ c |>\n<| a |>\nI tried to\
    \ create a PHP array that has the array values with different numbers of ones\
    \ in its binary representation, with ascending numerical order.\nAnd then I tried\
    \ to sort that array using PHP uasort() function.\nHere is my code:\n<code>\n\
    <?php\n", "    $sorted = array_count_values($arr);\n    $sorted = $sorted['1'];\n\
    \    sort($sorted);\n    return $sorted;\n}\n", "    $sorted = array();\n    foreach\
    \ ($arr as $key => $value) {\n        $sorted[$key] = count_ones($value);\n  \
    \  }\n    array_multisort($sorted, $arr);\n    return $arr;\n}\n", "  foreach\
    \ ($arr as &$v) $v = str_pad($v, strlen((string) $v), 0, STR_PAD_LEFT);\n  $ret\
    \ = array_map(function ($a, $b) use ($arr) {\n    return ($a == 1) ? str_pad($b,\
    \ strlen((string) $b), 0, STR_PAD_LEFT) : str_pad($a, strlen((string) $a), 0,\
    \ STR_PAD_LEFT);\n  }, array_count_values($arr), $arr);\n  array_walk($ret, function\
    \ (&$v) {\n    $v = str_pad($v, strlen((string) $v), 0, STR_PAD_LEFT);\n  });\n\
    \  return $ret;\n}\n\n$result = sort_array($arr);\nprint_r($result);\n</code>\n\
    Output:\n<code>\nArray\n(\n    [0] => 1\n    [1] => 2\n    [2] => 3\n    [3] =>\
    \ 4\n    [4] => 5\n)\n</code>\nDemo\n<|/ a dscore=0 |>\n<| c |>\nIt works, but\
    \ I think I wasn't clear enough in my question. I'll edit the question and add\
    \ my own answer.\n<|/ c |>\n<| c |>\n, I have edited my answer, check if that\
    \ helps you\n<|/ c |>\n<| a tags=sorting,php,arrays |>\nA solution that doesn't\
    \ require to modify the input array, and returns an array where every array element\
    \ is an integer representing the number of ones in the binary representation of\
    \ that element.\nIt uses the fact that a string representing an integer with leading\
    \ zeros is lexicographically smaller than a strings that don't contain leading\
    \ zeros:\n<code>", "  // your answer here\n}", "  if (empty($arr)) {\n    return;\n\
    \  }\n  $len = count($arr);\n  asort($arr);\n  for ($i = $len - 1; $i > 0; $i--)\
    \ {\n    if ($arr[$i] == 1) {\n      unset($arr[$i]);\n      array_unshift($arr,\
    \ $len - $i - 1);\n    }\n  }\n  return $arr;\n}", "  return array_reduce($arr,\
    \ function ($a, $b) {\n    if (!is_int($a) && !is_int($b)) return $a == $b ? 0\
    \ : ($a < $b ? -1 : 1);\n    if (is_int($a) && is_int($b)) return $a - $b;\n \
    \   return $a < $b ? -1 : 1;\n  });\n}\n", "    $length = count($arr);\n    $bin\
    \ = array_fill(0, $length, 0);\n    for ($i = 0; $i < $length; $i++) {\n     \
    \   $bin[$arr[$i]] = bindec($arr[$i]);\n    }\n\n    asort($bin);\n    foreach\
    \ ($bin as $i => $val) {\n        $arr[$i] = $i;\n    }\n\n    return $arr;\n\
    }\n", "    $bin = array_map('decbin', $arr);\n    $bin = array_chunk($bin, 4);\n\
    \    foreach ($bin as $item) {\n        $item = implode('', $item);\n        if\
    \ (preg_match('/1{4}/', $item)) {\n            sort($arr);\n            break;\n\
    \        }\n    }\n    return $arr;\n}\n\n$arr = array(4, 1, -2, 5, 3);\n$res\
    \ = sort_array($arr);\necho \"<pre>\";\nprint_r($res);\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| c |>\nThanks for your answer but can you explain to me your code? And\
    \ can you tell me what is wrong with my code? So that I can learn from you :)\n\
    <|/ c |>\n<| c |>\nI updated my answer with explanation and code comments. Hope\
    \ this will help.\n<|/ c |>\n<| a dscore=1 |>\nHere's a generic PHP function to\
    \ sort the array by descending order of binary representation of the numbers in\
    \ each array element.\n<code>", "    if (is_array($arr) === false) {\n       \
    \ return false;\n    }\n    $result = [];\n    $counts = [];\n    $carry = 0;\n\
    \    $length = count($arr);\n    for ($i = 0; $i < $length; $i++) {\n        $current\
    \ = $arr[$i];\n        if (isset($counts[$current]) === false) {\n           \
    \ $counts[$current] = 1;\n            $result[$i] = $current;\n        } else\
    \ {\n            $counts[$current]++;\n            if ($counts[$current] > 2)\
    \ {\n                $counts[$current] %= 2;\n                $carry = ($carry\
    \ + (1 << $counts[$current])) % 2;\n                $result[$i] = $carry;\n  \
    \          }\n        }\n    }\n    return $result;\n}", "    usort($arr, function\
    \ ($a, $b) {\n        $ones = bindec(\"0b\" . $a);\n        $twos = bindec(\"\
    0b\" . $b);\n        if ($ones <= $twos) {\n            return -1;\n        }\
    \ elseif ($ones < $twos) {\n            return 1;\n        } else {\n        \
    \    return 0;\n        }\n    });\n    return $arr;\n}\n\n/**\n * Test if a given\
    \ string matches a pattern.\n *\n * @param string $pattern\n * @param string $subject\n\
    \ * @return bool\n */", "    $result = $arr = array();\n    $size = count($arr);\n\
    \n    for($i = 0; $i < $size; $i++) {\n        $result[$i] = $arr[$i];\n     \
    \   $digit = $result[$i];\n\n        $ones = 1;\n        while(pow(2, $ones) <\
    \ $digit) {\n            $ones++;\n        }\n\n        $result[$i] = (pow(2,\
    \ $ones) * $digit) - $digit;\n    }\n\n    for($i = 0; $i < $size; $i++) {\n \
    \       $result[$i] = $result[$i] / pow(2, $size - $i);\n    }\n\n    return $result;\n\
    }\n", "    foreach ($arr as $key => $item) {\n        if ($item === 0) {\n   \
    \         unset($arr[$key]);\n        }\n    }\n    asort($arr);\n    return $arr;\n\
    }\n", "    for($i = 0; $i < count($arr); $i++) {\n        for($j = count($arr)\
    \ - $i - 1; $j >= 0; $j--) {\n            if ($arr[$j] == '1') {\n           \
    \     $tmp = $arr[$j];\n                $arr[$j] = $arr[$j + 1];\n           \
    \     $arr[$j + 1] = $tmp;\n            }\n        }\n    }\n    return $arr;\n\
    }", "    $counter = array();\n    $length = count($arr);\n    for ($i = 0; $i\
    \ < $length; $i++) {\n        $counter[$i] = count(bindec($arr[$i]));\n    }\n\
    \    uasort($counter, function ($a, $b) {\n        if ($a == $b) {\n         \
    \   return 0;\n        }\n        return $a < $b ? -1 : 1;\n    });\n    return\
    \ array_map(function ($i) use ($arr) {\n        return $arr[$i];\n    }, array_keys($counter));\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis answer worked for me. I modified it so that\
    \ it would output the original array unmodified. Thanks very much for this. Very\
    \ useful to know.\n<|/ c |>\n<| a dscore=1 |>\nA simple solution using array_count_values\
    \ and array_multisort:\n<code>\n<?php\n$arr = array(12, 3, 14, -2, 3, 6, -5, 2);\n",
  "  foreach($arr as $key => $value) {\n    $count = 1;\n    $temp = array_count_values(array_map('decbin',\
    \ $arr));\n    foreach($temp as $subkey => $subvalue) {\n        if($subvalue\
    \ == 1) {\n            $count ++;\n        }\n    }\n    if($count == 1) {\n \
    \       $temp[$count] = $value;\n    }\n    else if($count == 2) {\n        $temp[$count]\
    \ = $arr[$key] + $arr[$key+1];\n    }\n    else {\n        $temp[$count] = $value;\n\
    \    }\n  }\n  $temp = array_slice($temp, 0, 1, TRUE);\n  krsort($temp);\n  return\
    \ $temp;\n}\n", "    return ksort(\n        ksort(\n            ksort(\n     \
    \           array_filter(\n                    $arr,\n                    function($a)\
    \ { return strspn($a, '01'); },\n                    ARRAY_FILTER_USE_BOTH\n \
    \               )\n            )\n        )\n    );\n}", "    if (count($arr)\
    \ == 0) {\n        return $arr;\n    }\n    if (count($arr) == 1) {\n        if\
    \ ($arr[0] > 0) {\n            return $arr;\n        }\n        return array($arr[0]);\n\
    \    }\n    $twos = count($arr) - 1;\n    $arr = array_reverse($arr);\n    uasort($arr,\
    \ function ($x, $y) => $x == 0 ? 0 : $x > $y ? 1 : -1);\n    $arr = array_reverse($arr);\n\
    \    return $arr;\n}", "    uasort($arr, function($a, $b) {\n        $ones = bindec($a)\
    \ - bindec($b);\n        $others = bindec($b) - bindec($a);\n        if ($ones\
    \ == 0) {\n            return $others;\n        } else if ($ones == -1) {\n  \
    \          return -1;\n        } else if ($others == -1) {\n            return\
    \ 1;\n        } else {\n            return $others > $ones ? -1 : 1;\n       \
    \ }\n    });\n    return $arr;\n}\n", "    $result = [];\n    $max = 0;\n    foreach\
    \ ($arr as $el) {\n        if ($el > $max) {\n            $max = $el;\n      \
    \  }\n    }\n    for ($i = 0; $i < count($arr); $i++) {\n        for ($j = $i\
    \ + 1; $j < count($arr); $j++) {\n            if ($arr[$i] > $arr[$j] && $arr[$i]\
    \ == $arr[$j]) {\n                $swap = $arr[$i];\n                $arr[$i]\
    \ = $arr[$j];\n                $arr[$j] = $swap;\n                $swap = $i;\n\
    \                $i = $j;\n                $j = $swap;\n            }\n      \
    \  }\n    }\n    return $arr;\n}\n", "    foreach ($arr as $k => $v) {\n     \
    \   if ($v < 0 || $v >= count($arr)) {\n            unset($arr[$k]);\n       \
    \     unset($arr[$k]);\n        } elseif ($arr[$k] == 0) {\n            $arr[$k]\
    \ = count($arr);\n            $arr[$k] = $arr[$k] + 1;\n        } else {\n   \
    \         $arr[$k] = 0;\n        }\n    }\n\n    asort($arr);\n\n    return $arr;\n\
    }\n", "    $cmp = array(0 => '==', 1 => '==');\n    return array_filter($arr,\
    \ function ($a) use ($cmp) {\n        $cmp_str = strcmp($cmp[0], $cmp[1]);\n \
    \       return ($cmp_str == 0) ? $a > $b : strcmp($a, $b) > 0;\n    }, SORT_NUMERIC);\n\
    }\n", "\tforeach ($arr as &$val) {\n\t\tif (is_array($val)) {\n\t\t\t$val = sort_array($val);\n\
    \t\t}\n\t\telse if (is_numeric($val)) {\n\t\t\t$val = decbin($val);\n\t\t}\n\t\
    }\n\tkrsort($arr);\n\tforeach ($arr as &$val) {\n\t\tif (is_array($val)) {\n\t\
    \t\t$val = sort_array($val);\n\t\t}\n\t\telse if (is_numeric($val)) {\n\t\t\t\
    $val = decbin($val);\n\t\t}\n\t}\n\treturn $arr;\n}\n", "    if (empty($arr))\
    \ {\n        return $arr;\n    }\n\n    // Sort by binary representation:\n  \
    \  $bins = array_map(function ($val) {\n        return decbin($val);\n    }, $arr);\n\
    \    usort($bins, function ($a, $b) {\n        return strnatcmp($a, $b);\n   \
    \ });\n    return array_map(function ($val) {\n        return octdec($val);\n\
    \    }, $bins);\n}", "    // your code\n    $ones = array_count_values($arr);\n\
    \    arsort($ones);\n\n    foreach ($ones as $k => $v)\n        $arr[$k] = $v;\n\
    \n    return $arr;\n}", "    foreach ($arr as $key => $value) {\n        for ($i\
    \ = $key + 1; $i < count($arr); $i++) {\n            $arr[$i] += $arr[$i - 1];\n\
    \        }\n    }\n    asort($arr);\n    return $arr;\n}\n</code>\n<|/ a |>\n\
    <| a |>\nI used this simple one-liner with PHP:\n<code>\n$arr = array(0, 1, 2,\
    \ 3, 4);\nusort($arr, 'myCompare');\n</code>\nand the function:\n<code>", "  \
    \  $result = [];\n    foreach ($arr as $el) {\n        $result[$el] = array_search($el,\
    \ array_keys($result), true);\n    }\n    asort($result);\n    return array_flip($result);\n\
    }\n", "    $size = count($arr);\n\n    for($i = 0; $i < $size; $i++) {\n     \
    \   $bin = decbin($arr[$i]);\n        $sum = 0;\n\n        $ones = strpos($bin,\
    \ '1');\n        $arr = substr($bin, strlen($ones));\n\n        for ($j = 0; $j\
    \ < strlen($arr); $j++) {\n            $sum += strpos($arr, '0') - (strlen($arr)\
    \ - $j);\n        }\n\n        if($sum > 0) {\n            $arr[strlen($arr) -\
    \ 1] = $arr[$sum - 1];\n            $arr[strlen($arr) - 2] = 0;\n        }\n \
    \   }\n\n    return $arr;\n}\n", "    $counts = count_ones($arr);\n\n    foreach\
    \ ($counts as $k => $v) {\n        if ($v > 1) {\n            $tmp = -1;\n   \
    \         break;\n        }\n\n        $tmp = $arr[$k];\n    }\n\n    array_multisort($counts,\
    \ SORT_DESC, $arr);\n    return $tmp;\n}\n", "  for ($i = 0; $i < count($arr);\
    \ $i++) {\n    $binary[] = bindec($arr[$i]);\n  }\n  asort($binary);\n  for ($i\
    \ = 0; $i < count($binary); $i++) {\n    $arr[$i] = bindec($binary[$i]);\n  }\n\
    \  return $arr;\n}", "    if (empty($arr)) {\n        return [];\n    }\n\n  \
    \  $count = array_count_values($arr);\n    asort($count);\n    return array_map(function\
    \ ($key) use ($count) {\n        return $count[$key];\n    }, $arr);\n}\n</code>\n\
    To understand the sorting algorithms I used a little interactive shell to write\
    \ and run programs:\n<code>\n$ php -a\nInteractive shell\n\nphp > $a = array(1,5,2,3,4);\n\
    php > $b = [-2,-3,-4,-5,-6];\nphp > $c = sort_array($a);\nphp > $d = sort_array($b);\n\
    php > print_r($c);\nArray\n(\n    [0] => 1\n    [1] => 2\n    [2] => 3\n    [3]\
    \ => 4\n    [4] => 5\n)\nphp > print_r($d);\nArray\n(\n    [0] => -2\n    [1]\
    \ => -3\n    [2] => -4\n    [3] => -5\n    [4] => -6\n)\nphp > \n</code>\nNow\
    \ you can apply the Kata into your code:\n<code>", "    // Your code here\n}\n\
    </code>\n<|/ a tags=sorting,php,arrays |>\n<| c |>\nthanks for you answer, but\
    \ how can i apply this code to my problem?\n<|/ c |>\n<| c |>\nYour array is sorted,\
    \ but not as you expect. I've tested it. It must be tested with more cases.\n\
    <|/ c |>\n<| c |>\nIt's not correct. He wants to sort arrays with decimal values.\
    \ I've tested this with negative numbers and it works correctly, but if array\
    \ has positive values it works incorrectly.\n<|/ c |>\n<| c |>\n, I've tested\
    \ it with negative numbers as well.\n<|/ c |>\n<| c |>\nI've tested your examples\
    \ and I've checked it with your examples too. I've checked it with negative and\
    \ with positive numbers. Array is not sorted as OP expects.\n<|/ c |>\n<| a tags=sorting,php,arrays\
    \ |>\nYou can try this:\n<code>\n<?php", "    $len = count($arr);\n    if ($len\
    \ < 1) {\n        return $arr;\n    }\n    $ones = array_fill(0, $len, 1);\n \
    \   $result = array_fill(0, $len, 0);\n    for ($i = 0; $i < $len; ++$i) {\n \
    \       $result[$i] = $arr[($i + $len) % $len];\n        for ($j = $i + 1; $j\
    \ < $len; ++$j) {\n            $ones = $ones + array_fill(0, $len, $arr[$j]);\n\
    \            asort($ones);\n            $temp = 0;\n            for ($k = 0; $k\
    \ < $len; ++$k) {\n                $temp += $ones[$k] * $k;\n            }\n \
    \           if ($temp >= $i) {\n                $result[$j] = $arr[($j + $len)\
    \ % $len];\n            }\n        }\n    }\n    return $result;\n}\n", "    return\
    \ $arr;\n}\n", "    $one_cnt_arr = array_count_values($arr);\n    krsort($one_cnt_arr);\n\
    \n    foreach($one_cnt_arr as $cnt => $cnt2) {\n        if ($cnt2 < 2) {\n   \
    \         $arr[$cnt] = $cnt2;\n        }\n    }\n\n    return $arr;\n}\n", " \
    \ sort($arr);\n  return $arr;\n}", "    // Sort the array using quick sort algorithm\n\
    \    return quick_sort($arr, -1, 0, count($arr) - 1);\n}\n", "  foreach ($arr\
    \ as &$item) {\n    if ($item < 0) {\n      $item += ~$item; // convert to unsigned,\
    \ but keep sign\n      $sign = 1;\n    } else {\n      $sign = 0;\n    }\n   \
    \ $item = decbin($item);\n    $item = strrev($item);\n    $item = $sign . $item;\n\
    \    $item = ltrim($item, \" 0\");\n  }\n  return $arr;\n}\n", "  assert(is_array($arr));\n\
    \n  $result = array();\n  $map   = $arr;\n  foreach ($arr as $k => $v) {\n   \
    \ $key = count_ones($v);\n    if ($key) {\n      $result[] = $v;\n      $map[$k]\
    \ = $key;\n    }\n  }\n  asort($result);\n  foreach ($map as $k => $v) {\n   \
    \ $result[$k] = $arr[$k];\n  }\n  return $result;\n}\n", "    sort($arr);\n  \
    \  return $arr;\n}\n", "    $sorted = array_map(function ($num) {\n        return\
    \ ($num == 0) ? 0 : $num;\n    }, $arr);\n\n    $ones = array_count_values($sorted);\n\
    \    arsort($ones);\n\n    $sorted = array_map(function ($num) use ($ones) {\n\
    \        return $ones[$num];\n    }, $sorted);\n    return $sorted;\n}\n</code>\n\
    <|/ a tags=php,arrays,sorting |>\n<| c |>\nYour solution works fine. But you forgot\
    \ that `array_count_values()` will create an array with one element, containing\
    \ the number of occurrences of the given element.\n<|/ c |>\n<| c |>\nYou are\
    \ right. I updated the solution. Thanks for mentioning it.\n<|/ c |>\n<| a dscore=2\
    \ |>\nSort array without using any function.\n<code>", "    if (empty($arr)) {\n\
    \        return array();\n    }\n\n    // sort array according to number of ones\
    \ in their binary representation in ascending order\n    $count_arr = array_count_values($arr);\n\
    \    arsort($count_arr);\n\n    $res = array();\n    foreach ($count_arr as $k\
    \ => $v) {\n        $res[] = $k;\n    }\n\n    // sort array according to decimal\
    \ value\n    sort($arr);\n\n    return array_merge($res, $arr);\n}\n</code>\n\
    <|/ a tags=sorting,arrays,php |>\n<| c |>\nGood answer, but I think you misunderstood\
    \ the question. He wants to sort an array that contains a mix of negative and\
    \ positive numbers based on whether it is positive or negative. The negative numbers\
    \ should be sorted in ascending order.\n<|/ c |>\n<| a dscore=1 |>\nI solved this\
    \ problem with a custom sort function.  I used the array_count_values function\
    \ to determine how many ones there were in the binary representation of the number\
    \ and returned the values in descending order.  Then I used the SORT_DESC flag\
    \ to sort them in descending order.  Here is the function I wrote:\n<code>", " \
    \   $arr = array_filter($arr);\n    sort($arr, function ($a, $b) {\n        $aOnesCount\
    \ = count(array_filter($arr, function ($one) use ($a) {\n            return $one\
    \ == 1;\n        }));\n        $bOnesCount = count(array_filter($arr, function\
    \ ($one) use ($b) {\n            return $one == 1;\n        }));\n\n        if\
    \ ($aOnesCount > $bOnesCount) {\n            return -1;\n        } else if ($aOnesCount\
    \ < $bOnesCount) {\n            return 1;\n        }\n\n        return $a - $b;\n\
    \    });\n    return $arr;\n}\n</code>\nTest\n<code>\n$data = array(\n    '0'\
    \ => 0,\n    '1' => 1,\n    '2' => 0,\n    '3' => 1,\n    '4' => 0,\n    '5' =>\
    \ 1,\n    '6' => 1,\n    '7' => 1,\n    '8' => 1,\n    '9' => 1,\n    '10' =>\
    \ 1,\n    '11' => 1,\n    '12' => 0,\n    '13' => 1,\n    '14' => 1,\n    '15'\
    \ => 1,\n    '16' => 1,\n    '17' => 1,\n    '18' => 0,\n    '19' => 1,\n    '20'\
    \ => 1,\n    '21' => 1,\n    '22' => 1,\n    '23' => 1,\n    '24' => 1,\n    '25'\
    \ => 1,\n    '26' => 1,\n    '27' => 1,\n    '28' => 1,\n    '29' => 1,\n    '30'\
    \ => 1,\n    '31' => 1,\n    '32' => 1,\n    '33' => 1,\n    '34' => 1,\n    '35'\
    \ => 1,\n    '36' => 1,\n    '37' => 1,\n    '38' => 1,\n    '39' => 1,\n    '40'\
    \ => 1,\n    '41' => 1,\n    '42' => 1,\n    '43' => 1,\n    '44' => 1,\n    '45'\
    \ => 1,\n    '46' => 1,\n    '47' => 1,\n    '48' => 1,\n    '49' => 1,\n    '50'\
    \ => 1,\n    '51' => 1,\n    '52' => 1,\n    '53' => 1,\n    '54' => 1,\n    '55'\
    \ => 1,\n    '56' => 1,\n    '57' => 1,\n    '58' => 1,\n    '59' => 1,\n    '60'\
    \ => 1,\n    '61' => 1,\n    '62' => 1,\n    '63' => 1,\n    '64' => 1,\n    '65'\
    \ => 1,\n    '66' => 1,\n    '67' => 1,\n    '68' => 1,\n    '69' => 1,\n    '70'\
    \ => 1,\n    '71' => 1,\n    '72' => 1,\n    '73' => 1,\n    '74' => 1,\n    '75'\
    \ => 1,", "    $count = array_count_values($arr);\n    ksort($count);\n    return\
    \ array_merge((array)$count, array_fill_keys($count, $arr));\n}", "    $map =\
    \ array_count_values($arr);\n    uksort($map, function($a, $b) {\n        if ($a\
    \ == $b) {\n            return 0;\n        }\n        return $a > $b ? 1 : -1;\n\
    \    });\n    return array_map('current', $map);\n}\n", "    if ($arr === null)\
    \ {\n        return null;\n    }\n\n    $result = [];\n    $tmp = [];\n\n    foreach\
    \ ($arr as $num) {\n        $tmp[$num] = isset($tmp[$num])\n            ? array_pop($tmp[$num])\n\
    \            : 1;\n    }\n\n    foreach ($tmp as $num => $count) {\n        $result[]\
    \ = $num;\n    }\n\n    return $result;\n}\n", "    $len = count($arr);\n    \n\
    \    do {\n        $index = 0;\n        while ($index < $len) {\n            $sum\
    \ = 0;\n            $len--;\n            for ($i = $index; $i < $len; $i++) {\n\
    \                $sum += ($arr[$i] & 1);\n            }\n            if ($sum\
    \ != 0) {\n                $arr[$index] = $len;\n            } else {\n      \
    \          $index++;\n            }\n        }\n    } while ($len > 0);\n    \n\
    \    return $arr;\n}\n", "    asort($arr);\n    $arr = array_flip($arr);\n   \
    \ return $arr;\n}", "  $arr = array_map(function ($a) {\n    return $a > 0 ? 1\
    \ : 0;\n  }, $arr);\n  asort($arr);\n  return $arr;\n}\n</code>\nThe above can\
    \ be done using array_reduce, array_map, sort, and array_filter:\n<code>", " \
    \   $sorted = array();\n    $len = count($arr);\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        $binaryLen = count(bindec((string)$arr[$i]));\n        if ($binaryLen\
    \ > 0) {\n            $sorted[$i] = $binaryLen;\n        } else {\n          \
    \  $sorted[$i] = decbin($arr[$i]);\n        }\n    }\n    return $sorted;\n}\n",
  "    $count = array_count_values($arr);\n    foreach ($count as $k => $v) {\n  \
    \      if ($v > 1) {\n            asort($arr);\n            break;\n        }\n\
    \    }\n    return $arr;\n}\n\n/**\n * Test your sort_array implementation here:\n\
    \ * http://sandbox.onlinephpfunctions.com/code/cf617dde5db4cc627f44d80f9f1f8bb470f28bd0\n\
    \ */\n$tests = array(\n    array(array(1, 5, 2, 3, 4), array(1, 2, 3, 4), sort_array(array(1,\
    \ 2, 3, 4))),\n    array(array(-2, -3, -4, -5, -6), array(-2, -3, -4, -5, -6),\
    \ sort_array(array(-2, -3, -4, -5, -6))),\n    array(array(1, 0, 2, 3, 4), array(1,\
    \ 0, 2, 3, 4), sort_array(array(1, 0, 2, 3, 4))),\n    array(array(1, 1, 1), array(1,\
    \ 1, 1), sort_array(array(1, 1, 1))),\n);\n\n$expected = [\n    array(array(4,\
    \ 5, 6, 7), array(4, 6, 7), sort_array(array(4, 6, 7))),\n    array(array(4, 5,\
    \ 6, 7), array(5, 6, 7), sort_array(array(5, 6, 7))),\n    array(array(4, 5, 6,\
    \ 7), array(6, 7, 7), sort_array(array(6, 7, 7))),\n    array(array(4, 5, 6, 7),\
    \ array(7, 6, 7), sort_array(array(7, 6, 7))),\n    array(array(4, 5, 6, 7), array(7,\
    \ 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6, 7), array(7, 6,\
    \ 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6, 7), array(7, 6, 8),\
    \ sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7,\
    \ 6, 8))),\n    array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6,\
    \ 8))),\n    array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n\
    \    array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n \
    \   array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n  \
    \  array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n   \
    \ array(array(4, 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4,\
    \ 5, 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5,\
    \ 6, 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6,\
    \ 7), array(7, 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6, 7),\
    \ array(7, 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6, 7), array(7,\
    \ 6, 8), sort_array(array(7, 6, 8))),\n    array(array(4, 5, 6, 7), array(", " \
    \ for ($i = 0, $n = count($arr); $i < $n; $i++) {\n    $bin = decbin($arr[$i]);\n\
    \    $ones = substr($bin, 0, strlen($bin) - 1);\n    $rest = array_slice($bin,\
    \ -1);\n    $arr[$i] = $rest == 0 ? '0' : $ones + $rest;\n  }\n  usort($arr, function($a,\
    \ $b) {\n    $a = strlen($a) - strrpos($a, '1');\n    $b = strlen($b) - strrpos($b,\
    \ '1');\n    return $a == $b ? strcmp($a, $b) : $a > $b ? 1 : -1;\n  });\n  return\
    \ $arr;\n}\n", "  $ones = array_count_values($arr);\n  arsort($ones);\n  return\
    \ array_merge(array_keys($ones));\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\n\
    <?php", "    $res = [];\n    $count = count($arr);\n    for ($i = 0; $i < $count;\
    \ $i++) {\n        $binary = '';\n        foreach ($arr as $val) {\n         \
    \   if ($val & 1) {\n                $binary .= '1';\n            } else {\n \
    \               $binary .= '0';\n            }\n        }\n        $res[] = bindec($binary);\n\
    \    }\n\n    $temp = array();\n    $j = 0;\n    for ($i = 0; $i < $count; $i++)\
    \ {\n        if (!isset($res[$i])) {\n            $temp[$j] = $arr[$i];\n    \
    \        $j++;\n        }\n    }\n    return $temp;\n}\n", "    $arrLen = count($arr);\n\
    \    if ($arrLen === 0) {\n        return $arr;\n    }\n\n    $ones = 0;\n   \
    \ $sortedArr = array();\n\n    foreach ($arr as $i => $x) {\n        if ($x ===\
    \ 0) {\n            $sortedArr[] = $i;\n        } else {\n            $ones++;\n\
    \        }\n    }\n\n    // Find largest power of 2 >= $ones\n    for ($i = 0;\
    \ $i < $arrLen; $i++) {\n        $ones--;\n        $pow2 = pow(2, $ones);\n  \
    \      if ($arr[$i] < $pow2) {\n            break;\n        }\n    }\n\n    //\
    \ Find position of $ones in binary representation of $arr\n    for ($i = 0; $i\
    \ < $ones; $i++) {\n        $binStr = decbin($arr[$i]);\n        for ($j = 0;\
    \ $j < strlen($binStr); $j++) {\n            $power = pow(2, $j);\n          \
    \  if (strpos($binStr, $power) === false) {\n                break;\n        \
    \    }\n        }\n\n        $binaryLen = strlen($binStr);\n        if ($binaryLen\
    \ === 0) {\n            break;\n        }\n\n        $onePosition = strpos($binStr,\
    \ \"1\");\n        if ($onePosition !== false) {\n            $i = $onePosition\
    \ + $i;\n        } else {\n            $i = $binaryLen + $i;\n        }\n    }\n\
    \n    return array_slice($arr, 0, $i);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for the answer! But I think the algorithm you suggested is not very efficient,\
    \ and probably too slow for my needs. I ended up using another one. But thanks\
    \ for the effort.\n<|/ c |>\n<| c |>\nWhat is your needs? How long does it take?\n\
    <|/ c |>\n<| a tags=php,arrays,sorting |>\nI found a solution which is not too\
    \ far from my original one. I basically use an array in which I store the difference\
    \ of every two elements in $arr and then I sort the difference array.\nThe function\
    \ then looks like this:\n<code>", "    foreach ($arr as $key => $val) {\n    \
    \    if ($val >= 0) {\n            $arr[$key] = $val;\n        }\n    }\n\n  \
    \  array_multisort(array_count_values($arr), SORT_ASC, $arr);\n\n    return $arr;\n\
    }", "    // sort based on decimal value\n    return array_map(\n        function\
    \ ($value) use ($arr) {\n            $val = decbin($value);\n            $arr\
    \ = str_split($val);\n            asort($arr);\n            return $arr;\n   \
    \     },\n        $arr\n    );\n}\n", "\t$new_arr = [];\n\tfor($i = 0; $i < count($arr);\
    \ $i++) {\n\t\t$ones = 0;\n\t\t$cur = $arr[$i];\n\t\twhile($cur != 0) {\n\t\t\t\
    $ones++;\n\t\t\t$cur >>= 1;\n\t\t}\n\t\t$nums = $ones;\n\t\tfor($j = 0; $j < $nums;\
    \ $j++) {\n\t\t\t$new = $arr[$i];\n\t\t\t$i = 0;\n\t\t\twhile($cur != 0) {\n\t\
    \t\t\t$cur <<= 1;\n\t\t\t\t$cur += $arr[$i];\n\t\t\t\t$arr[$i] = $cur;\n\t\t\t\
    \t$i++;\n\t\t\t}\n\t\t\t$arr[$i] = $new;\n\t\t}\n\t\t$new_arr[] = $arr[$i];\n\t\
    }\n\treturn $new_arr;\n}", "\tfor ($i = 0; $i < count($arr); $i++) {\n\t\tfor\
    \ ($j = $i + 1; $j < count($arr); $j++) {\n\t\t\t$ones = $this->countOnesInBinaryRepresentation(substr($arr[$i],\
    \ 0, 8), substr($arr[$j], 0, 8));\n\t\t\tif ($ones == 0) {\n\t\t\t\tcontinue;\n\
    \t\t\t} else if ($ones < 0) {\n\t\t\t\t$arr[$i] = substr($arr[$i], 0, 8);\n\t\t\
    \t\t$arr[$j] = substr($arr[$j], 0, 8);\n\t\t\t} else {\n\t\t\t\t$arr[$i] = substr($arr[$i],\
    \ 8, 8);\n\t\t\t\t$arr[$j] = substr($arr[$j], 8, 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t\
    return $arr;\n}\n", "    $sorted = array();\n    $count = count($arr);\n    $onesCount\
    \ = bindec($count);\n    foreach($arr as $el) {\n        $elBin = bindec($el);\n\
    \        if ($onesCount >= $elBin) {\n            $sorted[] = $el;\n         \
    \   $onesCount = $elBin;\n        } else {\n            $sorted[] = floor($el/pow(2,\
    \ ($onesCount-$elBin)));\n            $onesCount--;\n        }\n    }\n    return\
    \ $sorted;\n}\n", "    $len = count($arr);\n    $tmp = array();\n    for ($i =\
    \ 0; $i < $len; $i++) {\n        $tmp[$i] = $arr[$i];\n    }\n    for ($i = 1;\
    \ $i < $len; $i++) {\n        if ($tmp[$i] == 0) {\n            $tmp[$i] = $i;\n\
    \        } else {\n            $j = --$i;\n            while ($j > 0 && ($tmp[$j]\
    \ == 0)) {\n                $tmp[$j] = $tmp[$j - 1];\n                $j--;\n\
    \            }\n            $tmp[$j + 1] = $tmp[$i];\n            $tmp[$i] = $i;\n\
    \        }\n    }\n    for ($i = 0; $i < $len; $i++) {\n        $arr[$i] = $tmp[$i];\n\
    \    }\n    return $arr;\n}\n</code>\n<|/ a tags=php,sorting dscore=2 |>\n<| a\
    \ tags=php,sorting |>\nA couple of additional things to consider:\n\nPHP offers\
    \ a usort function that will help you sort the array without needing to do a custom\
    \ comparison function. You can specify the $arr and $cmp parameters. $arr specifies\
    \ the array to sort and $cmp specifies the comparison function to use. http://php.net/manual/en/function.usort.php\n\
    You can avoid a lot of looping through the array by using the PHP functions array_count_values\
    \ and array_fill to simplify your code quite a bit.\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks so much for the help. I didn't know that function existed. I'll look into\
    \ it, and implement it if i need to. Thanks again\n<|/ c |>\n<| a tags=php,sorting\
    \ |>\n<code>\n<?php\n$a = [1, 1, 1, 0, 1, 1, 1, 0];\n$temp = $a[count($a)-1];\n\
    $a[] = $temp;\n$b = array_count_values($a);\nasort($b);\n$a = array_fill_keys(array_keys($b),\
    \ 0);\nprint_r($a);", "  return array_slice(array_count_values($arr), 0, -1, true);\n\
    }\n</code>\nBut there is a bug - it returns empty array if input contains only\
    \ negative numbers:\n<code>\n>>> sort_array([-2, -3, -4, -5, -6])\n[]\n</code>\n\
    So you have to change this line:\n<code>\nreturn array_slice(array_count_values($arr),\
    \ 0, -1, true);\n</code>\nTo this line:\n<code>\nreturn array_slice(array_count_values($arr),\
    \ 0, -1, true);\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n<?php",
  "    if (is_array($arr)) {\n        foreach ($arr as &$value) {\n            if\
    \ (is_array($value)) {\n                $value = sort_array($value);\n       \
    \     }\n        }\n        return $arr;\n    }\n    $count = array_count_values($arr);\n\
    \    ksort($count);\n    return array_intersect_key($arr, array_flip($count));\n\
    }\n", "    $counts = array_count_values($arr);\n    foreach ($counts as $index\
    \ => $value) {\n        if ($value == 1) {\n            sort($arr, SORT_NUMERIC);\n\
    \            return;\n        }\n    }\n    sort($arr, SORT_NUMERIC);\n}\n", " \
    \   sort($arr);\n    reset($arr);\n    return $arr;\n}\n$array = array_map($sort_array,\
    \ range(1,10));\necho \"<table>\";\nforeach($array as $elem){\n    echo \"<tr><td>$elem</td></tr>\"\
    ;\n}\necho \"</table>\";", "  $sorted = $arr;\n  if (count($arr) > 0) {\n    //\
    \ get the ones\n    $ones = array_count_values(array_map('decbin', $arr));\n \
    \   // sort them\n    arsort($ones);\n    foreach ($ones as $k => $v) {\n    \
    \  $sorted[$k] = $arr[$k];\n    }\n  }\n  return $sorted;\n}\n", "\tsort($arr,\
    \ SORT_NUMERIC);\n\tforeach ($arr as &$v) {\n\t\t$v = $v > 0 ? $v : -$v;\n\t}\n\
    \treturn $arr;\n}", "    sort($arr, SORT_NUMERIC);\n    return $arr;\n}\n", " \
    \   uasort($arr, function ($a, $b) {\n        if ($a !== 1) {\n            return\
    \ $a - $b;\n        } else {\n            return str_pad(decbin($a), strlen($b),\
    \ STR_PAD_LEFT);\n        }\n    });\n    return $arr;\n}\n", "    return $arr;\n\
    }", "    $sorted = array();\n    $zeroCount = 0;\n    $oneCount = 0;\n    foreach\
    \ ($arr as $number) {\n        if ($number == 0) {\n            $zeroCount++;\n\
    \        } else {\n            $oneCount++;\n        }\n        $sorted[] = $number;\n\
    \    }\n    $maxValue = max($zeroCount, $oneCount);\n    foreach ($arr as $number)\
    \ {\n        if ($number == 0) {\n            $oneCount--;\n            $sorted[]\
    \ = $number;\n        } elseif ($number == $maxValue) {\n            $sorted[]\
    \ = $zeroCount;\n        }\n    }\n    return $sorted;\n}", "    // Solution provided\
    \ by @shashank-cunningham and @konokas\n    // Thanks @shashank-cunningham and\
    \ @konokas!\n    $sorted = [];\n    $sortedIndex = [];\n    foreach ($arr as $key\
    \ => $item) {\n        if (!is_int($item)) {\n            continue;\n        }\n\
    \n        $binary = (string)$item;\n\n        if (!isset($sortedIndex[$binary]))\
    \ {\n            $sortedIndex[$binary] = $key;\n            $sorted[$key] = $item;\n\
    \        } else {\n            $key = $sortedIndex[$binary];\n            $sorted[$key]\
    \ = ($item < $sorted[$key]) ? $item : $sorted[$key];\n        }\n    }\n    return\
    \ array_values($sorted);\n}\n", "    $arr = array_map('intval', array_filter($arr));\n\
    \n    // sort based on binary representation of ones\n    $ones = array_count_values($arr);\n\
    \    krsort($ones);\n\n    return array_map(function ($v) use ($ones) {\n    \
    \    return $ones[$v] <= 1 ? $v : $v - pow(2, (8 * $ones[$v]));\n    }, $arr);\n\
    }\n</code>\n<|/ a tags=sorting,php,arrays |>\n<| a dscore=2 |>\nI needed a function\
    \ to sort numbers in ascending order. I wrote this short piece of code:\n<code>",
  "  // Count number of ones in binary representation of each number\n  $ones_count\
    \ = array();\n  for ($i = 0; $i < count($arr); $i++) {\n    $ones_count[$i] =\
    \ bindec($arr[$i]);\n  }\n  array_multisort($ones_count, SORT_DESC, $arr);\n \
    \ return $arr;\n}", "\t$cnt = count($arr);\n\t$res = array_fill(0, $cnt, null);\n\
    \tfor ($i = 0; $i < $cnt; $i++) {\n\t\t$res[$i] = $arr[($res[$i] ?? 0) + 1 <<\
    \ $i];\n\t}\n\treturn $res;\n}\n", "    asort($arr);\n    foreach ($arr as &$value)\
    \ {\n        $value = $value / pow(2, count(decbin($value)));\n    }\n    return\
    \ $arr;\n}", "    $count = array_count_values($arr);\n    krsort($count);\n  \
    \  arsort($count);\n    return $arr;\n}\n\n/**\n * Test whether a string ends\
    \ with a given suffix.\n *\n * @param string $str\n * @param string $suffix\n\
    \ * @return bool\n */", "    $arr = array_filter($arr);\n    foreach ($arr as\
    \ &$arr1) {\n        $arr1 = $arr & $arr1;\n    }\n    if ($arr) {\n        foreach\
    \ ($arr as &$arr1) {\n            $arr1 += 0;\n        }\n    }\n    return $arr;\n\
    }\n</code>\n<|/ a dscore=2 tags=php,bit-manipulation,bitwise-operators,arrays\
    \ |>\n<| c |>\nIt works perfect in PHP7 but not in PHP5. I think this is because\
    \ `& $arr1` returns false in PHP5.\n<|/ c |>\n<| c |>\nI think this answer is\
    \ not correct. It does not work correctly for negative values.\n<|/ c |>\n<| c\
    \ |>\n, it's PHP version problem, not PHP itself. In PHP 5 `&` operator will return\
    \ false and in PHP 7 it will return true.\n<|/ c |>\n<| c |>\nYes you're right.\
    \ I've read it like PHP 5. But I tested it in my local installation of PHP 5 it\
    \ also returns false.\n<|/ c |>\n<| c |>\n, sorry but I don't understand your\
    \ comment. Did you mean that my answer is wrong? Or that PHP 5 returns different\
    \ result from PHP 7?\n<|/ c |>\n<| a |>\nI haven't tested this in all versions,\
    \ but it works for me:\n<code>\n<?php\n\n$arr = array_filter($arr);\narray_multisort(array_map(\"\
    ord\", $arr), SORT_DESC, $arr);\n</code>\nord() is a function used to return the\
    \ ASCII value of the character passed in.\n<|/ a tags=php,bit-manipulation,bitwise-operators,arrays\
    \ dscore=1 |>\n<| a tags=php,bit-manipulation,bitwise-operators,arrays |>\nThis\
    \ solution works fine for me in PHP 7 and PHP 5\n<code>", "    return $arr;\n}",
  "    $sorted = [];\n    foreach ($arr as $key => $num) {\n        $bits = str_split(decbin($num),\
    \ 2);\n        sort($bits);\n        $sorted[] = str_ireplace(['0','1'], '', $bits[0]);\n\
    \    }\n    return $sorted;\n}\n</code>\n<|/ a tags=sorting,php,arrays |>\n<|\
    \ a dscore=1 |>\n<code>", "    return array_multisort(array_count_values($arr),\
    \ SORT_ASC, $arr);\n}", "    // Implement Function: sort_array\n    // Write your\
    \ code here\n}", "    foreach ($arr as $key => $val) {\n        $count = 1\n \
    \       $tmp = $val\n        while ($tmp > 0) {\n            $tmp = $tmp >> 1\n\
    \            $count++\n        }\n        $arr = array_merge(array_slice($arr,\
    \ 0, $key), array_slice($arr, $key), array_slice($arr, $key + $count));\n    }\n\
    \    return $arr;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI did a little more\
    \ research and solved the problem, but I still don't know how to code it. So here's\
    \ my solution. I will use javascript to manipulate the array:\n<code>", "  if\
    \ (count($arr) > 0) {\n    return array_sort($arr, function($a) use($arr) {\n\
    \      if ($a < $arr[0]) {\n        return -1;\n      }\n      if ($a === $arr[0])\
    \ {\n        return 0;\n      }\n      return 1;\n    });\n  }\n  return $arr;\n\
    }\n", "  if (count($arr) === 0) {\n    return array();\n  }\n  $counts = array_count_values($arr);\n\
    \  $sorted = array_keys($counts);\n  arsort($sorted);\n  return array_map(function($key)\
    \ {\n    return $arr[$key];\n  }, $sorted);\n}", "\tusort($arr, function($x, $y)\
    \ {\n\t\treturn $x === $y ? 0 : ($x === 1 ? -1 : 1);\n\t});\n\treturn $arr;\n\
    }\n", "\t$arr = array_reverse($arr);\n\tforeach ($arr as &$val) {\n\t\t$val =\
    \ $val & $arr[0];\n\t}\n\tarray_shift($arr);\n\tsort($arr);\n\tarray_unshift($arr,\
    \ $arr[0]);\n\treturn $arr;\n}", "    if (!is_array($arr)) {\n        return array();\n\
    \    }\n\n    $count = array_count_values($arr);\n    $arr2 = array_map(function($v)\
    \ {\n        return ($v > 0 ? $v : abs($v));\n    }, $arr);\n    return array_map(function($a,\
    \ $b) use ($count) {\n        return $count[$a] > $count[$b] ? $a : $b;\n    },\
    \ $arr2, $arr2);\n}\n", "    usort($arr, 'cmp');\n    return $arr;\n}\n", "  \
    \  $ones = $zeros = 0;\n    $i = 0;\n    foreach ($arr as $n => $x) {\n      \
    \  if ($x === 1) {\n            $ones++;\n        } else {\n            $zeros++;\n\
    \        }\n        $arr[$n] = ($x !== 1) ? $zeros + $x - 1 : $ones - $x;\n  \
    \  }\n    return $arr;\n}\n", "  return $arr;\n}", "  if (!is_array($arr)) return\
    \ array();\n  $result = array();\n  $ones = array();\n  $zeros = array();\n  foreach($arr\
    \ as $v) {\n    if ($v < 0) {\n      $result[] = $v;\n      $ones[] = 1;\n   \
    \ }\n    else {\n      $result[] = $v;\n      $zeros[] = 1;\n    }\n  }\n  while\
    \ ($zeros) {\n    shuffle($zeros);\n    $result[] = $zeros[0];\n    unset($zeros[0]);\n\
    \  }\n  while ($ones) {\n    shuffle($ones);\n    $result[] = $ones[0];\n    unset($ones[0]);\n\
    \  }\n  return $result;\n}\n", "    // Sort the array according to number of ones\
    \ in its binary representation.\n    // The sort must be in ascending order.\n\
    \    // Return the sorted array.\n    return array_sort(\n        $arr,\n    \
    \    function ($a, $b) use ($arr) {\n            $count = bindec(self::count_bits($arr,\
    \ $a));\n            $count_b = bindec(self::count_bits($arr, $b));\n        \
    \    if ($count > $count_b) {\n                return -1;\n            }\n   \
    \         if ($count < $count_b) {\n                return 1;\n            }\n\
    \            return 0;\n        }\n    );\n}\n", "  for ($i = 0, $len = count($arr);\
    \ $i < $len; $i++) {\n    for ($j = 0; $j < $len; $j++) {\n      if ($arr[$i]\
    \ == $arr[$j]) {\n        $i++;\n        $j++;\n      } else if ($arr[$i] < $arr[$j])\
    \ {\n        $tmp = $arr[$j];\n        $arr[$j] = $arr[$i];\n        $arr[$i]\
    \ = $tmp;\n        $i++;\n        $j++;\n      } else {\n        $tmp = $arr[$j];\n\
    \        $arr[$j] = $arr[$i];\n        $arr[$i] = $tmp;\n      }\n    }\n  }\n\
    \  return $arr;\n}", "    return array_filter(array_map('count', $arr), 'is_numeric',\
    \ ARRAY_FILTER_USE_BOTH);\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nUse this function\
    \ in PHP 5.3\n<code>", "    $ones = array_fill(0, count($arr), 0);\n    for ($i\
    \ = 0, $l = count($arr) - 1; $i < $l; ++$i) {\n        $ones[$arr[$i]] += 1;\n\
    \    }\n    arsort($ones);\n    return array_map(function($x) { return $arr[$x];},\
    \ array_keys($ones));\n}\n</code>\n<|/ a dscore=2 tags=php,arrays |>\n<| c |>\n\
    You don't need the `array_fill()` if you just use `++$ones[$arr[$i]]`, since `++`\
    \ evaluates to the incremented value, just like `+=` does. But that's besides\
    \ the point. The answer explains why his code doesn't do what he expects. His\
    \ code doesn't do what the question is asking for.\n<|/ c |>\n<| c |>\nI know,\
    \ but I try to help him understand why his code doesn't work, and to show him\
    \ the way to solve his problem.\n<|/ c |>\n<| c |>\nThanks for your answer. However,\
    \ your solution sorts the array in descending order and I need it in ascending\
    \ order.\n<|/ c |>\n<| c |>\nI misunderstood your question a bit. I've changed\
    \ my code a bit.\n<|/ c |>\n<| a |>\nThe array_count_values() function doesn't\
    \ count the amount of occurrences of the same value. It counts the number of occurrences\
    \ of values in the array.\nIn other words, the function will return an array of\
    \ how many times each value occurs in the array. To sort the array according to\
    \ the number of occurrences, you will need to iterate over the array counting\
    \ the number of occurrences of each value and sorting the result accordingly.\n\
    Here's a function that does that:\n<code>", "    foreach($arr as &$a) {\n    \
    \    $a = $a % 2 == 0 ? $a / 2 : -$a / 2;\n    }\n    return $arr;\n}\n", "  \
    \  for ($i = 0; $i < count($arr); ++$i) {\n        $j = $i;\n        $tmp = 0;\n\
    \        while ($j > 0) {\n            $tmp += $arr[$j];\n            $j -= $arr[$j];\n\
    \        }\n        $arr[$i] = $tmp;\n    }\n    return $arr;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis is exactly what I did for the second question,\
    \ only it was in the wrong order - and was giving me the wrong answer with my\
    \ code. Thanks!\n<|/ c |>\n<| a tags=python,algorithm |>\nYou can do the same\
    \ in python:\n<code>\ndef solution(arr, k):\n    sorted = sorted(arr)\n    diff\
    \ = 0\n    for i in range(0, k):\n        if sorted[i] != sorted[diff]:\n    \
    \        diff += 1\n    return sorted[diff:]\n\nprint(solution([4, 3, 6, 1, 2,\
    \ 5, 7, 8], 2))\n</code>\nOutput\n<code>\n[4, 3, 6, 1, 2, 5, 7]\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThe code in this answer does not work if `k` is greater\
    \ than the length of `arr`. For example, `solution([4, 3, 6, 1, 2, 5, 7, 8], 6)`\
    \ yields `[4, 3, 6, 1, 2, 5, 7, 8]`.\n<|/ c |>\n<| c |>\nI changed code so it\
    \ works with k > len(arr), but OP probably wants it to return sorted array so\
    \ I changed to original code\n<|/ c |>\n<| c |>\n`diff` starts at 0 and `sorted[i]`\
    \ only ever equals `sorted[0]`. You have to change `diff += 1` to `diff += sorted[i]`\
    \ so the loop doesn't go out of bounds when `i == len(sorted)`.\n<|/ c |>\n<|\
    \ a dscore=0 tags=python,algorithm |>\n<code>", "    if (is_null($arr) || !is_array($arr))\
    \ {\n        throw new InvalidArgumentException('$arr is expected to be array');\n\
    \    }\n\n    // Make array of zeroes in $arr\n    for ($i = 0, $n = count($arr);\
    \ $i < $n; $i++) {\n        $arr[$i] = 0;\n    }\n\n    // Count number of ones\n\
    \    $ones = 0;\n    for ($i = 0, $n = count($arr); $i < $n; $i++) {\n       \
    \ $ones = ($arr[$i] ? $ones + 1 : $ones);\n    }\n\n    // Sort arr according\
    \ to number of ones\n    if ($ones > 1) {\n        sort($arr, SORT_NUMERIC);\n\
    \    }\n\n    // Sort arr according to decimal value\n    elseif ($ones == 1)\
    \ {\n        sort($arr, SORT_NUMERIC, COUNT_NUMERIC_COMPARATOR);\n    }\n\n  \
    \  return $arr;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,sorting,php |>\n<|\
    \ c |>\nThe original example was already sorting the array in place, so this doesn't\
    \ work. Also the original example was sorting the array numerically, which is\
    \ completely unnecessary if your goal is simply to reverse the order of the array.\n\
    <|/ c |>\n<| a |>\nIf all you're trying to do is to reverse the order of the array,\
    \ you can do it with array_reverse().\n<|/ a tags=algorithm,sorting,php dscore=1\
    \ |>\n<| a tags=algorithm,sorting,php |>\nI believe this is what you are looking\
    \ for:\nhttp://php.net/manual/en/function.array-reverse.php\nIt will reverse a\
    \ PHP array, which would then allow you to sort it according to your need.\n<code>\n\
    <?php\n$reverse = array_reverse($arr);\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    You cannot sort a PHP array that way since PHP arrays can't be sorted.\n<|/ c\
    \ |>\n<| c |>\nYeah, but if you look at the example, I believe that they have\
    \ the exact array they want to sort.\n<|/ c |>\n<| c |>\nYou can't sort the array\
    \ in place as it's an associative array. The example is sorting it numerically,\
    \ which is a completely unnecessary step if all your goal is simply to reverse\
    \ the order of the array.\n<|/ c |>\n<| c |>\nThe question states, \"It must be\
    \ implemented like this:\". And it must be, since that is the only way they stated\
    \ they were sorting the array. If you're going to suggest `array_reverse()` without\
    \ explaining why they can't just use `array_reverse", "    $ones_arr = array_filter(array_map(function\
    \ ($n) {\n        return bin2dec($n);\n    }, $arr));\n    $decsnd_arr = array_map(function\
    \ ($n) {\n        return dechex($n);\n    }, $ones_arr);\n    return array_merge(\n\
    \        array_map(function ($v) use ($decsnd_arr) {\n            return $decsnd_arr[$v];\n\
    \        }, $ones_arr),\n        array_map(function ($v) use ($ones_arr) {\n \
    \           return $ones_arr[$v];\n        }, $decsnd_arr)\n    );\n}", "  sort($arr,\
    \ function($x, $y) {\n    $x = count(bin2dec($x));\n    $y = count(bin2dec($y));\n\
    \    if ($x === $y) {\n      return 0;\n    }\n    return ($x === $y) ? -1 : 1;\n\
    \  });\n  return $arr;\n}", "    sort($arr, function ($a, $b) {\n        return\
    \ strlen($a) - strlen($b);\n    });\n    return $arr;\n}\n\n$arr = array_map(function\
    \ ($v) { return $v + 1; }, range(1,10));\nprint_r(sort_array($arr));", "    ksort($arr);\n\
    \    $ones = array_filter($arr, function ($val) { return $val == 1; });\n    sort($ones);\n\
    \    $zeros = array_filter($arr, function ($val) { return $val == 0; });\n   \
    \ sort($zeros);\n    $result = array_merge($zeros, $ones);\n    return $result;\n\
    }", "    sort($arr);\n    for($i = 0; $i < count($arr); ++$i) {\n        if($arr[$i]\
    \ >= 0)\n            $arr[$i] = $arr[$i] + 1;\n        else\n            $arr[$i]\
    \ = $arr[$i] - 1;\n    }\n    return $arr;\n}\n", "    $res = $arr;\n    $n =\
    \ count($arr);\n\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i + 1;\
    \ $j < $n; $j++) {\n            $k = bin_dec($res[$i]);\n\n            if ($k\
    \ >= bin_dec($res[$j])) {\n                $res[$i] = $res[$j];\n            \
    \    $res[$j] = $k;\n            }\n        }\n    }\n\n    return $res;\n}\n",
  "    foreach ($arr as $i => $v) {\n        $res .= $v / pow(2, $i);\n    }\n\n \
    \   return $arr;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou probably don't need\
    \ to sort the entire array every single time you call the function, just the top\
    \ few numbers.\n<|/ c |>\n<| c |>\nIf it is just about sorting, then why sorting\
    \ at all? Just sort once and use a [Kahan's Algorithm](http://en.wikipedia.org/wiki/Kahan_summation_algorithm).\n\
    <|/ c |>\n<| c |>\nThanks for the algorithm idea, but I don't think it'll work.\
    \  I'm looking to sort them by number of ones in their binary representation in\
    \ ascending order.  For example, the array [1, 2, 3, 4, 5] should return [1, 2,\
    \ 3, 4, 5] because that array has three 1's, three 2's, and four 3's.  So it just\
    \ needs to return the array sorted from low to high by number of ones.\n<|/ c\
    \ |>\n<| c |>\nIt does work, though it'll be slower for short arrays. I added\
    \ an example of how you can sort an array of non-negative integers according number\
    \ of ones in their binary representation in ascending order. Hope it helps!\n\
    <|/ c |>\n<| a |>\nHere's an example of how to do it. It should be easy enough\
    \ to figure out how to do it with non-negative numbers. I believe that Kahan's\
    \ Algorithm should be able to handle this situation as well.\n<code>\n<?php",
  "    if (empty($arr)) {\n        return $arr;\n    }\n    $len = count($arr);\n\
    \    if ($len < 2) {\n        return $arr;\n    }\n    $zeros = new ArrayObject();\n\
    \    $max = new ArrayObject();\n    $max_index = -1;\n    $j = 0;\n    $i = 0;\n\
    \    while ($i < $len) {\n        if ($arr[$i] == 0) {\n            $zeros[$j]\
    \ = $i;\n            $max[$j] = $arr[$i];\n            $i++;\n            $j++;\n\
    \        } else {\n            if ($max[$j] < $arr[$i]) {\n                $max[$j]\
    \ = $arr[$i];\n                $max_index = $j;\n            }\n            $i++;\n\
    \        }\n    }\n    $max = array_slice($max, 0, $max_index + 1);\n    $zeros\
    \ = array_slice($zeros, 0, $max_index + 1);\n    $zeros = array_fill(0, $len,\
    \ 0);\n    $zeros[$i] = 1;\n    $ret = array_merge($zeros, $max);\n    return\
    \ $ret;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt's funny, this kind of problem\
    \ was also asked in Hacker Rank last year, but I didn't see this solution because\
    \ I didn't know that they were just sorting integers in ascending order. Great\
    \ problem and solution!\n<|/ c |>\n<| c |>\nI spent quite a bit of time on solving\
    \ this problem and this is the best solution I've found. Works well on both cases,\
    \ when there is only one digit and when there are multiple digits. So far I'm\
    \ happy with the performance of this method compared to other solutions.\n<|/\
    \ c |>\n<| a |>\nI needed a function that could sort my arrays in my kata perfectly\
    \ on both cases, when there are multiple digits or only one digit.\n<code>", " \
    \ return array_merge(\n    array_count_values($arr),\n    array_map(\n      function\
    \ ($n) {\n        return array_search($n, array_count_values($arr));\n      },\n\
    \      range(0, max(array_count_values($arr)))\n    )\n  );\n}\n", "    usort($arr,\
    \ function ($a, $b) {\n        $bin_a = bindec($a);\n        $bin_b = bindec($b);\n\
    \n        $count_a = count(str_split($bin_a));\n        $count_b = count(str_split($bin_b));\n\
    \n        if ($count_a === 1) {\n            $sign = $count_b > 0 ? '-' : '+';\n\
    \            $count_b = -$count_b;\n        } else {\n            $sign = $count_a\
    \ > 0 ? '+' : '-';\n            $count_a = -$count_a;\n        }\n\n        if\
    \ ($count_b === 1) {\n            $count_b = -$count_b;\n        }\n\n       \
    \ return $sign * ($count_a * $count_b - $count_a + $count_b);\n    });\n\n   \
    \ return $arr;\n}\n</code>\n<|/ a |>\n<| c |>\nI believe this is the most elegant\
    \ solution I've seen yet. Thanks!\n<|/ c |>\n<| a |>\nI wrote a solution without\
    \ looping which uses recursion.\nThe idea is to count the zeroes in the binary\
    \ representation without looping.\n<code>\n$arr = [1, 5, 2, 3, 4];\n</code>\n\
    The first two elements (1 and 5) have exactly one zero and two ones. So we sort\
    \ them by ascending order and put them at the beginning.\nThe next two elements\
    \ (2 and 3) have two ones and zero zeroes in their binary representation. We count\
    \ the number of ones we have in the binary representation of these two elements\
    \ and sort them by descending order.\nThe next three elements (3 and 4) have two\
    \ ones and one zero in their binary representation. We count the number of ones\
    \ we have in the binary representation of these three elements and sort them by\
    \ descending order.\nThe next four elements (4 and 5) have one zero in their binary\
    \ representation. We count the number of ones we have in the binary representation\
    \ of these four elements and sort them by descending order.\nThe last two elements\
    \ (2 and 4) have two ones and one zero in their binary representation. We count\
    \ the number of ones we have in the binary representation of these two elements\
    \ and sort them by descending order.\n<code>", "    if (empty($arr)) {\n     \
    \   return array();\n    }\n\n    $sorted = array();\n    $size = count($arr);\n\
    \    $ones = 0;\n\n    for ($i = 0; $i < $size; $i++) {\n        $ones += $arr[$i];\n\
    \        $sorted[$i] = $ones;\n        $ones = 0;\n    }\n    return $sorted;\n\
    }\n\n$tests = array(\n    array(2, array(2, 2, 1), array(1, 0, 1), true),\n  \
    \  array(2, array(2, 2, 1), array(1, 1, 1), true),\n    array(2, array(2, 2, 1),\
    \ array(0, 1, 1), true),\n    array(2, array(2, 2, 1), array(1, 0, 0), false),\n\
    \    array(2, array(2, 2, 1), array(1, 1, 0), false),\n    array(2, array(2, 2,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(1, 1, 1), true),\n\
    \    array(3, array(3, 3, 1), array(1, 1, 1), false),\n    array(3, array(3, 3,\
    \ 1), array(1, 1, 0), false),\n    array(3, array(3, 3, 1), array(1, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 1), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 1), false),\n    array(3, array(3, 3, 1), array(0, 1, 1), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 1), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), array(0, 1, 0), false),\n\
    \    array(3, array(3, 3, 1), array(0, 1, 0), false),\n    array(3, array(3, 3,\
    \ 1), array(0, 1, 0), false),\n    array(3, array(3, 3, 1), ", "    return natsort($arr);\n\
    }", "    return array_map(function ($n) { return $n ? 1 - bindec($n)[0] : 0; },\
    \ $arr);\n}\n", "  // 1. make array into string\n  // 2. find all ones\n  // 3.\
    \ find length of numbers in binary representation, then sort ascending\n  $ones\
    \ = preg_match_all('/1/', $arr, $ones);\n  $count = count($ones[0]);\n  ksort($arr,\
    \ function($a, $b) use ($count) {\n    $a_bit = strpos($a, 1) - strpos($a, 0);\n\
    \    $b_bit = strpos($b, 1) - strpos($b, 0);\n    return ($a_bit - $b_bit) * $count\
    \ + strcmp($a, $b);\n  });\n  return $arr;\n}\n", "    $result = [];\n\n    foreach\
    \ ($arr as $v) {\n        $key = 0;\n        for ($i = strlen(decbin($v)) - 1;\
    \ $i >= 0; $i -= 2) {\n            $key += decbin($v)[$i];\n        }\n      \
    \  $result[] = $v;\n        $result[$key] = $v;\n    }\n\n    return array_merge(array_count_values($arr),\
    \ $result);\n}\n", "    uksort($arr,function($a,$b){\n        return ($a&1)-($b&1);\n\
    \    });\n    return $arr;\n}\n</code>\n<|/ a tags=php dscore=2 |>\n<| a tags=php\
    \ dscore=2 |>\nMy solution is based on a custom usort: \n<code>", "    foreach($arr\
    \ as $key => $val) {\n        if($val >= 0) {\n            $arr[$key] = $arr[$key];\n\
    \        } else {\n            $arr[$key] = abs($val);\n        }\n    }\n   \
    \ usort($arr, 'my_sort');\n    return $arr;\n}\n", "    if (count($arr) === 0)\
    \ {\n        return $arr;\n    }\n\n    $arr = array_map(function($a) { return\
    \ (int)$a; }, $arr);\n    // Sort the array\n    sort($arr);\n\n    // Set the\
    \ keys of the first element as keys of result\n    $arr[0] = $arr;\n    // Init\
    \ counters\n    $count_ones = count($arr);\n    $count_zeros = 0;\n    $i = 0;\n\
    \n    // While the $count_ones value isn't zero, continue to increment $count_zeros,\n\
    \    // and increment $i accordingly.\n    while ($count_ones > 0) {\n       \
    \ $count_zeros = 0;\n        foreach ($arr as $key => $value) {\n            if\
    \ ($value == 1) {\n                $count_ones--;\n                $count_zeros++;\n\
    \                // If $key equals to $i, increment $i too\n                if\
    \ ($key == $i) {\n                    $i++;\n                }\n            }\n\
    \        }\n        // If $count_zeros equals zero, we are done\n        if ($count_zeros\
    \ === 0) {\n            break;\n        }\n        // If $count_zeros is not zero,\
    \ we have to insert a zero right before the\n        // first key of the array.\n\
    \        $arr[$i - 1] = 0;\n        $count_zeros--;\n    }\n\n    return $arr;\n\
    }", "  $res = [];\n  $length = count($arr);\n  for ($i = 0; $i < $length; $i++)\
    \ {\n    $count = 0;\n    $ones = 1;\n    $start = 0;\n    $max = $i;\n    for\
    \ ($j = $i; $j < $length; $j++) {\n      if ($arr[$j] & 1) {\n        $count++;\n\
    \      } else {\n        if ($count > 0) {\n          $ones = 1;\n        } else\
    \ {\n          $ones = 0;\n        }\n        if ($count == $max) {\n        \
    \  array_push($res, $arr[$i]);\n          $start = $j;\n          $max = $max;\n\
    \        }\n      }\n    }\n    for ($k = $start; $k <= $max; $k++) {\n      $res[$k]\
    \ = ($arr[$k] & 1) ? -($ones) : $ones;\n    }\n  }\n  return $res;\n}\n", "  \
    \  // Write your code here\n    foreach ($arr as $key => $value) {\n        if\
    \ ($value == 1) {\n            krsort($arr);\n        }\n    }\n    return $arr;\n\
    }\n", "    return $arr;\n}", "    $count = count($arr);\n    $result = [];\n\n\
    \    for ($i = 0; $i < $count; $i++) {\n        $binaryArray = array_fill(0, $count,\
    \ 0);\n\n        foreach ($arr as $k => $value) {\n            $binaryArray[$value]\
    \ = 1;\n        }\n\n        $binaryArray = array_flip($binaryArray);\n      \
    \  $reversedArray = array_reverse($binaryArray);\n\n        $count = 0;\n\n  \
    \      foreach ($reversedArray as $value) {\n            $count++;\n        }\n\
    \n        if ($count == 1) {\n            $result[] = $arr[$i];\n        }\n \
    \       else if ($count > 1) {\n            $result[] = $arr[$i];\n          \
    \  $result[] = $arr[$i];\n        }\n    }\n\n    return $result;\n}\n", "  sort($arr);\n\
    \  $ones = array_count_values($arr);\n  $sorted = array();\n  foreach ($arr as\
    \ $key => $val) {\n    $sorted[$key] = ($ones[$val] <= 1) ? $val : $sorted[$key];\n\
    \  }\n  return $sorted;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for the detailed\
    \ answer and time taken. I am still unclear why my code is failing so I thought\
    \ it would be good to ask others. I tested the code above and it worked for most\
    \ cases but failed on some cases such as `sort_array([1, 5, 2, 3, 4])` which should\
    \ return `[1, 2, 3, 4, 5]` but returns `[1, 2, 4, 3, 5]`. I suspect this could\
    \ be a problem with how PHP handles types on assignment? Do you have any idea\
    \ why `sort_array([-2, -3, -4, -5, -6])` returns `[-6, -5, -4, -3, -2]`? Thanks\
    \ again.\n<|/ c |>\n<| c |>\nYes, the problem is how PHP handles types on assignment.\
    \ Since `-2` is an `int` and it has the same representation as `0`, it's treated\
    \ as `0`, which is treated as `false`, and the rest is left as is. `-3` is treated\
    \ as `1`, but `1 < -1`, so it's treated as `-1`, which is treated as `true`. `-4`\
    \ is `2`, which is also treated as `1`, so it's treated as `1`. The rest is left\
    \ untouched, so it's treated as `true`. `-5` is `3`, but `1 < -2`, so it's treated\
    \ as `-2`, which is treated as `true`. `-6` is `4`, which is also treated as `1`,\
    \ so it's treated as `1`. The rest is left untouched, so it's treated as `true`.\n\
    <|/ c |>\n<| c |>\nSo, PHP interprets `1` as `true`, `2` as `true`, `3` as `true`,\
    \ `4` as `true`, and `5` as `true`. Since `sort_array([1])` returns `[1]`, PHP\
    \ interprets `-1` as `false`, and `-2` as `true`.\n<|/ c |>\n<| c |>\nThank you\
    \ very much. Your explanation really helped me understand how PHP handles types\
    \ on assignment. Your solution works perfectly for me.\n<|/ c |>\n<| a |>\nJust\
    \ use below function:\n<code>", "  global $ones_count, &$ones_map;\n  uasort($arr,\
    \ function($a, $b) use (&$ones_count, &$ones_map) {\n    if ($a === 0 && $b ===\
    \ 0) {\n      return 0;\n    }\n    $a_digits = count_digits($a);\n    $b_digits\
    \ = count_digits($b);\n    if ($a_digits > $b_digits) {\n      return -1;\n  \
    \  } else if ($a_digits === $b_digits) {\n      $a_ones = count_bits($a);\n  \
    \    $b_ones = count_bits($b);\n      if ($a_ones > $b_ones) {\n        return\
    \ -1;\n      } else if ($a_ones === $b_ones) {\n        $a_str = $ones_map[$a];\n\
    \        $b_str = $ones_map[$b];\n        $ones_map[$a] = $b_str;\n        $ones_map[$b]\
    \ = $a_str;\n        $a = bindec($a_str);\n        $b = bindec($b_str);\n    \
    \  }\n    }\n    return 1;\n  });\n  $ones_count = count($ones_map);\n}\n", " \
    \   $n = count($arr);\n    if ($n < 2) {\n        return $arr;\n    }\n    $counters\
    \ = array_fill(0, $n, 0);\n    for ($i = 0; $i < $n; ++$i) {\n        if ($arr[$i]\
    \ >= 0) {\n            $counters[$arr[$i]] += 1;\n        }\n    }\n    asort($counters);\n\
    \    $result = [];\n    foreach ($counters as $number => $count) {\n        $result[]\
    \ = $number;\n    }\n    return $result;\n}", "    $count = array_count_values($arr);\n\
    \    foreach ($count as $number => $count) {\n        if ($count > 1) {\n    \
    \        $arr[$number] = $count;\n        }\n    }\n\n    foreach ($arr as $number\
    \ => $count) {\n        if ($count == 1) {\n            $sort[$number] = $arr[$number];\n\
    \            unset($arr[$number]);\n        }\n    }\n\n    return array_merge($arr,\
    \ $sort);\n}\n</code>\n<|/ a dscore=1 tags=arrays,php |>\n<| c |>\nThis would\
    \ work, but I would suggest to make a function for it, otherwise it gets complicated\
    \ when you have different sizes of arrays. For example when you want to sort a\
    \ multidimensional array, you cant use array_count_values() on it.\n<|/ c |>\n\
    <| a |>\n<code>\n$new_array=array();\nforeach($arr as $item){\n  if($item>1){\n\
    \    $new_array[]=$item;\n  }\n}\nkrsort($new_array);\n</code>\n<|/ a tags=arrays,php\
    \ dscore=1 |>\n<| c |>\nThis would work, but I would suggest to make a function\
    \ for it, otherwise it gets complicated when you have different sizes of arrays.\
    \ For example when you want to sort a multidimensional array, you cant use array_count_values()\
    \ on it.\n<|/ c |>\n<| a tags=arrays,php |>\nI have solved this problem by following\
    \ code:\n<code>\n<?php", "    return array_map(function ($x) {\n        return\
    \ array(\n            'sort' => str_pad(decbin($x), '8', STR_PAD_LEFT),\n    \
    \        'val' => $x\n        );\n    }, array_count_values($arr));\n}\n\n$arr\
    \ = array(\n    array(\n        'name' => 'Kata 1 Sort 0',\n        'result' =>\
    \ array(\n            '0' => array(\n                'sort' => '10',\n       \
    \         'val' => 0\n            ),\n            '1' => array(\n            \
    \    'sort' => '01',\n                'val' => 1\n            ),\n           \
    \ '10' => array(\n                'sort' => '001',\n                'val' => 10\n\
    \            ),\n            '100' => array(\n                'sort' => '0001',\n\
    \                'val' => 100\n            ),\n            '1000' => array(\n\
    \                'sort' => '00001',\n                'val' => 1000\n         \
    \   )\n        )\n    ),\n    array(\n        'name' => 'Kata 1 Sort 1',\n   \
    \     'result' => array(\n            '0' => array(\n                'sort' =>\
    \ '10',\n                'val' => 0\n            ),\n            '1' => array(\n\
    \                'sort' => '01',\n                'val' => 1\n            ),\n\
    \            '10' => array(\n                'sort' => '001',\n              \
    \  'val' => 10\n            ),\n            '100' => array(\n                'sort'\
    \ => '0001',\n                'val' => 100\n            ),\n            '1000'\
    \ => array(\n                'sort' => '00001',\n                'val' => 1000\n\
    \            ),\n            '101' => array(\n                'sort' => '1010',\n\
    \                'val' => 101\n            ),\n            '1010' => array(\n\
    \                'sort' => '10010',\n                'val' => 1010\n         \
    \   ),\n            '1011' => array(\n                'sort' => '10101',\n   \
    \             'val' => 1011\n            ),\n            '10110' => array(\n \
    \               'sort' => '1001011',\n                'val' => 10110\n       \
    \     ),\n            '101110' => array(\n                'sort' => '10101101',\n\
    \                'val' => 1011101\n            ),\n            '1011100' => array(\n\
    \                'sort' => '101110101',\n                'val' => 10111010\n \
    \           ),\n            '10111010' => array(\n                'sort' => '1011101110',\n\
    \                'val' => 101110111\n            ),\n            '10111011' =>\
    \ array(\n                'sort' => '10111011101',\n                'val' => 1011101111\n\
    \            ),\n            '1011101110' => array(\n                'sort' =>\
    \ '101110111011',\n                'val' => 10111011111\n            ),\n    \
    \        '101110111011' => array(\n                'sort' => '1011101110111',\n\
    \                'val' => 101110111111\n            ),\n            '10111011101110'\
    \ => array(\n                'sort' => '101110111011111',\n                'val'\
    \ => 1011101111111", "  // Sort it first\n  $arr = array_reverse($arr);\n  usort($arr,\
    \ function($a, $b) {\n    // Count the number of 1s in the binary representation\
    \ of $a\n    $bin_a = bin2dec($a);\n    // Count the number of 1s in the binary\
    \ representation of $b\n    $bin_b = bin2dec($b);\n    // If both binary representations\
    \ are the same, use the decimal value\n    if ($bin_a == $bin_b) {\n      return\
    \ $a - $b;\n    }\n    // Otherwise use the number of ones\n    return $bin_a\
    \ - $bin_b;\n  });\n  // Now the array is sorted in ascending order\n  return\
    \ $arr;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe OP clearly stated that he\
    \ doesn't want a sorting algorithm (even though this looks like a sorting algorithm).\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's my implementation with using of PHP built-in\
    \ functions:\n<code>\n<?php\n", "  echo \"<pre>\";\n  print_r($arr);\n  echo \"\
    </pre>\";\n  echo \"<br>\";\n  for ($i = 1; $i < count($arr); $i++) {\n    for\
    \ ($j = $i; $j > 0; $j--) {\n      if ($arr[$j] == $arr[$j - 1]) {\n        $arr[$j]\
    \ = $arr[$j - 1];\n        unset($arr[$j - 1]);\n        break;\n      }\n   \
    \ }\n  }\n  $return = array_merge(array_fill(0, count($arr), $arr[0]), $arr);\n\
    \  echo \"<pre>\";\n  print_r($return);\n  echo \"</pre>\";\n  return $return;\n\
    }\n", "    return array_map(function($v){\n            return $v*2 + $v % 2; //\
    \ -2 -> 0, -1 -> 1, 0 -> 1, 1 -> 2\n        }, SORT_NUMERIC, $arr);\n}", "  $res\
    \ = array();\n  foreach($arr as $k => $v) {\n    if($v == 0)\n      $res[$k] =\
    \ $k;\n    else {\n      for($i = $v; $i > 0; $i--)\n        $res[$k++] = $i;\n\
    \    }\n  }\n  return $res;\n}\n", "    return ksort(\n        ksort(\n      \
    \      ksort(\n                array_filter($arr, 'strcmp', ARRAY_FILTER_USE_BOTH)\n\
    \            )\n        )\n    );\n}\n", "    // your code\n}\n", "    // Write\
    \ your code here\n}\n", "    $arr2 = [];\n    foreach ($arr as $key => $value)\
    \ {\n        $bin = decbin($value);\n        $arr2[$key] = count($bin) - strlen($bin)\
    \ - 1;\n    }\n    array_multisort($arr2, SORT_ASC, $arr);\n    return $arr;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nMy solution:\n<code>\n<?php\n\
    \n$inputs = [\n    ['1', '2', '3', '4', '5', '6'],\n    ['2', '5', '4', '3', '6',\
    \ '1'],\n    ['2', '2', '2', '2', '2', '2'],\n    ['2', '5', '4', '3', '6', '1']\n\
    ];\n\n$results = [];\n\nforeach ($inputs as $input) {\n    $bin = decbin($input);\n\
    \    foreach ($bin as $key => $value) {\n        $results[$key][$value] = 0;\n\
    \    }\n}\n", "  // Your code goes here.\n  $result = [];\n  foreach ($arr as\
    \ $key => $value) {\n    foreach (str_split(decbin($value)) as $number) {\n  \
    \    if ($number[0] == '1') {\n        $result[$key] = $value;\n        break;\n\
    \      }\n    }\n  }\n  return $result;\n}\n", "\tfor ($i = 0, $length = count($arr);\
    \ $i < $length; $i++) {\n\t\t$digit = 0;\n\t\t$bin = 0;\n\t\t$tmp = $arr[$i];\n\
    \t\twhile ($tmp > 0) {\n\t\t\tif ($tmp % 2 == 1) {\n\t\t\t\t$digit += 1;\n\t\t\
    \t}\n\t\t\t$tmp /= 2;\n\t\t}\n\t\t$bin = base_convert($digit, 2, 10);\n\t\tif\
    \ ($bin > $i) {\n\t\t\t$tmp = array($arr[$i], $arr[$bin]);\n\t\t\t$arr[$i] = $tmp[0];\n\
    \t\t\t$arr[$bin] = $tmp[1];\n\t\t}\n\t}\n\tksort($arr);\n\treturn $arr;\n}\n$array\
    \ = array(\n\t'-1' => array(1, \"-1\"),\n\t'-2' => array(2, \"-2\"),\n\t'1' =>\
    \ array(1, \"1\", \"1\"),\n\t'2' => array(2, \"2\", \"2\"),\n\t'3' => array(3,\
    \ \"3\", \"3\", \"3\"),\n\t'4' => array(4, \"4\", \"4\", \"4\", \"4\", \"4\"),\n\
    \t'5' => array(5, \"5\", \"5\", \"5\"),\n\t'6' => array(6, \"6\", \"6\", \"6\"\
    , \"6\"),\n\t'7' => array(7, \"7\", \"7\", \"7\", \"7\", \"7\", \"7\"),\n\t'8'\
    \ => array(8, \"8\", \"8\", \"8\", \"8\", \"8\", \"8\", \"8\", \"8\", \"8\", \"\
    8\", \"8\", \"8\", \"8\", \"8\", \"8\", \"8\", \"8\"),\n\t'9' => array(9, \"9\"\
    , \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\"\
    , \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\", \"9\"\
    , \"9\", \"9\", \"9\", \"9\"),\n\t'10' => array(10, \"10\", \"10\", \"10\", \"\
    10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\",\
    \ \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\"\
    , \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\", \"10\"),\n\t\
    '11' => array(11, \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\", \"11\"\
    , \"11\", \"11\", \"11\", \"", "    $result = [];\n    $n = count($arr);\n   \
    \ if ($n <= 1) {\n        return $arr;\n    }\n\n    $counts = [];\n    for ($i\
    \ = 0; $i < $n; ++$i) {\n        $counts[$arr[$i]] = isset($counts[$arr[$i]])\
    \ ? $counts[$arr[$i]] + 1 : 1;\n    }\n    uasort($counts, function ($a, $b) {\n\
    \        return $a < $b ? -1 : 1;\n    });\n    foreach ($counts as $k => $v)\
    \ {\n        for ($i = 0; $i < $n; ++$i) {\n            if ($arr[$i] == $k) {\n\
    \                $result[] = $k;\n                unset($counts[$k]);\n      \
    \          break;\n            }\n        }\n    }\n    foreach ($counts as $k\
    \ => $v) {\n        $result[] = $k;\n    }\n    return $result;\n}", "    $arr_size\
    \ = count($arr);\n    for ($i = 0; $i < $arr_size; ++$i) {\n        for ($j =\
    \ 0; $j < $arr_size; ++$j) {\n            if ($arr[$i] == 0) {\n             \
    \   $temp_arr[$i] = $arr[$j];\n                $arr[$j] = $arr[$i];\n        \
    \        $arr[$i] = $temp_arr[$i];\n            }\n        }\n    }\n    return\
    \ $arr;\n}\n</code>\nThe code above is written for Python and Python's sort function,\
    \ but I hope you can understand the concept and adapt to your situation. You may\
    \ also want to study some other sorting algorithms.\n<|/ a tags=arrays,php dscore=1\
    \ |>\n<| c |>\nThis is good but it is worse than sorting the array in descending\
    \ order. \nYour code gives me the following result: \n`[-6, -5, -4, -3, -2] \n\
    [-1, -4, -5, -6, -3] \n[-2, -3, -5, -6, -1] \n[0, 1, 2, 3, 4]`\n<|/ c |>\n<| c\
    \ |>\nI apologize, I missed the part about sorting based on decimal value. I will\
    \ edit the answer with some code in the morning.\n<|/ c |>\n<| c |>\nI revised\
    \ the answer to sort in descending order.\n<|/ c |>\n<| c |>\nI've added a more\
    \ general solution (including both ascending and descending order).\n<|/ c |>\n\
    <| a tags=arrays,php |>\nSort it by the first decimal digit of the number\n<code>",
  "    // Write your code here\n}", "    $arr = array_map(\n        function($val)\
    \ { return $val === -1 ? -$val : $val; },\n        $arr\n    );\n    array_multisort(\n\
    \        $arr, SORT_ASC, $arr, SORT_NUMERIC,\n        $arr\n    );\n    return\
    \ $arr;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis might work for you:\n<code>",
  "  if (empty($arr)) {\n    return $arr;\n  }\n  if (count($arr) > 0) {\n    $ones\
    \ = array_count_values($arr);\n    if ($ones == array_slice($ones, 0, 1)) {\n\
    \      $result = $arr;\n    }\n    else {\n      $result = array_map(function\
    \ ($v) use ($ones) {\n        return $ones[$v];\n      }, $arr);\n      sort($result);\n\
    \    }\n  }\n  return $result;\n}\n", "    if (sizeof($arr) == 0) {\n        return\
    \ $arr;\n    }\n\n    $retArr = $arr;\n    foreach ($retArr as $index => $num)\
    \ {\n        $bin = bin2hex($num);\n        $len = strlen($bin);\n        if ($len\
    \ < 8) {\n            $retArr[$index] = str_pad($num, 8, '0');\n            continue;\n\
    \        }\n        $ones = 0;\n        for ($i = 7; $i >= 0; $i--) {\n      \
    \      $ones = $ones * 2 + $bin[$i];\n            if ($ones > 255) {\n       \
    \         break;\n            }\n        }\n        $retArr[$index] = hexdec(substr($bin,\
    \ 0, $i));\n    }\n    return $retArr;\n}\n", "    $result = $arr;\n    if (sizeof($arr))\
    \ {\n        $temp = 0;\n        $count = 1;\n        $i = 0;\n        while ($i\
    \ < sizeof($arr)) {\n            $temp += $arr[($i + 1)];\n            $count++;\n\
    \            $i++;\n        }\n        $result[$i] = $temp;\n        while ($count\
    \ > 1) {\n            $i--;\n            $temp = $arr[$i];\n            $count--;\n\
    \            while ($count > 1) {\n                $i--;\n                $temp\
    \ += $arr[$i];\n                $count--;\n            }\n            $temp +=\
    \ $arr[($i + 1)];\n            $count--;\n            $result[$i] = $temp;\n \
    \           $i++;\n        }\n        $result = array_reverse($result);\n    }\n\
    \    return $result;\n}", "    krsort($arr);\n    $arr = array_filter($arr, function\
    \ ($e) {\n        return $e >= 0;\n    });\n    return $arr;\n}\n</code>\n<|/\
    \ a tags=arrays,php |>\n<| c |>\nThe input array is assumed to be non-negative.\
    \ Anything else will result in a negative-zero result.\n<|/ c |>\n<| c |>\nYou\
    \ don't need `array_filter` because `krsort` already filters out the negative\
    \ values. And the `-` sign is important because that would change the sort order.\
    \ And `krsort` puts the highest number first.\n<|/ c |>\n<| c |>\nYou are correct,\
    \ `array_filter` is redundant, I should have removed it from the answer. `krsort`\
    \ is used here to preserve the order of the array elements. But you have a good\
    \ point, `-` sign in front of the number would change the order, and `krsort`\
    \ would put `1` before `0`.\n<|/ c |>\n<| a tags=arrays,php |>\nTry this\n<code>\n\
    <?php\n\n$a = [\n    array(3, -2),\n    array(5, 1),\n    array(2, 5),\n    array(4,\
    \ -1),\n    array(7, 3),\n];\n\nsort($a);\n\nprint_r($a);\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThe result should be as `[1, 2, 3, 4, 5]`. Your code gives `[7,\
    \ 5, 2, 4, 3]`\n<|/ c |>\n<| c |>\n: It's not exactly what you want, but it's\
    \ a start point. Try with [this](https://www.tehplayground.com/xKi1lLKTdQxjZYb).\n\
    <|/ c |>\n<| c |>\nYeah, that's a good start point. However, the input array is\
    \ assumed to be non-negative. Anything else will result in a negative-zero result.\n\
    <|/ c |>\n<| c |>\n: I understand. But I cannot help you further unless I see\
    \ what exactly is the logic behind your expected result and the data input. This\
    \ is the only way that I can think of...\n<|/ c |>\n<| a tags=arrays,php |>\n\
    In short, yes, this is possible with ksort. Try this:\n<code>", "    if ($arr\
    \ == null) {\n        return $arr;\n    }\n\n    // Create binary representation.\n\
    \    $bin = array_fill(0, count($arr), 0);\n    foreach ($arr as $i) {\n     \
    \   $bin[bindec($i)] |= $i;\n    }\n\n    // Sort by number of ones.\n    uasort($bin,\
    \ function($a, $b) {\n        return strlen($a) - strlen($b);\n    });\n\n   \
    \ // Sort by decimal value.\n    uasort($bin, function($a, $b) {\n        return\
    \ $a - $b;\n    });\n\n    // Convert to sorted array.\n    $out = array();\n\
    \    foreach ($bin as $i => $c) {\n        $out[] = $arr[$i];\n    }\n\n    return\
    \ $out;\n}\n\n/**\n * Test if given value is in given range using \"less than\"\
    \ comparison.\n * Ranges are defined by min, $min <= $value <= max.\n *\n * @param\
    \ int $value Value to test\n * @param int $min Min value\n * @param int $max Max\
    \ value\n * @return bool\n */", "    if (empty($arr)) {\n        return $arr;\n\
    \    }\n\n    // count ones in binary representation\n    $count = array_count_values(array_map(\n\
    \        function ($n) { return decbin($n); },\n        $arr\n    ));\n\n    //\
    \ sort by count of ones\n    krsort($count);\n\n    // sort by number of ones\n\
    \    uasort($count, function ($a, $b) {\n        return ($a < $b) ? -1 : 1;\n\
    \    });\n\n    // sort by decimal value\n    uasort($arr, 'compare_dec');\n\n\
    \    return $arr;\n}\n", "    asort($arr);\n    return $arr;\n}\n</code>\n<|/\
    \ a tags=arrays,php,sorting |>\n<| a |>\nThis should work:\n<code>\n$array = array(1,1,2,2,2,3,5,6,8,9,0,11,12,14,17,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,61,62,63,64,65,66,67,68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,",
  "    usort($arr, [__CLASS__, 'sort_array_cmp']);\n    return $arr;\n}", "    if\
    \ (is_null($arr)) return [];\n\n    foreach ($arr as $key => $val) {\n       \
    \ $arr[$key] = ($val < 0) ? -$val : $val;\n    }\n\n    // Sort by decresing value\n\
    \    array_multisort(array_map(function ($i) { return $i / abs($i); }, $arr),\
    \ $arr);\n\n    // Sort by decresing value\n    array_multisort(array_map(function\
    \ ($i) { return abs($i); }, $arr), $arr);\n\n    return $arr;\n}\n</code>\n<|/\
    \ a dscore=1 tags=sorting,php,arrays |>\n<| c |>\nThis does not answer the question.\n\
    <|/ c |>\n<| a dscore=1 |>\nI liked the previous answers very much, however I\
    \ had to tweak it to work with associative arrays and with numeric values.\n<code>",
  "    // TODO: Write you code here\n    return $arr;\n}\n</code>\n<|/ a tags=sorting,php,arrays\
    \ |>\n<| c |>\nI guess you meant `return array_reverse(array_merge(...))`\n<|/\
    \ c |>\n<| c |>\nOh yes, I was looking at the question wrong, you're right.\n\
    <|/ c |>\n<| a |>\nYou could try something like this. \n<code>", "    krsort($arr);\n\
    \    asort($arr);\n    return $arr;\n}\n", "    $counts = [];\n    foreach ($arr\
    \ as $num) {\n        if (!isset($counts[$num])) {\n            $counts[$num]\
    \ = 0;\n        }\n        $counts[$num]++;\n    }\n    arsort($counts);\n   \
    \ $result = [];\n    $index = 0;\n    foreach ($counts as $num => $count) {\n\
    \        for ($i = 0; $i < $count; $i++) {\n            $result[$index++] = $arr[$i];\n\
    \        }\n    }\n    return $result;\n}", "    $res = array();\n    foreach\
    \ ($arr as $key => $val) {\n        $res[$key] = $val;\n    }\n    asort($res);\n\
    \    return $res;\n}\n\n$nums = array(\n    -1, 0, -3, -6, -8, -1,\n    1, 2,\
    \ 3, 4, 5, 6,\n    1, 2, 1, 4, 5, 6,\n    1, 2, 3, 1, 0, 2,\n    2, 2, 3, 1, 0,\
    \ 2,\n);\n\necho print_r($nums, true);\n</code>\nResults:\n<code>\nArray\n(\n\
    \    [0] => -1\n    [1] => 0\n    [2] => -3\n    [3] => -6\n    [4] => -8\n  \
    \  [5] => -1\n    [6] => 1\n    [7] => 2\n    [8] => 3\n    [9] => 4\n    [10]\
    \ => 5\n    [11] => 6\n    [12] => 1\n    [13] => 4\n    [14] => 2\n    [15] =>\
    \ 3\n)\n</code>\n<|/ a |>\n<| c |>\nThe solution is very simple, just use 'sort'\
    \ function.\n<|/ c |>\n<| c |>\nThe answer was too long for the comment box so\
    \ I added it as an answer.\n<|/ c |>\n<| c |>\nI agree it's simple, but it's not\
    \ what the OP asked for. The question explicitly states that they need to sort\
    \ a non-negative integers array according to number of ones in their binary representation\
    \ in ascending order. `sort` will not do the trick.\n<|/ c |>\n<| c |>\nThank\
    \ you for pointing out that the sorting must be based on the number of ones. I've\
    \ edited the answer to reflect that.\n<|/ c |>\n<| a tags=php,algorithm dscore=2\
    \ |>\nTry this - \n<code>\n$arr = array(1,5,2,3,4);\n$result= $arr;", "    foreach\
    \ ($arr as &$value) {\n        if (is_int($value)) {\n            $value = (1\
    \ << $value) - 1;\n        } elseif (is_string($value)) {\n            $value\
    \ = strrev($value);\n        }\n    }\n    asort($arr);\n    return $arr;\n}\n",
  "\tusort($arr, function($a, $b) {\n\t\t$binA = $binB = sprintf('%o', $a);\n\t\t\
    $binA .= sprintf('%o', $b);\n\t\treturn $binA > $binB;\n\t});\n\n\treturn $arr;\n\
    }\n", "  $cmp_fn = function($a, $b) use ($arr) {\n    if ($a === $b) { return\
    \ 0; }\n    return $a < $b ? -1 : 1;\n  };\n  return array_reduce($arr, function($carry,\
    \ $item) {\n    $carry[] = $item;\n    return $carry;\n  }, array());\n}\n", " \
    \   $n = count($arr);\n    for ($i = 0; $i < $n; ++$i) {\n        $ones = array_sum(array_slice($arr,\
    \ $i, $i));\n        if ($ones == 1) {\n            $tmp = array_slice($arr, $i,\
    \ 1);\n            $arr[$i] = $tmp[0];\n        }\n    }\n    array_walk($arr,\
    \ function (&$v) {\n        $v = -$v;\n    });\n    array_multisort($arr, SORT_ASC,\
    \ $arr);\n    return $arr;\n}\n</code>\n<|/ a tags=php |>\n<| a dscore=2 |>\n\
    I guess you are trying to implement a sort function that could work for any type\
    \ of numbers (not just integers).\nThe most simple solution would probably be\
    \ to create a function that converts your number to a string and then use that\
    \ for sorting\n<code>\n$myArray = array(1, 9, 11, 4, 3, 1);\n", "  if (empty($arr))\
    \ {\n    return;\n  }\n  $sorted = array_count_values($arr);\n  arsort($sorted);\n\
    \  $result = array();\n  foreach ($arr as $i => $c) {\n    if ($c === 0) {\n \
    \     $result[] = $i;\n    }\n  }\n  return $result;\n}\n</code>\nThe only thing\
    \ you need to do is write a test for your sort_array function, then you can compare\
    \ it with the built-in functions. \n<code>", "    if (empty($arr)) {\n       \
    \ return $arr;\n    }\n\n    $res = array();\n\n    foreach ($arr as $key => $val)\
    \ {\n        $tmp = 0;\n        foreach (str_split(decbin($val)) as $bit) {\n\
    \            $tmp += $bit;\n        }\n        $res[$key] = $tmp;\n    }\n\n \
    \   if (count($res) > 1) {\n        ksort($res);\n    }\n\n    return $res;\n\
    }\n", "    \n}\n", "  return array_merge(\n      array_count_values($arr), arsort($arr)\n\
    \  );\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a dscore=2 |>\n<code>", "    //\
    \ O(n) solution\n    $result = [];\n    $onesCounts = [];\n    foreach ($arr as\
    \ $num) {\n        $index = decbin($num)[1];\n        if (! isset($onesCounts[$index]))\
    \ {\n            $onesCounts[$index] = 0;\n        }\n        $onesCounts[$index]++;\n\
    \        if ($onesCounts[$index] > 1) {\n            $result[] = $num;\n     \
    \   }\n    }\n    return $result;\n}\n", "    ksort($arr);\n    foreach ($arr\
    \ as &$value) {\n        $arr[$value] = bindec($value);\n    }\n    ksort($arr);\n\
    \    return $arr;\n}", "    usort($arr, function($a, $b) {\n        $sum = (int)\
    \ $a ^ $b;\n        $diff = strspn(str_pad('1', $sum, STR_PAD_RIGHT), '1');\n\
    \        if ($diff === 0) {\n            return 0;\n        }\n        return\
    \ ($diff < 0) ? -1 : 1;\n    });\n    return $arr;\n}\n", "    sort($arr);\n \
    \   return $arr;\n}\n", "    $ret = array();\n    foreach ($arr as $v) {\n   \
    \     $k = 0;\n        while ($v & 1 << $k) {\n            $k++;\n        }\n\
    \        $ret[] = $v;\n    }\n    foreach ($ret as $k => $v) {\n        $ret[$k]\
    \ = $v % 2 == 0 ? $k : -$k;\n    }\n    return $ret;\n}\n", "    $ones = 0;\n\
    \    foreach($arr as $n) {\n        $ones += (1 << $n);\n    }\n    return array_reverse(array_merge(array_count_values($arr),\
    \ [$ones]));\n}\n", "    $count = array_count_values($arr);\n    asort($count);\n\
    \    $index = 0;\n    foreach ($count as $k => $v) {\n        $count[$k] = 0;\n\
    \        foreach ($arr as $i) {\n            if ($i === $k) {\n              \
    \  $count[$k]++;\n                break;\n            }\n        }\n    }\n  \
    \  $result = [];\n    foreach ($arr as $k) {\n        if ($count[$k] === 0) {\n\
    \            $result[] = $k;\n        }\n    }\n    return $result;\n}\n$arr =\
    \ array(3, 2, 5, 9, 2, 1);\nprint_r(sort_array($arr));\n</code>\n<|/ a tags=php,algorithm,arrays\
    \ dscore=1 |>\n<| c |>\nThis does not return `[3, 2, 5, 9, 2, 1]` as OP requested.\n\
    <|/ c |>\n<| c |>\n, I've updated my answer\n<|/ c |>\n<| c |>\nThis looks really\
    \ interesting but I can't get it to work and it seems that I'm missing something\
    \ in the logic of the code\n<|/ c |>\n<| c |>\n, I've added a test\n<|/ c |>\n\
    <| c |>\nAh, that works! However, it gives me `[3, 2, 1, 2, 9, 5]`instead of `[3,\
    \ 2, 5, 9, 2, 1]`. However, I can change this to a for loop and then do some adjustments.\
    \ Thanks!\n<|/ c |>\n<| a |>\nYou could use usort, with a custom comparator function.\n\
    The custom comparator function compares the two array values, and returns an array\
    \ of the indices of where the values differ.\n<code>", "    $res = [];\n\n   \
    \ $count = array_count_values($arr);\n    foreach ($count as $cnt => $n) {\n \
    \       $res[$cnt] = $n;\n    }\n    asort($res);\n    foreach ($res as $key =>\
    \ $n) {\n        $res[$key] = $arr[$key];\n    }\n    return $res;\n}", "\tusort($arr,\
    \ function($a, $b) {\n\t\tif ($a == $b) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn\
    \ strpos($a, $b);\n\t});\n\treturn $arr;\n}\n", "    if (empty($arr)) return $arr;\n\
    \    $arr = array_map('intval', array_values($arr));\n    usort($arr, function($a,\
    \ $b) {\n        $ones_a = bindec(bindec($a)[1]);\n        $ones_b = bindec(bindec($b)[1]);\n\
    \        return $ones_a < $ones_b ? -1 : 1;\n    });\n    return $arr;\n}\n",
  "    $tmp = array();\n    foreach ($arr as $key => $value) {\n        $tmp[$value]\
    \ = $key;\n    }\n    asort($tmp);\n    $out = array();\n    foreach ($tmp as\
    \ $key => $value) {\n        $out[$value] = $key;\n    }\n    return $out;\n}\n",
  "    if (empty($arr)) {\n        return $arr;\n    }\n    $new_arr = array();\n\
    \    foreach ($arr as $key => $value) {\n        if ($value < 0) {\n         \
    \   $new_arr[$key] = $value;\n        } else {\n            $ones = bindec($key);\n\
    \            $tens = $value % 10;\n            $tens_pow = (int) ($value - $tens);\n\
    \            $tens_pow *= 10;\n            $tens_bin = bindec($tens);\n      \
    \      $tens_bin = ($tens_bin < 10 ? '0' : '').$tens_bin;\n            $new_arr[$ones]\
    \ = $tens_bin . $tens_pow;\n        }\n    }\n    return array_values($new_arr);\n\
    }", "  usort($arr, 'sort_array_func');\n  return $arr;\n}\n", "  return $arr;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nYou can just use PHP's sort()\
    \ function and implement a custom callback for the comparison:\n<code>", "\tforeach($arr\
    \ as &$num) {\n\t\tif ($num < 0)\n\t\t\t$num = ~$num; // make it unsigned\n\t\t\
    $num = ~$num; // make it unsigned\n\t}\n\tkrsort($arr);\n\treset($arr);\n\treturn\
    \ $arr;\n}\n", "    $arr = array_filter($arr, function ($value) {\n        return\
    \ is_int($value);\n    });\n\n    if (empty($arr)) {\n        return $arr;\n \
    \   }\n\n    $arr = array_count_values($arr);\n\n    usort($arr, function ($a,\
    \ $b) {\n        $aCount = $arr[$a];\n        $bCount = $arr[$b];\n        if\
    \ ($aCount === $bCount) {\n            return 0;\n        }\n        if ($aCount\
    \ < $bCount) {\n            return 1;\n        }\n        return -1;\n    });\n\
    \n    return array_values($arr);\n}\n</code>\n<|/ a tags=arrays,php |>\n<| c |>\n\
    If you're using PHP 5.5+, you can use `array_column` to get the array keys, instead\
    \ of iterating over the entire array again\n<|/ c |>\n<| c |>\nNice! This really\
    \ helped me. Thanks!\n<|/ c |>\n<| a dscore=5 |>\nI needed a solution that will\
    \ work on both versions and be able to sort the array with a specific key. I came\
    \ up with the following function :\n<code>", "  $sorted = [];\n  $bits = preg_split('//',\
    \ $arr);\n  foreach ($bits as $bit) {\n    $count = 0;\n    for ($i = strlen($bit)\
    \ - 1; $i >= 0; $i--) {\n      $count += ($bit[$i] == '1');\n    }\n    $sorted[]\
    \ = $count;\n  }\n  ksort($sorted);\n  return array_reverse($sorted);\n}", " \
    \   $ones = array_count_values($arr);\n    uksort($ones, function ($a, $b) use\
    \ ($ones) {\n        return strnatcmp($ones[$a], $ones[$b]);\n    });\n    return\
    \ $arr;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
