name: HumanEval_33_sort_third
language: php
prompt: "<?php\n// This function takes a list l and returns a list l' such that\n\
  // l' is identical to l in the indicies that are not divisible by three, while its\
  \ values at the indicies that are divisible by three are equal\n// to the values\
  \ of the corresponding indicies of l, but sorted.\n// >>> sort_third([1, 2, 3])\n\
  // [1, 2, 3]\n// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\n\
  function sort_third($l) {\n"
tests: "function candidate(...$args) {\n    return sort_third(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(5, 6, 3, 4, 8, 9, 2)) !== array(2, 6,\
  \ 3, 4, 8, 9, 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(5,\
  \ 8, 3, 4, 6, 9, 2)) !== array(2, 8, 3, 4, 6, 9, 5)) { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(array(5, 6, 9, 4, 8, 3, 2)) !== array(2, 6, 9,\
  \ 4, 8, 3, 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(5,\
  \ 6, 3, 4, 8, 9, 2, 1)) !== array(2, 6, 3, 4, 8, 9, 5, 1)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["\t$l3 = [];\n\tforeach ($l as $key => $val)\n\t\t$l3[$val % 3] = $val;\n\
    \t$l3 = array_values($l3);\n\tsort($l3);\n\treturn $l3;\n}", "  foreach ($l as\
    \ $key => $val) {\n    if ($key % 3 != 0) {\n      if ($key % 3 != 0 && $key %\
    \ 3 != 1) {\n        $l[$key] = $val;\n      }\n      elseif ($key % 3 == 1) {\n\
    \        $l[$key - 3] = $val;\n      }\n    }\n  }\n  ksort($l);\n  return $l;\n\
    }\n", "  $l2 = array_map('intval', $l);\n  $l3 = array_map('sort', $l2);\n  return\
    \ $l3;\n}", "\t$third = array();\n\tfor($i = 0; $i < count($l); $i++) {\n\t\t\
    if($i % 3 != 0)\n\t\t\t$third[] = $l[$i];\n\t\telse {\n\t\t\t$t = 0;\n\t\t\tfor($k\
    \ = 0; $k < count($l); $k += 3) {\n\t\t\t\tif($l[$k] < $l[$k + 1])\n\t\t\t\t\t\
    $t++;\n\t\t\t}\n\t\t\tif($t == 1)\n\t\t\t\t$third[] = $l[$i];\n\t\t\telse if($t\
    \ == 2)\n\t\t\t\t$third[] = $l[$i - 2];\n\t\t\telse if($t == 3)\n\t\t\t\t$third[]\
    \ = $l[$i - 1];\n\t\t\telse {\n\t\t\t\t$third[] = $l[$i];\n\t\t\t\t$third[] =\
    \ $l[$i - 2];\n\t\t\t\t$third[] = $l[$i - 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn $third;\n\
    }\n", "  $l2 = [];\n  for ($i = 0; $i < count($l); $i++) {\n    $l3 = [$i];\n\
    \    for ($j = $i + 1; $j < count($l); $j++) {\n      if ($l[$j] % 3 == 0) {\n\
    \        $l3[] = $l[$j];\n      }\n    }\n    $l3[] = $l[$i];\n    $l2[] = $l3;\n\
    \  }\n  return $l2;\n}\n", "    $l1 = array_shift($l);\n    $l2 = array_shift($l);\n\
    \    $l3 = array_shift($l);\n    sort($l1);\n    sort($l2);\n    sort($l3);\n\
    \    $l1 = array_merge($l2, $l1, $l3);\n    return $l1;\n}\n", "    for($i = 0;\
    \ $i < count($l); $i += 3) {\n        $third = array_slice($l, $i, 3);\n     \
    \   sort($third);\n        array_splice($l, $i, 3, $third);\n    }\n    return\
    \ $l;\n}\n</code>\nIn response to the comments:\n<code>\n<?php\n", "  $lprime\
    \ = array_filter($l, function($x) { return ($x & 3) === 0; });\n  $lprime = sort($lprime);\n\
    \  $l = array_filter($l, function($x) { return ($x & 3) !== 0; });\n  $l = array_merge($lprime,\
    \ $l);\n  return $l;\n}\n", "    return array_map(\n        function ($a) use\
    \ ($l) {\n            return $l[($a % 3) / 3];\n        },\n        array_slice($l,\
    \ 0, count($l) / 3)\n    );\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nSorry but\
    \ i think i was unclear. I am looking for two elements that are equal and they\
    \ should be next to each other. I am not looking for a pairing function. My bad!\
    \ I will edit the post to clarify it.\n<|/ c |>\n<| c |>\n- Ok, understood. Have\
    \ updated the answer. Hope it helps.\n<|/ c |>\n<| c |>\nThank you for your help.\
    \ This is exactly what I was looking for.\n<|/ c |>\n<| a tags=php,arrays,sorting\
    \ |>\nNot sure if I'm missing something or what exactly you're asking, but if\
    \ you want two numbers that are equal, just sort them by value descending and\
    \ then compare the first two results of the array you sort.\n<code>\n$arr = [10,10,10,10,10,10];\n\
    usort($arr, function($a, $b) {\n    if ($a == $b)\n        return 0;\n    return\
    \ $a > $b ? 1 : -1;\n});\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is what I\
    \ was looking for. I did not know about usort.\n<|/ c |>\n<| a |>\nIf you are\
    \ not looking for pairing then you can do this:\n<code>\n<?php\n\n$arr = array(1,2,3,4,5,6);\n\
    $temp = $arr[0];\n$temp2 = $arr[0];\n\nfor($i=0;$i<count($arr);$i++)\n{\n    if($arr[$i]!=$temp)\n\
    \    {\n        echo $temp; echo ($arr[$i]);\n        $temp = $arr[$i];\n    }\n\
    \    else\n    {\n        echo $temp2; echo ($arr[$i]);\n        $temp2 = $arr[$i];\n\
    \    }\n}", "    sort($l, SORT_NUMERIC);\n    $n = count($l);\n    $i = 3;\n \
    \   for($i = 0;  $i < $n;  $i += $i) {\n        $j = $i;\n        for($j++;  $j\
    \ < $n;  $j += $i) {\n            if($j % $i == 0) continue;\n            $x =\
    \ $l[$i];\n            $l[$i] = $l[$j];\n            $l[$j] = $x;\n        }\n\
    \    }\n    return $l;\n}\n</code>\n<|/ a |>\n<| c |>\nI ran your code. There\
    \ are some errors. Check `sort_third([5, 6, 3, 4, 8, 9, 2])\n` output. the output\
    \ should be: `[2, 6, 3, 4, 8, 9, 5]`\n<|/ c |>\n<| c |>\n: Sorry about that; I\
    \ fixed my code to fix these bugs, as well as a new example to verify it works.\
    \ I realized that there are some edge cases with this, too. I edited my code again\
    \ and added a new example.\n<|/ c |>\n<| c |>\nThank you very much! That's really\
    \ great.\n<|/ c |>\n<| c |>\nNo problem. Glad I could help and happy to have helped.\n\
    <|/ c |>\n<| a dscore=0 |>\nThis should do the trick:\n<code>\n<?php", "    foreach\
    \ ($l as $index => $value) {\n        if ($index % 3 != 0) $l[$index] = $value;\n\
    \    }\n    foreach ($l as $index => $value) {\n        if ($index % 3 == 0) $l[$index]\
    \ = $value;\n    }\n    usort($l, 'sort_third_callback');\n    return $l;\n}\n",
  "  for ($i = 0; $i < count($l); $i++) {\n    // Iterate over each index\n    $count\
    \ = 1;\n    while ($count < 3) {\n      if ($i % $count == 0) {\n        // If\
    \ the current index is divisible by three, move it to the next index right after\
    \ it.\n        // If not, then move the index to the first position and skip to\
    \ the next index\n        $i++;\n        break;\n      }\n      $count++;\n  \
    \  }\n    if ($i == count($l)) {\n      // If there are no more indices, append\
    \ the elements from $l to the end of the list $l\n      $l[] = $l[$i - 1];\n \
    \   }\n    else {\n      // If there are more indices, then append the elements\
    \ from $l to the end of the list $l\n      $l[] = $l[$i];\n      $l[] = $l[$i\
    \ - 1];\n    }\n  }\n  return $l;\n}\n", "  $l2 = [];\n  $l3 = [];\n  foreach\
    \ ($l as $k => $v) {\n    $l3[$k] = $l3[$k] ? $l3[$k] : $v;\n  }\n  ksort($l3);\n\
    \  foreach ($l3 as $k => $v) {\n    $l2[$k] = $k;\n  }\n  return $l2;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks, that worked. I was trying to do this in one\
    \ line with array_intersect_key() but I wasn't really sure how to get it to sort\
    \ the values I wanted.\n<|/ c |>\n<| a dscore=0 |>\nYou can use array_multisort()\
    \ function,\nhttp://php.net/manual/en/function.array-multisort.php\n<|/ a tags=arrays,sorting,php\
    \ |>\n<| a tags=arrays,sorting,php |>\nI used a mix of array_multisort and array_walk.\
    \  \n<code>\n$array = array(4,2,7,1,3,5,6,8);\n\n$result = [];\narray_walk($array,\
    \ function($a) use (&$result) {\n  if ($a % 3 === 0) {\n    $result[] = $a;\n\
    \  }\n});\n\narray_multisort($result, SORT_DESC, SORT_NUMERIC, $array);\n\nprint_r($array);\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis worked for me:\n<code>\n$arr\
    \ = [7,5,1,4,6,8,2,3];", "    $size = sizeof($l);\n    $third = $size/3;\n   \
    \ $i = 0;\n    while($i < $third){\n        if($l[$i] != $l[$i+1] && $l[$i] !=\
    \ $l[$i+2]){\n            $l[$i] = $l[$i+1];\n            $l[$i+1] = $l[$i+2];\n\
    \            $l[$i+2] = $l[$i];\n        }\n        $i++;\n    }\n    $i = 0;\n\
    \    while($i < $size){\n        if($l[$i] != $l[$i+1] && $l[$i] != $l[$i+2]){\n\
    \            $l[$i] = $l[$i+1];\n            $l[$i+1] = $l[$i+2];\n          \
    \  $l[$i+2] = $l[$i];\n        }\n        $i++;\n    }\n    return $l;\n}", " \
    \   return array_map(\n        function ($e) {\n            return $e % 3;\n \
    \       }, \n        array_values($l)\n    );\n}\n", "    // return sorted($l);\n\
    \    $l2 = array();\n    foreach ($l as $i => $e) {\n        if ($i % 3 != 0)\
    \ {\n            $l2[$i] = $e;\n        }\n    }\n    // return array($l2);\n\
    \    return array_values($l2);\n}\n", "    $lenght = count($l);\n    $third =\
    \ 0;\n    $i = 0;\n    for ($i=0; $i<$lenght; $i++) {\n        if (($l[$i] % 3)\
    \ != 0) {\n            $l[$third++] = $l[$i];\n        } else {\n            $l[$third]\
    \ = $l[$i];\n        }\n    }\n    return $l;\n}\n", "  if ($l == '') {\n    return\
    \ $l;\n  }\n  $l = array_map('intval', $l);\n  // sort by value\n  sort($l);\n\
    \  // add back non-divisible values\n  for ($i = 0; $i < count($l); $i += 3) {\n\
    \    if ($l[$i] % 3 != 0) {\n      $l[$i] += $l[$i] / 3;\n    }\n  }\n  return\
    \ $l;\n}\n", "    // create an array with index 0 as our base case\n    $l3 =\
    \ [];\n    $l3[0] = &$l3[0];\n    $l3[0] = &$l3[0];\n    $l3[1] = &$l3[1];\n \
    \   $l3[2] = &$l3[2];\n    $l3[3] = &$l3[3];\n    $l3[4] = &$l3[4];\n    $l3[5]\
    \ = &$l3[5];\n    // loop through l copying each value into the appropriate index\
    \ depending on whether it is divisible by 3 or not\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if ($i % 3 == 0) {\n            $l3[$i] = $l[$i];\n       \
    \ } else {\n            $l3[$i] = &$l[$i];\n        }\n    }\n    // create an\
    \ array to hold our sorted copy\n    $l4 = [];\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if ($i % 3 == 0) {\n            $l4[] = $l3[$i];\n        }\
    \ else {\n            $l4[] = &$l3[$i];\n        }\n    }\n    // sort the copy\
    \ and return the new list\n    sort($l4);\n    return $l4;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nI love how this works but I wouldn't say it is as intuitive as\
    \ the other answers. It is more of a \"functional\" approach to the problem.\n\
    <|/ c |>\n<| c |>\nI agree with you about readability, but I believe it can be\
    \ done in a much simpler way. I'm not entirely sure what `&$l3[$i]` does but I\
    \ think it makes you make a copy of every value in the list, which is unnecessary\
    \ if all you want is a sorted copy. Also, `&$l3[$i]` isn't necessary. If you were\
    \ to run my function, you'll notice I didn't need to make copies of every value\
    \ in the list because I knew my list would always be of length 6. I believe this\
    \ makes your function more concise and efficient.\n<|/ c |>\n<| c |>\nI realize\
    \ now that you're right. I've actually been trying to think of a way I can make\
    \ this more concise since I came across this problem before and decided to try\
    \ and make my solution a bit more concise. Looks like I missed something really\
    \ obvious! Thank you for pointing this out. I'll edit my answer accordingly.\n\
    <|/ c |>\n<| a tags=php,arrays,sorting dscore=1 |>\nTry this. I think it will\
    \ help you.\n<code>\n<?php\n\n$arr1 = ", "    $l = array_slice($l, 0, count($l)\
    \ / 2);\n    sort($l);\n    array_splice($l, 0, count($l) / 2, $l);\n    return\
    \ $l;\n}\n", "    $llength = count($l);\n    $third = array_chunk($l, 3);\n  \
    \  $thirdlength = count($third);\n\n    for ($i = 0; $i < $thirdlength; $i++)\
    \ {\n        $third[$i][1] = array_search($third[$i][0], $l);\n    }\n\n    for\
    \ ($i = 0; $i < $llength; $i++) {\n        $l[$i][2] = array_search($l[$i][0],\
    \ $l);\n    }\n\n    for ($i = 0; $i < $thirdlength; $i++) {\n        for ($j\
    \ = 0; $j < $llength; $j++) {\n            if ($third[$i][0] === $l[$j][0]) {\n\
    \                unset($l[$j][2]);\n                array_splice($third[$i], $i,\
    \ 1, $l[$j]);\n                break;\n            }\n        }\n    }\n    return\
    \ array_merge($l, $third);\n}\n\n/**\n * Merges two lists and returns the result.\n\
    \ * @param array $a First list.\n * @param array $b Second list.\n * @return array\n\
    \ */", "    $l2 = $l;\n    sort($l2, SORT_NUMERIC);\n    $l3 = array();\n    for\
    \ ($i = 0; $i < count($l2); $i++) {\n        if ($i % 3 === 0) {\n           \
    \ $l3[] = $l[$i];\n        } else {\n            $j = ($i + 2) / 3;\n        \
    \    $l3[$j] = $l[$i];\n        }\n    }\n    return $l3;\n}\n", "    $n = count($l);\n\
    \    foreach (range(0, $n-2) as $i1) {\n        foreach (range($i1+1, $n-1) as\
    \ $i2) {\n            foreach (range($i2+1, $n) as $i3) {\n                if\
    \ ( divisible_by_three($l[$i1], $l[$i2], $l[$i3]) ) {\n                    if\
    \ ( divisible_by_three($l[$i2], $l[$i3], $l[$i1]) ) {\n                      \
    \  $t = $l[$i1];\n                        $l[$i1] = $l[$i2];\n               \
    \         $l[$i2] = $l[$i3];\n                        $l[$i3] = $t;\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ $l;\n}\n", "  for ($i=0;$i<count($l)-1;$i++) {\n    for ($j=0;$j<$i;$j++) {\n\
    \      if ($l[$j] % 3 == 0) {\n        list($l[$j], $l[$i]) = array($l[$i], $l[$j]);\n\
    \      }\n    }\n  }\n  return $l;\n}", "  $l1 = array();\n  foreach($l as $key=>$val)\n\
    \  {\n    if($key%3==0)\n      $l1[$key]=$val;\n  }\n  return $l1;\n}\n", "  \
    \  foreach ($l as $index => $value) {\n        if ($index % 3 == 0) {\n      \
    \      $l[$index] = $value;\n            unset($l[$index - 1]);\n            unset($l[$index\
    \ + 1]);\n        }\n    }\n    return $l;\n}\n", "    asort($l);\n    return\
    \ array_merge(array_slice($l, 0, ceil(count($l) / 3)), array_slice($l, ceil(count($l)\
    \ / 3) * 3, ceil(count($l) / 3) * 3), array_slice($l, ceil(count($l) / 3) * 3));\n\
    }\n", "  $leng = count($l);\n  for ($i = 0; $i < $leng; ++$i) {\n    $count =\
    \ 0;\n    for ($j = $i + 1; $j < $leng; ++$j) {\n      if ($l[$i] % 3 === 0) {\n\
    \        if ($l[$j] % 3 === 0)\n          $l[$i] = $l[$j];\n        else\n   \
    \       $count++;\n      }\n    }\n    if ($count === 1)\n      $l[$i] = $l[$i];\n\
    \  }\n  return $l;\n}\n", "    $l1 = array();\n    $l2 = array();\n    $l3 = array();\n\
    \    $n = count($l);\n    // If there are two or more non-divisible numbers, they\
    \ will be put in the first list\n    // This means if the first list contains\
    \ three non-divisible numbers, they are put in the third list\n    // If there\
    \ are only two non-divisible numbers, they are put in the first list\n    $index\
    \ = 0;\n    while ($index < $n) {\n        $test = $l[$index];\n        if (!is_int($test))\
    \ {\n            $l1[$test] = $test;\n            $l2[$test] = $test;\n      \
    \      $l3[$test] = $test;\n        }\n        // If this index is divisible by\
    \ three\n        // Put it in the first list if it is less than the next non-divisible\
    \ number\n        // This means if the first list contains three non-divisible\
    \ numbers, they are put in the third list\n        // If there are only two non-divisible\
    \ numbers, they are put in the first list\n        // Otherwise the numbers in\
    \ the first and second lists are equal\n        else {\n            $remainder\
    \ = intval($test / 3);\n            if ($test % 3 == 0) {\n                if\
    \ ($remainder < $l[$index + 1]) {\n                    $l1[$test] = $test;\n \
    \                   $l2[$test] = $test;\n                    $l3[$test] = $test;\n\
    \                }\n            }\n            // If this index is NOT divisible\
    \ by three\n            // Put it on its corresponding non-divisible number\n\
    \            else {\n                if ($l[$index] < $remainder) {\n        \
    \            $l1[$test] = $test;\n                    $l2[$test] = $test;\n  \
    \                  $l3[$test] = $test;\n                }\n                //\
    \ Otherwise put it on the non-divisible number that is divisible by three\n  \
    \              else {\n                    $l1[$test] = $l[$index];\n        \
    \            $l2[$test] = $remainder;\n                    $l3[$test] = $l[$index\
    \ + 1];\n                }\n            }\n        }\n        $index++;\n    }\n\
    \    return array($l1, $l2, $l3);\n}", "  for ($i = 0; $i < count($l); $i++) {\n\
    \    for ($j = 0; $j < (count($l) - $i); $j++) {\n      if ($j % 3 == 0) {\n \
    \       $l[$j + 1] = $l[$j];\n        unset($l[$j]);\n      }\n    }\n  }\n  return\
    \ $l;\n}\n", "    return array_merge(\n        array_intersect_key(\n        \
    \    array_flip($l),\n            array_filter(\n                array_unique(\n\
    \                    array_filter(\n                        array_intersect_key(\n\
    \                            array_flip($l),\n                            array_filter(\n\
    \                                array_count_values(\n                       \
    \             array_flip($l)\n                                )\n            \
    \                )\n                        ),\n                        function($x){\n\
    \                            return $x % 3 == 0;\n                        }\n\
    \                    )\n                ),\n                function($x){\n  \
    \                  return $x % 3 == 0;\n                }\n            )\n   \
    \     ),\n        array_values($l)\n    );\n}\n</code>\n<|/ a dscore=1 tags=arrays,php\
    \ |>\n<| a |>\nYou can do it using array_slice() and array_merge(). First slice\
    \ your array from 0 to 3, then merge it with your original array from 3 to end(original\
    \ array length).\n<code>\n$array = array_slice($array, 3, 0, true) . \n      \
    \  array_merge(array_slice($array, 3, $array.length, true));\n</code>\n<|/ a tags=arrays,php\
    \ dscore=0 |>\n<| a tags=arrays,php |>\narray_merge_recursive is probably the\
    \ best option, but this should work as well (tested with PHP 5.4):\n<code>\n<?php\n\
    $original = [\n    0 => ['apples', 'oranges', 'pears'],\n    1 => ['apples', 'pears'],\n\
    \    2 => ['oranges'],\n    3 => ['oranges', 'pears', 'apples', 'pears'],\n  \
    \  4 => ['pears', 'pears'],\n    5 => ['pears', 'apples', 'pears'],\n    6 =>\
    \ ['oranges', 'pears'],\n    7 => ['pears', 'pears'],\n];\n\n$result = array_merge(\n\
    \    array_map(\n        function($key, $value) {\n            $slice = array_slice($value,\
    \ 0, 3);\n            return array_merge(\n                $slice,\n         \
    \       array_map(\n                    function($slice, $key) use ($value) {\n\
    \                        $newValue = array_unique($slice);\n                 \
    \       $newValue[$key] = $value;\n                        return $newValue;\n\
    \                    },\n                    $slice,\n                    array_keys($slice)\n\
    \                )\n            );\n        },\n        array_keys($original),\n\
    \        array_values($original)\n    ),\n    $original\n);\n\nprint_r($result);\n\
    </code>\nOutput\n<code>\nArray\n(\n    [0] => Array\n        (\n            [0]\
    \ => apples\n            [1] => oranges\n            [2] => pears\n          \
    \  [3] => oranges\n            [4] => pears\n            [5] => pears\n      \
    \      [6] => oranges\n            [7] => pear", "\t$len = $l->length;\n\t$l->sort(sub\
    \ {\n\t\tmy ($x, $y) = @_;\n\t\tmy $x_mod = $x % 3;\n\t\tmy $y_mod = $y % 3;\n\
    \t\treturn $x_mod <=> $y_mod unless ($x_mod && $y_mod);\n\t\treturn $x_mod <=>\
    \ $y;\n\t});\n\tfor (my $i = 0; $i < $len; $i += 3) {\n\t\tfor (my $j = $i + 1;\
    \ $j < $len; $j += 3) {\n\t\t\tmy $x = $l->[$i];\n\t\t\tmy $y = $l->[$j];\n\t\t\
    \t$l->[$i] = $y;\n\t\t\t$l->[$j] = $x;\n\t\t}\n\t}\n\treturn $l;\n}\n\nsub _sum\
    \ {\n\tmy ($list, $carry, $head) = @_;\n\treturn $carry + ($head + $list->[$head]);\n\
    }\n\nsub _product2 {\n\tmy ($list, $carry, $head) = @_;\n\treturn $head * $carry\
    \ + ($list->[$head] * $carry);\n}\n\nsub _product3 {\n\tmy ($list, $carry, $head)\
    \ = @_;\n\treturn $head * $carry + ($list->[$head] * $list->[$head + 1] * $carry);\n\
    }\n\nsub _product4 {\n\tmy ($list, $carry, $head) = @_;\n\treturn $head * $carry\
    \ + ($list->[$head] * $list->[$head + 1] * $list->[$head + 2] * $carry);\n}\n\n\
    sub _product5 {\n\tmy ($list, $carry, $head) = @_;\n\treturn $head * $carry +\
    \ ($list->[$head] * $list->[$head + 1] * $list->[$head + 2] * $list->[$head +\
    \ 3] * $carry);\n}\n\nsub _product6 {\n\tmy ($list, $carry, $head) = @_;\n\treturn\
    \ $head * $carry + ($list->[$head] * $list->[$head + 1] * $list->[$head + 2] *\
    \ $list->[$head + 3] * $list->[$head + 4] * $carry);\n}\n\nsub _product7 {\n\t\
    my ($list, $carry, $head) = @_;\n\treturn $head * $carry + ($list->[$head] * $list->[$head\
    \ + 1] * $list->[$head + 2] * $", "    for($i=0; $i<count($l); $i++) {\n     \
    \   if($i%3 == 0) {\n            $t[] = $l[$i];\n        }\n    }\n    return\
    \ array_merge($t, array_slice($l,0,count($l)/3));\n}\n", "    $result = [];\n\
    \    $count = 0;\n    foreach ($l as $k => $v) {\n        if ($count % 3 === 0)\
    \ {\n            $result[] = $v;\n        }\n        $count++;\n    }\n    return\
    \ $result;\n}\n</code>\nDemo\n<|/ a dscore=0 tags=sorting,arrays,php |>\n<| c\
    \ |>\nThanks Barmar and all others, I have not tested it yet but i will do so\
    \ and see how it goes. Thanks again.\n<|/ c |>\n<| c |>\nThanks Barmar this works\
    \ perfectly for my purpose. I hope i can learn from this.\n<|/ c |>\n<| a dscore=0\
    \ tags=sorting,arrays,php |>\nThis is a different approach, using array_chunk\
    \ and array_map.\n<code>\n$nums = [1,2,3,4,5,6,7,8,9,10];\n$result = array_map(function\
    \ ($a) use ($nums) {\n    return $nums[$a % 3];\n}, array_chunk($nums, 3));\n\
    $result = array_values($result);\n</code>\n<|/ a |>\n<| c |>\nThanks Nathan, i\
    \ don't know why i didn't think of array_chunk.\n<|/ c |>\n<| a |>\nTry this array_multisort\n\
    <code>\n<?php\n\n$array = [1,2,3,4,5,6,7,8,9,10];\nprint_r($array);\n\n$array\
    \ = array_chunk($array,3);\nforeach($array as $k=>$v){\n    $array[$k] = $v; //\
    \ re-arrange array elements\n}\nprint_r($array);\n\narray_multisort($array,SORT_DESC,$array);\n\
    print_r($array);\n</code>\n<|/ a tags=sorting,arrays,php dscore=0 |>\n<| c |>\n\
    Thanks Himanshu, array_multisort is looking very good. Can you explain the array_chunk\
    \ part please?\n<|/ c |>\n<| c |>\narray_chunk will split the array into chunks\
    \ of 3 elements. Here we have split the array in chunks of 3 elements and used\
    \ foreach for re-arranging the array elements. array_multisort will sort array\
    \ according to values on keys (numerically) or according to values on keys (alphabetically)\
    \ and will maintain the relative order of values on keys (numerically) or values\
    \ of keys (alphabetically).\n<|/ c |>\n<| a dscore=0 |>\nTry this\n<code>\n<?php\n\
    $arr = array(1,2,3,4,5,6,7,8,9,10);\n", "\t$l2 = [];\n\t$l3 = [];\n\tfor ($i=0;\
    \ $i<count($l); $i++) {\n\t\tif ($i % 3 === 0) {\n\t\t\t$l3[$i] = $l[$i];\n\t\t\
    } else {\n\t\t\t$l2[$i] = $l[$i];\n\t\t}\n\t}\n\treturn array_merge($l2, $l3);\n\
    }", "  $third_idx = array();\n  for ($i = 0; $i < count($l); $i ++) {\n    $idx\
    \ = $i;\n    if ($idx % 3 === 0) {\n      // this index is divisible by three,\
    \ so keep it\n      $third_idx[] = $i;\n    } else {\n      // this index is not\
    \ divisible by three, so we must move it forward\n      $third_idx[$idx] = $i;\n\
    \    }\n  }\n  // sort list\n  sort($third_idx);\n  $l = array_fill(0, count($l),\
    \ false);\n  for ($i = 0; $i < count($l); $i++) {\n    $l[$third_idx[$i]] = $l[$i];\n\
    \  }\n  return $l;\n}", "  $l2 = array_slice($l, 1, count($l) / 3);\n  $l1 = array_slice($l,\
    \ 0, count($l) / 3);\n  return array_merge($l1, $l2);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhy would you assume that? The question asked for a *solution* to rearrange\
    \ the input list to put all `k` values ahead of every other `k` in the list, where\
    \ `k` does not necessarily divide into `count($l)`. It also does not ask for a\
    \ solution to the problem (because this problem is not well defined).\n<|/ c |>\n\
    <| c |>\nBecause my solution does what was asked for. I'm sorry that I missed\
    \ the 'without using any loops' requirement. I have updated my answer.\n<|/ c\
    \ |>\n<| c |>\nIt's still unclear whether you understand what the OP wants, though.\n\
    <|/ c |>\n<| c |>\nThanks, I missed that point. I've updated my answer.\n<|/ c\
    \ |>\n<| c |>\nThanks for the effort, but it's not what I need. As you said, if\
    \ the input list has \"three\" elements and the required output list should have\
    \ \"three\" elements, my solution will fail.\n<|/ c |>\n<| a tags=arrays,sorting,php\
    \ |>\nHere's a working code snippet (demo):\n<code>\n$input = [1,2,3,4,5,6,7,8,9,10];\n\
    \n$groups = array();\n$groupSize = 3;\n$i = -1;\nforeach($input as $item) {\n\
    \    $i++;\n    if($i % $groupSize == 0) {\n        $groups[] = $item;\n    }\
    \ else {\n        $groups[$i % $groupSize][] = $item;\n    }\n}\n\nusort($groups,\
    \ function($a, $b){\n    $cmp = count($b) - count($a);\n    if($cmp) {\n     \
    \   return $cmp;\n    }\n    return $a - $b;\n});\n\n$output = [];\nforeach($groups\
    \ as $group) {\n    if(count($group) == $groupSize) {\n        $output[] = array_shift($group);\n\
    \    }\n}\n\nprint_r($output);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] =>\
    \ 1\n    [1] => 2\n    [2] => 3\n    [3] => 4\n    [4] => 5\n    [5] => 6\n  \
    \  [6] => 7\n    [7] => 8\n    [8] => 9\n    [9] => 10\n)\n</code>\n<|/ a dscore=2\
    \ |>\n<| ", "    $newList = array();\n    $temp = $l[0];\n    foreach ($l as $k\
    \ => $val) {\n        if ($k % 3 != 0) $newList[] = $val;\n        if ($k < 3)\
    \ {\n            $newList[] = $val;\n            $temp = $val;\n        }\n  \
    \  }\n    return $newList;\n}\n", "    $l2 = [];\n    foreach ($l as $i => $v)\
    \ {\n        if ($v % 3 == 0) {\n            $l2[$i] = $v;\n        } else {\n\
    \            $l2[sort(array_keys($l, $i))[0]] = $v;\n        }\n    }\n    return\
    \ $l2;\n}\n", "    $threes = array_filter(range(1, count($l)), function($k) {\
    \ return $k % 3 == 0; });\n    foreach ($threes as $i) {\n        array_splice($l,\
    \ $i, 1);\n    }\n    sort($l, SORT_NUMERIC);\n    return $l;\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nYou could try something like this:\n<code>\n<?php\n\
    $list = array(10,1,2,5,4,6,7,9,11);\n\n$list2 = array();\n$threes = array_filter(range(1,count($list)),\
    \ function($k) { return $k % 3 == 0; });\n$list2 = array_diff($list,$threes);\n\
    $list2 = sort($list2);\n\nprint_r($list2);\n</code>\n<|/ a tags=php,sorting,arrays,algorithm\
    \ |>\n<| c |>\nYour solution is incorrect. It does not take into account that\
    \ the numbers are sorted in descending order.\n<|/ c |>\n<| a |>\n<code>", " \
    \   $third = [];\n    for ($i = 0; $i < count($l); $i++) {\n        $third[$i]\
    \ = $i;\n    }\n    arsort($third);\n    sort($third);\n    return $l;\n}\n",
  "    $l2 = [];\n    for ($i = 0; $i < count($l); $i++) {\n        $div = $i % 3;\n\
    \        if ($div === 0) {\n            $l2[$i] = $l[$i];\n        } else {\n\
    \            $div1 = $i - $div;\n            $div2 = ($i + 1) % 3;\n         \
    \   $l2[$i] = (isset($l[$div1])) ? $l[$div1] : $l[$div2];\n        }\n    }\n\
    \    return $l2;\n}\n\n/**\n * Returns all the numbers in an array that are divisible\
    \ by three.\n */", "\t$len = count($l);\n\t$third = array_fill(0, $len / 3, 0);\n\
    \tfor ($i = $len / 3; $i < $len; $i++) {\n\t\t$third[$i] = $l[$i];\n\t}\n\tusort($third,\
    \ function($a, $b) {\n\t\treturn $a - $b;\n\t});\n\t$sorted_l = [];\n\tfor ($i\
    \ = 0; $i < $len; $i++) {\n\t\t$sorted_l[$i] = $l[$i];\n\t}\n\tfor ($i = 0; $i\
    \ < $len; $i++) {\n\t\tif ($third[$i] != $sorted_l[$i]) {\n\t\t\t$l[$i] = $sorted_l[$i];\n\
    \t\t}\n\t}\n\treturn $l;\n}\n", "    sort($l);\n    for ($i = 1; $i < count($l);\
    \ $i += 3) {\n        $l[$i] = $l[$i];\n    }\n    $l[$i-1] = $l[$i-1];\n    return\
    \ $l;\n}", "  $lsorted = $l; // We need a new variable to avoid the side-effects\
    \ of passing by reference\n  foreach ($l as $indice => $value) {\n    if ($indice\
    \ % 3 != 0) {\n      unset($lsorted[$indice]);\n    }\n    else {\n      // If\
    \ we find an index which is divisible by three, remove it and its value, and replace\
    \ it with the value of the indicies that are not divisible by three\n      $indiceNotDivisibleByThree\
    \ = $indice - 2;\n      unset($lsorted[$indice]);\n      $lsorted[$indiceNotDivisibleByThree]\
    \ = $lsorted[$indice];\n    }\n  }\n  // Now sort the rest of the array\n  ksort($lsorted);\n\
    \  return $lsorted;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for this.\
    \ I'll try to understand the code as I read it and modify it a little.\n<|/ c\
    \ |>\n<| c |>\nI have just noticed that the `while` loop will never end. I didn't\
    \ have time yet to fix it, but I believe that it's because of the `if` statement\
    \ that is always true.\n<|/ c |>\n<| a tags=sorting,php |>\nYou can do this by\
    \ implementing a custom sort comparator and using uasort().\n<code>", "  $third\
    \ = $l[0];\n  for ($i = 1; $i < count($l); $i++) {\n    $third = $third > $l[$i]\
    \ ? $third : $l[$i];\n  }\n  for ($i = 0; $i < count($l); $i++) {\n    if ($l[$i]\
    \ % 3 == 0 && $i != 0) {\n      sort($l);\n      break;\n    }\n  }\n  return\
    \ $third;\n}\n", "    $divisible_by_three = false;\n    $sorted_third = [];\n\
    \    foreach ($l as $index => $value) {\n        if ($index % 3 === 0) {\n   \
    \         if (!$divisible_by_three) {\n                $divisible_by_three = true;\n\
    \            } else {\n                $sorted_third[] = $value;\n           \
    \ }\n            $divisible_by_three = false;\n        } else {\n            $sorted_third[]\
    \ = $value;\n        }\n    }\n    if ($divisible_by_three) {\n        array_push($sorted_third,\
    \ array_pop($l));\n    }\n    return $sorted_third;\n}\n\n$a = [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10];\n$b = sort_third($a);\nprint_r($b);", "    $l1 = [];\n    $l2\
    \ = [];\n    foreach($l as $i => $v) {\n        if ($i % 3 === 0) {\n        \
    \    $l1[$i] = $v;\n        } else {\n            $l2[$i] = $v;\n        }\n \
    \   }\n    array_multisort($l1, SORT_DESC, $l2, SORT_DESC, $l);\n    return $l;\n\
    }\n</code>\nIn action:\n<code>", "    foreach($l as $k => $v) {\n        if ($k%3\
    \ != 0) continue;\n        $l[$k] = $l[$k];\n    }\n    asort($l);\n    return\
    \ $l;\n}", "  $third = [];\n  for ($i = 0; $i < count($l); $i += 3) {\n    sort($third,\
    \ $l);\n  }\n  return $third;\n}\n", "    $size = count($l);\n    $l2 = array();\n\
    \    $count = 0;\n    for ($i = 0; $i < $size; $i++) {\n        $count++;\n  \
    \      if ($i % 3 != 0) {\n            $l2[$i] = $l[$i];\n        } else {\n \
    \           $j = $i;\n            while ($j > 0 && $l[$j - 3] > $l[$j]) {\n  \
    \              $l2[--$count] = $l[$j];\n            }\n            $l2[$i] = $l[$j];\n\
    \        }\n    }\n    return $l2;\n}\n", "    $l = (array)$l;\n    $l = $l; //\
    \ array cast to array so we can loop through it\n    ksort($l, SORT_NUMERIC);\n\
    \    for ($i = 0; $i < count($l); $i ++) {\n        if ($i % 3 === 0) {\n    \
    \        $l[$i] = $l[$i] - (count($l) - $i - 1);\n        }\n    }\n    return\
    \ $l;\n}\n", "  $l = array_reverse($l);\n  foreach ($l as $index => $value) {\n\
    \    $l[$index] = $value;\n  }\n  ksort($l);\n  return array_reverse($l);\n}",
  "    $res = array();\n    foreach($l as $i => $val) {\n        $res[] = $val;\n\
    \        if($i % 3 != 0) {\n            $res[$i%3] = $l[$i];\n        }\n    }\n\
    \    return $res;\n}\n</code>\n<|/ a dscore=0 tags=php,sorting,arrays |>\n<| a\
    \ dscore=0 |>\n<code>", "    $new = [];\n    for ($i = 0; $i < count($l); $i++)\
    \ {\n        if ($i % 3 === 0) {\n            $new[] = $l[$i];\n        }\n  \
    \  }\n    $new[] = $l[0];\n    $new[] = $l[count($l)-1];\n    for ($i = 1; $i\
    \ < count($new); $i++) {\n        $j = 0;\n        foreach ($new as $k => $v)\
    \ {\n            if ($k % 3 === 0) {\n                $new[$j] = $v;\n       \
    \         $j++;\n            }\n        }\n    }\n    return $new;\n}\n</code>\n\
    <|/ a dscore=0 tags=php,arrays,sorting |>\n<| a tags=php,arrays,sorting |>\nI\
    \ came up with this solution:\n<code>", "    $lprime = array();\n    $count =\
    \ 0;\n    foreach ($l as $value) {\n        $lprime[$count] = $value;\n      \
    \  $count++;\n    }\n    $count = 1;\n    $result = array();\n    foreach ($lprime\
    \ as $key => $value) {\n        if ($key % 3 != 0) {\n            $result[$key]\
    \ = $value;\n        } else {\n            $result[$key] = $result[$key - 1];\
    \ // sort by key (divisible by three)\n        }\n        $count++;\n    }\n \
    \   return $result;\n}", "    $lp = array_chunk($l, 3);\n    \n    $lpp = array_chunk($lp,\
    \ 3);\n    \n    $len = count($l);\n    \n    for($i = 0; $i < $len; $i++) {\n\
    \        $index = 0;\n        \n        for($j = 0; $j < 3; $j++) {\n        \
    \    \n            if($lpp[$j][0] == $i) {\n                if($lpp[$j][1] ==\
    \ $i) {\n                    $index++;\n                    \n               \
    \     if($index == 2) {\n                        $lpp[$j][1] = $lpp[$j][2];\n\
    \                        \n                        $lpp[$j][2] = $i;\n       \
    \                 \n                        break;\n                    }\n  \
    \                  \n                }\n            }\n            \n        }\n\
    \        \n    }\n    \n    return array_chunk($lpp, 3);\n}\n", "    $sorted_list\
    \ = array();\n    $index_of_first_non_divisible_element = 0;\n    $index_of_last_non_divisible_element\
    \ = $llength - 1;\n\n    // find the index of the first element that is not divisible\
    \ by three\n    for ($i = 0; $i < $llength; $i++) {\n        if ($i % 3 == 0)\
    \ {\n            $index_of_first_non_divisible_element = $i;\n            break;\n\
    \        }\n    }\n\n    // find the index of the last element that is not divisible\
    \ by three\n    for ($i = 0; $i < $llength; $i++) {\n        if ($i % 3 != 0)\
    \ {\n            $index_of_last_non_divisible_element = $i;\n            break;\n\
    \        }\n    }\n\n    // copy the elements starting from index_of_first_non_divisible_element\
    \ up to but not including the element that is\n    // divisible by three to the\
    \ end of the list\n    for ($i = $index_of_first_non_divisible_element; $i <=\
    \ $index_of_last_non_divisible_element; $i++) {\n        $sorted_list[$i] = $l[$i];\n\
    \    }\n\n    // find the index of the element that is divisible by three\n  \
    \  $index_of_third_element = 0;\n    for ($i = $index_of_last_non_divisible_element;\
    \ $i >= $index_of_first_non_divisible_element; $i--) {\n        if ($l[$i] / 3\
    \ == 0) {\n            $index_of_third_element = $i;\n            break;\n   \
    \     }\n    }\n\n    // sort the elements after the element that divides evenly\
    \ by three\n    for ($i = $index_of_third_element; $i >= $index_of_first_non_divisible_element;\
    \ $i--) {\n        if ($l[$i] / 3 == 0) {\n            $temp_sorted_list = $sorted_list;\n\
    \            $sorted_list = array();\n            foreach ($temp_sorted_list as\
    \ $temp) {\n                $sorted_list[$i] = $temp;\n            }\n       \
    \ }\n    }\n\n    // copy the elements starting from index_of_third_element to\
    \ the end of the list to the end of the list\n    for ($i = $index_of_third_element;\
    \ $i <= $llength - 1; $i++) {\n        $sorted_list[$i] = $l[$i];\n    }\n\n \
    \   return $sorted_list;\n}\n", "    $lt = [];\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if ($i % 3 == 0) {\n            $lt[$i] = $l[$i];\n       \
    \ } else {\n            $lt[$i] = $i;\n        }\n    }\n    return $lt;\n}\n",
  "  foreach($l as $k => $v) {\n    if ($k % 3 !== 0) {\n      $l[$k] = $l[$k + 1];\n\
    \      unset($l[$k + 1]);\n    }\n  }\n  return $l;\n}\n</code>\nThe function\
    \ sort_third takes an array l, and sorts it using its values as indicies and the\
    \ indicies that are divisible by three (so if l[0] returns 3, l[1] returns 5,\
    \ etc.).\nHere's how it works:\n<code>\n$l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
  "  $l = array_reverse($l);\n  $llen = count($l);\n  $l[$llen / 3 - 1] = $l[$llen\
    \ / 3 - 1];\n  array_splice($l, $llen / 3, 1);\n  return $l;\n}\n</code>\n<|/\
    \ a tags=sorting,php |>\n<| c |>\nYou need `if($a[$i] == $b[$i]) return 0;`\n\
    <|/ c |>\n<| c |>\nThanks, it wasn't meant as an offence, but as a warning for\
    \ anyone else who comes across this answer. Using `if(){}else{}` is more efficient\
    \ than `if($condition){}else{}`.  See http://www.php-fig.org/psr/psr-2/#9-declarative-style\n\
    <|/ c |>\n<| c |>\nThanks for the link.  I didn't know that.\n<|/ c |>\n<| a dscore=2\
    \ |>\nSorting in PHP is always going to be an O(nlog(n)) algorithm.  You can get\
    \ the quickest results by using a different sorting algorithm.  Here are a couple\
    \ solutions.  I haven't tested the performance, but I'd expect them to all be\
    \ quite similar to your current code.\nMerge Sorting\nI decided to test the performance\
    \ of some of the other algorithms using microtime() and sort() with the \"SORT_NUMERIC\"\
    \ flag.  The results are a bit surprising.  It's not the most efficient algorithm\
    \ in the world, but it seems to be the easiest to implement (and still pretty\
    \ quick).  I ran the tests on a laptop with 1gb of memory and 4 processors.  It\
    \ took about 5 seconds to sort an array of 10000 elements.  I hope you find it\
    \ helpful.\n<code>\n<?php\n\n$array = range(1,10000);\n$array = array_reverse($array);\n\
    $array = sort_third($array);\nsort($array, SORT_NUMERIC);\n", "    foreach($l\
    \ as $i => $v) {\n        if ($i % 3 == 0) {\n            $l[$i] = $l[$i];\n \
    \           $l[$i/3] = $l[$i];\n        }\n    }\n    \n    return $l;\n}\n",
  "    $third = array_slice($l, 0, count($l) / 3);\n    sort($third);\n\n    return\
    \ array_merge(\n        array_slice($l, count($l) / 3),\n        $third\n    );\n\
    }", "  $l2 = [];\n  for ($i = 0; $i < count($l); $i++) {\n    if ($l[$i] % 3 ===\
    \ 0) {\n      $l2[] = $l[$i];\n    }\n  }\n  if (count($l2) === 0) {\n    return\
    \ $l;\n  }\n  sort($l2);\n  return $l2;\n}\n", "    sort($l);\n    $lprime = array();\n\
    \    foreach ($l as $indice => $value) {\n        if ($indice % 3 != 0) $lprime[$indice]\
    \ = $value;\n    }\n    return $lprime;\n}\n", "    $n = count($l);\n    $l2 =\
    \ array_fill(0, $n, 0);\n    $l3 = array_fill(0, $n, 0);\n    $l4 = array_fill(0,\
    \ $n, 0);\n    $count = 0;\n    $first = true;\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        if ($l[$i] % 3 != 0) {\n            $l2[$i] = $l[$i];\n         \
    \   $l3[$i] = $l[$i];\n            $l4[$i] = $l[$i];\n        } else {\n     \
    \       $count++;\n            if ($count > 1) {\n                if ($first)\
    \ {\n                    $l2[++$count] = $l[$i];\n                    $first =\
    \ false;\n                } else {\n                    $l3[++$count] = $l[$i];\n\
    \                }\n            }\n        }\n    }\n    return array_merge($l2,\
    \ $l3, $l4);\n}\n</code>\nAnd to answer your final question, yes, it can make\
    \ for much more efficient code by avoiding looping, but if the only thing you\
    \ care about is efficiency then there is no reason not to do it the way that you\
    \ have done.\n<|/ a tags=php,arrays,algorithm dscore=1 |>\n<| a tags=php,arrays,algorithm\
    \ |>\n<code>", "  $sorted = array();\n  foreach ($l as $index => $value) {\n \
    \   if ($index % 3 == 0) {\n      $sorted[$index / 3][$index] = $value;\n    }\
    \ else {\n      $sorted[$index / 3][$index] = $value;\n      $sorted[$index /\
    \ 3][$index + 1] = $value;\n    }\n  }\n  return $sorted;\n}\n", "  $ls = $ls;\n\
    \  $ls = array_map('strval', $ls);\n  $ls = array_unique($ls);\n  sort($ls);\n\
    \n  $rs = array_keys(array_intersect_key($l, array_flip($ls)));\n  sort($rs);\n\
    \n  $third = array_intersect($ls, $rs);\n  return array_combine($third, $l);\n\
    }\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| a dscore=1 tags=arrays,sorting,php\
    \ |>\nHere is a function that sorts the array for you, just pass in the array\
    \ and the column (i.e. key) to sort by:\n<code>", "    if (empty($l)) return $l;\n\
    \    if (count($l) < 3) return $l;\n    $l = array_reverse($l);\n    sort($l);\n\
    \    sort($l, SORT_NUMERIC);\n    $l = array_reverse($l);\n    return $l;\n}\n",
  "\t$l = array_values($l);\n\tsort($l);\n\t$l2 = array();\n\tforeach ($l as $key\
    \ => $value) {\n\t\tif ($value % 3 == 0) {\n\t\t\t$l2[$key] = $value;\n\t\t} else\
    \ {\n\t\t\t$l2[$key] = $key + 1;\n\t\t}\n\t}\n\treturn $l2;\n}", "    $ld = array();\n\
    \    $ls = array();\n    for($i = 0; $i < count($l); $i++) {\n        if ($i %\
    \ 3 != 0) {\n            $ld[$i] = $l[$i];\n        } else {\n            $ls[$i]\
    \ = $l[$i];\n        }\n    }\n    for($i = 0; $i < count($l); $i++) {\n     \
    \   if ($i % 3 == 0) {\n            $ld[$i] = $ls[$i];\n        }\n    }\n   \
    \ for($i = 0; $i < count($ld); $i++) {\n        $l[$i] = $ld[$i];\n    }\n   \
    \ return $l;\n}", "    for($i = 0; $i < count($l); $i++) {\n        $l[$i] = 0;\n\
    \        if($i > 0) {\n            if($l[$i] % 3 == 0) {\n                $l[$i-1]\
    \ = $l[$i];\n                $l[$i] = 0;\n            } else {\n             \
    \   $l[$i-1] += $l[$i];\n            }\n        }\n    }\n    return $l;\n}\n",
  "  $n = 0;\n  $l = array_reverse($l);\n  foreach ($l as $i => $v) {\n    if ($i\
    \ % 3 == 0) {\n      $l[$n] = $v;\n      $n++;\n    }\n  }\n  ksort($l);\n  return\
    \ array_reverse($l);\n}", "    $l = array_filter($l);\n    usort($l, function($a,\
    \ $b){\n        if ($a % 3 === 0 && $b % 3 === 0) {\n            return 0;\n \
    \       }\n        return ($a % 3 === 0 && $b % 3 != 0) ? -1 : 1;\n    });\n \
    \   return $l;\n}", "  $third = array();\n  foreach ($l as $i => $value) {\n \
    \   if ($value % 3 != 0) {\n      $third[$i] = $value;\n    }\n  }\n  array_multisort($third,\
    \ $l);\n  return $l;\n}\n", "    $out = [];\n    $result = [];\n    foreach ($l\
    \ as $val) {\n        // Find the first index that doesn't divide by three\n \
    \       $index = array_search($val, ($out = []), true);\n        if ($index !==\
    \ false) {\n            $result[$index] = $val;\n        } else {\n          \
    \  $out[] = $val;\n        }\n    }\n    return $result;\n}\n", "  $lcopy = array_reverse($l);\n\
    \  usort($lcopy, create_function('$a, $b', '\n    if ($a % 3 == 0 && $b % 3 ==\
    \ 0) {\n      return $a - $b;\n    } else {\n      return $a - $b\n    }\n  '));\n\
    \  return $lcopy;\n}", "  $l1 = array_slice($l, 0, count($l) / 2);\n  sort($l1);\n\
    \  $l2 = array_slice($l, count($l) / 2, count($l));\n  sort($l2);\n  return array_merge($l1,\
    \ $l2);\n}\n", "    $l2 = array();\n    foreach($l as $i => $val) {\n        if($i\
    \ % 3 != 0) {\n            $l2[$i] = $val;\n        } else {\n            $j =\
    \ $i / 3;\n            while($j-- > 0) {\n                if($j != 0) {\n    \
    \                $j3 = $j / 3;\n                    $l2[$j] = $l2[$j3] + $l2[$j3\
    \ - 1];\n                } else {\n                    $j1 = $j - 1;\n       \
    \             while($j1 > 0) {\n                        $j2 = $j1 + 1;\n     \
    \                   if($l2[$j2] > $l2[$j1]) {\n                            $l2[$j1]\
    \ = $l2[$j2];\n                            $j1 = $j2;\n                      \
    \  } else if($l2[$j2] < $l2[$j1]) {\n                            $j1 = $j2;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return $l2;\n}\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm\
    \ |>\nMy solution takes into account that sorting is stable.\n<code>\npublic function\
    \ sortWith3($arr) {\n    $result = array();\n    $prev = [];\n    foreach ($arr\
    \ as $key => $val) {\n        // If previous element was sorted, we save it and\
    \ add current element as new element\n        if ($prev[$key] === $val) {\n  \
    \          $result[] = $val;\n        } else {\n            // If previous element\
    \ was not sorted, we save current element and add to result\n            if ($prev[$key]\
    \ !== $val) {\n                $result[] = $val;\n            }\n            //\
    \ We check whether the previous element was sorted or not\n            // If previous\
    \ element was sorted, we get its index and save it in $prev\n            if ($prev[$key]\
    \ === $val) {\n                // if previous and current elements are sorted,\
    \ we compare the indexes and add current element to result\n                $result[]\
    \ = $key;\n            }\n            // We add the current element to result\n\
    \            $result[] = $prev[$key];\n        }\n        $prev[$key] = $val;\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,algorithm\
    \ dscore=0 |>\nMy first idea would be to store all values in a list and sort them\
    \ (using QuickSort).\nThen you can use the values from the lists to split the\
    \ list and sort them again, but this time using Insertion Sort.\nExample:\n<code>\n\
    \   list  1\n          2\n          3\n          4\n   list  3\n          5\n\
    \          6\n          7\n   list  5\n          8", "  for ($i = 0; $i < count($l);\
    \ $i += 3) {\n    $l = array_merge($l, $l, $l, $l);\n  }\n  return $l;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nOh great! Thanks, I was really stuck with this, you\
    \ really nailed it. Now I just have to figure out how to sort them from lowest\
    \ to highest and only have one of each number in the array... lol\n<|/ c |>\n\
    <| c |>\nSorry, just saw this... this doesn't work, even after it sorts the array,\
    \ it still keeps repeating each number multiple times... like `[1, 2, 3, 4, 4,\
    \ 4, 5, 5, 5, 6, 6]`\n<|/ c |>\n<| a dscore=1 |>\nYou can use array_count_values\
    \ to get the counts for each number in your array and then sort your array according\
    \ to them:\n<code>\n$array = array(\n    1 => 5, 2 => 3, 3 => 1, 4 => 2, 5 =>\
    \ 3, 6 => 2, 7 => 2, 8 => 3, 9 => 3, 10 => 4, 11 => 2, 12 => 4, 13 => 4, 14 =>\
    \ 5, 15 => 6, 16 => 2, 17 => 2, 18 => 3, 19 => 3, 20 => 5, 21 => 5, 22 => 3, 23\
    \ => 3, 24 => 4, 25 => 4, 26 => 2, 27 => 4, 28 => 3, 29 => 4, 30 => 3, 31 => 4,\
    \ 32 => 3, 33 => 4, 34 => 2, 35 => 4, 36 => 2, 37 => 2, 38 => 3, 39 => 2, 40 =>\
    \ 3, 41 => 4, 42 => 2, 43 => 4, 44 => 4, 45 => 3, 46 => 3, 47 => 4, 48 => 4, 49\
    \ => 3, 50 => 4, 51 => 4, 52 => 4, 53 => 4, 54 => 4, 55 => 4, 56 => 3, 57 => 3,\
    \ 58 => 3, 59 => 4, 60 => 2, 61 => 3, 62 => 3, 63 => 4, 64 => 2, 65 => 3, 66 =>\
    \ 3, 67 => 4, 68 => 2, 69 => 3, 70 => 3, 71 => 4, 72 => 2, 73 => 4, 74 => 2, 75\
    \ => 3, 76 => 3, 77 => 4, 78 => 2, 79 => 3, 80 => 3, 81 => 4, 82 => 2, 83 => 4,\
    \ 84 => 2, 85 => 4, 86 => 2, 87 => 4, 88 => 2, 89 => 4, 90 => 2, 91 => 4, 92 =>\
    \ 4, 93 => 2, 94 => 4, 95 ", "    $ls = $ls;\n    $ls[3] = $ls[8] = $ls[9] = $ls[2]\
    \ = $ls[5] = $ls[6] = $ls[4] = $ls[1] = $ls[0] = $ls[7] = $ls[10] = $ls[11] =\
    \ $ls[12] = $ls[13] = $ls[14] = $ls[15] = $ls[16] = $ls[17] = $ls[18] = $ls[19]\
    \ = $ls[20] = $ls[21] = $ls[22] = $ls[23] = $ls[24] = $ls[25] = $ls[26] = $ls[27]\
    \ = $ls[28] = $ls[29] = $ls[30] = $ls[31] = $ls[32] = $ls[33] = $ls[34] = $ls[35]\
    \ = $ls[36] = $ls[37] = $ls[38] = $ls[39] = $ls[40] = $ls[41] = $ls[42] = $ls[43]\
    \ = $ls[44] = $ls[45] = $ls[46] = $ls[47] = $ls[48] = $ls[49] = $ls[50] = $ls[51]\
    \ = $ls[52] = $ls[53] = $ls[54] = $ls[55] = $ls[56] = $ls[57] = $ls[58] = $ls[59]\
    \ = $ls[60] = $ls[61] = $ls[62] = $ls[63] = $ls[64] = $ls[65] = $ls[66] = $ls[67]\
    \ = $ls[68] = $ls[69] = $ls[70] = $ls[71] = $ls[72] = $ls[73] = $ls[74] = $ls[75]\
    \ = $ls[76] = $ls[77] = $ls[78] = $ls[79] = $ls[80] = $ls[81] = $ls[82] = $ls[83]\
    \ = $ls[84] = $ls[85] = $ls[86] = $ls[87] = $ls[88] = $ls[89] = $ls[90] = $ls[91]\
    \ = $ls[92] = $ls[93] = $ls[94] = $ls[95] = $ls[96] = $ls[97] = $ls[98] = $ls[99]\
    \ = $ls[100] = $ls[101] = $ls[", "    $count = count($l);\n    $l[$count / 2]\
    \ = $l[$count / 2];\n    $l[$count / 2 + 1] = $l[$count / 2 + 1];\n    sort($l);\n\
    \    return $l;\n}\n", "  $l1 = array_chunk($l, 3);\n  $l2 = array_chunk($l1,\
    \ 3);\n  foreach ($l2 as $i1 => $list1) {\n    foreach ($list1 as $i2 => $list2)\
    \ {\n      $list2[$i2] = $list2[$i2] < $list1[$i2] ? $list2[$i2] : $list1[$i2];\n\
    \    }\n  }\n  $l3 = array_merge($l1, $l2);\n  return $l3;\n}\n", "  $count =\
    \ count($l);\n  $third = $count % 3;\n  return array_filter($l, function ($i)\
    \ use ($third) {\n    return $i % 3 == $third;\n  }, ARRAY_FILTER_USE_KEY);\n\
    }\n", "  $l = array_filter($l, function ($x) {\n    return $x % 3 == 0;\n  });\n\
    \  $l2 = array();\n  for ($i = 0, $j = count($l); $i < $j; $i++) {\n    if (!isset($l[$i]))\
    \ {\n      continue;\n    }\n    for ($k = 0, $l3 = count($l); $k < $l3; $k++)\
    \ {\n      if (isset($l[$k]) && $l[$k] == $l[$i]) {\n        continue;\n     \
    \ }\n      if ($k > $i && $l[$k] == $l[$i - 1] &&\n          $l[$k] == $l[$i -\
    \ 2]) {\n        continue;\n      }\n      $l2[] = $l[$i];\n    }\n  }\n  return\
    \ $l2;\n}", "    $new_l = array();\n    $l = array_filter($l);\n    foreach ($l\
    \ as $i => $val) {\n        if ($i % 3 != 0) {\n            $new_l[] = $val;\n\
    \        }\n    }\n    foreach ($l as $i => $val) {\n        if ($i % 3 == 0)\
    \ {\n            $new_l[] = $val; \n        }\n    }\n    return $new_l;\n}\n\
    </code>\n<|/ a tags=php,arrays |>\n<| a dscore=0 tags=php,arrays |>\n<code>\n\
    <?php\n\n$arr1 = array(1, 2, 3, 5, 7, 8, 9);\n$arr2 = array(1, 7, 8, 2, 3, 5,\
    \ 9);\n\n$arr1 = array_count_values($arr1);\n$arr2 = array_count_values($arr2);\n\
    \n$arr2 = array_filter($arr2, function($v) use ($arr1) {\n    return $arr1[$v]\
    \ > 1;\n});\n\nvar_dump($arr2);\n</code>\nOutput\n<code>\narray(3) {\n  [8]=>\n\
    \  int(2)\n  [7]=>\n  int(1)\n  [3]=>\n  int(1)\n}\n</code>\n<|/ a |>\n<| a |>\n\
    You can get the count of values by using array_count_values(). Then you can use\
    \ the array_filter() function to get the count of values of each array that are\
    \ not greater than 1.\n<code>\n<?php\n$arr1 = array(1, 2, 3, 5, 7, 8, 9);\n$arr2\
    \ = array(1, 7, 8, 2, 3, 5, 9);\n\n$counts = array_count_values($arr1);\n$arr2\
    \ = array_filter($arr2, function($val) use($counts) {\n    return $counts[$val]\
    \ > 1;\n});\nprint_r($arr2);\n</code>\nOutput:\n<code>\nArray\n(\n    [8] => 2\n\
    \    [7] => 1\n    [3] => 1\n)\n</code>\nDemo on 3v4l.org\n<|/ a tags=php,arrays\
    \ dscore=0 |>\n<| a tags=php,arrays |>\nTry this\n<code>\n<?php\n$arr1 = array(1,\
    \ 2, 3, 5, 7, 8, 9);\n$arr2 = array(1, 7, 8, 2, 3, 5, 9);\n$result = array();\n\
    foreach ($arr1 as $key => $val) {\n    $result[$key] = $arr2[$key];\n}\necho \"\
    <pre>\";\nprint_r($result);", "  // Use a list to store the indicies of l that\
    \ are not divisible by three in sorted order\n  $divisible = array();\n  // Use\
    \ a list to store the indicies of l that are not divisible by three in sorted\
    \ order\n  $unordered = array();\n\n  // For each element in the list\n  for ($i\
    \ = 0; $i < count($l); $i++) {\n    // If the element is not divisible by three,\
    \ add it to the list\n    if ($l[$i] % 3 !== 0) {\n      $unordered[] = $i;\n\
    \      // If it is divisible by three, add it to a list that is not yet sorted\n\
    \    } else {\n      $divisible[] = $i;\n    }\n  }\n\n  // Sort the divisible\
    \ and unordered lists, and return the result\n  return array_merge(sort_third($divisible),\
    \ sort_third($unordered));\n}\n", "  return array_map(\n    function ($x) {\n\
    \      return $x%3 ? $x%3 : ($x+1)%3 ? $x%3 : ($x+2)%3 ? $x%3 : ($x+3)%3 ? $x%3\
    \ : $x;\n    },\n    array_merge(\n      array_map('intval', array_splice($l,\
    \ 0, 3)),\n      array_map('intval', array_splice($l, 3, 3))\n    )\n  );\n}\n",
  "    return array_map(\n        function($n) {\n            return $n % 3;\n   \
    \     },\n        array_map(\n            function($n) {\n                return\
    \ $n / 3;\n            },\n            $l\n        )\n    )\n         + $l;\n\
    }\n", "  $lprime = [];\n  for ($i = 0; $i < count($l); $i++) {\n    if ($i % 3\
    \ == 0) {\n      $lprime[] = $l[$i];\n    }\n  }\n\n  for ($i = 0; $i < count($l);\
    \ $i++) {\n    if ($i % 3 != 0) {\n      $lprime[] = $l[$i];\n    }\n  }\n\n \
    \ $lprime = array_count_values($lprime);\n  arsort($lprime);\n\n  $lprime = array_keys($lprime);\n\
    \n  $lprime = array_merge(array_slice($lprime, 0, ceil(count($lprime) / 3)), array_slice($lprime,\
    \ ceil(count($lprime) / 3)));\n\n  return $lprime;\n}\n</code>\nThis code takes\
    \ your $data array and transforms it into $dataprime, sort the values in $dataprime\
    \ by key, then split it into two arrays by key that is divisible by 3 or more.\n\
    <|/ a |>\n<| a tags=sorting,php,arrays dscore=0 |>\n<code>\n$array = [1,2,3,4,5,6,7,8,9,10,11,12];\n\
    $result = [];\n$count = 3;\n\nforeach($array as $key => $val) {\n    if($key %\
    \ $count == 0) {\n        array_push($result, $val);\n    }\n}\narray_multisort($result,\
    \ SORT_DESC);\n</code>\nThis will get you the array you need.\n<|/ a |>\n<| a\
    \ tags=sorting,php,arrays dscore=0 |>\n<code>\n$array = [1,2,3,4,5,6,7,8,9,10,11,12];\n\
    \n$count = 3;\n$result = array();\nforeach($array as $key => $val) {\n    if($key\
    \ % $count == 0) {\n        array_push($result, $val);\n    }\n}\narray_multisort($result,\
    \ SORT_DESC);\nprint_r($result);\n</code>\nOutputs:\n<code>\nArray\n(\n    [0]\
    \ => 1\n    [2] => 2\n    [4] => 3\n    [6] => 4\n    [8] => 5\n    [10] => 6\n\
    \    [12] => 7\n    [14] => 8\n    [16] => 9\n    [18] => 10\n    [20] => 11\n\
    \    [21] => 12\n)\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n$array = [1,2,3,4,5,6,7,8,9,10,11,12];\n\
    $array = array_chunk($array, 3);\n$result = [];\n\nforeach ($array as $key=>$value)\
    \ {\n    $result[$key] = array_pop($value);\n", "    $lprime = $l;\n    // Sort\
    \ the list if necessary\n    if ($l == array_count_values($lprime)[$lprime]) {\n\
    \        $lprime = array_keys($lprime);\n        sort($lprime);\n    }\n\n   \
    \ // Return l if it has exactly the same values\n    if ($l == $lprime) {\n  \
    \      return $l;\n    }\n\n    // Find indicies of divisible by three in lprime\
    \ and set lprime[indicies] = lprime[indicies]\n    // and increment the indicies\
    \ of the divisible by three's by one\n    $lprime = array_values($lprime);\n \
    \   $lprime = array_map(function ($i) { return $i%3?$i:++$i; }, $lprime);\n\n\
    \    // Return lprime if they are identical and sorted in descending order\n \
    \   if ($l == array_reverse($lprime)) {\n        return $lprime;\n    }\n\n  \
    \  // Return l if there are less than three equal valued indicies in lprime\n\
    \    $l = array_keys($l);\n    $lprime = array_keys($lprime);\n    if (count($l)\
    \ <= count($lprime)) {\n        return $l;\n    }\n\n    // Return lprime if there\
    \ are three or more equal valued indicies in lprime\n    $lprime = array_keys($lprime);\n\
    \    $lprime = array_map(function ($i) { return $i%3?$i:++$i; }, $lprime);\n \
    \   sort($lprime);\n    return array_merge($l, array_reverse($lprime));\n}\n</code>\n\
    <|/ a |>\n<| c |>\nOh, I missed the requirement that the values should be sorted,\
    \ I thought that the requirement was that the indicies of the indicies that are\
    \ not divisible by three should be incremented by one. I'll update my answer.\n\
    <|/ c |>\n<| c |>\nI added an updated answer that sorts the values first and then,\
    \ if the indicies are equal, merges the two lists together. If the indicies are\
    \ not equal, returns the original list.\n<|/ c |>\n<| a |>\nThe code of Piotr\
    \ is really nice but does not work with arrays that contain a mix of strings,\
    \ numbers and booleans.\nSo I fixed this issue and here is the code I used:\n\
    <code>\n<?php\n\n/**\n * Takes a list and returns a list that is identical to\
    \ it in the indicies that are not divisible by three, while its values at the\
    \ indicies that are divisible by three are equal to the values of the corresponding\
    \ indicies of ", "\tglobal $arr;\n\tforeach($arr as $key => $value) {\n\t\t$arr[$key]\
    \ = $value;\n\t}\n\tforeach ($l as $key => $value) {\n\t\t$arr[$key] = $value;\n\
    \t}\n\tasort($arr);\n\tforeach ($arr as $key => $value) {\n\t\t$arr[$key] = $value;\n\
    \t}\n\tunset($arr);\n\treturn $l;\n}", "    $l2 = $l2;\n    $result = array();\n\
    \    foreach ($l as $key => $val) {\n        if ($val % 3 != 0) {\n          \
    \  $result[$key] = $val;\n        } else {\n            array_push($l2, $val);\n\
    \        }\n    }\n    return array_merge($l2, $result);\n}\n", "    $len = count($l);\n\
    \    for($i = 0; $i < $len; $i++) {\n        if(!($i % 3)) {\n            continue;\n\
    \        }\n        $left = $i-1;\n        $right = $len-1;\n        while($left\
    \ >= 0) {\n            if($l[$left] > $l[$right]) {\n                $temp = $l[$right];\n\
    \                $l[$right] = $l[$left];\n                $l[$left] = $temp;\n\
    \                $right--;\n            } else {\n                break;\n   \
    \         }\n            $left--;\n        }\n    }\n    return $l;\n}\n", " \
    \ $res = [];\n  foreach ($l as $key => $value) {\n    if ($key % 3 === 0) {\n\
    \      // $key must be divisible by three -- insert this value into the sorted\
    \ array\n      $res[] = $value;\n    } else {\n      // $key is not divisible\
    \ by three\n      // the value that needs to be inserted at this key must be equal\n\
    \      // to the value in $l at this key, but the values at indices divisible\
    \ by three need to be sorted\n      $res[$key % 3] = $value;\n    }\n  }\n  return\
    \ $res;\n}\n", "    $third = array_slice($l, 0, count($l) / 3);\n    sort($third);\n\
    \    return array_merge(array_slice($third, 0, count($l) / 3), array_slice($l,\
    \ count($l) / 3));\n}\n", "    $sorted = array();\n    $third = array();\n   \
    \ foreach ($l as $i => $e) {\n        $divisible_by_three = 0;\n        $third[ceil($i\
    \ / 3)][] = $i;\n        foreach ($third[ceil($i / 3)] as $j) $divisible_by_three\
    \ += ($i % $j) ? 1 : 0;\n        if ($divisible_by_three == 1) $sorted[] = $e;\n\
    \        if ($divisible_by_three == 2) {\n            $third[floor($i / 3)][]\
    \ = $e;\n            $third[floor(($i + 1) / 3)][] = $e;\n        }\n    }\n \
    \   return $sorted;\n}\n", "    $l2 = array();\n    $l3 = 0; $l4 = 0;\n    foreach\
    \ ($l as $k => $v) {\n        if ($k % 3 === 0) {\n            $l3++;\n      \
    \      $l4++;\n        }\n        $l2[($l3 + ($l3 % 3))] = $v;\n    }\n    return\
    \ $l2;\n}\n", "\tksort($l);\n\tfor ($i = 0; $i < count($l); $i += 3) {\n\t\tif\
    \ ($l[$i] != $l[$i+1]) {\n\t\t\t$temp = array($l[$i], $l[$i+1]);\n\t\t\t$l[$i]\
    \ = $l[$i+1];\n\t\t\t$l[$i+1] = $temp;\n\t\t}\n\t}\n\treturn $l;\n}", "  $l2 =\
    \ $l;\n  usort($l2, function($a, $b) {\n    $i1 = array_search($a % 3, $l);\n\
    \    $i2 = array_search($b % 3, $l);\n    return $i1 - $i2;\n  });\n  return $l2;\n\
    }", "    foreach ($l as $key => $value) {\n        $new[$key] = $value;\n    }\n\
    \    $new = [];\n    $new_values = [];\n    $even = array_filter($l, function\
    \ ($v) use ($new, $new_values) {\n        return $v % 3 == 0;\n    });\n    foreach\
    \ ($even as $key => $value) {\n        $new[$key] = $value;\n        $new_values[$key]\
    \ = $value;\n    }\n    $odd = array_filter($l, function ($v) use ($new, $new_values)\
    \ {\n        return $v % 3 == 1;\n    });\n    foreach ($odd as $key => $value)\
    \ {\n        $new[$key] = $value;\n        $new_values[$key] = $value;\n    }\n\
    \    $sorted = $new;\n    $sorted = array_intersect_key($sorted, $new_values);\n\
    \    ksort($sorted);\n    return $sorted;\n}", "\t$l3 = [];\n\tforeach($l as $i\
    \ => $n) {\n\t\tif (($i % 3) == 0) {\n\t\t\t$l3[$i] = $n;\n\t\t}\n\t}\n\tksort($l3);\n\
    \tforeach($l3 as $i => $n) {\n\t\t$l3[$i] = $l[$i];\n\t}\n\treturn $l3;\n}\n\n\
    /**\n * Finds out the list of files whose content is most frequently used in the\
    \ given list of URLs\n *\n * @param  array $urls List of URLs to search in\n *\
    \ @return array Associative array containing the frequency counts for all the\
    \ URLs\n */", "  $third = [];\n  for ($i = 0; $i < count($l); $i++) {\n    if\
    \ ($i % 3 === 0) {\n      $third[$i] = $l[$i];\n    }\n  }\n  return $third;\n\
    }\n", "    $l = [3, 5, 6, 3, 4, 8, 9, 5];\n\n    $l2 = [];\n    $count = 0;\n\
    \    foreach ($l as $k => $v) {\n        if ($v % 3 != 0) {\n            $l2[$count]\
    \ = $v;\n        } else {\n            $l2[++$count] = $v;\n        }\n    }\n\
    \n    return $l2;\n}\n</code>\n<|/ a tags=arrays,php,merge dscore=1 |>\n<| a |>\n\
    <code>\n<?php\n$array1 = [2, 3, 5, 6, 7, 8, 9];\n$array2 = [5, 6, 3, 4, 8, 9,\
    \ 2];\n\n$result = array();\narray_walk($array1, function($v, $k) use (&$result)\
    \ {\n    $result[$k] = $v; // Keep current value at given key.\n});\narray_walk($array2,\
    \ function($v, $k) use (&$result) {\n    // For each key, check if current value\
    \ is not divisible by 3.\n    if ($result[$k] % 3 != 0) {\n        // If not divisible\
    \ by 3 add value to result array.\n        $result[$k] = $v;\n    }\n});", " \
    \ return array_merge(\n    array_merge(\n      array_slice($l, 0, floor(count($l)\
    \ / 3)),\n      array_slice($l, floor(count($l) / 3), count($l))),\n    array_slice($l,\
    \ 0, count($l) / 3)\n  );\n}\n</code>\nThe last step is just to split the array\
    \ into two halves, sort each half in turn, and merge:\n<code>", "    foreach ($l\
    \ as $index => $value) {\n        $divisible = is_divisible($index, 3);\n    \
    \    $remaining = array_slice($l, $index);\n        if ($divisible) {\n      \
    \      array_push($remaining[$index], $remaining[($index + 1) % 3]);\n       \
    \     $remaining[($index + 1) % 3] = $value;\n            $l[$index] = $remaining;\n\
    \        } else {\n            $l[$index] = $remaining;\n        }\n    }\n  \
    \  return $l;\n}\n", "    $l = array_map(function($v) { return $v % 3; }, $l);\n\
    \    $l = array_chunk($l, 3);\n    foreach ($l as &$sub) {\n        sort($sub);\n\
    \    }\n    return $sub;\n}\n", "    $l3_rev = $l;\n    $l3_rev[count($l) - 1]\
    \ = $l3_rev[count($l) - 1] % 3;\n    ksort($l3_rev);\n    return $l3_rev;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=php |>\n<code>\n<?php\n$list1 = array('a',\
    \ 'b');\n$list2 = array('a', 'b', 'c', 'd', 'e');\n$list3 = array('a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g');\n$list4 = array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i');\n\n$lists = array($list1, $list2, $list3, $list4);\nforeach($lists as\
    \ $list) {\n    sort($list);\n}\n\necho '<pre>';\nprint_r($lists);\necho '</pre>';",
  "  uasort($l, function ($a, $b) use (&$l) {\n    for ($i = 0; $i < count($l); $i++)\
    \ {\n      if ($i % 3 == 0) {\n        if ($l[$i] == $a) {\n          $a = 0;\n\
    \        } else if ($l[$i] == $b) {\n          $b = 0;\n        } else {\n   \
    \       $a = 1;\n          $b = 0;\n        }\n      }\n    }\n    return $a +\
    \ $b;\n  });\n  return $l;\n}\n", "  foreach ($l as $index => $value)\n    $l[$index]\
    \ = ($index % 3 == 0) ? $value : (($value + $l[$index + 1]) / 2);\n\n  return\
    \ $l;\n}", "\tusort($l, function($x, $y) {\n\t\tif($x % 3 == 0){\n\t\t\treturn\
    \ $y % 3 == 0;\n\t\t}else{\n\t\t\treturn $x % 3 > $y % 3;\n\t\t}\n\t});\n\treturn\
    \ $l;\n}", "    $lprime = array();\n    for ($i = 0, $j = 1; $i < count($l); $i++)\
    \ {\n        for ($j = $i; $j < count($l); $j++) {\n            if ($i % 3 ===\
    \ 0 && $j % 3 !== 0) {\n                $lprime[$j] = $l[$j];\n            } else\
    \ if ($i % 3 !== 0) {\n                $lprime[$j + 1] = $l[$j];\n           \
    \ }\n        }\n    }\n    return $lprime;\n}", "  // make new list with values\
    \ equal to their indicies that are divisible by three\n  $l2 = array();\n  for\
    \ ($i = 0; $i < count($l); $i++) {\n    // if its indicies are not divisible by\
    \ three\n    if (!($i % 3)) {\n      // add its values to list\n      $l2[$i]\
    \ = $l[$i];\n    }\n  }\n\n  // sort l2 using their indicies as keys\n  ksort($l2);\n\
    \n  // return l2\n  return $l2;\n}", "\tsort($l, SORT_NUMERIC);\n\t$n = 0;\n\t\
    foreach ($l as $key => $val)\n\t\t$l[$n++] = $key % 3 == 0 ? $val : $key;\n\t\
    return $l;\n}\n", "    \n    // create an array that contains the indicies that\
    \ are divisible by three in $l\n    $threes = [];\n    foreach ($l as $i) {\n\
    \        if ($i % 3 == 0) {\n            $threes[] = $i;\n        }\n    }\n \
    \   \n    // the third indicies are those that are divisible by three in $l, but\
    \ whose values are equal in those indicies not divisible by three\n    $thirds\
    \ = array_intersect_key($l, $threes);\n    \n    // now create an array that contains\
    \ the indicies in $l which are equal and sort it\n    $equal_indicies = array_diff(range(count($l)),\
    \ $threes);\n    $equal_indicies = array_flip($equal_indicies);\n    $equal_indicies\
    \ = array_intersect_key($l, $equal_indicies);\n    \n    // now create a list\
    \ with the indicies that are not equal and sort it\n    $not_equal_indicies =\
    \ array_intersect_key($l, $equal_indicies);\n    \n    // now we get the two lists\
    \ and combine them\n    $l = [$equal_indicies, $not_equal_indicies];\n    $l =\
    \ array_merge($l, array_diff_key($l, $thirds));\n    \n    // now we sort it and\
    \ return the sorted list\n    sort($l);\n    return $l;\n}\n", "    foreach ($l\
    \ as $i => $val) {\n        if ($i % 3 === 0) {\n            $result[$i] = $val;\n\
    \        } else {\n            $result[$i] = $l;\n        }\n    }\n    asort($result);\n\
    \    return $result;\n}", "  foreach ($l as $i => $k) {\n    if ($k == $l[$i +\
    \ ($i % 3))]) { // divisible by 3\n      $l[$i] += $l[$i + (($i % 3) + 1)]; //\
    \ shift values after index at which they are divisible by 3\n      unset($l[$i\
    \ + (($i % 3) + 1)]); // remove divisible by 3 indicies from list\n    }\n  }\n\
    \  asort($l); // sort list by value\n  return $l;\n}\n</code>\nOutput\n<code>\n\
    print_r($array_result);\n/*\nArray\n(\n    [0] => Array\n        (\n         \
    \   [0] => 3\n            [1] => 4\n            [2] => 5\n        )\n\n    [1]\
    \ => Array\n        (\n            [0] => 1\n            [1] => 5\n          \
    \  [2] => 2\n        )\n\n    [2] => Array\n        (\n            [0] => 6\n\
    \            [1] => 8\n            [2] => 9\n        )\n\n)\n*/\n\nprint_r(sort_third($array_result));\n\
    /*\nArray\n(\n    [0] => Array\n        (\n            [0] => 3\n            [1]\
    \ => 5\n            [2] => 1\n        )\n\n    [1] => Array\n        (\n     \
    \       [0] => 4\n            [1] => 2\n            [2] => 6\n        )\n\n  \
    \  [2] => Array\n        (\n            [0] => 8\n            [1] => 9\n     \
    \       [2] => 6\n        )\n\n)\n*/\n</code>\n<|/ a |>\n<| c |>\nThanks so much!\
    \ This was exactly what I was looking for. Now I can use this function for any\
    \ number of items in an array, rather than just three!\n<|/ c |>\n<| a |>\nTry\
    \ this. it worked for me.\n<code>\n$arr1 = array(\n    array(\n        0 => 5,\n\
    \        1 => 1,\n        2 => 6,\n    ),\n    array(\n        0 => 8,\n     \
    \   1 => 7,\n        2 => 9,\n    ),\n    array(\n        0 => 2,\n        1 =>\
    \ 3,\n        2 => 4,\n    ),\n    array(\n        0 => 1,\n        1 => 5,\n\
    \        2 => 2,\n    )\n);\n", "    $third = array_splice($l, 0, 3);\n    $third\
    \ = array_combine(range(1, count($l)), $third);\n    $third = array_merge($third,\
    \ array_flip($third));\n    return array_values($third);\n}", "    foreach($l\
    \ as $key => $value) {\n        if ($value % 3 != 0) {\n            $l[$key] =\
    \ $value;\n        }\n    }\n    asort($l);\n    return $l;\n}", "  $l = array_map(function\
    \ ($i) {\n    if ($i%3 == 0) {\n      return ($i%3 != 0) ? $i : 9;\n    }\n  \
    \  return $i;\n  }, $l);\n  asort($l);\n  $l2 = array();\n  foreach ($l as $i\
    \ => $v) {\n    if ($v%3 == 0) {\n      $l2[] = $v;\n    }\n    else {\n     \
    \ $l2[] = $i;\n    }\n  }\n  return $l2;\n}\n", "  $newlist = array();\n  for\
    \ ($i = 0; $i < count($l); $i++) {\n    if ($i % 3 != 0) {\n      $newlist[$i]\
    \ = $l[$i];\n    }\n  }\n\n  for ($i = 0; $i < count($l); $i++) {\n    if ($i\
    \ % 3 == 0) {\n      $newlist[$i] = $l[$i];\n    }\n  }\n\n  sort($newlist);\n\
    \  return $newlist;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't really\
    \ answer the question asked and isn't a good way to approach the problem.  You're\
    \ copying arrays and sorting them multiple times.\n<|/ c |>\n<| c |>\nI appreciate\
    \ your concern but this answer is actually a good way to solve the question. It\
    \ does it without using loops or arrays.\n<|/ c |>\n<| c |>\n\"*This doesn't really\
    \ answer the question*\" - it does, and it is *much* better than what was asked.\
    \  But it is still inefficient and inelegant.  I wouldn't want to downvote it\
    \ because it's helpful, but it still isn't an answer.\n<|/ c |>\n<| c |>\nThank\
    \ you for the answer, I appreciate it but this does not answer the question at\
    \ all.\n<|/ c |>\n<| a dscore=0 |>\nHere's a pure PHP solution.  It has the advantage\
    \ of requiring no sorting of the input.  It also uses the same $l1 array for both\
    \ input and output, and does it in-place.\n<code>", "    $l2 = $l2;\n    $i =\
    \ array_keys($l);\n    $k = array_keys($l);\n    $l = array_values($l);\n    $d\
    \ = array_keys($l2);\n    for($j=0; $j<$d; $j++) {\n        $i[$j] /= 3;\n   \
    \ }\n    for($j=0; $j<$i; $j++) {\n        $l2[(($i[$j]+1)*3)] = $l[$j];\n   \
    \     $k[$j] = $i[$j];\n    }\n    for($j=0; $j<$i; $j++) {\n        $l[$j] =\
    \ $l[$k[$j]];\n    }\n    for($j=0; $j<$d; $j++) {\n        $i[$j] = $k[$j];\n\
    \    }\n    for($j=0; $j<$d; $j++) {\n        $k[$j] = $i[$j];\n    }\n    for($j=0;\
    \ $j<$d; $j++) {\n        $l[$j] = $l[$k[$j]];\n    }\n    return $l;\n}", "\t\
    $sorted = array();\n\tfor ($i = 0; $i < count($l); $i += 3) {\n\t\t$sorted[] =\
    \ $l[$i];\n\t\t$sorted[] = $l[$i + 1];\n\t\t$sorted[] = $l[$i + 2];\n\t}\n\tfor\
    \ ($i = 0; $i < count($l); $i += 3) {\n\t\tif ($l[$i] % 3 == 0) {\n\t\t\t$j =\
    \ $i + 1;\n\t\t\twhile ($l[$i] % 3 == 0 && $j < count($l)) {\n\t\t\t\t$sorted[]\
    \ = $l[$j];\n\t\t\t\t$j++;\n\t\t\t}\n\t\t\t$sorted[] = $l[$j];\n\t\t}\n\t}\n\t\
    for ($i = 0; $i < count($l); $i += 3) {\n\t\tif ($l[$i] % 3 == 1) {\n\t\t\t$j\
    \ = $i + 1;\n\t\t\twhile ($l[$i] % 3 == 1 && $j < count($l)) {\n\t\t\t\t$sorted[]\
    \ = $l[$j];\n\t\t\t\t$j++;\n\t\t\t}\n\t\t\t$sorted[] = $l[$j];\n\t\t}\n\t}\n\t\
    for ($i = 0; $i < count($l); $i += 3) {\n\t\tif ($l[$i] % 3 == 2) {\n\t\t\t$j\
    \ = $i + 1;\n\t\t\twhile ($l[$i] % 3 == 2 && $j < count($l)) {\n\t\t\t\t$sorted[]\
    \ = $l[$j];\n\t\t\t\t$j++;\n\t\t\t}\n\t\t\t$sorted[] = $l[$j];\n\t\t}\n\t}\n\t\
    return $sorted;\n}\n", "    foreach ($l as $key => $value) {\n        if (($key\
    \ % 3) != 0) {\n            $output[] = $value;\n            $output[] = $l[$key\
    \ - 1];\n        }\n    }\n    return $output;\n}", "  $l2 = [];\n  $even = 0;\n\
    \  for ($i = 0; $i < count($l); $i++) {\n    if ($i % 2 == 0) {\n      if ($l[$i]\
    \ % 3 != 0) {\n        $l2[$even] = $l[$i];\n        $even++;\n      }\n    }\n\
    \  }\n  return $l2;\n}\n\n/**\n * Re-arranges a list by grouping elements at even\
    \ indicies together and elements at odd indicies together\n * @param array $l\
    \ the list to be re-arranged\n * @return array the re-arranged list\n */", "\t\
    $l2 = [];\n\tforeach ($l as $i => $val) {\n\t\t$i2 = $i / 3;\n\t\t$i2 *= 3;\n\t\
    \tif ($i % 3 == 0) {\n\t\t\t$l2[$i2] = $val;\n\t\t} else {\n\t\t\t$l2[$i] = $val;\n\
    \t\t}\n\t}\n\tasort($l2);\n\treturn $l2;\n}\n", "\t$lprime = $l;\n\tforeach ($l\
    \ as $key => $value) {\n\t\tif ($key % 3 == 0) {\n\t\t\t$lprime[$key] = $l[$key];\n\
    \t\t}\n\t}\n\tksort($lprime);\n\treturn $lprime;\n}\n", "    $l2 = [];\n    foreach\
    \ ($l as $index => $value) {\n        $l2[($index % 3)] = $value;\n    }\n   \
    \ $l2 = array_values($l2);\n    ksort($l2);\n    return $l2;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 tags=sorting,arrays,php |>\nHere is a way to do\
    \ it :\n<code>\n<?php\n", "  foreach($l as $key1 => $value1) {\n    foreach($l\
    \ as $key2 => $value2) {\n      if($key1 != $key2) {\n        foreach($l as $key3\
    \ => $value3) {\n          if($key1 != $key3 && $key2 != $key3 && $key1 != $key2\
    \ && $key2 != $key3) {\n            if($key1 != $key2 && $key2 != $key3 && $key1\
    \ != $key3) {\n              if($key2 != $key3 && $key3 != $key1) {\n        \
    \        $third = $value1;\n                $third = $third + $value2;\n     \
    \           $third = $third + $value3;\n                $l[$key1] = $third;\n\
    \                $l[$key2] = $third;\n                $l[$key3] = $third;\n  \
    \            }\n            }\n          }\n        }\n      }\n    }\n  }\n \
    \ return $l;\n}", "    $l = array_change_key_case($l);\n    $l2 = [];\n    $j\
    \ = 0;\n    foreach ($l as $k => $v) {\n        if ($v % 3 == 0) {\n         \
    \   $l2[++$j] = $v;\n        } else {\n            $l2[$j] = $v;\n        }\n\
    \    }\n    return $l2;\n}\n", "    $l = array_merge([false], [$l]);\n    $l[0]\
    \ = $l[0] ? $l[1] : false;\n    $l[1] = $l[1] ? $l[0] : false;\n    $l[2] = $l[2]\
    \ ? $l[1] : false;\n    $l[3] = $l[3] ? $l[2] : false;\n    sort($l);\n    return\
    \ array_intersect_key($l, [false, false, false]);\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| c |>\nThis is almost exactly what I'm looking for, but it's giving me\
    \ a different result to what I need. How would I modify it to get the array as\
    \ I've described?\n<|/ c |>\n<| c |>\nYou would have to modify the code to handle\
    \ divisible by 3 in the appropriate place.  It doesn't appear to me as though\
    \ my answer addressed that issue.\n<|/ c |>\n<| a |>\nI really like Jack's answer\
    \ but I wanted an alternative solution using array_reduce:\n<code>\n$array = [1,\
    \ 2, 3, 4, 5];\n\narray_reduce($array, function($carry, $item){\n    return $carry[0]\
    \ == $item ? $carry : [$item, $carry];\n});\n</code>\n<|/ a tags=php,arrays dscore=1\
    \ |>\n<| a dscore=0 tags=php,arrays |>\nYou can use a combination of array_chunk\
    \ and array_reduce to do the trick:\n<code>\n$arr = [1,2,3,4,5,6,7,8,9,10];\n\
    $chunks = array_chunk($arr, 3, true);\n$chunks2 = array_filter($chunks, function($chunk){return\
    \ count($chunk);});\n$reduced = array_reduce($chunks2, 1, function($carry, $item){\n\
    \    $carry = array_unique($carry);\n    $carry[] = $item;\n    return $carry;\n\
    });\n$reduced2 = array_filter($reduced, function($item){return count($item);});\n\
    print_r($reduced2);\n</code>\nOutputs:\n<code>\nArray ( [0] => 1 [1] => 2 [2]\
    \ => 3 [3] => 4 [4] => 5 [5] => 6 [6] => 7 [7] => 8 [8] => 9 [9] => 10 ) \n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nA very simple approach is just to loop through the\
    \ array and keep track of how many times you've seen each number using a variable\
    \ (a counter) then if the count is 3 then output that number into the new array.\n\
    <code>\n$newArray = [];\n$counter = 0;\nfor($i=0;$i<count($array);$i++){\n   \
    \ if ($counter < 3) {\n        $", "    $len  = count($l);\n    $l[0] = $l[0];\n\
    \    for ($i = 1; $i <= $len; $i++) {\n        $l[$i] = 0;\n        for ($j =\
    \ 0, $len = count($l); $j < $len; $j++) {\n            if ($i % 3 === 0) {\n \
    \               if ($l[$j] != 0) {\n                    $l[$j+1] = $l[$j];\n \
    \                   unset($l[$j]);\n                }\n            } else {\n\
    \                if ($l[$j] == 0) {\n                    $l[$j] = $i;\n      \
    \          }\n            }\n        }\n    }\n    return $l;\n}\n</code>\n<|/\
    \ a |>\n<| a |>\n<code>\n<?php\n$array = [0,1,2,3,4,5,6,7,8,9];\n$array1 = array(0,1,2,3,4,5,6,7,8,9);\n\
    $array2 = array_map(function($value){\n    return $value % 3;\n}, $array);\nvar_dump($array2);\n\
    sort($array2);\nvar_dump($array2);\n</code>\n<|/ a dscore=2 tags=php,arrays |>\n\
    <| c |>\nI haven't really done a lot of PHP in 4 years, but I think that you can\
    \ pass `sort` the array directly. No need to call `array_map` to build a new array.\n\
    <|/ c |>\n<| c |>\nthank you for feedback. I think you're right with passing `sort`\
    \ directly array without using of `array_map`.\n<|/ c |>\n<| c |>\nThank you for\
    \ pointing out a mistake, I fixed my answer.\n<|/ c |>\n<| a tags=php,arrays |>\n\
    Here is an array map + array_reverse combo:\n<code>\n<?php\n\n$array = array(\n\
    \    0,1,2,3,4,5,6,7,8,9\n);\n\n$array = array_map(function($item) {\n    $item\
    \ %= 3;\n    return $item;\n}, $array);\n\nvar_dump($array);\n\n$array = array_reverse($array);\n\
    \nvar_dump($array);\n</code>\n<|/ a dscore=2 |>\n<| a |>\nUsing array_map and\
    \ array_reverse functions is really expensive as they iterate over whole array.\n\
    <code>\n<?php\n$array = [0,1,2,3,4,5,6,7,8,9];\n$array1 = array(0,1,2,3,4,5,6,7,8,9);\n\
    $array2 = array_map(function($value){\n    return $value % 3;\n}, $array);\nvar_dump($array2);\n\
    sort($array2);\nvar_dump($array2);\n</code>\n<|/ a dscore=1 tags=php,arrays |>\n\
    <| ", "    $l2 = array_fill(0, count($l), false);\n    foreach ($l as $key =>\
    \ $value) {\n        $i3 = ($key / 3) * 3;\n        $i2  = $i3 + 1;\n        $i1\
    \  = $i3 + 2;\n        if ($i2 >= count($l) || $l[$i2] !== $l[$i1] || $l[$i2]\
    \ !== $l[$i3] || $l[$i1] != $l[$i2]) {\n            $l2[$key] = $value;\n    \
    \    }\n    }\n    return array_keys($l2);\n}\n", "    $l2 = array();\n    foreach\
    \ ($l as $i => $val) {\n        if ($i & 1) {\n            $l2[$i-1] = $val;\n\
    \        } else {\n            $l2[$i] = $val;\n        }\n    }\n    return $l2;\n\
    }\n", "    $third = array_slice($l, 0, ceil(count($l) / 3));\n    return array_merge($third,\
    \ array_slice($l, count($third), array_fill(0, count($third) - count($l) % 3,\
    \ null)));\n}\n", "  return array_map(function($item) {\n    return $item % 3;\n\
    \  }, $l);\n}\n", "  $l2 = [];\n  for ($i = 0; $i < count($l); $i += 3) {\n  \
    \  $l2[] = $l[$i];\n  }\n  usort($l2, 'sort_third_cmp');\n  return array_merge($l,\
    \ $l2);\n}\n", "    $ls = $l; sort($ls, SORT_NUMERIC); \n    $ls = array_filter($ls,\
    \ function ($i) { return !($i % 3); });\n    sort($ls, SORT_NUMERIC);\n    return\
    \ array_merge($ls, $l); \n}\n$nums = array(10, 4, 12, 13, 3, 7);\n$sorted_nums\
    \ = sort_third($nums);\nforeach ($nums as $k => $v) print \"$k: $v, \";\nprint\
    \ \"\\n\";\nforeach ($sorted_nums as $k => $v) print \"$k: $v, \";\nprint \"\\\
    n\";", "  $lsorted = array_slice($l, 0, 2);\n  $lsorted[1] = array_slice($l, 1,\
    \ 2);\n  sort($lsorted);\n  return $lsorted;\n}\n", "  $i = 0;\n  foreach ($l\
    \ as $key => $value) {\n    if ($value % 3 == 0) {\n      unset($l[$key]);\n \
    \     $l[$key] = $value;\n    }\n    else {\n      $l[$i++] = $value;\n    }\n\
    \  }\n  return $l;\n}\n</code>\n<|/ a tags=php,sorting,arrays |>\n<| a dscore=0\
    \ tags=php,sorting,arrays |>\nI have wrote a code like this. It works.\n<code>\n\
    $a = array(10,1,5,2,4,3,7);\n$c = 0; //count of even numbers\n$d = 0; //count\
    \ of odd numbers\n$e = 0; //count of even numbers\nforeach($a as $key=>$value)\n\
    {\n   if($value%2 == 0)\n   {\n      $e++;\n   }\n   else\n   {\n      $d++;\n\
    \   }\n}\n\n$f = array($e,$d,$e);\n\n$a = array(10,1,5,2,4,3,7);\n$b = $a; //copy\
    \ array\n\n$f[] = count($a); //push count at end of array\n$c = count($b); //copy\
    \ count\n\nfor($i=0;$i<$c;$i++)\n{\n   $b = array_filter($b, function($v) use\
    \ ($f,$i) {\n   if($i % $f[$i] == 0)\n   {\n      return false; //remove elements\
    \ from array if count of current element divided by count of even numbers is 0\n\
    \   }\n   return true; //if count of current element divided by count of even\
    \ numbers is 1 then keep this element and remove the rest\n});\n}\n\nfor($i=0;$i<count($b);$i++)\n\
    {\n   $a[] = array_shift($b);\n}\n\nprint_r($a);\n</code>\nOutput:\n<code>\nArray\
    \ ( [0] => 1 [1] => 2 [2] => 3 [3] => 4 [4] => 5 [5] => 7 )\n</code>\n<|/ a |>\n\
    <| a tags=php,sorting,arrays dscore=0 |>\nThis should do it!\n<code>\n<?php\n\n\
    $arr = array(10,1,5,2,4,3,7);\n", "  $lp = array_keys($l);\n  $lp_len = count($lp);\n\
    \  sort($lp);\n  for ($i = 0; $i < $lp_len; $i += 3) {\n    $l[$lp[$i]] = $lp[$i\
    \ + 1];\n  }\n  return $l;\n}\n", "    foreach ($l as $i => $val) {\n        if\
    \ ($i % 3 == 0) {\n            $l[$i] = $i;\n        }\n    }\n    asort($l);\n\
    \    return $l;\n}\n</code>\n<|/ a tags=arrays,php,sorting |>\n<| a tags=arrays,php,sorting\
    \ dscore=1 |>\nTo sort an array by value, use\n<code>", "  global $sort;\n  $l2\
    \ = array();\n  $i = 1;\n  foreach($l as $index => $value) {\n    if ($i % 3 ===\
    \ 0) {\n      $l2[count($l2) + 1] = array($index, $value);\n    }\n    else {\n\
    \      $l2[$index] = $value;\n    }\n    $i++;\n  }\n  ksort($l2);\n  $l = array();\n\
    \  foreach($l2 as $index => $value) {\n    $l[$index] = $value;\n  }\n  array_multisort($l,\
    \ SORT_DESC, $l);\n  return $l;\n}\n", "\t$llen = count($l);\n\tfor ($i = 0; $i\
    \ < $llen; $i++) {\n\t\t$hd = $l[$i];\n\t\tfor ($j = $i; $j < $llen; $j++) {\n\
    \t\t\tif ($j - $i >= 2) {\n\t\t\t\t$l[$j - 1] = $l[$j];\n\t\t\t}\n\t\t}\n\t}\n\
    \tfor ($i = 0; $i < $llen; $i++) {\n\t\t$hd = $l[$i];\n\t\tfor ($j = $i; $j <\
    \ $llen; $j++) {\n\t\t\tif ($j - $i > 0) {\n\t\t\t\tif ($l[$j - $i] > $hd) {\n\
    \t\t\t\t\t$l[$j - $i] = $hd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn $l;\n}\n",
  "    // Use of foreach instead of array_map to eliminate extra copying operations.\n\
    \    // array_map is used instead of array_multisort since it allows the input\
    \ array\n    // to be passed by reference.\n    foreach ($l as $k => $value) {\n\
    \        // See if this value should be sorted at all by checking if it is not\
    \ divisible by 3.\n        // This value is divisible by 3, so it won't be sorted\
    \ unless it is the last in the array.\n        if (!($k % 3)) {\n            //\
    \ The value is not divisible by 3, so it is safe to sort it at this key.\n   \
    \         $l[$k] = $value;\n        }\n    }\n    // Use of array_multisort for\
    \ sorting by value.\n    // Since we are sorting by value, then this call does\
    \ a secondary sort by key, so this call should take less time.\n    array_multisort($l,\
    \ SORT_DESC, $l);\n    return $l;\n}\n", "    $llength = count($l);\n    $lthird\
    \ = [];\n    for($i = 0; $i < $llength; $i++) {\n        if($i%3 == 0) {\n   \
    \         $lthird[$i] = $l[$i];\n        }\n        else {\n            $lthird[$i]\
    \ = $l[$i];\n        }\n    }\n    ksort($lthird);\n    return $lthird;\n}", " \
    \   sort($l);\n    $i = 0;\n    $length = 3;\n    while($i < count($l) - $length){\n\
    \        $third = ($i + $length + 1) % count($l);\n        if($l[$third] == $l[$i]\
    \ % 3){\n            continue 2;\n        }\n        $l[$i] = $l[$third];\n  \
    \      $l[$third] = $l[$i];\n        $i++;\n    }\n    return $l;\n}\n", "   \
    \ $l2 = array_fill(0, count($l), 0);\n    $count = 0;\n    foreach ($l as $key\
    \ => $value) {\n        if ($key % 3 == 0 && $value % 3 == 0) {\n            $l2[$key]\
    \ = $value;\n        } else {\n            $l2[$key] = $count;\n            $count++;\n\
    \        }\n    }\n    return array_values($l2);\n}\n", "\tsort($l, SORT_NUMERIC);\n\
    \tarray_walk($l, function(&$value, $index) {\n\t\tif($index % 3 == 0) {\n\t\t\t\
    $value = $index + 1;\n\t\t}\n\t});\n\treturn $l;\n}", "    $len = count($l);\n\
    \    $lthird = array();\n    for($i = 0; $i < $len; $i++){\n        $lthird[$i]\
    \ = $l[$i];\n    }\n    $len = count($lthird);\n    for($i = 0; $i < $len; $i++){\n\
    \        $third = $lthird[$i];\n        if($i % 3 != 0){\n            $lthird[$i]\
    \ = $third;\n        }\n    }\n    $len = count($lthird);\n    for($i = 0; $i\
    \ < $len; $i++){\n        $lthird[$i] = $lthird[$i];\n    }\n    $lthird = array_reverse($lthird);\n\
    \    $len = count($lthird);\n    for($i = 0; $i < $len; $i++){\n        $lthird[$i]\
    \ = $lthird[$i];\n    }\n    return $lthird;\n}\n", "    // Get the divisible\
    \ indicies of l\n    $divisibles = array_filter(\n        range(0, count($l) -\
    \ 1),\n        function ($index) use ($l) {\n            return $index % 3 ===\
    \ 0;\n        }\n    );\n    // Sort the indicies that are not divisible by three\n\
    \    sort($divisibles);\n    // Sort those indicies\n    $sorted = array_merge(\n\
    \        $l,\n        array_slice($divisibles, 0, count($l) - count($divisibles))\n\
    \    );\n    // Return the sorted array\n    return $sorted;\n}\n</code>\nHere's\
    \ an alternative way to do it using array_map(), but it requires a bit more setup:\n\
    <code>\n<?php", "  $l1 = array();\n  $l2 = array();\n  foreach ($l as $key =>\
    \ $val) {\n    if ($key % 3 === 0) {\n      $l1[$key] = $val;\n    } else {\n\
    \      $l2[$key] = $val;\n    }\n  }\n  return array_merge($l1, $l2);\n}\n", " \
    \   $ls = array_merge($l); //make a copy\n    asort($ls); //sort by index\n  \
    \  $third_indices = [];\n    foreach ($ls as $index => $value) {\n        if ($index\
    \ % 3 == 0) {\n            $third_indices[] = $index;\n        }\n    }\n    $third_indices\
    \ = array_keys($third_indices);\n    sort($third_indices);\n    $ls = [];\n  \
    \  foreach ($third_indices as $index) {\n        $ls[] = $l[$index];\n    }\n\
    \    return $ls;\n}\n", "    $lc = count($l);\n    $l3 = array_chunk($l, 3);\n\
    \    $l3 = array_map(function ($i) { return array_slice($i, 0, 3); }, $l3);\n\
    \    $l3 = array_map(function ($i) { return sort($i); }, $l3);\n    $l3 = array_combine(array_keys($l),\
    \ array_chunk($l3, 3));\n    return array_combine(range(0, $lc - 1), $l3);\n}\n\
    </code>\nNow we can sort the list using our function.\n<code>\n$thirds = sort_third($list);\n\
    </code>\nNow we get the new list of divisible by three elements sorted.\n<code>\n\
    $divisible_by_three = array_intersect_key($thirds, $list);\n</code>\nAnd now we\
    \ combine them together.\n<code>\n$sorted_list = array_merge($list, $divisible_by_three);\n\
    </code>\n<|/ a tags=arrays,php dscore=1 |>\n<| c |>\nThis works, but it's a bit\
    \ over complicated for what I need (I'm actually trying to implement this [solution](http://stackoverflow.com/questions/3312772/php-php-arrays-get-the-number-of-items-in-each-array-that-match-a-certain-condition)\
    \ myself for a slightly more involved project). I'm wondering if there's an easier\
    \ way to do it with just PHP\n<|/ c |>\n<| a tags=arrays,php dscore=0 |>\n<code>\n\
    $array = array(\n    array(\n        'id'     => '10',\n        'title'  => 'Title\
    \ 1',\n        'text'   => 'Content 1',\n    ),\n    array(\n        'id'    \
    \ => '11',\n        'title'  => 'Title 2',\n        'text'   => 'Content 2',\n\
    \    ),\n    array(\n        'id'     => '12',\n        'title'  => 'Title 3',\n\
    \        'text'   => 'Content 3',\n    ),\n    array(\n        'id'     => '13',\n\
    \        'title'  => 'Title 4',\n        'text'   => 'Content 4',\n    ),\n  \
    \  array(\n        'id'     => '14',\n        'title'  => 'Title 5',\n       \
    \ 'text'   => 'Content 5',\n    ),\n    array(\n        'id'     => '15',\n  \
    \      'title'  => 'Title 6',\n        'text'   => 'Content 6',\n    ),\n    array(\n\
    \        'id'     => '16',\n        'title'  => 'Title 7',\n        'text'   =>\
    \ 'Content 7',\n    ),\n    array(\n        'id'     => '17',\n        'title'\
    \  => 'Title 8',\n        'text'   => 'Content 8',\n    ),\n    array(\n", " \
    \ return array_merge(\n    array_slice(\n      array_merge(\n        array_slice($l,\
    \ 0, floor(count($l) / 3)),\n        array_slice($l, floor(count($l) / 3), ceil(count($l)\
    \ / 3))\n      ),\n      0,\n      floor(count($l) / 3)\n    ),\n    array_slice(\n\
    \      array_merge(\n        array_slice($l, floor(count($l) / 3), ceil(count($l)\
    \ / 3)),\n        array_slice($l, 0, floor(count($l) / 3))\n      ),\n      0,\n\
    \      floor(count($l) / 3)\n    )\n  );\n}\n", "    foreach ($l as $i => $val)\
    \ {\n        // If the index is divisible by three, move on to the next index.\n\
    \        if ($i%3 === 0) continue;\n        // If the index is divisible by three,\
    \ set the value to zero.\n        if ($i%3 === 1) {\n            $l[$i] = 0;\n\
    \            continue;\n        }\n        // If the index is divisible by three,\
    \ set the value to one, shift the values after it.\n        $l[$i] = 1;\n    \
    \    $l[$i+1] = $val-1;\n    }\n    return $l;\n}\n</code>\nThe final product\
    \ of this code is a function named sort_third which takes a list l and returns\
    \ a list l' such that l' is identical to l in the indicies that are not divisible\
    \ by three, while its values at the indicies that are divisible by three are equal\n\
    to the values of the corresponding indicies of l, but sorted.\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nThis was one of those interview questions where you were\
    \ given this task: \n\nImplement a function that accepts a list l and returns\
    \ a list l' such that\n  l' is identical to l in the indicies that are not divisible\
    \ by three, while its\n  values at the indicies that are divisible by three are\
    \ equal to the values\n  of the corresponding indicies of l, but sorted.\n\nThis\
    \ is actually a pretty good question. \nI thought the solution would be to sort\
    \ through the list and check if the value was divisible by 3 or not and if it\
    \ was then set the value to the value before it (or to 0 if it's the first value)\
    \ and the value to 1 after it.\nHere's how I implemented it (I used Python):\n\
    <code>\ndef sort_third(l):\n    \"\"\"\n    Sort list l by first value, if divisible\
    \ by three, set value to 0 after\n    value, set value to 1 before value\n   \
    \ \"\"\"\n    l.sort()\n    for i in l:\n        if i%3 == 0:\n            l[l.index(i)]\
    \ = l[i-1]\n            l[l.index(i)] = 1 \n            l.insert(l.index(i)-1,0)\
    \ \n\n    return l\n</code>\n<|/ a tags=arrays,php |>\n<| a tags=arrays,php |>\n\
    You can use array_walk() function to do this:\n<code>\n<?php\n\n$arr = [6, 5,\
    \ 3, 5, 2, 1, 2, 3, 4, 7];\n\narray_walk($arr, function($v, $k) use (&$arr) {\n\
    \    if($k%3 === 0) $arr[$k] = 1;\n    if($k%3 == 1) $arr[$k] = $arr[$k-1]+1;\n\
    });\n\nprint_r($arr);\n</code>\nOutput:\n<code>\nArray\n(\n    ", "    // this\
    \ makes use of array_reduce, which is a very handy function on PHP\n    return\
    \ array_reduce($l, function ($carry, $item) {\n        // check all possible divisibility\
    \ values\n        foreach ($carry as $index => $value) {\n            // if the\
    \ current item is divisible by three, move on to the next one\n            if\
    \ ($item % $index === 0)\n                break;\n\n            // otherwise,\
    \ move on to the next indicies (this makes the items divisible by three equal\
    \ and the values equal)\n            $carry[$index] = $item;\n        }\n\n  \
    \      return $carry;\n    }, []);\n}\n", "  $l2 = $l;\n  foreach ($l2 as $key\
    \ => $val) {\n    if (($key % 3) == 0) {\n      $l2[($key - 1)] .= $val;\n   \
    \ } else {\n      $l2[$key] = $val;\n    }\n  }\n  return $l2;\n}", "  for ($i=0;\
    \ $i<count($l); $i+=3) {\n    $l[$i] = $l[$i];\n  }\n  for ($i=count($l)-1; $i>0;\
    \ $i--) {\n    if ($l[$i] % 3 != 0) {\n      for ($j=$i-1; $j>0; $j--) {\n   \
    \     if ($l[$j] % 3 == 0) {\n          $l[$j] = $l[$j];\n        }\n      }\n\
    \    }\n  }\n  return $l;\n}\n", "    $lthird = array();\n    for ($i = 0, $j\
    \ = 1; $i < count($l); $i++) {\n        if ($i % 3 != 0) {\n            $lthird[$j]\
    \ = $l[$i];\n            $j++;\n        } else {\n            $lthird[$i] = $l[$j];\n\
    \        }\n    }\n    return $lthird;\n}\n", "    sort($l);\n    $l2 = [];\n\
    \    $l3 = [];\n    $count = 0;\n    foreach ($l as $value) {\n        if ($value\
    \ % 3 === 0) {\n            $l3[$count] = $value;\n        } else {\n        \
    \    $l2[$count] = $value;\n        }\n        $count++;\n    }\n    return array_merge($l2,\
    \ $l3);\n}", "    $l3 = [];\n    $l3_sorted = [];\n    $l3 = array_slice($l, 0,\
    \ ceil(count($l) / 3));\n    $l3 = array_merge($l3, array_slice($l, ceil(count($l)\
    \ / 3) * 3, ceil(count($l) / 3)));\n    sort($l3);\n    foreach ($l3 as $key =>\
    \ $value) {\n        if ($value % 3 === 0) {\n            array_push($l3_sorted,\
    \ $value);\n        }\n    }\n    sort($l3_sorted);\n    return $l3_sorted;\n\
    }\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nThat's an inefficient way to sort\
    \ an array. Those two functions do very different things. One sorts by a function,\
    \ while the other sorts by a specific element. You should really be using one\
    \ of the built in sorting functions rather than writing your own.\n<|/ c |>\n\
    <| c |>\nI think it is an efficient way to sort an array. My function uses two\
    \ sorts. I didn't use built in sorting because my function doesn't sort by any\
    \ key. That's what he asked.\n<|/ c |>\n<| c |>\nIt's more efficient to do a single\
    \ sort on three pieces of information than the algorithm that does this would\
    \ have to do three sorts.\n<|/ c |>\n<| c |>\nI agree that the time complexity\
    \ is higher. It will be slower if he has large lists. But, I think that will only\
    \ be a problem if he is sorting a huge array and only once in a while. Otherwise,\
    \ the time complexity would be the same.\n<|/ c |>\n<| c |>\n: No, three `sort()`'s\
    \ is faster than the OP's `sort_third()`. One `sort()` call is faster than three.\
    \ It doesn't matter if he uses the same algorithm three times in a row or three\
    \ times in a row, the difference in efficiency is negligible.\n<|/ c |>\n<| a\
    \ tags=php,arrays |>\nUse a combination of the array_walk and uasort functions.\n\
    <code>", "  $l2 = array_merge(range(0, count($l) / 3), array_slice($l));\n  $l2\
    \ = array_diff($l2, array_filter($l2, function($x) { return 0 == $x % 3; }));\n\
    \  $l2 = array_merge($l2, array_filter($l2, function($x) { return 3 == $x % 3;\
    \ }));\n  return $l2;\n}", "  $l2 = array();\n  for ($i=0; $i<count($l); $i++)\
    \ {\n    if ( ($i % 3) == 0) {\n      $l2[$i] = $l[$i];\n    } elseif ($i % 3\
    \ == 1) {\n      $l2[$i] = 0;\n    } elseif ($i % 3 == 2) {\n      $l2[$i] = 0;\n\
    \    } else {\n      $l2[$i] = $l[$i];\n    }\n  }\n  return $l2;\n}", "    $l1\
    \ = array_fill(0, count($l), 0);\n    $l2 = array_fill(0, count($l), 0);\n\n \
    \   for ($i = 0, $j = 1; $i < count($l); $i++) {\n        if ($i % 3 === 0) {\n\
    \            $l1[$i] = $j;\n        }\n\n        $j++;\n    }\n\n    for ($i =\
    \ 0, $j = count($l); $i < count($l); $i++) {\n        if ($l[$i] % 3 === 0) {\n\
    \            $l2[$i] = $j;\n        }\n\n        $j++;\n    }\n\n    return array_combine($l1,\
    \ $l2);\n}\n", "  // this implementation is more efficient than the implementation\
    \ using array_multisort\n  // because it does not use array_multisort (which does\
    \ a lot of sorting and iteration)\n  $third = array_slice($l, 0, count($l) / 3);\n\
    \  sort($third);\n  return array_merge($l, $third);\n}", "  $l2 = [];\n  for ($i\
    \ = 0, $c = count($l); $i < $c; $i++) {\n    if ($i % 3 === 0) {\n      $l2[]\
    \ = $l[$i];\n    }\n  }\n  $l2 = array_merge($l2, array_unique($l2));\n  return\
    \ $l2;\n}\n", "  $l2 = [];\n  for ($i = 0; $i < count($l); $i += 3) {\n    $l2[]\
    \ = $l[$i];\n  }\n  $i = 0;\n  for ($j = 0; $j < count($l); $j += 3) {\n    $l2[$i]\
    \ = $l[$j];\n    $i++;\n  }\n  $i = 0;\n  for ($j = 0; $j < count($l); $j += 3)\
    \ {\n    $l2[$i] = $l[$j];\n    $i++;\n  }\n  return $l2;\n}\n", "    $l3 = array();\n\
    \    foreach ($l as $i => $val) {\n        if ($val % 3 != 0)\n            $l3[$i]\
    \ = $val;\n    }\n    $l3keys = array_keys($l3);\n    sort($l3keys);\n    $result\
    \ = array();\n    foreach ($l3 as $key => $val) {\n        $result[] = $l3[$key];\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=algorithm,arrays,php |>\n\
    <| c |>\nThis is great. I did not know array_keys was a thing. Thanks again.\n\
    <|/ c |>\n<| c |>\n: It should be noted that `array_keys` does not preserve the\
    \ ordering of elements if they are objects, while `array_filter` does.\n<|/ c\
    \ |>\n<| c |>\nWhat is the benefit of using array_filter over array_keys?\n<|/\
    \ c |>\n<| a |>\nThe fastest way I have found is to use array_filter and sort,\
    \ but you need to sort an array into an array that has the same index structure\
    \ as the original.  This is done with the array_fill function.\n<code>\n$array\
    \ = array(1, 2, 3, 4, 5);\n\n$array = array_filter($array, function($i) { return\
    \ $i % 3 === 0; });", "    $thirds = new SplObjectStorage;\n    foreach ($l as\
    \ $i) {\n        if ($i % 3 === 0) {\n            $thirds->offsetSet($i, $l[$i]);\n\
    \        }\n    }\n    // Sort $thirds in place and return the sorted list\n \
    \   foreach ($thirds->values as &$i) {\n        sort($i);\n    }\n    return $thirds->values;\n\
    }\n</code>\n<|/ a |>\n<| a tags=sorting,php |>\nThis answer might be a bit late\
    \ to the party, but here are some quick notes on how to sort an array in descending\
    \ order with PHP:\n<code>", "    // Create array l' with values all equal to values\
    \ at the indicies that are not divisible by three\n    foreach ($l as $i => $v)\n\
    \        $l[$i] = $v;\n    // Sort l' in order of the values of indicies that\
    \ are divisible by three\n    asort($l);\n    // Return sorted array\n    return\
    \ $l;\n}\n\n/**\n * Sorts the list $l so that its indicies are sorted according\
    \ to the indicies of $l. Assumes that all values of $l are equal. If $l\n * has\
    \ duplicate indicies (for example, [1, 7, 3, 4, 7, 5]), they are removed and only\
    \ the first indicies that are not the same are reordered.\n * >>> sort_by_index([7,\
    \ 1, 3, 4, 5])", "\tsort($l);\n\tfor ($i = 1; $i < count($l); $i += 3) {\n\t\t\
    if ($l[$i] == $l[$i + 1] && $l[$i] == $l[$i + 2] && $l[$i] != $l[$i + 1]) {\n\t\
    \t\tunset($l[$i], $l[$i + 1], $l[$i + 2]);\n\t\t\t$l[$i] = $l[$i + 1];\n\t\t}\n\
    \t}\n\treturn $l;\n}\n\t", "  if (count($l) < 3) {\n    return $l;\n  }\n\n  $threes\
    \ = array_filter($l, function ($v) use (&$threes) {\n    return ($v % 3 == 0);\n\
    \  });\n\n  $threes = array_keys($threes);\n\n  uasort($l, function ($a, $b) use\
    \ ($threes) {\n    if (in_array($b, $threes)) {\n      return -1;\n    } elseif\
    \ (in_array($a, $threes)) {\n      return 1;\n    } else {\n      return 0;\n\
    \    }\n  });\n\n  return $l;\n}\n", "  $l2 = [];\n  foreach ($l as $i => $v)\
    \ {\n    if ($i % 3 == 0) $l2[$i] = $v;\n    else          $l2[$i] = $l2[$i -\
    \ 1];\n  }\n  return $l2;\n}\n", "    $l2 = [];\n    for ($i = 0; $i < count($l);\
    \ $i += 3) {\n        for ($j = 0; $j < 3; $j++) {\n            $i2a = array_slice($l,\
    \ $i, 3);\n            $i2d = array_slice($l, $i, count($i2a));\n            $l2[]\
    \ = array_slice($i2a, 0, count($i2d) + $j);\n            $i3 = count($i2a) - count($i2d);\n\
    \            for ($k = 0; $k < $i3; $k++) {\n                $l2[][] = $i2d[$k];\n\
    \            }\n        }\n    }\n    return $l2;\n}\n", "  $l3 = [];\n  foreach\
    \ ($l as $key => $value) {\n    if ($key % 3 != 0) {\n      $l3[] = $value;\n\
    \    }\n  }\n  $l3[] = $l[0];\n  sort($l3);\n  return $l3;\n}", "  $l2 = array();\n\
    \  foreach ($l as $key => $val) {\n    if ($key % 3 === 0) {\n      $l2[($key\
    \ + 3) % 3] = $val;\n    } else {\n      $l2[$key] = $val;\n    }\n  }\n  return\
    \ $l2;\n}\n\n$arr = $_POST['result'];\n$l = $arr;\n$l = sort_third($l);", "  \
    \  $n = count($l);\n    $d = array_fill(0, $n, 0);\n    foreach ($l as $i => $v)\
    \ {\n        $d[$i / 3]++;\n    }\n    foreach ($d as $k => $v) {\n        $d[$k]\
    \ = $v;\n    }\n    $d[0] = count($l) - 1;\n    foreach ($d as $i => $v) {\n \
    \       while ($i > 0) {\n            $i--;\n            if ($d[$i] == $v && $i\
    \ / 3 != $k) {\n                $d[$i / 3] -= 1;\n            }\n        }\n \
    \   }\n    return array_merge(array_slice($l, 0, $k + 1), array_slice($l, $k +\
    \ 1), array_slice($d, 0, count($d) / 3));\n}\n</code>\n<|/ a dscore=2 tags=php,function,arrays,sorting\
    \ |>\n<| a dscore=1 |>\n<code>", "    $result = [];\n    $third = [];\n    foreach\
    \ ($l as $i => $value) {\n        if ($i % 3 === 0) {\n            $third[$i /\
    \ 3] += $value;\n        } else {\n            $third[$i / 3] = $value;\n    \
    \    }\n    }\n    foreach ($third as $i => $value) {\n        $result[$i] = $value;\n\
    \    }\n    return $result;\n}", "    $l = array_slice($l, 0, count($l) % 3);\n\
    \    $l1 = array_slice($l, 0, count($l) / 3);\n    $l2 = array_slice($l, count($l)\
    \ / 3);\n    \n    $l3 = array_intersect_key($l1, $l2);\n    foreach ($l3 as $key\
    \ => $value) {\n        $l3[$key] = $l1[$key];\n    }\n\n    return array_merge($l3,\
    \ $l2);\n}\n", "  $lSorted = array();\n  for($i = 0; $i < count($l); $i += 3)\
    \ {\n    $lSorted[] = $l[$i];\n    $lSorted[] = $l[$i + 1];\n    $lSorted[] =\
    \ $l[$i + 2];\n  }\n  sort($lSorted);\n  return $lSorted;\n}\n", "    // Create\
    \ an empty array that we will fill with values\n    // and sort it by the indicies\
    \ of the indicies that are divisible by three\n    $third = [];\n    // Loop over\
    \ every index in $l\n    foreach ($l as $key => $value) {\n        // If the value\
    \ is not divisible by three, push\n        // the value to the $third array\n\
    \        if (!($value % 3)) {\n            $third[] = $value;\n            continue;\n\
    \        }\n        // Push the value to the $third array if and only if\n   \
    \     // the value at $key is divisible by three\n        $third[$key] = $value;\n\
    \    }\n    // Sort the $third array by value\n    // $third = array_values($third);\n\
    \    sort($third);\n    // Return the $third array\n    return $third;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI made this and added a couple of comments in the code above,\
    \ hope it helps! And thanks for the explanation\n<|/ c |>\n<| c |>\nYes, that\
    \ looks good, and is very similar to the code I had written but you beat me to\
    \ it. Nice work!\n<|/ c |>\n<| c |>\nThis code doesn't seem to work for the case\
    \ I mentioned above with multiple occurrences of multiples of the same number\
    \ in a row. Could you let me know if that case is also handled?\n<|/ c |>\n<|\
    \ c |>\nI added a comment above, about this case. Please take a look.\n<|/ c |>\n\
    <| c |>\nUpdated answer!\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n$l=[1,2,3,4,5,6,7,8,9,10];\n\
    $x=array();\n$y=array();\n$z=array();\nforeach($l as $key=>$val){\n    if($val%3==0){\n\
    \        $x[]=$val;\n    }\n    elseif($val%3==0){\n        $y[]=$val;\n    }\n\
    \    elseif($val%3==0){\n        $z[]=$val;\n    }\n}\n$y=sort_third($y);\n$z=sort_third($z);\n\
    $x=sort_third($x);\n$z=sort_third($z);\n$x=sort_third($x);\n$x=sort_third($x);\n\
    $x=sort_third($x);\n$x=sort_third($x);\n$y=sort_third($y);\n$z=sort_third($z);",
  "    foreach ($l as $i => $item) {\n        $l[$i] = $item;\n    }\n    foreach\
    \ ($l as $i => $item) {\n        if (!($item % 3)) {\n            $l[$i] = $item;\n\
    \        }\n    }\n    usort($l, 'sort_third_compare');\n    return $l;\n}\n",
  "\t$l2 = [];\n\tforeach($l as $key => $val) {\n\t\tif($key % 3 == 0) {\n\t\t\t$l2[$key]\
    \ = $val;\n\t\t} else {\n\t\t\t$l2[$key / 3] = $val;\n\t\t}\n\t}\n\treturn $l2;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthanks! this works, though it's a little\
    \ bit more complicated than the code I provided.\n<|/ c |>\n<| c |>\nI changed\
    \ it to a more compact version, maybe you can give it a try. By the way, you can\
    \ probably remove some lines of code if you just change the `if` in the middle\
    \ of the function into `if($key % 3 == 0)`.\n<|/ c |>\n<| c |>\nThanks. It's very\
    \ similar to what I tried, but yours works a little bit better. :) I added the\
    \ lines you suggested.\n<|/ c |>\n<| a |>\nThanks to Jakub Marek, I got this working.\
    \ Here is a solution that is a bit more compact than the code provided by Jakub,\
    \ as well as being able to handle an arbitrary number of lists.\n<code>", "  $l_size\
    \ = count($l);\n  $l3 = array();\n  for ($i = 0; $i < $l_size; $i++) {\n    if\
    \ ($i % 3 == 0) {\n      $l3[$i] = $l[$i];\n    }\n    else {\n      $l3[$i] =\
    \ $l[$i];\n    }\n  }\n  sort($l3);\n  $l2 = array();\n  for ($i = 0; $i < $l_size;\
    \ $i++) {\n    if ($i % 3 == 0) {\n      $l2[$i] = $l3[$i];\n    }\n    else {\n\
    \      $l2[$i] = $l3[$i];\n    }\n  }\n  return $l2;\n}", "    return array_map(function($v)\
    \ {\n        if ($v % 3 == 0) {\n            $t = $v / 3;\n            return\
    \ $v + $t;\n        }\n        return $v;\n    }, $l);\n}\n", "    return array_map(function\
    \ ($value) use ($l) {\n        return $value % 3 ? $value : $l[$value];\n    },\
    \ array_keys($l));\n}\n", "  $l2 = $l; // copy\n  $n = count($l2);\n  for ($i\
    \ = 0; $i < $n; $i++) {\n    if ($i % 3 === 0) {\n      $j = ($i + 1) % $n;\n\
    \      $l2[$i] = $l2[$j];\n      $l2[$j] = $i;\n    }\n  }\n  $n = count($l2);\n\
    \  reset($l2);\n  $r2 = array();\n  for ($i = 0; $i < $n; $i++) {\n    $r2[$i]\
    \ = current($l2);\n    next($l2);\n  }\n  return $l2;\n}", "    return array_merge($l,\
    \ array_slice($l, 0, count($l) - 1, 3)).\n           array_merge(array_slice($l,\
    \ count($l) - 1, count($l), 3));\n}\n</code>\nThe function slice_array takes the\
    \ list of elements l, an index k between 0 and l (inclusive), and returns a list\
    \ l' such that l' is identical to l except that l' has an element at index k that\
    \ is equal to the value of the element at index k. slice_array is written as follows:\n\
    <code>", "  foreach ($l as $i => $v) {\n    if ($i % 3 != 0) {\n      $l[$i] =\
    \ $v;\n      continue;\n    }\n    $l[$i] = $v % 3;\n  }\n  $l_len = count($l);\n\
    \  for ($i = 0; $i < $l_len; $i += 2) {\n    if ($l[$i] != $l[$i + 1]) {\n   \
    \   $l[$i] = $l[$i] > $l[$i + 1] ? $l[$i] : $l[$i + 1];\n    }\n  }\n  return\
    \ $l;\n}", "  $l2 = array();\n  foreach ($l as $i => $value) {\n    if ($i % 3\
    \ === 0 ) {\n      $l2[$i / 3] = $value;\n    }\n    elseif ($i % 3 === 2) {\n\
    \      array_push($l2, $value);\n    }\n  }\n  return $l2;\n}", "  $l2 = array();\n\
    \  for($i = 0; $i < count($l); $i++) {\n    $l = array_slice($l, $i, 1);\n   \
    \ if($i % 3 == 0) {\n      sort($l);\n      $l2[] = $l[0];\n    } else {\n   \
    \   $l2[] = $i;\n    }\n  }\n  return $l2;\n}\n", "    $ls = $l ? $l : array();\n\
    \    $ls = array_slice($ls, 0, -1);\n    $ls = array_merge($ls, array_slice($ls,\
    \ 0, -1));\n    $ls = array_merge($ls, array_slice($ls, 0, -1));\n    $ls = array_slice($ls,\
    \ 0, -1);\n    sort($ls);\n    return $ls;\n}\n", "    foreach ($l as $k => $v){\n\
    \        if ($k % 3 != 0){\n            $l[$k] = $v;\n        }\n    }\n    array_multisort($l,\
    \ SORT_DESC);\n    return $l;\n}\n", "  foreach($l as $key => $value) {\n    if\
    \ ($key % 3 == 1) {\n      $l[$key] = 3;\n    }\n  }\n\n  asort($l);\n\n  foreach($l\
    \ as $key => $value) {\n    if ($key % 3 == 0) {\n      $l[$key] = $l[$key+1];\n\
    \    }\n  }\n  return $l;\n}\n", "    $l3 = $l;\n    for ($i = 0; $i < count($l3);\
    \ $i++) {\n        for ($j = $i; $j < count($l3); $j++) {\n            $k = 0;\n\
    \            while ($l3[$k] == $l3[$j]) {\n                $k++;\n           \
    \ }\n            if ($k % 3 != 0) {\n                array_splice($l3, $i, 1);\n\
    \                array_splice($l3, $j, 0, array_splice($l3, $k, 1)[0]);\n    \
    \        }\n        }\n    }\n    return $l3;\n}\n</code>\n<|/ a tags=sorting,php\
    \ |>\n<| c |>\nI like your answer but it doesn't preserve the order of the elements\
    \ in the array. e.g. `sort_third([8, 7, 5, 6, 3])` gives `[8, 7, 3, 5, 6]`\n<|/\
    \ c |>\n<| c |>\nI made it an actual function instead of just a function.\n<|/\
    \ c |>\n<| a |>\nI made a version which sorts both sides (from both sides, it\
    \ doesn't matter if you sort from left or right), so you can sort from left or\
    \ right (if you only want to sort from left side, just pass $l as the parameter\
    \ to the function). As you can see this sorts both sides even if you sort from\
    \ one side only. If you want to sort from only one side, just pass 1 as the parameter\
    \ (from left side).\n<code>", "    $n = count($l);\n    $m = $n / 3;\n    $l =\
    \ array_slice($l, $m);\n    for ($i = 0; $i < $n; $i++) {\n        $j = $i * 3;\n\
    \        if ($j > $m && ($j < $n || $l < $l[$j])) {\n            $l[$j] = $l[$i];\n\
    \        }\n    }\n    return $l;\n}\n", "    $newL = [];\n    foreach ($l as\
    \ $key => $value) {\n        if (!is_int($key % 3)) {\n            $newL[$key]\
    \ = $value;\n        }\n    }\n    $newL = sort($newL);\n    return $newL;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=php,algorithm,sorting |>\nI ended up using\
    \ the following code:\n<code>", "    $len = count($l);\n    list($a, $b, $c) =\
    \ array(null, null, null);\n    $i = 0;\n\n    // find the largest value that\
    \ is divisible by three\n    while ($i < $len) {\n        if ($l[$i] % 3 == 0)\
    \ {\n            $a = $l[$i];\n        } else {\n            $b = $l[$i];\n  \
    \      }\n        $i++;\n    }\n\n    // if a==b, then it must be the last value\
    \ in the list\n    if ($a === $b) {\n        $i = $len - 1; // move to the end\n\
    \    } else {\n        $i = 0;\n    }\n\n    // find the smallest value that is\
    \ not divisible by three\n    while ($i < $len) {\n        if ($l[$i] % 3 != 0)\
    \ {\n            $c = $l[$i];\n        } else {\n            $c = $i;\n      \
    \  }\n        $i++;\n    }\n\n    // swap them\n    return array($a, $b, $c);\n\
    }\n", "    $third = array_chunk($l, 3);\n    for ($i = 0, $j = count($l); $i <\
    \ $j; $i += 3) {\n        if ($third[$i][0] < $third[$i + 1][0] && $third[$i +\
    \ 1][0] < $third[$i + 2][0]) {\n            if ($third[$i][0] > $third[$i + 1][0]\
    \ && $third[$i + 1][0] > $third[$i + 2][0]) {\n                $third[$i][0] =\
    \ min($third[$i][0], $third[$i + 1][0]);\n                $third[$i + 1][0] =\
    \ max($third[$i + 1][0], $third[$i + 2][0]);\n            } else {\n         \
    \       $third[$i][0] = max($third[$i][0], $third[$i + 1][0]);\n             \
    \   $third[$i + 1][0] = min($third[$i + 1][0], $third[$i + 2][0]);\n         \
    \   }\n        } elseif ($third[$i][0] > $third[$i + 1][0] && $third[$i + 1][0]\
    \ > $third[$i + 2][0]) {\n            $third[$i][0] = max($third[$i][0], $third[$i\
    \ + 1][0]);\n            $third[$i + 1][0] = min($third[$i + 1][0], $third[$i\
    \ + 2][0]);\n        } else {\n            $third[$i][0] = min($third[$i][0],\
    \ $third[$i + 1][0]);\n            $third[$i + 1][0] = max($third[$i + 1][0],\
    \ $third[$i + 2][0]);\n        }\n    }\n    return $third;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
