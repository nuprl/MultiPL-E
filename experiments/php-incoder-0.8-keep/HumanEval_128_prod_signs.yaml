name: HumanEval_128_prod_signs
language: php
prompt: "<?php\n// You are given an array arr of integers and you need to return\n\
  // sum of magnitudes of integers multiplied by product of all signs\n// of each\
  \ number in the array, represented by 1, -1 or 0.\n// Note: return None for empty\
  \ arr.\n// Example:\n// >>> prod_signs([1, 2, 2, -4]) == -9\n// >>> prod_signs([0,\
  \ 1]) == 0\n// >>> prod_signs([]) == None\nfunction prod_signs($arr) {\n"
tests: "function candidate(...$args) {\n    return prod_signs(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 2, 2, -4)) !== -9) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(0, 1)) !== 0) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 1, 1, 2, 3, -1, 1)) !== -10) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array()) !== null) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(2, 4, 1, 2, -1, -1,\
  \ 9)) !== 20) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(-1,\
  \ 1, -1, 1)) !== 4) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(-1,\
  \ 1, 1, 1)) !== -4) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(-1,\
  \ 1, 1, 0)) !== 0) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  if (empty($arr)) return null;\n  $signs = array_flip($arr);\n  array_walk($arr,\
    \ function (&$val) {\n    $val *= $signs[$val];\n  });\n  return array_sum($arr);\n\
    }\n", "    if (empty($arr)) {\n        return null;\n    }\n    $sign = 1;\n \
    \   $result = 1;\n    $signs = array_fill(0, count($arr), $sign);\n    foreach\
    \ ($arr as $item) {\n        $signs = array_map(function ($i) use (&$signs) {\n\
    \            return $i * $sign;\n        }, $signs);\n        $result = $result\
    \ * ($item < 0 ? $signs[0] : $signs[1]);\n        $signs[0] = 0;\n        $signs[1]\
    \ = 0;\n    }\n    return $result;\n}\n", "    if (empty($arr)) return null;\n\
    \n    $sum = 0;\n    foreach ($arr as $val) {\n        $sign = array_search($val,\
    \ array_reverse($arr), true);\n        $sum += $sign * abs($val);\n    }\n   \
    \ return $sum;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice. Nice explanation.\
    \ Your solution makes perfect sense to me. I think this would be my favourite,\
    \ since this problem was asked and answered elsewhere and this is just a little\
    \ different from it. And this one has the added benefit of using the native `abs()`\
    \ function instead of using a custom function.\n<|/ c |>\n<| c |>\nGreat solution.\
    \ I did have to add a check for an empty array: `if (empty($arr)) return null;`\n\
    <|/ c |>\n<| c |>\nThanks, yeah I forgot about that since I wrote it for a different\
    \ use case.\n<|/ c |>\n<| c |>\nI like this solution. How does this compare with\
    \ some of the others?\n<|/ c |>\n<| c |>\nI like this solution. Why do you have\
    \ `if (empty($arr)) return null;` at the start? What do you think is wrong with\
    \ just `if (!empty($arr)) return null;`?\n<|/ c |>\n<| a dscore=2 |>\nThe other\
    \ answers here are great, but are missing some details that will help people who\
    \ are looking for an answer to the same question.\nThe main problem is \"How to\
    \ find the sum of the magnitudes of numbers in the array\".  To do this in Python\
    \ and most other languages, you will have to iterate through the array, find the\
    \ magnitude of each number, then add them.\nIn JavaScript, this is easy.  You\
    \ will need to write your own function that finds the magnitude of each number.\
    \  You could do something like:\n<code>", "  $signs = array_map(function ($i)\
    \ {\n    return $i < 0 ? -1 : 1;\n  }, $arr);\n  return array_sum($signs);\n}\n",
  "    $result = 0;\n    foreach ($arr as $val) {\n        if ($val < 0) {\n     \
    \       return null;\n        }\n        $result = $result * abs($val);\n    }\n\
    \    return $result;\n}\n", "  if (!$arr) return false;\n  $signs = array_map(function\
    \ ($v) { return $v < 0 ? -1 : 0; }, $arr);\n  return array_sum($signs) * array_product($signs);\n\
    }\n", "    if (empty($arr)) {\n        return null;\n    }\n\n    $s = array_reduce($arr,\
    \ function ($acc, $num) {\n        if ($num < 0) {\n            return $acc;\n\
    \        }\n\n        if ($num === 0) {\n            return null;\n        }\n\
    \n        return $acc * $num;\n    }, 1);\n\n    return $s;\n}\n\nvar_dump(prod_signs([1,\
    \ -4, 3]));\nvar_dump(prod_signs([0, -1, -2, 0, 2, 0]));\nvar_dump(prod_signs([]));",
  "    if (count($arr) == 0) {\n        return null;\n    }\n    $result = 1;\n  \
    \  foreach ($arr as $val) {\n        $result *= $val;\n        if ($result < 0)\
    \ {\n            return null;\n        }\n    }\n    return $result;\n}", "  //\
    \ Your code here\n  $sum = 0;\n  $res = null;\n  foreach ($arr as $num) {\n  \
    \  $sign = sign($num);\n    if ($sign == 0) $sign = 1;\n    $sum *= $sign;\n \
    \   $res += $sum;\n  }\n  return $res;\n}\n</code>\n<|/ a tags=algorithm,php |>\n\
    <| c |>\nThe solution is right in the question. I don't see why your solution\
    \ should be upvoted.\n<|/ c |>\n<| c |>\nI upvoted it because I like `sign` function.\
    \ It looks really cool and can solve a lot of problems very quickly. And I liked\
    \ your `array_walk` solution too.\n<|/ c |>\n<| a tags=algorithm,php |>\n<code>",
  "  if (empty($arr)) {\n    return null;\n  }\n\n  $sum = 0;\n  foreach ($arr as\
    \ $num) {\n    $sign = array_pop(array_pop(array_pop($arr)));\n    $sum += $sign\
    \ * $num;\n  }\n\n  return $sum;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<|\
    \ a tags=php,algorithm |>\nMy Solution :\n<code>\n$signsArray = [-1, -1, 1, 1,\
    \ -1, -1];\n\n$arrSum = array_sum($signsArray);\n", "  if (empty($arr)) {\n  \
    \  return null;\n  }\n  $signs = array();\n  $prod = 1;\n  foreach ($arr as $i\
    \ => $num) {\n    if ($num < 0) {\n      $signs[$i] = -1;\n      $num *= -1;\n\
    \    } else if ($num > 0) {\n      $signs[$i] = 1;\n    }\n    $prod *= $num;\n\
    \  }\n  return $signs == array_fill(0, count($arr), 1) ? $prod : $signs;\n}\n\
    </code>\n<|/ a tags=php,math,algorithm |>\n<| a tags=php,math,algorithm dscore=1\
    \ |>\nThis code uses recursion to solve this.\n<code>", "    if (empty($arr))\
    \ {\n        return null;\n    }\n\n    $sum = 0;\n    $prod = 1;\n\n    foreach\
    \ ($arr as $val) {\n        $sum += $val * $prod;\n        $prod = $prod * abs($val);\n\
    \    }\n\n    return $sum;\n}\n", "    if (count($arr) == 0) return None;\n  \
    \  $prod = 1;\n    foreach ($arr as $x) {\n        if ($x < 0) $prod *= -1;\n\
    \        $prod *= $x;\n    }\n    return $prod;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nthis doesn't work for `prod_signs([1,-2,3,-4,-5,-6])`, it should be `prod_signs([1,2,-3,4,-5,6])`\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a working python solution:\n<code>\nfrom itertools\
    \ import groupby\nfrom functools import reduce\ndef prod(lst):\n    return reduce(lambda\
    \ x,y: x*y, (sign for _, sign in groupby(lst)))\n\ndef prod_signs(lst):\n    return\
    \ prod([1 if sign > 0 else -1 if sign < 0 else 0 for sign in lst])\n</code>\n\
    <|/ a tags=algorithm,python,c |>\n<| a dscore=1 |>\nYou might be better off using\
    \ generators instead of looping over arrays. Something like:\n<code>\ndef signs(arr):\n\
    \    for x in arr:\n        if x > 0:\n            yield 1\n        elif x < 0:\n\
    \            yield -1\n        else:\n            yield 0\n\ndef prod(arr):\n\
    \    return reduce(lambda x, y: x*y, signs(arr))\n</code>\n<|/ a tags=algorithm,python,c\
    \ |>\n<| c |>\n`signs` is redundant, because you can simply iterate over `arr`,\
    \ without creating a list. You can also get rid of the `reduce` function.\n<|/\
    \ c |>\n<| c |>\nYou can avoid the creation of an intermediate list by using a\
    \ list comprehension `[sign(x) for x in arr]`\n<|/ c |>\n<| c |>\n`signs` creates\
    \ intermediate lists because it doesn't return anything, it only yields values.\n\
    <|/ c |>\n<| c |>\nYes, you're right. My mistake. I've edited my answer to remove\
    \ that redundant line.\n<|/ c |>\n<| a tags=algorithm,python,c |>\nHere is another\
    \ solution using lambda and generator :\n<code>\nimport math\n\ndef prod_signs(lst):\n\
    \    sign = 1\n    for i in lst:\n        sign = sign * math.copysign(1, i)\n\
    \    return sign\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere's my Python\
    \ solution:\n<code>\ndef prod_signs(lst):\n    sign = 0\n    for x in lst:\n \
    \       if x > 0:\n            sign = sign + 1\n        elif x < 0:\n        \
    \    sign = sign ", "    if (!$arr)\n        return null;\n    $s = 1;\n    for\
    \ ($i = 0, $len = count($arr); $i < $len; $i++) {\n        $x = $arr[$i];\n  \
    \      if ($x == 0)\n            continue;\n        $sign = 1;\n        if ($x\
    \ < 0)\n            $sign = -1;\n        if ($x == -1)\n            $sign = -1;\n\
    \        $s = s * $sign;\n    }\n    return $s;\n}\n", "    $s = $p = 0;\n   \
    \ foreach($arr as $x) { $s += abs($x); $p *= $x; }\n    return $s ? -$p * $s :\
    \ $p;\n}\n", "    $prod = array_product($arr);\n    $signs = array_map(function\
    \ ($a) { return $a * $a }, $arr);\n    return array_sum($signs) * $prod;\n}",
  "  if (empty($arr)) {\n    return;\n  }\n\n  $result = 0;\n  foreach ($arr as $elem)\
    \ {\n    $result *= $elem;\n  }\n\n  return $result > 0 ? 1 : 0;\n}\n", "    if\
    \ (empty($arr)) {\n        throw new Exception('empty array');\n    }\n\n    $result\
    \ = 0;\n    foreach ($arr as $val) {\n        $result *= $val;\n        if ($val\
    \ < 0) {\n            $result *= -1;\n        }\n    }\n    return $result;\n\
    }\n", "    $p = 1;\n    foreach($arr as $a) {\n        if($a >= 0) $p *= -1;\n\
    \        $p *= $a;\n    }\n    return $p;\n}\n", "  if (count($arr) == 0)\n  \
    \  return null;\n  $res = 1;\n  for ($i = 0, $n = count($arr); $i < $n; $i++)\
    \ {\n    if ($arr[$i] >= 0)\n      $res += 1 * $arr[$i];\n  }\n  return $res;\n\
    }", "    sort($arr);\n    $sum = 0;\n    foreach ($arr as $el) {\n        if ($el\
    \ < 0) {\n            $sum -= $el;\n        } else {\n            $sum += $el;\n\
    \        }\n    }\n    return $sum;\n}\n", "    $signs = [1, -1];\n    if (count($arr)\
    \ == 0) {\n        return null;\n    }\n    $n = array_shift($arr);\n    return\
    \ count($arr) == 0 ? 0 : $signs[$n * array_search($n, $arr)];\n}\n", "    if (!$arr)\n\
    \        return;\n\n    $product = 1;\n    $signs = [];\n    foreach ($arr as\
    \ $value) {\n        if ($value < 0) {\n            $signs[] = '-';\n        \
    \    $value = -$value;\n        }\n\n        $signs[] = '+';\n        $product\
    \ *= $value;\n    }\n\n    if (empty($signs))\n        return;\n\n    return $product\
    \ == 0\n        ? 0\n        : $product * str_repeat($signs, count($arr));\n}\n\
    \n/**\n * A custom sort compare callback for comparing two numbers.\n *\n * It\
    \ works by applying the \"less than\" inequality to both operands,\n * and returns\
    \ the result of the comparison (-1 or 1, or 0).\n *\n * @see https://php.net/manual/en/function.sort.php\n\
    \ * @param int $a First number\n * @param int $b Second number\n * @return int\
    \ A positive number if $a is less than $b or 0 if not.\n */", "    $signs = array_fill(0,\
    \ count($arr), 0);\n    foreach($arr as $val) {\n        $signs[$val] ^= $val\
    \ < 0 ? -1 : 1;\n    }\n    return $signs;\n}\n\n/**\n * Function that returns\
    \ multiplicative inverse.\n * @param $number number\n * @return number\n * Example:\n\
    \ * >>> inverse(-5)\n * -5\n * >>> inverse(0)\n * 0\n * >>> inverse(1)\n * 1\n\
    \ * >>> inverse(10000)\n * 10001\n */", "    sort($arr);\n    $signs = array_map(function\
    \ ($x) {\n        return $x == 0 ? '0' : ($x < 0 ? '-1' : '1');\n    }, $arr);\n\
    \    return array_reduce($signs, function ($sum, $sign) use ($arr) {\n       \
    \ return $sum * array_reduce($arr, 'pow', $sign);\n    }, 1);\n}\n", "    $result\
    \ = $sign = 1;\n    foreach($arr as $val) {\n        if ($val < 0) {\n       \
    \     $sign = -1;\n            $val = abs($val);\n        }\n        $result =\
    \ $result * $sign * $val;\n        $sign = 1;\n    }\n    return $result;\n}\n",
  "    foreach($arr as $v) {\n        if ($v == 0) {\n            return 0;\n    \
    \    }\n        if ($v < 0) {\n            return -1;\n        }\n    }\n    return\
    \ 1;\n}\n", "  $prod = 1;\n  foreach ($arr as $v) {\n    $prod *= $v > 0 ? 1 :\
    \ -1;\n  }\n  return $prod;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=php |>\n\
    My solution is\n<code>", "  for ($i = 0; $i < count($arr); $i++) {\n    // Sum\
    \ up signs for each integer multiplied by product of signs of ints\n    $signs\
    \ = array_map(function ($val) {\n      return $val > 0 ? 1 : $val < 0 ? -1 : 0;\n\
    \    }, $arr);\n    $signs = array_sum($signs);\n    // Multiply each num * sign\n\
    \    $arr[$i] = array_reduce($arr[$i], [\n      '$init' => 1,\n      '$op'   =\
    \ function ($x, $y) { return $x * $y; },\n      '$callback' => function ($prev,\
    \ $x) { return $prev * $x; }\n    ]);\n  }\n  return array_sum($arr);\n}\n", " \
    \   sort($arr);\n    $res = 0;\n    foreach ($arr as $x) {\n        $res += $x*sign(abs($x));\n\
    \    }\n    return $res == 0 ? None : $res;\n}\n", "  $sum = 0;\n  for ($i = 0;\
    \ $i < count($arr); $i++) {\n    $sign = $arr[$i] < 0 ? 1 : -1;\n    $sum += $sign\
    \ * abs($arr[$i]);\n  }\n  return $sum;\n}\n</code>\nNow, it's time to code the\
    \ function, which will find the product of all signs (which equals product of\
    \ all numbers in the array) multiplied by the product of magnitudes of numbers\
    \ in the array (which equals sum of magnitudes).\n<code>", "    if (empty($arr))\
    \ {\n      return null;\n    }\n    $signs = [];\n    $product = 1;\n    foreach\
    \ ($arr as $value) {\n        if ($value > 0 || $value < 0){\n            $signs[]\
    \ = '1';\n        } else {\n            $signs[] = '-1';\n        }\n        $product\
    \ *= ($value > 0? 1 : -1);\n    }\n    return $product * array_sum($signs);\n\
    }\n", "  if (count($arr) == 0) return None;\n  $max_sign = array_pop($arr);\n\
    \  $signs = [$max_sign];\n  foreach ($arr as $i) {\n    $signs[] = $max_sign *\
    \ ($i < 0 ?- 1 : ($i > 0 ? 1 : 0));\n    $max_sign *= $i < 0 ?- 1 : ($i > 0 ?\
    \ 1 : 0);\n  }\n  return array_sum($signs);\n}\n\n/**\n * This is an implementation\
    \ of knapsack's algorithm\n * http://en.wikipedia.org/wiki/Knapsack_problem\n\
    \ */", "    $ps = array_map(function ($x) { return $x ? '1' : '-1'; }, $arr);\n\
    \    return array_reduce($ps, function ($a, $b) {\n        return $a * $b;\n \
    \   });\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is actually the simplest\
    \ solution I've seen yet and it works on all cases. It even returns the product\
    \ of sums for negative numbers. I wish I could understand it more but this is\
    \ great. Thanks so much for this!\n<|/ c |>\n<| a |>\nI tried to solve this problem\
    \ with recursion. Here is my solution:\n<code>", "    if ($arr == null) return\
    \ null;\n    $prod = 1;\n    foreach ($arr as $val) $prod *= $sign($val);\n  \
    \  return $prod;\n}", "  if (empty($arr)) {\n    return null;\n  }\n\n  $signs\
    \ = array_map(function ($el) {\n    return $el > 0 ? 1 : -1;\n  }, $arr);\n  return\
    \ array_sum($signs);\n}\n", "  if (!$arr) return None;\n  $signs_prod = 1;\n \
    \ foreach ($arr as $num) {\n    $signs_prod *= $num > 0 ? 1 : -1;\n  }\n  return\
    \ $signs_prod;\n}\n", "    $signs = array_fill(0, count($arr), 1);\n    $prod\
    \ = array_reduce($arr, function($carry, $num) {\n        return $num * $carry;\n\
    \    });\n    $prod_signs = array_map(function($v) {\n        if ($v > 0) {\n\
    \            return $v;\n        }\n        return $v * $signs[$v];\n    }, $arr);\n\
    \    return ($prod_signs === array('') ? None : $prod);\n}\n", "  if (count($arr)\
    \ < 1) {\n    return null;\n  }\n  if (count($arr) == 1) {\n    return $arr[0]\
    \ * abs($arr[0]);\n  }\n  $signs = [];\n  $all_signs = 0;\n  foreach ($arr as\
    \ $n) {\n    $sign = abs($n);\n    if ($n > 0) {\n      $signs[] = $sign;\n  \
    \    $all_signs += $sign;\n    } else if ($n < 0) {\n      $signs[] = -$sign;\n\
    \      $all_signs -= $sign;\n    }\n  }\n  return array_reduce($signs, function($a,\
    \ $b) {\n    return $a * $b;\n  }, $all_signs);\n}\n", "  return array_reduce($arr,\
    \ function ($carry, $item) {\n    if ($item != 0) {\n      $sign = intval($item\
    \ / abs($item));\n      return $carry * $sign;\n    }\n    return $carry;\n  },\
    \ 0);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease don't post answers on obviously\
    \ off-topic questions! [See: **Should one advise on off topic questions?**](https://meta.stackoverflow.com/questions/276572/should-one-advise-on-off-topic-questions)\n\
    <|/ c |>\n<| c |>\nI see your point, but I think that this question is not off\
    \ topic. OP has given a problem and shown his attempt (which is not good) and\
    \ also showed a problem he is trying to solve. As I understand, OP wants to find\
    \ a solution to the problem. Nothing wrong with that.\n<|/ c |>\n<| c |>\nYour\
    \ solution is better than mine, indeed. But, it is not the most efficient way\
    \ (O(n)). My solution is O(n). Even though I agree that it is not the best solution,\
    \ it is also O(n). I believe that the other answer is the most efficient (although\
    \ not O(n)). Hence, I will update my answer.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\
    \nclass sumMagnitude {\npublic function sumMagnitude($arr) {\n    $result = 0;\n\
    \    $positive = 0;\n    $negative = 0;\n    foreach ($arr as $val) {\n      \
    \  if($val >= 0)\n            $positive++;\n        else\n            $negative++;\n\
    \    }\n    $positive = $positive*-1;\n    $negative = $negative*-1;\n    foreach\
    \ ($arr as $val) {\n        if($val >= 0) {\n            $result += $val;\n  \
    \      }\n    }\n    $result = $result * $positive + $result * $negative ;\n \
    \   return $result;\n  }\n}\n\n$obj = new sumMagnitude();\n\necho \"<pre>\";\n\
    echo \"Sum of Magnitude of array is \".$obj->sumMagnitude([-1, 0, 1, 2, 0]);\n\
    echo \"Sum of Magnitude of array is \".$obj->sumMagnitude([-1, -2, 0, 0]);\necho\
    \ \"Sum of Magnitude of array is \".$obj->sumMagnitude([-1, 0, 0, 0]);\necho \"\
    Sum of Magnitude of array is \".$obj->sumMagnitude([-1, 1, 2, -3]);\necho \"Sum\
    \ of Magnitude of array is \".$obj->sumMagnitude", "    if (count($arr) == 0)\
    \ return None;\n    $ret = 1;\n    foreach($arr as $elem) {\n        $ret *= (-1)\
    \ ** $elem;\n    }\n    return $ret;\n}\n", "  if (!$arr || !count($arr))\n  \
    \  return null;\n  $res = [];\n  foreach ($arr as $i) {\n    $tmp = 0;\n    for\
    \ ($j = 0; $j < strlen($i); $j++) {\n      $tmp *= $i[$j];\n      $tmp += ($i[$j]\
    \ == '-') ? 1 : -1;\n    }\n    $res[] = $tmp;\n  }\n  return array_sum($res);\n\
    }\n", "    if (empty($arr)) {\n        return null;\n    }\n\n    $res = null;\n\
    \    foreach ($arr as $num) {\n        if ($num > 0) {\n            $res = $num\
    \ * $res;\n        }\n    }\n\n    return $res;\n}\n", "  for ($i = 0; $i < count($arr);\
    \ $i++) {\n    if ($arr[$i] > 0) {\n      return $arr[$i];\n    }\n  }\n  return\
    \ null;\n}\n", "    $result = 0;\n    foreach ($arr as $num) {\n        $result\
    \ *= $num;\n        $result %= 3;\n    }\n    return $result;\n}\n", "  if (empty($arr))\
    \ return null;\n  return array_sum(array_map('abs', $arr)) *\n      array_sum(array_map('abs',\
    \ array_fill(0, count($arr), -1)));\n}\n</code>\n<|/ a tags=php,algorithm |>\n\
    <| c |>\nI knew there would be a mathematical answer to the question but I can't\
    \ for the life of me think it up myself. You are the man. Thanks a ton!\n<|/ c\
    \ |>\n<| c |>\nI realized my mistake, I was looking at it from the wrong angle\
    \ and getting completely blind when I saw it. Thanks again!\n<|/ c |>\n<| c |>\n\
    Just as a heads up, this is wrong. It should be ```return array_sum(array_map('abs',\
    \ $arr)) *\n      array_sum(array_map('abs', array_fill(0, count($arr), -1)));```\n\
    <|/ c |>\n<| c |>\nYes, that's correct. (Sorry for not testing it before submitting\
    \ my comment, just couldn't resist.) I'll edit it into the answer.\n<|/ c |>\n\
    <| a tags=php,algorithm |>\n<code>", "  foreach ($arr as $num) {\n    $sign =\
    \ 1;\n    if ($num < 0) {\n      $sign = -1;\n      $num = abs($num);\n    }\n\
    \    $prod = 1;\n    while ($num !== 0) {\n      $prod*=$num%2;\n      $num/=2;\n\
    \    }\n    $sign *= $prod;\n  }\n  return $sign;\n}\n", "    if (count($arr)\
    \ == 0)\n        return null;\n\n    $signs = array_map(function ($x) {\n    \
    \    return $x !== 0 ? 1 : -1;\n    }, $arr);\n\n    return array_sum($signs);\n\
    }\n\n/**\n * Return sum of magnitudes of integers in the given array.\n *\n *\
    \ Example:\n * >>> sum_of_mag([1, 2, 2, -4]) == 4\n * >>> sum_of_mag([-1]) ==\
    \ 0\n * >>> sum_of_mag([]) == None\n */", "    if (empty($arr)) {\n        return\
    \ null;\n    }\n\n    $sign = 1;\n    $res = 0;\n    foreach ($arr as $value)\
    \ {\n        $sign *= $value;\n        $res += $sign;\n    }\n\n    return $res;\n\
    }\n", "  $prod = 1;\n  foreach ($arr as $val) {\n    $prod *= $val;\n    $prod\
    \ *= $val < 0 ? -1 : 1;\n  }\n  return $prod;\n}\n</code>\nAnd the answer for\
    \ your homework:\n<code>", "    $prod = 1;\n    foreach ($arr as $val) {\n   \
    \     $sign = sgn($val);\n        $prod *= $sign;\n    }\n    return $prod;\n\
    }\n", "    if (empty($arr)) {\n        throw new Exception('Array is empty!');\n\
    \    }\n\n    $res = null;\n    foreach ($arr as $num) {\n        $sign = 1;\n\
    \        if ($num < 0) {\n            $sign = -1;\n        }\n        $res +=\
    \ $sign * log($num, 2);\n    }\n\n    return $res;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere's another approach using array_reduce and array_map\
    \ to build the magnitude of the sign for each element:\n<code>\n$arr = array_map('abs',\
    \ $arr);\n$magnitude = array_reduce($arr, function($carry, $item) {\n  return\
    \ $carry + log($item, 2);\n});\n</code>\n<|/ a tags=php,math |>\n<| a dscore=0\
    \ |>\nA more efficient approach (but this also has the disadvantage of not being\
    \ a pure function) is to do the math in two passes: first get the signs and magnitudes\
    \ in one pass, then do the multiplication the second time.\n<code>", "    if (count($arr)\
    \ == 0) {\n        return null;\n    }\n\n    $signs = array_count_values($arr);\n\
    \    $result = $signs['-'];\n    foreach ($arr as $item) {\n        $result *=\
    \ $signs[$item];\n    }\n    return $result;\n}\n", "    sort($arr);\n    return\
    \ array_reduce($arr, 'array_sum', 1) * prod_signs_recursive($arr);\n}\n", "  if\
    \ (empty($arr)) return None;\n  $signs = array_count_values($arr);\n  $sum = 0;\n\
    \  foreach ($signs as $s => $v)\n    if ($v) $sum += $s * $v;\n  return $sum;\n\
    }", "  $signs = array_map(function ($i) {\n    return $i * intval($i >= 0);\n\
    \  }, $arr);\n  return isset($signs[0]) ? $signs[0] : null;\n}\n</code>\nand you\
    \ have\n<code>\n$arr = [1, 2, 2, -4];\necho prod_signs($arr);\n</code>\n<|/ a\
    \ tags=php,math,arrays |>\n<| c |>\nThanks, you were first :)\n<|/ c |>\n<| a\
    \ dscore=1 tags=php,math,arrays |>\nYou can do like this\n<code>\n<?php\n$arr\
    \ = [1,2,-4,5];\n$signs = array_map(function($a) {\n    return $a * intval($a>=0);\n\
    }, $arr);\necho \"<pre>\";\nprint_r($signs);\necho \"</pre>\";", "    if (empty($arr))\
    \ {\n        echo \"None\\n\";\n    }\n    $result = 0;\n    for ($i = 0; $i <\
    \ count($arr); $i++) {\n        $result += ($arr[$i] * $i) * sign_of_array($arr[$i]);\n\
    \    }\n    return $result;\n}\n", "  if (count($arr) === 0) return None;\n  $result\
    \ = 0;\n  foreach ($arr as $num) {\n    if ($num < 0) $num *= -1;\n    $result\
    \ += $num;\n  }\n  return $result;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nthank\
    \ you for the answer. i was trying to do without loop. i will mark your answer\
    \ as correct if i cant find anything without loop. thank you\n<|/ c |>\n<| a |>\n\
    <code>", "    $res = 0;\n    foreach ($arr as $num) {\n        $res += $num*array_sum(array_map('abs',\
    \ $arr));\n    }\n    if (is_null($res)) return null;\n    return $res;\n}\n",
  "    foreach($arr as $i) {\n        $sign = is_positive($i) ? 1 : -1;\n        foreach\
    \ ($arr as $j) $sign *= is_negative($j) ? 1 : -1;\n        return $sign;\n   \
    \ }\n}\n", "    foreach ($arr as $value) {\n        array_push($signs, $value\
    \ < 0);\n    }\n    $total = 0;\n    foreach ($signs as $sign => $val) {\n   \
    \     $total *= $val * $sign;\n    }\n    return $total;\n}\n</code>\n<|/ a |>\n\
    <| a |>\nA faster solution, also works with negative numbers.\n<code>\n<?php",
  "  $res = [];\n  if (count($arr) == 0)\n    return null;\n  foreach($arr as $a)\
    \ {\n    $sign = 0;\n    $c = 0;\n    foreach(str_split($a) as $c) {\n      $sign\
    \ = $sign * 2 + $c;\n    }\n    $res[] = $sign;\n  }\n  return array_sum($res);\n\
    }\n</code>\n<|/ a dscore=0 tags=php,arrays,multidimensional-array |>\n<| a tags=php,arrays,multidimensional-array\
    \ dscore=0 |>\nHere's a solution using a ternary operator (condition ? true-result\
    \ : false-result) to return the value of the first element of the array if the\
    \ array is not empty. Otherwise, returns null.\n<code>", "  $res = null;\n  foreach\
    \ ($arr as $num) {\n    $sign = pow(-1, $num);\n    if ($res == null) {\n    \
    \  $res = $sign;\n    } else {\n      $res = $res * $sign;\n    }\n  }\n  return\
    \ $res;\n}\n", "    // write your code in PHP7\n    return $arr === null ? None\
    \ : (array_reduce(\n        array_map('abs', $arr), '*', 1),\n    );\n}", "  $signs\
    \ = array_map(function($item) { return $item < 0 ? -1 : 0; }, $arr);\n  return\
    \ array_sum(array_map('abs', $signs));\n}\n", "    if (!is_array($arr)) return\
    \ null;\n    $signs = array_map(function ($a) { return $a<0 ? -1 : +1; }, $arr);\n\
    \    array_walk($arr, function (&$a) { $a *= $signs[$a]; });\n    return array_sum($arr);\n\
    }\n", "  $r = [];\n  foreach ($arr as $e) {\n    if ($e >= 0) {\n      $r[] =\
    \ 1;\n    } else {\n      $r[] = -1;\n    }\n  }\n  return array_sum(array_map(function\
    \ ($x) {\n    return $x * array_reduce($r, function ($a, $b) {\n      return $a\
    \ * $b;\n    });\n  }, $arr));\n}\n", "    // Your code here\n    if (empty($arr))\
    \ {\n        return null;\n    }\n\n    $result = 0;\n    foreach ($arr as $x)\
    \ {\n        $sign = sign($x);\n        if ($sign == -1) {\n            $sign\
    \ *= -1;\n        }\n        $result *= $sign;\n    }\n\n    return $result;\n\
    }\n", "    if (empty($arr)) {\n        return;\n    }\n    $ret = 1;\n    foreach\
    \ ($arr as $value) {\n        if ($value < 0) {\n            $ret *= -1;\n   \
    \     }\n        $ret *= $value;\n    }\n    return $ret;\n}\n</code>\n<|/ a dscore=0\
    \ tags=php,arrays |>\n<| c |>\nThanks for the comment, I've updated my code to\
    \ be the answer I need. I've tried a solution similar to yours however I keep\
    \ getting a syntax error on the function call as it cannot find the function name\
    \ in the script. As far as I can tell, I'm using the same code as I posted?\n\
    <|/ c |>\n<| a dscore=0 |>\nThis solution works perfectly for me:\n<code>", " \
    \   if (!$arr) return None;\n    $prod = 1;\n    foreach ($arr as $val) {\n  \
    \      $prod *= $val;\n        if ($val < 0) return None;\n    }\n    return $prod;\n\
    }\n", "  if (!$arr || !$arr[0]) {\n    return null;\n  }\n  $signs = $prod_signs_arr\
    \ = [];\n  $len = count($arr);\n  foreach ($arr as $v) {\n    if ($v < 0) {\n\
    \      $signs[] = -1;\n    }\n    if ($v > 0) {\n      $signs[] = 1;\n    }\n\
    \    $prod_signs_arr[] = $signs[$len - 1];\n  }\n\n  return array_sum(array_map(function\
    \ ($sign) use ($prod_signs_arr) {\n    return $sign * $prod_signs_arr;\n  }, $signs));\n\
    }\n</code>\n<|/ a tags=python,php |>\n<| a |>\nHere is a solution using a for\
    \ loop and sum() function:\n<code>\ndef prod_signs(array):\n    product_sign =\
    \ 1\n    product_sign_sum = 0\n    for num in array:\n        if num > 0:\n  \
    \          product_sign *= -1\n            product_sign_sum += product_sign\n\
    \        else:\n            product_sign_sum += num\n    return product_sign_sum\n\
    \nprint(prod_signs([1, 2, 2, -4]))\nprint(prod_signs([0, 1]))\nprint(prod_signs([]))\n\
    </code>\nOutput:\n<code>\n-9\n0\nNone\n</code>\n<|/ a dscore=0 tags=python,php\
    \ |>\n<| a |>\nPHP\n<code>", "    if (count($arr) == 0)\n        return null;\n\
    \n    // Store sum of magnitudes of integers\n    $sum_of_mags = array();\n\n\
    \    // Store sum of product of all signs\n    $sum_of_signs = 1;\n\n    // Initialize\
    \ $sum_of_mags to 0\n    foreach ($arr as $x) {\n        $sum_of_mags[] = abs($x);\n\
    \        $sum_of_signs = $x * $sum_of_signs;\n    }\n\n    return $sum_of_signs\
    \ * (array_sum($sum_of_mags));\n}\n</code>\n<|/ a dscore=0 tags=php |>\n<| a tags=php\
    \ |>\nYou can try this simple code.\n<code>\n<?php\n\n$values = [1, 2, 2, -4];\n\
    $sum_of_magnitudes = array_sum(array_map('abs', $values));\n$product = array_reduce($values,\
    \ function($carry, $item) {\n    return $carry * ($item > 0 ? 1 : -1);\n}, 1);\n\
    \necho $sum_of_magnitudes * $product;\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "    $product = 1;\n    foreach ($arr as $num) {\n        $sign\
    \ = is_numeric($num) ? $num < 0 ? '-' : 1 : 0;\n        $product *= $sign;\n \
    \   }\n    return $product;\n}\n", "    if (count($arr) < 1) {\n        return\
    \ null;\n    }\n    $signs = 0;\n    foreach ($arr as $n) {\n        $signs +=\
    \ $n * $n / abs($n);\n    }\n    return $signs;\n}\n", "    if (count($arr) <\
    \ 2) return None;\n    $sign = 1;\n    $sum = 0;\n    foreach ($arr as $val) $sum\
    \ *= $sign;\n    $sign = $sum >= 0 ? '+' : '-';\n    $arr = array_map(function($a)\
    \ use ($sign) { return $sign * $a; }, $arr);\n    array_walk($arr, function(&$a)\
    \ { $a = $sign * $a; });\n    return $arr[0] + ($arr[0] + $arr[1]) * '0';\n}\n\
    </code>\n<|/ a |>\n<| c |>\nGreat solution! I didn't realize you could use `array_sum`\
    \ like this. For my solution, I tried `array_sum($arr)` and it did *not* work\
    \ even though `array_sum` was documented as doing exactly what I wanted. Your\
    \ solution did work. Thanks!\n<|/ c |>\n<| a dscore=0 tags=php,arrays |>\nThis\
    \ is very simple in PHP.\n<code>\n$arr = array(1,2,3,4);\n$prod = array_reduce($arr,function($acc,$item){\n\
    \    return $acc * $item;\n},1);\n</code>\n<|/ a |>\n<| c |>\nThis works but has\
    \ a very high overhead since you are looping through the array three times and\
    \ then multiplying them. `array_reduce` is actually quite slow on large arrays,\
    \ as it goes through them all before returning a result. But this is a good solution\
    \ if you need very high performance, otherwise I like the other solutions better.\n\
    <|/ c |>\n<| c |>\nThanks for the comment. I didn't know about array_reduce being\
    \ slow for large arrays. Can you comment on why my method is \"quite slow\"?\n\
    <|/ c |>\n<| c |>\nYou loop through the array once to calculate the sum, which\
    \ will be much faster than looping through the array three times (in our example).\n\
    <|/ c |>\n<| a dscore=0 |>\nThe first part of the problem is to calculate each\
    \ product, sum them up, and then return the product divided by the sum of the\
    \ squares.\nYou can do all of this with a single loop through each element of\
    \ the array and multiplying the previous value by current value.\n<code>", " \
    \   if (count($arr) == 0) return null;\n    $signs = [];\n    foreach($arr as\
    \ $x) {\n        $sign = 1;\n        if ($x < 0) $sign = -1;\n        $signs[]\
    \ = $sign;\n    }\n    return array_sum($signs) * prod($signs);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nFor me it outputs 3 while the answer should be 8.\
    \ Could you explain why?\n<|/ c |>\n<| c |>\nI added explanation to my answer\n\
    <|/ c |>\n<| a |>\nHere's a solution using recursion:\n<code>\ndef sum_of_magnitudes(arr):\n\
    \    def f(arr):\n        if not arr:\n            return 0\n        s = 0\n \
    \       for i in arr:\n            if i == 1:\n                s = s + i\n   \
    \         else:\n                s = s - i\n        return s + f(arr[1:]) * i\n\
    \    return f(arr)\n\nprint sum_of_magnitudes([1, 2, 2, -4])\n</code>\n<|/ a tags=math,python\
    \ dscore=2 |>\n<| c |>\nCan you please explain this ? what does `f(arr[1:])*i`\
    \ do ?\n<|/ c |>\n<| c |>\nThis is simple recursive function. `f()` calculates\
    \ the sum of all magnitudes from first element to last.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's a pure python solution. Be sure to check out the timings:\n<code>\n\
    def sum_of_magnitudes(arr):\n    if not arr:\n        return 0\n    total = 0\n\
    \    for x in arr:\n        if x == 1:\n            total += x\n        else:\n\
    \            total -= x\n    return total\n\ndef sum_of_magnitudes_recursive(arr):\n\
    \    if not arr:\n        return 0\n    return sum_of_magnitudes_recursive(arr[1:])\
    \ + arr[0]\n", "  foreach($arr as $value) {\n    if ($value == -abs($value)) {\n\
    \      return 0;\n    }\n  }\n  $signs = array();\n  foreach($arr as $value) {\n\
    \    if ($value > 0) {\n      $signs[] = 1;\n    }\n    if ($value < 0) {\n  \
    \    $signs[] = -1;\n    }\n  }\n  return array_sum(array_map(function ($value)\
    \ {\n    if ($value == -1) {\n      return 1;\n    }\n    if ($value == 1) {\n\
    \      return -1;\n    }\n    return $value;\n  }, $signs));\n}\n", "    if (empty($arr))\
    \ {\n        return;\n    }\n\n    $m = $prod = 1;\n    foreach ($arr as $x) {\n\
    \        $m *= sign($x);\n        $prod *= $x;\n    }\n    return $prod * ($m\
    \ < 0 ? -1 : 1) * $m;\n}\n", "    // Check if array is empty\n    if (!$arr) return\
    \ null;\n\n    // Multiply all magnitudes by 1 and -1 for positives and negatives\n\
    \    foreach ($arr as $key => $val)\n        $arr[$key] *= ($val >= 0 ? 1 : -1);\n\
    \n    // Return product of magnitudes\n    return array_sum($arr);\n}\n", "  \
    \  $res = [];\n    foreach($arr as $v)\n        $res[] = $v * ($v > 0);\n    if(count($res)\
    \ == 0)\n        return null;\n    return array_sum($res);\n}\n\n$input = array(1,\
    \ -2, 3, 5, -7, 0);\n$answer = prod_signs($input);\nif($answer == 0)\n    print('None\
    \ of the numbers have signs different from 0.');\nelse\n    print('Sum of magnitudes\
    \ of numbers multiplied by product of all signs of them is', $answer);", "   \
    \ $p = 0;\n    foreach ($arr as $i) {\n        if ($i < 0) $p += ($i * -1); //\
    \ change -1 to 1\n        else $p += $i;\n    }\n    return $p;\n}\n\n$data =\
    \ [1, -1, 2, -3, 3, 0, 4, 5, -6, 5, -4, 3, -2];\n$sum = array_sum(array_map('prod_signs',\
    \ $data));\necho $sum; // output: -25", "  if (empty($arr)) return null;\n  $signs\
    \ = array_map(function($x) {\n    return ($x<0)?-1:1;\n  }, $arr);\n  return array_sum(array_map(function($x)\
    \ {\n    return $x * $signs;\n  }, $arr));\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=php,arrays |>\n<code>\n<?php\n$array = [-1,\
    \ -2, 5, 7, -8, 3, 0];\n$result = 0;\nfor ($i = 0; $i < count($array); $i++) {\n\
    \  $result += $array[$i] * sign($array[$i]);\n}\necho 'Sum of magnitudes: ' .\
    \ $result;\n", "    if (count($arr) == 0) {\n        return null;\n    }\n   \
    \ $magnitude = array_map(function($x) {\n        return abs($x);\n    }, $arr);\n\
    \    $product = array_reduce($magnitude, function($carry, $x) {\n        return\
    \ $carry * ($x < 0);\n    });\n    $signs = array_map(function($x) {\n       \
    \ return $x < 0 ? -1 : 1;\n    }, $arr);\n    return $product * array_sum($signs);\n\
    }", "    if (!count($arr)) return None;\n    $result = 0;\n    foreach ($arr as\
    \ $a) $result *= $a; // Multiply all digits of the array by their signs\n    return\
    \ $result;\n}\n", "    if (empty($arr)) {\n        return null;\n    }\n\n   \
    \ $signs = array();\n    $sign = array();\n\n    foreach ($arr as $num) {\n  \
    \      $sign[] = 1;\n        $sign[] = -1;\n        $sign[] = 0;\n\n        foreach\
    \ ($sign as $i => $sgn) {\n            $signs[$num * $sgn] += $i;\n        }\n\
    \    }\n    return array_sum($signs);\n}\n", "  // write your code in PHP7\n \
    \ $arr = array_map(function($v){ return $v; }, $arr);\n  $signs = array_map(function($v){\
    \ return $v < 0 ? -1 : +1; }, $arr);\n  $prod = array_product($signs);\n  \n \
    \ foreach ($arr as $v) {\n    if ($v < 0)\n      $prod *= -1;\n  }\n  return $prod;\n\
    }\n</cell>\n<cell>", "    $result = 1;\n    foreach ($arr as $n) {\n        $result\
    \ *= (abs($n));\n        if ($n < 0) {\n            $result *= -1;\n        }\n\
    \    }\n    return $result;\n}\n</code>\nTest cases\n<code>\n$tests = [\n    [1,\
    \ 2, 2, -4],\n    [0, 1],\n    []\n];\n\n$results = [\n    [-9, 0],\n    [0],\n\
    \    []\n];\n</code>\nSolution\n<code>\n$sum_of_signs = [];\n$prod_signs = [];\n\
    \nforeach ($tests as $test) {\n    $sum_of_signs[] = prod_signs($test);\n    $prod_signs[]\
    \ = sum_of_signs($test);\n}\n\nvar_dump(array_diff_assoc($sum_of_signs, $prod_signs));\n\
    </code>\nOutput:\n<code>\narray(3) {\n  [1]=>\n  int(-9)\n  [0]=>\n  int(0)\n\
    \  [4]=>\n  int(1)\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,php dscore=0 |>\n\
    The simplest way is to find all the factors of N (a number that is a multiple\
    \ of all the other numbers multiplied by -1). Then, find the product of all factors\
    \ multiplied by -1. The product is multiplied by -1 if all the factors are negative.\
    \ \n<code>\n$n = 4\n$factors = [$n / $i * ($n % $i) == 0 \n    for $i = 2 ...\
    \ $n/2]\n$signs = map($factors, fn($x) { return $x ? 1 : -1; })\n$sign = array_reduce($signs,\
    \ function($prod, $sign) \n    return $prod * $sign == -1 ? $prod * -1 : 0, 1)\n\
    $sign == 0 ? \"0\" : $sign\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer,\
    \ but your function returns `0` for negative numbers.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer. Does it work?\n<|/ c |>\n<| c |>\nThe only problem here is that it\
    \ returns 0 also for `0`.\n<|/ c |>\n<| c |>\nI added the test cases to my answer.\
    \ Can you confirm that they are correct?\n<|/ c |>\n<| a tags=algorithm,php |>\n\
    The other answers didn't take into account that all negative numbers come before\
    \ all positive numbers. Here is a solution that does take this into account.\n\
    <code>", "  $result = 0;\n  foreach ($arr as $n) {\n    $result *= ($n & 1 ? 1\
    \ : -1);\n  }\n  return $result;\n}\n", "    $sum = 0;\n    foreach ($arr as $item)\
    \ {\n        if ($item != 0) {\n            $sum += $item;\n        }\n    }\n\
    \n    if ($sum == 0) {\n        return 0;\n    }\n\n    return $sum;\n}\n", " \
    \ // Write your code here\n  if ($arr !== [] && is_array($arr)) {\n    $n = count($arr);\n\
    \    $result = 0;\n    for($i = 0; $i < $n; $i++) {\n      $result *= $arr[$i];\n\
    \      if ($arr[$i] < 0) {\n        $result += abs($arr[$i]);\n      }\n    }\n\
    \    return $result;\n  } else {\n    return null;\n  }\n}\n", "    // Your code\
    \ here\n    if(empty($arr)) return null;\n\n    $signs = array_sum($arr);\n  \
    \  $product = array_prod($arr);\n    return ($signs == 0) ? 0 : ($signs * $product);\n\
    }\n\nvar_dump(prod_signs([1, 2, 2, -4]));\nvar_dump(prod_signs([0, 1]));\nvar_dump(prod_signs([]));\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThis would work, for small arrays.\
    \ It might not be the most efficient:\n<code>\n<?php\n", "    if (!$arr) {\n \
    \       return null;\n    }\n    $result = 0;\n    foreach ($arr as $num) {\n\
    \        $sign = ($num < 0) ? '-' : '';\n        $num *= $sign;\n        $result\
    \ += $num;\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php,algorithm |>\n\
    <| a tags=php,algorithm dscore=0 |>\nIt took me a while to understand your problem.\
    \ I will try to explain my thoughts so that you can complete the code yourself\
    \ if necessary. \nIn your example, \n<code>\n$input = [-4, -2, 2, 5, -8, -8, 8,\
    \ -1, -3, -5, -3, -7, -8, 3, 7, 4, -7, 5, -8, 5, -3, -7, -5, -8, -7, -4, -3, -4,\
    \ 1, -4, -4, -5, -4, -8, -4, -8, -8, -8, -4, 8, -7, 4, -7, -7, 7, -3, -7, -7,\
    \ -7, -4, -4, -8, -7, -4, 1, -4, -8, -1, -3, -7, -5, -7, -8, 8, -7, 3, -7, -7,\
    \ 7, -4, -4, -7, -5, -7, -5, -7, -7, 4, -3, -7, -8, -8, -4, -4, -8, -7, -4, -3,\
    \ -4, -7, -7, -7, -7, -8, 8, -7, -3, -7, -7, -7, -7, -7, -4, -4, -8, -4, -4, -7,\
    \ 8, -3, -5, -3, -7, -3, -7, -3, -5, -7, -7, -5, -4, -3, -7, -8, -7, -7, -7, -7,\
    \ -7, -3, -7, -5, -5, -4, -5, -7, -3, -7, -3, -5, -7, -4, -7, -8, -4, -7, -7,\
    \ -7, -7, -4, -7, -7, -5, -3, -7, -7, -8, 8, 3, -7, -4, -7, -7, -7, 7, -5, -3,\
    \ -7, -8, -8, -7, -7, -3, -5, -5, -4, -5, -5, -7, -7, -7, -7, -7, -7, -7, -3,\
    \ -7, -8, -4, -7, 8, -7, -7, -3, -7, -8, -7, -7, -3, -5, -4, -3, -7, -5, -7, -3,\
    \ -7, -3, -4, -7, -7, -5, -4, -3, -7, -3, -7, -8, 8, -7, -3, -7, -8, -4, -7, -7,\
    \ -3, -7, -3, -7, -7, -3, -7, ", "    if (empty($arr)) {\n        return None;\n\
    \    }\n\n    $signs = array_fill(0, count($arr), 0);\n    foreach ($arr as $x)\
    \ {\n        for ($i = 0; $i < $x; ++$i) {\n            $signs[$i] += $i ? 1 :\
    \ -1;\n        }\n    }\n\n    return array_sum($signs);\n}\n", "    if (!is_array($arr))\
    \ {\n        throw new InvalidArgumentException(\"Given argument is not an array\"\
    );\n    }\n    $sum = 0;\n    foreach ($arr as $value) {\n        if ($value ==\
    \ 0) {\n            continue;\n        }\n        $sign = sgn($value);\n     \
    \   $product = pow(-1, $sign);\n        $sum += $product * $value;\n    }\n  \
    \  return $sum;\n}\n", "  if (empty($arr)) {\n    return null;\n  }\n  $signs\
    \ = array_map(function ($a) {\n    return $a < 0 ? -1 : 1;\n  }, $arr);\n  $magnitudes\
    \ = array_map(function ($a) {\n    return $a < 0 ? -$a : $a;\n  }, $arr);\n  return\
    \ array_sum($magnitudes) * array_prod($signs);\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nHere's a more scalable version, which allows the user to provide an initial\
    \ array of any size and sums the product of all signs of its elements:\n<code>",
  "    if (empty($arr)) {\n        return null;\n    }\n    $res = [];\n    $signs\
    \ = [];\n    $sign = 0;\n    foreach ($arr as $e) {\n        $sign = 0;\n    \
    \    if ($e > 0) {\n            $sign = 1;\n        }\n        array_push($signs,\
    \ $sign);\n        $res = $res * $e;\n    }\n    return $res;\n}\n</code>\n<|/\
    \ a tags=php |>\n<| a dscore=2 |>\n<code>", "    foreach ($arr as $el) {\n   \
    \     $ret = intval($el * $el);\n        if ($ret < 0) {\n            return 0;\n\
    \        } else if ($ret > 0) {\n            return 1;\n        }\n    }\n}\n",
  "    if(count($arr) == 0) {\n        return null;\n    }\n    $result = 1;\n   \
    \ foreach($arr as $item) {\n        $result *= $item;\n    }\n    if($result <\
    \ 0) {\n        $result = 0;\n    }\n    return $result;\n}\n", "  if (empty($arr))\n\
    \    return null;\n  $prod = 0;\n  foreach ($arr as $val) {\n    $prod *= $val;\n\
    \    $prod += $val < 0 ? -1 : 1;\n  }\n  return $prod;\n}\n", "  for ($n = count($arr);\
    \ $n >= 0; --$n) {\n    if ($arr[$n] < 0) return None;\n    $product *= $arr[$n];\n\
    \  }\n  return $product;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks David. Your solution\
    \ gives me the exact result which I need. Can you please also tell me what are\
    \ the things that are causing the error in my code?\n<|/ c |>\n<| a |>\nThis code\
    \ will work fine:\n<code>", "  if (count($arr) === 0) {\n    return None;\n  }\n\
    \n  $result = 0;\n\n  foreach ($arr as $num) {\n    $sign = $num > 0 ? '1' : '-1';\n\
    \    if ($sign === $arr[0]) {\n      $result = $num;\n    } else {\n      $result\
    \ *= $sign;\n    }\n  }\n\n  return $result;\n}", "  $signs = array_map('intval',\
    \ array_fill(0, count($arr), -1));\n  $signs = array_map(function ($v, $i) use\
    \ ($signs) {\n    return $v * $signs[$i];\n  }, $arr, $signs);\n  return array_reduce($signs,\
    \ function ($carry, $v) {\n    return $carry + ($v < 0 ? -v : v);\n  });\n}\n",
  "  $prod = 1;\n  foreach ($arr as $v) $prod *= $v;\n  if ($prod > 0) return $prod;\n\
    \  else if ($prod < 0) return -$prod;\n  else return 0;\n}\n", "    if (empty($arr))\
    \ return None;\n    $prod = array_product($arr);\n    $signs = array_count_values($arr);\n\
    \    return $prod * array_sum($signs);\n}\n", "  $signs = array_map(function ($x)\
    \ {\n    return $x <=> 0;\n  }, $arr);\n  $sum = array_sum($signs);\n  if (!$sum)\
    \ {\n    return None;\n  }\n  return $sum * array_reduce($signs, function ($acc,\
    \ $x) {\n    return $acc * $x;\n  }, 1);\n}\n", "  $signs = array();\n  foreach\
    \ ($arr as $x) {\n    if ($x > 0) {\n      $signs[] = 1;\n    } else {\n     \
    \ $signs[] = -1;\n    }\n  }\n  return $signs * array_sum(array_map(function($x)\
    \ { return $x * $x; }, $arr));\n}\n</code>\n<|/ a dscore=1 tags=arrays,php,algorithm\
    \ |>\n<| a |>\nIf your array is sorted (ascending), then you can do a binary search\
    \ to find the first non-negative number. For every non-negative number, you can\
    \ do a binary search to find the first negative. Then use that value to subtract\
    \ the negative part from the non-negative number. After that you only need to\
    \ get the product of the positive numbers and the negative numbers.\n<|/ a tags=arrays,php,algorithm\
    \ dscore=0 |>\n<| a |>\n<code>\n<?php\n$n = [1,2,3,4,5];\n$n2 = [-1,-2,-3,-4,-5];\n\
    $n3 = [-10,-20,-30,-40,-50];\n$n4 = [-100,-200,-300,-400,-500];\n", "    if (empty($arr))\
    \ {\n        return null;\n    }\n\n    $result = 0;\n    foreach ($arr as $v)\
    \ {\n        $result *= $v;\n        if ($v > 0) {\n            $result *= -1;\n\
    \        }\n    }\n    return $result;\n}\n", "  // Write your implementation\
    \ here\n}", "  if (empty($arr)) {\n    return null;\n  }\n  $res = 0;\n  foreach\
    \ ($arr as $v) {\n    $res += abs($v) * $v < 0 ? 1 : 0;\n  }\n  return $res;\n\
    }\n\n/**\n * Given a number represented by a string consisting of digits ranging\n\
    \ * from 0 to 9 inclusive, return an array of all possible permutations.\n *\n\
    \ * Input: \"123\"\n * Output: [\"132\", \"213\", \"231\", \"312\", \"321\", \"\
    132\", \"213\", \"231\", \"312\", \"321\"]\n *\n * Input: \"123456789\"\n * Output:\
    \ [\"123456789\", \"987654321\", \"765432109\", \"543210987\", \"432109876\",\
    \ \"321098765\", \"213210987\", \"132109876\", \"143210987\", \"432159837\", \"\
    543215983\", \"765432159\", \"987654320\", \"765432108\", \"543210897\", \"432108976\"\
    , \"321089746\", \"213210897\", \"132108976\", \"143210897\", \"432159876\", \"\
    543215987\", \"7654321587\", \"987654315\", \"765431598\", \"543159788\", \"432159877\"\
    , \"543215977\", \"765432157\", \"987654315\", \"765431598\", \"543159788\", \"\
    432159877\", \"543215977\", \"765432157\", \"987654315\", \"765431598\", \"543159788\"\
    , \"432159877\", \"543215977\"]\n *\n * Time complexity: O(n x n)\n * Space complexity:\
    \ O(n x n)\n *\n * @param string $str\n *\n * @return string[]\n */", "    if\
    \ (empty($arr)) return null;\n    $sum = array_sum($arr);\n    $signs = array_map(function\
    \ ($x) {\n        return ($x * $x) > 0 ? 1 : -1;\n    }, $arr);\n    $product\
    \ = $sum * array_sum($signs);\n    return $product;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI believe this solution doesn't work because `array_sum` isn't\
    \ commutative.  Try this input `[3, 2, -1]` and you'll get the result `4` instead\
    \ of `-2`.\n<|/ c |>\n<| a tags=algorithm,php |>\n<code>\n<?php ", "    if ($arr\
    \ == []) return None;\n    $signs = [];\n    $product = 1;\n    for ($i = 0; $i\
    \ < count($arr); $i++) {\n        $sign = $arr[$i] >= 0 ? 1 : -1;\n        $signs[$i]\
    \ = $sign;\n        $product *= $sign;\n    }\n    return $product;\n}\n", " \
    \   $signs = array();\n    foreach ($arr as $value) {\n        if ($value < 0)\
    \ {\n            foreach ($signs as &$sign) {\n                $sign *= -1;\n\
    \            }\n            $signs[] = 1;\n        } else {\n            foreach\
    \ ($signs as &$sign) {\n                $sign *= 1;\n            }\n        }\n\
    \    }\n    return array_sum($signs);\n}\n", "    if(empty($arr)) {\n        return\
    \ null;\n    }\n\n    $sign = 1;\n    foreach($arr as $x) {\n        $sign *=\
    \ $x;\n    }\n    return $sign;\n}\n</code>\n<|/ a dscore=1 tags=python-3.x,python\
    \ |>\n<| c |>\nI guess this is really helpful. Thank you!\n<|/ c |>\n<| c |>\n\
    What happens if, say, `[-9, -7, -4]` were given as input?\n<|/ c |>\n<| c |>\n\
    I believe a `None` would return `None` because that is what the OP wants it to\
    \ do if they give an empty array. But I could be wrong. Either way, the OP seems\
    \ to want the sum of all the numbers in the array.\n<|/ c |>\n<| c |>\nThat's\
    \ what I was thinking as well. But the OP says \"sum of magnitudes of integers\"\
    . I guess it depends on what the OP means by magnitude.\n<|/ c |>\n<| c |>\nI\
    \ agree with what you're saying. I guess my interpretation was that they meant\
    \ what they wrote in the question title. I'll think about what it would mean for\
    \ an input like that.\n<|/ c |>\n<| a dscore=1 |>\nSince you tagged your question\
    \ Python3, a nice and fast solution is to use the new function sum with a generator\
    \ expression:\n<code>\n>>> def prod_signs(a):\n...     return sum(x*1 for x in\
    \ a)\n... \n>>> prod_signs([-9, -7, -4])\n-9\n>>> prod_signs([0, 1, 2, 3])\n0\n\
    >>> prod_signs([])\nTraceback (most recent call last):\n  File \"<stdin>\", line\
    \ 1, in <module>\n  File \"<stdin>\", line 2, in prod_signs\nValueError: zero\
    \ length field name in format\n</code>\n<|/ a tags=python-3.x,python |>\n<| c\
    \ |>\nThis has good explanation of what that function does (though I guess I didn't\
    \ understand it correctly), thanks!\n<|/ c |>\n<| a |>\nHere's a one-liner that\
    \ uses list comprehension and sum:\n<code>\nprint sum([x*y for x,y in zip(map(int,\
    \ list(str(int(raw_input())))[:-1]), map(int, list(str(int(raw_input())))[-1]))])\
    \ if raw_input().strip() else 0\n</code>\n<|/ a tags=python-3.x,python dscore=1\
    \ |>\n<| c |>\nThank you, but this only prints something if I enter `2` instead\
    \ of `-4`, as `print` returns `None` by default, which is not what I want. But\
    \ it may be helpful for someone else who's looking ", "    $sum_signs = 0;\n \
    \   foreach ($arr as $i => $val) {\n        $signs = $arr[$i];\n        if ($val\
    \ < 0) {\n            $signs = -$signs;\n        }\n        $sum_signs += $signs\
    \ * log($val, 2);\n    }\n    if ($sum_signs == 0) {\n        return 0;\n    }\n\
    \    return $sum_signs;\n}\n", "    if (count($arr) == 0)\n        return null;\n\
    \    $sum = 0;\n    foreach ($arr as $value) {\n        if ($value == 0) {\n \
    \           return null;\n        }\n        $sign = $value < 0 ? -1 : 1;\n  \
    \      $sum *= $sign;\n        $sum += $value;\n    }\n    return $sum;\n}\n",
  "  foreach ($arr as $elem) {\n    if ($elem < 0) {\n      return None;\n    }\n\
    \  }\n\n  $prod = 1;\n  foreach ($arr as $elem) {\n    $prod = $prod * $elem;\n\
    \  }\n\n  return abs($prod);\n}\n</code>\n<|/ a |>\n<| a tags=python |>\nThe code\
    \ below does what you have asked for. I don't see how this can be more optimized\
    \ but here it is:\n<code>\ndef sum(arr):\n  sum = 0\n  for i in range(len(arr)):\n\
    \    sign = arr[i] % 10\n    arr[i] /= 10\n    sum += sign * i\n  return sum\n\
    \nprint(sum([-1,-4,-2,-5,-6,-7,-1,-8]))\n</code>\n<|/ a dscore=1 |>\n<| a tags=python\
    \ |>\n<code>\ndef sumOfMagnitudes(num):\n    sum=0\n    for i in range(len(num)):\n\
    \        if (num[i]>0):\n            sum+=num[i]\n    return sum\n\ndef productOfSigns(num):\n\
    \    product=1\n    for i in range(len(num)):\n        if (num[i]<0):\n      \
    \      product=product*(-1)\n    return product\n\nprint(sumOfMagnitudes([-1,\
    \ -4, -2, -5, -6, -7, -1, -8]))\nprint(productOfSigns([-1, -4, -2, -5, -6, -7,\
    \ -1, -8]))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nAnother solution using map:\n\
    <code>\ndef product(array):\n    return sum(map(lambda x: x*(-1)**(array.count(x)>1),\
    \ array))\n</code>\n<|/ a dscore=1 tags=python |>\n<| c |>\nWhy use `map` when\
    \ you can just use `sum` ?\n<|/ c |>\n<| c |>\nHe was using the `map` function\
    \ to perform `sum`.\n<|/ c |>\n<| a tags=python dscore=1 |>\nThe code below works,\
    \ but I think it is a little bit slow. Hope it helps.\n<code>\ndef sum_of_magnitudes(arr):\n\
    \    sum = 0\n    for i in range(len(arr)):\n        if (arr[i]>0):\n        \
    \    sum += arr[i]\n    return sum\n\ndef product_of_signs(arr):\n    product\
    \ = 1\n    for i in range(len(arr)):\n        if (arr[i]<0):\n            product\
    \ *= (-1)\n    return product\n\ndef sum_of_magnitudes_optimized(arr):\n    sum\
    \ = 0\n    for i in range(len(arr)):\n        sign = arr[i] % 10\n        arr[i]\
    \ /= 10\n        sum += sign * i\n    return sum\n\ndef product_of_signs_optimized(arr):\n\
    \    product = 1\n", "    if (empty($arr)) {\n        return None;\n    }\n\n\
    \    $res = 0; // accumulator\n    foreach ($arr as $num) {\n        if ($num\
    \ < 0) {\n            $num *= -1;\n        }\n        $res += $num;\n    }\n\n\
    \    return $res;\n}\n", "    $sum = 0;\n    $sign = 1;\n\n    foreach ($arr as\
    \ $a) {\n        if ($a < 0) {\n            $sign = -1 * $sign;\n        } else\
    \ if ($a > 0) {\n            $sum += $sign * a;\n        }\n    }\n\n    return\
    \ $sum;\n}\n</code>\n<|/ a tags=function,arrays,algorithm,php |>\n<| a tags=function,arrays,algorithm,php\
    \ dscore=1 |>\n<code>", "    foreach($arr as $k=>$v) {\n        if ($v==0) return\
    \ None;\n        $ret = 0;\n        foreach($arr as $kk=>$vv) {\n            if\
    \ ($k==$kk) continue;\n            $ret += sign($v)*sign($vv);\n        }\n  \
    \      return $ret;\n    }\n}\n</code>\nTest\n<code>\n$arr = [0, -4, 1, 3, -2,\
    \ -4, -4];\nvar_dump(prod_signs($arr));\n</code>\nOutput:\n<code>\nint(-2)\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's a O(n log n) solution using PHP's\
    \ usort() function:\n<code>\n<?php\n", "    $sum = 0;\n    $sign = 1;\n\n    foreach\
    \ ($arr as $item) {\n        $sum += $sign * abs($item);\n        $sign *= -1;\n\
    \    }\n\n    return $sum;\n}\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\n\
    Here is my solution in Python.\n<code>\ndef prod_signs(arr):\n    sign = 1\n \
    \   sum = 0\n    for i in arr:\n        sum += sign * abs(i)\n        sign *=\
    \ -1\n    return sum\n\nprint(prod_signs([-5, -4, -3, 2, 2]))\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a |>\n<code>\n<?php\n$arr = [-5, -4, -3, -2, -2];\n$sign = -1;\n\
    $sum = 0;\nforeach ($arr as $value) {\n  $sum += $sign * abs($value);\n  $sign\
    \ *= -1;\n}\necho $sum;\n</code>\n<|/ a tags=php dscore=0 |>\n<| c |>\nWhat is\
    \ the purpose of multiplying $sign by -1? Isn't it the same as multiplying it\
    \ by 1?\n<|/ c |>\n<| c |>\nit multiplies $sign by -1 before it does the sum because\
    \ it's negative.\n<|/ c |>\n<| c |>\nYou don't need $sign *= -1; - it is already\
    \ being multiplied by 1 by default.\n<|/ c |>\n<| a tags=php |>\n<code>\n$arr\
    \ = [-5, -4, -3, -2, -2];\n$sum = 0;\n$sign = 1;\n\nforeach($arr as $val) {\n\
    \    $sum += $sign*abs($val);\n    $sign *= -1;\n}\n\necho $sum;\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nWhat is the purpose of multiplying $sign by -1? Isn't\
    \ it the same as multiplying it by 1?\n<|/ c |>\n<| c |>\nI wanted the opposite,\
    \ multiply by 1, but the negative sign is still there. IMO I like this solution\
    \ better than all the others because it is more explicit and therefore easier\
    \ to maintain.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$arr = [-5, -4, -3, -2, -2];\n\
    $sign = 1;\n$sum = 0;\nforeach ($arr as $value) {\n    $sum += $sign * abs($value);\n\
    \    $sign *= -1;\n}\necho $sum;\n</code>\n<|/ a tags=php |>\n<| c |>\nPlease\
    \ explain your answer, why you chose this solution and what it does.\n<|/ c |>",
  "  $res = [];\n  foreach($arr as $val) {\n    $sign = sign($val);\n    if (!isset($res[$sign]))\
    \ {\n      $res[$sign] = 0;\n    }\n    $res[$sign] += $val * $sign;\n  }\n  return\
    \ $res;\n}\n", "    foreach ($arr as $value) {\n        $sign = 1;\n        if\
    \ ($value < 0) {\n            $sign = -1;\n        }\n        $tmp[$sign]++;\n\
    \    }\n    if (count($tmp) == 1) {\n        return array_keys($tmp)[0];\n   \
    \ }\n    if (count($tmp) == 0) {\n        return null;\n    }\n    $result = 0;\n\
    \    foreach ($tmp as $val) {\n        if ($val != 0) {\n            $result *=\
    \ $val;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    +1 for an interesting solution and also thank you for showing that `isset()` can\
    \ be used with a variable and not just `if` statements.\n<|/ c |>\n<| c |>\nThanks\
    \ again! `isset()` is definitely a nice touch and very useful. I'm still new to\
    \ PHP and thought I needed it for the solution and I hadn't seen it used that\
    \ way before. Thanks again!\n<|/ c |>\n<| a tags=if-statement,php |>\n<code>",
  "  // Write your code here\n  for($i=0;$i<count($arr);$i++){\n    if($arr[$i]<0){\n\
    \      $arr[$i]*=-1;\n    }\n  }\n  return $arr[0]*$arr[1]*$arr[2]*$arr[3];\n}",
  "  for ($i = count($arr) - 1; $i >= 0; $i--) {\n    if ($arr[$i] > 0) {\n      return\
    \ $arr[$i];\n    } else if ($arr[$i] < 0) {\n      return -$arr[$i];\n    }\n\
    \  }\n  return null;\n}\n", "    if (empty($arr)) {\n        return;\n    }\n\n\
    \    $signs = array();\n    foreach ($arr as $value) {\n        if ($value > 0)\
    \ {\n            $signs[] = 1;\n        } else if ($value < 0) {\n           \
    \ $signs[] = -1;\n        } else {\n            $signs[] = 0;\n        }\n   \
    \ }\n\n    $signs = array_sum($signs);\n    return $signs * array_product($signs);\n\
    }\n</code>\n<|/ a tags=php,algorithm,math,loops |>\n<| c |>\nNice approach ! I\
    \ love that array sum trick to get the final result :)\n<|/ c |>\n<| c |>\nYeah,\
    \ I love using array_sum and array_product :) It works well when working with\
    \ arrays like that, but I haven't seen anyone else use it before, so thanks for\
    \ sharing\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  $sign = 1;\n  $sum = 0;\n \
    \ $len = count($arr);\n  for ($i = 0; $i < $len; $i++) {\n    $sign *= ($arr[$i]\
    \ > 0);\n    $sum += $arr[$i] * $sign;\n  }\n  return $sum;\n}\n", "    // Write\
    \ your code here.\n    if (count($arr) === 0) {\n        return null;\n    }\n\
    \    $sum = array_sum($arr);\n    $prod = array_product($arr);\n    return $sum\
    \ * $prod > 0 ? $sum * $prod : null;\n}\n", "  foreach ($arr as $a) {\n    $s\
    \ = $a * $a;\n    if ($s > 0) {\n      return $s;\n    }\n  }\n  return null;\n\
    }", "  $product = 1;\n  foreach ($arr as $x) {\n    $product *= ($x == $x ? 1\
    \ : -1);\n  }\n  return $product;\n}", "    $sum = 0;\n    $sign = -1;\n    foreach\
    \ ($arr as $val) {\n        $sign *= ($val < 0 ? -1 : 1);\n        $sum += abs($val);\n\
    \    }\n    return $sign < 0 ? $sum : $sum * -1;\n}\n", "    if (empty($arr))\
    \ {\n        return null;\n    }\n    $ret = 0;\n    foreach ($arr as $x) {\n\
    \        $ret += $x * $x;\n    }\n    return $ret;\n}\n</code>\nFor a small array\
    \ it's more efficient than using a recursive function, since it avoids doing any\
    \ extra work if there are more elements.  \nHowever, if the array is large (say,\
    \ 100 or more elements), then this recursive function is much faster (it takes\
    \ less than a second) than an iterative function (it takes less than a minute\
    \ on my machine).  So I would suggest sticking with the recursive function.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is recursive solution that should work\
    \ for you:\n<code>", "    foreach($arr as $v)\n        $prod = $prod * $v;\n \
    \   return $prod;\n}\n", "  $result = 0;\n  foreach ($arr as $i) {\n    $result\
    \ += (1 << ($i & 15));\n  }\n  return $result;\n}\n", "  $sum = 0;\n  foreach\
    \ ($arr as $value) {\n    $sign = $value > 0 ? 1 : -1;\n    $sum += $sign * abs($value);\n\
    \  }\n  return $sum;\n}\n", "    if (count($arr) == 0) return null;\n    $sum\
    \ = 1;\n    foreach ($arr as $el) {\n        $sign = ($el < 0) ? '-' : '';\n \
    \       $sign = ($el > 0) ? '+' : '';\n        $sign = ($el != 0) ? '0' : '';\n\
    \        $sum += $sign;\n    }\n    return $sum;\n}\n", "    // Your code here\n\
    \    $result = 0;\n    foreach ($arr as $num) {\n        $result *= $num;\n  \
    \      if ($num < 0) {\n            $result *= -1;\n        }\n    }\n    return\
    \ $result;\n}\n", "    if (empty($arr)) return null;\n    $result = 0;\n    foreach\
    \ ($arr as $val) $result *= ($val >= 0 ? 1 : -1);\n    return $result;\n}\n",
  "    $signs = array_map(function ($item) { return $item < 0 ? -1 : 1; }, $arr);\n\
    \    return $signs * array_sum($signs);\n}\n", "    if (empty($arr)) {\n     \
    \   return None;\n    }\n    $sign = 1;\n    foreach ($arr as $n) {\n        $sign\
    \ *= ($n % 3 ? -1 : 1) * $n;\n    }\n    return $sign;\n}\n", "    // Your code\
    \ here\n    $product = 1;\n    $result = [];\n    foreach ($arr as $num) {\n \
    \       foreach ($result as $sign => $value){\n            $product *= $value;\n\
    \        }\n        if($num<0){\n            $product *= -1;\n        }\n    \
    \    $result[$sign] = $product;\n        $product = 1;\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,math,arrays,function |>\nYou could\
    \ do it with a foreach loop. After you loop through the array you can check if\
    \ the number is negative or not and if it isn't, add to the total variable. \n\
    If the number is positive you can just multiply it with the product of the other\
    \ numbers in the array\n<code>\n<?php\n$arr = [1, 2, 2, -4];\n$total = 0;\nforeach($arr\
    \ as $number){\n    if($number < 0){\n        $total *= -1;\n    } else {\n  \
    \      $total *= $number;\n    }\n}\necho \"Sum of magnitudes of numbers in array:\
    \ \".$total;", "  if (count($arr) == 0) return None;\n  $signs = 0;\n  $prod =\
    \ 1;\n  foreach ($arr as $x) {\n    $signs = $x * $signs;\n    $prod = $x * $prod;\n\
    \  }\n  return $signs * $prod;\n}\n", "  return array_reduce($arr, function ($carry,\
    \ $i) {\n    return $carry + abs($i);\n  }, 0);\n}\n", "  if (count($arr) == 0)\
    \ return None;\n  $sum = 0;\n  $signs = [1, 1, -1, 1];\n  $max = 0;\n  foreach\
    \ ($arr as $v) $sum += $v * $signs[$v];\n  if ($sum > $max) $signs = array_reverse($signs);\n\
    \  foreach ($arr as $v) $signs[$v] *= -1;\n  $prod = 1;\n  foreach ($signs as\
    \ $v) $prod *= $v;\n  return $sum;\n}\n", "  $sign = 1;\n  foreach($arr as $elem)\
    \ {\n    $sign *= $elem * $sign;\n  }\n  return $sign;\n}\n", "    $res = 0;\n\
    \    foreach ($arr as $num) {\n        $res += $num > 0 ? 1 : -1;\n    }\n   \
    \ return $res;\n}\n", "    if (count($arr) == 0) {\n        return null;\n   \
    \ }\n    $sign = -1;\n    $product = 1;\n    foreach ($arr as $number) {\n   \
    \     $product *= $number;\n        if ($product < 0) {\n            $sign = -$sign;\n\
    \            $product *= -1;\n        }\n    }\n    return $sign * $product;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\ni like it but i can't use array\n<|/ c\
    \ |>\n<| c |>\nYou mean you can't use functions like `array_sum` and `array_product`?\n\
    <|/ c |>\n<| c |>\n: See my updated answer. I've written my own `array_product()`\
    \ and used it to calculate the product.\n<|/ c |>\n<| c |>\nok i understand but\
    \ i must use array_sum and array_product in function\n<|/ c |>\n<| c |>\n: That's\
    \ not what your question says. You say that you are given a function `prod_signs`\
    \ which given an array `[1,2,2,-4]` returns `-9` and the `prod_signs` function\
    \ does not use `array_sum` and `array_product`. Please make up your mind. If you\
    \ want people to help you, you need to put some effort into explaining what you\
    \ are asking.\n<|/ c |>\n<| a tags=php |>\nTry this :\n<code>\n$array1 = array(1,2,2,-4);\n\
    $array2 = array(2,3);\n$product = 0;\nforeach($array1 as $value) {\n    $product\
    \ += ($value * $array2[$array2[]]);\n}\necho $product;\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWhat if `$array2` is empty? Then `$array2[$array2[]]` would be\
    \ out of bounds.\n<|/ c |>\n<| c |>\nYep, you are right, thank you for pointing\
    \ that out. I'll just edit the answer\n<|/ c |>\n<| a dscore=0 |>\nYou can do\
    \ it by using array_sum() & array_product():\n<code>", "    $signs = array_count_values($arr);\n\
    \    $result = 0;\n    foreach ($signs as $sign => $count) {\n        $result\
    \ += (2 * $sign * $count);\n    }\n    return $result;\n}\n$arr1 = $arr2 = $arr3\
    \ = $arr4;\n$arr1[] = 4;\n$arr1[] = 4;\n$arr1[] = 4;\n$arr1[] = 0;\n$arr1[] =\
    \ 2;\n$arr1[] = 2;\n$arr1[] = 0;\n$arr2[] = 4;\n$arr2[] = 2;\n$arr2[] = 2;\n$arr2[]\
    \ = 0;\n$arr3[] = 4;\n$arr3[] = 4;\n$arr3[] = 0;\n$arr3[] = 0;\n$arr3[] = 0;\n\
    $arr4[] = 4;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[]\
    \ = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n\
    $arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[]\
    \ = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n\
    $arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[]\
    \ = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n\
    $arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[]\
    \ = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n\
    $arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[]\
    \ = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n\
    $arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;\n$arr4[] = 0;", "    $res\
    \ = null;\n    if (count($arr) == 0) {\n        return $res;\n    }\n\n    $signs\
    \ = [];\n    $i = 0;\n    $sign = $arr[$i] <= 0 ? '-' : $arr[$i] >= 0 ? '+' :\
    \ $arr[$i];\n\n    while (++$i < count($arr)) {\n        if ($sign != $arr[$i])\
    \ {\n            $signs[] = $sign;\n            $sign = $arr[$i] <= 0 ? '-' :\
    \ $arr[$i] >= 0 ? '+' : $arr[$i];\n        }\n    }\n    if ($sign) {\n      \
    \  $signs[] = $sign;\n    }\n    $res = array_sum($signs);\n    foreach ($signs\
    \ as $sign) {\n        $res *= $sign;\n    }\n    return $res;\n}\n", "  $sum\
    \ = 0;\n  foreach ($arr as $value) {\n    if ($value > 0) {\n      $sum += $value\
    \ * 1;\n    } else {\n      $sum += $value * -1;\n    }\n  }\n  return $sum;\n\
    }\n", "    $prod = 1;\n    $signs = [1, -1];\n    foreach ($arr as $item) {\n\
    \        $prod *= $item;\n        $signs *= $signs[$item < 0 ? 1 : -1];\n    }\n\
    \    return $prod if $prod;\n}\n", "  if (!$arr) {\n    return null;\n  }\n  $signs\
    \ = array();\n  foreach ($arr as $val) {\n    if ($val < 0) {\n      $signs[]\
    \ = -1;\n    }\n    if ($val > 0) {\n      $signs[] = 1;\n    }\n  }\n  $result\
    \ = 1;\n  foreach ($signs as $sign) {\n    $result *= abs($sign);\n  }\n  return\
    \ $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis fails for [1, 1, -1,\
    \ 1]\n<|/ c |>\n<| c |>\nI updated my answer with `prod_signs`. Did you try it?\n\
    <|/ c |>\n<| c |>\nI did - it fails for [-1,1,-3,-5]. I suspect this has to do\
    \ with how PHP treats negative integers. Your answer works just fine in Python\
    \ (where I've tested it). http://ideone.com/kO1Qyz\n<|/ c |>\n<| c |>\nI added\
    \ my answer. Could you please check it?\n<|/ c |>\n<| a |>\n<code>", "    if (count($arr)\
    \ < 1)\n        return null;\n    $sum = 0;\n    for ($i = 0, $len = count($arr);\
    \ $i < $len; $i++) {\n        $sign = $arr[$i];\n        if ($sign >= 0)\n   \
    \         $sum += $sign;\n        else\n            $sum -= $sign;\n    }\n  \
    \  return $sum;\n}\n", "    $result = 1;\n    $sign = 1;\n\n    foreach ($arr\
    \ as $num) {\n        if ($sign * $num < 0) {\n            $sign = -$sign;\n \
    \       } else {\n            $sign = 1;\n        }\n\n        $result *= $sign\
    \ * abs($num);\n    }\n\n    return $result;\n}\n", "    $result = 0;\n    foreach\
    \ ($arr as $x) {\n        $result += abs($x);\n    }\n    return $result;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nthis answer helped me to improve a lot of my code.\
    \ thanks!\n<|/ c |>\n<| c |>\nThanks so much. Your answers really helped!\n<|/\
    \ c |>\n<| a tags=php |>\nHere is my solution:\n<code>\n<?php\n", "    $result\
    \ = 0;\n    for ($i = 0; $i < count($arr); $i++) {\n        $result *= $arr[$i];\n\
    \        if ($arr[$i] < 0) {\n            $result = -$result;\n        }\n   \
    \ }\n    return $result;\n}\n", "  if (!$arr) {\n    return null;\n  }\n  $signs\
    \ = array_reduce($arr, function ($carry, $num) {\n    return $carry + ($num <\
    \ 0 ? 1 : -1);\n  }, 0);\n  $result = $signs * array_reduce($arr, function ($carry,\
    \ $num) {\n    return $carry * $num;\n  }, 1);\n  return $result;\n}\n\n$result\
    \ = [];\n$length = 20;\nfor ($i = 0; $i < $length; $i++) {\n  $arr = [];\n  for\
    \ ($j = 0; $j < $length; $j++) {\n    if ($i == $j || rand() % 3 == 0 || rand()\
    \ % 5 == 0) {\n      $arr[] = rand(0, $length);\n    }\n  }\n  $result[] = $arr;\n\
    }\n", "    if (!is_array($arr))\n        return;\n    $ret = 1;\n    foreach ($arr\
    \ as $val)\n        $ret *= $val < 0 ? -1 : 1;\n    return $ret;\n}\n", "    for($n\
    \ = count($arr)-1; $n>=0; $n--) {\n        $sum = 0;\n        for($i = 0; $i<$n;\
    \ $i++) {\n            $sum += abs($arr[$i]);\n        }\n        $product = 1;\n\
    \        for($i = 0; $i<$n; $i++) {\n            $product *= $arr[$i];\n     \
    \   }\n        if($product == 0) {\n            return None;\n        }\n    \
    \    return $sum * $product;\n    }\n}\n", "    $sum = 0;\n    foreach($arr as\
    \ $v) {\n        $v = abs($v);\n        $sign = is_int($v) ? 1 : ($v > 0 ? 1 :\
    \ -1);\n        $sum += $sign * $v;\n    }\n    return $sum;\n}\n", "    if (empty($arr))\
    \ {\n      return null;\n    }\n\n    $ret = 1;\n    foreach ($arr as $item) {\n\
    \      if ($item < 0) {\n        $ret *= -1;\n      }\n      $ret *= $item;\n\
    \    }\n    return $ret;\n}\n", "    if(empty($arr)) {\n        throw new Exception('Prod_signs:\
    \ empty array');\n    }\n\n    $sum = 0;\n    foreach($arr as $x) {\n        if($x\
    \ > 0) {\n            $sum += $x;\n        } else {\n            $sum -= $x;\n\
    \        }\n    }\n\n    return $sum;\n}\n", "    if (empty($arr))\n        return\
    \ null;\n    foreach ($arr as $value) {\n        $sign = signum($value);\n   \
    \     $result = 0;\n        foreach ($arr as $item) {\n            $result +=\
    \ ($sign * $item);\n        }\n        return $result;\n    }\n}\n</code>\n<|/\
    \ a tags=arrays,php |>\n<| c |>\nThis is wrong - the result for empty array should\
    \ return 0.\n<|/ c |>\n<| a tags=arrays,php dscore=0 |>\nThis also solves the\
    \ problem with negative numbers:\n<code>\n<?php", "    $sign = 1;\n    foreach($arr\
    \ as $v) {\n        $sign *= $v % 3;\n    }\n    return $sign;\n}\n</code>\n<|/\
    \ a tags=arrays,php,array-sum,arrays dscore=1 |>\n<| a tags=arrays,php,array-sum,arrays\
    \ |>\n<code>", "  if (empty($arr))\n    return None;\n  $s = array_sum($arr);\n\
    \  $p = 1;\n  foreach ($arr as $v)\n    $p *= $v & 1;\n  return $s * $p;\n}\n",
  "  for ($i = 0; $i < count($arr); $i++) {\n    $sign = intval($arr[$i]); // 0 or\
    \ 1\n    $arr[$i] = abs($arr[$i]); // make positive\n    if ($sign === 0) { //\
    \ 0 * 1 = 1\n      return $sign * $arr[$i];\n    }\n  }\n  return null;\n}\n</code>\n\
    <|/ a |>\n<| a tags=php |>\nTry this simple code to find sum of magnitude of numbers\
    \ in array - \n<code>\n<?php", "    if (empty($arr)) {\n        return None;\n\
    \    }\n\n    $signs = [0, 0];\n    for ($i = 0; $i < count($arr); $i++) {\n \
    \       $signs[0] += abs($arr[$i]);\n        $signs[1] += $arr[$i] > 0;\n    }\n\
    \n    return $signs[1] * $signs[0];\n}\n", "    if (!$arr) return None;\n    $signs\
    \ = array_map('intval', array_map(\n        function ($num) {\n            return\
    \ $num < 0 ? -1 : ($num == 0 ? 0 : 1);\n        },\n        $arr\n    ));\n  \
    \  return array_sum($signs) * array_prod($signs);\n}\n</code>\nThis solution does\
    \ have some minor optimizations:\n\nIt does not require any additional variables.\
    \ Instead it maintains only one variable, which is $signs. This is only required\
    \ in order to calculate $signs, as it is used later on for multiplication as well.\n\
    It does not use array_sum() or array_product(), instead it uses a custom multiplication\
    \ method (as you suggested).\nIt does not do any validation of the input array,\
    \ which is done inside array_map(). This ensures that any invalid input will be\
    \ caught by the function itself.\n<|/ a tags=php,functional-programming,algorithm\
    \ dscore=2 |>\n<| a tags=php,functional-programming,algorithm |>\nYou can use\
    \ array_reduce() and array_map() to achieve the desired result.\n<code>\n$input\
    \ = [1,2,2,-4,0,1]; \n\n$result = array_reduce(\n    $input,\n    function($carry,\
    \ $value) {\n        $carry += array_map(\n            function($val) { return\
    \ $val > 0 ? 1 : -1; }, \n            array_map(\n                function($val)\
    \ { return $val*1; }, \n                [$value]\n            )\n        );\n\
    \        return $carry;\n    }\n);\necho $result; //-9\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\n`array_reduce($input,function($carry,$val){$carry=$val*1;$carry=$carry-$carry-$carry+$carry;return\
    \ $carry;});`\n<|/ c |>\n<| a |>\n<code>\n<?php \n$input = [1,2,2,-4,0,1];\n$result=array_reduce($input,\
    \ function($carry, $val){\n    return $val>0?$carry:-$carry;\n});\necho $result;\
    \ //-9\n</code>\n<|/ a tags=php,functional-programming,algorithm dscore=1 |>\n\
    <| c |>\nThis fails for input `[0,0,1,0,1]`, because you return -0 for input `[0,0,1,-1,1]`\
    \ which is wrong.\n<|/ c |>\n<| a tags=php,functional-programming,algorithm dscore=1\
    \ |>\nThis is my solution that works perfectly:\n<code>\n$input = [1,2,2,-4,0,1];\
    \ \n$result = array_reduce(\n    $input,\n    ", "    foreach($arr as $v) {\n\
    \        if ($v < 0) return -1;\n        if ($v > 0) return 1;\n    }\n    return\
    \ 0;\n}\n", "    if (!$arr) return; // no need for processing\n    $sum = array_sum($arr);\n\
    \    if ($sum < 0) return $sum;\n    $signs = array_map(function($e) { return\
    \ $e < 0 ? -1 : 1; }, $arr);\n    return $signs * array_sum($signs) * $sum;\n\
    }\n\n$a = [1, 2, 2, -4];\nvar_dump(prod_signs($a));\n\n$a = [0, 1];\nvar_dump(prod_signs($a));\n\
    \n$a = [];\nvar_dump(prod_signs($a));\n\n$a = [-2, -1];\nvar_dump(prod_signs($a));\n\
    \n$a = [-1, 1];\nvar_dump(prod_signs($a));\n\n$a = [-2];\nvar_dump(prod_signs($a));\n\
    \n$a = [-2, 1, -2];\nvar_dump(prod_signs($a));\n\n$a = [-4, 2, 1];\nvar_dump(prod_signs($a));\n\
    \n$a = [-4, 2, 1, 2];\nvar_dump(prod_signs($a));\n</code>\nOutput:\n<code>\nint(-9)\n\
    int(0)\nint(None)\n</code>\nDemo on 3v4l.org\nNote that this could be modified\
    \ to handle non-integer numbers by removing the return $sum; line from your existing\
    \ code.\n<|/ a tags=arrays,php |>\n<| c |>\nThank you for the idea. However, when\
    \ I ran the code I got \"Fatal error: Uncaught Error: Unsupported operand types\"\
    \ on the line `$signs = array_map(function($e) { return $e < 0 ? -1 : 1; }, $arr);`\n\
    <|/ c |>\n<| c |>\nI'm sorry, I made a typo in my original answer, the array key\
    \ should not be `$e` but the array index. I will amend the answer to avoid confusion.\n\
    <|/ c |>\n<| c |>\nI corrected it now, but I got \"Fatal error: Uncaught Error:\
    \ Unsupported operand types\" on the line `$signs = array_map(function($e) { return\
    \ $e < 0 ? -1 : 1; }, $arr);`\n<|/ c |>\n<| c |>\nI tested the code at 3v4l.org\
    \ and it runs without error for me. Are you sure you are using the latest version\
    \ of PHP? Also note that the `$signs` array is an array of integers so the array\
    \ map function should work. If you are still getting an error with the above code\
    \ you might need to post your actual code that you attempted to run on 3v4l.org\
    \ in order for me to try and debug.\n<|/ c |>\n<| c |>\nI made a minor change\
    \ to handle non-integer numbers in the array and added a ", "    if (!$arr) {\n\
    \        return null;\n    }\n\n    $result = 0;\n    foreach ($arr as $num) {\n\
    \        $result = $num * $result;\n    }\n    return $result;\n}\n", "  $p =\
    \ 1;\n  foreach ($arr as $x) {\n    if ($x < 0) $x *= -1;\n    if ($x == 0) $p\
    \ *= 0;\n    else $p *= ($x == 1);\n  }\n  return $p;\n}\n</code>\n<|/ a tags=python\
    \ |>\n<| a |>\nHere's a Python implementation:\n<code>", "    if (empty($arr))\
    \ {\n        return null;\n    }\n\n    $prod = 1;\n    foreach ($arr as $value)\
    \ {\n        $prod *= $value;\n    }\n\n    $signs = array_map('intval', array_unique(array_map('abs',\
    \ $arr)));\n\n    return $signs ? array_reduce($signs, function($acc, $sign) {\n\
    \        return $acc * $prod * $sign;\n    }) : null;\n}\n", "    if (count($arr)\
    \ == 0) {\n        return null;\n    }\n    $sign = array(1, -1);\n    $result\
    \ = 1;\n    foreach ($arr as $el) {\n        $sign[$el] *= $sign[$el];\n     \
    \   $result *= $sign[$el];\n    }\n    return $result;\n}\n", "    foreach ($arr\
    \ as $v) {\n        $p = $v*$v*$v*$v;\n        if ($p < 0) {\n            $p =\
    \ $v*-$v*-$v*-$v; // $v*$v*$v*$v*$v*$v*$v*$v*-$v*-$v*-$v*-$v*-$v*-$v*-$v*-$v*-$v*-$v*-$v\n\
    \        }\n        $r += $p;\n    }\n    return $r;\n}\n", "  if (count($arr)\
    \ === 0)\n    return None;\n\n  $signs = [];\n  foreach ($arr as $num) {\n   \
    \ foreach ($signs as $sign)\n      $sign *= $num === 0 ? 1 : -1;\n    $signs[]\
    \ = $num;\n  }\n\n  $signs = array_map(function ($x) {\n    return ($x === 0)\
    \ ? None : $x;\n  }, $signs);\n\n  $result = 0;\n  foreach ($signs as $sign) {\n\
    \    $result += $sign;\n  }\n\n  return $result;\n}\n", "    $result = 1;\n  \
    \  foreach ($arr as $value) {\n        if ($value < 0) {\n            $result\
    \ *= -1;\n            $result += abs($value);\n        } else {\n            $result\
    \ *= 1;\n        }\n    }\n    return $result;\n}\n", "  $s = array();\n  foreach\
    \ ($arr as $i) {\n    if ($i > 0) {\n      $s[] = 1;\n    } else if ($i < 0) {\n\
    \      $s[] = -1;\n    } else {\n      $s[] = 0;\n    }\n  }\n  if (count($s)\
    \ === 0) {\n    return null;\n  }\n  return array_sum($s) * prod(array_map(function\
    \ ($x) { return $x * $x; }, $s));\n}\n</code>\n<|/ a tags=php dscore=2 |>\n<|\
    \ a |>\nYou can do this in one line using array_map and array_sum.\n<code>\n$result\
    \ = array_sum((array) array_map(function($item) { return (bool) $item ? 1 : 0;\
    \ }, $array));\n</code>\n<|/ a dscore=2 tags=php |>\n<| c |>\nThis answer seems\
    \ to be incorrect. For example, `[1,1,-1]` returns `0`, while it should return\
    \ `-1`.\n<|/ c |>\n<| c |>\nThat's because you forgot about negatives :-)\n<|/\
    \ c |>\n<| c |>\nThat is true, but my solution is more general, so I think it's\
    \ useful to have both here.\n<|/ c |>\n<| a dscore=1 |>\nThis can be done with\
    \ a one-liner using array_sum and array_map like so:\n<code>\n$arr = [-4, -7,\
    \ -10, -2, -6, -2, -8, -1];\necho array_sum(array_map(function ($x) {\n    if\
    \ ($x > 0) {\n        return 1;\n    } elseif ($x < 0) {\n        return -1;\n\
    \    } else {\n        return 0;\n    }\n}, $arr));\n</code>\nThe key is to cast\
    \ all negative values to 1 or -1 and return the sum of the results.\n<|/ a tags=php\
    \ |>\n<| c |>\nI suppose you meant `return $x < 0 ? -1 : 1` instead of `return`.\n\
    <|/ c |>\n<| c |>\nThank you! Updated.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n<?php",
  "  sort($arr);\n  $signs = array_map(function ($num) {\n    return $num >= 0 ? 1\
    \ : -1;\n  }, $arr);\n  return array_reduce($signs, function ($carry, $sign) {\n\
    \    return $carry + abs($sign);\n  }, 0);\n}\n", "  $res = [];\n  foreach ($arr\
    \ as $a) {\n    $sign = 1;\n    foreach ($arr as $aa) {\n      if ($aa != $a)\
    \ {\n        $sign *= ($aa < $a ? -1 : 1);\n      }\n    }\n    $res[] = $sign;\n\
    \  }\n  return $res == []\n    ? None\n    : $res\n        ? $res\n        : reduce(\n\
    \            function($a, $b) { return $a + $b; },\n            array_map(\n \
    \               function($x) { return $x; },\n                array_map(\n   \
    \                 function($x) { return $x == 0 ? None : $x; },\n            \
    \        $res,\n                )\n            )\n          );\n}\n", "    $signs\
    \ = array_map(function ($x) { return $x % 3 == 0 ? 1 : -1; }, $arr);\n    return\
    \ array_sum(array_map(function ($x) { return $x * prod($signs); }, $arr));\n}\n",
  "    if (empty($arr)) return None;\n    $signs = [];\n    $prod = 1;\n    foreach\
    \ ($arr as $val) {\n        if ($val < 0) $signs[] = -1;\n        if ($val > 0)\
    \ $signs[] = 1;\n        $prod *= abs($val);\n    }\n    return $prod * array_sum($signs);\n\
    }\n", "  foreach ($arr as $i => $v) if ($v > 0) $signs[$i] *= -1;\n  foreach ($arr\
    \ as $i => $v) if ($v < 0) $signs[$i] *= -1;\n  $res = array_sum($signs);\n  foreach\
    \ ($arr as $i => $v) $res += $v * $signs[$i];\n  return $res;\n}\n</code>\nThe\
    \ second function (prod_signs) calculates all possible product signs combinations\
    \ where each digit has a different sign (1, -1, 0).\nThe last function (array_sum)\
    \ sums up all product signs.\nThe code above outputs:\n<code>\nprod_signs([2,\
    \ -2, 3, -4]) == -9\nprod_signs([1, -1, 0, 1]) == 0\nprod_signs([]) == None\n\
    </code>\n<|/ a dscore=1 tags=math,algorithm,php |>\n<| c |>\nThank you for you\
    \ help! It works and your explanation is clear to me.\n<|/ c |>\n<| c |>\nNo problem\
    \ :) If you feel that this has answered your question, please consider accepting\
    \ the answer (by clicking the tick next to it), so that people know that you no\
    \ longer need help with this.\n<|/ c |>\n<| a dscore=0 |>\nThe simplest way to\
    \ solve this problem is to convert your array to string and then use array_reduce\
    \ function.\n<code>\n$arr = [1, -2, 3, -4];\n\n$result = array_reduce($arr, function($a,\
    \ $b){\n   return $a + $b * strval($b);\n}, 0);\n\necho $result;\n</code>\nIf\
    \ you need explanation, ask me. Also this solution works in both PHP >= 5.5 and\
    \ PHP <= 5.3.\n<|/ a tags=math,algorithm,php |>\n<| a |>\nPHP has many options\
    \ to solve this task:\n<code>", "    if (!is_array($arr)) {\n        return null;\n\
    \    }\n    $result = 0;\n    $sign = 1;\n    foreach ($arr as $value) {\n   \
    \     $result += $value * $sign;\n        $sign = -$sign;\n    }\n    return $result;\n\
    }\n", "    $res = 0;\n    $signs = [];\n    foreach ($arr as $e) {\n        $res\
    \ += $e;\n        $signs[$e] = 1;\n    }\n    foreach ($arr as $e) {\n       \
    \ $res *= $signs[$e];\n    }\n    return $res;\n}\n", "    $signs = [];\n    for\
    \ ($i = 0, $n = count($arr); $i < $n; ++$i) {\n        $sign = array_pop($arr);\n\
    \        if ($sign < 0)\n            $sign = 1;\n        elseif ($sign > 0)\n\
    \            $sign = -1;\n        else\n            $sign = 0;\n        $signs[]\
    \ = $sign;\n    }\n    return ($n === 0) ? None : (new Collection_Number(array_reduce($signs,\
    \ function ($s, $sign) { return $s * $sign; })));\n}\n</cell>\n<cell>", "    $res\
    \ = 1;\n    foreach ($arr as $num) {\n        $res += $num*$num;\n    }\n    return\
    \ $res;\n}", "  if (!is_array($arr) || count($arr) === 0) {\n    return null;\n\
    \  }\n  $sum = 0;\n  foreach ($arr as $n) {\n    if ($n < 0) {\n      $sum +=\
    \ -1 * $n;\n    } else if ($n > 0) {\n      $sum += $n;\n    }\n  }\n  return\
    \ $sum;\n}\n", "    if (count($arr) == 0) {\n        throw new InvalidArgumentException(\"\
    product of empty list\");\n    }\n\n    $sign = 1;\n    foreach ($arr as $value)\
    \ {\n        if ($value != 0) {\n            $sign *= $value; \n        }\n  \
    \  }\n    return $sign;\n}\n\n/**\n* Find a substring in string.\n* @param $string\
    \ (string) input string\n* @param $substring (string) substring to find\n* @param\
    \ $start (int) start position\n* @param $end (int) end position\n* @param $mode\
    \ (int) Search mode (default = 0 (strpos), 1 = strrpos, 2 = stristr).\n* @return\
    \ (int) position of substring if found, otherwise -1\n* @link http://php.net/manual/en/function.strpos.php\n\
    */", "    if (!$arr) {\n        return null;\n    }\n    $result = 0;\n    foreach\
    \ ($arr as $x) {\n        if ($x > 0) {\n            $result *= 1;\n        }\n\
    \        if ($x < 0) {\n            $result *= -1;\n        }\n    }\n    return\
    \ $result;\n}\n", "    if ($arr == null || $arr == \"\" || is_array($arr)) {\n\
    \        return None;\n    }\n    $sign = 1;\n    $result = 1;\n    foreach ($arr\
    \ as $number) {\n        if ($number < 0) {\n            $sign = -$sign;\n   \
    \     } else {\n            $sign = abs($sign);\n        }\n        $result =\
    \ $sign * $result;\n    }\n    return $result;\n}\n", "  $result = 0;\n  foreach\
    \ ($arr as $num) {\n    $result *= $num;\n    $result -= $num != 0 ? $num * array_sum(array_map('intval',\
    \ $arr)) * $num : 0;\n  }\n  return $result;\n}\n</code>\n<|/ a tags=php dscore=0\
    \ |>\n<| a tags=php dscore=0 |>\n<code>", "  foreach($arr as $n) {\n    if($n\
    \ < 0) {\n      $sign = -1;\n    } else if($n > 0) {\n      $sign = 1;\n    }\
    \ else {\n      $sign = 0;\n    }\n    $product *= $sign;\n  }\n  return $product;\n\
    }\n", "    foreach ($arr as $el) {\n        if ($el < 0) {\n            $sign\
    \ = 1;\n        } elseif ($el > 0) {\n            $sign = -1;\n        } else\
    \ {\n            $sign = 0;\n        }\n        foreach ($arr as $el2) {\n   \
    \         if ($el2 > $el) {\n                $sign *= -1;\n            }\n   \
    \     }\n        return $sign;\n    }\n}", "    sort($arr);\n    $sum = 0;\n \
    \   foreach ($arr as $n) {\n        if ($n < 0) {\n            $sum *= -1;\n \
    \       } elseif ($n == 0) {\n            $sum += 0;\n        } else {\n     \
    \       $sum += $n;\n        }\n    }\n    return $sum;\n}\n</code>\n<|/ a tags=math,php\
    \ dscore=4 |>\n<| a tags=math,php |>\n<code>", "    sort($arr);\n    $signs =\
    \ 0;\n    $prod = 0;\n    foreach ($arr as $num) {\n        $signs = ($signs *\
    \ $num);\n        $prod = ($prod * $num);\n    }\n    if ($prod != 0) {\n    \
    \    return $signs * $prod;\n    }\n    return null;\n}\n", "  $signs = array_map(function\
    \ ($i) {\n    return $i > 0 ? 1 : -1;\n  }, $arr);\n  $sum = 0;\n  foreach ($signs\
    \ as $sign) {\n    $sum = $sum * $sign;\n  }\n  return $sum;\n}\n", "    $signs\
    \ = 0;\n    foreach ($arr as $n) {\n        $signs *= $n;\n        if ($n<0) {\n\
    \            $signs *= -1;\n        }\n    }\n    return $signs;\n}\n", "    return\
    \ arr.reduce(function (acc, val) {\n        var sign = val >= 0 ? 1 : -1;\n  \
    \      return acc + sign * Math.abs(val);\n    }, 0);\n}\n", "    $product = array_product($arr);\n\
    \    if ($product == 0) return 0;\n    $productSigns = array_map(function ($i)\
    \ {\n        return $i == 0 ? '1' : '-1';\n    }, $arr);\n    $signs = array_map(function\
    \ ($i) {\n        return $i == 0 ? '+' : '-';\n    }, $arr);\n    return array_sum(array_map(function\
    \ ($i, $sign) use ($product, $productSigns) {\n        return $product * $productSigns[$i]\
    \ * $sign;\n    }, $arr, $signs));\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nSadly, this was too difficult for me. Here's a solution using array_reduce()\
    \ that also preserves the original order of signs:\n<code>", "    if (count($arr)\
    \ == 0) return null;\n\n    $signs = array_map(function ($x) { return $x < 0 ?\
    \ -1 : 1; }, $arr);\n    array_walk($signs, function (&$x) {$x -= $x == 0 ? 0\
    \ : 1;});\n\n    return array_sum($signs);\n}\n</code>\n<|/ a tags=arrays,php,math,algorithm,logic\
    \ |>\n<| a dscore=1 |>\nHere's a fairly simple way to do it:\n<code>"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
