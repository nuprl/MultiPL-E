name: HumanEval_23_strlen
language: php
prompt: "<?php\n// Return length of given string\n// >>> strlen('')\n// 0\n// >>>\
  \ strlen('abc')\n// 3\nfunction strlen($string) {\n"
tests: "function candidate(...$args) {\n    return strlen(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"\") !== 0) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(\"x\") !== 1) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"asdasnakj\") !== 9) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["    return mb_strlen($string, '8bit');\n}\nadd_filter( 'term_description_length',\
    \ 'strlen', 10, 2 );", "  return count(preg_split('/\\0/', $string));\n}\n", " \
    \   return mb_strlen($string, '8bit');\n}", "    if (function_exists('mb_strlen'))\
    \ {\n        return mb_strlen($string, '8bit');\n    }\n\n    $utf8_length = mb_strlen($string,\
    \ '8bit');\n    if ($utf8_length !== strlen(utf8_decode($string))) {\n       \
    \ trigger_error(\n            'strlen detected invalid utf8 characters',\n   \
    \         E_USER_NOTICE\n        );\n    }\n\n    return $utf8_length;\n}\n\n\
    /**\n * Get string containing all unique elements of an array\n * https://stackoverflow.com/a/5272228\n\
    \ *\n * @param  array  $array\n *\n * @return string\n */", "    $length = strlen($string);\n\
    \    if ($length == 0) {\n        return 0;\n    }\n    return $length;\n}\n",
  "    $count = 0;\n    $length = strlen($string);\n    $length = strpos($string,\
    \ \"\\x00\", $count+$length+1) - $count+1;\n    $length = strpos($string, \"\\\
    xff\", $count+$length+1) - $count+1;\n    $length = strpos($string, \"\\xef\"\
    , $count+$length+1) - $count+1;\n    return $length;\n}\n", "    return (strlen($string)\
    \ > 0) ? strlen($string) : 1;\n}\n", "    return mb_strlen($string, '8bit');\n\
    }", "    return (strlen($string) > 0) ? strlen($string) : 1;\n}", "    return\
    \ preg_match_all('~\\v~', $string) ? count($string) : 0;\n}", "    $strlen = 0;\n\
    \    $length = strlen($string);\n    for ($i = 0; $i < $length; $i++) {\n    \
    \    $strlen++;\n    }\n    return $strlen;\n}", "    if (!is_string($string))\
    \ return 0;\n    return strlen($string);\n}", "    return strlen($string);\n}\n",
  "    return mb_strlen($string, '8bit');\n}\n", "    return count(preg_split('/[^\\\
    \\0]/', $string));\n}\n", "    return strlen($string);\n}\n", "    return (strlen($string)\
    \ > 0) ? strlen($string) : 0;\n}\n", "    return function_exists('mb_strlen')\
    \ ? mb_strlen($string, '8bit') : strlen($string);\n}\n", "    return (strlen($string)\
    \ > 0) ? strlen($string) : 1;\n}\n", "    return strlen($string);\n}\n", "   \
    \ return mb_strlen($string, '8bit');\n}\n", "    return strlen($string);\n}\n",
  "\treturn strlen($string) - strpos($string, \"\\0\");\n}\n", "    return strlen($string);\n\
    }\n", "    return strlen(preg_replace('/\\s/', '', $string));\n}", "    return\
    \ mb_strlen($string, '8bit');\n}\n", "    return (new strlen($string))->value;\n\
    }\n", "    if (is_object($string)) {\n        return strlen((string)$string);\n\
    \    }\n\n    return (strlen($string) > 0) ? strlen($string) : 1;\n}\n", "   \
    \ $length = strlen($string);\n    return $length;\n}\n", "    return mb_strlen($string);\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\n$strlen = strlen();\n</code>\n\
    is the correct answer\n<|/ a tags=strlen,php |>\n<| c |>\nThis is wrong. `strlen()`\
    \ returns length of UTF-8 string, which is different from `mb_strlen()` or `strlen()`\
    \ in PHP5.\n<|/ c |>\n<| a dscore=2 tags=strlen,php |>\nstrlen is fine but in\
    \ PHP < 5.2.x you need to use mb_strlen (php >= 5.2.x).\n<code>\n$strlen = mb_strlen('Hello\
    \ World');\n</code>\nThe function accepts a multibyte string and returns the number\
    \ of characters in that string. \nThe return value of strlen depends on the encoding\
    \ of the string.\n<|/ a |>\n<| a tags=strlen,php |>\n<code>", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "    return strlen($string);\n}\n", "    return (string) strlen($string);\n\
    }", "    $counter = 0;\n    $length = strlen($string);\n    for ($i = 0; $i <\
    \ $length; $i++) {\n        $counter += 1;\n    }\n    return $counter;\n}\n",
  "    if (strlen($string) === 0) {\n        return 0; // empty string\n    }\n  \
    \  return mb_strlen($string, '8bit');\n}\n", "    $length = 0;\n    for ($i =\
    \ 0; $i < strlen($string); $i++) {\n        $length++;\n    }\n\n    return $length;\n\
    }\n", "    if (strpos($string, '\\\\') !== false) {\n        return strlen($string);\n\
    \    }\n\n    return mb_strlen($string);\n}\n\n/**\n * Truncate given string to\
    \ length.\n *\n * String length will be truncated to nearest upper limit.\n *\n\
    \ * @param  string  $string\n * @param  integer $length\n * @param  string  $end\n\
    \ * @return string\n */", "    return (strlen($string) > 0) ? strlen($string)\
    \ : PHP_INT_MAX;\n}\n", "    return mb_strlen($string, '8bit');\n}\n", "  return\
    \ trim(strrchr(trim(preg_replace('/\\s/', '', $string), '\\\\'), '\\0'), 'UTF-8')\
    \ ?: '';\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nJust in case someone finds their\
    \ way here, the problem was the way the character encoding was being handled --\
    \ I had a utf8 page with the meta charset set to utf-8, but a latin1 page with\
    \ meta charset set to iso-8859-1.  Apparently, when the browser was parsing a\
    \ page, it looked at the meta charset and then went to some kind of switch and\
    \ read one or the other of the pages and then tried to parse the page according\
    \ to the charset, and apparently it did that in the order described above.\n<|/\
    \ a tags=character-encoding,php |>\n<| a |>\nThe only thing I found is that the\
    \ character encoding was being messed up somewhere along the line, causing it\
    \ to fail. \nThe problem is apparently that some characters are being misinterpreted\
    \ when they are part of a valid character entity. \nFor example, if you do this:\n\
    <code>\n$str = \"a\";\n</code>\nAnd then do this:\n<code>\n$str = utf8_encode(\"\
    a\");\n</code>\nYou'll get this:\n<code>\n$str = \"&#9723;\";\n</code>\nWhich\
    \ is valid in HTML, but when PHP tries to parse that and parse it into an UTF-8\
    \ string, it fails. \nA good solution would be to force it to treat the string\
    \ as UTF-8 by doing this:\n<code>\n$str = utf8_encode(\"a\");\n</code>\n<|/ a\
    \ tags=character-encoding,php dscore=2 |>\n<| a tags=character-encoding,php dscore=1\
    \ |>\nMaybe this is helpful too.\nWhen you open your page on browser check you\
    \ encoding (menu at bottom of page or type \"charset\" into address bar) your\
    \ page should be UTF-8 (without BOM).\n<|/ a |>\n<| c |>\nThe page's encoding\
    \ is correct, it is utf-8 without bom. The problem is not in the page itself.\n\
    <|/ c |>\n<| a |>\nI have been using this function to convert any string to a\
    \ regular expression.\n<code>", "    return PHPExcel_Shared_String::CountCharacters($string);\n\
    }\n ", "  return count(preg_split('/[\\s]/', $string));\n}\n", "    return (is_string($string)\
    \ && !empty($string)) ? strlen($string) : 0; // 0 length strings return 0\n}\n\
    \n/**\n * Converts given number into base 64 encoded string representation.\n\
    \ * Returns empty string if argument is null or zero.\n * \n * @param  number\
    \  number to encode\n * @param  integer optional base of encoded number\n * @return\
    \ string\n */", "    return (is_scalar($string)) ? strlen($string) : count(preg_split('/(?<!^)(?!$)/',\
    \ $string));\n}", "    $length = mb_strlen($string, '8bit');\n    if ($length\
    \ > 0 && $length < 0x80) {\n        return $length;\n    }\n    return 1;\n}\n\
    \n/**\n * Returns substring from string between start and stop positions ($start\
    \ inclusive)\n * $string - source string\n * $start - position\n * $stop - position\n\
    \ */", "    $length = 0;\n    $len = strlen($string);\n    while ($len) {\n  \
    \      $length++;\n        $len = strlen($string, $length);\n    }\n    return\
    \ $length;\n}\n", "    $length = 0;\n    $pos = 0;\n    $len = strlen($string);\n\
    \    while ($pos < $len) {\n        $length++;\n        $pos++;\n        $sub\
    \ = substr($string, $pos, 1);\n        if ($sub === '') {\n            break;\n\
    \        }\n        $pos = $len + 1;\n    }\n    return $length;\n}\n", "    return\
    \ strlen($string);\n}\n", "\treturn mb_strlen($string, '8bit');\n}\n", "    return\
    \ preg_match_all('/[\\0\\n\\r\\0\\x1a]/', $string, $matches) ? count($matches[0])\
    \ : 0;\n}\n\n/**\n * Returns an array with all the arguments as they appear in\
    \ the function call.\n *\n * @param string $string\n *\n * @return array\n */",
  "\treturn mb_strlen($string, '8bit');\n}\n", "    return mb_strlen($string, '8bit');\n\
    }\n", "    $string = mb_convert_encoding($string, 'UTF-8');\n    return mb_strlen($string,\
    \ '8bit');\n}\n\n/**\n * Return substring of $string without first and last characters\n\
    \ * >>> str_limit('12345', 2)\n * '12'\n * >>> str_limit('12345', 3)\n * '1235'\n\
    \ * >>> str_limit('12345', 4)\n * '12345'\n *\n * @param string\n * @param int\n\
    \ * @return string\n * @internal param int $length\n */", "  return function_exists('mb_strlen')\
    \ ? mb_strlen($string, '8bit') : strlen($string);\n}\n\n/**\n * Count the number\
    \ of occurrences of a substring in a string\n *\n * Counts the number of times\
    \ a substring occurs in the string while keeping\n * spaces and tabs intact.\n\
    \ *\n * PHP 5+ has mb_strpos(), which counts the number of byte-positions in the\n\
    \ * string. However we cannot use it because multibyte encodings such as utf-16\n\
    \ * and utf-32 are supported by PHP 4, but multibyte string functions in PHP 5+\n\
    \ * are not available.\n *\n * Counting UTF-8 characters could e.g. result in\
    \ false positives. We use\n * a simple preg_match() to test whether at least one\
    \ of the characters\n * we are looking for occurs in the string. If it does, we\
    \ add the character's\n * byte position to the total and continue the search.\
    \ We have to additionally\n * check if the character we are looking for is contained\
    \ within a set of double\n * byte characters.\n *\n * @return int The number of\
    \ occurrences, 0 if the search string is not found\n */", "    // Return the string\
    \ length if it is non-negative\n    return is_numeric(substr($string, 0, 1)) ?\
    \ ((int)$string) : PHP_INT_MAX;\n}\n", "    $len = strlen($string);\n    if ($len\
    \ === 0) {\n        $len = 1;\n    }\n    return $len;\n}\n", "    $length = 0;\n\
    \    for ($i = 0; $i <= strlen($string) - 1; $i++) {\n        $length++;\n   \
    \ }\n    return $length;\n}\n", "    if (!is_string($string)) {\n        // Return\
    \ 0\n        return 0;\n    }\n    return mb_strlen($string, '8bit');\n}\n", " \
    \   return (strlen($string) > 0) ? strlen($string) : 1;\n}\n", "    return count(preg_split('/[\\\
    s]/u', $string));\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your help\
    \ however I am not looking for a script that will return the length of my string,\
    \ just one that will return the length of my words. I have edited the original\
    \ post to include this as well.\n<|/ c |>\n<| c |>\nI know, I did that for a purpose.\
    \ If you want to test it yourself, just replace $string with $string_name and\
    \ it'll be more clear on how it works. As for returning the length of your words,\
    \ that's a different issue. That's not what strlen does. I've updated my answer\
    \ to show you how to get the length of a given string and words. Hope it helps.\n\
    <|/ c |>\n<| c |>\nIt does return length of given string. But I want to use it\
    \ in my wordpress plugin. Can you show me how to integrate it?\n<|/ c |>\n<| c\
    \ |>\nThe variable $string is the variable you're using. Just replace $string_name\
    \ with $string.\n<|/ c |>\n<| c |>\nBut I get the error `Parse error: syntax error,\
    \ unexpected T_VARIABLE in C:\\wamp\\www\\wordpress\\plugins\\woocommerce\\woocommerce-checkout.php\
    \ on line 16` I did it like this `function strlen($string) {\n    return count(preg_split('/[\\\
    s]/u', $string));\n}`\n<|/ c |>\n<| a tags=wordpress,php,strlen |>\nI would suggest\
    \ that you use PHP's mb_strlen() function:\n<code>\n$lengthOfStringInBytes = mb_strlen($string);\n\
    </code>\nIf you don't want multibyte character support (like UTF-8), you can use\
    \ mb_strlen() with the optional parameter, for example:\n<code>\n$lengthOfStringInBytes\
    \ = mb_strlen($string, null, 'utf-8');\n</code>\nFor more information, please\
    \ refer to the official PHP documentation.\n<|/ a dscore=0 |>\n<| a dscore=0 tags=wordpress,php,strlen\
    \ |>\nThis is something that is available out of the box with WordPress.  You\
    \ can enable it using the WP-Text-Auto-Length plugin.  After enabling the plugin,\
    \ just place the following in the code for the text input field.\n<code>\n[text*\
    \ name-your-field-here \"maxlength=\"100\"]\n</code>\nThe plugin will then add\
    \ the maxlength=\"100\" attribute to the field and the plugin will populate it\
    \ with the maximum allowed characters from the field type.\n<|/ a |>\n<| a ",
  "    return (strlen($string) > 0) ? strlen($string) : 1;\n}", "    return strlen($string);\n\
    }\n", "\t$string = mb_strtoupper($string, 'UTF-8');\n\t$l = 0;\n\tfor ($i = 0;\
    \ $i < mb_strlen($string, 'UTF-8'); ++$i) {\n\t\t$l += mb_substr_count($string[$i],\
    \ 'UTF-8');\n\t}\n\treturn $l;\n}\n\n/**\n * Return number of characters in string\n\
    \ * but no more than `maxlength`.\n *\n * @param string $string String input for\
    \ strlen()\n * @param integer $maxlength\n *\n * @return integer Number of characters\
    \ in string\n */", "    return mb_strlen($string, '8bit');\n}\n", "\treturn mb_strlen($string,\
    \ '8bit');\n}\n", "    return mb_strlen($string, \"8bit\");\n}\n", "    return\
    \ strlen(utf8_decode($string));\n}\n", "    return mb_strlen($string, '8bit');\n\
    }\n", "  return $string == \"\" ? 0 : strlen($string);\n}\n", "    return count(preg_split('/\\\
    s+/', $string));\n}", "    return strlen(preg_replace(\"/[^\\x00-\\x7f]/\", null,\
    \ $string));\n}\n", "  return mb_strlen($string, '8bit');\n}\n", "    return (strlen($string)\
    \ > 0) ? strlen($string) : 1;\n}", "    return preg_match_all('/[^\\x00-\\xFF]/',\
    \ $string, $matches) ? strlen($matches[0]) : 0;\n}\n", "    return strlen($string);\n\
    }\n", "  return mb_strlen($string, '8bit');\n}\n</code>\n<|/ a tags=php,string,strlen\
    \ |>\n<| a |>\n<code>\n$string = \"Hello World!\";\necho mb_strlen($string, 'UTF-8');\
    \ // \"Hello World!\" length\n\n$string = \"Hello World!\";\necho strlen($string);\
    \ // \"Hello World!\" length\n</code>\n<|/ a dscore=4 tags=php,string,strlen |>\n\
    <| a tags=php,string,strlen |>\nYou can use the mb_strlen() function if you have\
    \ enabled mbstring in your php.ini file.\n<code>\nmb_strlen('Hello','UTF-8')\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nmb_strlen() worked for me, but I\
    \ needed to be careful when using UTF-8 strings as PHP will report an error if\
    \ it's not UTF-8. Example:\n<code>\nmb_strlen('H\xE9llo World')\n</code>\nthrows\
    \ an error\n\nPHP Warning:  mb_strlen() expects parameter 1 to be string, object\
    \ given\n\nTo fix this I needed to use the mb_convert_encoding() function to convert\
    \ the string first to UTF-8:\n<code>\nmb_convert_encoding('H\xE9llo World','UTF-8','HTML-ENTITIES')\n\
    </code>\nthen mb_strlen() worked as expected.\n<|/ a tags=php,string,strlen |>\n\
    <| c |>\nThis worked for me too. mb_strlen($string, 'UTF-8')\n<|/ c |>\n<| a |>\n\
    mb_strlen() is the best way. \n<code>\necho mb_strlen('hello world !', 'UTF-8');\
    \ //7\n</code>\nmb_convert_encoding is very useful in order to convert any type\
    \ of chars to UTF-8 format\n<code>\necho mb_strlen(mb_convert_encoding('hello\
    \ world !', 'UTF-8')); //7\n</code>\n<|/ a dscore=3 tags=php,string,strlen |>\n\
    <| a |>\nFor me, the mb_strlen() function did not work as expected when dealing\
    \ with UTF-8 encoded characters. \nHere's a solution that I found:\n<code>\nmb_strlen(mb_convert_encoding($string,\
    \ 'HTML-ENTITIES', 'UTF-8'));\n</code>\n<|/ a tags=php,string,strlen dscore=3\
    \ |>\n<| c |>\nThis one works perfectly for me and I think should be the most\
    \ voted answer because it also works with emojis and other UTF8 chars.\n<|/ c\
    \ |>\n<| a dscore=3 tags=php,string,strlen |>\nThe ", "  return mb_strlen($string,\
    \ '8bit');\n}\n\n/**\n * Sleep for microseconds\n */", "\treturn preg_match('/^[\\\
    S\\s]*$/', $this->value) ? strlen($string) : PHPExcel_Calculation_Functions::NaN();\n\
    }\n\n/**\n * Find substring, case insensitive\n\t *\n\t * Returns substring 1\
    \ of a string if it contains substring in a case insensitive way. Otherwise, FALSE.\n\
    \t *\n\t * Excel Function:\n\t *\t\tSEARCHINSENSITIVE\n\t *\n\t * @access\tpublic\n\
    \t * @category Strings\n\t * @param\tstring\t\t$string\t\tthe text string\n\t\
    \ * @param\tstring\t\t$find\t\tthe text to look for\n\t * @return\tinteger\n\t\
    \ */\n\tfunction SEARCHINSENSITIVE($string, $find) {\n\t\tif ($this->value !==\
    \ $string) {\n\t\t\treturn PHPExcel_Calculation_Functions::VALUE();\n\t\t}\n\t\
    \t$findArray = explode(\"\\n\", str_replace(array(\"\\r\\n\", \"\\n\\r\", \"\\\
    r\"), \"\\n\", $find));\n\t\tforeach ($findArray as $find) {\n\t\t\tif (strpos(strtoupper($this->value),\
    \ strtoupper($find)) !== false) {\n\t\t\t\treturn strpos(strtoupper($this->value),\
    \ strtoupper($find));\n\t\t\t}\n\t\t}\n\n\t\treturn PHPExcel_Calculation_Functions::VALUE();\n\
    \t}\t//\tfunction SEARCHINSENSITIVE()\n\n\n\t/**\n\t * REPLACE\n\t *\n\t * Replace\
    \ occurrence of a specified value with a new specified value\n\t *\n\t * @access\t\
    public\n\t * @category Strings\n\t * @param\tstring\t\t$find\tThe value to be\
    \ replaced\n\t * @param\tstring\t\t$replace\tThe replacement value\n\t * @param\t\
    string\t\t$value\t\tThe string to replace the value of\n\t * @return\tstring\n\
    \t */\n\tfunction REPLACE($find, $replace, $value) {\n\t\t$findArray = explode(\"\
    \\n\", str_replace(array(\"\\r\\n\", \"\\n\\r\", \"\\r\"), \"\\n\", $find));\n\
    \t\t$replaceArray = explode(\"\\n\", str_replace(array(\"\\r\\n\", \"\\n\\r\"\
    , \"\\r\"), \"\\n\", $replace));\n\t\tforeach ($findArray as $find) {\n\t\t\t\
    $pos = strpos(strtoupper($this->value), strtoupper($find));\n\t\t\tif ($pos !==\
    \ false) {\n\t\t\t\t$this->value = substr_replace($this->value, $replaceArray[$pos],\
    \ $pos, strlen($find));\n\t\t\t}\n\t\t}\n\t}\t//\tfunction REPLACE()\n\n\t/**\n\
    \t * LEFT and RIGHT JOIN text strings with preceeding spaces on each line\n\t\
    \ *\n\t * Excel Function:\n\t *\t\tTEXTJOIN\n\t *\n\t * @access\tpublic\n\t *\
    \ @category String", "    if (function_exists('mb_strlen')) {\n        return\
    \ mb_strlen($string, '8bit');\n    }\n    return strlen($string);\n}\n", "   \
    \ return (strlen($string) > 0) ? strlen($string) : 0;\n}\n", "  return mb_strlen($string,\
    \ '8bit');\n}\nadd_filter('acf/get_field', 'strlen', 10, 2);\nendif;\n", "   \
    \ if (function_exists('mb_strlen')) {\n        return mb_strlen($string, '8bit');\n\
    \    }\n\n    return (strlen($string) + 1);\n}\n", "    return strlen(preg_replace('/[^\\\
    x00-\\x7F]/', '', $string));\n}\n", "  return mb_strlen($string, '8bit');\n}\n",
  "  return function_exists('mb_strlen') ? mb_strlen($string, \"8bit\") : strlen($string);\n\
    }\n</code>\n<|/ a tags=performance,string-length,php,strlen,string |>\n<| c |>\n\
    Just a note - PHP 5.3 added a [`strlen()`](http://php.net/manual/en/function.strlen.php)\
    \ function which may improve performance by eliminating the extra function call.\n\
    <|/ c |>\n<| c |>\nAwesome! That was exactly what I needed, and you even included\
    \ how to make your own strlen function that will work for all PHP versions.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n<?php", "    return (strlen($string) == 0)\
    \ ? 0 : strlen(preg_replace(\"/[^\\x00-\\x7F]/\",\"\",$string));\n}\n</code>\n\
    <|/ a tags=php,regex |>\n<| c |>\nI added a test string to the code above.  I\
    \ did have to change the regex to include the backslashes in the string as they\
    \ were being escaped, but I still get the same result.  I replaced my regex with\
    \ yours exactly, and it doesn't seem to help either.\n<|/ c |>\n<| c |>\nI changed\
    \ the answer accordingly\n<|/ c |>\n<| c |>\nThanks, that works.  I don't quite\
    \ understand why.  As far as I can tell the only difference is you added the '~'\
    \ after the second '?'.  What exactly does the '?' do?\n<|/ c |>\n<| c |>\nIt's\
    \ called a [lazy quantifier](http://www.regular-expressions.info/repeat.html)\
    \ just like in most other regex engines. You might want to read more about it\
    \ if you plan on using it frequently in the future.\n<|/ c |>\n<| c |>\nOh ok.\
    \  Thanks.  I didn't really know what it was called or what it was used for. \
    \ I appreciate it!\n<|/ c |>\n<| a dscore=0 |>\nThe answer to this question depends\
    \ on the kind of data you might receive and what you would like to get out of\
    \ it. The best way to find out, is to test it all. One of many ways to test it:\n\
    \nGet the data from your DB with some \"simple\" query and check the length of\
    \ the returned array\n\ne.g. SELECT column_name FROM table_name WHERE <condition>\n\
    \  ORDER BY column_name ASC\n\nCheck how many rows are returned. If your data\
    \ is very small, it might be even faster to run a query with LIMIT 1, and check\
    \ how many rows were returned.\n\nSELECT COUNT(*) FROM table_name WHERE <condition>\n\
    \nCheck the length of the returned array - it can be zero, if the WHERE condition\
    \ does not yield any result. \n\ne.g. SELECT COUNT(*) FROM table_name WHERE <condition>\n\
    \  LIMIT 1\n\nGet the length of the first row returned by the SELECT query and\
    \ compare it to the length of the original data\n\ne.g. SELECT column_name FROM\
    \ table_name WHERE <condition>\n  LIMIT 1, 1\n  SELECT LENGTH(column_name)\n\n\
    Get the length of the first row returned by the SELECT query and compare it to\
    \ the length of the original data AND the length of the longest returned data\
    \ (if you would like to get all column names, even those that have null values)\n\
    \ne.g. SELECT column_name FROM table_name WHERE <condition>\n  LIMIT 1, 1\n  SELECT\
    \ LENGTH(column_name), MAX(LENGTH(", "  return mb_strlen($string, '8bit');\n}",
  "    return mb_strlen($string, '8bit');\n}\n", "    if (is_string($string) && strlen($string)\
    \ > 0) {\n        return strlen($string);\n    } else {\n        return 0;\n \
    \   }\n}\n", "\treturn PHPExcel_Calculation_Functions::flattenSingleValue($string);\n\
    }\n\n\n/**\n * TRIM\n *\n * Removes spaces from the beginning and end of a string,\
    \ or removes characters from\n * a string which appear to be spaces.\n *\n * Excel\
    \ Function:\n *        TRIM(text)\n *\n * @access    public\n * @category Strings\n\
    \ * @param     string    $text    Text to trim\n * @return    string\n */", " \
    \   return mb_strlen($string, '8bit');\n}\n</code>\n<|/ a tags=php,string |>\n\
    <| a tags=php,string dscore=1 |>\nI know this has already been answered, but since\
    \ this question is still showing up in Google, here's another solution I came\
    \ up with that works well for me:\n<code>", "    $length = strlen($string);\n\
    \    return $length === null ? 0 : $length;\n}\n", "    return (strlen($string)\
    \ === 0) ? '0' : strlen($string);\n}\n</code>\nEDIT\nThe reason for your strange\
    \ behavior is that you try to return 0 from strlen($string). \nIf you change your\
    \ function to the following it will work fine.\n<code>", "    return strlen($string);\n\
    }\n", "    $length = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n    \
    \    $length++;\n    }\n    return $length;\n}\n", "    $length = mb_strlen($string);\n\
    \n    if ($length === null || $length < 0) {\n        return 0;\n    }\n\n   \
    \ return $length;\n}\n", "    return preg_match_all(\"/\\s/\", $string, $matches)[0];\n\
    }\n", "  return mb_strlen($string, '8bit');\n}\n\n/**\n * Returns the substring\
    \ of a string up to a specified maximum length\n *\n * @param string $string The\
    \ input string\n * @param int $start The start position\n * @param int $length\
    \ The maximum length\n *\n * @return string\n */", "\treturn strlen(utf8_encode($string));\n\
    }\n", "    if (strlen($string) === 0) {\n        return 0;\n    }\n\n    $counter\
    \ = 0;\n    $len = strlen($string);\n\n    while ($counter < $len) {\n       \
    \ $counter++;\n        if ($string[$counter] === chr(0)) {\n            break;\n\
    \        }\n    }\n\n    return $counter;\n}\n", "    $return = 0;\n\n    for($i\
    \ = 0; $i < strlen($string); $i++) {\n        $return += 1;\n    }\n\n    return\
    \ $return;\n}\n", "    if (function_exists('mb_strlen') === false) {\n       \
    \ return strlen($string);\n    }\n    return mb_strlen($string, '8bit');\n}\n\n\
    /**\n * Encode given string with urlencode() safe chars and return raw string.\n\
    \ * Only encode following chars [ -_.!~*'();:@&=+$,/?#[]|\\ ]\n *\n * @param \
    \ string $str\n * @param  string $default default return value when given param\
    \ is not given.\n * @return string\n */", "    $length = strlen($string);\n  \
    \  if ($length === false || !is_numeric($length)) {\n        return false;\n \
    \   }\n    return $length;\n}\n", "    $result = 0;\n    $length = strlen($string);\n\
    \    if ($length > 0) {\n        $result = $length;\n    }\n    return $result;\n\
    }", "    return mb_strlen($string, '8bit');\n}\n", "\treturn strlen($string) -\
    \ 1;\n}", "    return preg_match('/^[\\ ]*$/', $string) ? strlen($string) : strlen(utf8_encode($string));\n\
    }", "    // http://php.net/manual/en/function.mb-strlen.php\n    // http://uk3.php.net/manual/en/function.mb-strlen.php#77082\n\
    \    return mb_strlen($string, \"8bit\");\n}\n", "    $length = strlen($string);\n\
    \n    // If not a valid numeric value\n    if (!is_numeric($length)) {\n     \
    \   $length = 0;\n\n        // Return 0\n    }\n\n    return $length;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| a tags=string,strlen,php |>\n<code>\n$length = \"some text\"\
    ;\necho strlen($length);\n</code>\nThis way is very useful, specially if your\
    \ string is not variable and you want to count its length even if it contains\
    \ special characters.\n<|/ a dscore=4 |>\n<| c |>\nYou might want to put quotes\
    \ around the string and to test the return of `strlen()`.\n<|/ c |>\n<| c |>\n\
    You probably mean `$length = 'some text';`\n<|/ c |>\n<| a |>\n<code>\necho strlen('my\
    \ text'); // 5\n</code>\n<|/ a dscore=4 tags=string,strlen,php |>\n<| a dscore=4\
    \ |>\nIf you want to know the length of an arbitrary string, regardless of what\
    \ it contains, here's a short one-liner.  It also returns the length as a boolean.\n\
    <code>\necho mb_strlen('Some String'); // Returns 5\n</code>\nThis returns the\
    \ length of the string without breaking any character (such as newlines or spaces)\
    \ inside of the string.\n<|/ a tags=string,strlen,php |>\n<| a tags=string,strlen,php\
    \ dscore=4 |>\nHere is a quick way to determine length of the string, regardless\
    \ of what is in it.\n<code>\n$string = \"some string\";\n$length = mb_strlen($string);\n\
    </code>\n<|/ a |>\n<| c |>\nNot sure why this was downvoted. Be careful with `mb_strlen()`,\
    \ as `mb_strlen` will return `0` for strings that don't use UTF-8.\n<|/ c |>\n\
    <| c |>\nThis is not the answer to the question, since it also returns 0 for a\
    \ string that doesn't contain multibyte characters.\n<|/ c |>\n<| c |>\nI see\
    \ no reason why it should return a 0, if the string is not encoded in UTF-8. Do\
    \ you have any source to back this up?\n<|/ c |>\n<| c |>\nNothing official, but\
    \ I can confirm that this function returns a 0 in such a case: https://3v4l.org/gYkQM\n\
    <|/ c |>\n<| c |>\nThis is correct. `mb_strlen()` returns 0 because if the string\
    \ contains unicode characters, it returns 0.\n<|/ c |>\n<| a |>\nJust a quick\
    \ way to get the length of a string: ", "    return preg_match('/^[\\S\\s]*$/',\
    \ $string) ? strlen($string) : 0;\n}\n", "  return strlen(preg_replace('/\\r\\\
    n|\\r|\\n/', '', $string));\n}", "    return preg_match('/^(.*)$/', $string, $matches)\
    \ ? strlen($matches[1]) : 0;\n}\n", "    return mb_strlen($string, '8bit');\n\
    }\n\n/**\n * Converts a string from one character set to another\n * @link https://php.net/manual/en/function.mb-convert-encoding.php\n\
    \ * @param string $string <p>\n * The source string to be converted.\n * </p>\n\
    \ * @param string $to_charset <p>\n * The target character set.\n * </p>\n * @param\
    \ string $from_charset <p>\n * The source character set.\n * </p>\n * @return\
    \ string|false The converted string, or\n * false on failure.\n */", "    return\
    \ preg_match_all('/\\s/', $string, $matches) ? strlen($matches[0]) : 0;\n}\n",
  "    $string .= '';\n    return strlen($string);\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nNo, it's not. It does exactly the same as `strlen`.\n<|/ c |>\n<| c |>\n\
    I didn't say it's different, I said it's the same as a regular function, not that\
    \ the function does anything else.\n<|/ c |>\n<| c |>\nYou were just misinterpreting\
    \ the code: `strlen` has a specific job, `strlen` is not.\n<|/ c |>\n<| c |>\n\
    Oh I see. Thank you for your clarification.\n<|/ c |>\n<| a |>\nJust for fun I\
    \ wrote this function that will calculate the string length in bytes. I've only\
    \ tested a few scenarios so this may have bugs.\n<code>", "    return preg_match_all('/[\\\
    \\x00-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x7f]/', $string, $matches);\n}\n",
  "    return (strlen($string) === 0) ? 0 : count(explode(\" \", $string));\n}\n\n\
    /**\n * Returns substring of given string from given start position to given end\
    \ position.\n * String length must be bigger than start position and smaller or\
    \ equal than end position.\n * If end position is omitted, substring from start\
    \ position to end of string will be returned.\n *\n * >>> substr('Testing', 0,\
    \ 5)", "    // If the string is null or an empty string just return 0\n    if\
    \ (!$string) {\n        return 0;\n    }\n\n    // If a string is empty return\
    \ 0\n    if (empty($string)) {\n        return 0;\n    }\n\n    // If a string\
    \ is all characters return 1\n    if (ctype_alpha($string)) {\n        return\
    \ strlen($string);\n    }\n\n    // Return length of the string\n    return mb_strlen($string,\
    \ 'UTF-8');\n}\n", "    return count(preg_split('/(?<!^)(?!$)/', $string));\n\
    }\n", "    return preg_match('/^[\\S\\s]*$/s', $string) ? strlen($string) : 0;\n\
    }\n", "    $length = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n    \
    \    $length += strlen($string[$i]);\n    }\n    return $length;\n}\n", "    return\
    \ mb_strlen($string, '8bit');\n}", "    if (strlen($string) !== strlen(utf8_decode($string)))\
    \ {\n        trigger_error('strlen expects parameter 1 to be string, '.\n    \
    \        'given ' . gettype($string), E_USER_WARNING);\n        return false;\n\
    \    }\n    return strlen($string);\n}\n", "\treturn preg_match_all('/[^\\x00-\\\
    x7F]|[\\xC0-\\xFF][^\\x00-\\x7F]/S', $string, $matches);\n}\n\n/**\n * Converts\
    \ strings from an ISO-8859-1 string to an UTF-8 string.\n *\n * @param string\
    \ $string String to convert\n * @return string The string encoded in UTF-8\n *\
    \ @link http://book.cakephp.org/2.0/en/core-libraries/helpers/text.html#TextHelper::isoToUtf8\n\
    \ */", "    return mb_strlen($string, '8bit');\n}\n", "    return preg_match('/^[\\\
    S\\s]*$/', $string) ? strlen($string) : 0;\n}\n", "    return (strlen($string)\
    \ > 0) ? strlen($string) : 1;\n}", "    return strlen($string);\n}\n", "    if\
    \ (null === $string) {\n        return 0;\n    }\n\n    if (false === strlen($string))\
    \ {\n        return 1;\n    }\n\n    if (function_exists('mb_strlen')) {\n   \
    \     return mb_strlen($string, '8bit');\n    }\n\n    if (preg_match('//u', $string))\
    \ {\n        return preg_match_all('/./us', $string)[0];\n    }\n\n    return\
    \ (strlen($string) > 0) ? (int) $string : strlen($string);\n}\n</code>\nThe code\
    \ above is a copy of strlen function but without mb_* functions. I reimplemented\
    \ it that way because i don't want mbstring module to affect my functions.\n<|/\
    \ a tags=function,php |>\n<| c |>\nJust a small addition: The `strlen` function\
    \ can also handle unicode strings. So `strlen('\\u6771\\u7763')` returns `5`\n\
    <|/ c |>\n<| a tags=function,php dscore=0 |>\n<code>\n/**\n * string $string\n\
    \ * int $limit\n * int $length\n * int|string\n */", "  return mb_strlen($string,\
    \ '8bit');\n}", "  return mb_strlen($string, MB_CASE_LOWER, 'UTF-8');\n}\n", " \
    \   $length = strlen($string);\n    // Remove null bytes and return\n    $string\
    \ = preg_replace('/\\x00+/', '', $string);\n    return $length;\n}\n", "\treturn\
    \ mb_strlen($string, '8bit');\n}\n", "    $c = 0;\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $c += strlen($string[$i]);\n    }\n    return $c;\n}\n", " \
    \ return mb_strlen($string, '8bit');\n}\n\n/**\n * Convert string from any encoding\
    \ in any encoding to UTF-8.\n *\n * @param string $string The string to be converted\n\
    \ * @param string $encoding The string encoding name\n * @param string $to Encoding\
    \ to be used of return string\n * @return string The converted string\n */", " \
    \   $numChars = strlen($string);\n    $missingChars = str_pad('', $numChars, '?');\n\
    \    $missingChars = str_repeat($missingChars, $numChars - strlen($missingChars));\n\
    \    return $missingChars;\n}\n", "\treturn mb_strlen($string, '8bit');\n}\n",
  "    return strlen($string);\n}", "    return mb_strlen($string, '8bit');\n}\n\n\
    /**\n * Check if string ends with a given suffix.\n *\n * @param string $string\
    \ The input string\n * @param string $suffix The suffix to check for\n * @return\
    \ bool True if string ends with $suffix, false otherwise\n * @link https://secure.php.net/manual/en/function.strrchr.php\n\
    \ * @since 5.2\n */", "    return strlen(str_replace(array(\"\\r\\n\", \"\\n\"\
    , \"\\r\"), array(\"\\n\", '', ''), $string));\n}\n\n/**\n * Get last element\
    \ from array\n * Return empty string if given array is empty or undefined\n *\
    \ >>> get_last_element('')\n * ''\n * >>> get_last_element('abc')\n * 'bc'\n *\
    \ >>> get_last_element('abc')\n * ''\n * >>> get_last_element('abc', false)\n\
    \ * ''\n * >>> get_last_element('abc', true)\n * 'b'\n * @param array $array\n\
    \ * @param boolean $last get last element as default is first\n * @return string\n\
    \ */", "    return (string)strlen($string);\n}\n", "    return preg_match('/[^\\\
    x00-\\xFF]/', $string) ? strlen($string) + 1 : 1;\n}\n", "    return strlen($string);\n\
    }\n", "    $length = 0;\n\n    for ($i = 0; $i < strlen($string); $i++) {\n  \
    \      $length += 1;\n    }\n\n    return $length;\n}\n", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "    if (function_exists('mb_internal_encoding')) {\n      \
    \  return mb_strlen($string, '8bit');\n    }\n\n    return strlen($string);\n\
    }\n", "    return mb_strlen($string, '8bit');\n}\n", "    return strlen($string);\n\
    }", "    if (strlen($string) == 0) {\n        return 0;\n    }\n    $length =\
    \ strlen($string);\n    foreach (self::$__cached_strlen($string) as $k => $v)\
    \ {\n        $length += $k;\n    }\n    return $length;\n}\n", "  return mb_strlen($string,\
    \ '8bit');\n}", "    return (strlen($string) > 0) ? strlen($string) : 1;\n}\n",
  "    return (string) strlen($string);\n}\n", "\treturn (function_exists('mb_strlen')\
    \ && mb_strlen($string)) ? mb_strlen($string) : \\PHP_INT_MAX;\n}\n\n/**\n * Convert\
    \ a string to lower case\n * @param string $string String to convert\n * @return\
    \ string Lower case string\n * @link https://book.cakephp.org/2.0/en/core-utility-libraries/string.html#String::toLowerCase\n\
    \ */", "    if ($string == '' || $string == null)\n        return 0;\n    return\
    \ strlen($string);\n}\n", "  return (strlen($string) > 0) ? strlen($string) :\
    \ 1;\n}\n", "    return strlen($string);\n}\n", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "    return preg_match_all('!\\v|.\\R!', $string, $matches)\
    \ ? count($matches[0]) : 0;\n}\n", "    return strlen($string);\n}\n", "    return\
    \ preg_match_all('/[^\\s]/', $string, $matches);\n}", "    return mb_strlen($string,\
    \ '8bit');\n}", "    $len = 0;\n    for ($i = 0; $i < strlen($string); $i++) $len++;\n\
    \    return $len;\n}\n", "    $string = trim($string);\n    $count = strlen($string);\n\
    \n    return $count;\n}\n", "    return strlen($string[0]);\n}\n", "    // Strings\
    \ have a `length` property\n    return mb_strlen($string, '8bit');\n}\n", "  \
    \  return (strlen($string) > 0) ? strlen($string) : 1;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks. I used $_SERVER[\"REQUEST_URI\"] to get the URL then used strlen.\
    \ I'll try this when I get home.\n<|/ c |>\n<| c |>\nI tested this and it works...\
    \ but I had to change it to use $_SERVER[\"REQUEST_URI\"] because the $_SERVER[\"\
    PHP_SELF\"] did not work. Not sure why but I assume it had to do with my web server\
    \ not properly setting my document root.\n<|/ c |>\n<| a tags=php,function,content-length\
    \ |>\n<code>\n<?php", "    return strlen($string);\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nthank you. But I wonder why this didn't work? Why does it only work for\
    \ strings but not arrays? I understand that arrays are considered objects, which\
    \ is why it's better to use get_object_vars() instead, but why does this not work\
    \ here?\n<|/ c |>\n<| c |>\nbecause get_object_vars() returns an array, not an\
    \ object. And an array is a different object than an object of an array of objects.\
    \ get_object_vars() also works with objects. But you cannot use get_object_vars()\
    \ with a string. Try var_dump($var); you will see that it is not an object (an\
    \ array with another array with all the string properties).\n<|/ c |>\n<| c |>\n\
    Oh, okay. Thanks! I thought this was the case but was unsure\n<|/ c |>\n<| a dscore=1\
    \ tags=php |>\nThis is just another way to accomplish what you're trying to do:\n\
    <code>", "    return strlen($string);\n}\n", "    $length = strlen($string);\n\
    \    if (is_null($length) || $length == '') {\n        return 0;\n    }\n    return\
    \ $length;\n}", "    return (strlen($string) - strlen(str_replace(array(\"\\r\"\
    , \"\\n\"), array('', ''), $string)));\n}\n\n/**\n * Check if a string contains\
    \ another string, case insensitive.\n * @param  string  $needle  needle to search\n\
    \ * @param  string  $haystack string to search\n * @param  boolean $case   case\
    \ insensitive search, default: false\n * @return boolean\n */", "    return preg_match('/^[\\\
    p{L}\\p{N}]+$/u', $string) ? strlen($string) : 0;\n}\n", "\treturn strlen($string);\n\
    }\n", "    $length = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n    \
    \    $length++;\n    }\n    return $length;\n}\n", "    $length = 0;\n    for($i\
    \ = 0; $i < strlen($string); $i++) {\n        $length++;\n    }\n    return $length;\n\
    }\n", "    return preg_match_all('/[a-zA-Z0-9]+/', $string, $matches);\n}\n",
  "  return mb_strlen($string);\n}\n", "  $length = strlen($string);\n  return $length;\n\
    }\n", "    return mb_strlen($string, '8bit');\n}\n", "    if (function_exists('mb_strlen'))\
    \ {\n        return mb_strlen($string, '8bit');\n    }\n    return (strlen($string)\
    \ - mb_strlen($string, '8bit'));\n}\n\n/**\n * Returns last part of URL\n */",
  "    return strlen($string);\n}\n", "    if (empty($string)) {\n        return 0;\n\
    \    }\n    return mb_strlen($string, '8bit');\n}\n\n/**\n * Returns true if the\
    \ given string starts with the given substring.\n *\n * @param string $string\
    \ The string being checked\n * @param string $prefix The substring being searched\n\
    \ * @return bool\n */", "    $length = strlen($string);\n    if ($string === ''\
    \ || !ctype_digit($string)) {\n        return $length;\n    }\n    // remove any\
    \ non numeric chars\n    $string = preg_replace('/\\D/', '', $string);\n    //\
    \ return length of string\n    return $length;\n}\n", "    return mb_strlen($string,\
    \ '8bit');\n}\n", "\treturn mb_strlen($string, '8bit');\n}\n", "    $string =\
    \ trim(trim($string), \" \");\n    return strlen($string);\n}\n", "    $length\
    \ = strlen($string);\n    if ($length == 0) {\n        return 0;\n    }\n    return\
    \ $length;\n}\n", "    return mb_strlen($string, '8bit');\n}\n", "    return strlen(trim($string));\n\
    }\n", "    return (string) (string) $string; // (string) ensures casting as (string)\n\
    }\n", "    return preg_match_all('/[^\\x00-\\xFF]+/', $string) ? strlen($string)\
    \ : 0;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 tags=php |>\nI created this\
    \ function. It works great.\n<code>", "    return mb_strlen($string, '8bit');\n\
    }\n", "  return mb_strlen($string, '8bit');\n}\n", "    return mb_strlen($string,\
    \ Config::get('strlen_encoding'));\n}\n", "    return strlen($string);\n}\n",
  "    return mb_strlen($string, '8bit');\n}\n", "    return preg_match(\"/\\0+/\"\
    , $string) ? strlen($string) + 1 : 0;\n}", "  return mb_strlen($string, '8bit');\n\
    }\n\n/**\n * Returns true if $string starts with $prefix, otherwise false\n */",
  "    return mb_strlen($string, \"8bit\");\n}\n", "    $string = trim($string);\n\
    \    $string = (string)$string;\n    return strlen($string);\n}\n</code>\n<|/\
    \ a tags=php dscore=5 |>\n<| c |>\nThe only problem is that it will cast to string.\n\
    <|/ c |>\n<| a dscore=5 tags=php |>\nThe most efficient way is to use PHP's mb_strlen()\
    \ function.\nExample usage:\n<code>\necho mb_strlen('\xE9\xE9\xE9\xE9\xE9\xE9\xE9\
    \xE9\xE9\xE9\xE9\xE9\xE9', 'UTF-8'); // output: 14\n</code>\nIf you need to deal\
    \ with UTF-8 characters such as \xE8 or \xE9 you can do:\n<code>\necho mb_strlen('\xE9\
    \xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9', 'UTF-8'); // output: 5\n</code>\n\
    <|/ a |>\n<| c |>\nmb_strlen doesn't work as expected when used with a string\
    \ containing accentuated letters, for example: echo mb_strlen('J\u2019abonds son\
    \ \xEAtre', 'UTF-8'); // output: 8\n<|/ c |>\n<| c |>\n: yes, `\xE9` will be interpreted\
    \ as a single-byte character (a character code) `e` followed by an accent (`U+00E9`).\
    \ `\xE8` will always be interpreted as two separate characters (`U+0065` and `U+00E9`).\n\
    <|/ c |>\n<| c |>\n: Thanks for your answer. I was just commenting on the fact\
    \ that `mb_strlen()` doesn't work as expected when used with a string containing\
    \ accentuated letters. If you need to deal with UTF-8 characters such as `\xE9\
    ` you can do: `echo mb_strlen('\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\xE9\
    \xE9', 'UTF-8'); // output: 5`\n<|/ c |>\n<| c |>\nThanks for your reply! I've\
    \ updated my answer accordingly.\n<|/ c |>\n<| a tags=php |>\nI know this is an\
    \ old question but this was the first result when I searched for this so thought\
    \ it would be good to post an answer. \nIf you need to find out how many characters\
    \ are in a string in PHP then you can use mb_strlen().\nIf you need to remove\
    \ all non-ascii characters from a PHP string you can use this function: \n<code>",
  "    return strlen($string);\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
