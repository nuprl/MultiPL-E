name: HumanEval_31_is_prime
language: php
prompt: "<?php\n// Return true if a given number is prime, and false otherwise.\n\
  // >>> is_prime(6)\n// False\n// >>> is_prime(101)\n// True\n// >>> is_prime(11)\n\
  // True\n// >>> is_prime(13441)\n// True\n// >>> is_prime(61)\n// True\n// >>> is_prime(4)\n\
  // False\n// >>> is_prime(1)\n// False\nfunction is_prime($n) {\n"
tests: "function candidate(...$args) {\n    return is_prime(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(6) !== false) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(101) !== true) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(11) !== true) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(13441) !== true) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(61) !== true) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(4) !== false) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(1) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(5)\
  \ !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(11) !==\
  \ true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(17) !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(85) !== false) {\
  \ throw new Exception(\"Test failed!\"); }\n    if (candidate(77) !== false) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(255379) !== false) { throw\
  \ new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $m = (int) sqrt($n);\n    for ($i = 2; $i <= $m; $i++) {\n    \
    \    if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "    if ($n < 2) {\n        // If n is less than or equal to two,\
    \ then the number is not prime\n        return false;\n    }\n\n    // Check divisibility\
    \ by all primes up to sqrt(n)\n    // If n = 2, the only even prime is 2, so any\
    \ even number can be checked for divisibility by 2\n    if ($n <= 7) {\n     \
    \   for ($i = 3; $i <= sqrt(($n + 2)); $i += 2) {\n            if ($n % $i ==\
    \ 0) {\n                return false;\n            }\n        }\n\n        return\
    \ true;\n    }\n\n    // Check divisibility by 2, 3, 5, 7 and 11\n    // If n\
    \ = 11 (mod 3), then 11 cannot be checked for divisibility by 2, so any even number\
    \ can not be checked for divisibility by 2, so any odd number must be checked\
    \ for divisibility by 3\n    if ($n <= 11) {\n        for ($i = 3; $i <= sqrt(($n\
    \ + 2)); $i += 2) {\n            if ($n % $i == 0) {\n                return false;\n\
    \            }\n\n            if ($i % 3 == 0) {\n                return false;\n\
    \            }\n        }\n\n        return true;\n    }\n\n    // Check divisibility\
    \ by 3 and 7\n    // If n = 3 (mod 7), then 3 cannot be checked for divisibility\
    \ by 2, so any even number can not be checked for divisibility by 2, so any odd\
    \ number must be checked for divisibility by 3\n    if ($n <= 3) {\n        for\
    \ ($i = 3; $i <= sqrt(($n + 2)); $i += 2) {\n            if ($n % $i == 0) {\n\
    \                return false;\n            }\n\n            if ($i % 7 == 0)\
    \ {\n                return false;\n            }\n        }\n\n        return\
    \ true;\n    }\n\n    // Check divisibility by 5 and 11\n    // If n = 5 (mod\
    \ 11), then 5 cannot be checked for divisibility by 2, so any even number can\
    \ not be checked for divisibility by 2, so any odd number must be checked for\
    \ divisibility by 3\n    if ($n <= 5) {\n        for ($i = 3; $i <= sqrt(($n +\
    \ 2)); $i += 2) {\n            if ($n % $i == 0) {\n                return false;\n\
    \            }\n\n            if ($i % 11 == 0) {\n                return false;\n\
    \            }\n        }\n\n        return true;\n    }\n\n    // Check divisibility\
    \ by 7 and 11\n    // If n = 7 (mod 11), then 7 cannot be checked for divisibility\
    \ by 2, so any even number can not be checked for divisibility by 2, so any odd\
    \ number must be checked for divisibility by 3\n    if ($n <= 7) {\n        for\
    \ ($i = 3; $i <= sqrt(($n + 2)); $i += 2) {\n            if ($n % $i == 0) {\n\
    \                return false;\n            }\n\n            if ($i % 11 == 0)\
    \ {\n                return ", "    if ($n <= 1) {\n        return false;\n  \
    \  }\n\n    // Sieve of Eratosthenes http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    $primes = array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97);\n    $is_prime = true;\n    $sq = $n;\n\
    \n    while ($is_prime && $sq > 1) {\n        foreach ($primes as $prime) {\n\
    \            if ($sq % $prime === 0) {\n                $is_prime = false;\n \
    \               break;\n            }\n        }\n        $sq = $sq / 2;\n   \
    \ }\n\n    return $is_prime;\n}\n", "  if ($n <= 1) return false;\n  if ($n ==\
    \ 2) return true;\n  if ($n % 2 == 0) return false;\n\n  $n_minus_2 = $n - 2;\n\
    \  for ($i = 3; $i <= $n_minus_2; $i += 2) {\n    if ($n % $i == 0) return false;\n\
    \  }\n\n  return true;\n}\n</code>\n<|/ q |>\n<| c |>\nThe only solution is to\
    \ not use recursion. If you're going to use recursion, you need to find a way\
    \ to break the recursion before it reaches the limit of memory.\n<|/ c |>\n<|\
    \ c |>\nWhat do you think you should be getting as a result? Because the answer\
    \ isn't going to be `5` nor is it going to be `6`.\n<|/ c |>\n<| c |>\nI thought\
    \ I was getting that as an answer but maybe I'm missing something obvious. But\
    \ how would I rewrite this using an iterative approach?\n<|/ c |>\n<| c |>\nDo\
    \ you want just a single result or all numbers between a certain range?\n<|/ c\
    \ |>\n<| c |>\nAll numbers between two given numbers.\n<|/ c |>\n<| a tags=php\
    \ dscore=2 |>\nRecursive function are bad\nRecursive functions are bad because\
    \ it runs out of memory and can lead to stack overflows.\nUse a loop instead\n\
    <code>\nfor ($i = $number1; $i <= $number2; $i++) {\n    if (is_prime($i)) {\n\
    \        echo \"$i is prime\";\n    }\n}\n</code>\nTo do the same with recursion\n\
    <code>", "    $test = 2;\n    while($test * $test <= $n) {\n        if($n % $test\
    \ == 0) {\n            return false;\n        }\n        $test++;\n    }\n   \
    \ return true;\n}\n", "    $n = abs($n);\n    if ($n < 1) return false;\n    $limit\
    \ = $n-1;\n    $sqrtn = sqrt(($n+1));\n    for($i=2;$i<$limit;$i++) {\n      \
    \  if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "  if ($n <= 3) return $n == 2 || $n == 3 || $n == 5 || $n == 7;\n\
    \  $test = 2; $d = 6; $m = 2; $p = 2; $q = 6; $x = 3;\n  while ($n > $test) {\n\
    \    if ($n % $test != 0) {\n      $d = $d * ($p + ($x % $p));\n      $m = $m\
    \ + ($q % $q);\n      $p = $p * ($x % $x);\n      $q = $q * ($q % $q);\n     \
    \ $x = $x * $x;\n    }\n    $test = $test * $test;\n    $n = $n - $test;\n  }\n\
    \  if ($m != $n) return $n == 2 || $n == 3 || $n == 5 || $n == 7;\n  if ($d ==\
    \ 6) return $n == 3; else return $n <= 1;\n}\n", "    $i = 2;\n    while (is_prime($i))\
    \ {\n        if ($n % $i == 0) {\n            return false;\n        }\n     \
    \   $i++;\n    }\n    return true;\n}", "    $n--;\n    if ($n < 2) {\n      \
    \  return false;\n    }\n    // Hundreds of millions of times faster than most\
    \ of our big prime numbers.\n    if ($n % 2) {\n        return false;\n    }\n\
    \    if ($n & 1) {\n        return false;\n    }\n\n    $i = 52;\n    while ($i\
    \ >= 5) {\n        $i--;\n        $k = pow($i, 2) - 1;\n        if ($k > 0) {\n\
    \            if ($n !== $i && $n % $k === 0) {\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=php,python,algorithm,math\
    \ |>\n<| c |>\nThis isn't a primality test. It tests whether the number is divisible\
    \ by 2, 3, 5, 7 and 11, which is not the same as whether it is the [prime number](http://mathworld.wolfram.com/PrimeNumber.html).\
    \ This is a more computationally expensive and less reliable algorithm.\n<|/ c\
    \ |>\n<| c |>\n- Good point. I'll edit my post to include a link to a better description\
    \ of primality testing, however.\n<|/ c |>\n<| c |>\nThe [Sieve of Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin)\
    \ is a good prime number test that checks if a number is prime in logarithmic\
    \ time. `is_prime(n): if n is prime return True, else return False`\n<|/ c |>\n\
    <| c |>\nThe Sieve of Atkin is much more expensive than my solution. My solution\
    \ requires O(N**2) time, whereas Sieve is O(N). Both are linear in the number\
    \ of iterations, but the latter requires more memory than the former requires\
    \ more time to generate. My solution is more \"efficient\" because it only generates\
    \ primes up to N (which may or may not be significantly less memory than what\
    \ your server has).\n<|/ c |>\n<| c |>\n: I agree with your statement that Sieve\
    \ is O(N). But if you have a look at my code: `$n = 5; while($n < $N) { $primes[$n]\
    \ = $n; $n = $n*2; ... }`, the number of iterations are much larger than the prime\
    \ numbers themselves. `while ($n < $N) { ...` will be iterated N times. So it's\
    \ not O(N^2), it's O(N).\n<|/ c |>\n<| a |>\nHere is an example of how to implement\
    \ a faster sieve using the Sieve of Atkin algorithm and here is an example of\
    \ how to implement a faster sieve\nHere are some benchmarks that show that the\
    \ Sieve ", "  if ($n <= 1)\n    return FALSE;\n  // Test for divisibility by all\
    \ odd numbers up to sqrt(n).\n  for ($i = 3; $i <= sqrt($n); $i += 2)\n    if\
    \ ($n % $i == 0)\n      return FALSE;\n  return TRUE;\n}", "  if (!is_numeric($n)\
    \ || $n < 2 || $n == 0)\n    return false;\n\n  // Trial divider other than 1\
    \ is of no use.\n  // >>> is_prime(6)\n  // False\n  // >>> is_prime(93)\n  //\
    \ False\n  // >>> is_prime(8)\n  // False\n  // >>> is_prime(2)\n  // True\n \
    \ for ($i = 3; $i <= sqrt($n); $i += 2) {\n    if ($n % $i == 0)\n      return\
    \ false;\n  }\n\n  return true;\n}\n</code>\nAnd this is how you test it out:\n\
    <code>\n$ ./test.php\n5 is prime\n101 is prime\n11 is prime\n13441 is prime\n\
    61 is prime\n4 is prime\n1 is prime\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere\
    \ is a fast way to determine whether a number is a prime.  Just run it until the\
    \ number you are checking doesn't divide evenly into the next number.  If it does,\
    \ it's prime.  If you run it a second time, it will tell you if your number is\
    \ prime since you already know it's not prime.\n<code>\nbool IsPrime(int number)\n\
    {\n    bool result = false;\n\n    for (int i = 2; i < number; i++)\n    {\n \
    \       if (number % i == 0)\n        {\n            result = true;\n        \
    \    break;\n        }\n    }\n\n    return result;\n}\n</code>\n<|/ a tags=php\
    \ dscore=1 |>\n<| a tags=php |>\nThe first thing you want to do is make sure the\
    \ number you are passing into the function is an integer.  If it is not, you can\
    \ add an if statement to ensure the number is an integer and not an alphanumeric\
    \ character.\n<code>", "  // Return false if the number is 1 or less.\n  if ($n\
    \ < 2) {\n    return false;\n  }\n\n  // Return true if only a single digit is\
    \ in the number.\n  if ($n === 2 || $n === 3) {\n    return true;\n  }\n\n  //\
    \ Return false if there are an odd number of digits, or if the\n  // number is\
    \ greater than 2.\n  if (strlen((string) $n) % 2 === 0) {\n    return false;\n\
    \  }\n\n  // Cache the square root of $n (sqrt(sqrt(5))).\n  $sqrt5 = sqrt(($n\
    \ + 1) / 5);\n\n  // Return true if $n is prime and less than or equal to $sqrt5.\n\
    \  return (bool) ($sqrt5 <= sqrt($n));\n}\n", "    // Return true if the number\
    \ is prime and false otherwise.\n    // >>> is_prime(6)\n    // False\n    //\
    \ >>> is_prime(101)\n    // True\n    // >>> is_prime(11)\n    // True\n    //\
    \ >>> is_prime(13441)\n    // True\n    // >>> is_prime(61)\n    // True\n   \
    \ // >>> is_prime(4)\n    // False\n    // >>> is_prime(1)\n    // False\n   \
    \ if (is_int($n) && $n < 2) return false;\n    $n = (int) $n;\n    $i = 1;\n \
    \   while (true) {\n        if ($n % $i == 0) return false;\n        $i++;\n \
    \   }\n    return true;\n}\n", "  $n = (int)$n;\n  for ($i = 2; $i <= sqrt($n);\
    \ $i++) {\n    if ($n % $i == 0)\n      return false;\n  }\n  return true;\n}\n",
  "    $n = abs($n);\n\n    if ($n < 2) {\n        return false;\n    }\n\n    //\
    \ The special case n == 0 is handled in a single if statement\n    if ($n == 0)\
    \ {\n        return true;\n    }\n\n    // Factorization is very simple.\n   \
    \ // If a number is evenly divided by any number other than 1 and it\n    // is\
    \ greater than 1 then it is divisible by all numbers from 2 to\n    // sqrt(n).\n\
    \    // Therefore, all prime numbers must have the form 6k + 1 or 6k - 1\n   \
    \ // where k is a non-negative integer.\n    // For example: 5 is prime, since\
    \ it is the base case (we call this\n    // the trivial case), and all other powers\
    \ of 5 are of form 6k + 1 or\n    // 6k - 1.\n    //\n    // 6k + 1 or 6k - 1\
    \ has exactly the same prime factors as k, so\n    // no further tests are necessary.\n\
    \    //\n    // The other prime case that is not handled by the special case\n\
    \    // above is 5n - 1. The factors of n other than n itself are 6n + 1 or\n\
    \    // 6n - 1, and n is divisible by either 6n+1 or 6n-1.\n    // For example:\
    \ 5n + 1 is the trivial case where n = 10 + 7 - 1 and\n    // n = 10 + 7 + 1 which\
    \ are both factors of 10.\n    //\n    // Therefore, we can define the trivial\
    \ case as being the base case of\n    // a general prime test that is divisible\
    \ by all numbers from 2 to\n    // sqrt(n).\n    //\n    // In the general case,\
    \ we will factor the number to be tested as\n    // n^(6k + 1).\n    // If n =\
    \ 10^k + 7 then 10^k + 1 = 10(k + 1) and 10^k + 7 = 10(k + 7)\n    // Therefore,\
    \ 10^k = 6k + 1 where k = ceiling(log(n) / log(6))\n    // Therefore, k = ceil(log(n)\
    \ / log(6)).\n    // The base case is 6k + 1 = 6 * ceiling(log(n) / log(6)).\n\
    \    // Therefore, k = ceil(log(n) / log(6)).\n    // 6*ceiling(log(n) / log(6))\
    \ = 6k + 1 = 6 * ceil(log(n) / log(6))\n    //\n    // The first such 6k + 1 number\
    \ that is not evenly divisible by\n    // 2 is then obviously 6.\n    // Since\
    \ 2 is the first number that is not evenly divisible by 2, 6k + 1 is\n    // the\
    \ first such number that is also not evenly divisible by 2. 6k + 1\n    // is\
    \ thus the smallest number that evenly divides n.\n    //\n    // Therefore, the\
    \ algorithm ", "  $count = self::count_primes($n);\n  return ($count !== false\
    \ && $count !== NULL) ? $count : false;\n}\n", "  if ($n <= 1)\n    return false;\n\
    \n  // Trial division using the Sieve of Eratosthenes\n  // http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \  $squareRoot = $this->sqrt($n);\n\n  $array = [$n];\n  for ($i = 2; $i <= $squareRoot;\
    \ $i++) {\n    if ($n % $i == 0)\n      return false;\n    $array[] = $i;\n  }\n\
    \n  return true;\n}\n\n$number = 51;\n$prime = new PrimeFinder($number);\n$primes\
    \ = $prime->find();\n\n$is_prime = is_prime($number);\n\n$is_prime2 = is_prime($number);",
  "  global $count;\n  $count++;\n  if ($count == 1)\n    return true;\n  if ($n ==\
    \ 1) {\n    if ($count == 2)\n      return true;\n    return false;\n  }\n  else\
    \ {\n    if ($n % 2 == 0) {\n      $n = ($n-1);\n      if ($n == 1)\n        return\
    \ true;\n      else\n        return false;\n    }\n    else {\n      for ($i =\
    \ 3; $i * $i <= $n; $i+=2)\n        if ($n % $i == 0)\n          return false;\n\
    \      return true;\n    }\n  }\n}\n", "    return $n == 2 || $n == 3 || !($n\
    \ % 2) && !($n % 3) && !($n % 5) && $n != 1;\n}\n", "    if ($n == 1)\n      \
    \  return false;\n    $m = 2;\n    while ($m <= sqrt($n))\n        if ($n % $m\
    \ == 0)\n            return false;\n        $m++;\n    return true;\n}", "   \
    \ $num = (int) sqrt($n); // Only need to test up to square root.\n    $root2 =\
    \ (int) pow($num, 1/2.0); // Only need to test up to 0.5\n    $root3 = (int) pow($num,\
    \ 1/3.0);\n    if ($n < 7) return ($n == 1) || ($n == 2) || ($n == 3);\n    if\
    \ ($n % 2 == 0) return false;\n    if ($n == 2) return true;\n    if ($n % 3 ==\
    \ 0) return false;\n\n    for ($i = 5; $i <= $num; $i += 6) {\n        $root4\
    \ = $i * $i - 4 * $i * $num + $num;\n        if ($root4 <= 0) return false;\n\
    \        if ($root4 < $root2) return true;\n    }\n\n    return false;\n}", " \
    \   $limit = (int)sqrt(($n + 1) >> 1);\n    $limit2 = (int)sqrt(($limit + 1) >>\
    \ 1);\n    if ($n <= 1) return false;\n    for ($i = 2; $i < $limit; $i++) {\n\
    \        if ($n % $i == 0)\n            return false;\n    }\n    return true;\n\
    }\n", "\tif ($n <= 1) {\n\t\treturn false;\n\t}\n\tif ($n == 2) {\n\t\treturn\
    \ true;\n\t}\n\tif ($n % 2 == 0) {\n\t\treturn false;\n\t}\n\t$a = 5; // Factor\
    \ of five for searching.\n\t$b = 5; // Factor of five for iteration.\n\tfor ($i\
    \ = 5; $i * $i <= $n; $i += 2) {\n\t\tif ($n % $i == 0) {\n\t\t\treturn false;\n\
    \t\t}\n\t\twhile ($a * $i <= $n) {\n\t\t\tif ($n % $i == 0) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\t$a++;\n\t\t}\n\t\t$b++;\n\t}\n\treturn true;\n}\n", " \
    \ // Write your code here\n  if ($n <= 1) {\n    return true;\n  }\n\n  for ($i\
    \ = 2; $i <= sqrt($n); ++$i) {\n    if ($n % $i == 0) {\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "    // Check for oddity.\n    if ($n % 2\
    \ == 0) {\n        // The number is odd.\n        return false;\n    }\n\n   \
    \ // The number is odd, but it doesn't have the property that all of its\n   \
    \ // factors are prime.\n    $num_divisors = range(1, $n/2 + 1);\n\n    // Use\
    \ Eratosthenes to compute the primes in the prime factorization of the\n    //\
    \ number.\n    foreach ($num_divisors as $num_divisor) {\n        if ($n % $num_divisor\
    \ == 0) {\n            return false;\n        }\n    }\n\n    // All of the number's\
    \ factors are prime.\n    return true;\n}\n", "  // Trial division with sieve.\n\
    \  $n = 3 * $n - 2;\n  $x = 2;\n  for ($i = 3; $i <= sqrt($n); $i += 2) {\n  \
    \  if (!isset($sieve[$i])) {\n      $sieve[$i] = $x;\n      $x = ($x * $x) + 1;\n\
    \    }\n  }\n  unset($sieve[3]);\n\n  if ($n < 1373653) {\n    for ($i = 2; $i\
    \ <= $n; $i += 2) {\n      if (!isset($sieve[$i])) {\n        $sieve[$i] = $i;\n\
    \      }\n    }\n  }\n\n  return !isset($sieve[$n]);\n}\n", "  // We only need\
    \ to go up to sqrt(n), as even numbers are not\n  // composite, but if we do go\
    \ up to sqrt(n), some composites are\n  // much faster.\n  // See Sieve of Eratosthenes\
    \ for more information.\n  for($i = 2; $i <= sqrt($n); $i++) {\n    if($n % $i\
    \ == 0)\n      return false;\n  }\n  return true;\n}\n", "  // Check argument\n\
    \  if(is_null($n)) {\n    throw new InvalidArgumentException('is_prime() expects\
    \ at least 2 arguments');\n  }\n  // Initialization\n  $factors = range(2, $n-1);\n\
    \  // Test if n is prime\n  if($n == 2 || $n == 3) {\n    return true;\n  }\n\
    \  // Test if n is even and larger than 3\n  if($n % 2 == 0 || $n == $n - 3) {\n\
    \    return false;\n  }\n  // Test if n is composite and larger than 3\n  foreach($factors\
    \ as $factor) {\n    if($n % $factor == 0 || $n == ($factor * $n)) {\n      return\
    \ false;\n    }\n  }\n  // If n is composite and larger than 3, then it is a prime\n\
    \  return true;\n}\n</code>\n<|/ a tags=php,number-theory,algorithm,primes |>\n\
    <| a tags=php,number-theory,algorithm,primes dscore=3 |>\nIf you're doing this\
    \ in PHP, you can use the Sieve of Eratosthenes (http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ algorithm.\n<|/ a |>\n<| c |>\nSieve of Eratosthenes is a more generalized form\
    \ of the Sieve of Atkin, also known as Sieve of Eels.\n<|/ c |>\n<| a dscore=3\
    \ tags=php,number-theory,algorithm,primes |>\nYes, you can do it with Sieve of\
    \ Eratosthenes algorithm. I wrote a small function to do this in PHP. Here is\
    \ the code (I hope you will not mind it):\n<code>\n/**\n * Return array of prime\
    \ numbers from 1 to $limit\n * \n * int $limit\n * \n * array\n */", "    if (!is_numeric($n)\
    \ || $n < 1) {\n        throw new Exception('is_prime expected a positive integer.');\n\
    \    }\n    // http://stackoverflow.com/questions/5143037/sieve-of-eratosthenes-php-implementation\n\
    \    $n = abs($n);\n    $max_check = ceil($n ** .25); // square root of $n\n \
    \   for ($i = 2; $i <= $max_check; $i++) {\n        $check_primes[$i] = $n % $i;\n\
    \        if ($check_primes[$i] == 0) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n\n$data = array();\n$data['time'] = microtime(true);\n\
    for($i=0;$i<1000000;$i++) {\n    $data['i'] = $i;\n}\nksort($data);\n$data['time']\
    \ = microtime(true) - $data['time'];\necho $data['time'].' seconds';", "    $limit\
    \ = 6;\n    $test = 2;\n    $counter = 0;\n    while ($counter < $limit && $test\
    \ <= $n) {\n        if ($n % $test === 0) {\n            $counter++;\n       \
    \ } else {\n            $test++;\n        }\n    }\n\n    return ($counter ==\
    \ $limit);\n}\n", "\t$counter = 1;\n\t$multiplier = 1;\n\twhile ($multiplier <\
    \ $n) {\n\t\tif ($n % $multiplier == 0) {\n\t\t\t$counter++;\n\t\t}\n\t\t$multiplier++;\n\
    \t}\n\treturn ($counter == 1);\n}", "    // If n is less than 2 then all prime\
    \ numbers are less than 2\n    if ($n < 2) {\n        return true;\n    }\n\n\
    \    // Check if the number can be divided by any numbers from 2 to n-1\n    //\
    \ and if so then it isn't prime\n    for ($i = 2; $i <= $n; $i++) {\n        if\
    \ ($n % $i == 0) {\n            return false;\n        }\n    }\n\n    // If n\
    \ is greater than or equal to 2 then every number greater than 2\n    // and less\
    \ than or equal to n-1 is prime\n    return true;\n}\n", "    // return $n <=\
    \ 2;\n    if ($n < 2) {\n        return $n >= 2;\n    }\n    if ($n == 2 || $n\
    \ == 3) {\n        return true;\n    }\n    $i = 2;\n    $isPrime = true;\n  \
    \  while ($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n            $isPrime\
    \ = false;\n            break;\n        }\n        $i++;\n    }\n    return $isPrime;\n\
    }", "    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n   \
    \     return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n   \
    \ }\n\n    // Now the number is odd, so we'll start trial division from\n    //\
    \ 3 to sqrt($n). The odd number $i is then the square root of $i plus one.\n \
    \   $i = 1;\n    $j = 0;\n    while ($i <= sqrt($n)) {\n        $j++;\n      \
    \  $i += $j;\n    }\n\n    // If we get here, we're guaranteed to get to the last\
    \ one,\n    // which means $i is the last odd number with a factor of $n.\n  \
    \  $i = $j + 1;\n\n    // Now let's just test the odd numbers from 3 to $i, and\n\
    \    // see if they have no factors greater than $n.\n    foreach (range(3, $i,\
    \ 2) as $k) {\n        if ($n % $k == 0) {\n            return false;\n      \
    \  }\n    }\n\n    return true;\n}", "    if ($n <= 1) return false;\n\n    $limit\
    \ = (int) sqrt($n);\n\n    for ($i = 2; $i <= $limit; $i++) {\n        if ($n\
    \ % $i == 0) return false;\n    }\n\n    return true;\n}", "    // 1. If n is\
    \ less than 2, return false\n    if ($n < 2) {\n        return false;\n    }\n\
    \n    // 2. If n is odd, return false\n    if ($n % 2 === 0) {\n        return\
    \ false;\n    }\n\n    // 3. if n is less than 3, return true\n    if ($n < 3)\
    \ {\n        return true;\n    }\n\n    // 6. Let m be the smallest integer greater\
    \ than or equal to n that is divisible by n.\n    // 7. Let k be n.\n    // 8.\
    \ While k < m, k += k + 1. Increase k by 1.\n    // 9. Return false.\n    // 10.\
    \ Return true if n is a prime number.\n    // For large values of n, this loop\
    \ might never terminate.\n\n    $m = $n + (int)($n - 1) / 2; // If $n == 6, $m\
    \ == 5.\n\n    while (true) {\n        $k = sqrt($n);\n        if ($k > $m) {\n\
    \            return false;\n        }\n        if ($n % $k == 0) {\n         \
    \   return true;\n        }\n        $n = $k + 1;\n    }\n}\n", "    $count =\
    \ count($factors = array());\n    for($x = 2; $x <= $n; $x++) {\n        if(!isset($factors[$x]))\
    \ {\n            for($i = 1; $i * $i <= $n; $i++) {\n                if($n % $i\
    \ == 0) {\n                    $factors[$x] = $i;\n                    $count--;\n\
    \                }\n            }\n        }\n    }\n    return $count == 0;\n\
    }\n", "    $start = 2;\n    if ($n <= 1)\n        return false;\n    if ($n %\
    \ 2 == 0 || $n <= 3)\n        return true;\n\n    while ($start <= $n) {\n   \
    \     if ($n % $start == 0 || $n % $start == 1 || $n % $start == 2)\n        \
    \    return false;\n        $start++;\n    }\n    return true;\n}\n", "    $result\
    \ = true;\n    for ($div = 3; $div <= sqrt($n); $div++) {\n        if ($n % $div\
    \ == 0) {\n            $result = false;\n        }\n    }\n    return $result;\n\
    }\n\necho \"$n $primes<br>\";\nfor ($i = 0; $i < $n; $i++) {\n    if (is_prime($i))\
    \ {\n        echo \"$i \";\n        $primes++;\n    }\n}\necho \"$n $primes<br>\"\
    ;", "    if ($n <= 1 || $n >= 100) return $n%2 == 0 || $n%3 == 0;\n    for($a\
    \ = 2; $a <= sqrt($n); $a++) {\n        if (($n % $a == 0) && ($n != $a && ($n%$a\
    \ == 0 || $n%$a != 0))) return false;\n    }\n    return true;\n}", "    if ($n\
    \ == 0)\n        return false;\n    if ($n == 1)\n        return true;\n    if\
    \ ($n == 2)\n        return true;\n    if ($n % 2 == 0)\n        return false;\n\
    \n    $a = floor($n/2);\n\n    if ($n % $a == 0) {\n        return is_prime($n);\n\
    \    } else {\n        return false;\n    }\n}\n", "    if (!is_numeric($n)) {\n\
    \        return false;\n    }\n\n    if ($n < 2) {\n        return false;\n  \
    \  }\n\n    // Only prime numbers can be factors of 2, 3, and 5.\n    // If n\
    \ is divisible by 3, then it's also not prime (unless n is 5).\n    // If n is\
    \ divisible by 5, then it's prime.\n    $divisors = array(1, 3, 5);\n    foreach\
    \ ($divisors as $divisor) {\n        if ($n % $divisor === 0) {\n            return\
    \ false;\n        }\n    }\n\n    // If n is prime then it's a prime number.\n\
    \    return true;\n}\n", "    // Return false if n is less than or equal to zero.\n\
    \    if ($n <= 0)\n        return false;\n    // Return true if the number has\
    \ no divisors less than or equal to n.\n    return !($n-1 % $n);\n}\n", "  //\
    \ Coerce n to int to avoid problems with floats.\n  $n = intval($n);\n  if ($n\
    \ < 2) {\n    return false;\n  }\n  // Check for primes up to sqrt(n).\n  for\
    \ ($m = 2; $m < $n; $m++) {\n    if ($n % $m == 0) {\n      return false;\n  \
    \  }\n  }\n  return true;\n}\n", "    if ($n < 2) {\n        return false;\n \
    \   }\n    if ($n & 1) { // is odd\n        return false;\n    }\n    $n++;\n\
    \    $k = 2;\n    while ($k < $n) {\n        if ($n % $k === 0) {\n          \
    \  return false;\n        }\n        $k++;\n    }\n    return true;\n}\n", " \
    \ if ($n == 1) {\n    return true;\n  }\n  if (!is_prime($n-1)) {\n    return\
    \ false;\n  }\n  for ($i = 2; $i * $i <= $n; $i++) {\n    if ($n % $i == 0) {\n\
    \      return false;\n    }\n  }\n  return true;\n}", "    $sqrt = sqrt($n);\n\
    \    $root2 = $sqrt * $sqrt;\n    \n    // return true if $n is prime and false\
    \ otherwise\n    return !( $n < 2 || $n % 2 == 1 || $n % $root2 == 0 || \n   \
    \            ( $n % $root2 > 1 && \n                 ( $n % $root2 != 1 && $n\
    \ % $root2 != $root2 || $n % $root2 != 2 ) ) ); \n}\n", "    if ($n < 2) {\n \
    \       return false;\n    }\n    \n    // Make sure n is a positive integer\n\
    \    $n = abs($n);\n    \n    // Set $i to 2\n    $i = 2;\n    \n    // Loop while\
    \ $i * $i <= $n\n    while ($i * $i <= $n) {\n        if ($n % $i == 0) {\n  \
    \          return false;\n        }\n        \n        $i += 2;\n    }\n    \n\
    \    // If we reached this point, $n is prime\n    return true;\n}\n", "  if ($n\
    \ < 2) {\n    return false;\n  }\n\n  // Trial division with sieve.\n  $num =\
    \ intval($n);\n  foreach (new Sieve(array($num)) as $prime) {\n    if ($num %\
    \ $prime === 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", " \
    \ if ($n <= 1) return false;\n  \n  // Initialize Sieve of Eratosthenes\n  $sieve\
    \ = array(1,1); \n  \n  // Check all odd numbers up to N\n  for ($i = 2; $i <=\
    \ $n; $i++) {\n    if ($sieve[$i]) continue;\n    \n    // Set $i to multiples\
    \ of $n\n    for ($j = $i*$n; $j <= $n; $j += $i) {\n      $sieve[$j] = true;\n\
    \    }\n  }\n  \n  // Check if N is prime\n  return $sieve[$n];\n}", "    if ($n\
    \ < 2) {\n        return false;\n    }\n    if ($n <= 5) {\n        return true;\n\
    \    }\n\n    // Check all the numbers of the form 6k+1 or 6k-1\n    // to see\
    \ if any of them are factors.\n    for ($i = 3; $i * $i <= $n; $i += 2) {\n  \
    \      if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}", "  $limit = sqrt($n);\n  for($i = 1; $i <= $limit; $i++) {\n    if($n\
    \ % $i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  // 2\
    \ is a special case\n  if ($n != 2 && $n % 2 == 0) {\n    return false;\n  }\n\
    \n  // If we passed this test, we have eliminated all even numbers\n  // greater\
    \ than 2 without a remainder.\n  if ($n % 2 == 0) {\n    return false;\n  }\n\n\
    \  // No number greater than 3 can be composite without a\n  // remainder.\n \
    \ if ($n % 3 == 0) {\n    return false;\n  }\n\n  // Check all the numbers from\
    \ 5 to 9 to see if the first n\n  // numbers are relatively prime with each other.\n\
    \  for ($i = 5; $i <= 9; $i += 2) {\n    $c = fmod($n, $i);\n    if ($i != $c)\
    \ {\n      return false;\n    }\n  }\n\n  return true;\n}\n</code>\n<|/ a tags=primes,php,sieve-of-eratosthenes\
    \ |>\n<| c |>\nI like that one ! Thanks !\n<|/ c |>\n<| c |>\nThe first `for`\
    \ loop could be `for ($i = 5; $i <= sqrt($n); $i += 2)` and you don't need the\
    \ `if` statement inside of the `for` loop - you already eliminated all even numbers.\n\
    <|/ c |>\n<| c |>\nThanks. I didn't consider that. I also wasn't sure if he meant\
    \ prime numbers or primes less than n so I used both solutions. I edited the answer\
    \ to include both solutions.\n<|/ c |>\n<| c |>\nThis algorithm is quite fast,\
    \ but the result is wrong if the number is larger than `50000`. The problem is\
    \ the `fmod($n, $i)` which returns the modulus in decimal form. This causes big\
    \ numbers to lose precision and result in `False`. See [this question](https://stackoverflow.com/q/15031770/451475).\n\
    <|/ c |>\n<| a |>\n<code>", "  $is_prime = TRUE;\n  for ($i = 2; $i <= $n/2; $i++)\
    \ {\n    if ($n % $i == 0)\n      $is_prime = FALSE;\n  }\n  return $is_prime;\n\
    }\n\n$primes = array();\n$n = 20;\nfor ($i = 1; $i <= $n; $i++) {\n  $primes[]\
    \ = $i;\n}\n", "  if ($n <= 1) return false;\n  if ($n == 2) return true;\n  if\
    \ ($n % 2 == 0) return false;\n\n  // Trial division using Sieve of Eratosthenes.\n\
    \  $limit = (int) (sqrt($n) + 1);\n  for ($i = 2; $i <= $limit; ++$i) {\n    if\
    \ ($n % $i == 0) return false;\n  }\n\n  return true;\n}\n", "    $lower = 2;\n\
    \    $upper = (int) sqrt($n);\n    while($lower < $upper) {\n        if($n % $lower\
    \ == 0) {\n            return false;\n        }\n        $lower++;\n    }\n  \
    \  return true;\n}\n\n/**\n * Return the number of prime numbers less than or\
    \ equal to the given number.\n * \n * @param int $n the number to find prime numbers\
    \ less than or equal to.\n * @return int the number of prime numbers less than\
    \ or equal to the given number.\n */", "    return $this->_is_prime($n, 3);\n\
    }\n\n/**\n * Test if n is a prime, using the Sieve of Eratosthenes\n *\n * @param\
    \ int $n\n * @param int $max The max number to test\n * @return bool True if the\
    \ number is prime, false otherwise.\n */", "    if ($n < 2) {\n        return\
    \ false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i\
    \ == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "  if ($n < 2) {\n    return false;\n  }\n  if ($n < 6) {\n    return true;\n  }\n\
    \  $sqrt_n = sqrt($n);\n  for ($i = 3; $i * $i <= $sqrt_n; $i++) {\n    if ($n\
    \ % $i == 0) {\n      return false;\n    }\n  }\n  return true;\n}", "    // Primes\
    \ <=0 are handled separately\n    if ($n < 2) {\n        return false;\n    }\n\
    \n    // If n is odd, return only after dividing n by 2\n    if ($n & 1) {\n \
    \       return false;\n    }\n\n    // If n is even, check only if n-1 is even\n\
    \    if ($n & 2) {\n        return !($n == 2);\n    }\n\n    // Find first prime\
    \ number greater than n\n    $i = 3;\n    while ($i * $i <= $n) {\n        if\
    \ ($n % ($i * $i) == 0) {\n            return false;\n        }\n        $i +=\
    \ 2;\n    }\n\n    return true;\n}", "    if ($n < 2) {\n        return false;\n\
    \    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0)\
    \ {\n        return false;\n    }\n    $i = $n - 1;\n    while ($i > 0) {\n  \
    \      if ($n % $i == 0) {\n            return false;\n        }\n        $i /=\
    \ 2;\n    }\n    return true;\n}\n", "  global $count;\n  if (!isset($count))\
    \ {\n    $count = 1;\n  }\n  if ($n <= 1) return false;\n  if ($n == 2 || $n ==\
    \ 3) return true;\n  if ($n % 2 == 0 || $n % 3 == 0) return false;\n  for ($i\
    \ = 5; $i * $i <= $n; $i += 6) {\n    if ($n % $i == 0 || $n % ($i + 2) == 0)\
    \ return false;\n  }\n  return true;\n}\n", "    // Write your PHP-fu here.\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThere are some good answers above that\
    \ cover a lot of your bases, but I wanted to mention that you don't need so much\
    \ code. Here are some good solutions that I've used before:\n<code>", "    $n++;\n\
    \    foreach (array(3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47) as $lp)\
    \ {\n        $x = ($n >> $lp) & 1;\n        if ($x || ($n & $x && ($n & 1 || $n\
    \ % $x == 0))) {\n            return false;\n        }\n    }\n    return true;\n\
    }", "  $n = abs($n);\n  if($n < 1) {\n    return false;\n  }\n\n  $count = array(\
    \ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97 );\n  for($i = 2; $i < $n; ++$i) {\n    if(!isset($count[$i]))\
    \ {\n      $x = $i;\n      for($j = 0; $j < $n; $j += $x) {\n        $x = $x *\
    \ $x + 1;\n      }\n      $count[$i] = $x ? $x - 1 : 0;\n    }\n    if(!isset($count[$i]))\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| a tags=algorithm,php dscore=0 |>\n<code>\n<?php ", "  global $generator;\n\
    \  $a = $generator->random(2);\n  while ($a < $n) {\n    $a = $generator->random(2);\n\
    \  }\n  return $n % $a == 0;\n}\n", "    if ($n < 2) {\n        return false;\n\
    \    }\n\n    // If n is prime itself, then certainly it must be prime-squared\n\
    \    // to have any factor greater than 2, so if n was already known\n    // to\
    \ be prime then there's no need to check any smaller\n    // factors.\n    if\
    \ ($n & 1) {\n        return false;\n    }\n\n    $n = $n - 1;\n    for ($i =\
    \ 3; $i * $i <= $n; $i++) {\n        if ($n % ($i * $i) == 0) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "    $n = abs($n);\n\n   \
    \ // Special cases: 1,3,5,7...\n    if ($n < 2) {\n        return false;\n   \
    \ }\n\n    // Check divisibility by 2, 3, 5, 7...\n    $sqrt_n = sqrt(($n + 1)\
    \ | 0);\n    for($i = 2; $i <= $sqrt_n; $i++) {\n        if ($n % $i == 0) {\n\
    \            return false;\n        }\n    }\n\n    // Check divisibility by 3\
    \ and 5\n    $sqrt_n2 = sqrt(($sqrt_n + 1) | 0);\n    for($i = 2; $i <= $sqrt_n2;\
    \ $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n\
    \    }\n\n    return true;\n}\n", "  if ($n < 2) {\n    return false;\n  }\n \
    \ else if ($n == 2 || $n == 3) {\n    return true;\n  }\n  else {\n    $factor\
    \ = 2;\n    $p = 1;\n    while (pow($factor, $n) != $n) {\n      $p++;\n     \
    \ $factor = round($factor * $p, 10);\n    }\n    return $p == $n;\n  }\n}\n",
  "  $factors = array(2, 3);\n  for($i = 0; $i < count($factors); $i++) {\n    if($n\
    \ % $factors[$i] == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "    // Make sure n is greater than or equal to 1.\n    if ($n < 1) {\n        return\
    \ false;\n    }\n\n    // Check if n is even.\n    if ($n % 2 == 0) {\n      \
    \  // If n is even, return true.\n        return true;\n    }\n\n    // Check\
    \ all the numbers in the range from 2 to n to see if they divide\n    // n, or\
    \ if the number is prime (so return true).\n    for ($i = 2; $i <= $n; $i++) {\n\
    \        if ($n % $i == 0) {\n            return false;\n        }\n    }\n\n\
    \    // If we've got here, all numbers in the range from 2 to n must be factors\n\
    \    // of n. If we've got here, all numbers in the range from 2 to n must be\n\
    \    // prime numbers. If we've got here, n is not prime (so return false).\n\
    \    return true;\n}\n", "  if ($n < 2) {\n    return false;\n  }\n\n  foreach\
    \ (range(1, $n - 1) as $i) {\n    if ($n % $i === 0) {\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n</code>\nThe first two functions are straightforward.\
    \ The third function generates all the numbers that satisfy the condition, and\
    \ returns the array.\nThe second two functions work by generating a random number\
    \ (between 1 and $n) then seeing if that number divides the current number. \n\
    The first function checks if the number is prime (is 1 or greater), while the\
    \ second checks whether the number is divisible by any number between 1 and $n-1.\n\
    The second function takes a number, $n, and returns an array where each element\
    \ is the result of is_prime($n) and the index is the number itself.\n<|/ a dscore=3\
    \ |>\n<| c |>\nThank you! I still can't quite grasp what's going on with these\
    \ functions, but I think I understand it now. Thank you!\n<|/ c |>\n<| c |>\n\
    Having trouble finding this in the PHP documentation ... where can i learn more\
    \ about these functions?\n<|/ c |>\n<| a |>\n<code>\n$primes=array();\n$primes[2]\
    \ = 1;\nfor($i=3;$i<=sqrt($n);$i++){\n    if($i%2==0){\n        $primes[]=$i;\n\
    \    }else{\n        for($j=0;$j<count($primes);$j++){\n            if($i%$primes[$j]==0){\n\
    \                $primes[$j]=0;\n            }\n        }\n    }\n}\nprint_r($primes);\n\
    </code>\n<|/ a dscore=3 tags=php,primes |>\n<| c |>\nPlease explain the code in\
    \ your answer and how it solves the original problem.\n<|/ c |>\n<| c |>\n, Thank\
    \ you, but I think it's too difficult for someone who does not know this language.\n\
    <|/ c |>\n<| c |>\nFor me it looks very much like Matt B's answer.\n<|/ c |>\n\
    <| a |>\nI think this would be the simplest solution\n<code>\n$n = 13;\n", " \
    \ if ($n <= 1) return false;\n  if ($n <= 3) return true;\n  if ($n % 2==0) return\
    \ false;\n  if ($n % 5==0) return false;\n\n  $m = $n-1;\n  while ($m > 0 && $m%6==0)\
    \ {\n    $m = (int)($m/6);\n  }\n  return $m<=1;\n}\n", "  // http://stackoverflow.com/questions/7290086/primality-test-that-will-tell-you-if-a-number-is-prime-or-not\n\
    \  // http://primal.math.washington.edu/\n  // Only odd numbers are prime.\n \
    \ // http://primes.utm.edu/glossary/xtr.html#P\n  global $is_prime;\n\n  // This\
    \ list primes up to about 2**16 (the square root of 2**32) for testing.\n  $is_prime\
    \ = array();\n  $is_prime[0] = TRUE;\n  for ($i = 1; $i <= 8; ++$i) {\n    if\
    \ (!$is_prime[$i]) {\n      for ($j = 2; $j <= sqrt($i); ++$j) {\n        if (!$is_prime[$j])\
    \ {\n          $is_prime[$i] = FALSE;\n          break;\n        }\n      }\n\
    \    }\n  }\n\n  if (!$is_prime[$n]) {\n    // No primes exist, so this number\
    \ is not prime.\n    return FALSE;\n  }\n\n  // Check that the number is congruent\
    \ to 2 mod 3\n  // by multiplying the number by 3 in successive odd (mod 3)\n\
    \  // numbers.  This congruence reduces the problem to a\n  // Miller-Rabin test\
    \ that can be used to test primality\n  // in factorization.\n  // This test will\
    \ take about 2**n operations to complete.\n  for ($x = 2; $x * 3 <= $n; $x++)\
    \ {\n    if (!$is_prime[$x]) {\n      return FALSE;\n    }\n    for ($y = $x *\
    \ 3; $y < $n; $y += 2) {\n      $a = $x + ($y - 1);\n      if (!$is_prime[$a])\
    \ {\n        return FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n/**\n\
    \ * Test if an integer is prime.\n */", "    if ($n <= 1) return false;\n\n  \
    \  $sieve = new Sieve(1000001);\n    return $sieve->isPrime($n);\n}\n", "    if\
    \ ($n < 2) {\n        return false;\n    }\n    $sieve = array(\n        2 =>\
    \ true,\n        3 => true,\n        5 => true,\n        7 => true,\n        11\
    \ => true,\n        13 => true,\n        17 => true,\n        19 => true,\n  \
    \      23 => true,\n        29 => true,\n        31 => true,\n        37 => true,\n\
    \        43 => true,\n        59 => true,\n        61 => true,\n        67 =>\
    \ true,\n        71 => true,\n        73 => true,\n        79 => true,\n     \
    \   83 => true,\n        89 => true,\n        97 => true,\n        101 => true,\n\
    \        103 => true,\n        107 => true,\n        109 => true,\n        113\
    \ => true,\n        127 => true,\n        131 => true,\n        137 => true,\n\
    \        139 => true,\n        149 => true,\n        151 => true,\n        157\
    \ => true,\n        163 => true,\n        167 => true,\n        173 => true,\n\
    \        179 => true,\n        181 => true,\n        191 => true,\n        193\
    \ => true,\n        197 => true,\n        199 => true,\n        211 => true,\n\
    \        223 => true,\n        227 => true,\n        229 => true,\n        233\
    \ => true,\n        239 => true,\n        241 => true,\n        251 => true,\n\
    \        257 => true,\n        263 => true,\n        269 => true,\n        271\
    \ => true,\n        277 => true,\n        281 => true,\n        283 => true,\n\
    \        293 => true,\n        307 => true,\n        311 => true,\n        313\
    \ => true,\n        317 => true,\n        331 => true,\n        337 => true,\n\
    \        347 => true,\n        349 => true,\n        353 => true,\n        359\
    \ => true,\n        367 => true,\n        373 => true,\n        379 => true,\n\
    \        383 => true,\n        389 => true,\n        397 => true,\n        401\
    \ => true,\n        409 => true,\n        419 => true,\n        439 => true,\n\
    \        443 => true,\n        449 => true,\n        479 => true,\n        481\
    \ => true,\n        483 => true,\n        487 => true,\n        ", "  $t = 1;\n\
    \  $i = 2;\n  while ($i <= sqrt($n)) {\n    if ($n % $i == 0) {\n      $t = 0;\n\
    \      break;\n    }\n    $i++;\n  }\n  return $t;\n}\n", "    $n = abs($n);\n\
    \    for($i = 2; $i < $n; ++$i) {\n        if($n % $i == 0)\n            return\
    \ false;\n    }\n    return true;\n}\n", "  if ($n < 2) {\n    return false;\n\
    \  }\n  for ($i = 3; $i * $i < $n; $i++) {\n    if ($n % $i == 0) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}", "  // Fast return for easy testing.\n\
    \  if ($n < 2) return false;\n\n  // Create a list containing only the odd numbers.\n\
    \  $odd_numbers = array_filter(range(1, $n), function($n) {\n    return $n % 2\
    \ === 1;\n  });\n\n  // If all the numbers are even, return false.\n  if (count($odd_numbers)\
    \ === count($odd_numbers))\n    return false;\n\n  // Otherwise, go through the\
    \ odds and remove them from the list.\n  $prime = true;\n  foreach ($odd_numbers\
    \ as $odd_number) {\n    if ($odd_number === 2)\n      $prime = false;\n    else\n\
    \      $odd_numbers[$odd_number] = false;\n  }\n\n  return $prime;\n}", "  if\
    \ ($n < 3) {\n    return false;\n  }\n  $tests = array(3, 5, 7);\n  for ($i =\
    \ 3; $i <= sqrt(($n + 1)); ++$i) {\n    // Check if $i is prime.\n    $tests[$i]\
    \ = $n % $i;\n    if ($tests[$i]) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n\n$primes = array(2, 7, 11, 41, 105, 207, 137, 409);", "  // Write\
    \ your code here\n  $sum = 0;\n  for ($i = 2; $i < $n; $i++) {\n    if ($n % $i\
    \ == 0)\n      return false;\n    $sum += $i;\n  }\n  return ($n % $n == 0);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=primes,php,for-loop dscore=0 |>\nThe\
    \ first step is to use your function is_prime to check whether a number is prime.\
    \ Once that's done, you can use that function to eliminate all numbers that are\
    \ divisible by 2 or 3. You can do that by iterating through the numbers from 2\
    \ to sqrt(n) to see if any of those numbers are divisible by 2 or 3.\nHere's a\
    \ function that eliminates all numbers that are divisible by 2 or 3:\n<code>",
  "    // Check to see if the number is 1 or less.\n    if ($n == 1) {\n        return\
    \ false;\n    }\n\n    // Check that the number isn't divisible by any number\
    \ between 2 and itself.\n    for ($x = 2; $x <= sqrt($n); $x++) {\n        if\
    \ ($n % $x == 0) {\n            return false;\n        }\n    }\n\n    // If we\
    \ get this far, the number is prime, so return true.\n    return true;\n}", " \
    \ // Only odd numbers are prime numbers.\n  if ($n % 2 == 0) {\n    return false;\n\
    \  }\n  for ($i = 3; $i * $i < $n; $i += 2) {\n    if ($n % $i == 0) {\n     \
    \ return false;\n    }\n  }\n  return true;\n}\n</code>\nThe next part of the\
    \ algorithm is more straight forward, and you actually already implemented it.\
    \ I will just leave it in case you want to take a look at it for yourself.\nThe\
    \ next part of your algorithm is the following (as described in the question you\
    \ linked to):\n<code>", "  // Return false if n is less than 2.\n  if ($n < 2)\
    \ return false;\n  // If n is even, return false if n does not evenly divide\n\
    \  // 6 (because any even number divides 6).\n  if ($n % 2 == 0) return $n % 6\
    \ == 0;\n  // If n is odd, return true if there is a remainder after\n  // dividing\
    \ n by anything other than itself (which will\n  // be the case if n is greater\
    \ than 3).\n  return !($n%6 == 1 && $n%12 == 1);\n}\n", "\tif ($n <= 1) return\
    \ false;\n\tif ($n <= 3) return true;\n\n\t// Check if n is a power of two.\n\t\
    for ($i = 2; $i <= sqrt($n); $i++) {\n\t\tif ($n % $i == 0) return false;\n\t\
    }\n\treturn true;\n}\n", "  // This test is not particularly efficient, so it\
    \ fails with many numbers.\n  // However, it ensures that we return false for\
    \ composite numbers.\n  return ($n != 1 && $n != 2 && $n != 4 && $n != 61 && $n\
    \ != 61 && $n != 61 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 &&\
    \ $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n !=\
    \ 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 &&\
    \ $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n !=\
    \ 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 &&\
    \ $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n !=\
    \ 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 &&\
    \ $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n !=\
    \ 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 &&\
    \ $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n !=\
    \ 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 &&\
    \ $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n != 9136 && $n !=\
    \ 9136 && $", "    $n = abs($n);\n    if ($n < 2) return false;\n    if ($n ==\
    \ 2) return true;\n    if ($n % 2 == 0) {\n        $f = 1;\n        for ($i =\
    \ 3; $i * $i <= $n; $i += 2) {\n            if ($n % $i == 0) {\n            \
    \    $f = 0;\n                break;\n            }\n        }\n        return\
    \ $f;\n    }\n    for ($i = 3; $i * $i <= $n; $i += 2) {\n        if ($n % $i\
    \ == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "    // Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    \    // This is a very simple sieve that can find prime numbers up to `N` in about\n\
    \    // `O(sqrt(N))` time. However the sieve can take a long time to compute for\n\
    \    // larger N than our maximum prime. To speed it up we use an explicit sieve\
    \ that\n    // can take a long time to compute. Here we find all primes below\
    \ `N` in\n    // about `O(sqrt(N))` time using a sieve with about `O(sqrt(N))`\
    \ compute\n    // time. Note: If your computer can do very large numbers then\
    \ you can\n    // increase the upper limit up to `N` but this should be done as\
    \ a last resort\n    // and should only be used as a last resort.\n\n    if ($n\
    \ <= 1) {\n        return false;\n    }\n\n    $sieve = array();\n\n    for ($i\
    \ = 2; $i <= sqrt($n); $i++) {\n        // If $n divides evenly into the square\
    \ root then $i is prime\n        if ($n % $i == 0) {\n            return false;\n\
    \        }\n\n        // Keep a list of all the prime numbers we've found\n  \
    \      $sieve[$i] = true;\n    }\n\n    // If we've reached here then none of\
    \ the numbers in the sieve\n    // were factors of $n so it's composite\n    return\
    \ true;\n}\n", "    $sieve = [1, 2, 3, 4, 5, 6];\n\n    for($i = 2; $i * $i <\
    \ $n; ++$i) {\n        if($sieve[$i]) continue;\n        $sieve[$i] = $n % $i;\n\
    \        $n = $n / $i;\n    }\n    return $sieve[$n];\n}\n", "    if (!is_numeric($n))\
    \ {\n        return false;\n    }\n    if ($n == 1) {\n        return true;\n\
    \    }\n\n    if ($n < 2) {\n        return false;\n    }\n\n    if ($n <= 7)\
    \ {\n        return true;\n    }\n\n    $root = $primes[$n];\n\n    if ($n % $root)\
    \ {\n        return false;\n    }\n\n    $i = 1;\n    while($i <= $root) {\n \
    \       $d = $i << 1;\n        $m = $i | 1;\n        while($m != 0) {\n      \
    \      if ($n % $d == 0) {\n                return false;\n            }\n   \
    \         $d += $m;\n            $m >>= 1;\n        }\n        ++$i;\n    }\n\n\
    \    return true;\n}\n", "\tif ($n < 2)\n\t\treturn false;\n\tif ($n < 3)\n\t\t\
    return true;\n\tif ($n % 2 == 0)\n\t\treturn false;\n\tif ($n % 3 == 0)\n\t\t\
    return true;\n\n\tfor ($i = 3; $i * $i <= $n; $i+=2) {\n\t\tif ($n % $i == 0)\n\
    \t\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "    $n = (int) $n;\n    if\
    \ ($n < 2) {\n        return false;\n    }\n    // if even, nothing to do\n  \
    \  if ($n & 1) {\n        return false;\n    }\n    // test all the odd numbers\
    \ in the range from 2 to sqrt(n) to see if they are prime or not\n    for ($i\
    \ = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i === 0) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "  for ($i = 0; $i <= $n;\
    \ $i++) {\n    if ($i != 1 && $n % $i == 0) {\n      return false;\n    }\n  }\n\
    \  return true;\n}\n", "    if ($n % 2 == 0) {\n        return true;\n    }\n\n\
    \    $sqrt_n = sqrt(($n));\n    $square_n = $sqrt_n * $sqrt_n;\n\n    for($i =\
    \ 2; $i <= $square_n; $i++) {\n        if ($n % $i == 0) {\n            return\
    \ false;\n        }\n    }\n\n    return true;\n}\n", "    if ($n<=1){\n     \
    \   return false;\n    }\n\n    for($i=2 ; $i<$n ; $i++){\n        if($n%$i==0){\n\
    \            return false;\n        }\n    }\n\n    return true;\n}\n", "    //\
    \ TODO: Add more robust checks.\n    if ($n < 2) {\n        return false;\n  \
    \  }\n    $sqrtN = sqrt($n);\n    for ($i = 1; $i < $sqrtN; $i++) {\n        if\
    \ ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "  // Only prime numbers are greater than 1. Otherwise, we'd have to check\
    \ up to sqrt\n  if ($n <= 1)\n    return false;\n  // Loop up to sqrt(n).\n  for\
    \ ($i = 1; $i <= sqrt(($n - 1)); ++$i)\n    if ($n % $i == 0)\n      return false;\n\
    \  return true;\n}", "  global $count;\n  $count++;\n  if ($n == 1)\n  {\n   \
    \ return false;\n  }\n  if ($n == 2) {\n    return true;\n  }\n  $x = 2;\n  $y\
    \ = $n - 1;\n  while($x > $y) {\n    if ($n % $x == 0) {\n      return false;\n\
    \    }\n    $x++;\n  }\n  return true;\n}\n\n/**\n * Test if a number is a power\
    \ of two.\n *\n * @param  integer $number\n * @param  integer $power\n *\n * @return\
    \ boolean\n */", "    static $primes = array(\n        2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n        71, 73, 79, 83, 89,\
    \ 97\n    );\n    return in_array($n, $primes) || $n % 6 == 0;\n}", "    if ($n\
    \ < 2) {\n        return false;\n    }\n\n    // Check up to n-1 (rather than\
    \ n) since the number is prime if it only needs to check up to n-1\n    $limit\
    \ = $n - 1;\n    $i = 2;\n    $limitsqr = ($limit * $limit);\n    do {\n     \
    \   if ($i % $limit === 0) {\n            return false;\n        }\n        $i++;\n\
    \    } while (--$i);\n\n    if ($limitsqr == ($limit * $limit)) {\n        return\
    \ true;\n    }\n\n    // If we got this far, it means it's either not prime or\
    \ it's prime\n    // but doesn't have the right factors. We could still be in\
    \ range\n    // of n-1 and have a factor larger than the limit.\n    $limitsqr\
    \ = ($limit * $limit);\n    do {\n        if ($n % $limit === 0) {\n         \
    \   return false;\n        }\n        $i++;\n    } while (--$i);\n\n    if ($limitsqr\
    \ == ($limit * $limit)) {\n        return true;\n    }\n\n    return false;\n\
    }\n", "  if ($n <= 1) {\n    return false;\n  }\n\n  // n is odd, or is not an\
    \ integer power of 2\n  if ($n % 2 == 0 || $n%5 == 0) {\n    return false;\n \
    \ }\n\n  $root2 = $n ** .5;\n\n  for($i=3; $i ** .5 <= $root2; $i++) {\n    if\
    \ ($n % $i == 0 || $n%($i+1) == 0) {\n      return false;\n    }\n  }\n\n  return\
    \ true;\n}\n", "  // Check if n is a prime\n  // We use a modified Sieve of Eratosthenes\
    \ algorithm,\n  // which checks all odd numbers < n\n\n  // Check if n is 1, which\
    \ is easy\n  if ($n === 1) {\n    return true;\n  }\n\n  // Check all odd numbers\
    \ less than n\n  for ($i = 3; $i * $i < $n; $i += 2) {\n    // If n is divisible\
    \ by current number i, then\n    // it is not prime\n    if ($n % $i === 0) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis has a flaw, since it can return False for even numbers. For example,\
    \ `is_prime(1)` is `True`.\n<|/ c |>\n<| c |>\nI agree with you, however, it's\
    \ true that even number cannot be prime. From the definition of prime: \"A prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself. For example, the numbers `2`, `3`, and `5` are not prime\
    \ numbers; however, `7`, `11` and `13` are.\" But if n is even, then n is not\
    \ prime.\n<|/ c |>\n<| c |>\nI believe that it is possible to have some numbers\
    \ larger than the square root of the number being checked, as long as all even\
    \ numbers can be divided by the odd number and no number between them is divisible\
    \ by the number. For example, `7` can be divisible by `3` and `5` can be divisible\
    \ by `2`, and the numbers themselves aren't prime (since neither `7` nor `5` can\
    \ be divisible by `2`), so it is not possible to have a prime number greater than\
    \ the square root of the number.\n<|/ c |>\n<| c |>\nI thought about that, but\
    \ I felt it would take some time to find the exact limit. But, you are right,\
    \ that is a possible case. Thanks for pointing it out!\n<|/ c |>\n<| c |>\nThe\
    \ fact that 7 is divisible by 3 is irrelevant. You could have `7` be divisible\
    \ by 2 also, leaving `7` not prime and yet `6` was already found.\n<|/ c |>\n\
    <| a tags=php,primes dscore=4 |>\nThis question was asked a lot over the years.\n\
    One of the answers gives a nice solution:\n<code>", "    if ($n < 2) {\n     \
    \   return false;\n    }\n\n    $n = abs($n);\n    if ($n == 2) {\n        return\
    \ true;\n    }\n\n    if ($n%2 == 0) {\n        return false;\n    }\n\n    $root\
    \ = sqrt($n);\n    for($i = 3; $i <= $root; $i += 2) {\n        if ($n%$i == 0)\
    \ {\n            return false;\n        }\n    }\n\n    return true;\n}", "  \
    \  $isPrime = true;\n    $sqrtN = sqrt($n);\n    for($i = 0; $i < $sqrtN; $i++)\
    \ {\n        $remainder = $n % $sqrtN;\n        if($remainder != 0) {\n      \
    \      $isPrime = false;\n            break;\n        }\n    }\n    return $isPrime;\n\
    }\n</code>\n<|/ a tags=php,sieve-of-eratosthenes dscore=4 |>\n<| c |>\nI think\
    \ this should be the accepted answer\n<|/ c |>\n<| a dscore=4 |>\n<code>", " \
    \   // Return true if the number is prime, and false otherwise.\n    // >>> is_prime(2)\n\
    \    // True\n    // >>> is_prime(3)\n    // False\n    // >>> is_prime(10)\n\
    \    // False\n    if ($n < 2) return false;\n\n    // If the number has an odd\
    \ divisor, ignore it.\n    if ($n % 2 != 1) return false;\n\n    // If all the\
    \ numbers are factors of 2, 3, 5, 7, 11, and 13, then the\n    // number is prime.\n\
    \    if ($n == 2 || $n == 5 || $n == 7 || $n == 11 || $n == 13) return true;\n\
    \n    // If there are four factors, they are all even, and not prime.\n    if\
    \ ($n%4 == 0 && $n%100 != 0) return false;\n\n    // If there is a factor of 21,\
    \ it is prime.\n    if ($n%21) return true;\n\n    // If there is a factor of\
    \ 29, it is prime.\n    if ($n%29) return true;\n\n    // Otherwise, there are\
    \ only two factors - 1 and 29.\n    return false;\n}\n", "  if ($n < 2) {\n  \
    \  return false;\n  }\n\n  if ($n == 2 || $n == 3) {\n    return true;\n  }\n\n\
    \  for ($i = 3; $i <= sqrt($n); $i++) {\n    if ($n % $i == 0) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a tags=php,numbers,primes\
    \ |>\n<| c |>\nIt's not very efficient to check all numbers between 2 and sqrt($n)\
    \ in a loop\n<|/ c |>\n<| c |>\n- If you're going to be doing this on a regular\
    \ basis, then it's probably better to write a small prime number check function\
    \ instead of making your code unnecessarily complicated.\n<|/ c |>\n<| a |>\n\
    A naive approach would be to generate a list of all the prime numbers from 2 to\
    \ your limit, then check if your number is in this list.\n<code>\n$primes = array(2);\
    \ // The first prime number\n$isPrime = true; // Assume the number is prime\n\
    for ($n = 2; $n < $limit; $n++) {\n    if (in_array($n, $primes)) {\n        $isPrime\
    \ = false;\n        break; // Stop checking numbers we've already seen\n    }\n\
    \    $isPrime = true;\n    foreach ($primes as $prime) {\n        if ($n % $prime\
    \ == 0) {\n            $isPrime = false;\n            break; // Stop checking\
    \ this number\n        }\n    }\n    // If we found a divisor for this number,\
    \ we aren't prime.\n    // If we didn't find any divisors for this number, we\
    \ are.\n}\n</code>\nThe above code should be O(n), but it's also the slowest possible\
    \ algorithm possible. There is a faster algorithm (O(sqrt(n)) instead of O(n))\
    \ if you search from prime numbers to trial numbers. The following code uses the\
    \ Sieve of Eratosthenes, which is an efficient algorithm to generate a list of\
    \ prime numbers.\n<code>", "    // Base case: 1 or 0 => not a prime\n    if ($n\
    \ < 2 || $n <= 1) {\n        return false;\n    }\n\n    // Check if n is prime.\n\
    \    $i = 2; \n    while($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n    \
    \        return false;\n        }\n        $i += 1;\n    }\n\n    // If we get\
    \ here, then n is prime.\n    return true;\n}\n", "  // Only prime numbers have\
    \ positive factors\n  if ($n <= 1) return false;\n\n  // Test if n can be evenly\
    \ divided by each of its prime factors (from 2 to sqrt(n)).\n  for ($i = 2; $i\
    \ <= sqrt($n); $i++) {\n    if ($n % $i == 0) return false;\n  }\n\n  // All n\
    \ were factors of 2.\n  return true;\n}\n", "    if($n == 1)\n        return false;\n\
    \n    // Use a sieve. Fast test for primality up to n^2 in several ways.\n   \
    \ static $primes = [0, 3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    if(isset($primes[$n]))\n        return\
    \ true;\n\n    static $mods;\n\n    if(!isset($mods))\n        $mods = array_fill(0,\
    \ $n + 1, 2);\n\n    for($i = 2; $i <= $n; $i++)\n        $mods[$i]++;\n\n   \
    \ foreach($mods as &$mod) {\n        if($mod < 2)\n            return false;\n\
    \        $mod *= $mod;\n    }\n\n    return !$mod;\n}\n", "  if ($n < 2) {\n \
    \   return false;\n  }\n\n  if ($n == 2) {\n    return true;\n  }\n\n  if ($n\
    \ == 0 || is_prime($n - 1)) {\n    return false;\n  }\n\n  return is_prime($n\
    \ - 2);\n}\n", "    if ($n < 2) return false;\n    if ($n & 1 || ($n == 2 && ($n\
    \ % 2 == 0))) return false;\n    if ($n % 3 == 0) return false;\n    if ($n %\
    \ 5 == 0) return false;\n    $n = (int) sqrt($n);\n    for($i = 3; $i <= $n; $i\
    \ += 2)\n        if ($n % $i == 0 || $n % ($i + 2) == 0)\n            return false;\n\
    \    return true;\n}\n", "  global $primes;\n  if (is_null($primes)) {\n    $primes\
    \ = __DIR__ . '/primes.txt';\n  }\n  foreach (file($primes) as $prime) {\n   \
    \ if ($prime == (string)$n) {\n      return true;\n    }\n  }\n  return false;\n\
    }\n", "  $factors = array(2, 3);\n  for ($i = 3; $i < $n; ++$i) {\n    if ($n\
    \ % $i == 0) {\n      $factors[] = $i;\n    }\n  }\n\n  return $factors === array(3,\
    \ 3);\n}\n", "    if ($n == 2 || $n == 3) {\n        return true;\n    }\n   \
    \ \n    // Sieve of Eratosthenes.\n    $primes = array(\n        2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997\n\
    \    );\n    \n    foreach($primes as $p) {\n        if ($n % $p == 0) {\n   \
    \         return false;\n        }\n    }\n    \n    return true;\n}\n \n$n =\
    \ isset($_POST[\"n\"]) ? $_POST[\"n\"] : NULL;\n$p = isset($_POST[\"p\"]) ? $_POST[\"\
    p\"] : NULL;\n\n$answer1 = is_prime($n);\n$answer2 = is_prime($p);\n", "    //\
    \ Special cases: 2 and 3 are primes, 5 is prime.\n    if ($n < 2) {\n        return\
    \ false;\n    }\n\n    if ($n < 7) {\n        return true;\n    }\n\n    if ($n\
    \ % 2 == 0) {\n        return false;\n    }\n\n    $root1 = $n - 2;\n    $root2\
    \ = $n / 2 - 1;\n    $root3 = ($n - 1) / 3;\n    \n    $b = $root1;\n    $c =\
    \ $root2;\n    $d = $root3;\n\n    while ($b <= $c) {\n        if ($c % $n ==\
    \ 0 || $d % $n == 0) {\n            return false;\n        }\n\n        $root3\
    \ = $c + $d;\n        $b = $c + 1;\n        $c = $root3;\n        $d = $root3;\n\
    \    }\n\n    if ($n % $n == 0 || $d % $n == 0) {\n        return false;\n   \
    \ }\n\n    return true;\n}\n", "    if ($n==1 || $n==0) {\n        return true;\n\
    \    }\n    // Find first prime\n    $i=2;\n    $root=sqrt($n);\n    while($i*$i<=$root)\
    \ {\n        if ($n%$i==0) {\n            return false;\n        }\n        $i++;\n\
    \    }\n    // If no prime was found, then n is not prime\n    return true;\n\
    }\n", "  global $primes;\n  $m = $n-1;\n  while ($m <= 0) {\n    if(!isset($primes[$m]))\
    \ {\n      return false;\n    }\n    $m++;\n  }\n  $result = true;\n  $sqrtn =\
    \ $primes[$n];\n  for ($j = 2; $j <= $sqrtn; $j++) {\n    if ($n % $j == 0) {\n\
    \      $result = false;\n      break;\n    }\n  }\n  return $result;\n}\n", " \
    \   // Check if n is prime.\n    // Assume n is a natural number. \n    // If\
    \ n is not natural number then it will be false in any case\n    // because is_prime\
    \ can not handle non-natural numbers.\n    if ($n <= 1) {\n        return false;\n\
    \    }\n\n    // If n is prime then return true.\n    if (is_prime($n)) {\n  \
    \      return true;\n    }\n\n    // If n is composite then check if it has only\
    \ 1 factor.\n    if ($n % 2 == 0) {\n        return false;\n    }\n\n    // If\
    \ n is composite then check if it has 3 factors.\n    if ($n % 3 == 0) {\n   \
    \     return false;\n    }\n\n    // If n is composite then check if it has 5\
    \ factors.\n    if ($n % 5 == 0) {\n        return false;\n    }\n\n    // If\
    \ n is composite then check if it has 7 factors.\n    if ($n % 7 == 0) {\n   \
    \     return false;\n    }\n\n    // If n is composite then check if it has 9\
    \ factors.\n    if ($n % 9 == 0) {\n        return false;\n    }\n\n    // If\
    \ n is composite then check if it has 11 factors.\n    if ($n % 11 == 0) {\n \
    \       return false;\n    }\n\n    // If n is composite then check if it has\
    \ 13 factors.\n    if ($n % 13 == 0) {\n        return false;\n    }\n\n    //\
    \ If n is composite then check if it has 17 factors.\n    if ($n % 17 == 0) {\n\
    \        return false;\n    }\n\n    // If n is composite then check if it has\
    \ 19 factors.\n    if ($n % 19 == 0) {\n        return false;\n    }\n\n    //\
    \ If n is composite then check if it has 23 factors.\n    if ($n % 23 == 0) {\n\
    \        return false;\n    }\n\n    // If n is composite then check if it has\
    \ 29 factors.\n    if ($n % 29 == 0) {\n        return false;\n    }\n\n    //\
    \ If n is composite then check if it has 31 factors.\n    if ($n % 31 == 0) {\n\
    \        return false;\n    }\n\n    // If n is composite then check if it has\
    \ 37 factors.\n    if ($n % 37 == 0) {\n        return false;\n    }\n\n    //\
    \ If n is composite then check if it has 41 factors.\n    if ($n % 41 == 0) {\n\
    \        return false;\n    }\n\n    // If n is composite then check if it has\
    \ 43 factors.\n    if ($n % 43 == 0) {\n        return false;\n    }\n\n    //\
    \ If n is composite then check if it has 47 factors.\n    if ($n % 47 == 0) {\n\
    \        return false;\n    }\n\n    // If n is composite then check if it has\
    \ 53 factors.\n    if ($n % 53 == 0) {\n        return false;\n    }\n\n    //\
    \ If n is composite then check if it has 59 factors.\n    if ($n % 59 == 0) {\n\
    \        return false;\n    }\n\n    // If n is composite then check if it has\
    \ 61 factors.\n    if ($n % 61 == 0) {\n        return false;\n", "    if ($n\
    \ == 1) return false;\n    if ($n == 2) return true;\n    if ($n % 2 == 0) return\
    \ false;\n    if ($n <= 4) return true;\n    if ($n % 5 == 0) return false;\n\
    \    if ($n % 3 == 0) return false;\n    return true;\n}\n", "    if ($n < 2 ||\
    \ $n%2 == 0)\n        return false;\n\n    $square_roots_table = [];\n    for($root\
    \ = $n; $root; $root = $square_roots_table[$root])\n        $square_roots_table[$root]\
    \ = $root * $root;\n\n    $test = 2;\n    for($i = 3; $i < $n; $i += 2)\n    \
    \    if ($square_roots_table[$i] != ($test - $test*$test))\n            return\
    \ false;\n    return true;\n}", "  if ($n < 2) {\n    return false;\n  }\n  if\
    \ ($n <= 3) {\n    return true;\n  }\n  if ($n % 2 == 0 || $n % 3 == 0) {\n  \
    \  return false;\n  }\n  $numSquareRoot = $this->sqrt($n);\n  for ($i = 3; $i\
    \ <= $numSquareRoot; $i += 2) {\n    if ($n % $i == 0 || $n % ($i + 1) == 0) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  if ($n < 2) {\n   \
    \ return false;\n  }\n\n  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ($n % $i\
    \ == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "    if ($n\
    \ < 2) {\n        return false;\n    }\n    $result = true;\n    for ($i = 2;\
    \ $i * $i <= $n; $i++) {\n        if ($n % $i == 0) {\n            $result = false;\n\
    \        }\n    }\n    return $result;\n}\n", "  if ($n <= 1) return false;\n\
    \  if ($n == 2) return true;\n  if ($n % 2 == 0 || $n <= 3) return true;\n\n \
    \ // If n = 2 * 3\xB2\u2076 + 1 there is a solution:\n  // if n % 4 = 0 and n\
    \ % 7 = 0 and n % 14 = 0 then n is prime\n  if ($n == 14) return true;\n\n  //\
    \ If n is a composite number with two factors, it is:\n  // if n % 4 = 0 and n\
    \ % 7 = 0 then n is prime\n  if (($n % 4 == 0) && ($n % 7 == 0)) {\n    return\
    \ true;\n  }\n\n  // If n = 6 and n\xB2 = 11, there are two solutions n % 7 =\
    \ 1 and n % 7 = 7.\n  // So it is n\xB2 = 11 if n % 7 = 0.\n  if (($n % 7 == 0)\
    \ && ($n % 7 == 0)) {\n    return false;\n  }\n\n  // If n = 7 and n\xB2 = 71,\
    \ there are three solutions n % 7 = 3, n % 7 = 7\n  // and n % 7 = 3\u2076 + 1.\
    \ So it is n\xB2 = 11 if n % 7 = 0.\n  if (($n % 7 == 0) && ($n % 7 == 0)) {\n\
    \    return false;\n  }\n\n  // If n = 81 and n\xB2 = 157, there are three solutions\
    \ n % 7 = 7,\n  // n % 7 = 3, n % 7 = 3\u2076 + 1. So it is n\xB2 = 11 if n %\
    \ 7 = 0.\n  if (($n % 7 == 0) && ($n % 7 == 0)) {\n    return false;\n  }\n\n\
    \  // If n = 81 and n\xB2 = 157, there are three solutions n % 7 = 7,\n  // n\
    \ % 7 = 3, n % 7 = 3\u2076 + 1. So it is n\xB2 = 11 if n % 7 = 0.\n  if (($n %\
    \ 7 == 0) && ($n % 7 == 0)) {\n    return false;\n  }\n\n  // If n = 105, 107,\
    \ 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\n  // 173, 179, 181,\
    \ 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\n  // 251, 257, 263,\
    \ 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331,\n  // 337, 347, 349,\
    \ 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\n  // 421, 431, 433,\
    \ 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\n  // 503, 509, 521,\
    \ 523, 541, 547, 557, 563, 569, ", "  $limit = sqrt($n) + 1;\n  $i   = 1;\n\n\
    \  while ($i <= $limit) {\n    if ($n % $i == 0) {\n      return false;\n    }\n\
    \n    $i++;\n  }\n\n  return true;\n}\n", "    if ($n < 2) {\n        return false;\n\
    \    }\n\n    if ($n == 2) {\n        return true;\n    }\n\n    if ($n % 2 ==\
    \ 0) {\n        return false;\n    }\n\n    $root = $n - 1;\n\n    foreach (range(1,\
    \ $n) as $prime) {\n        if ($prime == $root) {\n            return false;\n\
    \        }\n\n        if ($n % $prime == 0) {\n            return false;\n   \
    \     }\n    }\n\n    return true;\n}\n", "    // Make sure n is a positive integer\n\
    \    if ($n == 0) return false;\n    if ($n == 1) return false;\n    if ($n ==\
    \ 2) return true;\n    $num_divisors = 1;\n    // Check factors for prime\n  \
    \  $i = 2;\n    while ($i <= sqrt($n)) {\n        if ($n % $i == 0) $num_divisors++;\n\
    \        $i += 1;\n    }\n    return $num_divisors > 1;\n}\n", "    // Return\
    \ false if n is less than or equal to 0 or if n is divisible by 1 or\n    // less\
    \ than 1.\n    if ($n < 0 || $n % 1 == 0 || $n % 2 == 0) {\n        return false;\n\
    \    }\n\n    // Write your code here.\n    $dividend = 1;\n    $divisor = 2;\n\
    \    for($i = 3;$i<=$n;$i++){\n        if($n%$divisor==0){\n            $dividend\
    \ = 2*$dividend;\n            $divisor++;\n        }\n    }\n    if($dividend>$divisor){\n\
    \        return true;\n    }\n    return false;\n}", "  if ($n<2) {\n    return\
    \ false;\n  }\n  if ($n==2) {\n    return true;\n  }\n  $m = $n/2;\n  while ($n%$m==0)\
    \ {\n    if ($m==2) {\n      return true;\n    }\n    $m++;\n  }\n  return false;\n\
    }", "    $n = abs($n);\n    if ($n < 2) {\n        return false;\n    }\n    if\
    \ ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return\
    \ false;\n    }\n    $root  = sqrt($n);\n    $root = floor($root);\n    return\
    \ !(is_prime($root));\n}\n", "    $start = 2;\n    while ($start <= sqrt($n))\
    \ {\n        if ($n % $start == 0) {\n            return false;\n        }\n \
    \       $start++;\n    }\n    return true;\n}\n", "    // Check to see that n\
    \ is an integer and return false if it is not.\n    if (!is_integer($n)) {\n \
    \       return false;\n    }\n\n    // Check base for primeness.\n    if ($n <\
    \ 2) {\n        return true;\n    }\n\n    // Check whether n is a prime using\
    \ trial division.\n    if ($n % 2 == 0) {\n        return false;\n    }\n\n  \
    \  // Check whether n is a prime using the Sieve of Eratosthenes.\n    // https://en.wikipedia.org/wiki/Primality_test#Sieve_of_Eratosthenes_algorithm\n\
    \    $k = ceil(log($n, 2));\n\n    // If n is greater than sqrt(n), then n is\
    \ prime.\n    if ($k > 0) {\n        for ($i = 3; $i * $i <= $n; $i += 2) {\n\
    \            if ($n % $i == 0) {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n\n    // If n is less than sqrt(n), then\
    \ n is not prime.\n    return false;\n}\n", "    $n++;\n    // $n = abs($n);\n\
    \    $i = $n - 1;\n    while($i >= 2) {\n        if($n % $i == 0)\n          \
    \  return false;\n        $i--;\n    }\n    return true;\n}\n", "  // Check that\
    \ $n is a natural number >= 2.\n  if ($n < 2) {\n    return false;\n  }\n\n  //\
    \ Check that $n is a prime number.\n  for ($divisor = 2; $divisor <= $n; $divisor++)\
    \ {\n    if ($n % $divisor === 0) {\n      return false;\n    }\n  }\n\n  return\
    \ true;\n}\n</code>\n<|/ a tags=php dscore=0 |>\n<| c |>\nIf $n is prime then\
    \ $n must be greater than or equal to 2. That is what that if statement is checking.\n\
    <|/ c |>\n<| a tags=php |>\n<code>", "    if ($n < 2) {\n        return false;\n\
    \    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n <= 3) {\n\
    \        return true;\n    }\n    if (($n % 2) == 0) {\n        return false;\n\
    \    }\n    for($i=3; $i*i <= $n; $i++) {\n        if ($n % $i == 0) {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n", "\t$is_prime\
    \ = true;\n\tif($n > 1) {\n\t\t$factors = array(1,2,4,6,8,10);\n\t\t$i = 3;\n\t\
    \twhile($i < $n) {\n\t\t\tif(in_array($i, $factors)) {\n\t\t\t\t$is_prime = false;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\t$i += 2;\n\t\t}\n\t}\n\treturn $is_prime;\n}",
  "    $n = abs($n);\n    if ($n < 1)\n        return false;\n    if ($n == 1)\n \
    \       return true;\n    if ($n % 2 == 0)\n        return false;\n    if ($n\
    \ == 3)\n        return true;\n\n    // Trial division with |n| odd is enough\
    \ to prove it isn't prime.\n    // We use the fact that 2 is a prime number to\
    \ prove that |n| is\n    // not a prime number, because if it were, we would still\
    \ have\n    // a small factor. That would give us a chance to immediately\n  \
    \  // find out it is composite.\n    foreach (range(3, $n + 1, 2) as $prime)\n\
    \        if ($n % $prime == 0)\n            return false;\n    return true;\n}",
  "  // Make sure we're an integer.\n  $n = (int) $n;\n  // We only need to check\
    \ if we're odd.\n  if ($n % 2) {\n    // If we're odd, then either 1 or 3 have\
    \ to be even.\n    $is_odd = ($n % 2);\n  } else {\n    // We're even, so just\
    \ 1 or 3 have to be odd.\n    $is_odd = (isset($GLOBALS[\"$GLOBALS['primes_odd']\"\
    ][0]) ? 1 : 0);\n  }\n  // If we're prime or our only even prime is odd, then\
    \ we're prime.\n  return $is_odd || $GLOBALS[\"$GLOBALS['primes_odd']\"][0][$n\
    \ % 2] == $n;\n}\n", "    $n = abs($n);\n    $n_div2 = intval($n / 2);\n    \n\
    \    if ($n_div2 == 1) {\n        if ($n % 2 == 0) {\n            return false;\n\
    \        }\n        $n_sqr_div2 = intval($n / 4);\n        if ($n_sqr_div2 ==\
    \ 0) {\n            return true;\n        }\n        $n_sqr_div2 = intval($n_sqr_div2\
    \ / 2);\n        if ($n_sqr_div2 == 1) {\n            return false;\n        }\n\
    \        $n_sqr_div2 = intval($n_sqr_div2 / 4);\n        if ($n_sqr_div2 == 0)\
    \ {\n            return true;\n        }\n        $n_sqr_div2 = intval($n_sqr_div2\
    \ / 2);\n        if ($n_sqr_div2 == 1) {\n            return false;\n        }\n\
    \        $n_sqr_div2 = intval($n_sqr_div2 / 4);\n        if ($n_sqr_div2 == 0)\
    \ {\n            return true;\n        }\n        return true;\n    }\n    else\
    \ {\n        $n_div2 = intval($n_div2 / 2);\n        if ($n_div2 == 1) {\n   \
    \         return false;\n        }\n        $n_div2 = intval($n_div2 / 2);\n \
    \       if ($n_div2 == 1) {\n            return false;\n        }\n        $n_div2\
    \ = intval($n_div2 / 2);\n        if ($n_div2 == 1) {\n            return false;\n\
    \        }\n        $n_div2 = intval($n_div2 / 2);\n        if ($n_div2 == 1)\
    \ {\n            return false;\n        }\n        $n_div2 = intval($n_div2 /\
    \ 2);\n        if ($n_div2 == 1) {\n            return false;\n        }\n   \
    \     $n_div2 = intval($n_div2 / 2);\n        if ($n_div2 == 1) {\n          \
    \  return false;\n        }\n        $n_div2 = intval($n_div2 / 2);\n        if\
    \ ($n_div2 == 1) {\n            return false;\n        }\n        $n_div2 = intval($n_div2\
    \ / 2);\n        if ($n_div2 == 1) {\n            return false;\n        }\n \
    \       $n_div2 = intval($n_div2 / 2);\n        if ($n_div2 == 1) {\n        \
    \    return false;\n        }\n        $n_div2 = intval($n_div2 / 2);\n      \
    \  if ($n_div2 == 1) {\n            return false;\n        }\n        $n_div2\
    \ = intval($n_div2 / 2);\n        if ($n_div2 == 1) {\n            return false;\n\
    \        }\n        $n_div2 = intval($n_div2 / 2);\n        if ($n_div2 == 1)\
    \ {\n            return false;\n        }\n        $n_div2 = intval($n_div2 /\
    \ 2);\n        if ($n_div2 == 1) {\n            return false;\n        }\n   \
    \     $n_div2 = intval($n_div2 / ", "  if ($n < 2) {\n    return false;\n  }\n\
    \  for ($i = 2; $i * $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "    $low = 1;\n    $high = sqrt($n);\n\
    \    while($low < $high) {\n        $mid = $low + $high;\n        if($mid > $n)\
    \ break;\n        if($mid % 2 != 0) return false;\n        $low = $mid + 1;\n\
    \    }\n    return $n == 2 || $n == 3 || $n == 5\n}\n", "  if (!is_numeric($n)\
    \ || $n < 2 || $n <= 1) return false;\n  $f = 5; $c = 3; $nc = $n - 1;\n  while\
    \ ($nc > 0) {\n    if ($f <= sqrt($c)) {\n      if ($c == $nc || $nc == ($nc +\
    \ 1) && $n != ($nc - 1))\n        return true;\n      else if ($c % $nc != 0)\n\
    \        return false;\n    }\n    $nc -= 1;\n    $c++;\n    $f*=5;\n  }\n  return\
    \ false;\n}", "    if ($n == 1) {\n        return false;\n    }\n\n    $i = 2;\n\
    \    while ($i < $n) {\n        if ($n % $i == 0) {\n            return false;\n\
    \        }\n        $i += 2;\n    }\n\n    return true;\n}\n", "  // Return true\
    \ if the number is prime (that is, if it is evenly divisible only by itself and\
    \ 1).\n  $n = intval($n);\n  if ($n < 2) {\n    return false;\n  }\n  for ($i\
    \ = 2; $i <= sqrt($n); ++$i) {\n    if ($n % $i === 0) {\n      return false;\n\
    \    }\n  }\n  return true;\n}", "    $n = abs($n);\n    $n = $n <= 0 ? 1 : (abs($n)\
    \ === 1 ? $n : mod(($n-1), $n));\n    $num_primes = 1;\n    for($i = 2; $i < $n;\
    \ $i++) {\n        if($n % $i === 0) $num_primes++;\n    }\n    return $num_primes\
    \ > 1;\n}", "  if ($n < 1) {\n    return false;\n  }\n  // if pow($n, 1.0/$n)\
    \ == 1.0, then n cannot be prime because\n  // 1/n != 0\n  // http://en.wikipedia.org/wiki/Primality_test#Primality_of_an_abundant_number\n\
    \  // If pow($n, 1.0/$n) != 0.0, then n must be prime because\n  // pow($n, 1.0/$n)\
    \ neither equals nor exceeds $1\n  // http://en.wikipedia.org/wiki/Primality_test#Primality_of_a_number\n\
    \  if (pow($n, 1.0/$n) != 0.0) {\n    return false;\n  }\n  $n = intval($n);\n\
    \  if ($n < 2) {\n    return false;\n  }\n  if ($n == 2) {\n    return true;\n\
    \  }\n  if ($n == $n - 1) {\n    return true;\n  }\n  $root = $this->sqrt($n);\n\
    \  for($i = 3; $i * $i <= $root; $i+=2) {\n    if ($n % $i == 0) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "    if($n < 2)\n        return false;\n\
    \    for($i = 2; $i * $i <= $n; ++$i) {\n        if($n % $i == 0)\n          \
    \  return false;\n    }\n    return true;\n}\n", "  // Check base case first.\n\
    \  if ($n === 1) {\n    return true;\n  }\n  if ($n < 2) {\n    return false;\n\
    \  }\n  // Check all the even numbers less than n.\n  for ($i = 2; $i < $n; $i\
    \ += 2) {\n    if ($n % $i === 0) {\n      return false;\n    }\n  }\n  // Check\
    \ all the odd numbers less than n.\n  for ($i = 2; $i < $n; $i += 2) {\n    if\
    \ ($n % $i !== 0) {\n      return false;\n    }\n  }\n  return true;\n}", "  \
    \  if ($n === 0 || $n === 1) {\n        return false;\n    }\n    // Use the Sieve\
    \ of Eratosthenes method for finding\n    // the first prime > $n\n    if ($n\
    \ <= 2) {\n        return true;\n    }\n\n    $sieve = new Sieve(2);\n    $result\
    \ = $sieve->isPrime($n);\n\n    return $result;\n}", "    $i = 2; $is_prime =\
    \ true;\n    while ($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n         \
    \   $is_prime = false;\n            break;\n        }\n        $i++;\n    }\n\
    \    return $is_prime;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI thought about\
    \ this for a while and decided that it wasn't worth the effort, but then I thought,\
    \ \"why not?\"\nHere's a solution in PHP.  You'll need a little math skills to\
    \ understand it.  I haven't tested it, so it may or may not work correctly in\
    \ all situations, but it's worth a shot.\n<code>", "    $count = 5; // Hard-coded\
    \ prime count\n\n    // Skip even numbers, which are not primes.\n    if ($n%2\
    \ == 0) return false;\n\n    // Use trial division to determine if a number is\
    \ prime.\n    // If it divides into three or more primes, it is not prime.\n \
    \   for ($i = 3; $i <= sqrt($n); $i += 2)\n        if ($n%$i == 0) return false;\n\
    \n    // If we got this far, there are only two primes (1 and 2) which are > 2.\n\
    \    // If none of the above rules result in primes, then none of the numbers\
    \ are prime.\n    return true;\n}", "    $n = intval($n);\n    if ($n < 2)\n \
    \       return false;\n    if ($n == 2)\n        return true;\n\n    // Trial\
    \ division by 2 can save a lot of time on average.\n    if ($n % 2 == 0)\n   \
    \     return false;\n\n    // If we've already determined that it's a prime, return\
    \ that.\n    static $one, $two;\n    if ($one) {\n        $one->value = 1;\n \
    \       $one->is_prime = true;\n        return true;\n    }\n\n    // Sieve of\
    \ Eratosthenes - see http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n    $one\
    \ = new BigInt(1);\n    $two = new BigInt(2);\n    for($i = 5; $i <= $n; $i +=\
    \ 2)\n        $two->value = $two->value * $i;\n    $p = $two;\n    $m = $two;\n\
    \    for($j = 3; $j > 0; $j--) {\n        $m->value = $m->value * $p;\n      \
    \  $m = $m->mod;\n    }\n    $m = $one;\n    for($j = 3; $j > 0; $j--) {\n   \
    \     if($m->value == 1)\n            $m->value = $p->value;\n        else\n \
    \           $m->value = $m->value * $p->value;\n        $m = $m->mod;\n      \
    \  $p = $p->mod;\n    }\n\n    // If we've reached here we've determined that\
    \ $n is a prime number.\n    $one->value = $two->value;\n    $one->is_prime =\
    \ true;\n    return true;\n}\n", "    if ($n <= 1) return false;\n    $n = intval($n);\n\
    \    return $n <= sqrt($n);\n}\n", "    if ($n<2)\n        return false;\n   \
    \ if($n==2 || $n==3)\n        return true;\n    if($n%2==0 || $n%3==0)\n     \
    \   return false;\n    for($i=5;$i<=$((sqrt($n)));$i+=2)\n        if($n%$i==0\
    \ || $n%$i==1)\n            return false;\n    return true;\n}\n\n/**\n * Test\
    \ if the given number is a multiple of 5.\n *\n * @param int $number\n * @return\
    \ bool\n */", "    $sieve = array(2, 3, 5, 7);\n    return !array_search($n, $sieve);\n\
    }\n\n$primes = array();\nfor ($i = 1; $i <= 50; ++$i) {\n    if (isset($primes[$i])\
    \ && $primes[$i]) continue;\n    $primes[$i] = is_prime($i);\n}\n", "  if (!is_numeric($n))\
    \ {\n    $n = strval($n);\n  }\n\n  if ($n <= 2) {\n    return false;\n  }\n\n\
    \  for ($i = 3; $i * $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      return\
    \ false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Calculates the square of\
    \ a number. Does not accept decimals.\n *\n * @param string $n The number to calculate\
    \ the square of.\n *\n * @return string\n * @see http://en.wikipedia.org/wiki/Square_root\n\
    \ */", "\t$n = abs($n);\n\tif ($n <= 1) return false;\n\tfor ($i = 3; $i <= sqrt($n);\
    \ $i += 2) {\n\t\tif ($n % $i == 0) return false;\n\t}\n\treturn true;\n}\n",
  "  if ($n <= 1) return false;\n  if ($n % 2 == 0) return false;\n  for ($i = 3;\
    \ $i * $i <= $n; $i += 2)\n    if ($n % $i == 0) return false;\n  return true;\n\
    }", "    if ($n <= 1) return false;\n    if ($n <= 3) return true;\n    if ($n\
    \ % 2 == 0) return false;\n    if ($n % 3 == 0) return false;\n    if ($n % 5\
    \ == 0) return false;\n    if ($n % 7 == 0) return false;\n    $i = 5;\n    while\
    \ ($i <= sqrt($n)) {\n        if ($n % $i == 0) return false;\n        $i += 6;\n\
    \    }\n    return true;\n}\n", "    if (!is_numeric($n)) {\n        return false;\n\
    \    }\n    return $n == 2  ||  $n == 3 ||  $n == 5  ||  $n == 7  ||\n       \
    \     $n == 9  ||  $n == 11 || $n == 12 || $n == 13;\n}\n", "  $sieve = array(6,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61);\n  for ($i = 2; $i\
    \ * $i <= $n; ++$i) {\n    if (!isset($sieve[$i])) {\n      $sieve[$i] = $i;\n\
    \    }\n  }\n  return !isset($sieve[$n]) ? false : true;\n}", "    if ($n % 2\
    \ == 0 || $n == 1) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n);\
    \ $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n       \
    \ }\n    }\n    return true;\n}\n\necho \"is_prime($n): \" . (is_prime($n) ? 'true'\
    \ : 'false') . \"\\n\";\n", "  if ($n < 2) {\n    return false;\n  }\n  foreach\
    \ (range(1, $n) as $i) {\n    if ($n % $i == 0) {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "  // Only odd numbers are prime (no notion of order\
    \ here).\n  if ($n % 2 == 0) return false;\n\n  // Sieve of Eratosthenes to determine\
    \ composite number\n  for ($i = 3; $i <= $n/2; $i += 2)\n    if ($n % $i == 0)\n\
    \      return false;\n\n  return true;\n}\n", "  // Sieve of Erastosthenes (http://en.wikipedia.org/wiki/Sieve_of_Erastosthenes)\n\
    \  // Algorithm by Marcin Cieslik and Sam Wyles (http://www.swh.de)\n  //   and\
    \ John W. Miller (http://www.johnmm.com)\n  //   and modified by Rajkumar Ghosh\
    \ (http://www.rajkumar-ghosh.com)\n  // Improved by Chris G. Pedersen (http://www.cui.org.uk)\n\
    \  // Improved by Eugene W. Kaneva (http://www.cui.org.uk)\n  // Improved by Patrick\
    \ K. Gauss  (http://www.patrick-gaus.com)\n  //   and Josh MacDonald (http://www.jmacdonald.com)\n\
    \  //\n  // Suggested optimizations: Trial division using primes only, and a\n\
    \  // check-to-square root based Miller-Rabin primality test.\n\n  if ($n < 2\
    \ || $n == 1) { return false; }\n\n  // special case\n  if ($n == 2) { return\
    \ true; }\n\n  // Check whether n is an integer and greater than 1.\n  $is_integer\
    \ = floor($n);\n  if ($is_integer == 0) { return false; }\n\n  $limit = (int)\
    \ sqrt($n);\n  // Trial division with up to $limit \u2212 1 guesses.\n  // Since\
    \ `sqrt(x)` approaches `x` for any nonnegative integer `x`, the\n  // number of\
    \ guesses needed is at most \u221A$limit.\n  $guesses = $limit;\n  if ($guesses\
    \ <= 0) { return false; }\n\n  // Compute sqrt($n) iteratively using the Sieve\
    \ of Erathostenes\n  // and check if $n is prime.\n  $is_prime = true;\n  for\
    \ ($i = 1; $i < $guesses; ++$i) {\n    $k = ($i * $i) % $limit;\n    $n_i_over_limit\
    \ = pow($limit, $i) / pow($limit, $k);\n    $is_prime = ($n <= $n_i_over_limit\
    \ + 1 && $n % $i == 0);\n    if (!$is_prime) { break; }\n  }\n  return $is_prime;\n\
    }", "    // Special case: 1 is prime; 2 is prime; 3 is prime.\n    if ($n ===\
    \ 1) {\n        return 1;\n    }\n\n    // Otherwise, check all numbers between\
    \ 2 and $n-1.\n    for ($i = 2; $i <= $n; ++$i) {\n        // If the number is\
    \ divisible by any primes less than or equal to $i, return false.\n        $primes\
    \ = range(3, $i + 1);\n        foreach ($primes as $prime) {\n            if ($n\
    \ % $prime === 0) {\n                return false;\n            }\n        }\n\
    \n        // If the number is evenly divisible by all primes less than or equal\
    \ to $i, return false.\n        // This only happens because all primes less than\
    \ or equal to $i were excluded above.\n        if (($n % 2 === 0) && ($n % $i\
    \ !== 0)) {\n            return false;\n        }\n    }\n\n    // If we get here,\
    \ we have a prime!\n    return true;\n}", "  if ($n === 1 || $n === 3 || $n ===\
    \ 5) {\n    return true;\n  }\n  for ($i = 2; $i < $n / 2; $i++) {\n    if ($n\
    \ % $i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n", "    $divby3\
    \ = $n%3;\n    if($divby3 == 0 OR $divby3 == 1)\n        return false;\n    $divby5\
    \ = $n%5;\n    if($divby5 == 0 OR $divby5 == 1)\n        return false;\n    $divby7\
    \ = $n%7;\n    if($divby7 == 0 OR $divby7 == 1)\n        return false;\n    return\
    \ true;\n}\n", "  if ($n == 1) {\n    return true;\n  }\n  for ($i = 2; $i < $n;\
    \ $i++) {\n    if ($n % $i == 0) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n\n$primes = array();\nfor ($i = 0; $i < 10000; $i++) {\n  $primes[]\
    \ = $i;\n}\n\n$primes_set = array_flip($primes);\n", "  if ($n == 1) return false;\n\
    \  if ($n < 2) return false;\n  if ($n == 2) return true;\n  if ($n % 2 == 0)\
    \ return false;\n  if ($n == 5 || $n == 11 || $n == 13 || $n == 17) return true;\n\
    \  if ($n % 3 == 0) return false;\n  if ($n % 5 == 0) return false;\n\n  // If\
    \ n is divisible by 5 then it can only be a prime\n  // if one of its factors\
    \ is divisible by 5.\n  for ($i = 3; $i <= sqrt($n); $i += 2) {\n    if ($n %\
    \ $i == 0 || $n % ($i + 2) == 0)\n      return false;\n  }\n\n  return true;\n\
    }\n", "    $prime = true;\n\n    // Only loop the composite numbers up to the\
    \ square root of the number.\n    for ($i = 0; $i * $i <= $n; $i++) {\n      \
    \  $composite = is_prime($n % $i);\n\n        if ($composite == false) {\n   \
    \         $prime = false;\n        }\n    }\n\n    return $prime;\n}\n", "   \
    \ $n = (int) ($n);\n    if ($n < 2) {\n        return false;\n    }\n    if ($n\
    \ == 2) {\n        return true;\n    }\n    // Trial division algorithm\n    $limit\
    \ = isset($GLOBALS['primes_sqrt'][$n])\n        ? $GLOBALS['primes_sqrt'][$n]\n\
    \        : ceil(sqrt($n));\n    if ($limit < 2) {\n        return false;\n   \
    \ }\n    $test = (($n % 2 == 0) && $n++ % 2 == 0) ? 0 : 1;\n    for ($i = 2; $i\
    \ < $limit; $i++) {\n        if ($n % $i == 0) {\n            $test = 0;\n   \
    \         break;\n        }\n    }\n    return ($test == 0) ? true : false;\n}",
  "    if ($n % 2 == 0) {\n        return false;\n    }\n\n    $root2sqrt = sqrt(2\
    \ * $n);\n    $root4sqrt = sqrt(4 * $n);\n    $root6sqrt = sqrt(6 * $n);\n   \
    \ $root8sqrt = sqrt(8 * $n);\n    $root10sqrt = sqrt(10 * $n);\n\n    if ($root2sqrt\
    \ * $root2sqrt == $n) {\n        return true;\n    }\n\n    if ($root4sqrt * $root4sqrt\
    \ == $n) {\n        return true;\n    }\n\n    if ($root6sqrt * $root6sqrt ==\
    \ $n) {\n        return true;\n    }\n\n    if ($root8sqrt * $root8sqrt == $n)\
    \ {\n        return true;\n    }\n\n    if ($root10sqrt * $root10sqrt == $n) {\n\
    \        return true;\n    }\n\n    return false;\n}\n", "  // Check that n is\
    \ prime, and verify that it isn't even.\n  if (is_int($n) && $n % 2 == 0 && $n\
    \ > 2) return false;\n  // Check for factors up to sqrt(n).\n  $imax = ceil(sqrt($n));\n\
    \  for ($i = 2; $i <= $imax; $i++) {\n    if ($n % $i == 0) return false;\n  }\n\
    \  return true;\n}", "    if ($n < 2) return false;\n    if ($n == 2) return true;\n\
    \    if ($n == 3) return true;\n    if ($n % 2 == 0) return false;\n    if ($n\
    \ % 3 == 0) return false;\n    return true;\n}\n", "  $primes = array(\n    2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n \
    \   73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n\
    \    157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\n\
    \    239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\n\
    \    331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\n\
    \    421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n\
    \    509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n\
    \    613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n\
    \    709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\n\
    \    821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\n\
    \    919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\n  );\n  return\
    \ in_array($n, $primes);\n}\n", "    if ($n <= 1)\n        return false;\n\n \
    \   // If n is prime, then the number is greater than 1 and\n    // either a factor\
    \ of it exists (in which case it should\n    // be even), or it is composite in\
    \ which case it should\n    // have a factor of 2.\n    for ($i = 1; $i < $n;\
    \ $i++)\n        if ($n % $i == 0)\n            return false;\n\n    return ($n\
    \ % $n == 0);\n}", "  if ($n === 1) {\n    return false;\n  }\n\n  // Special\
    \ cases.\n  if ($n === 2) {\n    return true;\n  }\n\n  // Check for even numbers.\n\
    \  if ($n % 2 === 0) {\n    return false;\n  }\n\n  // If n is less than or equal\
    \ to 3, then it is prime.\n  if ($n <= 3) {\n    return true;\n  }\n\n  // Check\
    \ ranges.\n  list($end, $num_of_bonus) = rangePrime($n);\n  if ($n <= $end) {\n\
    \    return true;\n  }\n\n  // Check ranges.\n  list($begin, $num_of_bonus) =\
    \ rangePrime($n);\n  return $begin <= $n && $n <= $end;\n}\n", "  return !isPrime($n);\n\
    }\n", "  if ($n < 2) {\n    return false;\n  }\n\n  // If the number is less than\
    \ or equal to sqrt(3), then it has no\n  // multiplicative factors. If it has\
    \ more than 1 multiplicative\n  // factor, then it's prime.\n  $num_minus_one_minus_sqrt_3\
    \ = (int) ($n * $n - 1);\n\n  if ($num_minus_one_minus_sqrt_3 <= $num_minus_one_minus_sqrt_3)\
    \ {\n    return ($num_minus_one_minus_sqrt_3 <= 2);\n  }\n\n  $i = 0;\n  while\
    \ ($i < $num_minus_one_minus_sqrt_3) {\n    $i++;\n    if ($n % $i == 0) {\n \
    \     return false;\n    }\n  }\n  return ($i <= $num_minus_one_minus_sqrt_3);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nOh I see now. This just makes the program\
    \ run too long for my computer - I'm going to see if I can find the bug, it's\
    \ probably in there. I don't think you can get any faster than that.\n<|/ c |>\n\
    <| c |>\nI fixed it - there was a typo in. I changed the `while` loop to `for\
    \ ($i = 1; $i <= $num_minus_one_minus_sqrt_3; $i++) {` and it worked! Thanks a\
    \ lot for your help! I just couldn't figure it out. Cheers!\n<|/ c |>\n<| c |>\n\
    `for ($i = 1; $i <= $num_minus_one_minus_sqrt_3; $i++)` will take long time if\
    \ $num_minus_one_minus_sqrt_3 is large. e.g. if you call is_prime(50000000), it\
    \ will run forever until memory is exhausted.\n<|/ c |>\n<| c |>\n: Thanks for\
    \ pointing that out. I missed that part and did not notice that the number of\
    \ multiplicative factors was the limit (it took me a while to figure out that).\
    \ Fixed now.\n<|/ c |>\n<| c |>\nAh, that makes sense. I tried running the program\
    \ again using just `$num_minus_one_minus_sqrt_3` instead of the whole for loop\
    \ and it takes so long to find any prime numbers. This is good news. Now it's\
    \ just going to take me a while to find a way around the memory issue. Thanks\
    \ again!\n<|/ c |>\n<| a dscore=0 tags=primes,math,php,algorithm |>\nFirst of\
    \ all you should use a bit faster is_prime function, and you can do the following:\n\
    <code>", "  if ($n < 2) {\n    return false;\n  }\n\n  $i = 2; //initial value\
    \ of i\n  $x = sqrt($n) + 1; //initial value of x\n\n  while ($i <= $x) {\n  \
    \  if ($n % $i == 0) {\n      return false;\n    }\n    $i++;\n  }\n  return true;\n\
    }\n", "  $i = 2; $was_composite = 0; $found_prime = 0; $isprime = true;\n\n  if\
    \ ($n < 2) {\n    // $n <= 0 is only prime if $n > 0\n    return $n;\n  }\n\n\
    \  while ($i <= sqrt($n)) {\n    if ($n % $i == 0) {\n      $found_prime = 1;\n\
    \      $isprime = false;\n      break;\n    }\n    $i += $i % 2 ? 2 : 1;\n  }\n\
    \n  if ($found_prime) {\n    if ($isprime) {\n      return $n;\n    }\n  }\n\n\
    \  return $was_prime ? $n : false;\n}\n", "  // If n is less than or equal to\
    \ zero, return false.\n  if ($n <= 0) {\n    return false;\n  }\n\n  // Make a\
    \ note of whether n is prime.\n  $num_prime = true;\n\n  // Now test all numbers\
    \ from 2 to $n.  If n is evenly divisible by any number\n  // between 2 and itself,\
    \ then it isn't prime.\n  for ($x = 2; $x <= $n; $x++) {\n    if ($x % 2 == 0)\
    \ {\n      $num_prime = false;\n      break;\n    }\n  }\n\n  return $num_prime;\n\
    }\n\n/**\n * Returns true if given number is even and false otherwise.\n */",
  "  // Test for divisibility by primes up to n-1 (because 2 will be prime\n  // but\
    \ 3 will never be prime).\n  if ($n == 1) return false;\n  for ($i = 3; $i * $i\
    \ <= $n; $i++) if ($n % $i == 0) return false;\n  return true;\n}\n", "    $nCheck\
    \ = $n;\n    if($nCheck <= 2){\n        return false;\n    }\n\n    for($i = 2;\
    \ $i<=$nCheck; $i++){\n        if($nCheck % $i == 0){\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    if ($n == 0 || $n <= 1)\n    \
    \    return false;\n    if ($n % 2 == 0)\n        return true;\n\n    $root =\
    \ $n;\n\n    while ($root % 5 == 0)\n        $root = $root / 5;\n\n    for ($i\
    \ = 3; $i <= $root; $i += 2)\n        if ($n % ($i) == 0)\n            return\
    \ false;\n\n    return true;\n}", "  if ($n % 2 == 0) return $n != 1;\n\n  //\
    \ 3S + 5\n  $c = 3 * $n - 2;\n  for ($i = 3; $i * $i <= $n; $i++) if ($n % $i\
    \ == 0 || $n % ($i + 2) == 0)\n    return false;\n\n  return true;\n}\n</code>\n\
    <|/ a tags=php,algorithm |>\n<| c |>\nThat code is very slow. For example, on\
    \ `is_prime(13441)` it took over 20 seconds for me. That's not just an algorithm\
    \ issue but it's also a problem with the mathematical implementation. Sieve of\
    \ Eratosthenes is *not* an efficient way of finding primes up to any limit unless\
    \ it's run on a very large scale.\n<|/ c |>\n<| c |>\nI doubt you can beat that\
    \ in php because of the floating point precision\n<|/ c |>\n<| c |>\nYou can beat\
    \ it in Python and Ruby because it has much better floats than PHP and Java do.\
    \ For PHP it's even worse because it's based on a very small number which is *not*\
    \ representable in PHP's floats. In Ruby it's even worse because it's based on\
    \ a number which is much larger than PHP's floats.\n<|/ c |>\n<| c |>\nThis code\
    \ is extremely slow. It can take up to 5 or so seconds to calculate a prime number.\
    \ I'm looking for a faster algorithm that I can implement. I'll implement the\
    \ Sieve of Eratosthenes in PHP so I could test it out against the Sieve of Atkin.\n\
    <|/ c |>\n<| c |>\nOkay, so I implemented the Sieve of Eratosthenes algorithm\
    \ and my PHP script now takes about 7 seconds to calculate is_prime(13441) or\
    \ is_prime(677). But that's still not good enough for me since I need to determine\
    \ if numbers are prime for up to 50 million numbers. So I need an algorithm that's\
    \ able to calculate this in just under 1 minute. I can't use an online solution.\
    \ I need to implement this in PHP. I'm looking for a faster algorithm that I can\
    \ implement that can do this.\n<|/ c |>\n<| a |>\nFirst of all your formula is\
    \ wrong. The proper formula would be \n<code>\np = (1+sqrt(5))/2\n</code>\nBut\
    \ that's not going to help you much. I think you should start with a list of prime\
    \ numbers. Here is an implementation in C#. I don't know much about PHP and you\
    \ didn't tag the question with it.\n<|/ a dscore=0 tags=php,algorithm |>\n<| c\
    \ |>\nI'm not ", "    if ($n < 2) {\n        return false;\n    }\n    if ($n\
    \ == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return\
    \ false;\n    }\n    $test = (int)(sqrt($n) + 0.5);\n    for ($i = 3; $i <= $test;\
    \ $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n       \
    \ }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=2 tags=python,primes,php\
    \ |>\n<| c |>\n+1 for a great and well thought out answer.  But I think there\
    \ may be a bug in the code.  It says 6 is a prime number because no prime number\
    \ exists that is less than 5.  So the function should only return true if $n is\
    \ less than 5.\n<|/ c |>\n<| c |>\nThank you for your comments.  I've edited the\
    \ code accordingly.\n<|/ c |>\n<| c |>\nthank you so much guys ! this is really\
    \ helpful and saved me a lot of time. i just needed to understand the theory behind\
    \ it. thanks again.\n<|/ c |>\n<| a |>\n<code>\ndef is_prime(n):\n    if n<=1:\n\
    \        return False\n    if n==2:\n        return True\n    if n%2==0:\n   \
    \     return False\n    for x in range(3,int(n**0.5+1),2):\n        if n%x==0:\n\
    \            return False\n    return True\n</code>\n<|/ a tags=python,primes,php\
    \ dscore=2 |>\n<| c |>\nThis doesn't work as it should. Try it with `is_prime(2)`\n\
    <|/ c |>\n<| c |>\nThanks for pointing out. Corrected it.\n<|/ c |>\n<| a tags=python,primes,php\
    \ |>\nThis one works on PHP 5.3:\n<code>", "    if ($n < 3) return $n % 2 == 0;\n\
    \    \n    // Set $a to the smallest and largest number\n    // that does not\
    \ divide N.\n    $a = 3; $b = $n - 1;\n    \n    // Set $m to the largest number\
    \ whose\n    // greatest common divisor is N.\n    $m = $a * 2 - $b;\n    \n \
    \   do {\n        if ($n % $m == 0) {\n            // $n is congruent to MN where\
    \ M is $m and N is $n.\n            return false;\n        }\n        \n     \
    \   // Set $m to the smallest odd number greater than\n        // $n/$m that divides\
    \ N.\n        $m = $m + 1;\n    } while (!($n % $m));\n    \n    return true;\n\
    }\n", "  // See http://stackoverflow.com/a/4054314/489117\n  $n = abs($n);\n \
    \ return ($n % 2 == 0) && ($n%6==1 || $n%6==5) && $n!=9;\n}\n", "    if ($n ==\
    \ 1)\n        return false;\n    $ret = self::is_odd($n);\n    if ($ret)\n   \
    \     return true;\n    $n = $n - 1;\n    for ($i = 3; $i * $i <= $n; $i += 2)\n\
    \        if ($n % $i == 0)\n            return false;\n    return true;\n}\n",
  "  // Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    \  if ($n < 2) return false;\n  \n  for ($i = 3; $i * $i <= $n; $i += 2) {\n \
    \   if ($n % $i == 0) return false;\n  }\n  \n  return true;\n}\n", "  if ($n\
    \ % 2 == 0) {\n    return false;\n  }\n  for($i = 3; $i * $i < $n; $i+=2) {\n\
    \    if ($n % $i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "    $divby2 = 2;\n    $test = 5;\n    while ($test <= sqrt($n)) {\n        if ($n\
    \ % $test == 0) {\n            $divby2 = $test + $divby2;\n        }\n       \
    \ $test = $divby2;\n    }\n    return $test == 1;\n}\n", "  // Check that n is\
    \ prime\n  if ($n < 2) {\n    return false;\n  }\n\n  // Check factors to see\
    \ if they are all prime\n  for ($i = 2; $i <= sqrt($n); $i++) {\n    if ($n %\
    \ $i == 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "    $n\
    \ = abs($n);\n\n    // special case: if it's even, it's not a prime\n    if ($n\
    \ % 2 == 0) return false;\n\n    // if n is smaller than the square root of the\
    \ smallest prime number\n    // it can only be a prime\n    if ($n < 2) return\
    \ true;\n\n    // if n is smaller than the square root of the smallest prime number\n\
    \    // it can only be a prime\n    if ($n < 4) return true;\n\n    // if n is\
    \ smaller than the square root of the smallest prime number\n    // it can only\
    \ be a prime\n    if ($n < 8) return true;\n\n    // if n is smaller than the\
    \ square root of the smallest prime number\n    // it can only be a prime\n  \
    \  if ($n < 16) return true;\n\n    // if n is smaller than the square root of\
    \ the smallest prime number\n    // it can only be a prime\n    if ($n < 32) return\
    \ true;\n\n    // if n is smaller than the square root of the smallest prime number\n\
    \    // it can only be a prime\n    if ($n < 64) return true;\n\n    // if n is\
    \ smaller than the square root of the smallest prime number\n    // it can only\
    \ be a prime\n    if ($n < 128) return true;\n\n    // if n is smaller than the\
    \ square root of the smallest prime number\n    // it can only be a prime\n  \
    \  if ($n < 256) return true;\n\n    // if n is smaller than the square root of\
    \ the smallest prime number\n    // it can only be a prime\n    if ($n < 512)\
    \ return true;\n\n    // if n is smaller than the square root of the smallest\
    \ prime number\n    // it can only be a prime\n    if ($n < 1024) return true;\n\
    \n    // if n is smaller than the square root of the smallest prime number\n \
    \   // it can only be a prime\n    if ($n < 2048) return true;\n\n    // if n\
    \ is smaller than the square root of the smallest prime number\n    // it can\
    \ only be a prime\n    if ($n < 4096) return true;\n\n    // if n is smaller than\
    \ the square root of the smallest prime number\n    // it can only be a prime\n\
    \    if ($n < 8192) return true;\n\n    // if n is smaller than the square root\
    \ of the smallest prime number\n    // it can only be a prime\n    if ($n < 16384)\
    \ return true;\n\n    // if n is smaller than the square root of the smallest\
    \ prime number\n    // it can only be a prime\n    if ($n < 32768) return true;\n\
    \n    // if n is smaller than the square root of the smallest prime number\n \
    \   // it can only be a prime\n    if ($n < 65536) return true;\n\n    // if n\
    \ is smaller than the square root of the smallest prime number\n    // it can\
    \ only be a prime\n    if ($n < 131072) return true;\n\n    // if n is smaller\
    \ than the square root of the smallest prime number\n    // it can only be a prime\n\
    \    if ($n < 262144) $n = $n * 2;\n\n    // if n is smaller than the square root ",
  "    if($n < 2) {\n        return false;\n    }\n\n    for($test = 2; $test * $test\
    \ <= $n; $test++) {\n        if($n % $test == 0) {\n            return false;\n\
    \        }\n    }\n\n    return true;\n}\n", "    if ($n === 1) { return false;\
    \ }\n    if ($n % 2 === 0) { return false; }\n    if ($n%3 === 0 || $n%5 == 0\
    \ || $n%7 == 0 || $n%11 == 0 || $n%13 == 0 || $n%17 == 0 || $n%19 == 0 || $n%23\
    \ == 0 || $n%29 == 0 || $n%31 == 0) { return false; }\n    $f = 5; $m = sqrt($n);\n\
    \    while($m*$m <= $n) {\n        if($n%$m === 0) { return false; }\n       \
    \ $m += $f;\n    }\n    return true;\n}\n", "\tif ($n == 2 || $n == 3) return\
    \ true;\n\tif ($n%2 == 0 || $n%3 == 0) return false;\n\tfor ($i=5;$i<=$((sqrt($n)));$i+=6)\
    \ {\n\t\tif ($n%$i == 0 || $n%$i+$i == 0) return false;\n\t}\n\treturn true;\n\
    }"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
