name: HumanEval_70_strange_sort_list
language: php
prompt: "<?php\n// Given list of integers, return list in strange order.\n// Strange\
  \ sorting, is when you start with the minimum value,\n// then maximum of the remaining\
  \ integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3,\
  \ 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([])\
  \ == []\nfunction strange_sort_list($lst) {\n"
tests: "function candidate(...$args) {\n    return strange_sort_list(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(array(1, 2, 3, 4)) !== array(1,\
  \ 4, 2, 3)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(5,\
  \ 6, 7, 8, 9)) !== array(5, 9, 6, 8, 7)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(1, 2, 3, 4, 5)) !== array(1, 5, 2, 4, 3)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(5, 6, 7, 8, 9, 1))\
  \ !== array(1, 9, 5, 8, 6, 7)) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(5, 5, 5, 5)) !== array(5, 5, 5, 5)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array()) !== array()) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 2, 3, 4, 5, 6, 7, 8)) !== array(1,\
  \ 8, 2, 7, 3, 6, 4, 5)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(0,\
  \ 2, 2, 2, 5, 5, -5, -5)) !== array(-5, 5, -5, 5, 0, 2, 2, 2)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(111111)) !== array(111111)) { throw\
  \ new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $lst_copy = array_flip($lst);\n    arsort($lst_copy);\n    return\
    \ array_flip($lst_copy);\n}", "  if (empty($lst)) return [];\n  $lst_tmp = $lst;\n\
    \  $lst_tmp = array_reverse($lst_tmp);\n  return $lst_tmp;\n}\n", "    // sort\
    \ by first item, descending\n    array_multisort(array_reverse(array_keys($lst)),\
    \  SORT_NUMERIC,  $lst);\n\n    // reverse order of sorted keys\n    foreach(array_reverse(array_keys($lst))\
    \ as $key)\n        $lst[$key] = $lst[$key][0];\n    return $lst;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nI used this as my base code, and modified it slightly:\n\
    <code>", "    $min = array_shift($lst);\n    sort($lst);\n    $max = array_pop($lst);\n\
    \    sort($lst);\n    $min = array_shift($lst);\n    sort($lst);\n    $max = array_pop($lst);\n\
    \    sort($lst);\n    $min = array_shift($lst);\n    sort($lst);\n    return array($min,\
    \ $max, $lst);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNice solution, I was thinking\
    \ of writing a recursive function, but this looks much more elegant.\n<|/ c |>\n\
    <| c |>\nThe best and most elegant solution I have seen on internet! :)\n<|/ c\
    \ |>\n<| c |>\nNice solution. Can we do this in other languages other than php?\
    \ I am working on python now and wondering if there's any similar solution.\n\
    <|/ c |>\n<| c |>\nYou will have to replace `sort($lst)` with another function\
    \ that can sort the list for you in some other language.\n<|/ c |>\n<| c |>\n\
    Thanks for this solution. I've made a small modification to suit my needs: It\
    \ returns an empty list if all integers are equal. `strange_sort_list([1, 1, 2,\
    \ 2, 3, 3]) == [1, 3, 2, 4, 1, 3]`\n<|/ c |>\n<| a dscore=5 tags=algorithm,sorting\
    \ |>\nAs the answer by is quite elegant and short, here is a more verbose answer\
    \ for those who don't feel comfortable with recursion yet. \n<code>", "  foreach\
    \ ($lst as $key => $val) {\n    for ($i = $key + 1; $i < count($lst); $i++) {\n\
    \      $swap = $lst[$i];\n      $lst[$i] = $lst[$key];\n      $lst[$key] = $swap;\n\
    \    }\n  }\n  return $lst;\n}", "  $l = count($lst);\n  if ($l === 0) {\n   \
    \ return [];\n  }\n  $min = reset($lst);\n  $max = end($lst);\n  $even = reset($lst);\n\
    \  $odd = end($lst);\n  for ($i = 1; $i <= $l; $i++) {\n    if ($lst[$i] < $min)\
    \ {\n      $min = $lst[$i];\n    } else if ($lst[$i] > $max) {\n      $max = $lst[$i];\n\
    \    } else if ($lst[$i] === $even) {\n      $even = $lst[$i];\n    } else if\
    \ ($lst[$i] === $odd) {\n      $odd = $lst[$i];\n    }\n  }\n  asort($lst);\n\
    \  return array_merge(array($min), $lst, array($max), array($even), array($odd));\n\
    }\n", "    // Sort only if the list is not empty.\n    if (!empty($lst)) {\n \
    \       $min = $lst[0];\n        $max = max($lst);\n        $min_index = array_search($min,\
    \ $lst);\n        $lst = array_merge($lst, array_fill(0, count($lst) - 1, $max));\n\
    \        $lst =  array_merge($lst, array_fill(0, count($lst) - 1, $min));\n  \
    \      $lst =  array_merge($lst, array_fill(0, count($lst) - 1, $min_index));\n\
    \    }\n    return $lst;\n}\n</code>\nThe above example will return the list in\
    \ the order from smallest to largest. This means, if the list contains multiple\
    \ occurrences of the same value, it will sort it at the end.\n<|/ a |>\n<| c |>\n\
    This is not the right way since it sorts the duplicate values at the end. Try\
    \ it with `[1, 1, 2, 3, 3, 3]`.\n<|/ c |>\n<| c |>\nYeah, I missed that. Thought\
    \ there could be only two unique elements in the list. I'll update my answer.\n\
    <|/ c |>\n<| a dscore=3 tags=arrays,php |>\n<code>\n$arr = [1, 1, 2, 3, 3, 3];\n\
    usort($arr, function($a, $b) {\n    return $a > $b;\n});\n\nprint_r($arr);\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "    $sorted = $lst;\n    asort($sorted);\n    return\
    \ $sorted;\n}\n", "    sort($lst);\n    $min = min($lst);\n    $max = max($lst);\n\
    \    $mid = $min + ($max - $min) / 2;\n    array_push($lst, $mid);\n    sort($lst);\n\
    \    return $lst;\n}\n</code>\nOutput\n<code>\n$lst = strange_sort_list([4, 1,\
    \ 3, 2]);\necho \"<pre>\";\nprint_r($lst);\necho \"</pre>\";\n</code>\n<|/ a |>\n\
    <| c |>\nThat is so elegant man\n<|/ c |>\n<| a dscore=1 |>\nUse array_map and\
    \ array_unshift\n<code>\n<?php\n$arr = [4, 5, 3, 1, 2, 6, 7];\n\n$new_arr = array_map(function($v){\n\
    \  return $v * $v;\n}, $arr);\n\narray_unshift($new_arr, 0);\n\nprint_r($new_arr);\n\
    </code>\n<|/ a tags=php,arrays |>\n<| c |>\nI like this one, since it keeps the\
    \ original array intact (although it does change the order of the array elements)\n\
    <|/ c |>\n<| a |>\n<code>\n<?php\n\n$numbers = [1,2,3,4,5,6,7,8,9,10];\nfor($i=0;$i<count($numbers);$i++){\n\
    \    $numbers[$i] = $i*$i;\n}\n</code>\n<|/ a dscore=1 tags=php,arrays |>\n<|\
    \ c |>\nThis one works too, but why use loop if we can use array_map and array_unshift\
    \ ?\n<|/ c |>\n<| a dscore=1 |>\nYou can use array_map() and array_unshift() to\
    \ achieve this. \nThe first argument to array_map() will be a callback that will\
    \ receive each array element and return the value you want.\nThe second argument\
    \ to array_unshift() will be the value you want to be the first element of the\
    \ array after mapping the callback.\nThe third argument to array_map() is the\
    \ original array you want to map the callback to (the first argument). \nThe final\
    \ line is to ensure that the original array is unchanged since you don't want\
    \ to change the original array but map the callback onto it.\n<code>\n$arr = [4,\
    \ 5, 3, 1, 2, 6, 7];\narray_unshift(array_map(function($a) {\n    return $a *\
    \ $a;\n}, $arr), 0);\nprint_r($arr);\n</code>\nOutput:\n<code>\nArray\n(\n   \
    \ [0] => 0\n    [1] => 4\n    [2] => 9\n    [3] => 16\n    [4] => 25\n    [5]\
    \ => 36\n    [6] => 49\n    [7] => 64\n    [8", "    $sorted = [];\n\n    if (!$lst)\
    \ {\n        return $sorted;\n    }\n\n    $sorted = $lst;\n    $sorted = array_reverse($sorted);\n\
    \n    return $sorted;\n}\n</code>\n<|/ a dscore=2 tags=arrays,sorting,php |>\n\
    <| a tags=arrays,sorting,php |>\nTry this \n<code>", "    $lst_length       =\
    \ count($lst);\n    $min_value        = min($lst);\n    $max_value        = max($lst);\n\
    \    $min_value_index   = $lst_length-1;\n    $max_value_index   = 0;\n\n    for\
    \ ($index = 0; $index < $lst_length; $index++) {\n        if ($lst[$index] ==\
    \ $min_value) {\n            $min_value_index = $index;\n        }\n        if\
    \ ($lst[$index] == $max_value) {\n            $max_value_index = $index;\n   \
    \     }\n    }\n\n    if ($min_value_index < $max_value_index) {\n        $tmp\
    \ = $lst[$min_value_index];\n        $lst[$min_value_index] = $lst[$max_value_index];\n\
    \        $lst[$max_value_index] = $tmp;\n\n        for ($index = $min_value_index+1;\
    \ $index < $lst_length; $index++) {\n            if ($lst[$index-1] < $lst[$index])\
    \ {\n                $tmp = $lst[$index-1];\n                $lst[$index-1] =\
    \ $lst[$index];\n                $lst[$index] = $tmp;\n            }\n       \
    \ }\n    }\n    return $lst;\n}", "  sort($lst);\n  return $lst;\n}\n", "  $min\
    \ = array_shift($lst);\n  $max = array_shift($lst);\n  foreach ($lst as $el) {\n\
    \    if ($el < $min) $min = $el;\n    if ($el > $max) $max = $el;\n  }\n  $res\
    \ = [];\n  for ($i = $min; $i <= $max; $i++) {\n    $res[] = $i;\n  }\n  return\
    \ $res;\n}\n", "    $min = min($lst);\n    $max = max($lst);\n    $sorted = array();\n\
    \    for ($i = $min; $i < $max; $i++) {\n        $sorted[] = $i;\n    }\n    array_multisort($sorted,\
    \ $lst);\n    return $sorted;\n}\n\n$list = strange_sort_list($list_values);",
  "  // create new sorted array and add all items to it\n  $sortedArr = array();\n\
    \  foreach ($lst as $item) {\n    $sortedArr[] = $item;\n  }\n  \n  // sort this\
    \ array in reverse order\n  rsort($sortedArr);\n  \n  // return array without\
    \ first and last element\n  return array_slice($sortedArr, 1, -1);\n}\n", "  \
    \  // No elements?\n    if (count($lst) == 0) {\n        return [];\n    }\n \
    \   $min = $lst[0];\n    $max = $lst[0];\n    foreach ($lst as $element) {\n \
    \       if ($element < $min) {\n            $min = $element;\n        } elseif\
    \ ($element > $max) {\n            $max = $element;\n        }\n    }\n    return\
    \ $lst;\n}", "  // Sort descending by minimum.\n  return array_merge($lst,\n \
    \     array_reverse($lst, function($v1, $v2) {\n        return $v1 - $v2;\n  \
    \    })\n  );\n}", "  // Sort list first\n  sort($lst);\n  foreach ($lst as $key\
    \ => $value) {\n    $new[$key] = $value;\n  }\n\n  // Now start with the highest\
    \ number\n  $new_max = max($new);\n  unset($new[$new_max]);\n  $new_min = min($new);\n\
    \  unset($new[$new_min]);\n  $new_min += 1;\n  foreach ($new as $key => $value)\
    \ {\n    $new[$key] = $new_min + $key;\n  }\n\n  return $new;\n}\n", "  $min =\
    \ min(array_keys($lst));\n  $max = max(array_keys($lst));\n\n  for ($i = $min;\
    \ $i <= $max; $i++) {\n    $swap = $lst[$i];\n    foreach ($lst as $key => $val)\
    \ {\n      if ($key == $i) {\n        unset($lst[$key]);\n        $lst[$key] =\
    \ $swap;\n      }\n    }\n  }\n\n  return $lst;\n}\n", "  // We start with the\
    \ first integer.\n  $cur = head($lst);\n  while ($cur !== null) {\n    // Now\
    \ we swap with the last one in order.\n    $tmp = last($lst);\n    last($lst)\
    \ = head($lst);\n    head($lst) = $cur;\n    $cur = $tmp;\n  }\n  return $lst;\n\
    }", "  $lst = array_map('intval', $lst);\n  usort($lst, 'strange_sort_func');\n\
    \  return $lst;\n}\n", "    $length = count($lst);\n    for($i = 0; $i < $length;\
    \ $i++) {\n        $j = $length - 1;\n        while($j > 0 && $lst[$i] > $lst[$j])\
    \ {\n            $swap = $lst[$j];\n            $lst[$j] = $lst[$i];\n       \
    \     $lst[$i] = $swap;\n            $j--;\n        }\n    }\n    return $lst;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nYou could use this snippet with a little\
    \ less code:\n<code>", "    $min = array_shift($lst);\n    foreach ($lst as $v)\
    \ {\n        $tmp = $v;\n        if ($tmp < $min) {\n            $min = $tmp;\n\
    \        }\n    }\n    $lst = array_merge([$min], $lst);\n    return $lst;\n}\n",
  "  if (empty($lst)) return $lst;\n  $last = count($lst) - 1;\n  $min_int = min($lst);\n\
    \  $max_int = max($lst);\n  $swap = $min_int;\n  foreach ($lst as $key => $value)\
    \ {\n    if ($value < $swap) {\n      list($list[$key], $list[$swap]) = array($list[$swap],\
    \ $list[$key]);\n    }\n    if ($value == $swap) {\n      if ($key + 1 != $last)\
    \ {\n        $swap = $value;\n        continue;\n      }\n      break;\n    }\n\
    \  }\n  return $list;\n}\n$sorted_lists = strange_sort_list($lists);", "    if\
    \ (empty($lst)) {\n        return [];\n    }\n\n    $min_idx = array_search(min($lst),\
    \ $lst);\n    $max_idx = array_search(max($lst), $lst);\n\n    $tmp = $lst;\n\
    \    unset($tmp[$max_idx]);\n\n    foreach (array_reverse(range($min_idx, $max_idx))\
    \ as $idx) {\n        $tmp[$idx] = $lst[$idx];\n    }\n\n    return $tmp;\n}\n\
    </code>\nDemo: https://3v4l.org/4SZ8A\n<|/ a |>\n<| a |>\n<code>\n$arr = [1,3,4,6,7,8,9,5,6,4,3,5];\n\
    $min_key = min($arr);\n$max_key = max($arr);\n$min_index = array_search($min_key,$arr);\n\
    $max_index = array_search($max_key,$arr);\n$swap = $arr[$max_index];\n$arr[$max_index]\
    \ = $arr[$min_index];\n$arr[$min_index] = $swap;\n</code>\n<|/ a dscore=0 tags=php,sorting,arrays\
    \ |>\n<| c |>\nplease add some explanation with your answer.\n<|/ c |>\n<| c |>\n\
    He is sorting in descending order\n<|/ c |>\n<| a tags=php,sorting,arrays dscore=0\
    \ |>\nYou can use the following code\n<code>\n$array = [1,3,4,6,7,8,9,5,6,4,3,5];\n\
    $firstIndexOfMin = array_search(min($array), $array);\n$lastIndexOfMax = array_search(max($array),\
    \ $array);\n$tmpArray = $array;\n$tmpArray[$lastIndexOfMax] = $tmpArray[$firstIndexOfMin];\n\
    unset($tmpArray[$firstIndexOfMin]);\nprint_r($tmpArray);\n</code>\n<|/ a |>\n\
    <| a |>\nThis solution will also work for associative arrays.\n<code>\n<?php\n\
    \n$array = [\n    ['name' => 'Jack', 'age' => 20],\n    ['name' => 'Mick', 'age'\
    \ => 35],\n    ['name' => 'Alex', 'age' => 28]\n];\n\n$minKey = 'age';\n$maxKey\
    \ = 'name';\n$minValue = null;\n$maxValue = null;\n", "    $lst_sorted = array();\n\
    \n    foreach ($lst as $int) {\n        if ($int >= 1) {\n            $lst_sorted[]\
    \ = $int + $lst_sorted[count($lst_sorted) - 1];\n        }\n    }\n\n    return\
    \ $lst_sorted;\n}\n", "  if (!empty($lst)) {\n    $sorted_list = array();\n  \
    \  foreach ($lst as $item) {\n      $index = array_search($item, $sorted_list);\n\
    \      if ($index === FALSE) {\n        $sorted_list[] = $item;\n      } else\
    \ {\n        $index += 1;\n        $sorted_list[$index] = $item;\n      }\n  \
    \  }\n    return $sorted_list;\n  }\n  return array();\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nOk, so I came up with a solution that is rather messy, but it does\
    \ the trick. \nI am sure there are more elegant ways of doing this, but it gets\
    \ the job done :)\nHere it is, I'll explain what it does and how it works:\n<code>\n\
    <?php\n", "    $count = count($lst);\n    $index = 0;\n    $max = $lst[$index];\n\
    \n    for ($i = 1; $i < $count; $i++) {\n        if ($lst[$i] > $max) {\n    \
    \        $max = $lst[$i];\n            $index = $i;\n        }\n    }\n    if\
    \ ($index == 0) {\n        return $lst;\n    }\n\n    for ($i = $index - 1; $i\
    \ >= 0; $i--) {\n        $tmp = $lst[$i];\n        $lst[$i] = $lst[$index];\n\
    \        $lst[$index] = $tmp;\n    }\n    return $lst;\n}", "  foreach ($lst as\
    \ $key => $value) {\n    if ($value <= min($lst)) {\n      unset($lst[$key]);\n\
    \    }\n  }\n  foreach ($lst as $key => $value) {\n    if ($value >= max($lst))\
    \ {\n      unset($lst[$key]);\n    }\n  }\n  return $lst;\n}\n", "  if (!$lst)\
    \ {\n    return array();\n  }\n  $min = $max = $first = $lst[0];\n  for ($i =\
    \ 1; $i < count($lst); $i++) {\n    if ($lst[$i] < $first) {\n      $first = $lst[$i];\n\
    \    }\n    if ($lst[$i] > $max) {\n      $max = $lst[$i];\n    }\n  }\n  $first\
    \ = strange_sort_list($lst);\n  $lst = array();\n  for ($i = $min; $i < $max;\
    \ $i++) {\n    $lst[] = $first[$i];\n  }\n  return $lst;\n}\n", "    if (count($lst)\
    \ == 0) {\n        return $lst;\n    }\n    $result = $lst;\n    if ($lst[0] <\
    \ $lst[count($lst) - 1]) {\n        $result = $lst;\n        sort($result);\n\
    \    }\n\n    $swap = null;\n    $tmp = $lst[0];\n    for ($i = 0; $i < count($lst)\
    \ - 1; $i++) {\n        if ($lst[$i] > $lst[$i + 1]) {\n            $swap = $lst[$i];\n\
    \            $lst[$i] = $lst[$i + 1];\n            $lst[$i + 1] = $swap;\n   \
    \     }\n    }\n    return $lst;\n}\n", "  // First we sort the list by its minimum\
    \ value\n  // If that value was already in the list, it will\n  // be the first\
    \ element in the sorted list\n  $sorted_list = array();\n  foreach ($lst as $value)\
    \ {\n    if (in_array($value, $sorted_list)) {\n      continue;\n    }\n    $sorted_list[$value]\
    \ = $value;\n  }\n\n  // Now, we sort the list by its maximum value\n  foreach\
    \ ($lst as $value) {\n    if (in_array($value, $sorted_list)) {\n      continue;\n\
    \    }\n    $sorted_list[$value] = $value;\n  }\n\n  return $sorted_list;\n}",
  "    // sort list to start with the minimum\n    usort($lst, function ($a, $b) {\n\
    \        return $a < $b ? -1 : 1;\n    });\n\n    // loop through rest of list\
    \ and swap minimum and current value\n    foreach ($lst as $key => $value) {\n\
    \        if ($value == $lst[0]) {\n            array_shift($lst);\n        }\n\
    \    }\n\n    return $lst;\n}\n</code>\nI hope this is what you are looking for!\n\
    <|/ a |>\n<| c |>\nI think this is what I am looking for, however, the problem\
    \ I have is that there can be duplicate values and I need to preserve them in\
    \ the array and sort the values differently. For example, I need to sort {1, 2,\
    \ 3, 4} into {1, 3, 2, 4} and {3, 1, 2, 4} into {3, 2, 4, 1} etc...\n<|/ c |>\n\
    <| c |>\nAhh I understand, so the duplicate values can remain in their correct\
    \ place but they need to be sorted in a different order?\n<|/ c |>\n<| c |>\n\
    Yes, that is correct\n<|/ c |>\n<| a tags=php,arrays,sorting |>\nYou can use array_map\
    \ to iterate through each value in the array and sort it, then use array_merge\
    \ to merge the results back together\n<code>\n<?php", "    return array_merge(\n\
    \            array_merge(\n                    array_merge(\n                \
    \            array_merge(array(), $lst),\n                            $lst),\n\
    \                    $lst),\n            $lst);\n}\n", "    $new_lst = array();\n\
    \    $first = min($lst);\n    $last = max($lst);\n    foreach ($lst as $number)\
    \ {\n        if ($number > $first) {\n            $new_lst[] = $first;\n     \
    \       $first = $number;\n        } else if ($number < $last) {\n           \
    \ $new_lst[] = $last;\n            $last = $number;\n        }\n    }\n    return\
    \ $new_lst;\n}\n</code>\n<|/ a tags=php,arrays,sorting |>\n<| c |>\nThanks for\
    \ the answer, but that's not what I'm looking for. I want the array to be sorted\
    \ in the way the original array is ordered. The answer from Kolink did the trick.\n\
    <|/ c |>\n<| a tags=php,arrays,sorting |>\nMy attempt.\n<code>", "  $sorted_list\
    \ = array();\n  usort($lst, 'strange_sort');\n  $sorted_list = array_reverse($sorted_list);\n\
    \  return $sorted_list;\n}\n", "    $min = min($lst);\n    $max = max($lst);\n\
    \n    for($i = 0; $i < count($lst); $i++) {\n        if($lst[$i] == $min) {\n\
    \            sort($lst);\n        } else {\n            sort($lst);\n        \
    \    array_shift($lst);\n        }\n    }\n\n    return $lst;\n}\n\n$data = $_POST['userInput'];\n\
    $data = str_replace(\",\",\"\",$data);\n\n$fileContent = file_get_contents($_POST['fileToUpload']);\n\
    $fileContent = str_replace(\",\",\"\",$fileContent);\n", "    $min = reset($lst);\n\
    \    $max = end($lst);\n    $middle = floor(($min + $max) / 2);\n    return array_merge($lst,\
    \ array_merge(array($min), array_merge($lst,\n            array($middle), array_merge(array($max),\
    \ $lst)));\n}\n", "    if (!$lst)\n        return $lst;\n\n    // Sort minimum\
    \ and maximum\n    $min_val = min($lst);\n    $max_val = max($lst);\n\n    //\
    \ Create new list with minimum and maximum\n    $new_list = array();\n    foreach\
    \ ($lst as $val) {\n        if ($val == $min_val)\n            $new_list[0] =\
    \ $min_val;\n        elseif ($val == $max_val)\n            $new_list[1] = $max_val;\n\
    \        else\n            $new_list[] = $val;\n    }\n\n    return $new_list;\n\
    }\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm,php,arrays |>\nThe algorithm\
    \ is quite simple.\nYou need to go through each element, find the minimum and\
    \ maximum, swap them, and start over again. \nThe minimum will end up with the\
    \ smallest element, the maximum will end up with the largest element, and each\
    \ element will end up with the one that had its place in the original list. \n\
    To make the algorithm more efficient (O(nlogn)), you need to sort your list first\
    \ using selection sort or quick sort (O(nlogn)). Then you can go through your\
    \ list and swap elements until they're in the same place. If you want to do it\
    \ in less code, just use array_search.\n<code>\n<?php\n\n$a = array(1, 6, 4, 8,\
    \ 7, 5, 2);\n", "    $sorted = array();\n    foreach ($lst as $v) {\n        $sorted[]\
    \ = $v;\n    }\n    array_multisort($sorted, SORT_NUMERIC, $lst);\n    return\
    \ $lst;\n}\n", "\tksort($lst);\n\trsort($lst);\n\tusort($lst, function($a, $b)\
    \ {\n\t\tif ($a == $b) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ($a < $b) {\n\t\t\treturn\
    \ 1;\n\t\t}\n\t\treturn -1;\n\t});\n\treturn $lst;\n}\n", "  $min_value = min($lst);\n\
    \  $max_value = max($lst);\n  $result = [];\n  for ($i = $min_value; $i <= $max_value;\
    \ $i++) {\n    $result[] = $i;\n  }\n  return $result;\n}", "  if (empty($lst))\
    \ {\n    return array();\n  }\n\n  // Find the min/max of the list\n  $max_value\
    \ = min($lst);\n  $min_value = max($lst);\n\n  // Sort by descending order of\
    \ the list\n  $lst = array_reverse($lst);\n\n  // Iterate over the list and sort\
    \ each element with the max/min\n  // We have to use array_map as array_sort doesn't\
    \ support callback parameter\n  $result = array_map(function ($a, $b) use ($max_value,\
    \ $min_value) {\n    return ($a - $min_value) * ($a - $max_value) < ($b - $min_value)\
    \ * ($b - $max_value) ? 1 : -1;\n  }, $lst, $lst);\n\n  return $result;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nThis code works in PHP 5.5 and later. I used the sort() function\
    \ instead of usort(), because the usort() function is deprecated.\nThis also works\
    \ in PHP 7.0, PHP 7.1, and PHP 7.2.\n<code>", "    $len = count($lst);\n    $result\
    \ = $lst;\n    for ($i = 0; $i < $len; $i++) {\n        if ($i != $len - 1) {\n\
    \            $result[$i] = $lst[$len - 1];\n        }\n        $result[$i] = $i;\n\
    \    }\n    return $result;\n}", "  $min = $lst[0];\n  foreach($lst as $key =>\
    \ $val){\n    if($val < $min){\n      $min = $val;\n    }\n  }\n\n  $min++;\n\
    \  foreach($lst as $key => $val){\n    if($val > $min){\n      $lst[$key] = $min;\n\
    \    }\n  }\n\n  $min--;\n  foreach($lst as $key => $val){\n    if($val < $min){\n\
    \      $lst[$key] = $min;\n    }\n  }\n\n  return $lst;\n}\n", "  sort($lst);\n\
    \  $min = reset($lst);\n  asort($lst);\n  return $min;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nI have just read a very good article on this. A very simple\
    \ and clean solution is available here \n<code>", "    $list = $lst;\n    sort($list);\n\
    \    return $list;\n}\n</code>\nI hope this helps! If I'm missing something, or\
    \ anything else is unclear, please let me know and I'll edit this post. Cheers.\n\
    <|/ a |>\n<| c |>\nThanks for your answer. It works. But I used `krsort` instead\
    \ of `sort`, which is faster. I found this solution [here](http://www.php.net/manual/en/function.sort.php#117094).\n\
    <|/ c |>\n<| c |>\nNo problem! I realized that `krsort` was actually a pretty\
    \ neat solution, thanks for mentioning it :)\n<|/ c |>\n<| c |>\nA very nice solution\
    \ +1 :)\n<|/ c |>\n<| c |>\nThanks. +1 :)\n<|/ c |>\n<| c |>\nThank you for your\
    \ answer.\n<|/ c |>\n<| a tags=arrays,php dscore=2 |>\n<code>", "    $sorted =\
    \ [];\n\n    // First pass, find min and max values\n    for ($i = 0; $i < count($lst);\
    \ $i++) {\n        $sorted[$i] = [$i, $lst[$i]];\n    }\n    uksort($sorted, 'strange_sort_cmp');\n\
    \n    // Second pass, reverse the min and max values\n    for ($i = count($lst)\
    \ - 1; $i >= 0; $i--) {\n        $sorted[$i] = [$i, $lst[$i]];\n    }\n    uksort($sorted,\
    \ 'strange_sort_cmp');\n\n    return $sorted;\n}\n\n/**\n * Compare function for\
    \ uksort.\n *\n * @param array $a First value.\n * @param array $b Second value.\n\
    \ *\n * @return int Negative integer if $a < $b, positive integer if $a > $b,\
    \ zero if\n *           they are equal.\n */", "  $min_val = 0;\n  $max_val =\
    \ 1000;\n  foreach ($lst as $val) {\n    if ($val < $min_val) $min_val = $val;\n\
    \    if ($val > $max_val) $max_val = $val;\n  }\n  $arr = array();\n  $count =\
    \ 0;\n  for ($val = $min_val; $val <= $max_val; $val++) {\n    while ($count <\
    \ count($lst) && $val == $lst[$count]) {\n      $arr[] = $val;\n      $count++;\n\
    \    }\n  }\n  return $arr;\n}\n</code>\n<|/ a tags=sorting,php,arrays dscore=2\
    \ |>\n<| a tags=sorting,php,arrays |>\n<code>", "  return array_merge(\n    array_slice($lst,\
    \ 0, -1),\n    array_slice($lst, -1),\n    array_slice($lst, 0, -1)\n  );\n}\n",
  "    $sort = array();\n    $sortf = function() use (&$sort, $lst) {\n        $sortf\
    \ = array();\n        foreach($sort as $i => $sortf) {\n            foreach($lst[$sortf]\
    \ as $k => $v) {\n                if(isset($sort[$k]) && $sort[$k] === $sortf)\
    \ {\n                    $sortf[] = $k;\n                }\n            }\n  \
    \      }\n        $sort = $sortf;\n        return $sort;\n    };\n    $sortf();\n\
    \    $result = array();\n    foreach($sortf() as $k => $v) {\n        $result[]\
    \ = $lst[$v];\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=0 tags=php,arrays,algorithm\
    \ |>\n<| c |>\nThis is really helpful. However, it's not what I was looking for.\
    \ I'm looking for the \"Strange Sort Array\" algorithm. I want the array to be\
    \ sorted in such a way that when it's reversed, it comes back exactly as it was\
    \ sorted. Your solution would reverse the array and would not allow to rearrange\
    \ the array back as it was sorted. I'm looking for the \"Strange Sort Array\"\
    \ algorithm.\n<|/ c |>\n<| c |>\nI see what you're saying. I don't think you can\
    \ get the same result as a PHP built-in function. If you had a PHP function that\
    \ returned the sorted array (which you could reverse), you could call that function\
    \ twice: once to reverse the array and once to rearrange it back as it was sorted.\
    \ My algorithm would require a loop that would reverse the array multiple times\
    \ because of the nested foreach loops. My algorithm is much less elegant than\
    \ the built-in function.\n<|/ c |>\n<| c |>\nOh, I see what you're saying. You're\
    \ saying that I would be better off doing something similar to what you said and\
    \ not use the built in function? Hmmm...\n<|/ c |>\n<| c |>\nYeah, I was just\
    \ trying to be creative. Not a bad idea. You could even use a recursive function.\n\
    <|/ c |>\n<| a |>\n<code>\n$arr = array(1, 10, 3, 20, 5, 30, 15, 100, 2);\n\n\
    sort($arr);\n\n$reverse = array_reverse($arr);\nprint_r($arr);\necho \"<br>\"\
    ;\nprint_r($reverse);\n", "  $sort = array();\n  foreach($lst as $value) {\n \
    \   $sort[] = $value;\n  }\n  return sort($sort);\n}", "    foreach ($lst as $key\
    \ => $value) {\n        for ($i = $key + 1; $i < count($lst); $i++) {\n      \
    \      if ($lst[$i] < $value) {\n                unset($lst[$key]);\n        \
    \        array_splice($lst, $i, 0, $value);\n            }\n        }\n    }\n\
    \    return $lst;\n}\n", "  return array_merge(\n      array_slice($lst,0,1),\n\
    \      array_slice($lst,-1),\n      array_slice($lst,0,-1)\n      );\n}", "  \
    \  if (!is_array($lst)) {\n        return false;\n    }\n    $sort = array();\n\
    \    foreach ($lst as $key => $val) {\n        $sort[$key] = $val;\n        unset($lst[$key]);\n\
    \    }\n    ksort($sort);\n    return $sort;\n}\n\n/**\n * Returns true if the\
    \ given string is an integer.\n *\n * @param string $str String to check\n * @return\
    \ boolean Whether $str is an integer\n */", "  return array_merge(\n      array_reverse(array_slice($lst,\
    \ 1)),\n      array_slice($lst, 0, -1),\n      array_slice($lst, 1)\n  );\n}\n\
    </code>\n<|/ a tags=sorting,php dscore=1 |>\n<| a dscore=0 |>\nUse usort with\
    \ custom callback function\n<code>", "    $copy = $lst;\n    $sorted = [];\n \
    \   foreach ($copy as $key => $value) {\n        // Find the first value in the\
    \ list that is not the current value\n        $j = 0;\n        while ($j < (count($copy)\
    \ - 1)) {\n            if ($copy[$j] == $value) {\n                break;\n  \
    \          }\n            $j++;\n        }\n\n        if ($j == (count($copy)\
    \ - 1)) {\n            // The value already in the correct position\n        \
    \    // no need to sort this value\n            $sorted[] = $value;\n        }\
    \ else {\n            // Sort the value to the correct position\n            $tmp\
    \ = $value;\n            for ($i = $j + 1; $i < count($copy); $i++) {\n      \
    \          $tmp = $copy[$i];\n                for ($k = $j; $k < count($copy);\
    \ $k++) {\n                    if ($copy[$k] < $tmp) {\n                     \
    \   $copy[$k] = $tmp;\n                    }\n                }\n            }\n\
    \            $sorted[] = $tmp;\n        }\n    }\n    return $sorted;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post -\
    \ you can always comment on your own posts, and once you have sufficient [reputation](http://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment).\n\
    <|/ c |>\n<| c |>\nI agree with you on his first part. My apologies for the downvote\
    \ (not my vote) on my first answer. I updated my answer with a detailed description\
    \ of the algorithm. I also provided a link to the relevant wikipedia article.\n\
    <|/ c |>\n<| c |>\nI appreciate it. I upvoted your answer, but I think this approach\
    \ of swapping is better than a bubble sort, because this doesn't require to find\
    \ every single value in the list, instead of finding the minimum and maximum,\
    \ and then swapping the minimum and maximum. Also, the code is a lot more easy\
    \ to understand than the bubble sort implementation. Also, it requires less memory.\
    \ Also, it's slightly faster, because it doesn't require the extra loop to find\
    \ the minimum and maximum value during the bubble sort.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is a solution in javascript. Its fast for larger data sets than bubble\
    \ sort.\n<code>", "  if (!$lst) {\n    return [];\n  }\n\n  $min = min(array_keys($lst));\n\
    \  $max = max(array_keys($lst));\n  $min = min($min, $max);\n  $max = max($min,\
    \ $max);\n\n  $sorted_list = array();\n  for ($i = $min; $i <= $max; $i++) {\n\
    \    $sorted_list[] = $lst[$i];\n  }\n\n  return $sorted_list;\n}\n</code>\n<|/\
    \ a tags=php,sorting,arrays |>\n<| a tags=php,sorting,arrays |>\nUsing PHP7.1\
    \ you can sort a list like so:\n<code>\n$list = [\n    'b' => 1,\n    'd' => 5,\n\
    \    'c' => 3,\n    'a' => 2,\n    'e' => 4,\n];\n\nusort($list, [\n    Closure::bind(\n\
    \        function ($a, $b) {\n            return strcmp($a, $b) ?: 1;\n      \
    \  },\n        null,\n        new class() {\n            private $aKey;\n    \
    \        private $bKey;\n\n            public function __construct(array $aKey,\
    \ array $bKey) {\n                $this->aKey = $aKey;\n                $this->bKey\
    \ = $bKey;\n            }\n\n            public function getAKey() {\n       \
    \         return $this->aKey;\n            }\n\n            public function getBKey()\
    \ {\n                return $this->bKey;\n            }\n        }\n    ),\n]);\n\
    \n$list = array_values($list);\n</code>\nThe usort function accepts a comparison\
    \ function which can be any callable. Since this is a Closure, we can also pass\
    \ it other data by binding. We then bind the array keys as arguments to our comparison\
    \ function so that we can reference them in the function.\nThe comparison function\
    \ uses two parameters (the two array keys) to compare the two values. If the first\
    \ one comes first in the array, then the function should return 1. Otherwise,\
    \ it should return 0, which is equivalent to sorting by string length and alphabetical\
    \ order in most applications.\n<|/ a dscore=3 |>\n<| c |>\nThanks for sharing!\
    \ I was looking for a way to sort an array according to another array and I did\
    \ this a little differently, see my answer below: https://stackoverflow.com/a/65751143/2735286\n\
    <|/ c |>\n<| a tags=php,sorting,arrays |>\nHere's a more generic way to sort an\
    \ array according to another array (that could be a key or value array, not necessarily\
    \ the array's keys). It's a method which uses usort() to sort the array, then\
    \ array_values() to reset the array's keys. \n<code>", "  $min = min($lst);\n\
    \  $max = max($lst);\n\n  $sorted_lst = [];\n  for ($i = $min; $i <= $max; $i++)\
    \ {\n    $sorted_lst[] = $i;\n  }\n\n  return $sorted_lst;\n}\n", "    $length\
    \ = count($lst);\n    for ($i = 0; $i < $length; $i++) {\n        for ($j = $i\
    \ + 1; $j < $length; $j++) {\n            if ($lst[$i] > $lst[$j]) {\n       \
    \         $swap = $lst[$j];\n                $lst[$j] = $lst[$i];\n          \
    \      $lst[$i] = $swap;\n            }\n        }\n    }\n    return $lst;\n\
    }\n", "  // If empty list, return empty list.\n  if(!$lst) {\n    return [];\n\
    \  }\n\n  // Initialize variables.\n  $min = min($lst);\n  $max = max($lst);\n\
    \  $min_idx = 0;\n  $max_idx = count($lst) - 1;\n\n  while(true) {\n    // Compare\
    \ current element to its neighbors.\n    // At least one of the neighbors must\
    \ greater than\n    // the current value.\n    if($lst[$min_idx] > $lst[$max_idx]\
    \ || $lst[$max_idx] > $lst[$min_idx]) {\n      // Find the next highest value.\n\
    \      if($lst[$min_idx] > $min) {\n        $next_max_idx = $min_idx;\n      }\
    \ else {\n        $next_max_idx = $max_idx;\n      }\n    } else {\n      // Find\
    \ the next lowest value.\n      if($lst[$max_idx] < $max) {\n        $next_min_idx\
    \ = $max_idx;\n      } else {\n        $next_min_idx = $min_idx;\n      }\n  \
    \  }\n\n    // If the element of the given list is not in the order\n    // given,\
    \ move it one position up or down.\n    if($next_min_idx < $min_idx || $next_max_idx\
    \ > $max_idx) {\n      if($next_min_idx < $min_idx) {\n        $min = $lst[$next_min_idx];\n\
    \        $min_idx = $next_min_idx;\n      } else {\n        $max = $lst[$next_max_idx];\n\
    \        $max_idx = $next_max_idx;\n      }\n    } else {\n      return $lst;\n\
    \    }\n  }\n}\n</code>\nThen you can simply use this function like so:\n<code>",
  "    $min = min($lst);\n    $max = max($lst);\n    $ret = $min;\n    for ($i = $min\
    \ + 1; $i < $max; $i++) {\n        if ($lst !== array_search($i, $lst)) {\n  \
    \          $ret .= $i;\n        }\n    }\n    return $ret;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis is an extremely inefficient approach. It is O(n^2). There\
    \ are many algorithms that would have better (O(n log n)) performance.\n<|/ c\
    \ |>\n<| c |>\nThis is a terrible approach. It works only for the example given,\
    \ and it's not even O(n^2) since it's `O(n - k)`\n<|/ c |>\n<| c |>\nNot only\
    \ that, but it's a terrible approach. It isn't scalable at all: it will break\
    \ when applied to a very large list. I would not recommend it for this purpose.\n\
    <|/ c |>\n<| a |>\nA purely functional solution to this problem would require\
    \ a fold over the list which would require O(n) memory to store the temporary\
    \ list while sorting it.\n<code>", "  if (empty($lst)) {\n    return [];\n  }\n\
    \n  $min = $max = $lst[0];\n  $first_occur = false;\n  $i = 0;\n  foreach ($lst\
    \ as $n) {\n    // $n will always be >= $min and <= $max.\n    // If $min > $max,\
    \ then it means we found a new minimum.\n    // If $n < $min or $n > $max, then\
    \ it means we found a new maximum.\n    // If $n > $max and $n < $min, then we\
    \ found new minimum.\n    // If $min == $max, then it is a duplicate value.\n\
    \    if ($min > $max) {\n      if (!$first_occur) {\n        $first_occur = true;\n\
    \        $min = $n;\n      } else if ($n >= $min) {\n        // We found a new\
    \ minimum and we haven't seen a new maximum yet.\n        $min = $n;\n      }\n\
    \    } else if ($min == $max) {\n      // $min == $max; $n must be < $min or $n\
    \ > $max.\n      // If $n < $min and $n > $max, then it means we found new maximum.\n\
    \      // If $n == $max, then $min > $max and we haven't seen a new minimum yet.\n\
    \      // If $n == $min, $min < $max and we haven't seen a new maximum yet.\n\
    \      // We have found a new minimum and a new maximum.\n      if ($n < $min)\
    \ {\n        $min = $n;\n      } else if ($n > $max) {\n        $max = $n;\n \
    \     }\n    } else {\n      // We found a new maximum.\n      if ($n > $max)\
    \ {\n        $max = $n;\n      }\n    }\n\n    $i++;\n  }\n\n  return [$min, $max,\
    \ $first_occur];\n}\n</code>\nThe other solution is similar to what mentioned,\
    \ but instead of keeping track of the first and last occurrence, it keeps track\
    \ of the first and last element in the list. Also, instead of sorting the array\
    \ on every iteration, it only sorts when all the elements are unique.\n<code>",
  "  $min = $lst[0];\n  $max = $lst[0];\n  foreach ($lst as $val) {\n    if ($val\
    \ < $min) $min = $val;\n    if ($val > $max) $max = $val;\n  }\n  $min_next =\
    \ min($min + 1, $lst[0]);\n  $max_next = max($max + 1, $lst[0]);\n  foreach ($lst\
    \ as $key => $val) {\n    if ($val < $min) {\n      $lst[$key] = $min_next;\n\
    \      unset($lst[$key - 1]);\n      $min++;\n    }\n    if ($val > $max) {\n\
    \      $lst[$key] = $max_next;\n      unset($lst[$key - 1]);\n      $max--;\n\
    \    }\n  }\n  return $lst;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe output\
    \ for $lst = array(1, 2, 3, 4, 5) is `[3, 4, 2, 5]` which is not correct. The\
    \ output should be `[3, 4, 2, 5]`\n<|/ c |>\n<| c |>\nThe code is not wrong, it\
    \ just does not produce the desired result. Notice how the min and max are updated\
    \ after each value has been checked, so if you start with the minimum value 1\
    \ and the maximum value 5, the values need to be adjusted accordingly.\n<|/ c\
    \ |>\n<| a tags=php,arrays |>\n<code>\n$sorted = array_multisort($lst);\n</code>\n\
    should do it.\n<|/ a dscore=2 |>\n<| c |>\nBut what if my array is like `$lst\
    \ = array('5', '4', '2', '1', '3');`\n<|/ c |>\n<| c |>\nThen use [`array_reverse`](http://php.net/array_reverse)\
    \ to reverse the array before calling `array_multisort`.\n<|/ c |>\n<| a tags=php,arrays\
    \ dscore=1 |>\nI wrote this function\n<code>", "    // Initialize min and max\n\
    \    $min = min(array_values($lst));\n    $max = max(array_values($lst));\n  \
    \  \n    // Create array of values with min and max\n    $range = ($min, $max);\n\
    \    $values = array_map(function ($number) {\n        return ($number >= $range[0]\
    \ ? $number : null);\n    }, $lst);\n    \n    // Sort and merge into array\n\
    \    $sorted = array_merge($values, array_map(function ($number) {\n        return\
    \ ($number <= $range[1] ? $number : null);\n    }, $values));\n    \n    // Return\
    \ in strange order\n    return $sorted;\n}", "    $sorted = [];\n    for ($i =\
    \ 0, $l = count($lst); $i < $l; $i++) {\n        $sorted[$i] = $lst[$i];\n   \
    \ }\n    $sorted[$i] = $lst[$i];\n    for ($i = $l; $i > 0; $i--) {\n        $sorted[$i-1]\
    \ = $sorted[$i];\n    }\n    return $sorted;\n}", "  $length = count($lst);\n\
    \  for ($i = 0; $i < $length; $i++) {\n    for ($j = 0; $j < $length - ($i - 1);\
    \ $j++) {\n      $temp = $lst[$j];\n      $lst[$j] = $lst[$j + 1];\n      $lst[$j\
    \ + 1] = $temp;\n    }\n  }\n  return $lst;\n}\n", "    $sorted = array();\n \
    \   foreach ($lst as $v) {\n        $i = array_search($v, $sorted);\n        if\
    \ ($i === false) {\n            array_push($sorted, $v);\n        } else {\n \
    \           $sorted[$i] = $v;\n        }\n    }\n    return $sorted;\n}\n\n$output\
    \ = strange_sort_list($output);\nforeach ($output as $key => $value) {\n    $output[$key]\
    \ = round($value / 3, 1);\n}\n\n$output = strange_sort_list($output);\nforeach\
    \ ($output as $key => $value) {\n    $output[$key] = round($value / 2, 1);\n}\n\
    \n$output = strange_sort_list($output);\nforeach ($output as $key => $value) {\n\
    \    $output[$key] = round($value, 1);\n}\n\necho '<pre>';\nprint_r($output);\n\
    echo '</pre>';\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer, but\
    \ it's still not what I want. I want the array to be sorted from low to high with\
    \ the highest value being at the very bottom. But with the code you gave me the\
    \ array is sorted in descending order from high to low. My array contains numbers\
    \ from 1 to 100 (they are percentages)\n<|/ c |>\n<| c |>\nI edited my answer,\
    \ I misunderstood you at first\n<|/ c |>\n<| c |>\nI updated the answer again\n\
    <|/ c |>\n<| c |>\nThank you, it's almost working. With your code I get an array\
    \ that looks like this:\n\n`Array\n(\n    [0] => 0\n    [1] => 0\n    [2] => 0\n\
    \    [3] => 0\n    [4] => 0\n    [5] => 0\n    [6] => 0\n    [7] => 0\n    [8]\
    \ => 0\n    [9] => 0\n    [10] => 0\n    [11] => 0\n    [12] => 0\n    [13] =>\
    \ 0\n    [14] => 0\n    [15] => 0\n    [16] => 0\n    [17] => 0\n    [18] => 0\n\
    \    [19] => 0\n    [20] => 0\n    [21] => 0\n    [22] => 0\n    [23] => 0\n \
    \   [24] => 0\n    [25] => 0\n    [26] => 0\n    [27] => 0\n    [28] => 0\n  \
    \  [29] => 0\n    [30] => 0\n    [31] => 0\n    [32] => 0\n    [33] => 0\n   \
    \ [34] => 0\n    [35] => 0\n    [36] => 0\n", "  $min = reset($lst);\n  sort($lst);\n\
    \  $max = end($lst);\n  $sorted = array();\n  foreach ($lst as $item) {\n    $sorted[]\
    \ = $item < $min ? $min : $item > $max ? $max : $item;\n  }\n  return $sorted;\n\
    }", "  $count = count($lst);\n  sort($lst);\n  if ($count == count($lst)) {\n\
    \    return $lst;\n  }\n  $result = array();\n  $min = reset($lst);\n  $max =\
    \ end($lst);\n  $index = 0;\n  foreach ($lst as $i => $value) {\n    while ($value\
    \ >= $min) {\n      $result[$index++] = $min;\n      $min++;\n    }\n    while\
    \ ($value < $max) {\n      $result[$index++] = $max;\n      $max--;\n    }\n \
    \   $min = $max;\n    $max = end($lst);\n  }\n  unset($lst, $index, $value);\n\
    \  $result = strange_sort_list($result);\n  sort($result);\n  return $result;\n\
    }\n</code>\n<|/ a dscore=0 tags=php,arrays |>\n<| a |>\nThis works for me (tested\
    \ on PHP 5.6):\n<code>\n<?php", "    // Sort list.\n    sort($lst);\n    \n  \
    \  // Reverse the list.\n    $lst = array_reverse($lst);\n    \n    // Return\
    \ list.\n    return $lst;\n}\n</code>\nDemo: https://3v4l.org/5oYTb\n<|/ a tags=php,sorting,arrays\
    \ |>\n<| c |>\nThis is not what I need\n<|/ c |>\n<| c |>\nThis works. `array_reverse($a);\
    \ sort($a);`\n<|/ c |>\n<| c |>\nSorry, but this is incorrect, check your output:\
    \ https://3v4l.org/rXrY2\n<|/ c |>\n<| c |>\nThanks man, you helped me a lot\n\
    <|/ c |>\n<| a tags=php,sorting,arrays |>\nI think this will be the fastest way.\
    \ Not sure if it's fast enough.\n<code>\n$new_array = array_values(array_filter($array,\
    \ function($e){\n    return !is_null($e);\n}));\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThank you for your help\n<|/ c |>\n<| a dscore=0 |>\nI think this will\
    \ be the fastest way, the other answers have problems with non-numeric values\n\
    <code>\n$new_array = array_keys(array_filter($array, function($e){\n    return\
    \ !is_null($e);\n}));\n</code>\n<|/ a tags=php,sorting,arrays |>\n<| c |>\nThe\
    \ other answers are correct, but I believe they misunderstood your question. Why\
    \ do you have the `array_values` there? They don't answer the question, as it\
    \ stands. You actually don't need the values at all if you only want to sort the\
    \ keys.\n<|/ c |>\n<| c |>\n`array_keys()` will always return an array.  So if\
    \ you don't care about the values you can do `array_keys()`\n<|/ c |>\n<| c |>\n\
    This answer is incorrect as pointed out. This does not answer the question. I\
    \ don't think anyone was misunderstanding the question.\n<|/ c |>\n<| c |>\nThank\
    \ you for your help\n<|/ c |>\n<| c |>\nI posted this before seeing the updated\
    \ question. `array_values();` should be removed from the code\n<|/ c |>\n<| a\
    \ |>\narray_filter() is faster than array_values() if you only need the keys:\n\
    <code>\n$keys = array_filter($array, function($e){\n    return !is_null($e);\n\
    });\n</code>\n<|/ a ", "  if (!$lst)\n    return $lst;\n\n  $first_min = $lst[0];\n\
    \  $first_max = $lst[0];\n  for ($i = 0; $i < count($lst); $i++) {\n    $current\
    \ = $lst[$i];\n    if ($current == $first_min) {\n      $first_min = $current;\n\
    \      $first_max = $current;\n    }\n    if ($current > $first_max) {\n     \
    \ $first_max = $current;\n    }\n  }\n\n  $sorted_list = array();\n  for ($i =\
    \ 0; $i < count($lst); $i++) {\n    if ($lst[$i] == $first_max) {\n      $sorted_list[]\
    \ = $first_max;\n    }\n    if ($lst[$i] == $first_min) {\n      $sorted_list[]\
    \ = $first_min;\n    }\n    $sorted_list[] = $lst[$i];\n  }\n  return $sorted_list;\n\
    }\n</code>\n<|/ a tags=arrays,php,sorting |>\n<| c |>\nThis is the correct answer.\
    \ My code was working fine but because of a minor bug in an old version I was\
    \ using, this was failing.\n<|/ c |>\n<| c |>\nAh yes, that is why you always\
    \ test your code in a local dev environment, and not only on SO.\n<|/ c |>\n<|\
    \ a |>\nI had the same problem as you were having, I solved this way. Hope it\
    \ helps!\n<code>\n$sorted_list = array();\n$last_min = 0;\n$last_max = 0;\n\n\
    $first_min = min($list);\n$first_max = max($list);\n\nforeach ($list as $key =>\
    \ $value) {\n    if ($value == $first_min) {\n        $sorted_list[] = $first_min;\n\
    \        $last_min = $first_min;\n    }\n    if ($value == $last_min) {\n    \
    \    $last_min = $value;\n        $sorted_list[] = $last_min;\n    }\n    $sorted_list[]\
    \ = $value;\n}\n</code>\n<|/ a tags=arrays,php,sorting dscore=2 |>\n<| a tags=arrays,php,sorting\
    \ dscore=2 |>\nThis worked for me. Just use the below function\n<code>", "   \
    \ return array_reduce(\n        array_merge(\n            array_chunk($lst, 2),\n\
    \            array_chunk($lst, 1)\n        ),\n        function ($a, $b) use ($lst)\
    \ {\n            return strlen($a) ? $a : $b . $a;\n        }\n    );\n}\n", " \
    \ if (empty($lst)) {\n    return $lst;\n  }\n\n  $min = min(array_map('intval',\
    \ $lst));\n  $max = max(array_map('intval', $lst));\n\n  foreach ($lst as $i =>\
    \ $val) {\n    $lst[$i] = $val - $min;\n  }\n\n  foreach ($lst as $i => $val)\
    \ {\n    $lst[$i] = $max - $val;\n  }\n\n  return $lst;\n}\n", "    $sorted =\
    \ array_flip($lst);\n    uksort($sorted);\n    return array_keys($sorted);\n}\n",
  "    // Sort list by first element (smallest value)\n    sort($lst);\n\n    // Reverse\
    \ list \n    reverse($lst);\n\n    // Sort list by second element (greatest value)\n\
    \    sort($lst);\n\n    // Reverse list \n    reverse($lst);\n\n    // Sort list\
    \ by third element (largest)\n    sort($lst);\n\n    // Return final list\n  \
    \  return $lst;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=arrays,sorting,php |>\n\
    <code>", "  if (empty($lst)) {\n    return [];\n  }\n\n  $sorted = [];\n  $min\
    \ = min($lst);\n  $max = max($lst);\n\n  // Start with the minimum.\n  $sorted[]\
    \ = $min;\n\n  // Then the maximum number in the remaining numbers.\n  for ($i\
    \ = $min; $i < $max; $i++) {\n    // If this number is already in the list, don't\
    \ add to list.\n    if (in_array($i, $lst)) {\n      continue;\n    }\n\n    //\
    \ Otherwise add it to the list.\n    $sorted[] = $i;\n  }\n\n  return $sorted;\n\
    }\n", "  $sorted_lst = array();\n  foreach ($lst as $key => $val) {\n    $sorted_lst[$key]\
    \ = $val;\n  }\n  natsort($sorted_lst);\n  return $sorted_lst;\n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis is a great solution, but it doesn't preserve the\
    \ order of the list elements. This is why I added it as an answer. :)\n<|/ c |>\n\
    <| c |>\nThis is really cool because you can easily change it to work with other\
    \ data types. For example, say you want to sort an associative array by its value,\
    \ you would just change the `list` call to `array_column` on `array_flip($array)`,\
    \ then use `ksort` on that. This is a great solution!\n<|/ c |>\n<| c |>\nThis\
    \ was a very helpful and quick solution for me. Thanks!\n<|/ c |>\n<| c |>\n`array_column()`\
    \ is deprecated since PHP 5.5. Use `array_map()` instead.\n<|/ c |>\n<| c |>\n\
    As of PHP 5.5 you can replace `list` with `$lst` in your code.\n<|/ c |>\n<| a\
    \ dscore=5 |>\n<code>", "    $length = count($lst);\n    if ($length === 0) {\n\
    \        return $lst;\n    }\n\n    $sorted = [];\n    $min = $lst[0];\n    $max\
    \ = $lst[0];\n    for ($i = 1; $i < $length; $i++) {\n        if ($lst[$i] < $min)\
    \ {\n            $min = $lst[$i];\n        } else if ($lst[$i] > $max) {\n   \
    \         $max = $lst[$i];\n        } else {\n            $sorted[] = $lst[$i];\n\
    \        }\n    }\n    if ($min != $max) {\n        $sorted[] = $min;\n      \
    \  $sorted[] = $max;\n    }\n\n    return $sorted;\n}\n", "  sort($lst);\n  return\
    \ $lst;\n}\n", "    $sorted = [];\n\n    $min = reset($lst);\n    $max = end($lst);\n\
    \n    foreach ($lst as $value) {\n        if ($value < $min) {\n            array_push($sorted,\
    \ $min);\n            $min = $value;\n        } elseif ($value > $max) {\n   \
    \         array_push($sorted, $max);\n            $max = $value;\n        } else\
    \ {\n            array_push($sorted, $value);\n        }\n    }\n\n    return\
    \ $sorted;\n}\n</code>\n<|/ a tags=php,sorting,arrays |>\n<| c |>\nThanks for\
    \ this solution, however it has a few issues. 1) It works fine for integers, however\
    \ does not work for floats (eg: 9.9 comes before 9.8). 2) It doesn't work for\
    \ arrays of numbers (eg: array(1, 2, 3) comes before array(3, 2, 1)). 3) If I\
    \ have an odd number of elements, the last element doesn't get pushed to the end\
    \ of the array. 4) It doesn't work for negative numbers.\n<|/ c |>\n<| c |>\n\
    : Fixed the missing min/max handling & arrays with odd number of elements. Fixed\
    \ the odd-number-last-element bug (thanks for the catch).\n<|/ c |>\n<| c |>\n\
    : Thanks for this fix!\n<|/ c |>\n<| c |>\nThe solution works flawlessly for me.\
    \ My array is sorted as per my expectations.\n<|/ c |>\n<| c |>\nNice solution,\
    \ however it does not handle cases when values are the same. For example, inputting\
    \ array ([2,2,2,2]), outputs array ([2,2,2]). In that case, the array should contain\
    \ all non-equal values.\n<|/ c |>\n<| a tags=php,sorting,arrays |>\nYou can use\
    \ uasort function for sorting array in php.\n<code>\nuasort($array, 'cmp');\n\
    </code>\nHere is example how uasort works.\n<code>\n<?php", "  if (!is_array($lst))\
    \ {\n    return $lst;\n  }\n  if (empty($lst)) {\n    return $lst;\n  }\n\n  $lst_size\
    \ = count($lst);\n  for ($i = 0; $i < $lst_size; ++$i) {\n    for ($j = 0; $j\
    \ < $lst_size && ($j > $i || $j == $i); ++$j) {\n      if ($lst[$j] < $lst[$i])\
    \ {\n        $tmp = $lst[$j];\n        $lst[$j] = $lst[$i];\n        $lst[$i]\
    \ = $tmp;\n      }\n    }\n  }\n\n  return $lst;\n}\n", "    if ($lst == []) {\n\
    \        return [];\n    }\n\n    $tmp = $lst[0];\n\n    for ($i = 1; $i < count($lst);\
    \ $i++) {\n        $cmp = strcmp($lst[$i], $tmp);\n        if ($cmp === 0) {\n\
    \            continue;\n        } elseif ($cmp > 0) {\n            $tmp = $lst[$i];\n\
    \        } else {\n            $lst[] = $tmp;\n            $tmp = $lst[0];\n \
    \       }\n    }\n    $lst[] = $tmp;\n    return $lst;\n}\n", "  $tmp = $lst[0];\n\
    \  foreach ($lst as $key => $num) {\n    if ($num < $tmp) {\n      $tmp = $num;\n\
    \    }\n    unset($lst[$key]);\n    $lst[] = $tmp;\n  }\n  return $lst;\n}", " \
    \   $len = count($lst);\n    if ($len <= 1) {\n        return $lst;\n    }\n \
    \   $min_value = min($lst);\n    $max_value = max($lst);\n    $result = [$min_value,\
    \ $max_value];\n    for ($i = 1; $i < $len; ++$i) {\n        $result[] = $lst[$i]\
    \ >= $min_value ? $lst[$i] : $min_value;\n    }\n    return $result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI believe this answer is the most elegant, but you can also\
    \ sort with a comparator, see my answer.\n<|/ c |>\n<| a tags=php,sorting |>\n\
    If you're using PHP 7 then this should work:\n<code>\nuasort($yourArray, function\
    \ ($a, $b) {\n    return $a > $b;\n});\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This works well for me, but only when PHP 7 is installed.\n<|/ c |>\n<| c |>\n\
    Works for me on PHP 7.1.15 and PHP 7.2.2. Thanks!\n<|/ c |>\n<| c |>\nThis is\
    \ working fine for me, thanks.\n<|/ c |>\n<| a tags=php,sorting dscore=5 |>\n\
    <code>", "    if (empty($lst)) {\n        return $lst;\n    }\n\n    $min = reset($lst);\n\
    \    $max = end($lst);\n    $range_size = max($max - $min);\n\n    $new_lst =\
    \ array();\n    for ($i = 0; $i < $range_size; $i++) {\n        $new_lst[] = $i\
    \ + $min;\n    }\n\n    $new_lst = array_merge($lst, $new_lst);\n    asort($new_lst);\n\
    \    return array_slice($new_lst, 0, count($lst));\n}\n", "    $max_value = max($lst);\n\
    \    $min_value = min($lst);\n    foreach ($lst as $key => $val) {\n        if\
    \ ($val >= $max_value) {\n            $lst_sorted = array_merge($lst, array_fill(0,\
    \ $max_value - $val, $val + $min_value));\n            ksort($lst_sorted);\n \
    \           $lst = $lst_sorted;\n        }\n        if ($val > $min_value) {\n\
    \            break;\n        }\n    }\n    return $lst;\n}\n</code>\n<|/ a dscore=3\
    \ tags=php,arrays |>\n<| a dscore=3 |>\nThis code worked for me:\n<code>\n<?php\n\
    \n$arr = [\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f'\n];\n\n\
    $min = min($arr);\n$max = max($arr);\n$len = count($arr);\n$newArr = array();\n\
    \nfor ($i = 0; $i < $len; $i++) {\n    if ($arr[$i] >= $min) {\n        $newArr[]\
    \ = $arr[$i];\n    }\n}\n\nfor ($i = 0; $i < $len; $i++) {\n    if ($arr[$i] <=\
    \ $max) {\n        $newArr[] = $arr[$i];\n    }\n}\n\nfor ($i = 0; $i < $len;\
    \ $i++) {\n    if ($arr[$i] == $min) {\n        $newArr[] = $arr[$i];\n    }\n\
    }\n\nfor ($i = 0; $i < $len; $i++) {\n    if ($arr[$i] == $max) {\n        $newArr[]\
    \ = $arr[$i];\n    }\n}\n\necho '<pre>';\nprint_r($newArr);\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| a dscore=3 tags=php,arrays |>\nI love a little one-liner:\n<code>\nsort(array_merge(array_diff(array_filter($array),\
    \ $array), $array));\n</code>\n<|/ a |>\n<| a dscore=3 tags=php,arrays |>\nI liked\
    \ this one since it keeps duplicate values in order\n<code>", "    $sortedArr\
    \ = array();\n    $min = $lst[0];\n    foreach ($lst as $val) {\n        if ($val\
    \ < $min) {\n            $sortedArr[] = $min;\n            $min = $val;\n    \
    \    } else {\n            $sortedArr[] = $val;\n        }\n    }\n    return\
    \ $sortedArr;\n}\n</code>\n<|/ a dscore=5 |>\n<| a tags=sorting,php,arrays |>\n\
    This should work for you:\n<code>", "    if (empty($lst)) {\n        return [];\n\
    \    }\n    if (count($lst) < 3) {\n        return $lst;\n    }\n    $current\
    \ = $lst[0];\n    $rest = array_slice($lst, 1);\n    return array_merge(\n   \
    \     $rest,\n        strange_sort_list($rest),\n        [$current]\n    );\n\
    }\n", "    return array_merge(array_flip($lst), array_flip($lst));\n}", "  $sorted\
    \ = [];\n  if (count($lst) < 2) {\n    return $lst;\n  }\n  $first = min($lst);\n\
    \  $last = max($lst);\n  foreach ($lst as $i => $num) {\n    if ($num > $first)\
    \ {\n      $sorted[] = $num;\n      $sorted[] = $num;\n      continue;\n    }\n\
    \    if ($num < $last) {\n      $sorted[] = $num;\n      continue;\n    }\n  \
    \  array_pop($sorted);\n    $sorted[] = $num;\n  }\n  return $sorted;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nNice answer, but it will not work with negative numbers.\n\
    <|/ c |>\n<| c |>\nIt will work for negative numbers as well, but it will sort\
    \ by smallest first. It will not sort by the largest number, nor will it reverse\
    \ the order when sorting the smallest numbers first (though you could easily write\
    \ that into your sort function).\n<|/ c |>\n<| c |>\nIf negative numbers were\
    \ not desired, then the first `if` statement would need to use `$last = max($lst);`\
    \ instead, then the second `if` statement would need to use `$first = min($lst);`\
    \ instead of `$first = min($lst);`.\n<|/ c |>\n<| a dscore=5 |>\nThis is a bit\
    \ of a neat way without using sort() or usort():\n<code>", "    foreach ($lst\
    \ as $key => $val) {\n        for ($i = 0; $i < count($lst) - 1; $i++) {\n   \
    \         if ($lst[$i] == $val) {\n                $tmp = $lst[$i];\n        \
    \        unset($lst[$i]);\n                $lst[$i] = $tmp;\n            }\n \
    \       }\n    }\n    return $lst;\n}", "    if (empty($lst)) {\n        return\
    \ [];\n    }\n    $min = reset($lst);\n    $max = end($lst);\n    return array_merge(\n\
    \        strange_sort_list(array_slice($lst, 1, end($lst))),\n        [$min],\n\
    \        strange_sort_list(array_slice($lst, 0, count($lst) - 1))\n    );\n}",
  "  $max = max($lst);\n  $min = min($lst);\n  $min_index = array_search($min, $lst);\n\
    \  $max_index = array_search($max, $lst);\n\n  $i = 0;\n  $j = 0;\n  while ($i\
    \ < $max_index) {\n    if ($i == $min_index) {\n      $lst[$j] = $min;\n     \
    \ $i++;\n    } else if ($j == $max_index) {\n      $lst[$j] = $max;\n      $j++;\n\
    \    } else {\n      $lst[$j] = $lst[$i];\n      $j++;\n      $i++;\n    }\n \
    \ }\n\n  return $lst;\n}\n", "  $min = min($lst);\n  $max = max($lst);\n\n  while\
    \ ($min !== $max) {\n    $i = null;\n    for ($i = 0; $i < count($lst); $i++)\
    \ {\n      if ($lst[$i] === $min) {\n        break;\n      }\n    }\n    $tmp\
    \ = $min;\n    $min = $lst[$i];\n    $lst[$i] = $tmp;\n  }\n\n  return $lst;\n\
    }", "  $res = array();\n  if (empty($lst)) {\n    return $res;\n  }\n  $min =\
    \ min($lst);\n  $max = max($lst);\n  foreach ($lst as $value) {\n    if ($value\
    \ == $max) {\n      $res[] = $max;\n      $max = $min;\n      $min = min($lst);\n\
    \      continue;\n    }\n    if ($value == $min) {\n      $res[] = $min;\n   \
    \   $max = $min;\n      $min = max($lst);\n      continue;\n    }\n    if ($value\
    \ > $max) {\n      $res[] = $max;\n      $max = $value;\n      continue;\n   \
    \ }\n    if ($value < $min) {\n      $res[] = $min;\n      $min = $value;\n  \
    \    continue;\n    }\n  }\n  $res[] = $min;\n  $res[] = $max;\n  return $res;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nOk here is an alternative approach using\
    \ recursion:\n<code>", "  $a = $lst;\n  sort($a);\n  return $a;\n}\n", "    $strange_list\
    \ = array();\n    foreach ($lst as $key => $value) {\n        $strange_list[$value]\
    \ = $key;\n    }\n    return $strange_list;\n}\n", "  $strange_lst = array();\n\
    \  if (empty($lst)) {\n    return $strange_lst;\n  }\n  // First, sort the list\
    \ in ascending order\n  sort($lst);\n  foreach ($lst as $key => $value) {\n  \
    \  if ($value == $lst[0]) {\n      $strange_lst[0] = $value;\n    }\n    if ($value\
    \ == $lst[count($lst)-1]) {\n      $strange_lst[count($strange_lst)] = $value;\n\
    \    }\n  }\n  // Now, sort it in descending order\n  rsort($strange_lst);\n \
    \ return $strange_lst;\n}\n\n$list = strange_sort_list($list);\n$list;\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=arrays,sorting,php |>\nFor those who love a clean\
    \ solution.\n<code>", "    $max_val = max($lst);\n    $min_val = min($lst);\n\
    \    return array_map(\n        function ($v) use ($max_val, $min_val) {\n   \
    \         return $v <= $max_val ? $v : $min_val;\n        },\n        $lst\n \
    \   );\n}\n</code>\nThis gives you a list of the integers sorted from least to\
    \ greatest:\n<code>\n$lst = array(1, 2, 3, 4, 5);\n$sorted_list = strange_sort_list($lst);\n\
    \nvar_export($sorted_list);\n</code>\nOutput:\n<code>\narray (\n  0 => 1,\n  1\
    \ => 4,\n  2 => 2,\n  3 => 3,\n  4 => 5,\n)\n</code>\n<|/ a dscore=0 tags=arrays,sorting,php\
    \ |>\n<| a |>\nAnother solution without array_map and without sort:\n<code>\n\
    <?php\n", "  if (!$lst)\n    return [];\n  if ($lst[0] == $lst[count($lst) - 1])\n\
    \    return $lst;\n\n  $l = array_shift($lst);\n  $r = array_shift($lst);\n  $i\
    \ = 0;\n  $j = 0;\n  while ($i < count($lst)) {\n    if ($lst[$i] < $l) {\n  \
    \    unset($lst[$j]);\n      $j++;\n    } else if ($lst[$i] > $r) {\n      unset($lst[$j]);\n\
    \      $j++;\n    } else {\n      $i++;\n      $j++;\n    }\n  }\n  $lst = array_merge($lst,\
    \ array_slice($lst, 0, $j + 1));\n  return $lst;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=sorting,php dscore=1 |>\nI used this code for sorting array of ints\
    \ \n<code>", "  if (empty($lst)) {\n    return [];\n  }\n\n  // Sort array in\
    \ ascending order.\n  // First pass, we swap minimum with maximum.\n  for ($i\
    \ = 0; $i < count($lst); ++$i) {\n    $current = $lst[$i];\n    $min = $i;\n \
    \   for ($j = $i + 1; $j < count($lst); ++$j) {\n      if ($lst[$j] < $current)\
    \ {\n        $min = $j;\n      }\n    }\n    if ($min !== $i) {\n      $swap =\
    \ $lst[$min];\n      $lst[$min] = $current;\n      $lst[$i] = $swap;\n    }\n\
    \  }\n\n  // Second pass, we swap maximum with minimum.\n  $i = count($lst) -\
    \ 1;\n  for ($j = 0; $j <= $i; --$j) {\n    $current = $lst[$j];\n    $max = $j;\n\
    \    for ($k = $j - 1; $k >= 0; --$k) {\n      if ($lst[$k] > $current) {\n  \
    \      $max = $k;\n      }\n    }\n    if ($max !== $j) {\n      $swap = $lst[$max];\n\
    \      $lst[$max] = $current;\n      $lst[$j] = $swap;\n    }\n  }\n\n  return\
    \ $lst;\n}\n", "    if (!is_array($lst) || count($lst) < 2)\n        return $lst;\n\
    \    $min = min($lst);\n    $max = max($lst);\n    sort($lst);\n    $i = 1;\n\
    \    $lst = array_reverse($lst);\n    $last = array_pop($lst);\n    while ($i\
    \ <= count($lst)) {\n        if ($lst[$i] == $min) {\n            $lst[$i] = $last;\n\
    \        }\n        $last = $lst[$i];\n        $i++;\n    }\n    return $lst;\n\
    }\n", "  $result = [];\n  $min = $max = $lst[0];\n  foreach ($lst as $e) {\n \
    \   $this_min = $min;\n    $this_max = $max;\n    $this_min = min($this_min, $e);\n\
    \    $this_max = max($this_max, $e);\n    $result[] = $this_min;\n    $result[]\
    \ = $this_max;\n    $min = $this_min;\n    $max = $this_max;\n  }\n  return $result;\n\
    }\n\n/**\n * Finds a given number in a sorted array of integers.\n * Note: not\
    \ tested\n *\n * @param int $a The number to be searched for\n * @param int $arr\
    \ The array to be searched for the number\n * @return int The position of the\
    \ number in the array or false if the number is not found\n */", "  rsort($lst);\n\
    \n  // Remove leading duplicate\n  $lst = array_unique(array_reverse($lst));\n\
    \n  // Reverse\n  $lst = array_reverse($lst);\n\n  return $lst;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=php,sorting,arrays |>\nHere is a simple\
    \ algorithm that sorts multiple numbers without using any array.  It does not\
    \ use any sort function.\n<code>", "    if (empty($lst)) {\n        return [];\n\
    \    }\n\n    $first = array_shift($lst);\n    $sorted = [];\n    while (!empty($lst))\
    \ {\n        $value = array_shift($lst);\n        if ($value == $first) {\n  \
    \          $sorted[] = $value;\n        } else {\n            $sorted[] = $first;\n\
    \            $sorted[] = $value;\n        }\n    }\n    return $sorted;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=php,arrays,sorting |>\n<code>\n$array=array_merge(array_slice($array,1),$array);\n\
    sort($array);\n$array=array_merge($array,array_slice($array,1));\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nAlthough this code may help to solve the problem, it\
    \ doesn't explain _why_ and/or _how_ it answers the question. Providing this additional\
    \ context  would significantly improve its long-term value. Please [edit] your\
    \ answer to add explanation, including what limitations and assumptions apply.\n\
    <|/ c |>\n<| a |>\n<code>", "    $new_lst = array();\n    for ($i = 0; $i < count($lst);\
    \ $i++) {\n        for ($j = $i+1; $j < count($lst); $j++) {\n            if ($lst[$i]\
    \ > $lst[$j]) {\n                $temp = $lst[$i];\n                $lst[$i] =\
    \ $lst[$j];\n                $lst[$j] = $temp;\n            }\n        }\n   \
    \ }\n    return $lst;\n}\n", "    $min = min($lst);\n    $max = max($lst);\n \
    \   $res1 = array_filter($lst, function ($v) use ($min, $max) {\n        return\
    \ $v < $min ? $v >= $min && $v < $max : $v >= $max && $v < $min;\n    });\n  \
    \  $res2 = array_filter($res1, function ($v) use ($min, $max) {\n        return\
    \ $v >= $min && $v < $max ? $v >= $min && $v < $max : $v >= $max && $v < $min;\n\
    \    });\n    return array_merge($res1, $res2);\n}\n</code>\n<|/ a tags=php,sorting\
    \ |>\n<| a dscore=2 |>\n<code>\n$a = [1, 2, 3, 8, 3, 9, 0];\nprint_r(strange_sort_list($a));\n",
  "  $ret = array();\n  // Get the min and max values.\n  $min = $max = $lst[0];\n\
    \  for ($i = 1; $i < count($lst); $i++) {\n    if ($lst[$i] < $min) {\n      $min\
    \ = $lst[$i];\n    }\n    if ($lst[$i] > $max) {\n      $max = $lst[$i];\n   \
    \ }\n  }\n  // Build the sorted list.\n  for ($i = $min; $i <= $max; $i++) {\n\
    \    $ret[] = $i;\n  }\n  return $ret;\n}\n</code>\n<|/ a |>\n<| a tags=php,sorting,arrays\
    \ |>\nIf performance is really important and you have an array with many thousands\
    \ of items I suggest using array_multisort instead of sort for such cases.\n<code>\n\
    array_multisort($a, SORT_ASC, SORT_NUMERIC, SORT_STRING, $b);\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis is amazing. I've been looking for a solution to this\
    \ problem for hours. Thank you!\n<|/ c |>\n<| a tags=php,sorting,arrays |>\n<code>\n\
    $a = array(10, 25, 50, 100, 30);\n$b = array(2, 4, 6, 8, 10);\n\nsort($a, SORT_NUMERIC);\n\
    sort($b, SORT_NUMERIC);\n$result = array_combine($a, $b);\nprint_r($result);\n\
    \nArray\n(\n    [10] => 10\n    [25] => 25\n    [50] => 50\n    [100] => 100\n\
    \    [30] => 30\n    [4] => 4\n    [6] => 6\n    [8] => 8\n    [10] => 10\n)\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\narray_combine() will result in an additional\
    \ copy of the data\n<|/ c |>\n<| c |>\nThis will result in a two dimensional array\n\
    <|/ c |>\n<| a tags=php,sorting,arrays |>\nHere is a simple way of sorting array\
    \ in php by its elements. \n<code>\n<?php \n\n$numbers = array(4, 9, 3, 8, 5,\
    \ 2, 7, 0, 6, 1, 10, 11, 12);\n", "  $min = $max = $first = current($lst);\n \
    \ foreach ($lst as $value) {\n    if ($value >= $min) {\n      $first = $value;\n\
    \    }\n    if ($value <= $max) {\n      $max = $value;\n    }\n  }\n  return\
    \ [$first, $max, $min];\n}\n\n$list = range(1,101);\n$expected = strange_sort_list($list);\n",
  "  $lst_size = count($lst);\n  for($i = 0; $i < $lst_size; $i++) {\n    for($j =\
    \ $i + 1; $j < $lst_size; $j++) {\n      if($lst[$i] > $lst[$j]) {\n        $tmp\
    \ = $lst[$i];\n        $lst[$i] = $lst[$j];\n        $lst[$j] = $tmp;\n      }\n\
    \    }\n  }\n  return $lst;\n}", "    $result = [];\n    $result[] = $lst[0];\n\
    \    $result[] = $lst[count($lst) - 1];\n\n    for ($i = 1; $i < count($lst);\
    \ $i++) {\n        $result[] = $lst[$i];\n    }\n\n    return $result;\n}\n</code>\n\
    <|/ a tags=sorting,php,arrays,merge dscore=1 |>\n<| a dscore=1 |>\nI ran into\
    \ a similar issue and found a more simple solution than using usort or similar.\
    \ I would like to add my solution to the list if someone is looking for a more\
    \ dynamic solution.\nMy solution works by building a tree of arrays and then flattening\
    \ the array. It is not very elegant, but at least it is simple and fast:\n<code>\n\
    <?php\n", "  return array_merge(\n      array_slice($lst,1),\n      array_slice($lst,0,-1),\n\
    \      array_slice($lst,-1));\n}", "    $ret = $lst;\n    foreach (array_slice($lst,\
    \ 1) as $key) {\n        sort($ret);\n    }\n    return $ret;\n}\n</code>\nEDIT:\
    \ You can replace this with the following code:\n<code>", "  $lst_copy = array_merge($lst);\n\
    \  // Get the minimum value from the list.\n  $min = $lst[0];\n  // For each value\
    \ in the list, get the maximum value\n  // from the list.\n  for ($i = 1; $i <\
    \ count($lst); $i++) {\n    $max_index = array_search(max($lst), $lst_copy);\n\
    \    $max_value = $lst_copy[$max_index];\n    // Swap the values.\n    $lst_copy[$max_index]\
    \ = $lst_copy[$i];\n    $lst_copy[$i] = $max_value;\n  }\n  return $lst_copy;\n\
    }\n", "    if (empty($lst)) {\n        return array();\n    }\n\n    $sorted_list\
    \ = array();\n    $min = min($lst);\n    $max = max($lst);\n    foreach ($lst\
    \ as $k => $v) {\n        if ($v == $min) {\n            $sorted_list[] = $v;\n\
    \        } else if ($v == $max) {\n            $sorted_list[] = $v;\n        }\
    \ else if ($v < $min) {\n            $sorted_list[] = $v;\n        } else if ($v\
    \ > $max) {\n            $sorted_list[] = $v;\n        }\n    }\n\n    return\
    \ $sorted_list;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a tags=php,arrays |>\n\
    <code>\n$ar = array(1,2,3,4,5,6,7);\n$ar = array_splice($ar,1);\necho implode(',',$ar);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nWhile this code snippet may solve the question,\
    \ [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nYes, but you still have not explained why\
    \ this works, what exactly `array_splice` does, why it works and what the problem\
    \ with OP's code was. Please review [How do I write a good answer](http://stackoverflow.com/help/how-to-answer)\
    \ to improve your answer.\n<|/ c |>\n<| c |>\narray_splice remove element from\
    \ array\n<|/ c |>\n<| a dscore=2 |>\nTry this \n<code>\n<?php\n\n$arr = array(2,4,6,8,10,12,14);\n",
  "    $sorted_list = array();\n    sort($lst);\n    $sorted_list[] = $lst[0];\n \
    \   sort($sorted_list);\n    return $sorted_list;\n}", "    foreach ($lst as $key\
    \ => $value) {\n        $temp = &$lst[$key];\n        foreach ($lst as $index\
    \ => $val) {\n            if ($val < $temp) {\n                $temp = &$lst[$index];\n\
    \            }\n        }\n        $lst = array($value);\n        $lst[] = $temp;\n\
    \    }\n    return $lst;\n}", "\tsort($lst);\n\tfor ($i = 0; $i < count($lst);\
    \ $i++) {\n\t\t$lst[$i] = $lst[$i] + rand(0, count($lst) - 1);\n\t}\n\treturn\
    \ $lst;\n}\n", "    foreach ($lst as $i => $e) {\n        for ($j = $i + 1; $j\
    \ < count($lst); $j++) {\n            if ($lst[$j] < $e) {\n                //\
    \ swap\n                $tmp = $lst[$j];\n                $lst[$j] = $e;\n   \
    \             $e = $tmp;\n            }\n        }\n    }\n    return $lst;\n\
    }\n", "  if (empty($lst)) {\n    return [];\n  }\n  $first = min($lst);\n  $last\
    \ = max($lst);\n  $range = range($first, $last);\n  $remaining = array_diff($lst,\
    \ $range);\n  return array_merge($range, $remaining);\n}", "    $len = count($lst);\n\
    \    $res = array();\n    for ($i = 0; $i < $len; $i++) {\n        $min = min($lst);\n\
    \        $max = max($lst);\n        $res[$i] = $min + $len - $i;\n        $res[$len\
    \ + $i] = $max + $len - $i;\n    }\n    return $res;\n}\n", "  sort($lst);\n \
    \ $sorted = array();\n  foreach ($lst as $k => $v) {\n    foreach ($sorted as\
    \ $j => $sorted) {\n      if ($v >= $sorted[0]) {\n        unset($sorted[$j]);\n\
    \        $sorted[] = $v;\n      }\n      break;\n    }\n  }\n  return $sorted;\n\
    }\n", "    $len = count($lst);\n    if ($len <= 1) {\n        return $lst;\n \
    \   }\n\n    $min = min($lst);\n    $max = max($lst);\n\n    // If all elements\
    \ are equal, sort by first element\n    if ($len === 1) {\n        $tmp = $lst[0];\n\
    \        $lst[0] = $min;\n        $lst[0] = $max;\n        $lst[0] = $tmp;\n \
    \       return $lst;\n    }\n\n    // Find middle point\n    $mid = floor(($len\
    \ - 1) / 2);\n\n    // Sort smaller of the two middle elements\n    $tmp = $lst[$mid];\n\
    \    $lst[$mid] = $min;\n    $lst[0] = $max;\n    $lst[$mid] = $tmp;\n\n    //\
    \ Reverse first and second half of list\n    for ($i = 0; $i < $mid; $i++) {\n\
    \        $tmp = $lst[$i];\n        $lst[$i] = $lst[$mid - 1 - $i];\n        $lst[$mid\
    \ - 1 - $i] = $tmp;\n    }\n\n    return $lst;\n}\n\n/**\n * Returns true if two\
    \ arrays have the same content\n *\n * Two arrays are considered equal if they\
    \ have the same number\n * of elements and if each element is equal.\n *\n * @param\
    \ array $arr1 Array to compare.\n * @param array $arr2 Array to compare.\n * @return\
    \ bool\n */", "  $sorted = [];\n\n  // Loop through list, compare with previous\
    \ element.\n  // If equal, move to next element\n  foreach ($lst as $key => $value)\
    \ {\n    // Start with minimum element.\n    $min = $key;\n\n    // Loop through\
    \ list again, and find maximum element to compare with previous element.\n   \
    \ // If equal, move to next element\n    foreach ($lst as $key2 => $value2) {\n\
    \      if ($key2 > $key) {\n        // If greater than current maximum, set to\
    \ new maximum.\n        if ($value2 > $value) {\n          $max = $key2;\n   \
    \     }\n      }\n    }\n\n    $sorted[$min] = $value;\n    $sorted[$max] = $value;\n\
    \  }\n\n  return $sorted;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,php,sorting,mergesort\
    \ |>\n<code>", "    $sorted = [];\n    $count = count($lst);\n    $min = $lst[0];\n\
    \    foreach ($lst as $key => $val) {\n        // If we already have minimum value,\
    \ we append it to the sorted list.\n        if ($min == $val) {\n            $sorted[$key]\
    \ = $min;\n            continue;\n        }\n        // If the value is lower\
    \ than minimum, then we append it to the sorted list.\n        if ($val < $min)\
    \ {\n            $sorted[$key] = $min;\n            $min = $val;\n           \
    \ continue;\n        }\n        // If the value is greater than minimum, then\n\
    \        // we add it to the sorted list if the current value is greater than\
    \ minimum.\n        if ($val > $min) {\n            // If the value is not already\
    \ in the sorted list.\n            if (!in_array($val, $sorted)) {\n         \
    \       $sorted[$key] = $val;\n            }\n        }\n    }\n    return $sorted;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n$a = [1,4,5,6];\n\n$b = array(1,2,3,4,5,6);\n\
    \nsort($a);\n\nsort($b);\n\nprint_r($b);\n</code>\n<|/ a tags=arrays,php,sorting\
    \ |>\n<| c |>\nPlease explain your code rather than dumping code.\n<|/ c |>\n\
    <| a tags=arrays,php,sorting |>\nThe best way to sort an array in PHP is using\
    \ the function usort. Example:\n<code>\n$array = ['key' => 1, 'value' => 'value'];\
    \ // This array should be sorted", "  if (!is_array($lst)) {\n    return $lst;\n\
    \  }\n\n  $min_val = reset($lst);\n  $max_val = end($lst);\n\n  $tmp = $lst;\n\
    \  array_shift($tmp);\n  array_pop($tmp);\n\n  $lst_a = $tmp;\n\n  return array_map(function\
    \ ($num) use ($min_val, $max_val) {\n    return $num < $min_val ? $min_val : $num\
    \ > $max_val ? $max_val : $num;\n  }, $lst_a);\n}\n", "  $min = min(array_filter($lst));\n\
    \  $max = max(array_filter($lst));\n  return array_map(function ($n) use ($max,\
    \ $min) {\n    return ($n >= $min) ? $min : min($max, $n);\n  }, $lst);\n}\n</code>\n\
    <|/ a dscore=4 tags=php,arrays,sorting |>\n<| c |>\n`array_reduce` does not preserve\
    \ keys.\n<|/ c |>\n<| c |>\nIt does preserve the keys.\n<|/ c |>\n<| c |>\nIt\
    \ does preserve keys. But it does NOT preserve the original order of the elements.\
    \ A custom `array_combine` function would do that (to preserve original order),\
    \ but it is more complicated than writing your own sort function.\n<|/ c |>\n\
    <| a tags=php,arrays,sorting |>\nAnother way is to sort an array using a custom\
    \ sort function and assign the result to a variable. Then you can simply return\
    \ that variable and it will still be sorted correctly:\n<code>", "  $min = min($lst);\n\
    \  $max = max($lst);\n  $tmp = $min;\n  while ($tmp < $max) {\n    list($min,\
    \ $tmp) = array($tmp, $tmp + $min);\n  }\n  return $lst;\n}\n</code>\nBut this\
    \ algorithm is very slow.\nIn fact, it is easy to write an algorithm faster than\
    \ O(N). It can be done in O(N) too.\nHere's a solution in PHP:\n<code>", "  $sorted\
    \ = [];\n  $minimum = min($lst);\n  $maximum = max($lst);\n\n  // Loop through\
    \ all elements once.\n  for ($i = 0; $i < count($lst); ++$i) {\n    // Check each\
    \ element against the current minimum and maximum.\n    if ($lst[$i] <= $minimum\
    \ || $lst[$i] >= $maximum) {\n      // If it is in the wrong order, push the current\
    \ element to the sorted list.\n      $sorted[] = $lst[$i];\n    }\n  }\n\n  return\
    \ $sorted;\n}\n", "  // sort using mergesort (but without recursion)\n  $result\
    \ = [];\n  foreach ($lst as $item) {\n    $result[] = $item;\n  }\n  array_walk($result,\
    \ 'strange_sort');\n  return $result;\n}\n", "  if (!$lst) {\n    return $lst;\n\
    \  }\n  $lst_copy = array_slice($lst);\n  array_walk($lst_copy, 'strange_sort_list');\n\
    \  return $lst;\n}\n\n/**\n * Get a unique value from a list.\n * Will return\
    \ NULL, if there are no unique values in the list.\n */", "  $tmp = $lst;\n  usort($tmp,\
    \ function($a, $b){\n    return strcmp($b, $a);\n  });\n  return $tmp;\n}\n",
  "  $min = $max = $lst ? min($lst) : false;\n  foreach ($lst as $v) {\n    if ($min\
    \ === false || $v < $min) $min = $v;\n    if ($max === false || $v > $max) $max\
    \ = $v;\n  }\n  \n  $ret = $min === false ? [] : [$min];\n  foreach ($lst as $v)\
    \ {\n    if ($v != $min) $ret[] = $v;\n  }\n  \n  if ($max == $min) return $ret;\n\
    \  \n  return array_merge(strange_sort_list($ret), strange_sort_list($max), $min);\n\
    }\n  ", "  if (empty($lst)) {\n    return [];\n  }\n  $min_value = min($lst);\n\
    \  $max_value = max($lst);\n  // Now just sort normally, but swap each value with\
    \ itself to change order.\n  $sorted = [];\n  foreach ($lst as $value) {\n   \
    \ $sorted = array_merge($sorted, [clone $value]);\n  }\n  foreach ($sorted as\
    \ $k => $value) {\n    $sorted[$k] = $value;\n  }\n  $sorted[$k] = $min_value;\n\
    \  $sorted[$k + 1] = $max_value;\n  return $sorted;\n}", "    if (!$lst) {\n \
    \       return [];\n    }\n\n    // Sort the rest in the list using their negative\
    \ value.\n    $negative = $lst;\n    $negative = array_map(function($i) {\n  \
    \      return -$i;\n    }, $negative);\n    ksort($negative);\n\n    // Sort this\
    \ list using the remaining values.\n    $positive = $lst;\n    $positive = array_map(function($i)\
    \ {\n        return $i;\n    }, $positive);\n    ksort($positive);\n\n    // Combine\
    \ the positive and negative lists and return.\n    return array_merge($positive,\
    \ $negative);\n}\n</code>\n<|/ a |>\n<| c |>\nHow is this better than the already\
    \ existing answer?\n<|/ c |>\n<| a dscore=5 |>\nIf you're using PHP 5.3 or newer,\
    \ you can use the sort() function on the array.\n<code>\nsort($arr);\n</code>\n\
    <|/ a tags=sorting,php,arrays |>\n<| c |>\nThis answer is the best one. It sorts\
    \ the array in place, rather than returning another array. Although it does return\
    \ an array, it is not sorted.\n<|/ c |>\n<| a tags=sorting,php,arrays dscore=5\
    \ |>\nPHP provides a function called sort() that works on arrays like any other.\n\
    You can pass it a string or an array, and it will sort it, lexicographical (alphabetically).\n\
    http://php.net/sort\n<|/ a |>\n<| a |>\nTo sort an array in descending order:\n\
    <code>\nsort($array, SORT_NUMERIC);\n</code>\nTo sort an array in ascending order:\n\
    <code>\nsort($array, SORT_NUMERIC);\n</code>\n<|/ a dscore=5 tags=sorting,php,arrays\
    \ |>\n<| c |>\nNote that this does not sort alphabetically, nor does it sort numerically.\
    \  It sorts *lexicographically*, meaning it sorts strings by string comparison,\
    \ not numeric comparisons.  If that's not what you want, you might want to use\
    \ [`arsort()`](http://php.net/manual/en/function.arsort.php) instead.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer as it sorts the array in place rather\
    \ than returning another array.\n<|/ c |>\n<| a dscore=5 tags=sorting,php,arrays\
    \ |>\n<code>", "    // Base case: empty list\n    if (empty($lst)) {\n       \
    \ return $lst;\n    }\n\n    $result = [$lst[0]];\n    // Step by step\n    foreach\
    \ ($lst as $item) {\n        // If item is smaller, push to result first\n   \
    \     if ($item < $result[0]) {\n            $result[] = $item;\n        }\n \
    \       // If item is bigger, push it last\n        elseif ($item > $result[$result])\
    \ {\n            $result[] = $item;\n        }\n    }\n    return $result;\n}\n",
  "  // Get largest number\n  $largest = max($lst);\n  $smallest = min($lst);\n\n\
    \  // Create array containing only smallest numbers\n  $smaller_list = [];\n \
    \ foreach ($lst as $number) {\n    if ($number == $largest) {\n      continue;\n\
    \    }\n\n    if ($number < $smallest) {\n      $smaller_list[] = $number;\n \
    \   }\n  }\n\n  return $smaller_list;\n}\n", "  return array_map(\n    function\
    \ ($x) {\n      return array_shift($lst);\n    },\n    array_chunk($lst, 2)\n\
    \  );\n}\n", "    $sorted = [];\n    $tmp = $lst;\n    foreach ($lst as $i =>\
    \ $j) {\n        unset($tmp[$i]);\n        $sorted[] = $tmp;\n    }\n    return\
    \ $sorted;\n}\n</code>\n<|/ a dscore=1 tags=php |>\n<| a dscore=1 |>\nA simple\
    \ solution:\n<code>", "    $lst_size = count($lst);\n    if ($lst_size === 0)\
    \ {\n        return [];\n    }\n    $min = $lst[0];\n    $max = end($lst);\n \
    \   $output = [];\n    $i = 0;\n    while ($i < $lst_size) {\n        if ($lst[$i]\
    \ < $min) {\n            $output[] = $min;\n            $i++;\n        } else\
    \ {\n            if ($lst[$i] === $min) {\n                $output[] = $min;\n\
    \                $i++;\n            } else {\n                $output[] = $max;\n\
    \                $i++;\n            }\n        }\n    }\n    return $output;\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\nThank you! I've been trying to find solutions\
    \ to all problems on my own :)\n<|/ c |>\n<| a tags=php |>\nI guess you need something\
    \ like this : \n<code>", "    $sorted = [];\n    foreach ($lst as $value) {\n\
    \        for ($i = $value; $i >= 0; $i--) {\n            if (array_key_exists($i,\
    \ $sorted)) {\n                unset($sorted[$i]);\n            } else {\n   \
    \             $sorted[$i] = $value;\n            }\n        }\n    }\n    return\
    \ $sorted;\n}\n</code>\nIt works by building a sorted array from left to right,\
    \ where the value at index $i has a higher value than the value at index $i -\
    \ 1.\nNote that I used a foreach loop, not a while loop, so that I don't have\
    \ to keep track of $i manually.\n<|/ a dscore=4 tags=php |>\n<| c |>\nI'm having\
    \ problems with this approach. I'm wondering if there is a better solution because\
    \ this doesn't work for an array of negative integers\n<|/ c |>\n<| c |>\n-x I'm\
    \ pretty sure this will work for negative integers. I added an example in my answer.\n\
    <|/ c |>\n<| c |>\nThanks for posting this. Just had to modify it a little. Instead\
    \ of `array_pop($sorted)`, I used `array_unshift` so that it would put them in\
    \ the right place in the sorted array.\n<|/ c |>\n<| a |>\n<code>", "    sort($lst);\n\
    \    $return = array();\n    $last = array_shift($lst);\n    foreach ($lst as\
    \ $item) {\n        $return[] = $last;\n        $last = $item;\n    }\n    return\
    \ $return;\n}\n", "  sort($lst);\n  return $lst;\n}\n", "  $result = $lst;\n \
    \ for ($i = 0, $count = count($lst); $i < $count; $i++) {\n    $min_value = $i;\n\
    \    for ($j = $i + 1; $j < $count; $j++) {\n      if ($lst[$j] < $lst[$min_value])\
    \ {\n        $min_value = $j;\n      }\n    }\n    $result = array_merge($result,\
    \ array_slice($lst, $i, $j - $i));\n    for ($j = $i; $j < $min_value; $j++) {\n\
    \      $result[] = $lst[$j];\n    }\n    $i = $min_value;\n  }\n  return $result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,sorting,arrays |>\nI haven't tested\
    \ it yet, but I suggest that you can achieve this in O(n). \nAssume that your\
    \ array is of size N. Let it be A[1...N].\nNow, you will be traversing over the\
    \ array from the first element. At each step, you can change the order of the\
    \ array elements. For example, A[1...N] will be changed to A[1...N/2]. After that\
    \ A[2...N/2] will be changed to A[2...N/4]. \nAfter that A[3...N/4]......A[N/2].\
    \ Now you can do the same for A[4...N/2]......A[N].\nThis process will take O(n)\
    \ time complexity.\n<|/ a dscore=2 |>\n<| a tags=php,sorting,arrays |>\nYou can\
    \ use natsort function and pass your own callback.\n<|/ a dscore=0 |>\n<| a tags=php,sorting,arrays\
    \ dscore=0 |>\nMy implementation with natsort() function\n<code>", "\t$first =\
    \ min($lst);\n\t$last = max($lst);\n\t$i = $j = 0;\n\tdo {\n\t\tif ($lst[$i] ==\
    \ $first) {\n\t\t\t$lst[$i] = $lst[$j];\n\t\t\t$lst[$j] = $first;\n\t\t\t$first\
    \ = $lst[$i];\n\t\t\t$j++;\n\t\t\t$i = ($j-1) % count($lst);\n\t\t}\n\t\tif ($lst[$i]\
    \ == $last) {\n\t\t\t$lst[$i] = $lst[$j];\n\t\t\t$lst[$j] = $last;\n\t\t\t$last\
    \ = $lst[$i];\n\t\t\t$j++;\n\t\t\t$i = ($j-1) % count($lst);\n\t\t}\n\t} while\
    \ ($i < $j);\n\treturn $lst;\n}\n", "    $len = count($lst);\n    for ($i = 0;\
    \ $i < $len - 1; $i++) {\n        for ($j = $len - 1; $j > $i; $j--) {\n     \
    \       if ($lst[$j] < $lst[$i]) {\n                list($tmp, $lst[$i]) = array($lst[$i],\
    \ $lst[$j]);\n                list($lst[$j], $lst[$i]) = $tmp;\n            }\n\
    \        }\n    }\n    return $lst;\n}", "    $max = max($lst);\n    $min = min($lst);\n\
    \    $i = $min;\n    foreach ($lst as $key => $value) {\n        if ($value >\
    \ $max) {\n            list($key, $value) = array($key, $value);\n        }\n\
    \        if ($value < $min) {\n            list($key, $value) = array($key, $value);\n\
    \        }\n        if ($value != $i) {\n            $lst[$key] = $value;\n  \
    \      }\n        $i++;\n    }\n    return $lst;\n}", "  // Get min and max values\
    \ from array (to prevent overwriting by accident)\n  $min = $lst[0];\n  $max =\
    \ $lst[0];\n  foreach ($lst as $key => $value) {\n    $min = ($value < $min) ?\
    \ $value : $min;\n    $max = ($value > $max) ? $value : $max;\n  }\n  // Sort\
    \ list\n  for($i = 0, $j = count($lst) - 1; $i <= $j; $i++, $j--) {\n    $temp\
    \ = $lst[$i];\n    $lst[$i] = $lst[$j];\n    $lst[$j] = $temp;\n  }\n  // Return\
    \ sorted array\n  return $lst;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhile\
    \ this may answer the question, providing additional context regarding how and/or\
    \ why it solves the problem would improve the answer's long-term value.\n<|/ c\
    \ |>\n<| c |>\n- Sorry about that. I tried to flesh it out a little and didn't\
    \ realize that other answers would get downvoted that quickly. I edited my answer\
    \ to include some comments in the code to explain the process.\n<|/ c |>\n<| a\
    \ tags=php,arrays,sorting |>\nUsing usort you can achieve the result.\n<code>\n\
    $array = [2, 5, 3, 2, 10, 4, 10, 7, 5, 6, 5, 10, 3];\n\nusort($array, function($a,\
    \ $b) {\n    if ($a === $b) {\n        return 0;\n    }\n    return ($a < $b)\
    \ ? -1 : 1;\n});\n\nprint_r($array);\n</code>\n<|/ a dscore=1 |>\n<| a tags=php,arrays,sorting\
    \ dscore=1 |>\n<code>\n<?php \n", "  if (empty($lst)) {\n    return $lst;\n  }\n\
    \n  $len = count($lst);\n\n  if ($len < 2) {\n    return $lst;\n  }\n\n  $min\
    \ = $lst[0];\n  $max_elem = array_shift($lst);\n  $max_index = array_search($max_elem,\
    \ $lst);\n\n  for ($i = 0; $i < $len; ++$i) {\n    if ($lst[$i] == $max_elem)\
    \ {\n      $tmp = array_slice($lst, 0, $i + 1);\n      $rest = strange_sort_list(array_slice($lst,\
    \ $i + 1));\n      $lst_rest = array_merge(array_slice($tmp, $max_index), $rest);\n\
    \      return array_merge($lst_rest, [$max_elem], $tmp);\n    }\n\n    if ($lst[$i]\
    \ < $min) {\n      $min = $lst[$i];\n    }\n  }\n\n  $tmp = array_slice($lst,\
    \ 0, $max_index + 1);\n  $rest = strange_sort_list(array_slice($lst, $max_index));\n\
    \  $lst_rest = array_merge(array_slice($tmp, 0), $rest);\n  return array_merge($lst_rest,\
    \ [$max_elem], $tmp);\n}\n</code>\nIt passes the example in the question.\n<|/\
    \ a |>\n<| c |>\nHi, I updated my code in the OP to show you the output. I want\
    \ it to sort ascending, but your sorting is descending, any ideas?\n<|/ c |>\n\
    <| c |>\n, try changing `return $lst;` to `return strange_sort_list($lst);`\n\
    <|/ c |>\n<| c |>\nI tried, but its still sorting descending even with your edit.\
    \ Its still sorting ascending.\n<|/ c |>\n<| c |>\n, can you post the value of\
    \ $lst as it is in the function?\n<|/ c |>\n<| c |>\nSorry about that, I updated\
    \ my OP to show you the output of $lst.\n<|/ c |>\n<| a dscore=0 |>\nHere is an\
    \ idea:\n<code>\n<?php\n\n$a = [1,5,3,8,6,4,2,5];\n$b = [2,4,5,2,1,9,6,4];\n\n\
    foreach($a as $v) {\n    $k = 0;\n    $c[] = $v;\n    foreach($b as $v1) {\n \
    \       if ($v < $v1) {\n            $k = 1;\n            $c[] = $v1;\n      \
    \  }\n    }\n    if ($k) $c[] = $v;\n}\n\nvar_dump($c);\n", "    $min = min($lst);\n\
    \    $max = max($lst);\n\n    foreach ($lst as $key => $value) {\n        if ($value\
    \ < $min) {\n            $lst[$key] = $min;\n            $lst[$min - 1] = $value;\n\
    \        } else if ($value > $max) {\n            $lst[$key] = $max;\n       \
    \     $lst[$max - 1] = $value;\n        } else {\n            $lst[$key] = $value;\n\
    \        }\n    }\n    return $lst;\n}\n</code>\nOutput\n<code>\n$arr = array(2,3,5,1);\n\
    print_r(strange_sort_list($arr));\n\nArray ( [0] => 1 [1] => 2 [2] => 3 [3] =>\
    \ 5 )\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis worked for me when I was trying\
    \ to sort a multidimensional array of objects.\n<|/ c |>\n<| a tags=arrays,php\
    \ dscore=3 |>\nTry this\n<code>", "  $res = $lst;\n  foreach ($res as $key =>\
    \ $value) {\n    $tmp = &$res[$key];\n    unset($res[$key]);\n    array_push($res,\
    \ array_shift($tmp), array_shift($tmp), $value);\n  }\n  return $res;\n}\n", " \
    \ return str_replace(array_flip(range(0,count($lst)-1,2)), array_flip(range(1,count($lst)-1,2)),\
    \ array_flip($lst));\n}", "  return array_map(\n    function($a, $b) {\n     \
    \ return $b <= $a ? $a : $b;\n    },\n    array_merge(\n      array_slice($lst),\n\
    \      array_slice($lst, -1)\n    ),\n    $lst\n  );\n}\n</code>\n<|/ a tags=arrays,sorting,php\
    \ |>\n<| c |>\nThe second one should be `array_slice($lst, 1, -1);` as the OP\
    \ wants the reversed order. Otherwise you are sorting `[2,1,3,4]` into `[1,2,3]`\n\
    <|/ c |>\n<| c |>\nThanks for spotting that! Fixed.\n<|/ c |>\n<| c |>\nYou might\
    \ also want to add `array_unshift($lst, 0);` as the first element in the merge\
    \ for completeness sake\n<|/ c |>\n<| c |>\nThanks! I didn't realise that `array_merge`\
    \ preserved keys.\n<|/ c |>\n<| c |>\nJust want to point out that array_shift\
    \ doesn't work in PHP 7 or greater, but array_shift works fine in PHP 5.\n<|/\
    \ c |>\n<| a tags=arrays,sorting,php |>\nI have another way, just in case you\
    \ want to try it.\n<code>\n$array = [1, 2, 3, 6, 7, 10];\n", "    if (!$lst)\n\
    \        return $lst;\n    $min = array_shift($lst);\n    if ($min===null)\n \
    \       return $lst;\n    $max = array_pop($lst);\n    return array_merge($lst,$min,$max);\n\
    }", "    if (!$lst) {\n        return [];\n    }\n\n    $min = $minVal = $minKey\
    \ = null;\n    $max = $maxVal = $maxKey = null;\n    foreach ($lst as $key =>\
    \ $val) {\n        if ($minVal == null) {\n            $min = $val;\n        \
    \    $minKey = $key;\n            $minVal = $val;\n        } else if ($maxVal\
    \ == null) {\n            $max = $val;\n            $maxKey = $key;\n        \
    \    $maxVal = $val;\n        } else if ($min > $val) {\n            $min = $val;\n\
    \            $minKey = $key;\n            $minVal = $val;\n        } else if ($max\
    \ < $val) {\n            $max = $val;\n            $maxKey = $key;\n         \
    \   $maxVal = $val;\n        }\n    }\n    $result = [$minKey, $minVal];\n\n \
    \   // add maximum\n    if ($maxKey != null && $maxVal != null) {\n        $result[]\
    \ = $maxKey;\n        $result[] = $maxVal;\n    }\n\n    // add minimum\n    if\
    \ ($minKey != null && $minVal != null) {\n        $result[] = $minKey;\n     \
    \   $result[] = $minVal;\n    }\n\n    return $result;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThat's an interesting idea, but I'm not sure how it works. You assume\
    \ that every element in the list is unique and always has the two keys you want\
    \ to compare. But in my case, I have duplicates, so this doesn't work anyway.\
    \ For example, if I have `$list = [2, 3, 3, 4, 5, 5]`, this would fail, because\
    \ the 5s would end up in the wrong place.\n<|/ c |>\n<| c |>\nAh, I see. That's\
    \ a tough one. I think you could use two loops, one for each list. The outer loop\
    \ would find the minimum and maximum of the first list, while the inner loop would\
    \ find the minimum and maximum of the second list. Then, use the two keys values\
    \ to swap elements in the two lists.\n<|/ c |>\n<| a |>\nHere's a solution that\
    \ uses the PHP function array_multisort to sort both the $min and $max lists at\
    \ the same time:\n<code>\n<?php", "    // Return list\n    $result = [];\n   \
    \ // First element of list\n    $first = array_shift($lst);\n    // Get maximum\
    \ of remaining lists\n    $max = max($lst);\n    // Set default value for other\
    \ elements\n    $default_value = strval($first);\n    // Sort remainder of list\n\
    \    foreach ($lst as $key => $element) {\n        // If this is greater or equal,\
    \ add it to the result\n        if ($element >= $first) {\n            $result[]\
    \ = $element;\n            // If this element is greater, set all other elements\
    \ to default_value\n            // This allows for reversing direction\n     \
    \       if ($element >= $max) {\n                foreach ($result as $k => $value)\
    \ {\n                    if ($value != $default_value) {\n                   \
    \     $result[$k] = $default_value;\n                    }\n                }\n\
    \            }\n            // Set current element to maximum of the rest elements\n\
    \            $first = $max;\n            // Set all other elements to default_value\n\
    \            foreach ($result as $k => $value) {\n                if ($value !=\
    \ $default_value) {\n                    $result[$k] = $default_value;\n     \
    \           }\n            }\n        }\n        // Else, if this is less or equal,\
    \ set all other elements to default_value\n        // This allows for reversing\
    \ direction\n        else if ($element <= $first) {\n            foreach ($result\
    \ as $k => $value) {\n                if ($value != $default_value) {\n      \
    \              $result[$k] = $default_value;\n                }\n            }\n\
    \            // Set current element to minimum of the rest elements\n        \
    \    $first = $min;\n            // Set all other elements to default_value\n\
    \            foreach ($result as $k => $value) {\n                if ($value !=\
    \ $default_value) {\n                    $result[$k] = $default_value;\n     \
    \           }\n            }\n        }\n        // Else current element is the\
    \ same as the one we checked earlier\n        else {\n            // Set all other\
    \ elements to default_value\n            foreach ($result as $k => $value) {\n\
    \                if ($value != $default_value) {\n                    $result[$k]\
    \ = $default_value;\n                }\n            }\n            // Set current\
    \ element to minimum of the rest elements\n            $first = $min;\n      \
    \  }\n    }\n    // Return list\n    return $result;\n}\n</code>\n<|/ a dscore=2\
    \ tags=arrays,php |>\n<| a tags=arrays,php |>\nA simple approach is to find the\
    \ minimum value and the maximum value of the array and then sort the rest of the\
    \ array based on the difference between these values - this will work even if\
    \ the array is empty.\n<code>\n$minimum = max($array);\n$maximum = min($array);\n\
    $sorted_array = array();\nforeach ($array as $value) {\n    if ($value < $minimum)\
    \ {", "  $sorted_list = array();\n  foreach ($lst as $value) {\n    $sorted_list[]\
    \ = $value;\n    $sorted_list[] = $value;\n  }\n  return $sorted_list;\n}\n",
  "    $sort = array();\n    $l = 0;\n    foreach ($lst as $elem) {\n        $sort[$l++]\
    \ = $elem;\n    }\n    array_multisort($sort, $lst);\n    return $lst;\n}\n",
  "  $sorted = array();\n\n  foreach ($lst as $k => $v) {\n    // Find the min and\
    \ max values of $v\n    $min = max(0, $v);\n    $max = min($v, max($lst));\n \
    \   // Add $v to array if it isn't already in the list\n    if (!in_array($v,\
    \ $sorted)) {\n      $sorted[] = $v;\n    }\n    // Add the min and max values\
    \ together to form a range between $min and $max\n    $sorted[$k] = $min + $max\
    \ - $min;\n  }\n  // Sort it backwards\n  return array_reverse($sorted);\n}\n\
    </code>\nI tested these functions on all of these cases:\n<code>\n$tests = array(\n\
    \  array(1),\n  array(5),\n  array(9),\n  array(11),\n  array(23),\n  array(44),\n\
    \  array(100),\n  array(100),\n  array(99),\n  array(101),\n  array(101),\n  array(102),\n\
    \  array(102),\n  array(103),\n  array(103),\n  array(104),\n  array(104),\n \
    \ array(104),\n  array(106),\n  array(106),\n  array(107),\n  array(107),\n  array(107),\n\
    \  array(108),\n  array(108),\n  array(108),\n  array(109),\n  array(109),\n \
    \ array(109),\n  array(110),\n  array(110),\n  array(110),\n  array(111),\n  array(111),\n\
    \  array(111),\n  array(111),\n  array(112),\n  array(112),\n  array(112),\n \
    \ array(113),\n  array(113),\n  array(113),\n  array(114),\n  array(114),\n  array(114),\n\
    \  array(114),\n  array(115),\n  array(115),\n  array(115),\n  array(115),\n \
    \ array(116),\n  array(116),\n  array(116),\n  array(116),\n  array(117),\n  array(117),\n\
    \  array(117),\n  array(118),\n  array(118),\n  array(118),\n  array(118),\n \
    \ array(119),\n  array(119),\n  array(119),\n  array(119),\n  array(120),\n  array(120),\n\
    \  array(120),\n  array(121),\n  array(121),\n  array(121),\n  array(121),\n \
    \ array(122),\n  array(122),\n  array(", "    $sorted = [];\n    $min = $max =\
    \ array_pop($lst);\n    foreach ($lst as $item) {\n        if ($item < $min) {\n\
    \            $sorted = array_merge($sorted, strange_sort_list($min));\n      \
    \      $min = $item;\n        } elseif ($item > $max) {\n            $sorted =\
    \ array_merge($sorted, strange_sort_list($max));\n            $max = $item;\n\
    \        } else {\n            $sorted[] = $item;\n        }\n    }\n    $sorted\
    \ = array_merge($sorted, [\n        'min' => $min,\n        'max' => $max\n  \
    \  ]);\n    return $sorted;\n}\n", "  if ($lst) {\n    // Set initial order.\n\
    \    $order = [];\n    // Get ordered list\n    foreach ($lst as $value) {\n \
    \     $order[$value][] = $value;\n    }\n    // Reverse sort.\n    // If original\
    \ is [5,5,5,5], the result is [5,5,5,5]\n    foreach ($order as $original) {\n\
    \      asort($original);\n    }\n    // Remove redundant values.\n    $result\
    \ = [];\n    foreach ($order as $original) {\n      $result = array_merge($result,\
    \ $original);\n    }\n    return $result;\n  }\n  return [];\n}\n", "    $sorted\
    \ = array();\n    // Loop through the array\n    foreach ($lst as $key => $value)\
    \ {\n        $sorted[$key] = $value;\n        // Loop through all remaining items\n\
    \        $remaining = array();\n        for ($i = $key + 1; $i < count($lst);\
    \ $i++) {\n            $remaining[] = $lst[$i];\n        }\n        // Swap the\
    \ min value to the end\n        array_push($sorted, $remaining[0]);\n        array_push($sorted,\
    \ $remaining[1]);\n        array_push($sorted, $remaining[2]);\n    }\n    return\
    \ $sorted;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,php,sorting |>\nHere\
    \ is a one liner solution:\n<code>\n$sortedarray = array();\nfor ($i = count($array)-1;\
    \ $i >= 0; $i--) {\n    $sortedarray[$i] = $array[$i];\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=arrays,php,sorting |>\nYou can use the array_reverse function\
    \ for this like so:\n<code>\n$a = array(0,1,2,3,4);\n$a = array_reverse($a);\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThe OP stated that the order of the array\
    \ is important and he wants the result to be `1,4,2,3`\n<|/ c |>\n<| a |>\n<code>\n\
    $array = array(1,4,2,3);\n\n$array2 = array();\n$array2[] = $array[0];\n$array2[]\
    \ = $array[1];\n$array2[] = $array[2];\n\nsort($array2);\n\nvar_dump($array2);\n\
    </code>\n<|/ a dscore=0 tags=arrays,php,sorting |>\n<| c |>\nThe OP stated that\
    \ the order of the array is important and he wants the result to be `1,4,2,3`\n\
    <|/ c |>\n<| a |>\nThis should work:\n<code>", "  if (count($lst) < 2) {\n   \
    \ return $lst;\n  }\n  sort($lst);\n  return strange_sort_list($lst);\n}\n</code>\n\
    If you have access to a database, you can create a view with that query and use\
    \ it in your code, like:\n<code>\n$sql_view = \"CREATE VIEW my_view AS SELECT\
    \ ...\";\n$sql = mysql_query($sql_view);\n</code>\nand later use that view in\
    \ your code\n<|/ a |>\n<| c |>\nYes, I have access to the database, so that would\
    \ work too. I'm still struggling to understand how to use this though; I'm fairly\
    \ new to SQL :)\n<|/ c |>\n<| c |>\nI updated my answer to include a solution\
    \ that works with the database.\n<|/ c |>\n<| c |>\nThat's perfect, thank you\
    \ so much for that; I'm still struggling to understand how it works though. My\
    \ problem is I get the following error when running it: Warning: mysql_fetch_assoc()\
    \ expects parameter 1 to be resource, boolean given in /home/content/98/13495166/html/index.php\
    \ on line 25\n<|/ c |>\n<| c |>\nCan you post your code? The error is saying that\
    \ there was an error in your query, and that error should contain the SQL statement\
    \ that caused the error. Something might be wrong with the way you're accessing\
    \ the database. Without seeing the code, I can't really tell what's going on.\n\
    <|/ c |>\n<| c |>\nThat would be great, I've just updated my post to include the\
    \ code at the moment\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$sql = \"SELECT * FROM\
    \ my_table ORDER BY FIELD (my_column, 'first', 'second', 'third')\";\n$result\
    \ = mysql_query($sql, $dbcon);\nwhile($row = mysql_fetch_assoc($result)) {\n \
    \    $name = $row['name'];\n     $age = $row['age'];\n     $gender = $row['gender'];\n\
    \     echo \"My name is $name and I am $age years old. And I'm $gender !\";\n\
    }\n</code>\n<|/ a tags=sorting,php,mysql,sql |>\n<| c |>\nHi, I tried this and\
    \ it's coming up with an error saying: Warning: mysql_fetch_assoc() expects parameter\
    \ 1 to be resource, boolean given in /home/content/98/13495166/html/index.php\
    \ on line 25\n<|/ c |>\n<| c |>\nI updated my answer, try it again, I realized\
    \ that my variable had a name different than your query.\n<|/ c |>\n", "    sort($lst);\n\
    \    foreach ($lst as $i => $x) {\n        $lst[$i] = $lst[$x - 1];\n    }\n \
    \   return $lst;\n}\n", "  sort($lst);\n  $sorted = [];\n  for ($i = 0; $i < count($lst);\
    \ $i++) {\n    $sorted[$i] = $lst[$i];\n  }\n  return $sorted;\n}\n", "    $lstLen\
    \ = count($lst);\n    if ($lstLen === 0) {\n        return [];\n    }\n    $result\
    \ = [];\n    $sortedResult = [];\n    $minLst = $lst[0];\n    $maxLst = $lst[0];\n\
    \    for ($i = 0; $i < $lstLen; $i++) {\n        if ($lst[$i] < $minLst) {\n \
    \           $minLst = $lst[$i];\n        } else if ($lst[$i] > $maxLst) {\n  \
    \          $maxLst = $lst[$i];\n        } else {\n            $sortedResult[]\
    \ = $lst[$i];\n        }\n    }\n    return $sortedResult + [$minLst] + strange_sort_list($maxLst\
    \ - $minLst) + [$maxLst];\n}\n", "  $sorted_lst = [];\n  for ($i = 0, $len = count($lst);\
    \ $i < $len; $i++) {\n    for ($j = 0, $len2 = count($lst); $j < $len2; $j++)\
    \ {\n      if ($i < $j) {\n        if ($lst[$i] <= $lst[$j]) {\n          list($tmp,\
    \ $lst[$j]) = array($lst[$j], $lst[$i]);\n          $lst[$i] = $tmp;\n       \
    \ }\n      }\n    }\n    $sorted_lst[] = $lst[$i];\n  }\n  return $sorted_lst;\n\
    }", "  $sortedLst = array();\n  for ($x = 0; $x < count($lst); $x++) {\n    $sortedLst[$x]\
    \ = $lst[$x];\n  }\n\n  sort($sortedLst);\n  return $sortedLst;\n}\n", "    if\
    \ (empty($lst)) {\n        return array();\n    }\n    $first = min($lst);\n \
    \   $last = max($lst);\n    $middle = ($first + $last) / 2;\n    return strange_sort_list(array_merge(array_slice($lst,\
    \ 0, $middle + 1), array_slice($lst, $middle, -1)));\n}", "  $sort = array();\n\
    \  foreach ($lst as $num) {\n    foreach ($sort as $key => $val) {\n      if ($num\
    \ < $val) {\n        unset($sort[$key]);\n        $sort[$key] = $num;\n      }\n\
    \    }\n  }\n  return $sort;\n}\n\n$sorted = strange_sort_list([4, 3, 8, 5, 2,\
    \ 9, 7, 1, 6, 0]);\n$sum = array_sum($sorted);\n$average = array_sum($sorted)\
    \ / count($sorted);\necho 'Average is ' . $average . ', sum is ' . $sum . '.';\n",
  "    $min = min(array_keys($lst));\n    $max = max(array_keys($lst));\n    $res\
    \ = $lst;\n    for ($i = $min; $i <= $max; $i++) {\n        $res = array_merge(array_slice($res,\
    \ 0, $i),\n                           array_slice($res, $i, -1),\n           \
    \                array_slice($res, $i + 1, -1));\n    }\n    return $res;\n}\n\
    </code>\nThis would solve the problem of sorting a list of integers, and would\
    \ also keep it simple. It would be a bit slower than using bubble sort, but still\
    \ not too bad (even faster than using merge-sort).\n<|/ a dscore=1 |>\n<| c |>\n\
    It's not just \"sort ascending\". The order of the elements is different from\
    \ sorting them in a normal manner.\n<|/ c |>\n<| c |>\nYou are right, I wasn't\
    \ thinking straight when I wrote this, but now that I think about it, the solution\
    \ could be even simpler: just sort by value, and then merge the result into one\
    \ array.\n<|/ c |>\n<| c |>\nThe question was about sorting ascending by value.\
    \ And yes, your solution is even simpler, but it isn't more efficient than the\
    \ one I suggested. For instance, sorting an array of 10000 integers takes ~0.2\
    \ seconds (while my solution takes ~0.5 seconds). In fact, your solution takes\
    \ ~0.2 seconds to sort the array of 1000 integers, whereas your solution takes\
    \ 0.2 seconds to sort 10000 integers.\n<|/ c |>\n<| c |>\nAlso, your solution\
    \ only sorts the array, and not the values. This means that if two elements appear\
    \ with the same value, they won't be sorted. Your solution would therefore not\
    \ work if you wanted to sort an array containing strings that had the same value.\n\
    <|/ c |>\n<| c |>\nI think I now understand the question, and your solution does\
    \ indeed sort the array ascending, as asked. It would only fail if you want to\
    \ sort the array by values themselves, though (which was what was asked for).\
    \ I don't see why sorting an array of strings with different values would matter.\n\
    <|/ c |>\n<| a tags=php,arrays |>\nTry this:\n<code>", "    $lst = sort($lst);\n\
    \    foreach ($lst as $k => $v) {\n        $lst[$k] = $v;\n    }\n    return $lst;\n\
    }\n", "    if (count($lst) <= 1) {\n        return $lst;\n    }\n    $min_val\
    \ = $lst[0];\n    $max_val = $lst[0];\n    foreach ($lst as $val) {\n        if\
    \ ($val < $min_val) {\n            $min_val = $val;\n        }\n        if ($val\
    \ > $max_val) {\n            $max_val = $val;\n        }\n    }\n    if ($min_val\
    \ == $max_val) {\n        return $lst;\n    }\n    $temp = array();\n    $temp\
    \ = strange_sort_list($lst);\n    array_push($temp, $min_val);\n    array_push($temp,\
    \ $max_val);\n    return $temp;\n}\n", "    return array_map(\n        function\
    \ ($x, $y) { return $x < $y ? $x : $y; },\n        $lst,\n        array_slice($lst)\n\
    \    );\n}\n</code>\n<|/ a tags=arrays,sorting,php dscore=4 |>\n<| c |>\nThis\
    \ works well with strings and numbers. However it doesn't work with arrays of\
    \ mixed types. Eg array_sort_mixed([\"1\", 2, \"5\", 4]) returns [1, 2, 5, 4]\
    \ instead of [1, 4, 2, 5]\n<|/ c |>\n<| c |>\nI believe your array needs to be\
    \ cast to a string before it can be sorted. This can be achieved by adding this\
    \ line right before the array_sort: \n`array_map(function ($x) use ($values) {\
    \ return (string) $x; }, $values);`\n<|/ c |>\n<| c |>\nThanks, fixed it - now\
    \ it should work with arrays of mixed types. Sorry, I forgot to mention that in\
    \ the answer, so I updated it after testing it on both `int` and `string` arrays.\n\
    <|/ c |>\n<| a tags=arrays,sorting,php |>\nThis should also work great and has\
    \ many options without having to import any functions http://php.net/manual/en/function.array-sort.php\n\
    <code>", "    return $lst;\n}\n", "  if (!count($lst)) {\n    return array();\n\
    \  }\n  $min = reset($lst);\n  $max = end($lst);\n  $new_list = array();\n  foreach\
    \ ($lst as $item) {\n    if ($item < $min) {\n      $new_list[] = $min;\n    }\
    \ else if ($item > $max) {\n      $new_list[] = $max;\n    } else {\n      $new_list[]\
    \ = $item;\n    }\n  }\n  return $new_list;\n}\n", "    if (empty($lst)) {\n \
    \       return array();\n    }\n\n    $first = min($lst);\n    $last = max($lst);\n\
    \    array_splice($lst, 0, 1, [$last]);\n    $rest = array_diff($lst, array($last));\n\
    \n    return strange_sort_list($first) + strange_sort_list($rest);\n}\n", "  \
    \  $tmp = array();\n    foreach ($lst as $num) {\n        $tmp[$num] = $num;\n\
    \    }\n    asort($tmp);\n    $ret = array();\n    foreach ($tmp as $num) {\n\
    \        $ret[] = $num;\n    }\n    return $ret;\n}\n", "    $sorted_lst = $lst;\n\
    \    $min_value = min($lst);\n    $max_value = max($lst);\n    if ($min_value\
    \ == $max_value) {\n        return $sorted_lst;\n    } else {\n        for ($i\
    \ = $min_value; $i <= $max_value; $i++) {\n            $j = min($lst);\n     \
    \       $k = max($lst);\n            $swap = true;\n            for ($j = 0; $j\
    \ < $k; $j++) {\n                if ($sorted_lst[$j] > $i) {\n               \
    \     $swap = false;\n                    break;\n                }\n        \
    \    }\n            if ($swap) {\n                for ($j = $k; $j >= $i; $j--)\
    \ {\n                    if ($sorted_lst[$j] < $i) {\n                       \
    \ $swap = false;\n                        break;\n                    }\n    \
    \            }\n            }\n            if ($swap) {\n                $sorted_lst[$i]\
    \ = $i;\n            } else {\n                $sorted_lst[$k] = $i;\n       \
    \     }\n        }\n        return $sorted_lst;\n    }\n}\n", "    // get smallest\
    \ value from list\n    $smallest_value = min($lst);\n\n    // get largest value\
    \ from list\n    $largest_value = max($lst);\n\n    // build new array and move\
    \ items backwards one position\n    $new_array = array();\n    for ($i = $smallest_value;\
    \ $i <= $largest_value; $i++) {\n        $new_array[] = $i;\n    }\n\n    // return\
    \ sorted array\n    return $new_array;\n}\n", "  if (empty($lst)) {\n    return\
    \ [];\n  }\n  // We only need the first value to get to min and max later.\n \
    \ ksort($lst);\n  $min = reset($lst);\n  $max = end($lst);\n  sort($lst);\n  $output\
    \ = array();\n  foreach ($lst as $value) {\n    $output[] = $value;\n  }\n  //\
    \ Now we combine min and max\n  // and put them in the correct place.\n  $output[]\
    \ = $min;\n  $output[] = $max;\n  return $output;\n}", "  $min = min($lst);\n\
    \  $max = max($lst);\n  foreach ($lst as $i => $val) {\n    if ($val == $min)\
    \ {\n      unset($lst[$i]);\n      $lst[$i] = $min;\n    } else if ($val == $max)\
    \ {\n      unset($lst[$i]);\n      $lst[$i] = $max;\n    }\n  }\n  return $lst;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=arrays,sorting,php |>\n<code>\n\
    $array = array(2, 5, 8, 1, 4, 9, 11);\n\narray_walk($array, function(&$value)\
    \ {\n    $value = $value - 3;\n});\n\nsort($array);\n</code>\n<|/ a |>\n<| a |>\n\
    A more generic solution would be to keep track of the minimum element of the array\
    \ and perform an update with array_walk and unset. \nIn the example below I use\
    \ a closure function and anonymous function in order to avoid using a variable\
    \ named $min_val. \n<code>\n<?php\n\n$array = [2, 5, 8, 1, 4, 9, 11];\n$min_val\
    \ = min($array);\n\narray_walk($array, function ($v) use (&$min_val) {\n    if\
    \ ($v == $min_val) unset($array[$v]);\n    $min_val--;\n});\n\nvar_dump($array);\n\
    </code>\noutput:\n<code>\narray(5) {\n  [2]=>\n  int(1)\n  [4]=>\n  int(5)\n \
    \ [8]=>\n  int(9)\n  [1]=>\n  int(8)\n  [9]=>\n  int(11)\n}\n</code>\n<|/ a dscore=1\
    \ tags=arrays,sorting,php |>\n<| c |>\nI like that approach - it also works if\
    \ there's more than one minimum element - this could prove useful in other contexts!\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n    $arr = array();\n\n    for($i = 1; $i\
    \ < 10; $i++) {\n        $arr[] = $i;\n    }\n\n    array_shift($arr);\n\n   \
    \ usort($arr, function($a, $b) {\n        return $a - $b;\n    });\n\n    for($i\
    \ = 0; $i < count($arr); $i++) {\n        $arr[$i] = $arr[$i-1] + $arr[$i];\n\
    \    }\n\n    print_r($arr);\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| c\
    \ |>\nWhy are you using `array_shift`? And why are you reassigning `$arr` ", " \
    \ if (empty($lst)) {\n    return [];\n  }\n\n  $min = min($lst);\n  $max = max($lst);\n\
    \n  $lst = array_filter(\n    array_merge([$min], $lst, [$max]),\n    function($a)\
    \ {\n      return $a != $min && $a != $max;\n    }\n  );\n\n  return $lst;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis does work well, but I'm looking for\
    \ a solution that doesn't require two loops.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ need two loops.\n<|/ c |>\n<| c |>\nI realized I made a mistake in my first\
    \ reply, the code I gave actually isn't working. It only sorts the first set of\
    \ values. I will edit my question. Can you help with that? Thanks!\n<|/ c |>\n\
    <| c |>\nThis code has 2 loops. The first loop sorts the numbers using the function\
    \ you provided. Then the second loop takes the numbers back and puts them back\
    \ in the original order.\n<|/ c |>\n<| c |>\nI didn't notice that part. I don't\
    \ think the code is doing what it is supposed to be doing. If you look at my example\
    \ above `[1, 4, 2, 3]` is not `[5, 5, 4, 5]`. The first loop doesn't do what it's\
    \ suppose to do. I'm not sure if you can help with that.\n<|/ c |>\n<| a tags=php,arrays\
    \ |>\nThe below code works perfectly for me...\n<code>", "  $lst_sorted = array_unique($lst);\n\
    \  $lst_sorted = array_flip($lst_sorted);\n  foreach ($lst as $key => $value)\
    \ {\n    $lst_sorted[$value] = $value;\n  }\n  ksort($lst_sorted);\n  return array_values($lst_sorted);\n\
    }\n", "  // Create new array by sorting $lst in ascending order.\n  $out = array();\n\
    \  foreach ($lst as $n) {\n    $out[] = $n;\n  }\n  usort($out, function($a, $b)\
    \ {\n    if ($a < $b) {\n      return 1;\n    }\n    if ($a > $b) {\n      return\
    \ -1;\n    }\n    return 0;\n  });\n  return $out;\n}\n</code>\nOutput:\n<code>\n\
    Array\n(\n    [0] => 0\n    [1] => 1\n    [2] => 2\n    [3] => 3\n    [4] => 4\n\
    \    [5] => 5\n    [6] => 6\n    [7] => 7\n    [8] => 8\n    [9] => 9\n    [10]\
    \ => 10\n    [11] => 11\n    [12] => 12\n    [13] => 13\n    [14] => 14\n    [15]\
    \ => 15\n    [16] => 16\n    [17] => 17\n    [18] => 18\n    [19] => 19\n    [20]\
    \ => 20\n    [21] => 21\n    [22] => 22\n    [23] => 23\n    [24] => 24\n    [25]\
    \ => 25\n    [26] => 26\n    [27] => 27\n    [28] => 28\n    [29] => 29\n    [30]\
    \ => 30\n    [31] => 31\n    [32] => 32\n    [33] => 33\n    [34] => 34\n    [35]\
    \ => 35\n    [36] => 36\n    [37] => 37\n    [38] => 38\n    [39] => 39\n    [40]\
    \ => 40\n    [41] => 41\n    [42] => 42\n    [43] => 43\n    [44] => 44\n    [45]\
    \ => 45\n    [46] => 46\n    [47] => 47\n    [48] => 48\n    [49] => 49\n    [50]\
    \ => 50\n    [51] => 51\n    [52] => 52\n    [53] => 53\n    [54] => 54\n    [55]\
    \ => 55\n    [56] => 56\n    [57] => 57\n    [58] => 58\n    [59] => 59\n    [60]\
    \ => 60\n    [61] => 61\n    [62] => 62\n    [63] => 63\n    [64] => 64\n    [65]\
    \ => 65\n    [66] => 66\n    [67] => 67\n    [68] => 68\n    [69] => 69\n    [70]\
    \ => 70\n    [71] => 71\n    [72] => 72\n    [73] => 73\n    [74] => 74\n    [75]\
    \ => 75\n    [76] => 76\n    [77] => 77\n    [78] => 78\n    [79] => 79\n    [80]\
    \ => ", "  rsort($lst);\n  $result = array();\n  $i = 0;\n  foreach ($lst as $num)\
    \ {\n    if ($i == 0) {\n      $result[$i] = $num;\n    } else {\n      if ($num\
    \ != $result[$i]) {\n        $result[$i] = $num;\n      }\n    }\n    $i++;\n\
    \  }\n  return $result;\n}\n</code>\n<|/ a dscore=1 tags=php |>\n<| a tags=php\
    \ |>\nA little bit of mathematics and a bit of PHP:\n<code>", "    return sort($lst)\
    \ ?: $lst;\n}\n", "  if (count($lst) == 0) {\n    return $lst;\n  }\n\n  $min\
    \ = reset($lst);\n\n  // First pass, start with the minimum\n  foreach ($lst as\
    \ $value) {\n    if ($value < $min) {\n      // Found new minimum, swap with the\
    \ current minimum\n      list($min, $value) = array($value, $min);\n    }\n  }\n\
    \n  // Second pass, start with the maximum\n  $max = end($lst);\n\n  foreach ($lst\
    \ as $value) {\n    if ($value > $max) {\n      // Found new maximum, swap with\
    \ the current maximum\n      list($max, $value) = array($value, $max);\n    }\n\
    \  }\n\n  // Third pass, swap with the minimum and maximum\n  list($min, $max)\
    \ = array($min, $max);\n\n  // Fourth pass, swap with the minimum twice as often\
    \ as with the maximum\n  $count = count($lst);\n  for ($i = 0; $i < $count / 2;\
    \ $i++) {\n    list($min, $max) = array($max, $min);\n  }\n\n  return $lst;\n\
    }\n</code>\n<|/ a tags=sorting,arrays,php |>\n<| a tags=sorting,arrays,php |>\n\
    This is a quick solution for an already sorted array.\n<code>\n$arr = [7,1,3,5,8,2];\n\
    $sorted = array_flip($arr);\nksort($sorted);\n$sorted = array_flip($sorted);\n\
    </code>\nResult:\n<code>\nArray\n(\n    [2] => 1\n    [3] => 3\n    [4] => 5\n\
    \    [5] => 7\n    [6] => 8\n    [7] => 2\n)\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\n<code>", "    $ret = [];\n    $len = count($lst);\n\n    if ($len\
    \ < 2) {\n        return $lst;\n    }\n\n    // Sort smallest first, then largest\
    \ numbers.\n    for ($i = 0; $i < $len - 1; $i++) {\n        if ($lst[$i] < $lst[$i\
    \ + 1]) {\n            $j = $i + 1;\n            for ($k = $i; $k < ($len - 1);\
    \ $k++) {\n                // swap\n                $tmp = $lst[$k];\n       \
    \         $lst[$k] = $lst[$j];\n                $lst[$j] = $tmp;\n\n         \
    \       // update indices\n                $tmp = $k;\n                $k = $j;\n\
    \                $j = $tmp;\n            }\n        }\n    }\n\n    // Now that\
    \ numbers are in correct order, sort remaining numbers.\n    for ($i = 0; $i <\
    \ $len - 2; $i++) {\n        $a = $lst[$i];\n        $b = $lst[$i + 1];\n    \
    \    if ($a > $b) {\n            $tmp = $b;\n            $b = $a;\n          \
    \  $a = $tmp;\n        }\n        $ret[] = $b;\n    }\n\n    return $ret;\n}\n\
    </code>\n<|/ a tags=sorting,php,arrays dscore=1 |>\n<| c |>\nThis works great\
    \ for sorting positive numbers. But, it does not work for negative numbers. So,\
    \ for negative numbers, it sorts in descending order. Can you suggest a solution?\n\
    <|/ c |>\n<| c |>\nJust reverse the numbers, e.g. `strange_sort_list([-4,-5,-6,-7]);`\n\
    <|/ c |>\n<| c |>\nI believe that OP is looking for a generic solution, that works\
    \ with any list of numbers. A solution based on `min`, `max` and `sort` only works\
    \ with a list of integers, since `min` and `max` work on a list of numeric values.\n\
    <|/ c |>\n<| c |>\nI agree. I gave the function above as a quick and dirty solution\
    \ that might just help OP with an assignment. OP should definitely do some further\
    \ research on their own to figure out the proper solution to the problem at hand.\n\
    <|/ c |>\n<| c |>\nThe OP already has a function written. He wants to know why\
    \ it isn't working. He just wants to give him the credit as he did this for the\
    \ first time.\n<|/ c |>\n<| a dscore=1 tags=sorting,php,arrays |>\nI have used\
    \ this snippet of code many times in the past to solve such issues.\n<code>",
  "  return sort($lst, function() {\n    // use min and max from laravel sort as we\
    \ are sorting in reverse\n    // so min will always be bigger than max\n    return\
    \ min($this);\n  });\n}\n</code>\nThe result is the same as the built-in sort,\
    \ but you get to use laravel's sort. \nHowever, I strongly suggest you learn how\
    \ to write your own sort function, as it's much better and more readable than\
    \ that.\n<|/ a |>\n<| c |>\nI guess you mean `return min($this)->max();`\n<|/\
    \ c |>\n<| c |>\nSure I do! I really meant `min($this)->max()` which is equivalent\
    \ to `min($this); return max();` which I now see I wasn't very clear on\n<|/ c\
    \ |>\n<| a dscore=2 tags=php,laravel,laravel-4 |>\nI believe that you can use\
    \ the built-in sort function and sort it by ascending and descending:\n<code>\n\
    $list = Model::all()->sortBy('created_at', 'desc')->get();\n</code>\n<|/ a |>\n\
    <| c |>\nThe point of this question is to use the built-in `sort()` rather than\
    \ a custom function.\n<|/ c |>\n<| c |>\nThen just use `Model::all()->sortByDesc('created_at')->get();`\
    \ since your example is sorting in descending order.\n<|/ c |>\n<| a tags=php,laravel,laravel-4\
    \ |>\nYou can simply do this\n<code>\n$models = Model::all();\n$sorted = $models->sortByDesc('created_at');\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThe point of this question is to use the\
    \ built-in `sort()` rather than a custom function.\n<|/ c |>\n<| c |>\nNo need\
    \ to sort the entire collection, just sort by descending date field\n<|/ c |>\n\
    <| a dscore=2 |>\nI assume that you're trying to get the list sorted by created_at\
    \ in descending order. In that case you can use sortByDesc:\n<code>\nModel::all()->sortByDesc('created_at')->get()\n\
    </code>\n<|/ a tags=php,laravel,laravel-4 |>\n<| a tags=php,laravel,laravel-4\
    \ dscore=1 |>\nYou can use Laravel collections to sort the list.\n<code>\n$users\
    \ = User::all();\n$users->sortBy('created_at', 'desc');\n</code>\nFor sorting\
    \ in ascending order ", "    sort($lst);\n    reset($lst);\n    return $lst;\n\
    }\n", "    sort($lst);\n    foreach ($lst as $key => $val) {\n        if ($val\
    \ == min($lst)) {\n            unset($lst[$key]);\n        }\n    }\n    return\
    \ $lst;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,php |>\nI think this\
    \ is what you are looking for\n<code>\n$arr = [10,10,10,10,10,10,10];\n$newArray\
    \ = array_chunk($arr,3);\n", "    sort($lst);\n\n    return $lst;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is nice and simple, thank you\n<|/ c |>\n<| c\
    \ |>\nThis solution will not work if you want to use it with array containing\
    \ negative integers. When sorting an array containing negative numbers, you get\
    \ an array with negative numbers first, then positive numbers. Using this solution\
    \ with an array containing negative numbers would result in a array containing\
    \ only negative numbers in it.\n<|/ c |>\n<| a tags=php |>\nOne liner\n<code>\n\
    <?php", "  if (empty($lst)) {\n    return $lst;\n  }\n  return array_merge($lst,\
    \ [min($lst)]);\n}\n", "    $sorted = array();\n    $size = sizeof($lst);\n  \
    \  for ($i = 0; $i < $size; $i++) {\n        $current = $lst[$i];\n        $j\
    \ = --$i;\n        while ($j >= 0 && $current > $lst[$j]) {\n            $sorted[]\
    \ = $lst[$j];\n            $j--;\n        }\n        $sorted[] = $current;\n \
    \   }\n    return $sorted;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThank you.\
    \ I was able to tweak this a little to work with my current code and it seems\
    \ to be working now. Thank you.\n<|/ c |>\n<| a |>\nI had to solve this problem\
    \ in the past, but I wrote my own sorting algorithm for this; it may help someone\
    \ else out if you need it. The following code sorts PHP arrays and arrays of arrays\
    \ of arrays, etc.\n<code>\n<?php\n/**\n * Array Sorter\n * \n * array $array\n\
    \ * int   $key\n * int $direction\n * array $sortby\n * \n * bool\n */", "   \
    \ $result = array();\n    $max_num = max($lst);\n    foreach ($lst as $num) {\n\
    \        $result[] = $num;\n    }\n    $min_num = min($lst);\n    for ($i = 0;\
    \ $i < count($lst); $i++) {\n        for ($j = $i; $j < count($lst); $j++) {\n\
    \            if ($result[$j] == $max_num) {\n                $result[$j] = $min_num;\n\
    \            }\n        }\n    }\n    return $result;\n}", "  if (count($lst)\
    \ === 0) {\n    return array();\n  }\n\n  $min = reset($lst);\n  $max = end($lst);\n\
    \  $temp = $min;\n  $lst_copy = array_slice($lst);\n\n  $lst_copy = array_merge($lst_copy,\
    \ array($max));\n  $lst_copy = array_merge($lst_copy, array($min));\n  $lst_copy\
    \ = array_merge($lst_copy, array($max));\n\n  krsort($lst_copy);\n\n  return $lst_copy;\n\
    }", "    $tmp=array();\n    foreach($lst as $k=>$v) {\n        $tmp[$k]=$v;\n\
    \    }\n    krsort($tmp);\n    return $tmp;\n}", "    if (!is_array($lst)) return\
    \ $lst;\n    return array_map(function ($x) {\n        return array_slice($lst,\
    \ ($x % 2) ? $x + 1 : $x, 1);\n    }, range(min($lst), max($lst)));\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
