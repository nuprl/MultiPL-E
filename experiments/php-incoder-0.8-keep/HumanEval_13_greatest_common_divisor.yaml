name: HumanEval_13_greatest_common_divisor
language: php
prompt: "<?php\n// Return a greatest common divisor of two integers a and b\n// >>>\
  \ greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n\
  // 5\nfunction greatest_common_divisor($a, $b) {\n"
tests: "function candidate(...$args) {\n    return greatest_common_divisor(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(3, 7) !== 1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(10, 15) !== 5) { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(49, 14) !== 7) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(144, 60) !== 12) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["    return $a % $b ? $b : $a;\n}\n", "  $gcd = 0;\n  for ($i = 1; $i\
    \ <= $b && $a % $i == 0; ++$i) {\n    $gcd = max($gcd, $i);\n  }\n  return $gcd;\n\
    }\n", "    return $b ? gcd($a, $b % $a) : $a;\n}\n", "    // Check if they are\
    \ equal\n    if ($a == $b) {\n        return 1;\n    }\n\n    // Calculate and\
    \ return the greatest common divisor\n    return $a % $b == 0 ? $a / $b : greatest_common_divisor($b,\
    \ $a % $b);\n}\n", "    $lcm = lcm($a, $b);\n    $gcd = gcd(($lcm), $b);\n   \
    \ return $lcm;\n}", "    $gcd = 0;\n    while (0 !== ($tmp = $a % $b)) {\n   \
    \     $a = $b;\n        $b = $tmp;\n        $gcd++;\n    }\n    return $gcd;\n\
    }\n", "    $common = gcd($a, $b);\n\n    $remainder = $a % $common;\n    if ($remainder\
    \ == 0) {\n        $remainder = $b % $common;\n    }\n\n    return $common * $remainder;\n\
    }\n", "\treturn ($a % $b) + (($a % $b && $b) || ($b % $a));\n}\n", "    $remainder\
    \ = $a % $b;\n    if ($remainder == 0) {\n        return $b;\n    }\n    return\
    \ $remainder;\n}\n</code>\n<|/ a |>\n<| c |>\nAwesome answer, but I think this\
    \ should be a comment, unless you also show some code to accompany it.\n<|/ c\
    \ |>\n<| c |>\nOh yeah, sorry. I was so focused on how to *calculate* the greatest\
    \ common divisor that I completely forgot how to write a function.\n<|/ c |>\n\
    <| c |>\nI agree that you should post code with your answer, but this is an appropriate\
    \ answer, as it is an algorithm that does what the OP asked for.\n<|/ c |>\n<|\
    \ c |>\nBtw, while I love your solution for its elegance, I think it's worth pointing\
    \ out that `gcd_with_zero` should be `if ($b == 0)`\n<|/ c |>\n<| c |>\n: Thanks,\
    \ fixed.\n<|/ c |>\n<| a dscore=5 tags=php,math,algorithm,division |>\n<code>",
  "  // Ensure $a is bigger than $b\n  if ($a < $b) {\n    $a = $b;\n    $b = $a;\n\
    \  }\n  \n  // Initialize $gcd and $x to 1, then $y to the remainder.\n  $gcd\
    \ = 1;\n  $x = 0;\n  $y = 0;\n\n  // Repeat until $gcd is greater than or equal\
    \ to $b (i.e. $a divides $gcd evenly).\n  while (--$gcd) {\n    // $x = $a%$gcd;\
    \ $a = floor($a/$gcd);\n    $x = $a % $gcd;\n    $a = floor($a / $gcd);\n\n  \
    \  // $y = $x%$b; $x = floor($x/$b); $y = $y%$gcd ($remainder)\n    $y = $x %\
    \ $b;\n    $x = floor($x / $b);\n\n    // If $a and $x are equal, then $y is $a\
    \ and $gcd = 0\n    if ($a === $x) {\n      $gcd = intval($y);\n    }\n  }\n\n\
    \  return $gcd;\n}\n", "    $gcd = 0;\n    if ($a < 0) {\n        $a = -$a;\n\
    \    }\n    if ($b < 0) {\n        $b = -$b;\n    }\n    while ($a != 0) {\n \
    \       $t = $b;\n        $b = $a;\n        $a = $t % $a;\n        $gcd = max($gcd,\
    \ $a);\n    }\n    return $gcd;\n}\n", "\tif ($a < $b)\n\t\t$temp = $a;\n\telse\n\
    \t\t$temp = $b;\n\n\tfor ($x = 1; $x <= $temp; $x++) {\n\t\tif (($a % $x) == 0)\
    \ {\n\t\t\tif ($b % $x == 0)\n\t\t\t\treturn $x;\n\t\t\telse\n\t\t\t\treturn $temp;\n\
    \t\t}\n\t}\n}", "    if ($a == 0)\n        return $b;\n    if ($b == 0)\n    \
    \    return $a;\n    if ($a < 0 && $b > 0)\n        return $b;\n    if ($a > 0\
    \ && $b < 0)\n        return $a;\n    while (true) {\n        if ($a % $b !==\
    \ 0)\n            return $b;\n        $a = floor($a / $b);\n        $b = $a -\
    \ 1;\n    }\n}", "    $gcd = $a;\n    $a = $b;\n    $b = $gcd;\n    while (true)\
    \ {\n        $gcd  = $a % $gcd;\n        $a    = $b;\n        $b    = $gcd;\n\
    \        if ($b == 0) {\n            return $gcd;\n        }\n    }\n}\n", " \
    \ $r = $b % $a;\n  if ($r == 0) {\n    return $a;\n  }\n  return $r;\n}\n", " \
    \ return ($a % $b !== 0) ? $a : gcd($a, $b); /* see euclid.h */\n}\n", "  $d =\
    \ $a % $b;\n  $a = $b % $a;\n  $b = $d;\n  do {\n    $b = $b + ($a /= 2);\n  \
    \  $a = $a + ($b /= 2);\n    $d = $d + ($a /= 2);\n    $a = $a + ($b /= 2);\n\
    \    $d = $d + ($a /= 2);\n  } while ($a != 1);\n  return $b;\n}\n", "  $r = $a\
    \ % $b;\n  if ($r == 0) {\n    return $b;\n  } else {\n    return $r;\n  }\n}\n",
  "    return ($b == 0) ? $a : $greatest_common_divisor_helper($a, $b >> 1);\n}\n",
  "    if ($a < $b) {\n        $a = $b;\n        $b = $a;\n    }\n    while ($a !=\
    \ 0) {\n        $a = $b % $a;\n        $b = ($a * $b) / $a;\n    }\n    return\
    \ $b;\n}\n", "    while ($b != 0) {\n        if ($a % $b == 0)\n            return\
    \ $b;\n        $a = $b % $a;\n        $b = $a * 2;\n    }\n    return $b;\n}\n\
    </code>\nAnd here's the resultant code:\n<code>\n<?php", "    while ($a > 0) {\n\
    \        $tmp = $a;\n        $a = $b % $tmp;\n        $b = $tmp;\n    }\n    return\
    \ $b;\n}\n\n$a = isset($_REQUEST[\"a\"]) ? $_REQUEST[\"a\"] : false;\n$b = isset($_REQUEST[\"\
    b\"]) ? $_REQUEST[\"b\"] : false;\n\nif($a && $b) {\n    $g = greatest_common_divisor($a,\
    \ $b);\n}\n", "    // a > b\n    if ($a > $b) {\n        $a = $b;\n        $b\
    \ = $a;\n    }\n\n    $c = $a;\n    do {\n        $c = $b % $c;\n        $b =\
    \ $a;\n        $a = $c;\n    } while (!$b);\n\n    return $c;\n}\n</code>\n<|/\
    \ a dscore=1 tags=php |>\n<| c |>\nthis does not take negative values into account\n\
    <|/ c |>\n<| a tags=php |>\nThis is working well:\n<code>", "    return !$b ?\
    \ $a : gcd($b, $a%$b);\n}", "  for ($i = 2; $i <= sqrt($a * $b); $i++) {\n   \
    \ if ($a % $i == 0 && $b % $i == 0) {\n      return $i;\n    }\n  }\n}\n", " \
    \   $a_large = $a > $b;\n    $b_large = $b > $a;\n    $a = $a > $b ? $a : $b;\n\
    \    $b = $a_large ? $b_large : $b;\n    if ($a % $b == 0 && !$a_large) {\n  \
    \      if ($b == 1) {\n            return $a;\n        } else {\n            return\
    \ $b;\n        }\n    }\n\n    $c = 1;\n    while (!($a % $b)) {\n        $a *=\
    \ $b;\n        $c++;\n    }\n    return $c;\n}\n", "    if ($a < $b) {\n     \
    \   return $b;\n    }\n\n    return $a;\n}\n\n/**\n * Return a new array with\
    \ only unique items from the input array\n * >>> unique_everseen([1, -1, 1, 2],\
    \ is_int)", "    $temp = $a;\n    while(true) {\n        if ($temp % $b == 0)\
    \ {\n            return $b;\n        }\n        $temp = $temp / $b;\n    }\n}",
  "\t$lcm = 1;\n\tfor ($i = 1; $i <= abs($a % $b); $i++) {\n\t\t$lcm = bcmod($lcm,\
    \ $b);\n\t}\n\treturn $lcm;\n}", "  for ($k = $b; $a % $k == 0; $k = $k / $a,\
    \ $a++);\n  return $k;\n}", "    return $b == 0 ? $a : $b == $a ? $a : greatest_common_divisor($b,\
    \ $a % $b);\n}\n", "    $div = $a / $b;\n    $mod = $a % $b;\n    if ($div > $mod)\
    \ {\n        $div = $mod;\n    }\n    while ($div) {\n        $mod = $div;\n \
    \       $div = $mod / $b;\n        if ($div > $mod) {\n            $mod = $div;\n\
    \        }\n    }\n    return $mod;\n}\n", "  $a = intval($a);\n  $b = intval($b);\n\
    \  if ($a < $b) {\n    $a = $b; // Handle negative values\n  }\n  $r = $a;\n \
    \ $d = 1;\n  for ($i = 0; $i < abs($b); $i++) {\n    if (($a % $d) != 0) {\n \
    \     $d++;\n    }\n  }\n  return $r;\n}", "    while ($b > 0) {\n        $remainder\
    \ = $a % $b;\n        if ($remainder === 0) {\n            $a = $b;\n        }\
    \ else {\n            $b = $remainder;\n        }\n    }\n    return $a;\n}\n\n\
    /**\n * Returns the value of a query string argument by name provided\n *\n *\
    \ get_query_var('name[foo][]', array('foo' => 'bar')) == array('foo' => 'bar')\n\
    \ * get_query_var('name[foo][]', array('foo' => 'bar')) == array('foo' => array('bar'))\n\
    \ *\n * @param string $key\n * @param array $defaults\n * @return mixed\n */",
  "\t$tmp = $a;\n\t$a = $b;\n\t$b = $tmp;\n\twhile (1) {\n\t\tif ($a < 1) {\n\t\t\t\
    $a = $b;\n\t\t\tbreak;\n\t\t}\n\t\tif ($b < 1) {\n\t\t\t$b = $a;\n\t\t\tbreak;\n\
    \t\t}\n\t\t$tmp = $a % $b;\n\t\t$a = $b;\n\t\t$b = $tmp;\n\t}\n\treturn $a;\n\
    }\n", "  // Make sure a and b are integers\n  $a = intval($a);\n  $b = intval($b);\n\
    \  do {\n    $r = $a % $b;\n    $a = $b;\n    $b = $r;\n  } while($a != 0);\n\
    \  return $b;\n}", "  while (b != 0) {\n    $t = $b;\n    $b = $a % $b;\n    $a\
    \ = $t;\n  }\n  return $a;\n}\n", "  // Euclid's algorithm\n  $max_divisor = $b;\n\
    \  for ($i = 1; $max_divisor != ($a / $i); ++$i) {\n    if ($max_divisor == ($a\
    \ % $i)) {\n      return $i;\n    }\n  }\n  return $a;\n}\n", "    $remainder\
    \ = $a % $b;\n    if ($remainder == 0) {\n        return $b;\n    }\n    return\
    \ greatest_common_divisor($b, $remainder);\n}\n", "\tif ($a < $b) return $b;\n\
    \telseif ($a > $b) return $a;\n\telse return $a;\n}\n", "  return ($a % $b) /\
    \ gcd($a, $b);\n}\n", "    $gcd = 0;\n    while(1) {\n        $gcd++;\n      \
    \  if ($gcd&1) {\n            $a%= $b;\n            if ($a<0) {\n            \
    \    $a+=abs($b);\n                $b=$b;\n            }\n        } else {\n \
    \           if ($a%$b<0) {\n                $a+=abs($b);\n                $b=$b;\n\
    \            }\n        }\n        if ($b==0) {\n            break;\n        }\n\
    \        $b=$b / $gcd;\n        $gcd++;\n    }\n    return $gcd;\n}\n", "  //\
    \ Initialize variables\n  $result = 0;\n  $max_divisor = 0;\n\n  // If either\
    \ integer is zero, return the other integer\n  if ($a == 0 || $b == 0) {\n   \
    \ return $a > $b ? $a : $b;\n  }\n\n  // Get the greatest common divisor\n  while\
    \ (true) {\n    // If they divide evenly, take their remainder\n    if ($a % $b\
    \ == 0) {\n      $result -= $b;\n    }\n\n    // If they divide oddly, take their\
    \ quotient\n    else {\n      $result -= $a % $b;\n    }\n\n    // If their remainder\
    \ is 0, they have the same greatest common divisor\n    if ($result == 0) {\n\
    \      break;\n    }\n\n    // Increase the larger integer\n    if ($result >\
    \ $max_divisor) {\n      $max_divisor = $result;\n    }\n\n    // Decrease the\
    \ smaller integer\n    $a = $b;\n    $b = $result % $a;\n  }\n\n  return $max_divisor;\n\
    }\n</code>\n<|/ a tags=php,greatest-common-divisor |>\n<| a dscore=4 tags=php,greatest-common-divisor\
    \ |>\nThe algorithm is a bit more complicated than just looping through all the\
    \ numbers and finding the greatest common divisor.  As long as there is a remainder,\
    \ then the numbers share the same greatest common divisor.  By definition their\
    \ greatest common divisor is also their greatest common dividend and by definition\
    \ they are coprime.\nThe algorithm is explained here: http://en.wikipedia.org/wiki/Greatest_common_divisor#Algorithms\n\
    <|/ a |>\n<| c |>\nThe link you provided gives a good explanation. Can you please\
    \ explain a bit more on the algorithm?\n<|/ c |>\n<| c |>\nI added a link to a\
    \ Wikipedia page that explains the algorithm.\n<|/ c |>\n<| c |>\nThat doesn't\
    \ make it a lot more complicated!\n<|/ c |>\n<| a dscore=4 |>\nI love this one!\n\
    <code>\n<?php\n", "    $t = $a % $b;\n    if ($t === 0) {\n        return $b;\n\
    \    }\n    else {\n        return $b;\n    }\n}\n", "  // Make sure the two numbers\
    \ are whole numbers\n  $a = abs((int) $a);\n  $b = abs((int) $b);\n\n  // Make\
    \ sure b > a\n  if ($a > $b) {\n    $temp = $a;\n    $a = $b;\n    $b = $temp;\n\
    \  }\n\n  $gcd = $b;\n  while ($a > 0) {\n    $tmp = --$gcd % $a;\n  }\n\n  return\
    \ $gcd;\n}\n", "  if ($a == 0) return $b; if ($b == 0) return $a; while (true)\
    \ {\n    $x = ($a % $b) / $b; if ($x == 0) return $b; if ($x == 1) return $a;\n\
    \    $a = $x; $b = $x % $b;\n  }\n}", "    $r = $b % $a;\n    return ($r == 0)\
    \ ? $a : $r;\n}", "    // Write your code here\n}\n</code>\nNow we will need to\
    \ use that function in our main code. There are three ways to do this. One would\
    \ be to inline it, so the code is only executed when it is called:\n<code>\n$num1\
    \ = 25;\n$num2 = 15;\n", "  if ($a < 0) {\n    return -1 * greatest_common_divisor(-$a,\
    \ $b);\n  }\n  if ($b < 0) {\n    return -1 * greatest_common_divisor($a, -$b);\n\
    \  }\n  $i = 0;\n  if ($a === 0) {\n    return $b;\n  }\n  if ($b === 0) {\n \
    \   return $a;\n  }\n  while ($a != $b) {\n    $i++;\n    $a = ($a / $i) | 0;\n\
    \    $b = ($b / $i) | 0;\n  }\n  return $i;\n}\n/*\n    pow($base, $exp, $modulus=1)\
    \ returns a ^ $exp mod $modulus\n*/\n", "    $gcd = 0;\n    for ($i = $a; $i >\
    \ 0; $i--) {\n        if ($b % $i == 0) {\n            $gcd = $i;\n        }\n\
    \    }\n    return $gcd;\n}\n", "    // Euclid's algorithm\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    $r = 1;\n    $d = 0;\n    while ($a != 0) {\n        $t = $b / $a;\n    \
    \    $r = $r * $a + $t;\n        $d = $d;\n        $a = $t - $d;\n    }\n    return\
    \ ($r % $b == 0) ? $r : 0;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer!\
    \ The PHP solution looks promising, but I can't seem to make it work. I'm not\
    \ sure I understand how this would work. Would you mind explaining a bit more?\n\
    <|/ c |>\n<| c |>\nI added a PHP solution to my answer, hope it helps.\n<|/ c\
    \ |>\n<| c |>\nThanks for the answer! I updated my question above to include the\
    \ code that I tried to use that uses PHP's bcdiv. Unfortunately, the code doesn't\
    \ work. I'm very confused as to what I'm doing wrong.\n<|/ c |>\n<| c |>\nI've\
    \ updated my answer and included a working PHP solution. I hope it helps.\n<|/\
    \ c |>\n<| a tags=php,floating-point,algorithm |>\nThis problem looks more like\
    \ integer division (not floating point) than floating point division.  I see two\
    \ possible solutions depending on whether your numbers are small or large.  For\
    \ small numbers, you might try dividing them by 10, 100, or 1000 until you have\
    \ a result that's a multiple of the divisor.\nFor large numbers, I would recommend\
    \ using the algorithm outlined in this Wikipedia article.\n<|/ a dscore=0 |>\n\
    <| c |>\nThank you for the answer! Unfortunately I can't do that because my numbers\
    \ will vary in size, and also because these numbers are just examples.\n<|/ c\
    \ |>\n<| a tags=php,floating-point,algorithm |>\nHere is a PHP version using bcmul\
    \ (as posted by David Farmer in his answer), but with some error checking. I also\
    \ added some comments to help you understand what is going on:\n<code>\n/**\n\
    \ * Return the greatest common divisor of two integers a and b\n * int $a\n *\
    \ int $b\n * int\n */", "    if ($a < $b) {\n        $a += $b;\n        $b = $a;\n\
    \    }\n\n    do {\n        $c = $b;\n        $b = $a % $c;\n        $a = $c;\n\
    \    } while ($a != $b);\n\n    return $b;\n}", "    return $b == 0 ? $a : $a\
    \ / greatest_common_divisor($b, $a % $b);\n}", "    return $b ? gcd($a, $b) :\
    \ $a;\n}\n", "    $x = abs($a) % abs($b);\n    $y = (abs($a) - $x) / abs($b);\n\
    \    return ($x < $y) ? $x : $y;\n}\n", "    while ($b > 0) {\n        $a = $b;\n\
    \        $b = $a % $b;\n    }\n    return $a;\n}\n", "\t$b = max ($b, $a);\n\t\
    if ($b == 0)\n\t\treturn $a;\n\treturn ($b == 1) ? $a : $b % $a;\n}\n", "    if\
    \ ($a === 0) {\n        return $b;\n    }\n\n    if ($b === 0) {\n        return\
    \ $a;\n    }\n\n    // get gcd of $a and $b\n    $gcdOfA = gcd($a, $b);\n    $gcdOfB\
    \ = gcd($b, $a);\n\n    // return greatest common divisor\n    return $gcdOfA\
    \ > $gcdOfB ? $gcdOfA : $gcdOfB;\n}\n", "    while ($a && $b) {\n        $a =\
    \ $b % $a;\n        $b = $a % $b;\n    }\n    return $b;\n}\n\n$users = get_users(array(\"\
    filter\"=>\"role=administrator\"));\n$numusers = count($users);\nif ($numusers\
    \ > 0) {\n    ?>\n        <?php if ($numusers == 1) {\n            $user = get_user($users[0]->ID);\n\
    \            $username = $user->user_login;\n        }\n        else\n       \
    \ {\n            $username = '(Multiple)';\n        }\n        ?>\n        <table>\n\
    \            <tr valign=\"top\">\n                <th scope=\"col\">#</th>\n \
    \               <th scope=\"col\">Username</th>\n            </tr>\n         \
    \   <?php\n            foreach ($users as $user) {\n                $userid =\
    \ $user->ID;\n                $username = $user->user_login;\n               \
    \ echo \"<tr><td>$userid</td><td>$username</td></tr>\";\n            }\n     \
    \       ?>\n        </table>\n        <?php\n}\nelse\n{\n    echo '<p class=\"\
    error\">No user found</p>';\n}", "  $r = $a;\n  while($r && $r%$b) $r += $b;\n\
    \  return $r;\n}\n", "    while ($a && $b) {\n        $a = $a % $b;\n        $b\
    \ = $b % $a;\n    }\n    return $a;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    If you don't mind using libraries, I would recommend using GMP. Its implementation\
    \ is very efficient, efficient, fast, and easy to use. \n<code>\n<?php\n$gmp =\
    \ new GMP(2); // create a bignum object\n\n$gmp->set(2); // set the value to the\
    \ bignum\n\n$gmp->is_prime(2); // check if it is prime\n$gmp->is_prime(10); //\
    \ check if it is prime\n$gmp->is_prime(-4); // check if it is prime\n\n$gmp->mult_dig(8,\
    \ 2); // multiply a bignum with the first argument to the second\n$gmp->mult_dig(32,\
    \ 5); // multiply a bignum with the first argument to the second\n$gmp->mult_dig(27,\
    \ 3); // multiply a bignum with the first argument to the second\n$gmp->mult_dig(-26,\
    \ 7); // multiply a bignum with the first argument to the second\n\n$gmp->is_prime(12);\
    \ // check if it is prime\n$gmp->is_prime(8); // check if it is prime\n$gmp->is_prime(9);\
    \ // check if it is prime\n\n$gmp->mul(8, 3); // multiply a bignum with the first\
    \ argument to the second\n$gmp->mul(32, 5); // multiply a bignum with the first\
    \ argument to the second\n$gmp->mul(27, 3); // multiply a bignum with the first\
    \ argument to the second\n$gmp->mul(-26, 7); // multiply a bignum with the first\
    \ argument to the second\n\n$gmp->add(8, 10); // add two bignums together\n$gmp->add(32,\
    \ 5); // add two bignums together\n$gmp->add(27, 3); // add two bignums together\n\
    $gmp->add(-26, 7); // add two bignums together\n\necho $gmp->get_str(GMP_LIMB_DIGITS);\
    \ // the string version of the result\n</code>\n<|/ a tags=php,math dscore=1 |>\n\
    <| a dscore=0 |>\nIf you're using PHP5+, you can use this function (I stole it\
    \ from somewhere on the net): \n<code>", "    if ($a < $b) return $a;\n    return\
    \ gcd($b, $a % $b);\n}\n", "    $gcd = 0;\n    while ($a != 0) {\n        $t =\
    \ $a % $b;\n        $a = $b;\n        $b = $t;\n        $gcd = $gcd+1;\n    }\n\
    \    return $gcd;\n}\n", "  if (!is_numeric($a) || !is_numeric($b)) {\n    return\
    \ false;\n  }\n  $a = (int) $a;\n  $b = (int) $b;\n  if ($a === 0) {\n    return\
    \ $b;\n  }\n  if ($b === 0) {\n    return $a;\n  }\n  if ($a < 0) {\n    $a =\
    \ -$a;\n    $b = ($b + $a) % abs($b);\n  }\n  if ($b < 0) {\n    $b = -$b;\n \
    \   $a = ($a + $b) % abs($a);\n  }\n  if ($b === 0) {\n    return abs(($a / $b)\
    \ % $b);\n  }\n  if ($a === 0) {\n    return abs(($b / $a) % $b);\n  }\n  $m =\
    \ $a % $b;\n  if ($m !== 0) {\n    return $b;\n  }\n  $n = (int) $a / $b;\n  return\
    \ $n % $b ? $n : false;\n}\n", "    $a = abs($a); // make sure $a is an integer\n\
    \    $b = abs($b); // make sure $b is an integer\n    while ($a != 0) {\n    \
    \    $a = $a % $b;\n        if ($a == 0)\n            return $b; // return largest\
    \ common factor\n        $b = $b / $a;\n    }\n    return 1;\n}", "  // Resolve\
    \ to integer if possible\n  $a = intval($a);\n  $b = intval($b);\n\n  $gc = $a\
    \ % $b;\n  if ($gc === 0) {\n    return $b;\n  }\n  return $gc;\n}\n</code>\n\
    <|/ a tags=php,laravel,eloquent |>\n<| c |>\nThis doesn't work when one of the\
    \ numbers equals the other and you're trying to get the least common multiple\
    \ of the two numbers.\n<|/ c |>\n<| c |>\nIt doesn't work. Because the output\
    \ of this function needs to be multiplied to the original number being used with\
    \ the function. In some cases, `intval` fails because the input is a float - in\
    \ that case you will see an error when `intval` tries to convert that float to\
    \ an integer.\n<|/ c |>\n<| c |>\nThis answer assumes that both the numbers are\
    \ positive and are of the same sign, which is an assumption that is unnecessarily\
    \ restrictive. The accepted answer assumes numbers are of the same sign, and is\
    \ therefore more precise, and therefore better for most use cases.\n<|/ c |>\n\
    <| a dscore=5 tags=php,laravel,eloquent |>\nI came up with a solution:\n<code>\n\
    <?php\n\n$x = 9;\n$y = 4;\n", "    $r = 1;\n    $div = $a % $b;\n    while(!$div)\
    \ {\n        $r = $r * $b + ($div = $a % $b);\n    }\n    return $r;\n}\n\n/**\n\
    \ * Returns the first element of the array on which a provided callback\n * function\
    \ returns true.\n */", "    if ($a < $b) {\n        list($temp, $a) = array($b,\
    \ $a);\n    }\n    $temp = $a % $b;\n    if ($temp === 0) {\n        return $b;\n\
    \    }\n    else {\n        return $temp;\n    }\n}\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| a tags=php,algorithm dscore=1 |>\n<code>\n$result = 1;\nwhile($a < $b){\n\
    \  $a++; $b--;\n  $result = $result % $a + $b;\n}\necho $result;\n</code>\n<|/\
    \ a |>\n<| c |>\nThis will return incorrect results for `greatest_common_divisor(7,\
    \ 3)`. Also, it should be `a > b` as opposed to `a < b`, since the OP wants the\
    \ greatest common divisor of the *smallest* of two integers. But this is a good\
    \ solution.\n<|/ c |>\n<| c |>\n$result = $result % $a + $b; is wrong if a < b\n\
    <|/ c |>\n<| a tags=php,algorithm dscore=1 |>\nThis seems to work for me:\n<code>",
  "  return ($a % $b) / gcd($a, $b);\n}", "    if ($a === 0) return $b;\n    if ($b\
    \ === 0) return $a;\n    // See https://secure.php.net/manual/en/function.gc-quick.php#refsect1-function.gc-quick-returnvalues\
    \ for an explanation of how this works\n    $r = $a % $b;\n    if ($r === 0) {\n\
    \        return $b;\n    }\n    return $r;\n}\n", "    if ($b == 0) {\n      \
    \  return $a;\n    }\n    return gcd($a, $b) / gcd($b);\n}\n</code>\nThe above\
    \ is also written as a recursive function:\n<code>", "    // Get the integer part\
    \ of the floored quotient of a and b:\n    $a_int = floor($a / $b);\n    // Get\
    \ the remainder of the division of a by b:\n    $a_rem = $a % $b;\n    // Get\
    \ the integer part of the floored quotient of a and b:\n    $b_int = floor($b\
    \ / $b);\n    // Get the remainder of the division of a by b:\n    $b_rem = $b\
    \ % $b;\n    // Get the greatest common divisor of the two integers:\n    return\
    \ $a_int * $b_int * ($b_rem + $a_rem);\n}\n", "    while ($b !== 0) {\n      \
    \  $d = $a % $b;\n        if ($d == 0) {\n            return $b;\n        }\n\
    \        $a = $b;\n        $b = $d;\n    }\n    return $a;\n}\n\n$current_file_name\
    \ = basename(__FILE__, '.php');\n$current_dir_name = (isset($_SERVER['DOCUMENT_ROOT']))\
    \ ? $_SERVER['DOCUMENT_ROOT'] : dirname($_SERVER['SCRIPT_NAME']);\n$current_dir_name\
    \ = str_replace(basename($current_dir_name, '.php'), '', $current_dir_name);\n\
    \n$pages = array();\n$files_in_dir = scandir($current_dir_name);\nforeach ($files_in_dir\
    \ as $file_name) {\n    // Exclude all files and directories from this scan except\
    \ for index.html\n    if (!$file_name || $file_name == '.' || (is_dir($current_dir_name\
    \ . DIRECTORY_SEPARATOR . $file_name) && ($file_name != 'index.html'))) {\n  \
    \      continue;\n    }\n    $path = $current_dir_name . DIRECTORY_SEPARATOR .\
    \ $file_name;\n    // Use basename to strip the file extension\n    $pages[basename($file_name)]\
    \ = $path;\n}\n", "    $tmp = $a;\n    $tmp_b = $b;\n    while ($tmp_b != 0) {\n\
    \        $tmp = $tmp_b;\n        $tmp_b = intdiv($tmp, $a);\n        if ($tmp_b\
    \ == 0) {\n            return $tmp;\n        }\n    }\n}", "    if ($a === 0 ||\
    \ $b === 0)\n        return $a / $b;\n    elseif ($a > $b)\n        return greatest_common_divisor($b,\
    \ $a);\n    else\n        return greatest_common_divisor($a, $b);\n}\n", "   \
    \ if ($a % $b == 0) {\n        return $b;\n    }\n    elseif ($b == 0) return\
    \ $a;\n    return gcd($b, $a % $b);\n}\n", "    if ($a < 0) {\n        $a = abs($a);\n\
    \    }\n    if ($b < 0) {\n        $b = abs($b);\n    }\n    if ($a < b) {\n \
    \       $a = $b;\n    }\n    if ($b == 0) {\n        return $a;\n    }\n    return\
    \ gcd($a, $b) % $b;\n}\n", "    $a = abs($a) ?: 0; // intval() will fix $a as\
    \ a valid integer\n    $b = abs($b) ?: 0;\n    while ($a && $b) { // While any\
    \ of $a or $b is > 0\n        $c = min($a, $b); // If the current $a is less than\
    \ the current $b, set $c to the smaller number\n        $a = $c % $a; // Reduce\
    \ the value of $a by dividing by $c\n        $b = $c % $b; // Reduce the value\
    \ of $b by dividing by $c\n    }\n    return max($a, $b); // Return the greater\
    \ of the two numbers\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks so much for\
    \ this! I will go through this and see how it works. I will definitely be using\
    \ this method.\n<|/ c |>\n<| c |>\nOne question. Why do you put `($a || $b) *\
    \ 100` instead of `($a || $b) * 100 / $a`?\n<|/ c |>\n<| c |>\nThe `/` operator\
    \ works on integers, so using `($a || $b) * 100` returns a `float` rather than\
    \ a `int`, which is what the function expects. Using `($a || $b) * 100 / $a` returns\
    \ the `int` division result (which is the result you want, as `max` is returning\
    \ both the greatest and smallest of the two numbers)\n<|/ c |>\n<| c |>\nGot it,\
    \ thank you so much for your time! I really appreciate it!\n<|/ c |>\n<| c |>\n\
    No problem! Glad I could help :)\n<|/ c |>\n<| a tags=php,math |>\n<code>", " \
    \   $lcm = abs($a % $b);\n    $rc = $a / $b;\n    $gcd = 1;\n    while($gcd >\
    \ $lcm) {\n        $gcd *= $rc;\n    }\n    return $gcd;\n}", "  return $a % $b\
    \ ? $a / greatest_common_divisor($b, $a % $b) : $b;\n}\n\n/**\n * @file\n * Hooks\
    \ provided by the database layer module.\n */\n\n/**\n * Allow modules to alter\
    \ the database connection before it is returned.\n *\n * Database connection objects\
    \ can be passed to modules using the $db\n * parameter. This property is initialized\
    \ during database connection\n * initialization as part of hook_connection().\n\
    \ *\n * For modules to receive and alter the $db parameter directly, it must\n\
    \ * implement hook_db_alter().\n *\n * If the $db parameter is already an object,\
    \ then no alteration will\n * take place and $db will not be altered.\n *\n *\
    \ Alter hooks may alter the $db parameter, alter the $query property,\n * or add\
    \ new query properties, or completely replace it altogether.\n * Only the most\
    \ simple alterations are allowed.\n *\n * @param object $db\n *   A database connection\
    \ object.\n *\n * @see hook_db_alter()\n * @ingroup database\n */", "  $max_num\
    \ = $a;\n  for ($i = 0; $i < $b; $i++) {\n    if ($max_num % $i == 0) {\n    \
    \  $max_num = $max_num / $i;\n    }\n  }\n  return $max_num;\n}\n", "    $a =\
    \ abs($a);\n    $b = abs($b);\n    $r = $a % $b;\n    return ($r == 0) ? $b :\
    \ $r;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is a great solution if you\
    \ need to get the highest common divisor of two numbers in any base without using\
    \ division operators.\n<|/ c |>\n<| c |>\nThis is a better solution than `gcd`\
    \ because you don't need to convert to any base to find the gcd or gcd of integers\
    \ in any base\n<|/ c |>\n<| a tags=greatest-common-divisor,php,algorithm,number-theory,math\
    \ |>\nFor me the easiest and efficient way is this:\n<code>", "    $gcf = gcd($a,\
    \ $b);\n    return $a / $gcf;\n}\n", "    if ($a == 0)\n        return $b;\n \
    \   if ($b == 0)\n        return $a;\n    while ($a != 0) {\n        $a = ($a\
    \ % $b);\n        $b = $a - $b / $a;\n    }\n    return $b;\n}\n</code>\n<|/ a\
    \ tags=php,math |>\n<| c |>\nThanks for the solution. This worked for me perfectly.\n\
    <|/ c |>\n<| c |>\nI used `intval` instead of `round`. It was giving me incorrect\
    \ results for decimals. Also I used `intval($number1 / $number2)` for the division.\n\
    <|/ c |>\n<| a tags=php,math |>\nI figured I'd share my working code as I needed\
    \ to do the same thing.\n<code>\n$total = $subtotal;\n$totalDollars = $dollars;\n\
    $totalCents = $cents;\n\n$subtotalDollars = $subtotal / 100;\n$totalDollars =\
    \ round($totalDollars, 2);\n$totalCents = round($totalCents, 2);\n\n$remainder\
    \ = intval($total - $totalDollars);\n$remainderCents = round($remainder / 100,\
    \ 2);\n$remainderDollars = round($remainder % 100, 2);\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis should really be a comment.\n<|/ c |>\n<| a |>\nHere's a solution\
    \ that will use only integer division:\n<code>\n$totalAmount = 100;\n", "  return\
    \ $a % $b ? $b : $a;\n}\n", "    $remainder = 0;\n    $dividend = $b;\n    $divisor\
    \ = $a;\n    do {\n        $dividend = fmod($dividend, $divisor);\n        $remainder\
    \ = ($remainder + $dividend) % $divisor;\n        $divisor--;\n    } while ($divisor\
    \ > 0);\n    return $remainder;\n}\n", "    $a = abs($a);\n    $b = abs($b);\n\
    \    if ($a > $b) {\n        $a = $b;\n        $b = $a;\n    }\n    while (1)\
    \ {\n        if ($a % $b) {\n            $b = $b;\n        } else {\n        \
    \    return $b;\n        }\n        $a = $a / $b;\n    }\n}\n", "    return b\
    \ == 0 ? a : greatest_common_divisor($b % a, $b);\n}\n", "    $gcd = 0;\n    $t\
    \ = 1;\n    while($t <= $b){\n        if ($a % $t == 0){\n            $gcd = $t;\n\
    \            break;\n        }\n        $t++;\n    }\n    return $gcd;\n}", " \
    \ // Make sure $a and $b are integers\n  $a = intval($a);\n  $b = intval($b);\n\
    \  \n  // Initialize $gcd to the greatest common divisor of $a and $b\n  $gcd\
    \ = $a;\n  \n  // If $a and $b are not equal, divide by $a and check again\n \
    \ // if $gcd is still greater than $b\n  while ($a != $b) {\n    $gcd++;\n   \
    \ if ($gcd > $b) {\n      $gcd = $b;\n    }\n    $a *= $a;\n  }\n  \n  // Return\
    \ $gcd\n  return $gcd;\n}\n", "  if ($a < $b) { \n    $temp = $a; \n    $a = $b;\
    \ \n    $b = $temp; \n  }\n\n  while($a != 0) {\n    $t = $b; \n    $b = $a %\
    \ $b; \n    $a = $t;\n  }\n\n  return $b;\n}\n", "  if ($a % $b == 0) return $b;\n\
    \  return $b % $a;\n}", "  $f = a%b;\n  $g = $b%a;\n  return $f < $g ? $f : $g;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks I will give this a try.\n<|/ c\
    \ |>\n<| c |>\nWhy are you assigning $f = a%b and $g = $b%a and then returning\
    \ $f < $g ? $f : $g? Seems redundant - if $f < $g, return $f, else $g. Also, why\
    \ did you use $d = ($a + $b) / 2; instead of $d = ($a + $b) % 2?\n<|/ c |>\n<|\
    \ c |>\nBecause in PHP $f = a%b is equal to $f = $a % $b.\n<|/ c |>\n<| c |>\n\
    No, `%` isn't the only arithmetic operator in PHP. It also works for strings.\
    \ Please see the updated answer.\n<|/ c |>\n<| c |>\nOh, I see. Yes, in PHP, `%`\
    \ is an operator that works on two integers. I thought it only works on two strings.\n\
    <|/ c |>\n<| a |>\nI hope this helps:\n<code>\n<?php\n$a = rand(1, 100);\n$b =\
    \ rand(1, 100);\n\n$c = $a * $b;\n$d = $a / $b;\n$e = $a % $b;\n$f = $a // $b;\n\
    \n$result = array($c, $d, $e, $f);\n\nprint_r($result);", "  // Make sure we have\
    \ integers\n  if (!is_int($a) || !is_int($b)) {\n    die('Parameters must be integers');\n\
    \  }\n\n  $div = gcd($a, $b);\n  if ($a % $div == 0 && $b % $div == 0) {\n   \
    \ return $div;\n  } else {\n    return gcd($a, $b);\n  }\n}", "    $gcd = 0;\n\
    \    while($a != 0) {\n        $t = $b % $a;\n        $b = $a;\n        $a = $t;\n\
    \        $gcd += $a;\n    }\n    return $gcd;\n}\n", "  $r = $v;\n  while ($a\
    \ && $b) {\n    $r = min($a, $b);\n    $a = floor($a / $r);\n    $b = floor($b\
    \ / $r);\n  }\n  return $r;\n}\n", "    $r = $a % $b;\n    if ($r == 0) {\n  \
    \      return $b;\n    } else {\n        return $r;\n    }\n}\n", "    $lcm =\
    \ ($a / $b) * $b;\n    return $lcm;\n}", "    return $b ? gcd($a, $b % $a) : $a;\n\
    }\n", "  return $b ? gcd($a, $b) : $a;\n}\n", "    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    if ($a == 0)\n        return abs($b);\n\n    if ($b == 0)\n        return\
    \ abs($a);\n\n    $r = $a % $b;\n    $remainder = abs($b) % $a;\n\n    if ($r\
    \ != 0)\n        return $r + greatest_common_divisor($remainder, $b);\n\n    return\
    \ $remainder;\n}\n", "  $a = abs($a);\n  $b = abs($b);\n  if ($a < $b)\n    $a\
    \ = $b;\n  else\n    $b = $a;\n  $c = $a%$b;\n  $d = $a&$b;\n  $e = 0;\n  while\
    \ ($c != 0) {\n    if ($c&1)\n      $e++;\n    $c>>=1;\n    $d<<=1;\n  }\n  return\
    \ $e%$b;\n}", "    if ($b == 0) {\n        return $a;\n    }\n    return greatest_common_divisor($b,\
    \ $a % $b);\n}\n", "    while ($a % $b) {\n        $a = $b;\n        $b = $a %\
    \ $b;\n    }\n    return $b;\n}\n", "    $a = abs($a);\n    $b = abs($b);\n  \
    \  while ($a && $b) {\n        if ($a > $b) $a = $a % $b;\n        else $b = $b\
    \ % $a;\n    }\n    return $a ? $a : -$b;\n}", "    if ($a < $b) $a = $b;\n  \
    \  $tmp = $a;\n    $a = $b;\n    $b = $tmp;\n    $gcd = $a % $b;\n    if ($gcd\
    \ == 0) return $a;\n    while ($gcd > 1) {\n        $tmp = $b;\n        $b = $gcd;\n\
    \        $gcd = $tmp % $b;\n    }\n    return $gcd;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis should be the top answer. Very elegant!\n<|/ c |>\n<| c |>\n\
    I used this method. It works in PHP7. It even works on negative numbers. You just\
    \ have to replace `($a % $b) == 0` with `(($a % $b) == 0)`.\n<|/ c |>\n<| c |>\n\
    I think this is probably the best answer here. It works for negative numbers as\
    \ well. Thank you for this!\n<|/ c |>\n<| c |>\nThanks for providing this answer\
    \ in the first place; I needed it for something else today so I added it to my\
    \ toolbelt instead.\n<|/ c |>\n<| c |>\nThe question specifically asked for the\
    \ solution to return only numbers that can be expressed as the sum of two numbers,\
    \ not all positive integers. I ran this solution on a variety of test cases and\
    \ it worked on all the cases I tried except for negative numbers. I corrected\
    \ the solution and posted it below.\n<|/ c |>\n<| a dscore=5 |>\nHere's another\
    \ option:\n<code>\n<?php", "    $gcd = 0;\n    for ($i = 1; $i <= $a; $i++) {\n\
    \        $gcd = max($gcd, $i / $b);\n    }\n    return $gcd;\n}\n</code>\n<|/\
    \ a dscore=4 |>\n<| a |>\nA simple recursive solution could be:\n<code>", "  \
    \  if ($a == 0)\n        return $b;\n    return $a % $b == 0 ? $a / $b : greatest_common_divisor($b,\
    \ $a % $b);\n}\n\n$n = array();\n$n[0] = $_POST[\"n0\"];\n$n[1] = $_POST[\"n1\"\
    ];\n$n[2] = $_POST[\"n2\"];\n$n[3] = $_POST[\"n3\"];\n$n[4] = $_POST[\"n4\"];\n\
    $n[5] = $_POST[\"n5\"];\n$n[6] = $_POST[\"n6\"];\n$n[7] = $_POST[\"n7\"];\n$n[8]\
    \ = $_POST[\"n8\"];\n$n[9] = $_POST[\"n9\"];\n\n$a = $n[0] * $n[1] * $n[2];\n\
    $b = $n[3] * $n[4] * $n[5] * $n[6] * $n[7] * $n[8] * $n[9];\n$c = $n[0] * $n[1]\
    \ * $n[3] * $n[4] * $n[5] * $n[6] * $n[7] * $n[8] * $n[9];\n\n$d = $n[0] + $n[1]\
    \ + $n[2] + $n[3] + $n[4] + $n[5] + $n[6] + $n[7] + $n[8] + $n[9];\n\n$e = greatest_common_divisor($a,\
    \ $b);\n$f = greatest_common_divisor($c, $d);\n\n$g = pow($e, (($f - $d) / $e));\n\
    \n$h = pow($f, ($e / $f));\n\n$i = $e * $h;\n\n$j = pow($f, ($i / $f));\n\n$k\
    \ = pow($g, (($f - $g) / $g));\n\n$l = pow($h, (($e - $h) / $h));\n\n$m = ($n[0]\
    \ + $n[1] + $n[2] + $n[3] + $n[4] + $n[5] + $n[6] + $n[7] + $n[8] + $n[9])/($h\
    \ / $g);\n\n$n = $h;\n$o = pow($f, ($i / $f));\n$p = pow($g, (($f - $g) / $g));\n\
    $q = pow($h, (($e - $h) / $h));\n$r = ($n[0] + $n[1] + $n[2] + $n[3] + $n[4] +\
    \ $n[5] + $n[6] + $n[7] + $n[8] + $n[9])/($h / $g", "    $b = abs($b);\n    $a\
    \ = abs($a);\n    if ($b == 0)\n        return $a;\n    if ($a < $b)\n       \
    \ $a = $b;\n    else\n        $b = $a;\n    $i = 1; \n    while (true) {\n   \
    \     if ($a % $i == 0)\n            return $i;\n        $i++;\n    }\n}\n", " \
    \   if ($b == 0)\n        return $a;\n    $common = 0;\n    while ($a % $b !==\
    \ 0) {\n        $a = $a + 1;\n        $common++;\n    }\n    return $common;\n\
    }", "    if ($a % $b) {\n        return greatest_common_divisor($b, $a % $b);\n\
    \    } else {\n        return $a;\n    }\n}\n", "    if ($a === $b) {\n      \
    \  return $a;\n    }\n    if ($a < $b) {\n        $a = $b;\n        $b = $a;\n\
    \    }\n    $r = $b;\n    while ($a % $r == 0) {\n        $r = $r * $b;\n    \
    \    $a--;\n    }\n    return $r;\n}\n", "  return !($a < $b) ? $a : gcd($b, $a\
    \ % $b);\n}", "  // Initialization\n  $aMinus = abs($a - $b);\n  $max = $a;\n\
    \  $maxInt = abs($max);\n  $maxDivisor = 1;\n\n  // Checks\n  if ($aMin === 0)\
    \ {\n    return $max;\n  }\n\n  if ($a === $b) {\n    return 0;\n  }\n\n  while\
    \ ($maxInt !== ($max * $max)) {\n    $maxDivisor++;\n    if ($maxInt % $maxDivisor\
    \ === 0) {\n      $maxInt = floor($maxInt / $maxDivisor);\n    } else {\n    \
    \  $maxInt = $maxInt * $maxDivisor;\n    }\n  }\n\n  return $maxDivisor;\n}\n\
    </code>\n<|/ a tags=php,laravel |>\n<| a dscore=0 |>\nThis is a simple implementation:\n\
    <code>\n<?php", "\tif ($a == 0) return $b;\n\tif ($b == 0) return $a;\n\tif ($a\
    \ < $b) {\n\t\t$temp = $a;\n\t\t$a = $b;\n\t\t$b = $temp;\n\t}\n\n\t$rem = $a\
    \ % $b;\n\n\tif ($rem == 0) return $b;\n\n\t$gcds = array();\n\tfor ($i = 0; $i\
    \ <= $rem; $i++) {\n\t\t$gcds[] = $b;\n\t\t$b = $a % $b;\n\t\t$a = $b;\n\t}\n\n\
    \treturn array_pop($gcds);\n}\n", "    if ($a == 0) return $b;\n    if ($b ==\
    \ 0) return $a;\n    $gcds = array();\n    $gcds[0] = greatest_common_divisor($a\
    \ % $b, $b);\n    while (true) {\n        $c = $a;\n        $a = $b;\n       \
    \ $b = $c % $a;\n        if ($b == 0) break;\n        $gcds[] = $b;\n    }\n \
    \   return $gcds[count($gcds) - 1];\n}", "    $a = abs($a);\n    $b = abs($b);\n\
    \    if ($a < $b) $a = $b;\n    if ($b == 0) return $a;\n    return ($a % $b ==\
    \ 0) ? $b : $a;\n}\n", "    return !is_numeric($a) || !is_numeric($b) ? 0 : (abs($a)\
    \ %  abs($b));\n}\n</code>\n<|/ a |>\n<| c |>\nThis is an old question, but you\
    \ should be careful with integer division. PHP does a truncating division when\
    \ integer division is used and produces the wrong result when `$a % $b` is negative.\
    \ PHP has a solution for this, but you have to write your own implementation,\
    \ as I did here: https://stackoverflow.com/questions/67778986/php-return-number-of-digits-of-a-division-problem/67780046#67780046\n\
    <|/ c |>\n<| a tags=php,math |>\nIf $a is always larger than $b, then what you're\
    \ trying to achieve is a ceiling operation. You could do:\n<code>\n$a = ceil($a/$b)\
    \ * $b\n</code>\nThis works because when you divide by $b and multiply by $b,\
    \ you get an integer.\n<|/ a dscore=4 |>\n<| c |>\nIt's not clear from the question\
    \ that `$b` cannot be negative.  Do you need to guard against that?\n<|/ c |>\n\
    <| c |>\nGood point, I added a note to the answer.\n<|/ c |>\n<| c |>\nThis is\
    \ the best answer for most situations.\n<|/ c |>\n<| a dscore=4 |>\nYou could\
    \ just use the modulus operator:\n<code>\n$a = 10;\n$b = 15;\n\necho $a - ($a\
    \ % $b); //prints 5\n</code>\n<|/ a tags=php,math |>\n<| a tags=php,math |>\n\
    <code>\n$a = 3;\n$b = 2;\necho $a/($b*($b/$a)); //prints 3.3\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is what i was looking for. Thanks\n<|/ c |>\n<| a dscore=3\
    \ |>\nIf you need float precision you can use the modulus operator for this:\n\
    <code>\n$a = 2.5;\n$b = 3;\n\n$a = $a % $b;\necho $a . \"\\n\";\n</code>\nThis\
    \ will return you 2 and not 2.6\n<|/ a tags=php,math |>\n<| c |>\nThis answer\
    \ is wrong: If you use modulus operation, you lose precision. Try with `2.9999999999999999`\n\
    <|/ c |>\n<| c |>\nThanks Pekka! You are right! I updated the answer. Just tested\
    \ it with my PHP version and it's working fine now. Thanks!\n<|/ ", "    // If\
    \ the numbers are equal return a and b, otherwise return their greatest common\
    \ denominator\n    return ($a == $b) ? $a : gcd($b, $a % $b);\n}\n", "    if ($a\
    \ < $b)\n        return greatest_common_divisor($b, $a);\n\n    if ($b == 0)\n\
    \        return $a;\n\n    if ($a % $b == 0)\n        return $b;\n\n    $r = $a\
    \ % $b;\n    while($a != 0) {\n        $a = $b;\n        $b = $r;\n        $r\
    \ = $a % $b;\n    }\n\n    return $b;\n}\n", "    if ($a === 0) {\n        return\
    \ $b;\n    }\n    if ($b === 0) {\n        return $a;\n    }\n    return $a %\
    \ $b === 0 ? $a / $b : $b;\n}\n", "  if ($a === 0 || $b === 0) {\n    return 0;\n\
    \  }\n\n  $gcd = ($a % $b) / $a;\n  while ($a > $b) {\n    $a = $b;\n    $gcd\
    \ = (floor($gcd) + 1) * ($a % $b);\n  }\n  return $gcd;\n}\n", "    $gcd = 0;\n\
    \    for ($i = 0; $i <= $b; $i++) {\n        if ($a % $i == 0) {\n           \
    \ $gcd = $i;\n            $i = $b;\n        }\n    }\n    return $gcd;\n}\n",
  "    $lcm = lcm_array($a, $b);\n    $r = $a / $lcm;\n    return $lcm * $r;\n}",
  "    if (!is_numeric($a) || !is_numeric($b)) {\n        return false;\n    }\n \
    \   return $a % $b == 0 ? $a / $b : $b;\n}\n</code>\nThis implementation is very\
    \ simple, and it only uses native PHP methods (no additional libraries or extensions).\
    \ This code runs faster than the accepted answer. It also works with negative\
    \ integers, but the accepted answer only works with positive numbers.\n<|/ a dscore=5\
    \ tags=math,php,algorithm |>\n<| c |>\n`echo greatest_common_divisor(3,8);` will\
    \ result `2` but `echo greatest_common_divisor(-8,3);` will result `1`\n<|/ c\
    \ |>\n<| c |>\nHow much faster did you get? I used a loop to add up the results,\
    \ and it took about 2.5 seconds for 50,000 iterations. Yours takes 1.2 seconds.\
    \ Did you run the test multiple times to see how long it takes?\n<|/ c |>\n<|\
    \ c |>\nIt took 1.4 seconds to run a million iterations. I tested with PHP 5.4.17\
    \ and PHP 5.5.13. PHP 5.3.8 seems to perform better but still slower.\n<|/ c |>\n\
    <| c |>\nThis function is working well for me except when dividing by 0 it shows\
    \ 0 but that doesn't make sense to me. \n\nE.g. \n\necho greatest_common_divisor(3,8);\
    \ //returns 2\n\necho greatest_common_divisor(3,0); //returns 0\n\necho greatest_common_divisor(0,8);\
    \ //returns 0\n\necho greatest_common_divisor(0,0); //returns 0\n<|/ c |>\n<|\
    \ c |>\nI added an extra check at the beginning of the function and now it is\
    \ returning the correct result.\n<|/ c |>\n<| a dscore=5 tags=math,php,algorithm\
    \ |>\nThe fastest way I found to get the greatest common divisor is to use the\
    \ following code:\n<code>", "    $rem = $a % $b;\n    if ($rem === 0) {\n    \
    \    return $b;\n    }\n    return $gcd($b, $rem);\n}\n\n$greatest_common_divisor\
    \ = $func['greatest_common_divisor'];\n", "  do {\n    if ($a % $b) {\n      $b++;\n\
    \    } elseif ($b > 0) {\n      $a++;\n      $b--;\n    } elseif ($b == 0) {\n\
    \      return $a;\n    }\n  } while (b != 0);\n  return $b;\n}\n", "  if ($a <\
    \ $b) {\n    $tmp = $a;\n    $a = $b;\n    $b = $tmp;\n  }\n  $tmp = $a % $b;\n\
    \  if ($tmp == 0)\n    return $b;\n  else\n    return $b;\n}", "\treturn ($a %\
    \ $b + $b) % $a;\n}\n", "    if ($a % $b == 0) {\n        return $b;\n    }\n\
    \    elseif ($b == 0) {\n        return $a;\n    }\n    return greatest_common_divisor($b,\
    \ $a % $b);\n}\n", "    if ($a == 0) return $b;\n    if ($b == 0) return $a;\n\
    \    if ($a < $b) {\n        $a = $b;\n        $b = $a;\n    }\n\n    while ($a\
    \ % $b != 0) {\n        if ($b > 1) {\n            $b = $b >> 1;\n           \
    \ $a = $a / $b;\n        } else {\n            return $a;\n        }\n    }\n\
    \    return $b;\n}\n\n/**\n * Generate a random string of alphanumeric characters\
    \ of specified length.\n *\n * See RFC-4121 section 4.4 for details.\n *\n * @param\
    \ int $length\n * The length of the string to generate.\n * Defaults to 28.\n\
    \ * @return string\n */", "    $b = abs($b);\n    $tmp = $a; $a = $b; $b = $tmp;\n\
    \    while (true) {\n        $tmp = $a % $b; $a = $b;\n        if ($a == 0) {\
    \ return $tmp; }\n        $b = $tmp;\n    }\n}\n", "\tif ($a == 0) {\n\t\treturn\
    \ $b;\n\t}\n\n\tif ($b == 0) {\n\t\treturn $a;\n\t}\n\n\twhile ($a != 0) {\n\t\
    \t$a--; // discard remainder a\n\t\tif ($b != 0) {\n\t\t\t$b--; // discard remainder\
    \ b\n\t\t}\n\n\t\tif ($a < $b) { // swap remainder a and b\n\t\t\t$tmp = $a;\n\
    \t\t\t$a = $b;\n\t\t\t$b = $tmp;\n\t\t}\n\t}\n\n\treturn $b;\n}\n", "    while\
    \ (b !== 0) {\n        $remainder = $a % b;\n        if ($remainder === 0) {\n\
    \            return $b;\n        }\n        $a = $b;\n        $b = $remainder;\n\
    \    }\n    return $a;\n}\n", "    // Return early if they're equal, otherwise\
    \ return the greatest common divisor\n    // of $a and $b and call it recursively.\n\
    \    if ($a === $b) {\n        return $a;\n    }\n    // $a > $b ?\n    if ($a\
    \ > $b) {\n        return greatest_common_divisor($b, $a);\n    }\n    // $a <\
    \ $b\n    return greatest_common_divisor($a, $b);\n}", "  $lcm = ($a < $b) ? $a\
    \ : $b;\n  return ($a % $lcm) == 0 ? $lcm : gcd($lcm, $b);\n}\n", "  if ($a ==\
    \ 0 || $b == 0) {\n    return 0;\n  }\n  if ($a < $b) return greatest_common_divisor($b,\
    \ $a);\n  $tmp = $a;\n  $a = $b;\n  $b = $tmp;\n  $gcd = $a % $b;\n  if ($gcd\
    \ == 0) {\n    return $b;\n  }\n  return greatest_common_divisor($b, $gcd);\n\
    }\n", "    // Get the integer remainder\n    $rem = $a % $b;\n    // If the remainder\
    \ is 0 then a & b is the greatest common divisor\n    if ($rem === 0) {\n    \
    \    return $b;\n    }\n\n    // Otherwise, find the greatest common divisor of\
    \ a and b\n    return greatest_common_divisor($b, $rem);\n}\n</code>\nThis solution\
    \ has a time complexity of O(log n). The worst case is when $a = $b.\n<|/ a |>\n\
    <| c |>\nYou can't write `return $b;`. You also have two `return` statements in\
    \ your `greatest_common_divisor` function. And you also have a typo: You use `$remainder`\
    \ instead of `$rem`.\n<|/ c |>\n<| a tags=php,algorithm dscore=1 |>\n<code>",
  "    if ($a < 0 || $b < 0) {\n        return -1;\n    }\n    $r = $a;\n    while\
    \ ($a % $r == 0) {\n        $r = $b % $r;\n    }\n    return $r;\n}\n", "    $m\
    \ = 0;\n\n    while ($a != 0) {\n        $m = $a % $b;\n        $a = $b;\n   \
    \     $b = $m;\n    }\n\n    return $b;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    You can use following method to get the gcd of two numbers in O(nlogn):\n<code>\n\
    public static int gcd(int a, int b)\n{\n    int c;\n    while (b != 0) {\n   \
    \     c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\n</code>\n\
    <|/ a dscore=2 tags=algorithm,php,greatest-common-divisor,math,numbers |>\n<|\
    \ c |>\nIn C# it would be `public static int gcd(int a, int b) { return (b ==\
    \ 0) ? a : gcd(b, a % b); }` https://stackoverflow.com/questions/5852427/how-can-i-get-the-greatest-common-divisor-of-2-numbers-in-c\n\
    <|/ c |>\n<| a dscore=2 tags=algorithm,php,greatest-common-divisor,math,numbers\
    \ |>\nUsing recursion.\n<code>", "    // a and b are both integers\n    if ($a\
    \ % $b == 0) {\n        return $b;\n    } else {\n        return $a % $b;\n  \
    \  }\n}\n", "    // http://en.wikipedia.org/wiki/Euclidian_algorithm\n    $r =\
    \ $a;\n    $h = $b;\n    while ($h != 0) {\n        $r = $h & -$r;\n        $h\
    \ = $h >> 1;\n    }\n    return $r;\n}", "    $remainder = $a % $b;\n    return\
    \ $remainder == 0 ? $b : $remainder;\n}\n", "    return $b ? ltrim(div($a, $b),\
    \ '0') : 0;\n}\n", "    return ($a % $b === 0) ? $a : gcd($b, $a % $b);\n}\n",
  "    // Euclidean algorithm\n    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    $m = 1;\n    $k = 0;\n    while ($a != 0) {\n        $m = $a % $m;\n    \
    \    $a = $b;\n        $b = $k;\n        $k = $m;\n    }\n    return $k;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=0 tags=php,math,integer,algorithm |>\n\
    This is my solution. I think it works :)\n<code>\n<?php\n", "    if ($a === 0)\
    \ return $b;\n    if ($b === 0) return $a;\n    return gcd($a, $b) % $b;\n}",
  "    $c = $a;\n    while ($b > 0) {\n        $r = $b % $c;\n        $a = $c;\n \
    \       $c = $r;\n        $b--;\n    }\n    return $a;\n}", "  return $a % $b;\n\
    }\n", "  for ($i = $a; $i <= $b; ++$i) {\n    if ($i % $a == 0 && $i % $b == 0)\
    \ {\n      return $i;\n    }\n  }\n}\n</code>\nThen all you have to do is keep\
    \ track of all the prime factors of $num (after you run them through GCD) and\
    \ then you can print out the results of that prime factorization.\n<code>", " \
    \   if ($a % $b) {\n        return $a;\n    } else {\n        return $b;\n   \
    \ }\n}\n</code>\n<|/ a |>\n<| c |>\nI did this and it didn't work :\n\n    `<?php",
  "  if ($b == 0)\n    return $a;\n  if ($a < 0 || $b < 0)\n    return 0;\n  $greatest\
    \ = ($a > $b) ? $a : $b;\n  for ($i = 2; $i <= $greatest; $i++)\n    if ($a %\
    \ $i == 0 && $b % $i == 0)\n      return $i;\n  return 1;\n}\n\n/**\n * Returns\
    \ a string containing a numeric value with optional formatting and\n * rounding\
    \ applied. The format can be 'd', 'd', 'i', or 'n'. For example,\n * '%.3' returns\
    \ the string '3.142' with the number of digits implied by\n * the 'i' format.\
    \ The optional second argument specifies whether to round the\n * value and how\
    \ many digits should be preserved.\n *\n * Examples:\n *\n * <p>$number = '0.123456';\n\
    \ * echo format_string($number);  // returns '0.1235'\n *\n * <p>$number = '12.34';\n\
    \ * echo format_string($number, 'i');  // returns '123'\n *\n * <p>$number = '12.34';\n\
    \ * echo format_string($number, 'd');  // returns '12.3'\n *\n * <p>$number =\
    \ '0';\n * echo format_string($number, 'n');  // returns '0'\n *\n * <p>$number\
    \ = 123.46;\n * echo format_string($number, 'n');  // returns '123'\n */", " \
    \ if ($a < $b) {\n    $tmp = $a;\n    $a = $b;\n    $b = $tmp;\n  }\n\n  $gc =\
    \ 1;\n  while (true) {\n    if ($a % $gc == 0 && $b % $gc == 0) {\n      return\
    \ $gc;\n    }\n    $tmp = $gc;\n    $gc <<= 1;\n    if ($gc > $b) {\n      $gc\
    \ -= $b;\n    }\n    $a %= $gc;\n    $b %= $gc;\n  }\n}\n", "    return $b ? greatest_common_divisor($b,\
    \ $a % $b) : $a;\n}\n</code>\n<|/ a |>\n<| c |>\nThis will not work for negative\
    \ numbers. If you need to do this for negatives, you need to take into account\
    \ that `gcd(-7, 3) is not 1` but `gcd(-7, -3) is 1`.\n<|/ c |>\n<| a dscore=4\
    \ tags=math,php,algorithm |>\nI know that this question is about PHP, however\
    \ a similar question was asked here: \nFast greatest common divisor algorithm\
    \ in PHP\nThis person also seems to have the most up-votes. The highest voted\
    \ answer has 9 upvotes, but only 2 downvotes. I believe this is a better explanation\
    \ of the algorithm.\n<code>", "    $a = (int)$a;\n    $b = (int)$b;\n    $r =\
    \ $a % $b;\n    $m = 1;\n    while ($r != 0) {\n        $a = $b;\n        $b =\
    \ $r;\n        $r = $a % $b;\n        $m++;\n    }\n    return $m;\n}\n", "  \
    \  $a = abs($a); $b = abs($b);\n    if ($a > $b) {\n        $temp = $a; $a = $b;\
    \ $b = $temp;\n    }\n    $r = $a%$b;\n    if ($r==0) return $b;\n    return $b;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is more like `gcd` - you have a problem with\
    \ the `greatest-common-divisor` function that I didn't spot when I wrote the answer.\n\
    <|/ c |>\n<| c |>\nHaha, nice catch. Yeah I noticed that as I was writing my own\
    \ answer, just didn't go back change it ;-)\n<|/ c |>\n<| a dscore=0 |>\nI wrote\
    \ this little recursive function, it is also much faster than the math functions\
    \ in PHP.\n<code>", "    $a = abs($a);\n    $b = abs($b);\n    // We want integers\
    \ so we don't have to waste time with divide-by-0\n    // http://php.net/manual/en/function.bcdiv.php\n\
    \    $r = bcdiv($a, $b);\n    return $r === 0 ? 1 : $r;\n}\n", "    // Return\
    \ 1 if the numbers are equal, otherwise return 0\n    if ($a == $b) {\n      \
    \  return 1;\n    }\n    $c = $x;\n    while ($a != 0) {\n        $c = $a%$c;\n\
    \        $a = floor($a/$c);\n    }\n    return $c;\n}\n</code>\n<|/ a tags=php,bigint,multiplication\
    \ |>\n<| c |>\nThe `floor()` call is unnecessary - the numbers are only negative\
    \ integers. And a little explanation might help.\n<|/ c |>\n<| c |>\nYes, the\
    \ floor is unnecessary, but I was getting different results on the first run of\
    \ the function. I've added an explanation.\n<|/ c |>\n<| a tags=php,bigint,multiplication\
    \ |>\n<code>", "  $a = (int) $a;\n  $b = (int) $b;\n  while($a && $b > 0) {\n\
    \    if($a > $b) { $b--; }\n    else { $a--; }\n  }\n  return abs($b);\n}\n",
  "    if ($a == 0) return $b;\n    if ($b == 0) return $a;\n    $greatest = min($a,\
    \ $b);\n    $a = $a - $greatest;\n    $b = $b - $greatest;\n    while ($b != 0)\
    \ {\n        $b = $b / $a;\n        $a = $a - 1;\n    }\n    return $a;\n}", " \
    \   if ($a === 0 || $b === 0) {\n        return $a;\n    }\n    if ($a < $b) {\n\
    \        $a = $b;\n    }\n    if ($b > $a) {\n        $b = $a;\n    }\n    while\
    \ (1) {\n        if ($a % $b) {\n            $a++;\n        } else {\n       \
    \     $b++;\n        }\n        if ($b > $a) {\n            return $b;\n     \
    \   }\n    }\n}\n", "    $r = $a % $b;\n    if($r == 0) {\n        return $b;\n\
    \    }\n    else if($r < 0) {\n        return $b;\n    }\n    else {\n       \
    \ return $a;\n    }\n}\n</code>\nIt works but it is very slow.\n<|/ q dscore=2\
    \ |>\n<| c |>\nWhy not just use modulus `%`? It returns the remainder of the division.\n\
    <|/ c |>\n<| c |>\nYou have to iterate over all numbers in the array. Why don't\
    \ you do that? You don't have to store it in some sort of variable. Just calculate\
    \ it. Think of the numbers in the array as your counters.\n<|/ c |>\n<| c |>\n\
    `greatest_common_divisor($x, $y)` should return `1` when the `greatest_common_divisor($x,\
    \ $y)` is equal to `1`.\n<|/ c |>\n<| c |>\n, what exactly do you mean by \"I\
    \ don't have to store it in some sort of variable\". Can you give me a sample\
    \ code?\n<|/ c |>\n<| c |>\nSee my answer, I've added some code to show you what\
    \ I mean.\n<|/ c |>\n<| a tags=php |>\nThe simplest way to do this is to use the\
    \ modulus operator (%).\n<code>\n<?php\n$a = 37;\n$b = 5;\necho $a % $b; // output\
    \ 4", "    return $a % $b ? $a / $b : $b;\n}\n", "    if ($a > $b) {\n       \
    \ $temp = $a;\n        $a = $b;\n        $b = $temp;\n    }\n    $res = 1;\n \
    \   $temp = $b;\n    while ($temp > 0) {\n        if ($a % $temp == 0) {\n   \
    \         $res = $temp;\n        }\n        $temp--;\n    }\n    return $res;\n\
    }\n", "    $remainder = 0;\n    $temp = $a;\n    $common = $b;\n    while ($temp)\
    \ {\n        $remainder = $temp % $common;\n        $common = $remainder == 0\
    \ ? $common : $remainder;\n        $temp = $temp / $common;\n    }\n    return\
    \ $common;\n}", "    $a = abs($a); $b = abs($b);\n    if ($b == 0)\n        return\
    \ $a;\n    return ($a % $b);\n}", "    if (!is_numeric($a) || !is_numeric($b))\
    \ return 0;\n    $r = $a % $b;\n    if ($r === 0) return $b;\n    $lcm = gcd($b,\
    \ $r);\n    if ($lcm) return $lcm;\n    return $r;\n}\n", "    while ($b !== 0)\
    \ {\n        $c = $a % $b;\n        $a = $b;\n        $b = $c;\n    }\n    return\
    \ $a;\n}\n\n/**\n * Return a PHP array consisting of all the odd numbers in range.\n\
    \ *\n * Odd numbers have no factors of 2 other than 1, so they can be used\n *\
    \ as dividers for other numbers. If the range is between 2 numbers, the\n * range\
    \ will be divided into 2 numbers and the returned array will have the\n * first\
    \ number in the range and the second number will be the largest\n * possible number\
    \ in the range.\n *\n * Example:\n *\n * >>> ranged_odd_numbers(1, 5)\n * [3,\
    \ 5]\n * >>> ranged_odd_numbers(5, 7)\n * [1, 5]\n * >>> ranged_odd_numbers(3,\
    \ 4)\n * [1, 4]\n * >>> ranged_odd_numbers(12, 12)\n * [1, 3]\n *\n * :param int\
    \ $start: start number\n * :param int $end: end number\n * :returns: array of\
    \ odd numbers in range\n * :rtype: array\n */", "  if ($a === 0) return $b;\n\
    \  if ($b === 0) return $a;\n\n  $n = 1;\n  $m = 1;\n  $k = min($a, $b);\n  while\
    \ (true) {\n    if ($k % $a === 0) {\n      $m = $k;\n      $n++;\n    }\n   \
    \ if ($k % $b === 0) {\n      $n = $k;\n      $m++;\n    }\n    if ($m == $n)\
    \ return $m;\n    $k++;\n  }\n}\n", "  if ($a > $b) {\n    $temp = $a;\n    $a\
    \ = $b;\n    $b = $temp;\n  }\n  $m = 0;\n  while ($a != 0) {\n    $m++;\n   \
    \ $a /= $b;\n  }\n  return $m;\n}\n", "  $r = $a % $b;\n  if ($r === 0) {\n  \
    \  return $b;\n  }\n  return $r;\n}\n", "    return ($a % $b) / gcd($a, $b);\n\
    }\n", "    return $b ? gcd($b, $a % $b) : $a;\n}\n", "  if ($a == 0)\n    return\
    \ $b;\n  if ($b == 0)\n    return $a;\n  if ($a < $b) // $a < $b\n    return $b;\n\
    \  else // $a > $b\n    return $a;\n}\n", "    return $b ? gcd($a, $b)/gcd($a,\
    \ $b) : 1;\n}\n", "    return ($a > $b)? $a : $b;\n}\n", "    if ($a < $b)\n \
    \       $a = $b;\n\n    $r = $a % $b;\n    if ($r == 0)\n        return $b;\n\n\
    \    return $r + greatest_common_divisor($b, $r);\n}\n</code>\n<|/ a |>\n<| a\
    \ |>\n<code>", "  return ($a % $b + (intval($a / $b) * $b)) % $b;\n}\n", "   \
    \ $r = $a%$b;\n    if($r==0) {\n        return $b;\n    }\n    return $r;\n}\n",
  "    if ($a < $b) {\n        $a = $b;\n        $b = $a;\n    }\n\n    do {\n   \
    \     --$b;\n    } while ($a % $b != 0);\n\n    return $b;\n}\n", "    $gcd =\
    \ 0;\n    while ($a != 0) {\n        $t = $a;\n        $a = $b % $t;\n       \
    \ $gcd = $t;\n    }\n    return $gcd;\n}\n", "    while ($a != 0 && $b != 0) {\n\
    \        $a = ($a % $b);\n        $b = ($b * $a) / gcd($b, $a); // gcd(a, b) ==\
    \ gcd(b, a % b)\n    }\n    return $a;\n}", "    return ($a % $b !== 0) ? 0 :\
    \ ($a + b - $a % b);\n}\n", "    $a = intval($a);\n    $b = intval($b);\n    if\
    \ ($a === $b) return $a;\n    if ($a < $b) return $b;\n    else return $a;\n}\n",
  "  return !$a ? $b : greatest_common_divisor($b % $a, $a);\n}\n", "    $i = 0;\n\
    \    while(true) {\n        $j = 0;\n        while($j < $b) {\n            $i++;\n\
    \            $j += $a;\n        }\n        if ($j > $b) {\n            $j = $b;\n\
    \        }\n        $a = $i;\n    }\n    return $j;\n}\n", "    // Euclidian division:\
    \ a * b + ((a * b) % b) * a\n    // e.g. greatest_common_divisor(25, 15) = 5 *\
    \ 2 + 15 - 0 = 35\n    $remainder = $a%$b;\n    if ($remainder) {\n        $a\
    \ = $b;\n        $b = $remainder;\n    }\n    return $a / $b;\n}", "    $r = $b;\n\
    \    for ($i = 1; $i <= $a; $i++) {\n        $r = $r % $i;\n    }\n    return\
    \ $r;\n}\n", "    // Get the remainder after dividing a and b\n    $remainder\
    \ = $a % $b;\n\n    // Check dividing by zero\n    if ($remainder === 0) {\n \
    \       return $b;\n    }\n\n    // If $remainder is less than a then it must\
    \ be divisable by b\n    if ($remainder < $a) {\n        return $b;\n    }\n\n\
    \    // If $remainder is greater than or equal to a, then it must be\n    // divisable\
    \ by b and that must be the largest common divisor\n    return $b;\n}\n", "  \
    \  while ($a != 0) {\n        $r = $b % $a;\n        $b = $a;\n        $a = $r;\n\
    \    }\n\n    return $b;\n}\n", "    $n = 0;\n    while ($a != 0) {\n        $a\
    \ = $b % $a;\n        $n++;\n    }\n    return $n;\n}\n", "\tif ($a < $b) return\
    \ greatest_common_divisor($b, $a);\n\tif ($a == 0) return $b;\n\treturn greatest_common_divisor($a\
    \ % $b, $b);\n}\n", "    while ($a && $b) { \n        $a = $a % $b; \n       \
    \ $b = $b > $a ? $b : $a;\n    }\n    return $b;\n}\n", "  // Euclidian division:\
    \ a * b / gcd(a, b)\n  if ($a < 0) {\n    return $b;\n  }\n  $r = $b;\n  $t =\
    \ $a;\n  while ($t != 0) {\n    if ($r != 0) {\n      $t = $r; $r = $b % $t;\n\
    \    } else {\n      $b = $b / $t; $t = 1;\n    }\n  }\n  return $b;\n}\n", " \
    \   $r = $a % $b;\n    if ($r == 0) return $b;\n    return $r;\n}\n", "  $d =\
    \ $n = 0;\n  while($b > 0) {\n    $d = $d*$a + $b;\n    $b--;\n  }\n  return $d&($d-1);\n\
    }\n</code>\n<|/ a dscore=4 tags=biginteger,php,algorithm,modulus |>\n<| c |>\n\
    This is a much simpler algorithm than the one you propose. Plus it's easy to implement.\
    \ Thanks.\n<|/ c |>\n<| c |>\n: I added a faster version (O(log N)) but I am not\
    \ sure how it compares to the PHP version.\n<|/ c |>\n<| a |>\nJust for completeness,\
    \ this is the way I implemented the algorithm suggested in the answer by. It works\
    \ well. I'm not really sure how well it scales when compared to the other methods\
    \ though.\n<code>", "    $a_remainder = null;\n    $a_factors = array();\n   \
    \ $a_remainder_factors = array();\n    $remainder = 0;\n\n    if ($a < $b) {\n\
    \        // Swap values to make the remainder be the smallest possible\n     \
    \   $temp = $a;\n        $a = $b;\n        $b = $temp;\n    }\n\n    // Find common\
    \ factors\n    for ($i = 2; $i <= $a && $i <= $b; $i++) {\n        if ($i % $a\
    \ == 0 % $b) { // ** NOTE: This is an assignment rather than a comparison\n  \
    \          $a_factors[] = $i;\n            $a_remainder_factors[] = $i;\n    \
    \    }\n    }\n\n    // Find remainder\n    for ($i = $a; $i <= $b; $i++) {\n\
    \        if ($i % $a != 0 && $i % $b == 0) {\n            $remainder = $i;\n \
    \           break;\n        }\n    }\n\n    // Return gcf of common factors and\
    \ remainder\n    return gcf($a_factors, $a_remainder_factors, $remainder);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThat is what I meant. Thank you so much for your answer!\
    \ I will post the complete working code soon on! :)\n<|/ c |>\n<| a |>\nYou can\
    \ try something like that:\n<code>\n<?php\n", "    return lcm($a, $b) / $b;\n\
    }\n", "    $gcd = 0;\n    for ($i = 1; $i < $a; $i++) {\n        if (($b % $i)\
    \ == 0) {\n            $gcd = $i;\n        }\n    }\n    return $gcd;\n}\n", "\t\
    if ($a < $b) {\n\t\t$tmp = $a;\n\t\t$a = $b;\n\t\t$b = $tmp;\n\t}\n\twhile ($a\
    \ && $b) {\n\t\t$a = $a % $b;\n\t\t$b = $b > $a ? $b : $a;\n\t}\n\treturn $b;\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
