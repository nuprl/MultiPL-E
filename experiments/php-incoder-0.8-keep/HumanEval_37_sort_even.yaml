name: HumanEval_37_sort_even
language: php
prompt: "<?php\n// This function takes a list l and returns a list l' such that\n\
  // l' is identical to l in the odd indicies, while its values at the even indicies\
  \ are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even([1,\
  \ 2, 3])\n// [1, 2, 3]\n// >>> sort_even([5, 6, 3, 4])\n// [3, 6, 5, 4]\nfunction\
  \ sort_even($l) {\n"
tests: "function candidate(...$args) {\n    return sort_even(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 2, 3)) !== array(1, 2, 3)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(5, 3, -5, 2, -3, 3,\
  \ 9, 0, 123, 1, -10)) !== array(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(5, 8, -12, 4, 23,\
  \ 2, 3, 11, 12, -10)) !== array(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10)) { throw new\
  \ Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    for($i = 0; $i < count($l); $i++){\n        if($i % 2 == 0){\n\
    \            $l[$i] = $l[$i];\n        }\n    }\n    for($i = 0; $i < count($l);\
    \ $i++){\n        if($i % 2 == 1){\n            $l[$i] = $l[$i]; // swap values\n\
    \            $temp = $l[$i];\n            $l[$i] = $l[$i - 1];\n            $l[$i\
    \ - 1] = $temp;\n        }\n    }\n    return $l;\n}\n\n$list = get_elements($db,\
    \ \"SELECT * FROM list ORDER BY list_id\");\nprint_r($list);", "    $even = array();\n\
    \    $odd = array();\n    for($i = 0; $i < count($l); $i++)\n    {\n        if($i\
    \ % 2 == 0)\n        {\n            $even[] = $l[$i];\n        }\n        else\n\
    \        {\n            $odd[] = $l[$i];\n        }\n    }\n    for($i = 0; $i\
    \ < count($even); $i++)\n    {\n        $j = 0;\n        while($j < count($odd))\n\
    \        {\n            if($even[$i] == $odd[$j])\n            {\n           \
    \     break;\n            }\n            else\n            {\n               \
    \ $j++;\n            }\n        }\n        unset($odd[$j]);\n        $even[$i]\
    \ = $odd[$i];\n    }\n    return $even;\n}\n", "    // Get l' sorted into even\
    \ indicies\n    $l_sorted = array_merge($l, $l->slice());\n    // Get even-indicies\
    \ of l'\n    $l_inds = array_keys($l_sorted);\n    // Make even-indicies of l\
    \ equal their values\n    $l_sorted[$l_inds[1]] = $l_sorted[$l_inds[0]];\n   \
    \ // Get sorted l'\n    $l_sorted = array_values($l_sorted);\n    // Return l'\
    \ as a list\n    return $l_sorted;\n}", "\t$evens = array_filter($l, function($e)\
    \ {return $e % 2 == 0;});\n\tsort($evens);\n\treturn array_merge($evens, $l);\n\
    }\n", "\t$odd = array_filter($l, function ($i) { return $i % 2 == 0; });\n\treturn\
    \ array_merge($odd, array_intersect_key($l, array_flip($odd)));\n}", "    $even\
    \ = array_slice($l, 0, count($l) / 2);\n    $odd = array_slice($l, count($l) /\
    \ 2, count($l));\n\n    sort($even, SORT_NUMERIC);\n    sort($odd, SORT_NUMERIC);\n\
    \n    return array_merge($even, $odd);\n}\n", "    $l2 = [];\n    $even_index\
    \ = 0;\n    foreach ($l as $item) {\n        if (!isset($l2[$even_index])) {\n\
    \            $l2[$even_index] = $item;\n            $even_index++;\n        }\n\
    \        elseif ($l[$even_index] == $item) {\n            $l2[$even_index] = $item;\n\
    \            $even_index++;\n        } else {\n            $l2[$even_index] =\
    \ $item;\n            $even_index++;\n            $l2[$even_index] = $item;\n\
    \            $even_index++;\n        }\n    }\n    return $l2;\n}\n", "    $newList\
    \ = $l;\n    $count = 0;\n    foreach($newList as $index => $value) {\n      \
    \  if ($index % 2 == 0) {\n            $newList[$count] = $value;\n        }\n\
    \        $count++;\n    }\n    return $newList;\n}", "    if (count($l) % 2 !=\
    \ 0) return $l;\n    foreach ($l as $i => $e) {\n        $even[] = $e; $even[$i]\
    \ = $e; $even[$i] = $e;\n    }\n    asort($even);\n    return $even;\n}", "  $evens\
    \ = array_fill(0, count($l), array());\n  foreach($l as $k => $v) {\n    $evens[$k%2]\
    \ = $v;\n  }\n  return array_merge(array_reverse($evens), $l);\n}\n</code>\n<|/\
    \ a tags=php,arrays |>\n<| a dscore=1 tags=php,arrays |>\nThis one seems to work\
    \ ok.\n<code>\n$arr = [\n    [ 'name' => 'Lol', 'age' => 3 ],\n    [ 'name' =>\
    \ 'Lol2', 'age' => 4 ],\n    [ 'name' => 'Lol3', 'age' => 5 ],\n    [ 'name' =>\
    \ 'Lol4', 'age' => 1 ],\n    [ 'name' => 'Lol5', 'age' => 2 ],\n];\n\n$arr = call_user_func_array('array_merge',\
    \ array_map(function ($a) { return array_reverse($a); }, $arr));\n$arr = call_user_func_array('array_merge',\
    \ $arr);\n$arr = call_user_func_array('array_merge', $arr);\n$arr = call_user_func_array('array_merge',\
    \ $arr);\n\nprint_r($arr);\n</code>\n<|/ a |>\n<| a tags=php,arrays |>\nThis code\
    \ will get rid of even indexes, but will reorder other elements if they exist\
    \ in $l:\n<code>\n$l = array(1, 2, 3, 5, 6, 4, 5, 7, 8, 1, 9, 10, 2, 8, 3, 6,\
    \ 5);\n$even = array();\nforeach ($l as $key => $value) {\n    if ($key % 2 ===\
    \ 0) {\n        $even[] = $value;\n    }\n}\n\n$l = array_merge(array_reverse($l),\
    \ $even);\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n$array = array(\n\
    \    array('name' => 'Lol', 'age' => 3),\n    array('name' => 'Lol2', 'age' =>\
    \ 4),\n    array('name' => 'Lol3', 'age' => 5),\n    array('name' => 'Lol4', 'age'\
    \ => 1),\n    array('name' => 'Lol5', 'age' => 2),\n);\n\n$tempArray = array();\n\
    foreach ($array as $key => $value) {\n    if ($key % 2 === 0)\n        $tempArray[]\
    \ = array_reverse($value);\n}\n$array = array_merge($tempArray, $array);\n</code>\n\
    <|/ a tags=php,arrays |>\n<| a dscore=1 |>\n<code>\n$arr = [\n    array('name'\
    \ => 'Lol', 'age' => 3),\n    array('name' => 'Lol2', 'age' => 4),\n    array('name'\
    \ => 'L", "    $l2 = [];\n    $evens = $odds = [];\n    foreach ($l as $k => $v)\
    \ {\n        $l = $v;\n        if ($k % 2) {\n            $evens[] = $v;\n   \
    \     } else {\n            $odds[] = $v;\n        }\n    }\n    $l2 = array_intersect_key($l,\
    \ array_flip($odds));\n    $l2 = array_values($l2);\n    $l2 = array_merge($evens,\
    \ $l2);\n    return $l2;\n}\n", "\tforeach($l as $key => $value) {\n\t\tif ($key\
    \ % 2 == 0) {\n\t\t\t$l[$key] = $value;\n\t\t}\n\t}\n\tarray_multisort($l, SORT_ASC,\
    \ SORT_NUMERIC);\n\treturn $l;\n}", "    $even = $even = array();\n    foreach\
    \ ($l as $k=>$v)\n        if ($k & 1)\n            $even[$k] = $v;\n        else\n\
    \            $even[$k] = $v;\n    $even = array_merge($even,$even);\n    asort($even);\n\
    \    return $even;\n}", "    $l = array_reverse($l);\n    $evens = array_fill(0,\
    \ count($l)/2, 0);\n    return array_intersect_key($l, array_fill(0, count($l)/2,\
    \ 0), $evens);\n}\n", "    // Copy l into a new array, so that we don't accidentally\
    \ modify l\n    $l1 = $l;\n    for($i = 0; $i < count($l1); $i++) {\n        if($i\
    \ % 2 == 0) {\n            $l1[$i] = $l1[$i];\n        }\n    }\n    for($i =\
    \ 1; $i < count($l1); $i++) {\n        if($l1[$i] == $l1[$i-1]) {\n          \
    \  $l1[$i] = $l1[$i-1];\n        }\n    }\n    return $l1;\n}\n", "    return\
    \ array_filter(\n        array_map('reset', array_map(\n            function($e)\
    \ { return $e%2?$e:$e/2; },\n            array_values($l)\n        )),\n     \
    \   'is_int'\n    );\n}\n</code>\n<|/ a |>\n<| c |>\nI didn't know about the 'key'\
    \ argument, this is awesome! And yeah, I'm aware that there are many ways to solve\
    \ this problem. I'm actually just starting to learn PHP, and I'd like to learn\
    \ more about sorting algorithms and such. Thanks!\n<|/ c |>\n<| c |>\nWhat does\
    \ it mean that `key` is `'is_int'`? Also, why does it matter if `$l` is reversed\
    \ or not? Why isn't `array_reverse` enough?\n<|/ c |>\n<| c |>\nThe `key` argument\
    \ to [`array_map()`](http://php.net/manual/en/function.array-map.php) is a function\
    \ that defines the return value for each element of the resulting array. The `'is_int'`\
    \ argument is a comparison function that defines whether the element of the resulting\
    \ array should be included or excluded in the resulting array. For example, using\
    \ `'is_int'` would include any non-integer values in the resulting array, but\
    \ would exclude any integer values. See the [`is_int` comparison](http://php.net/manual/en/function.is-int.php)\
    \ documentation for more information.\n<|/ c |>\n<| a tags=php,sorting |>\nIf\
    \ all you are looking to do is sort, then use PHP's sort function.\n<code>\n<?php",
  "    return $l[array_search($l[array_search($l, 0.5)], 0.5)]\n}\n</code>\nThe algorithm\
    \ works by finding where in the list the current item is. If it's in the center,\
    \ the second item in the list is the midpoint of the two numbers, otherwise the\
    \ first item is the midpoint of the two numbers. If the current item is in the\
    \ midpoint, then the second item is the midpoint, and otherwise the second item\
    \ is set to the first item. After that, swap the two items as needed.\n<|/ a tags=algorithm,arrays,sorting\
    \ |>\n<| c |>\nThis is so helpful. Thank you!\n<|/ c |>\n<| a tags=algorithm,arrays,sorting\
    \ dscore=1 |>\nFor an odd number of elements, there is always a \"center\" element.\
    \ Let it be the element at index (n/2). There are no swapping necessary between\
    \ any two elements in the center element, n/2, or between the center element and\
    \ the element at the (n+1)th position (n being the number of elements in the array).\n\
    If an odd number of elements is to be sorted, we find the \"center\" element as\
    \ the element at index n/2. \nThe algorithm to sort an odd number of elements\
    \ is:\n<code>\n1. Let the size of the array be n.\n2. Let the left element be\
    \ the first element in the array.\n3. Let the right element be the last element\
    \ in the array.\n4. Find the index of the center element in the array.\n5. Swap\
    \ the center element with the element at the (n+1)th position.\n6. Repeat step\
    \ 4.\n7. Repeat steps 3 & 4 until all elements are sorted.\n</code>\n<|/ a |>\n\
    <| c |>\nThis seems to be the most efficient way of doing it, but I think it can\
    \ be generalized for any odd number of elements :p\n<|/ c |>\n<| a dscore=1 |>\n\
    The most straightforward approach is to find the center element in the array.\
    \ Swap that element with the first or last element, and then iterate the array\
    \ in either direction until it is sorted. Here's some Python code to do that:\n\
    <code>\ndef sort_odd(arr):\n    l = len(arr)\n    if l % 2:\n        print \"\
    array is not odd\"\n        return\n    center = l / 2\n    arr[center], arr[0]\
    \ = arr[0], arr[center]\n    for i in xrange(l / 2 - 1, -1, -1):\n        if arr[i]\
    \ > arr[i + center]:\n            arr[i + center], arr[i] = arr[i], arr[i + center]\n\
    \    for j in xrange(1, l / 2):\n        if arr[j] > arr[j - center]:\n      \
    \      arr[j - center], arr[j] = arr[j], arr[j - center]\n    return arr\n\nprint\
    \ sort_odd([1, 2, 3, 4, 5, 6, 7, ", "  for ($i = 0; $i < count($l); $i += 2) {\n\
    \    if ($l[$i] == $l[$i + 1]) {\n      $l[$i] = $l[$i + 1];\n      $l[$i + 1]\
    \ = $l[$i];\n    }\n  }\n\n  return $l;\n}", "  $even = array();\n  $odd = array();\n\
    \  for ($i = 0; $i < count($l); $i++) {\n    if ($i % 2 == 0) {\n      $even[]\
    \ = $l[$i];\n    } else {\n      $odd[] = $l[$i];\n    }\n  }\n  return $even\
    \ == $odd ? $l : sort($even, TRUE) + sort($odd);\n}", "    foreach (range(0, count($l)-1)\
    \ as $i) {\n        $tmp = $l[$i];\n        $l[$i] = $l[$i+1];\n        $l[$i+1]\
    \ = $tmp;\n    }\n    return $l;\n}\n</code>\nYou can then sort your data as follows:\n\
    <code>", "    $len = $l[0];\n    $res = array();\n    foreach ($l as $value) {\n\
    \        for ($i = 0; $i < $len; $i++) {\n            if ($i%2 != 0) {\n     \
    \           $res[$i] = $value;\n            }\n        }\n    }\n    return $res;\n\
    }\n", "    $n = count($l);\n    $ln = array_fill(0, $n, false);\n    for ($i =\
    \ 0; $i < $n; $i++) {\n        $ln[$i] = true;\n    }\n\n    for ($i = 0; $i <\
    \ $n; $i++) {\n        if (!$ln[$i]) {\n            for ($j = $i + 1; $j < $n;\
    \ $j++) {\n                if ($l[$i] > $l[$j]) {\n                    $t = $l[$j];\n\
    \                    $l[$j] = $l[$i];\n                    $l[$i] = $t;\n    \
    \            }\n            }\n        } else {\n            for ($j = $i + 1;\
    \ $j < $n; $j++) {\n                if ($l[$i] == $l[$j]) {\n                \
    \    continue;\n                } else {\n                    $t = $l[$i];\n \
    \                   $l[$i] = $l[$j];\n                    $l[$j] = $t;\n     \
    \           }\n            }\n        }\n    }\n    return $l;\n}\n</code>\nThis\
    \ code doesn't have the problem mentioned above.  It doesn't use O(n^2) algorithms\
    \ (which I assume you were referring to), and it doesn't have this problem:\n\
    <code>\n<?php\n$a = array(5,1,3,6,7,8,2,4,9,0,6,7,6,3,0,5);\n$b = array();\n$l\
    \ = count($a);\nfor ($i = 0; $i < $l; $i++) {\n    for ($j = $i + 1; $j < $l;\
    \ $j++) {\n        if ($a[$i] == $a[$j]) {\n            continue;\n        } else\
    \ {\n            $b[$i] = $a[$i];\n            $b[$j] = $a[$j];\n        }\n \
    \   }\n}\nprint_r($b);\n</code>\nThis code also uses O(n) algorithms.  It just\
    \ does the sorting in two stages, rather than sorting in O(n*log(n)) time.\nBut\
    \ it has the problem I mentioned earlier: It does a lot of extraneous comparisons,\
    \ making the performance worse than the O(n*log(n)) algorithms.  That is, it is\
    \ less efficient than the O(n^2) algorithms when it has to sort an array with\
    \ about 1,000,000 elements.\n<|/ a |>\n<| c |>\nThank you for your answer.  I\
    \ like your O(n*log(n)) code but I don't see why it is better than the O(n^2)\
    \ code.  Can you please explain why it is better?  I see that your code also does\
    \ a lot of extraneous comparisons (and I suspect that this is why the performance\
    \ is worse than the O(n^2) algorithm), but I don't see how this extraneous comparison\
    \ can make the performance ", "    // Create a copy of the original list\n   \
    \ // The reason this works is that PHP assigns variables by reference\n    //\
    \ and so assigning a value to a variable doesn't make a copy of the variable\n\
    \    // Instead, the variable in memory gets the new value.\n    // See https://php.net/manual/en/language.references.pass.php\
    \ for more information\n    $l = $l;\n    for ($i = 0; $i < count($l); $i+=2)\
    \ {\n        $l[$i] = $l[$i];\n    }\n    // Sort the copy\n    // The sort function\
    \ uses usort, so passing a third parameter tells\n    // it to sort using custom\
    \ comparer\n    sort($l, SORT_NUMERIC);\n    // Return the copy\n    return $l;\n\
    }", "  // Sort the list according to the even indicies\n  $even = array_map(function($i)\
    \ use ($l) {\n    return $l[$i];\n  }, array_filter(range(0, count($l) - 1, 2)));\n\
    \  // Put the odd indicies in the correct order\n  $odd = array_map(function($i)\
    \ use ($l) {\n    return $l[$i];\n  }, array_filter(range(1, count($l) - 1, 2)));\n\
    \  // Merge the two lists together\n  return array_merge($even, $odd);\n}\n</code>\n\
    The reason for using array_map instead of a foreach loop is that array_filter\
    \ requires that we specify a callback that takes a single argument to filter the\
    \ array.  array_map can take a function whose parameter list is exactly the same\
    \ as the array to be filtered, or any number of arrays whose lengths are equal\
    \ to the number of elements to be filtered.  The second option requires that we\
    \ define an anonymous function that takes one argument and applies a callback\
    \ to every element of the array.\n<|/ a tags=sorting,arrays,php dscore=0 |>\n\
    <| a dscore=0 |>\nIf you're happy to do more work in PHP (which you probably should\
    \ be), then the easiest way would be to create a multidimensional array with the\
    \ values ordered according to the odd indicies and then merge it with the even\
    \ indicies:\n<code>", "    $l = array_count_values($l);\n    $l = array_keys($l);\n\
    \    asort($l);\n    return $l;\n}\n", "    $even = array_fill(0, count($l), 0);\n\
    \    $odd = array_fill(0, count($l), 0);\n    for ($i = 0; $i < count($l); $i++)\n\
    \        array_push($even, $l[$i]);\n        for ($j = $i; $j < count($l); $j++)\n\
    \            array_push($odd, $l[$j]);\n    return array_merge($even, array_values($l),\
    \ $odd);\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=2 |>\nFor those who prefer\
    \ an approach that uses no more code than the other answers, here's how I did\
    \ it:\n<code>\n$array = [1, 2, 3];\n$sortedArray = [];\n$newArray = [];\n$evenElements\
    \ = [];\n$oddElements = [];\n\nforeach ($array as $key => $value) {\n    if ($key\
    \ % 2 == 0) {\n        $evenElements[$key] = $value;\n    } else {\n        $oddElements[$key]\
    \ = $value;\n    }\n}\n", "    return array_reduce(array_slice($l, 1), function($a,\
    \ $b) {\n        $a[] = $b;\n        return $a;\n    }, []);\n}\n</code>\nTo apply\
    \ the function, the array_reduce is called. First argument is an array and second\
    \ is callback function. The array_slice removes first element from array. The\
    \ rest is simple for loop over all array elements and push to the new array.\n\
    <|/ a dscore=3 |>\n<| c |>\nIt seems that `array_map()` is more idiomatic than\
    \ `array_reduce()` for this purpose.\n<|/ c |>\n<| a tags=arrays,php,sorting |>\n\
    Here's a solution that uses array_multisort() to sort elements based on their\
    \ original index, and then merges the sorted arrays:\n<code>", "    $l2 = [];\n\
    \    foreach ($l as $k => $v) {\n        $i2 = 0;\n        $v2 = $v;\n       \
    \ while ($i2 < $k && $l2[$i2] == $v2)\n            $i2++;\n        $l2[$i2] =\
    \ $v;\n    }\n    return $l2;\n}\n", "    $l = sort($l);\n    for ($i = 1; $i\
    \ < count($l); $i+=2) {\n        $l[$i-1] = $l[$i];\n    }\n    return $l;\n}\n",
  "    sort($l);\n    $evens = array_filter($l, function($v) { return $v & 1; });\n\
    \    sort($evens);\n    return array_merge($evens, array_slice($l, 0, count($l)\
    \ - count($evens)));\n}\n", "    sort($l);\n    for ($i = count($l) - 2; $i >\
    \ 0; $i -= 2) {\n        if ($l[$i] > $l[$i + 1]) {\n            list($l[$i],\
    \ $l[$i + 1]) = array($l[$i + 1], $l[$i]);\n        }\n    }\n    return $l;\n\
    }\n", "\t$even = array();\n\t$odd = array();\n\t$l = array_values($l);\n\tfor($i\
    \ = 0; $i < count($l); $i += 2) {\n\t\t$odd[] = $l[$i];\n\t\t$even[] = $l[$i+1];\n\
    \t}\n\tarray_multisort($odd, $even, SORT_NUMERIC, $l);\n\treturn $l;\n}\n", " \
    \   $even = [];\n    $odd = [];\n    $evens = $odds = [];\n\n    foreach ($l as\
    \ $k => $v) $k % 2 ? $evens[] = $v : $odds[] = $v;\n\n    $even = array_values($evens);\n\
    \    $odd = array_values($odds);\n\n    $even = array_merge($even, $evens);\n\
    \    $odd = array_merge($odd, $odds);\n\n    return array_merge($even, $odd);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is very efficient, but I am having trouble\
    \ understanding how it works. I think my best guess is that the array_map() call\
    \ is taking the keys of the original array (which are the odd indicies) and is\
    \ reordering them. After the array_map() call, the odd indicies are all reordered\
    \ by the keys of the original array, but after that the array_merge() calls are\
    \ taking both the odd indicies and even indicies from the original array and merging\
    \ them. Does that seem right?\n<|/ c |>\n<| a |>\nHere is another simple solution:\n\
    <code>\n$data = array_combine(array_column($array, 'odd'), $array);\n</code>\n\
    <|/ a tags=arrays,sorting,php dscore=4 |>\n<| a dscore=3 |>\nFor those who want\
    \ to sort the array in ascending order and keep the key with the sorted data,\
    \ here's my solution (also preserves the key): \n<code>\n$myArray = array(\"a\"\
    \ => 1, \"b\" => 2, \"c\" => 3, \"d\" => 4, \"e\" => 5, \"f\" => 6, \"g\" => 7,\
    \ \"h\" => 8);\n\n$myArray = $myArray + $myArray; // appending array\n$myArray\
    \ = array_values($myArray); // reindex array\nsort($myArray);\n", "  $even = [];\n\
    \  $odd = [];\n  foreach ($l as $i => $n) {\n    if ($i % 2 == 0) {\n      $even[]\
    \ = $n;\n    } else {\n      $odd[] = $n;\n    }\n  }\n  return array_merge($even,\
    \ $odd);\n}", "    $rev = array_reverse($l);\n    sort($rev);\n    return $rev;\n\
    }\n", "    $even_index = array_keys($l) % 2;\n    array_splice($l, $even_index);\n\
    \    array_map(function ($val) use ($l, $even_index) {\n        array_splice($l,\
    \ $even_index, 1);\n        $l[$even_index] = $val;\n    }, array_values($l));\n\
    \    return $l;\n}", "    $n = count($l);\n    for ($i = 1;  $i <= $n/2 ; $i++)\
    \ {\n        $j = $i + $i % 2;\n        $tmp = $l[$i];\n        $l[$i] = $l[$j];\n\
    \        $l[$j] = $tmp;\n    }\n    return $l;\n}", "\t$l2 = array();\n\tforeach\
    \ ($l as $i => $e) {\n\t\tif ($i % 2 == 0) {\n\t\t\t$l2[$i] = $e;\n\t\t} else\
    \ {\n\t\t\t$e2=$l[$i];\n\t\t\twhile ($e2 > 0) {\n\t\t\t\t$l2[$i] = $e2;\n\t\t\t\
    \t$e2--;\n\t\t\t}\n\t\t}\n\t}\n\treturn $l2;\n}\n", "    $evens = array();\n \
    \   $odds = array();\n    $size = count($l);\n    for ($i = 0; $i < $size; $i++)\
    \ {\n        if ($i % 2 == 0) {\n            $evens[] = $l[$i];\n        } else\
    \ {\n            $odds[] = $l[$i];\n        }\n    }\n    $result = array();\n\
    \    foreach ($odds as $key => $value) {\n        foreach ($evens as $key2 =>\
    \ $value2) {\n            if ($key == $key2) {\n                $result[$key]\
    \ = $value;\n            }\n        }\n    }\n    return $result;\n}\n", "   \
    \ $evens = array_filter($l, function($e) {\n        return $e % 2 === 0;\n   \
    \ });\n    sort($evens);\n    return array_merge($evens, $l);\n}\n", "  $sorted\
    \ = [];\n  for ($i = 0, $len = count($l); $i < $len; ++$i) {\n    if ($i % 2 ==\
    \ 0) {\n      // Even\n      $sorted[] = $l[$i];\n    }\n  }\n  return $sorted;\n\
    }\n\n/**\n * Sorts the even indicies of a list of integers.\n */", "  sort($l);\n\
    \  $even = [];\n  foreach ($l as $key => $val) {\n    if (($key & 1) == 0) {\n\
    \      $even[$key] = $val;\n    }\n  }\n  $even = array_values($even);\n  return\
    \ $even;\n}\n</code>\nThis would require only a single array sort, while retaining\
    \ the even numbers.  You could extend this to a single function as follows:\n\
    <code>", "    $evens = array_filter($l, function($x) {\n        return $x & 1;\
    \ // odd\n    });\n    $odd = array_filter($l, function($x) {\n        return\
    \ !($x & 1); // even\n    });\n    return array_merge($odd, $evens);\n}\n", " \
    \ sort($l);\n  $even = array_slice($l, 0, count($l)-1);\n  $odd = $l;\n  $even[$even[0]]\
    \ = $even[0];\n  return array_merge($even, $odd);\n}\n", "\t$even = array_fill(0,\
    \ count($l), 0);\n\tforeach ($l as $i => $val)\n\t\t$even[$i]++;\n\treturn array_merge(\n\
    \t\tarray_slice($l, $even[0]),\n\t\tarray_slice($l, 0, $even[0]),\n\t\tarray_slice($l,\
    \ $even[1])\n\t);\n}\n\n/*\n * Return a random value from the supplied array,\
    \ or a default\n * value if the supplied array is empty.\n */", "    return array_combine(array_slice($l,\
    \ 0, count($l) / 2, true), array_slice($l, count($l) / 2, count($l), true));\n\
    }\n", "    return array_merge(\n        array_chunk($l, ceil(count($l) / 2)),\
    \ // split l into two chunks\n        array_chunk(array_reverse($l), ceil(count($l)\
    \ / 2))  // split l into two chunks\n    );\n}\n", "  $result = array();\n  $sorted\
    \ = array();\n\n  foreach ($l as $key => $value) {\n    $sorted[$key] = $value;\n\
    \  }\n\n  ksort($sorted);\n\n  for ($i = 0; $i < count($l); $i += 2) {\n    $result[]\
    \ = $sorted[$i];\n  }\n\n  return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nI forgot\
    \ to mention that the resulting array should be the same length as the input list,\
    \ if possible.\n<|/ c |>\n<| c |>\n: That was not a requirement in the question.\
    \ I've updated the answer now.\n<|/ c |>\n<| a dscore=1 |>\nTo do this, you first\
    \ need to know which array is longer, the length of the array before you start\
    \ the counting.\n<code>\n$a = array(1,2,3,4,5,6);\n$b = array(1,2,3,4,5,7,8,9,0);\n\
    \n$maxA = count($a)-count($b);\n$maxB = count($b)-count($a);\n</code>\nThen you\
    \ need to loop through each of the arrays and check if they match up and then\
    \ merge them\n<code>\nwhile($i < $maxA && $j < $maxB)\n{\n    if($a[$i] == $b[$j])\n\
    \    {\n        $i++;\n        $j++;\n    }\n    else\n    {\n        $result[]\
    \ = $a[$i];\n        $i++;\n    }\n}\nwhile($i < $maxA)\n{\n    $result[] = $a[$i];\n\
    \    $i++;\n}\nwhile($j < $maxB)\n{\n    $result[] = $b[$j];\n    $j++;\n}\n</code>\n\
    <|/ a tags=php,arrays |>\n<| c |>\nthis would also work and is probably the simplest\
    \ solution. +1 for the loop condition\n<|/ c |>\n<| a dscore=1 tags=php,arrays\
    \ |>\nI would do this:\n<code>", "  $l2 = array();\n  for ($i = 0; $i < count($l);\
    \ $i++) {\n    $even = array();\n    for ($j = 1; $j < count($l); $j += 2) {\n\
    \      $even[] = $l[$j];\n    }\n    $l2[] = array_shift($even);\n  }\n  return\
    \ $l2;\n}\n</code>\nApart from the performance costs related to array_shift()\
    \ you can also use this function with any number of dimensions.  For example,\
    \ the following will sort a list of 3 dimensions with an even number of dimensions.\n\
    <code>\n$l = [\n   [\n      ['d','a','c','b'],\n      ['c','b','d','a'],\n   \
    \   ['e','a','f','c'],\n   ],\n   [\n      ['a','b','c','d'],\n      ['a','c','b','e'],\n\
    \      ['a','b','c','d'],\n   ],\n   [\n      ['d','e','f','c'],\n      ['d','e','f','c'],\n\
    \      ['d','e','f','c'],\n   ],\n];\n\n$l = sort_even($l);\n\nprint_r($l);\n\
    </code>\noutput\n<code>\nArray\n(\n    [0] => Array\n        (\n            [0]\
    \ => d\n            [1] => a\n            [2] => c\n            [3] => b\n   \
    \     )\n\n    [1] => Array\n        (\n            [0] => a\n            [1]\
    \ => b\n            [2] => c\n            [3] => d\n        )\n\n    [2] => Array\n\
    \        (\n            [0] => d\n            [1] => e\n            [2] => f\n\
    \            [3] => c\n        )\n\n)\n</code>\n<|/ a |>\n<| a |>\n<code>\n<?php\n\
    \n$array = array(\n    'first' => array(\n        'a' => 'b',\n        'c' =>\
    \ 'd',\n    ),\n    'second' => array(\n        'c' => 'd',\n        'e' => 'f',\n\
    \        'd' => 'h',\n        'a' => 'g',\n    ),\n);\n\n$result = array();\n\
    foreach($array as $key => $val){\n    if(isset($val['a']) && isset($val['c'])\
    \ && isset($val['e'])){\n        $result[$key]['a'] = $val['a'];\n        $result[$key]['c']\
    \ = $val['c'];\n        $result[$key]['e'] = $val['e'];\n    }\n    if(isset($val['a'])\
    \ && isset($val['c'])){\n        $result[$key]['a'] = $val", "    $sorted = [];\n\
    \    $even = []; // the even values of this list will be sorted\n    foreach ($l\
    \ as $i) {\n        if ($i % 2 == 0) {\n            $sorted[] = $i;\n        }\
    \ else {\n            $even[] = $i;\n        }\n    }\n    return array_merge($even,\
    \ $sorted);\n}", "    foreach($l as $k => $v) {\n        $l[$k] = $v % 2;\n  \
    \  }\n    ksort($l);\n    return array_values($l);\n}\n", "\t\n\tif (count($l)\
    \ == 0) return $l;\n\t\n\t$l2 = array();\n\t\n\t// Create an array l2 where all\
    \ the values of l are in even indicies\n\t// of the new list\n\tfor ($i=0; $i<count($l);\
    \ $i+=2)\n\t\t$l2[] = $l[$i];\n\t\n\t// Add elements of l to l2 in even indicies\
    \ until all elements are in even indicies\n\tfor ($i=1; $i<count($l); $i++) {\n\
    \t\t$l2[] = $l[$i];\n\t\tif ($i == count($l)) break;\n\t}\n\t\n\treturn $l2;\n\
    }\n", "    $result = [];\n    $even_index = 0;\n    $odd_index = 0;\n    foreach\
    \ ($l as $k => $v) {\n        if ($even_count < $odd_count) {\n            $result[$k]\
    \ = $v;\n            $even_index++;\n        } else if ($even_count == $odd_count)\
    \ {\n            $result[$k] = $l[$even_count];\n            $odd_index++;\n \
    \       }\n        $even_count++;\n    }\n    return $result;\n}", "  // sort\
    \ only odd indicies\n  for ($i = 1; $i < count($l); $i += 2)\n    $l[$i] = $l[$i\
    \ - 1];\n  return $l;\n}\n\n/**\n * Sorts an array according to the values in\
    \ another array,\n * without modifying the original array.\n */", "    if (count($l)\
    \ % 2 == 0) {\n        $l[count($l)/2] = $l[count($l)/2] .', ' .$l[count($l)/2];\n\
    \        $l = array_slice($l,0,count($l)/2);\n    }\n    return $l;\n}", "   \
    \ $even = array_filter($l, function($i) { return $i & 1; }); // get an array of\
    \ all even indicies\n    $odd = array_filter($l, function($i) { return $i & 1;\
    \ }); // get an array of all odd indicies\n    array_multisort($odd, SORT_ASC,\
    \ SORT_NUMERIC, $even, SORT_NUMERIC, $l);\n    return $l;\n}\n", "  $l = array_reverse($l,\
    \ 1);\n  $l[$l % 2] = $l[$l % 2];\n  $l = array_reverse($l, 1);\n  return $l;\n\
    }\n", "    if ($l == NULL || count($l) < 2) return $l;\n    $evens = array();\n\
    \    $odds = array();\n    for ($i = 0; $i < count($l); $i++) {\n        if ($i\
    \ % 2 == 0) {\n            $evens[] = $l[$i];\n        } else {\n            $odds[]\
    \ = $l[$i];\n        }\n    }\n    sort($evens);\n    sort($odds);\n    $evens[count($evens)\
    \ - 1] = $odds[count($odds) - 1];\n    return array_merge($evens, $odds);\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=php |>\nIf you want a pure PHP solution,\
    \ and don't want a recursive function or a while loop, you can do something like\
    \ this:\n<code>\n$list = array(1, 2, 3);\n$newList = array();\nforeach ($list\
    \ as $key => $value) {\n    if($key % 2 == 0)\n        $newList[$key] = $value;\n\
    \    else\n        $newList[count($newList) - 1] = $value;\n}\nprint_r($newList);\n\
    </code>\nAnd this is probably the simplest and most efficient way to do it.\n\
    <|/ a dscore=1 |>\n<| a tags=php dscore=0 |>\nIf you can use array_multisort,\
    \ here's an example for you to try:\n<code>\n<?php\n$list1 = array(1, 5, 2, 6,\
    \ 3, 7);\n$list2 = array(3, 5, 7, 4, 6);\narray_multisort($list1, SORT_NUMERIC,\
    \ $list2);\nprint_r($list1);\nprint_r($list2);", "\tfor ($i = 0; $i < count($l);\
    \ $i+=2) {\n\t\t$temp = array_merge($l[$i], $l[$i+1]);\n\t\tarray_splice($l, $i,\
    \ 2, $temp);\n\t}\n\treturn $l;\n}", "\t$lsize = count($l);\n\t$even = $lsize\
    \ % 2;\n\t$even_ind = $even ? range($lsize/2, $lsize, 2) : range($lsize/2, $lsize-1,\
    \ 2);\n\t$even_l = [];\n\tfor ($i = 0; $i < $lsize; $i++) {\n\t\t$even_l[$i] =\
    \ $l[$even_ind[$i]];\n\t}\n\tsort($even_l);\n\tforeach ($even_ind as $i) {\n\t\
    \t$l[$i] = $even_l[$i];\n\t}\n\treturn $l;\n}\n", "    $even = array_slice($l,\
    \ 0, count($l) / 2);\n    $odd = array_slice($l, count($l) / 2, count($l));\n\
    \    return array_merge($even, $odd);\n}\n", "    $sorted = array_reverse($l);\n\
    \    for ($i = 0; $i < count($sorted); $i += 2) {\n        $sorted[$i] = $sorted[$i\
    \ + 1];\n    }\n    return $sorted;\n}\n", "  sort($l);\n  for($i = 1; $i < count($l);\
    \ $i++) {\n    if($i % 2 == 0) {\n      if($l[$i-1] == $l[$i]) {\n        $l[$i-1]++;\n\
    \      }\n      else {\n        $l[$i] = $l[$i-1];\n        $l[$i-1] = $l[$i];\n\
    \      }\n    }\n  }\n  return $l;\n}\n", "    $ln = count($l);\n    foreach ($l\
    \ as $k => $v) {\n        if ($k % 2 == 0) {\n            $tmp = $l[$k];\n   \
    \         $l[$k] = $l[$k -1];\n            $l[$k -1] = $tmp;\n        }\n    }\n\
    \    return $l;\n}", "  // First sort the list by its values\n  $even = array();\n\
    \  for ($i = 0; $i < count($l); $i += 2) {\n    $even[$i] = $l[$i];\n  }\n\n \
    \ // Then sort the lists by the odd indicies\n  sort($even);\n\n  // Return new\
    \ list\n  return $even;\n}\n", "    sort($l);\n    for ($i = 1; $i < count($l);\
    \ $i += 2) {\n        $l[$i-1] = $l[$i];\n    }\n    return $l;\n}\n", "    return\
    \ rsort($l, function ($x, $y) {\n        if ($x % 2 == 0) {\n            if ($y\
    \ % 2 == 0) {\n                return 0;\n            }\n            return -1;\n\
    \        }\n        if ($y % 2 == 0) {\n            return 1;\n        }\n   \
    \     return 0;\n    });\n}\n</code>\n<|/ a |>\n<| c |>\nI actually was going\
    \ to vote this down for lack of explanation, but then I realized it could potentially\
    \ be useful to someone else who wants to sort a list in PHP. Thanks!\n<|/ c |>\n\
    <| c |>\nI was about to ask the same question. Thanks!\n<|/ c |>\n<| c |>\nHow\
    \ does this sort an array?\n<|/ c |>\n<| a tags=php,sorting |>\n<code>\nclass\
    \ mySort {\n\n    private $a;\n\n    public function __construct($a){\n      \
    \  $this->a = $a;\n    }\n\n    public function cmp($a, $b) {\n        return\
    \ $a<=$b ? -1 :1;\n    }\n\n}\n\n$list = new mySort($array);\nusort($list, 'cmp');\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't sort a php array but rather\
    \ a php object array.\n<|/ c |>\n<| a tags=php,sorting |>\n<code>\n$input = array(\
    \ 'a','b','c','d','e','f','g','h' );\n$input = array('z','y','x','w','v','u','t','s','r','q','p','o','n','m','l','k','j','i','h','g','f','e','d','c','b','a');\n\
    usort($input, \"strcmp\");\nprint_r($input);\n</code>\n<|/ a dscore=4 |>\n<| a\
    \ dscore=4 |>\n<code>\n$list = array('2', '7', '9', '5', '2', '6', '5', '8', '4',\
    \ '4', '1', '8', '7', '6', '9', '7', '5', '3', '4', '2', '9', '7', '8', '9', '5',\
    \ '6', '4', '1', '7', '7', '8', '3', '5', '5', '3', '9', '2', '6', '5', '5', '1',\
    \ '7', '3', '6', '9', '5', '7', '5', '7', '8', '2', '8', '8', '4', '4', '4', '5',\
    \ '8', '7', '8', '7', '5', '1', '8', '9', '2', '1', '4', '7', '1', '2', '3', '9',\
    \ '8', '4', '5', '5', '8', '1', '3', '5', '4', '5', '4', '2', '3', '3', '5', '1',\
    \ '", "  $l = array_reverse($l);\n  for ($i = 0; $i < count($l); $i += 2) {\n\
    \    $l[$i] = $l[$i];\n  }\n  return $l;\n}\n", "    $lt = array_count_values($l);\n\
    \    $lt = $lt[0];\n    array_push($l, $lt);\n    return $l;\n}\n", "    $l =\
    \ array_reverse($l);\n    $evens = array_fill(0, count($l), true);\n    for ($i\
    \ = 0, $c = count($l); $i < $c; $i += 2) {\n        $evens[$i] = $l[$i];\n   \
    \ }\n    return array_merge(array_flip($evens), $l);\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ |>\n<| c |>\nThis is very nice and simple. Easy to understand too. Thanks.\n\
    <|/ c |>\n<| a tags=php,arrays,sorting dscore=1 |>\nOne solution using array_reverse:\n\
    <code>\n$l = array(1,2,3,4,5);\n\n$l2 = array_reverse($l);\nfor($i=0;$i<count($l);$i+=2)\n\
    {\n    $l2[$i] = $l[$i];\n}\n$l2 = array_merge($l2,$l);\n$l2 = array_reverse($l2);\n\
    </code>\n<|/ a |>\n<| a tags=php,arrays,sorting |>\nI prefer array_chunk to do\
    \ this as it is much faster than other methods. I have had to make a function\
    \ because I needed the array to be re-indexed.\n<code>", "  return array_merge($l,\
    \ array_slice($l, 0, count($l) / 2));\n}\n", "  $l1 = array_fill(0, count($l),\
    \ 0);\n  $l2 = array_fill(0, count($l), 0);\n  foreach($l as $v) {\n    if($v\
    \ & 1)\n      $l1[$v] = $v;\n    else\n      $l2[$v] = $v;\n  }\n  return array_merge(array_intersect_key($l1,\
    \ $l2), array_diff_key($l2, $l1));\n}\n", "    $even = [];\n    $odd = [];\n \
    \   foreach ($l as $key => $val) {\n        if (!$key % 2) {\n            $even[]\
    \ = $val;\n        } else {\n            $odd[] = $val;\n        }\n    }\n  \
    \  return array_merge($even, $odd);\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    Here's a version that doesn't require a separate array to sort, but instead uses\
    \ a function for the comparison (I chose to use the function cmp, which is a comparison\
    \ function in PHP):\n<code>", "    $result = [];\n    $even = 0;\n    $odd = 0;\n\
    \    foreach ($l as $e) {\n        if ($e % 2 == 0) {\n            $even = $e;\n\
    \        }\n        else {\n            $odd = $e;\n        }\n        $result[$even]\
    \ = $e;\n        $result[$odd] = $e;\n    }\n    return $result;\n}", "    return\
    \ array_combine(range(0,count($l)-1), $l);\n}\n", "  $l2 = [];\n  for ($i = 0;\
    \ $i < count($l); $i += 2) {\n    $l2[] = $l[$i];\n  }\n  return $l2;\n}", " \
    \   $lsize = count($l);\n    for ($i=0; $i < $lsize; $i+=2) {\n        $l[$i]\
    \ = $l[$i];\n    }\n    sort($l);\n    for ($i=1; $i < $lsize; $i+=2) {\n    \
    \    $l[$i] = $l[$i];\n    }\n    return $l;\n}\n", "    $even = $odd = array();\n\
    \    foreach ($l as $index => $value) {\n        $even[$index] = $value;\n   \
    \ }\n    array_walk($even, function (&$value) use ($even, &$odd) {\n        $value\
    \ = $value;\n        $value = $even[$value];\n        $value = $odd = $odd[$value];\n\
    \    });\n    return $even;\n}", "  $l = array_reverse($l);\n  for ($i = 0; $i\
    \ < count($l); $i += 2) {\n    $l[$i] = $l[$i + 1];\n  }\n  return $l;\n}", " \
    \   $sorted = $l;\n    for ($i = 1; $i < count($l); $i++) {\n        if ($i %\
    \ 2 != 0) {\n            $sorted[$i] = $l[$i];\n        } else {\n           \
    \ for ($j = $i; $j > 0; $j--) {\n                if ($l[$j] < $sorted[$j - 1])\
    \ {\n                    $sorted[$j] = $sorted[$j - 1];\n                    break;\n\
    \                }\n            }\n            $sorted[$j] = $l[$j];\n       \
    \ }\n    }\n    return $sorted;\n}\n", "  $even = array();\n  $odd = $l;\n  for\
    \ ($i=0; $i < count($l); $i++) {\n    if ($i % 2 == 0) {\n      $even[] = $l[$i];\n\
    \    } else {\n      $odd[] = $l[$i];\n    }\n  }\n  return array_merge($odd,\
    \ $even);\n}", "  return array_map(function ($e) {\n    return $e % 2 ? $e : $e\
    \ + 1;\n  }, array_values($l));\n}\n", "    list($even, $odd) = array_chunk($l,\
    \ 2, true);\n    return array_merge($even, $odd);\n}\n", "  $even_index = array_filter($l,\
    \ function ($e) { return !($e % 2); });\n  foreach ($even_index as $i => $e) {\n\
    \    $even_index[$i] = $e;\n  }\n  array_multisort($even_index, 0, count($even_index),\
    \ SORT_DESC, $l);\n  return $l;\n}\n", "\tsort($l, SORT_NUMERIC);\n\t$even = array_fill(0,\
    \ count($l), $l[0]);\n\t$l = array_map(function ($i) use ($even) {\n\t\treturn\
    \ $even[$i];\n\t}, $l);\n\treturn $l;\n}\n", "    $even = [];\n    $odd = [];\n\
    \    foreach ($l as $key => $val) {\n        if ($key % 2 == 0) {\n          \
    \  $even[$key] = $val;\n        } else {\n            $odd[$key] = $val;\n   \
    \     }\n    }\n    return $even = array_merge($even, $odd);\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you for providing this.  I really appreciate the example!\n\
    <|/ c |>\n<| a tags=sorting,php |>\nFor php 7.1 you can use the new array_walk\
    \ function\n<code>\narray_walk($items, function(&$v, $k, $s) use ($sortBy) {\n\
    \    $v = $sortBy($v);\n});\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,php\
    \ |>\nAs of PHP 8.0, you can use the array sort function and pass a callback as\
    \ the first parameter:\n<code>\narray_sort($items, function($a, $b) {\n    return\
    \ $a['order'] - $b['order'];\n});\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    The array_walk is great when you only have 1 element to sort by, but when you\
    \ have multiple elements to sort by you need to reorganize your array:\n<code>\n\
    $input = array(\n    array(\n        'name'=> 'Bob',\n        'order'=> 1\n  \
    \  ),\n    array(\n        'name'=> 'Sue',\n        'order'=> 2\n    ),\n    array(\n\
    \        'name'=> 'John',\n        'order'=> 3\n    ),\n    array(\n        'name'=>\
    \ 'Susan',\n        'order'=> 4\n    )\n);\n", "    return $l;\n}", "    foreach\
    \ ($l as &$element) {\n        if ($element % 2 === 0) {\n            $evens =\
    \ $element;\n            $element = $evens;\n        }\n    }\n    return $l;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNice! But in PHP 5.4 there is a bug, doesn't\
    \ it?\n<|/ c |>\n<| a tags=sorting,php |>\n<code>\n<?php", "  return array_intersect_key($l,\
    \ array_flip($l))\n}", "    $even_indexes = [];\n    $odd_indexes = [];\n    foreach\
    \ ($l as $index => $value) {\n        if ($index % 2 == 0) {\n            $even_indexes[]\
    \ = $value;\n        } else {\n            $odd_indexes[] = $value;\n        }\n\
    \    }\n    return $even_indexes\n         + $odd_indexes\n         + sort(array_combine($odd_indexes,\
    \ $even_indexes));\n}\n", "    $llen = count($l);\n    $even = array_chunk($l,\
    \ 2);\n    $odd = $even[0];\n    $even = array_pop($even);\n\n    foreach ($even\
    \ as $key => $value) {\n        if ($key % 2 === 0) {\n            foreach ($odd\
    \ as $key2 => $value2) {\n                $odd[$key2] = $value2;\n           \
    \ }\n        } else {\n            foreach ($even as $key2 => $value2) {\n   \
    \             $even[$key2] = $value2;\n            }\n        }\n    }\n\n   \
    \ return array_merge($even, $odd);\n}\n", "  foreach($l as $index => $val) {\n\
    \    if ($index % 2 == 0) {\n      $l[$index] = $val;\n    }\n  }\n  sort($l);\n\
    \  return $l;\n}\n", "    list($even, $odd) = partition($l);\n    list($even)\
    \ = sort_even($even);\n    list($odd) = sort_even($odd);\n    return array_merge($even,\
    \ $odd);\n}", "    $even = $odd = $l;\n    // iterate over the even indicies and\
    \ copy them into the odd indicies.\n    for ($i = 0; $i < count($even); $i +=\
    \ 2) {\n        $odd[$i] = $even[$i];\n    }\n    // sort odd indicies\n    asort($odd);\n\
    \    // merge odd indicies and even indicies into a single list.\n    $l = array_merge(array_slice($even,\
    \ 0), $odd);\n    return $l;\n}\n", "\t$l = $l;\n\t$odd = array_keys($l, 1); //\
    \ get odd indicies of l\n\tfor ($i = 0, $j = count($l); $i < $j; $i++) {\n\t\t\
    if ($i%2==1) {\n\t\t\t$l[$i] = $l[$odd[$i]];\n\t\t} else {\n\t\t\t$l[$i] = $l[$odd[$i]];\n\
    \t\t}\n\t}\n\treturn $l;\n}\n", "  // If the list has only one element, return\
    \ that element.\n  if (count($l) == 1) return $l;\n  // If the list has an even\
    \ number of elements, return the list in the odd indices.\n  $evens = array_intersect_key($l,\
    \ array_fill(0, count($l), false));\n  // For each even, sort its values from\
    \ low->high.\n  foreach ($evens as $key => $value) {\n    $evens[$key] = array_keys($l,\
    \ $value);\n  }\n  return $evens;\n}", "    $even = $l = array_fill(0, count($l),\
    \ 0);\n    foreach ($l as $i => $e) {\n        $l[$i] = $e;\n        $l[$even[$i]]\
    \ = $e;\n    }\n    return $l;\n}", "  // make a copy of l\n  $l2 = $l;\n  sort($l2);\n\
    \  $even = array();\n  foreach ($l2 as $k => $v) {\n    // if we have an even\
    \ number in l2, add its value to the even positions of l\n    if ($k % 2 == 0)\
    \ {\n      $even[] = $v;\n    }\n  }\n  // copy the even positions of l2 into\
    \ l\n  for ($i = 0; $i < count($l2); $i++) {\n    if ($i % 2 == 0) {\n      $l[]\
    \ = $l2[$i];\n    }\n  }\n  return $l;\n}\n", "    $ls = array_merge($l, $l);\n\
    \    $ls[array_search($l[$l % 2], $ls)] = $l[$l % 2];\n    return $ls;\n}\n",
  "\tsort($l);\n\tfor ($i = 0; $i < count($l); $i += 2) {\n\t\t$l[$i] = $l[$i + 1];\n\
    \t}\n\treturn $l;\n}\n", "  return array_intersect_key($l, array_flip(range(1,\
    \ count($l), 2)));\n}\n", "    return array_merge(\n        array_slice($l, 0,\
    \ ceil(count($l) / 2)), // take the first half\n        array_map(function($i)\
    \ { return $l[$i]; }, // map to the second half by index\n            array_keys($l))\
    \ // get the even indices\n    );\n}\n", "    // The even indices of the list\
    \ l.\n    // The list l is modified in place.\n    $even = array();\n    foreach\
    \ ($l as $i => $item) {\n        if ($i % 2) {\n            $even[] = $item;\n\
    \        }\n    }\n\n    // Sort even. Notice that we are passing $l by reference.\n\
    \    // See http://php.net/manual/en/function.sort.php\n    sort($even);\n\n \
    \   // Merge evens.\n    // Notice that we pass in $even by reference, since sort()\
    \ sorts the list in-place.\n    // See http://php.net/manual/en/function.sort.php\n\
    \    foreach ($even as &$e) {\n        $e = array_shift($l);\n    }\n\n    //\
    \ Merge odds.\n    sort($l, SORT_NUMERIC);\n\n    return $l;\n}\n</code>\nThis\
    \ solution has a complexity of O(n*log(n)), which is not bad at all.\n<|/ a tags=sorting,algorithm,php\
    \ |>\n<| a dscore=0 tags=sorting,algorithm,php |>\nThe best answer that I found\
    \ was from here : https://stackoverflow.com/a/47704076/4480613\nThe idea is to\
    \ store two arrays. The first array stores the original order, the second array\
    \ stores the ordered array.\n<code>", "    $l2 = array_map(function($value){\n\
    \        return $value % 2 == 0 ? $value : $value % 2 == 1 ? $value + 1 : $value\
    \ + 2;\n    }, $l);\n    sort($l2);\n    return $l2;\n}\n", "  $l = array_map('intval',\
    \ $l);\n  if ($l[0] === $l[1]) {\n    sort($l, SORT_NUMERIC);\n  }\n  return $l;\n\
    }\n", "    $even = array_fill(0, count($l), FALSE);\n    foreach ($l as $i =>\
    \ $e) {\n        if ($i % 2 === 0) {\n            $even[$i] = $e;\n        }\n\
    \    }\n    return array_values($even);\n}\n\n/**\n * Sorts the list by the value\
    \ of the element.\n *\n * Sorts the list by the value of the element, with the\
    \ even indices sorted\n * to the end, and the odd indices sorted in-place. For\
    \ example,\n * sort_by('a', 'a') would sort the list by 'a' in the odd indices,\
    \ and by 'a'\n * in the even indices. However, since 'a' has odd indices, the\
    \ even indices \n * are swapped with themselves to get that effect. For example:\n\
    \ * >>> sort_by('a', 'b')\n * [('a', 5), ('b', 1)]\n * >>> sort_by('a', 'a')\n\
    \ * [('a', 1), ('b', 5)]\n *\n * >>> sort_by('a', 'a'), sort_by('a', 'b')\n *\
    \ [('a', 1), ('b', 5)]\n * [('a', 5), ('b', 1)]\n *\n * sort_by can take a list\
    \ of elements as well as strings.\n *\n * Note that if a key in the second list\
    \ does not map to a value in the\n * first list, the value will simply be copied\
    \ to the second list.\n *\n * Examples:\n * >>> sort_by('abc', [1, 5, 2])\n *\
    \ [(2, 1), ('c', 5), (3, 2)]\n * >>> sort_by('abc', 'abcd')\n * [('a', 5), ('b',\
    \ 2), ('c', 5), (3, 'd')]\n *\n * Note that sort_by is destructive. The list passed\
    \ in is modified\n * by reference. If you need to preserve the original list,\
    \ make a copy.\n *\n * @param $list\n *   The list to sort.\n * @param $key\n\
    \ *   A string or array of strings to sort by.\n * @return array\n *   A sorted\
    \ list of $list as returned by array_sort.\n */", "    foreach ($l as $key1 =>\
    \ $value1) {\n        for ($key2 = 0; $key2 < $key1; $key2++) {\n            if\
    \ ($key2 % 2 == 0) {\n                $l[$key2] = $l[$key1];\n            }\n\
    \        }\n    }\n    return $l;\n}\n\n/**\n * Compares two lists while keeping\
    \ the keys and values in the same order.\n * @return list\n */", "  return array_intersect_key($l,\
    \ array_flip(range(1, count($l), 2)))\n}\n", "\t$l2 = [];\n\tforeach ($l as $k\
    \ => $v) {\n\t\tif ($k % 2) {\n\t\t\t$l2[$k] = $v;\n\t\t} else {\n\t\t\t$i = $k;\n\
    \t\t\twhile ($i > 0) {\n\t\t\t\t$i -= 2;\n\t\t\t\tif ($l[$i] < $l[$i + 1]) {\n\
    \t\t\t\t\t$l2[$i + 1] = $l[$i + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ $l2;\n}\n", "\t$even = array_slice($l, 0, count($l) / 2);\n\t$odd = array_slice($l,\
    \ count($l) / 2);\n\n\tarray_multisort($even, $odd);\n\n\treturn $even;\n}\n",
  "\tsort($l, SORT_NUMERIC);\n\tfor ($i = 0, $n = count($l) - 1; $i < $n; $i = $i\
    \ + 2) {\n\t\t$l[$i] = $l[$i + 1];\n\t}\n\treturn $l;\n}\n", "  $even = array_slice($l,\
    \ 0, -1);\n  sort($even);\n  $even = array_merge($even, $l);\n  return $even;\n\
    }", "  $even = array_slice($l, 0, count($l)/2);\n  $odd = array_slice($l, count($l)/2);\n\
    \  sort($even);\n  sort($odd);\n  return array_merge($even, $odd);\n}\n", "  \
    \  return array_merge(\n        array_intersect_key(\n            array_flip($l),\
    \ \n            array_flip(array_filter(range(1, count($l), 2)))\n        ), \n\
    \        $l\n    );\n}\n</code>\nNote that this uses the array_filter trick to\
    \ get the even indicies of each value in l; it then flips the even indicies and\
    \ adds them to the array.  In the end, the even indicies are in the same order\
    \ as the original array, and then the array is flipped again so that all the odd\
    \ indicies are the odd indicies.\n<|/ a tags=arrays,php,sorting,multidimensional-array\
    \ dscore=1 |>\n<| a |>\nHere is a simple solution for you:\n<code>\n<?php\n\n\
    $arr = array();\n$arr[0] = 'a';\n$arr[1] = 'b';\n$arr[2] = 'c';\n$arr[3] = 'd';\n\
    $arr[4] = 'e';\n\n$even_keys = array_keys($arr);\n\nforeach($arr as $key=>$val){\n\
    \    if($key % 2 != 0){\n        $arr[$key] = $arr[$even_keys[$key]];\n    }\n\
    }\n\nprint_r($arr);\n</code>\n<|/ a tags=arrays,php,sorting,multidimensional-array\
    \ dscore=0 |>\n<| a tags=arrays,php,sorting,multidimensional-array |>\n<code>\n\
    $arr = array();\n$arr[0] = 'a';\n$arr[1] = 'b';\n$arr[2] = 'c';\n$arr[3] = 'd';\n\
    $arr[4] = 'e';\n", "  for ($i = 0; $i < count($l); $i += 2) {\n    $l[$i] = $l[$i];\n\
    \  }\n  return $l;\n}", "  $even = array();\n  foreach ($l as $k => $v) {\n  \
    \  if ($k%2 == 0) {\n      $even[$k] = $v;\n    }\n  }\n  $even = array_intersect_key($even,\
    \ $l);\n  ksort($even);\n  return $even;\n}\n", "  $even = array_fill(0, count($l),\
    \ 0);\n  $odd = array_fill(0, count($l), 1);\n  for ($i = 0; $i < count($l); $i\
    \ += 2) {\n    $even[$i] += $l[$i];\n    $odd[$i] += $l[$i + 1];\n  }\n  return\
    \ array_combine(array_keys($even), $odd);\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nYou seem to have written this in PHP by mistake, right? :)\n<|/ c |>\n<|\
    \ c |>\nSorry, I copied it from the PHP documentation, so I actually wrote it\
    \ while I was in the middle of writing a PHP question. :)\n<|/ c |>\n<| a |>\n\
    <code>", "  $even = array();\n  $odd = array();\n  foreach ($l as $i => $v) {\n\
    \    if ($i % 2 == 0) {\n      $even[] = $v;\n    } else {\n      $odd[] = $v;\n\
    \    }\n  }\n  $even = array_merge($even, $odd);\n  sort($even);\n  return $even;\n\
    }", "    $even = array_fill(0, count($l), 0);\n    $odd = array_fill(0, count($l),\
    \ 0);\n    for ($i = 0; $i < count($l); $i++) {\n        if ($i % 2 == 0) {\n\
    \            $even[$i] = $l[$i];\n        } else {\n            $odd[$i] = $l[$i];\n\
    \        }\n    }\n    sort($even);\n    sort($odd);\n    return $even + $odd;\n\
    }", "    sort($l, SORT_NUMERIC);\n    return array_intersect_key($l, array_flip(range(0,\
    \ count($l) - 1, 2)));\n}", "\tsort($l);\n\tfor ($i = 1; $i < count($l); $i +=\
    \ 2) {\n\t\t$l[$i - 1] = $l[$i];\n\t}\n\treturn $l;\n}\n", "  $lcopy = array_filter($l,\
    \ function($el) {\n    return $el % 2 == 0;\n  });\n  sort($lcopy);\n  $even =\
    \ [];\n  for ($i = 0; $i < count($l); $i++) {\n    if ($i % 2 == 0) {\n      $even[]\
    \ = $l[$i];\n    }\n  }\n  return array_merge($even, $lcopy);\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=merge,php,sorting,arrays |>\nI wrote a little function\
    \ to merge arrays of different lengths together.\n<code>", "  if (count($l) ===\
    \ 0) {\n    return $l;\n  }\n  $even_indexes = array_slice($l, 0, count($l) /\
    \ 2);\n  $odd_indexes = array_slice($l, count($l) / 2);\n  $sorted_indexes = array_merge($even_indexes,\
    \ $odd_indexes);\n  sort($sorted_indexes);\n  return array_combine($sorted_indexes,\
    \ $l);\n}", "    $l2 = $l;\n    array_pop($l2);\n    for ($i = 0; $i < count($l2);\
    \ $i += 2) {\n        sort($l2);\n    }\n    return $l2;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks, I'm glad you pointed this out. After fixing the sort function\
    \ as I commented, the script runs quite slowly (~30 seconds to complete for my\
    \ test set).\n<|/ c |>\n<| c |>\n: Can you please post your modified `sort` function?\n\
    <|/ c |>\n<| c |>\nSure. I edited my original post with the modified function.\n\
    <|/ c |>\n<| c |>\n: Okay, I see what you were saying, I was missing one piece\
    \ of code (the comparison function for `sort_even`). I've updated the answer accordingly.\n\
    <|/ c |>\n<| c |>\n: Thanks for the update. I've now added a comment on the `sort_even`\
    \ function, explaining how the code works. I'm glad you found it useful!\n<|/\
    \ c |>\n<| a tags=php dscore=1 |>\nThe main problem is that you are using foreach\
    \ loop and trying to sort each element individually.\nYou can use array_multisort()\
    \ to sort all elements in one shot. Here is the code using array_multisort():\n\
    <code>\n<?php", "  // Sort the list by value, then by index\n  $a = array_map('unserialize',\
    \ array_map('serialize', $l));\n  // Set odd indicies to equal even indicies,\
    \ and sort the arrays\n  $b = array_map('array_replace', $a[1..$a[0]], $a);\n\
    \  array_multisort($b, SORT_NUMERIC, $a);\n  // Return new sorted array\n  return\
    \ $a;\n}", "    $odd = array_fill(0, count($l)-1, 0);\n    $even = array_fill(0,\
    \ count($l), 0);\n    foreach($l as $i => $el) {\n        if ($i % 2 == 0) {\n\
    \            $even[$i] = $el;\n        } else {\n            $odd[$i] = $el;\n\
    \        }\n    }\n    $even = array_merge($even, $odd);\n    return $even;\n\
    }\n", "    return array_combine(range(count($l), 0, -1), $l);\n}", "  $l2 = array();\n\
    \  for ($i=0; $i<count($l); $i+=2) {\n    $l2[$i] = $l[$i];\n  }\n  ksort($l2);\n\
    \  return $l2;\n}\n", "    $n = count($l);\n    for($i=0; $i < $n/2; $i++) {\n\
    \        $l[$i] = $l[$n-1-$i];\n    }\n    for($i=$n/2; $i < $n; $i++) {\n   \
    \     $l[$i] = $l[$n-$i-1];\n    }\n    return $l;\n}\n", "    $even = array();\n\
    \    $odd = array();\n    foreach ($l as $k=>$v) {\n        if ($k % 2 == 0) {\n\
    \            $even[$k] = $v;\n        } else {\n            $odd[$k] = $v;\n \
    \       }\n    }\n    $even = array_values($even);\n    $odd = array_values($odd);\n\
    \    array_push($even, $odd);\n    array_push($even, $odd);\n    return $even;\n\
    }", "  $even = array_filter($l, function($a) { return $a % 2 == 0; });\n  return\
    \ array_combine($even, array_fill(0, count($l), $even));\n}\n\n/**\n * Tests if\
    \ the given number is a multiple of $factor.\n */", "\t$length = count($l);\n\t\
    for ($i = 0; $i < $length / 2; ++$i) {\n\t\t$l[$i] = $l[$i];\n\t}\n\n\tfor ($i\
    \ = 1; $i < $length; ++$i) {\n\t\tif ($l[$i - 1] > $l[$i]) {\n\t\t\t$l[$i - 1]\
    \ = $l[$i];\n\t\t}\n\t}\n\n\treturn $l;\n}\n", "    $result = array();\n    foreach\
    \ ($l as $index => $value) {\n        if ($index % 2 == 0) {\n            $result[]\
    \ = $value;\n        } else {\n            $result[] = $l[$index & 1];\n     \
    \   }\n    }\n    return $result;\n}", "    $new_list = array();\n    foreach\
    \ ($l as $key => $value) {\n        if ($key % 2 == 0) {\n            $new_list[]\
    \ = $value;\n        }\n    }\n    return $new_list;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't seem to be the solution. While it does produce the\
    \ required output, it's not a good solution in general. Your function doesn't\
    \ handle cases like `sort_even([0, 2, 1, 2, 0]) == [0, 2, 0, 2, 0]`.\n<|/ c |>\n\
    <| c |>\nWell, no, it does handle that case. Have you tried it? What happened?\
    \ The only case it fails on is `[]`. If that case is supposed to be handled gracefully,\
    \ then `sort_even` isn't the right function to be using. Instead, write a new\
    \ function that takes two lists and compares them using the `sort_even` function,\
    \ then return the result of that comparison if they're equal. This is what it\
    \ does.\n<|/ c |>\n<| c |>\n: It handles `[]` correctly. Your function doesn't\
    \ handle it correctly because your function doesn't handle the case where both\
    \ lists are equal.\n<|/ c |>\n<| c |>\n: Ah! I see that now. Yeah, you're right,\
    \ it does fail on the case `sort_even([0, 2, 1, 2, 0]) == [0, 2, 0, 2, 0]`. I\
    \ need to fix that.\n<|/ c |>\n<| c |>\n: You're right. I fixed my answer to handle\
    \ that case.\n<|/ c |>\n<| a |>\n<code>", "  for ($i = 0; $i < count($l) % 2;\
    \ $i++) {\n    $l[$i] = $l[$i]; // copy evens\n  }\n  sort($l, SORT_NUMERIC);\n\
    \  for ($i = 0; $i < count($l) % 2; $i++) {\n    $l[$i] /= 2; // divide evens\
    \ by 2\n  }\n  return $l;\n}\n</code>\n<|/ a dscore=0 tags=php,arrays,sorting\
    \ |>\n<| a |>\nHere is another solution using SORT_NUMERIC:\n<code>\n$a = array(1,\
    \ 3, 2);\nuasort($a, function($a, $b){\n    return ($a % 2 != 0) - ($b % 2 !=\
    \ 0);\n});\nprint_r($a);\n</code>\nThis solution compares the current position\
    \ with its neighbouring position and sorts the array accordingly.\n<|/ a tags=php,arrays,sorting\
    \ dscore=0 |>\n<| c |>\nIt works perfectly, but it doesn't sort ascending order\
    \ when the condition is `return ($a % 2 != 0) - ($b % 2 != 0);`. Is it possible\
    \ to fix this?\n<|/ c |>\n<| c |>\n, yes. I have edited my answer to reflect the\
    \ change. Hopefully that helps\n<|/ c |>\n<| a dscore=0 tags=php,arrays,sorting\
    \ |>\nYou can take advantage of array_splice:\n<code>\n$array = [1,2,4,6,8,9,3];\n\
    $array_index = 0;\n$count = 1;\ndo {\n    $array[++$array_index] = $array[--$count];\n\
    } while ($count && $array_index > 0);\n\narray_splice($array, 0, $array_index,\
    \ $array);\nprint_r($array);\n</code>\nThe result would be:\n<code>\nArray\n(\n\
    \    [0] => 1\n    [2] => 2\n    [4] => 4\n    [6] => 6\n    [8] => 8\n    [9]\
    \ => 9\n)\n</code>\n<|/ a |>\n<| a dscore=0 |>\nA simple solution would be using\
    \ a for loop to loop over the array and swap the element you want in the middle\
    \ (here the middle element) with the element you want next to it (here the middle\
    \ one + 1).\nSo the code would look like this:\n<code>\n$a = array(1, 2, 3, 4);\n\
    $b = array();\n$c = count($a); // count how many elements are in the array\n$d\
    \ = $c; // set the middle element to $d\nfor($i = 0; $i < $c - 1; $i++) { //loop\
    \ from 0 to n-1 where n is the number of ", "  return array_merge(array_flip(range(0,\
    \ count($l) - 1)), array_slice($l, 0, count($l) / 2));\n}\n", "    $lsize = count($l);\n\
    \    for($i = 1; $i < $lsize; $i+=2) {\n        $j = ($i+$lsize) % $lsize;\n \
    \       $l[$i] = $l[$j];\n    }\n    return $l;\n}", "  $even = array();\n  $odd\
    \ = array();\n  for ($i = 0; $i < count($l); $i++) {\n    if ($i % 2 == 0) {\n\
    \      $even[] = $l[$i];\n    }\n    else {\n      $odd[] = $l[$i];\n    }\n \
    \ }\n  return $even;\n}\n", "    return array_intersect_key($l, array_flip(range(0,\
    \ count($l), 2)));\n}\n", "    $even = array();\n    $odd = array();\n    $llength\
    \ = count($l);\n    for ($i = 0; $i < $llength; $i++) {\n        $even[$i] = $l[$i];\n\
    \    }\n    for ($i = 0; $i < $llength; $i++) {\n        $odd[$i] = $l[$i];\n\
    \    }\n    for ($i = 0; $i < $llength; $i++) {\n        if ($i % 2 === 0) {\n\
    \            $even[$i] = $even[$i] - $odd[$i];\n            $odd[$i] = $odd[$i]\
    \ + $even[$i];\n        }\n    }\n    return array_merge($even, $odd);\n}\n",
  "    $evens = array_chunk($l, 2);\n    $odds = array_chunk($l, 2);\n    $evens =\
    \ array_map(function($a) {\n        return $a[1];\n    }, $evens);\n    array_push($evens,\
    \ $odds);\n    return $evens;\n}\n", "  for ($i = 0, $n = count($l); $i < $n;\
    \ $i++) {\n    $even_pos = $i % 2;\n    if ($even_pos) {\n      $l[$i] = $l[$even_pos];\n\
    \    }\n  }\n  return $l;\n}", "    $l = array_reverse($l);\n    for ($i=0; $i\
    \ < count($l); $i+=2) {\n        $l[$i] = $l[$i];\n    }\n    return $l;\n}\n",
  "  global $sort;\n  foreach ($l as $key => $value) {\n    $even = array_keys($l,\
    \ $value, 1);\n    $odd  = array_keys($l, $value, 0);\n    for ($i = 0; $i < $odd;\
    \ $i++) {\n      $sort[$key] = $even[$i];\n    }\n  }\n  return $l;\n}\n", " \
    \   $even = array_slice($l, 0, count($l) / 2);\n    return $even + array_combine(array_slice($l,\
    \ count($l) / 2), $even);\n}\n</code>\n<|/ a dscore=2 tags=sorting,php,arrays\
    \ |>\n<| c |>\nGood answer, but it's worth pointing out that it doesn't work with\
    \ associative arrays, e.g. `$arr = [1 => 'a', 2 => 'b', 3 => 'c']`. To do that,\
    \ the key needs to be sorted before array_combine is called.\n<|/ c |>\n<| a tags=sorting,php,arrays\
    \ dscore=1 |>\nThis should do it:\n<code>", "    $even = array_filter($l, function($i)\
    \ use ($l) {\n        return ($i % 2);\n    });\n    return array_merge($even,\
    \ array_fill(0, count($l), $l));\n}", "    $n = count($l);\n    $evens = array_fill(0,\
    \ $n, 0);\n    foreach($l as $k => $v) {\n        $odd = ($k + 1) & $n;\n    \
    \    $evens[$odd] = $v;\n    }\n    return $evens;\n}", "    $odd = $even = [];\n\
    \    foreach ($l as $value) {\n        $is_even = ($value % 2 === 0);\n      \
    \  $odd[$is_even ? 0 : 1] = $value;\n        $even[$is_even ? 1 : 0] = $value;\n\
    \    }\n    $odd = array_merge($even, $odd);\n    sort($odd);\n    sort($even);\n\
    \    return array_merge($odd, $even);\n}\n", "    foreach ($l as $k => $v) {\n\
    \        if (!isset($l[$k]) || $k % 2) {\n            continue;\n        }\n\n\
    \        $l[$k] = $l[$k];\n        $l[$k % 2] = $v;\n    }\n\n    return $l;\n\
    }\n", "    $even = [];\n    $odd = [];\n\n    for ($i = 0; $i < count($l); $i++)\
    \ {\n        if ($i % 2 == 0) {\n            $even[$i] = $l[$i];\n        } else\
    \ {\n            $odd[$i] = $l[$i];\n        }\n    }\n\n    ksort($even);\n \
    \   ksort($odd);\n\n    return array_merge($even, $odd);\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| c |>\nThe idea is fine, but I think your code is missing a key part -\
    \ why are you using `ksort` twice?\n<|/ c |>\n<| c |>\nI edited the answer to\
    \ include some explanations for `ksort` in the comments. I agree with you though,\
    \ this function has flaws, and I should go and fix it when I have the time.\n\
    <|/ c |>\n<| c |>\nI tested this with some more test data and it's working fine\
    \ now. I did change it slightly to use `array_merge` instead of `array_map` and\
    \ to just use `array_values` to get the values of the array. I'm not sure if it\
    \ would be better to just `foreach` over `$l` directly instead, since you aren't\
    \ really using `$i`. Anyway, thanks for the help!\n<|/ c |>\n<| c |>\nGood answer.\
    \ I'd add `array_values` to the end of the `array_merge` call. `array_values`\
    \ will ensure the values are properly ordered.\n<|/ c |>\n<| c |>\nI agree, though\
    \ it isn't necessary in this case. :)\n<|/ c |>\n<| a dscore=3 |>\nHow about this:\n\
    <code>", "  $even = array_fill(0, count($l), 0);\n  $odd = array_fill(0, count($l),\
    \ 0);\n  for ($i = 0; $i < count($l); $i++) {\n    $even[$i] .= $l[$i] % 2;\n\
    \    $odd[$i] .= $l[$i];\n  }\n  array_multisort($even, $odd, $l);\n  return $l;\n\
    }", "    $lp = $l = array_flip($l);\n    for ($i = 0; $i < count($l); $i += 2)\
    \ {\n        // Swap the two values\n        list($l[$i], $l[$i + 1]) = $l[$i\
    \ + 1], $l[$i];\n        $lp[$i] .= $lp[$i + 1];\n    }\n    return $l;\n}\n",
  "  $even = array_fill(0, count($l), false);\n  foreach ($l as $i => $e) {\n    if\
    \ ($even[$i]) $l[$i] = $even[$i];\n    $even[$i] = true;\n  }\n  return $l;\n\
    }\n", "  if (count($l) > 0) {\n    $odd = array_slice($l, 0, count($l)/2);\n \
    \   $even = array_slice($l, count($l)/2, count($l));\n    $even = array_merge($even,\
    \ $even);\n    return array_merge($odd, $even);\n  }\n}\n", "  $l1 = array();\n\
    \  for ($ii = 0; $ii < count($l); $ii++) {\n    $l1[$ii] = $l[$ii];\n  }\n  for\
    \ ($ii = 0; $ii < count($l); $ii += 2) {\n    for ($jj = $ii+1; $jj < count($l);\
    \ $jj++) {\n      if ($l1[$ii] < $l1[$jj]) {\n        $swap = $l1[$ii];\n    \
    \    $l1[$ii] = $l1[$jj];\n        $l1[$jj] = $swap;\n      }\n    }\n  }\n  return\
    \ $l1;\n}\n", "  foreach ($l as $key => $val) {\n    if ($key % 2 == 0) {\n  \
    \    if ($val < $l[$key - 1]) {\n        $l[$key] = $val;\n      } else {\n  \
    \      array_push($l, $val);\n      }\n    } else {\n      if ($val < $l[$key\
    \ + 1]) {\n        $l[$key] = $val;\n      } else {\n        array_push($l, $val);\n\
    \      }\n    }\n  }\n  return $l;\n}", "  $even = array_fill(0, count($l), 0);\n\
    \  foreach ($l as $i => $value) {\n    if ($i & 1) {\n      $even[$i] = $value;\n\
    \    }\n  }\n  return $even;\n}\n</code>\nThis has O(n log n) complexity, and\
    \ O(n) space complexity.\n<|/ a dscore=1 |>\n<| c |>\nThanks for the fast reply,\
    \ but I'm not sure how to implement this into my code.\n<|/ c |>\n<| c |>\nIt's\
    \ a separate function. You'd use it just like you would any other function.\n\
    <|/ c |>\n<| c |>\nI updated my code in the original question. Can you please\
    \ show me how I should implement this into my code? I'm sorry I'm new to this\
    \ and don't fully understand your answer.\n<|/ c |>\n<| c |>\nI put a link to\
    \ my code in the original question, so you can see how I implemented your solution.\n\
    <|/ c |>\n<| c |>\nI realized that the way you did it is really inefficient, but\
    \ I figured out how to sort my list. Thank you for your help!\n<|/ c |>\n<| a\
    \ dscore=0 tags=algorithm,php,sorting |>\nMy method of doing this is to split\
    \ up the list into two arrays, where the first array contains all the odd numbers\
    \ (starting at index 1) and the second array contains the even numbers (starting\
    \ at index 0). Then you can sort the two arrays and then combine the two results\
    \ into a new array.\n<code>\n<?php\n$a = [1, 2, 3, 4];\n$b = array_filter($a);\n\
    $c = array_chunk($b, 2);\n$d = array_merge(sort_odd($c[0]), sort_even($c[1]));\n\
    $e = array_merge($b, $d);\n$f = array_values($e);\nprint_r($f);\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work. Sort of like doing `array_merge($b, $d)` then\
    \ sorting `$b` then sorting `$d`, which would result in `[3, 4, 2, 1]`, but sorting\
    \ `$d` would result in `[1, 2, 3, 4], not `[1, 1, 2, 3]`\n<|/ c |>\n<| c |>\n\
    Your method of doing the merge of arrays is wrong. Check my answer, it's much\
    \ more efficient\n<|/ c |>\n<| a dscore=0 |>\nHere's a way to do this in O(n):\n\
    <code>", "  return array_values($l)\n    ? array_map('array_shift', array_chunk($l,\
    \ 2))\n    : $l;\n}\n", "  $even = array();\n  foreach ($l as $k=>$v) {\n    if\
    \ ($k % 2 == 0) {\n      $even[$k] = $v;\n    } else {\n      $odd[$k] = $v;\n\
    \    }\n  }\n  return array_merge($even, $odd);\n}\n", "    $even = $odd;\n  \
    \  $even = array_slice($l, 0, count($l) / 2);\n    $odd = array_slice($l, count($l)\
    \ / 2);\n    $even = array_reverse($even);\n    return $even + $odd;\n}\n", " \
    \   $even = [];\n    $odd = [];\n    for ($i = 0; $i < count($l); $i += 2) {\n\
    \        $even[] = $l[$i];\n        $odd[] = $l[$i + 1];\n    }\n    return array_merge($odd,\
    \ $even);\n}\n</code>\n<|/ a tags=php,algorithm,arrays,sorting dscore=1 |>\n<|\
    \ c |>\nIt doesn't answer the question at all. The answer has nothing to do with\
    \ the question asked. I am not sure why you have the downvote.\n<|/ c |>\n<| c\
    \ |>\nI guess I thought the question had to do with sorting an array in \"pairs\"\
    . That's why I answered it.\n<|/ c |>\n<| c |>\nI downvoted because I believe\
    \ this does not answer the question. I agree with you that OP wants to sort by\
    \ pairs, but they did not ask for that. They specifically said they wanted to\
    \ sort the odd indicies first, then the even indicies.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to show that you can use the `sort` function to do that. Sort by odd\
    \ and then by even.\n<|/ c |>\n<| c |>\nI did a test case where it does work,\
    \ and it does indeed sort them by pairs. I used the test case I provided.\n<|/\
    \ c |>\n<| a |>\nYou could use usort to sort the odd indicies first and if the\
    \ odd indicies are equal, sort by the even indicies.\n<code>\n$odd = array_slice($array,\
    \ 0, count($array) / 2);\n$even = array_slice($array, count($array) / 2);\nusort($odd,\
    \ function ($a, $b) {\n    if ($a > $b) {\n        return 1;\n    }\n\n    if\
    \ ($a < $b) {\n        return -1;\n    }\n\n    return 0;\n});\n\nusort($even,\
    \ function ($a, $b) {\n    if ($a > $b) {\n        return 1;\n    }\n\n    if\
    \ ($a < $b) {\n        return -1;\n    }\n\n    return 0;\n});\n\n$result = [];\n\
    $index = 0;\nforeach ($even as $key => $val) {\n    if ($index >= count($odd))\
    \ {\n        break;\n    }\n\n    if ($val == $odd[$index]) {\n        $result[$key]\
    \ = $val;\n        $index++;\n    }\n}\n</code>\nThis sorts them by pairs. You\
    \ can change the usort callback if you prefer to sort them by any other criteria.\n\
    <|/ a tags=php,algorithm,arrays,sorting d", "    sort($l, SORT_NUMERIC);\n   \
    \ for ($i=0; $i<count($l); $i+=2) {\n        $l[$i] = $l[$i];\n    }\n    return\
    \ $l;\n}\n", "  $odd = array();\n  foreach ($l as $k => $v)\n    if ($k & 1)\n\
    \      $odd[$k] = $v;\n  ksort($odd);\n  $even = array();\n  foreach ($l as $k\
    \ => $v)\n    if ($k & 2)\n      $even[$k] = $v;\n  return array_merge($odd, $even);\n\
    }", "    return $l != count($l) ? $l : array_merge(sort_odd(array_slice($l, 0,\
    \ count($l) / 2)), sort_odd(array_slice($l, count($l) / 2, count($l))));\n}",
  "    $l2 = [];\n    $i = 0;\n    foreach ($l as $v) {\n        if ($i % 2 == 0)\
    \ {\n            $l2[] = $v;\n        } else {\n            $l2[] = $l[$i];\n\
    \            $l2[count($l2) - 1] = $l2[count($l2) - 1] + $l[$i];\n        }\n\
    \        $i++;\n    }\n    return $l2;\n}\n", "    $l2 = $l; // make a copy\n\
    \    for ($i=0; $i<count($l2); $i+=2) {\n        $l2[$i] = $l2[$i];\n    }\n \
    \   array_multisort($l2, SORT_DESC, $l); // sort the copy\n    return $l; // return\
    \ the copy\n}\n</code>\n<|/ a dscore=1 tags=sorting,php,arrays |>\n<| c |>\nThis\
    \ answer seems better than my own, but I believe there is a problem with the last\
    \ line of `sort_even`. If `$l2[$i]` is not an odd number then it would be set\
    \ at `$l2[$i+1]` instead of `$l2[$i]`.\n<|/ c |>\n<| c |>\nYou are right. I was\
    \ too focused on the last line. My bad, edited. Thanks for noticing!\n<|/ c |>\n\
    <| c |>\n+1 This was the right direction, but I went with the array_multisort\
    \ route since I need the array to be in the same order it started out in. Also,\
    \ I had to change it to `$l2[$i+1]` instead of `$l2[$i+2]` since I was sorting\
    \ in descending order. Thanks!\n<|/ c |>\n<| c |>\nAh, okay, I'm glad you figured\
    \ it out. :) You might be interested in this other answer I posted a while back:\
    \ http://stackoverflow.com/questions/1340305/sort-an-array-according-to-another-array/1340595#1340595\n\
    <|/ c |>\n<| a |>\nNot sure if this is what you're looking for, but a basic solution\
    \ would be to keep a count and sort based off of that. You could even swap the\
    \ positions of items in your array as they get swapped based on the count.\n<code>",
  "    foreach ($l as $key => $value) {\n        if ($key % 2 == 0) {\n          \
    \  $l[$key] = $value;\n        }\n    }\n    sort($l);\n    return $l;\n}\n",
  "  $even = array_intersect_key($l, array_filter($l, 'is_int'));\n  $odd = array_intersect_key($l,\
    \ array_filter($l, '!is_int'));\n  return array_merge(array_values($even), array_values($odd));\n\
    }\n</code>\n<|/ a tags=arrays,sorting,php dscore=0 |>\n<| a tags=arrays,sorting,php\
    \ dscore=0 |>\nYou can do something like this (a little bit optimized I think)\
    \ :\n<code>\n$newArray = array();\n\nforeach($array as $key => $value){\n    if($key\
    \ % 2 == 0){\n        $newArray[$key] = $value;\n    }\n}\n\n$newArray = array_values($newArray);\n\
    </code>\n<|/ a |>\n<| a |>\nPHP array_intersect_key() returns an array containing\
    \ all the entries of one array which have keys that are present in another array.\
    \ \nYou can use this as first parameter for array_values() to reindex the array.\n\
    <code>", "    $odd = array_splice($l, 0, count($l) / 2);\n    array_splice($l,\
    \ count($l) / 2, count($l) - count($l) / 2, $odd);\n    return $l;\n}", "  $even\
    \ = [];\n  $odd = [];\n  for ($i = 0, $length = count($l); $i < $length; $i++)\
    \ {\n    $even[$i] = $l[$i];\n    $odd[$i] = $l[$i];\n    if ($i % 2 == 0) {\n\
    \      $even[$i] = $even[$i];\n    } else {\n      $odd[$i] = $odd[$i];\n    }\n\
    \  }\n\n  return $even;\n}\n", "    return array_merge(\n        array_slice($l,\
    \ 0, count($l) / 2),\n        array_slice($l, count($l) / 2)\n    );\n}\n", " \
    \   return array_intersect_key($l, array_flip(range(0, count($l))));\n}\n", " \
    \ for ($i = 1; $i < count($l); $i++) {\n    for ($j = 0; $j < $i; $j++) {\n  \
    \    if ($j % 2 == 0) {\n        $l[$j] = $l[$i];\n      }\n    }\n  }\n  return\
    \ $l;\n}\n", "  $l = array_count_values($l);\n  $l2 = array();\n  foreach ($l\
    \ as $k => $v) {\n    if ($k % 2 == 0) {\n      $l2[$k] = $v;\n    }\n  }\n  return\
    \ $l2;\n}\n", "  $odd = array_slice($l, 0, count($l) / 2);\n  $even = array_slice($l,\
    \ count($l) / 2, count($l));\n  $even = array_merge($even, $l);\n  ksort($even);\n\
    \  return array_merge($odd, $even);\n}", "    foreach ($l as $k => $v) {\n   \
    \     $l[$k] = $v;\n    }\n    // If l has odd numbers, reverse it\n    if (count($l)\
    \ % 2 == 1) {\n        array_reverse($l);\n    }\n    // Now sort the even indicies\n\
    \    for ($i = 0; $i < count($l); $i += 2) {\n        sort($l, $i);\n    }\n \
    \   return $l;\n}\n$l = array(10, 20, 5, 15, 12, 35, 20, 15, 12, 20, 5, 10);\n\
    print_r(sort_even($l));", "    $evens = [];\n    $odds = [];\n    foreach ($l\
    \ as $i => $v) {\n        if ($i % 2 == 0) {\n            $evens[] = $v;\n   \
    \     } else {\n            $odds[] = $v;\n        }\n    }\n    return array_merge($evens,\
    \ $odds);\n}\n</code>\nThe function can now be called with or without arguments:\n\
    <code>\n<?php\n", "    $even = array();\n    foreach ($l as $key => $value) {\n\
    \        if (!is_int($key)) {\n            $even[$key] = $value;\n        }\n\
    \    }\n    ksort($even);\n    return array_merge(array_flip($l), $even);\n}\n",
  "    $even = array();\n    $odd = $l;\n    foreach ($l as $key => $value) {\n  \
    \      if ($key % 2 === 0) {\n            $even[$key] = $value;\n        } else\
    \ {\n            $odd[$key] = $value;\n        }\n    }\n    return $even;\n}\n",
  "  $l2 = [];\n  foreach ($l as $k=>$v) {\n    if ($k%2 == 0) {\n      $l2[$k] =\
    \ $v;\n    } else {\n      if (isset($l[$k+1])) {\n        if ($l[$k+1] < $v)\
    \ {\n          $l2[$k] = $v;\n        } else {\n          $l2[$k+1] = $v;\n  \
    \      }\n      }\n    }\n  }\n  return $l2;\n}\n", "    return array_merge($l,\
    \ $l[array_keys($l)] ?? []);\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not work\
    \ with an array of strings, only with integers.\n<|/ c |>\n<| c |>\nThe example\
    \ in the question does work with strings, but the array being sorted contains\
    \ strings, and the code works fine with integers.\n<|/ c |>\n<| c |>\nAh, OK,\
    \ sorry, I didn't see you were using strings. And that example would work fine\
    \ with integers.\n<|/ c |>\n<| a tags=sorting,php,arrays |>\nYou can use the array_multisort\
    \ function to sort an array with multiple keys. For example:\n<code>\n$array =\
    \ array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5);\narray_multisort($array,\
    \ SORT_DESC, SORT_ASC, SORT_NUMERIC, $array);\n</code>\nThe above will result\
    \ in:\n<code>\narray(5) {\n  [\"b\"]=>\n  int(2)\n  [\"c\"]=>\n  int(3)\n  [\"\
    d\"]=>\n  int(4)\n  [\"e\"]=>\n  int(5)\n  [\"a\"]=>\n  int(1)\n}\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nThis worked very well for me, thanks. I added array_multisort\
    \ and SORT_NATURAL into my code as parameters to get my sorted array in numeric\
    \ order. Otherwise the array was sorted by ASCII order\n<|/ c |>\n<| a tags=sorting,php,arrays\
    \ |>\nI know this is a bit old but I think this is the most elegant and simple\
    \ way to sort an array with multiple keys and maintaining the keys as well. \n\
    <code>\n$array = array('one' => 1, 'two' => 2, 'three' => 3);\n", "  foreach ($l\
    \ as $i => $val) {\n    if ($i%2 == 0) $l[$i] = $l;\n  }\n  usort($l, function($a,\
    \ $b) {\n    return $a - $b;\n  });\n  return $l;\n}\n", "    $evens = array_keys($l,\
    \ $l[$i & 1]);\n    return $evens ? array_intersect_key($l, $evens) : [];\n}\n",
  "  $size = count($l);\n  $evens = array_fill(0, $size, '');\n  $odds = array_fill(1,\
    \ $size, '');\n  $out  = array();\n\n  for ($i = 0; $i < $size; $i++) {\n    if\
    \ ($i%2 == 0) {\n      $out[] = $l[$i];\n      $evens[$i] = $l[$i];\n      $odds[$size-$i]\
    \ = $l[$size-$i-1];\n    }\n    else {\n      $out[] = $evens[$i];\n      $out[]\
    \ = $odds[$size-$i-1];\n    }\n  }\n\n  return $out;\n}\n", "  $even = array_fill(0,\
    \ count($l), FALSE);\n  foreach ($l as $key => $val) {\n    $even[$key] |= ($key\
    \ & 1) ? TRUE : FALSE;\n  }\n  return array_keys($even);\n}\n", "  $even = array_filter($l,\
    \ function ($e) {\n    return $e % 2 == 0;\n  });\n  sort($even);\n  $l = array_merge($even,\
    \ $l);\n  return $l;\n}\n", "  $odd = array_slice($l, 0, count($l) / 2);\n  sort($odd);\n\
    \  return array_merge($odd, $l);\n}", "  return array_merge(\n    array_fill(0,\
    \ count($l) % 2, $l[array_keys($l)[0]]),\n    sort($l[array_keys($l)[1]])\n  );\n\
    }\n</code>\n<|/ a tags=php,arrays,sorting dscore=1 |>\n<| c |>\nI like this one\
    \ because it is simple and easy to understand. I'll use this in other parts of\
    \ my code too thanks!\n<|/ c |>\n<| a dscore=0 |>\nIf you're just looking to sort\
    \ by even numbers, then you can use a custom sort function with the usort function:\n\
    <code>", "  $odd = [];\n  $even = array_fill(0, count($l), 0);\n  for($i=0; $i<count($l);\
    \ $i++) {\n    $odd[$i] = $i;\n    $even[$i] = $l[$i];\n  }\n  array_multisort($even,\
    \ $odd, SORT_ASC, SORT_NUMERIC, $l);\n  return $l;\n}", "    $length = count($l);\n\
    \    $even = [];\n    $odd = [];\n\n    for ($i = 0; $i < $length; ++$i) {\n \
    \       if ($i % 2 == 0) {\n            $even[] = $l[$i];\n        } else {\n\
    \            $odd[] = $l[$i];\n        }\n    }\n\n    return array_merge(sort_even($odd),\
    \ $even);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your answer but\
    \ I think that the problem with this solution is that it will give unpredictable\
    \ results for an array that has duplicates. The first array `[1,2,3,4,5]` should\
    \ return `[1,2,3,4,5]` but this code returns `[1,2,4,5,3]`\n<|/ c |>\n<| c |>\n\
    It was a typo in the `array_merge`; it should be `$even = sort_even($odd);`. It\
    \ was returning the same array for duplicates, which is what your question states.\n\
    <|/ c |>\n<| c |>\nOh, I see what you mean. It still doesn't work in that situation\
    \ though. If I put `[1,2,4,5]` into the test script then it returns `[2,4,5,1]`\
    \ when it should be `[2,4,5]`. It's also not giving me the desired ordering when\
    \ given `[1,2,3,4]`. It returns `[1,2,4,3]`.\n<|/ c |>\n<| c |>\nAhh yeah I see!\
    \ I see how that would cause a problem. I'll have to think about how to fix that.\n\
    <|/ c |>\n<| c |>\nOkay I think I fixed it now. Updated my answer.\n<|/ c |>\n\
    <| a dscore=0 |>\nI took the time to write a custom function to solve this problem.\
    \ Since you were also looking for an answer with array_merge(), I figured I'd\
    \ just post it here. I'm sure it could be improved, but I think it's pretty straight\
    \ forward and easy to understand.\nThis function takes a list l, and returns a\
    \ list l sorted in the way that I would describe in the original question (i.e.\
    \ alternating values that are equal, while keeping the original order).\n<code>",
  "    foreach ($l as $key => $value) {\n        if ($key % 2 == 0) {\n          \
    \  $l[$key] = $value;\n        }\n    }\n    sort($l);\n    return $l;\n}\n</code>\n\
    <|/ a tags=arrays,sorting,php,algorithm |>\n<| c |>\nThis is an interesting solution,\
    \ however it is in O(n^2)\n<|/ c |>\n<| c |>\nI didn't see that.  That makes it\
    \ O(n^2) worst case, which is very different.\n<|/ c |>\n<| c |>\nIt's O(n) worst\
    \ case because `sort` is in-place.  It's O(n) average case because `sort` doesn't\
    \ need to do any extra copies.\n<|/ c |>\n<| a dscore=2 tags=arrays,sorting,php,algorithm\
    \ |>\nMy answer is a bit different than, although I find it more elegant.\n<code>\n\
    <?php\n$a = [1, 2, 3, 4, 5];\nusort($a, function($a, $b){\n    return ($a % 2\
    \ == 0 && $b%2 == 0) ? $b : $a - $b;\n});\nprint_r($a);\n</code>\n<|/ a |>\n<|\
    \ c |>\nthis would only work for arrays with odd-length arrays though. Not generic.\n\
    <|/ c |>\n<| c |>\nIndeed. That's why I said *different than* ;-)\n<|/ c |>\n\
    <| c |>\nWell, I said *different than* because I find it *more elegant*. :-)\n\
    <|/ c |>\n<| c |>\nI find it more elegant than `sort` because it sorts the array\
    \ in place. I find it more elegant than `usort` because it uses anonymous functions.\
    \ If you don't want to use anonymous functions, you can replace `function($a,\
    \ $b){return ($a % 2 == 0 && $b%2 == 0) ? $b : $a - $b;}` with `$cmp = $cmp ?\
    \ $cmp : function ($a, $b) { return ($a % 2 == 0 && $b%2 == 0) ? -1 : ($a % 2\
    \ != 0 && $b%2 != 0) ? 1 : 0;};`. Then, you have `usort($a, '$cmp');`\n<|/ c |>\n\
    <| c |>\nIf you don't like anonymous functions, you can do `function cmp($a, $b)\
    \ {return ($a % 2 == 0 && $b%2 == 0) ? -1 : ($a % 2 != 0 && $b%2 != 0) ? 1 : 0;}`\
    \  Then, you can use `usort($a, \"cmp\")`.\n<|/ c |>", "  $evens = array_chunk($l,\
    \ 2);\n  return array_map(function ($evens) use ($l) { return $evens[1]; }, $evens);\n\
    }", "  $evens = array_keys($l);\n  sort($evens, SORT_NUMERIC);\n  $even_values\
    \ = array_intersect_key($l, array_flip($evens));\n  return array_merge($evens,\
    \ $even_values);\n}\n", "    return array_map(function($elem) {\n        return\
    \ ($elem % 2 ? $elem : $elem+1);\n    }, $l);\n}", "    return $l[0] <= $l[1]\
    \ ? $l : array_merge(sort_even([$l[1], $l[0]]), [$l[0]]);\n}\n", "    $l2 = array_chunk($l,\
    \ 2, true);\n    sort($l2[0]);\n    sort($l2[1]);\n    return array_merge(array_slice($l2,\
    \ 1, 1), $l2[0]);\n}\n", "    $odd = $even = array();\n    for ($i = 0; $i < count($l);\
    \ $i++) {\n        if (!isset($odd[$i])) {\n            $odd[$i] = $even[$i] =\
    \ $l[$i];\n        } elseif ($i % 2 == 0) {\n            $even[$i] = $l[$i];\n\
    \        } else {\n            $odd[$i] = $l[$i];\n        }\n    }\n    return\
    \ $odd + array_reverse($even);\n}\n", "  $l2 = [];\n  for ($i=0; $i<count($l);\
    \ $i++) {\n    $i2 = 0;\n    while ($i2 < count($l) && $l[$i] == $l[$i2]) {\n\
    \      $i2++;\n    }\n    $l2[($i % 2)] = $l[$i];\n    if ($i2 != count($l)) {\n\
    \      $l[$i] = $l[$i2];\n    }\n  }\n  return $l2;\n}", "    foreach ($l as $key\
    \ => $value) {\n        $even_keys = array_keys($l, $value);\n        if (count($even_keys)\
    \ === 0) {\n            unset($l[$key]);\n        }\n    }\n    arsort($l);\n\
    \    $even_keys = array_keys($l);\n    $result = array();\n    foreach ($even_keys\
    \ as $key) {\n        $result[$key] = $l[$key];\n    }\n    return $result;\n\
    }\n</code>\nI tested the above function using PHPUnit and it works. Hope this\
    \ helps.\n<|/ a tags=arrays,php,algorithm,sorting |>\n<| c |>\nThe answer given\
    \ by \"David\" is the simplest and efficient way to do this.\n<|/ c |>\n<| a tags=arrays,php,algorithm,sorting\
    \ |>\nMy solution is this:\n<code>", "    // $l' is a copy of $l\n    // so no\
    \ need to worry about it getting out of scope\n    $l' = array();\n    // iterate\
    \ through the list and add the even indices\n    // to the new array\n    for\
    \ ($i = 0; $i < count($l); $i += 2) {\n        $l'[] = $l[$i];\n    }\n    //\
    \ iterate through the new list and add the odd indices\n    // to $l' while sorting\
    \ them\n    for ($i = 1; $i < count($l') - 1; $i += 2) {\n        // sort them\
    \ so that odd indicies come first\n        $l'[$i] = $l'[$i] - $l'[$i + 1];\n\
    \        // then sort them again so that the even indicies come first\n      \
    \  $l'[$i + 1] = $l'[$i] - $l'[$i + 1];\n    }\n    // return the sorted list\n\
    \    return $l;\n}\n</code>\nI hope this helps!\n<|/ a dscore=2 |>\n<| a tags=php,arrays,algorithm\
    \ dscore=2 |>\n<code>"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
