name: HumanEval_54_same_chars
language: php
prompt: "<?php\n// Check if two words have the same characters.\n// >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddeddabc')\n// True\n// >>> same_chars('abcd', 'dddddddabc')\n// True\n\
  // >>> same_chars('dddddddabc', 'abcd')\n// True\n// >>> same_chars('eabcd', 'dddddddabc')\n\
  // False\n// >>> same_chars('abcd', 'dddddddabce')\n// False\n// >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddddabc')\n// False\nfunction same_chars($s0, $s1) {\n"
tests: "function candidate(...$args) {\n    return same_chars(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"abcd\", \"dddddddabc\"\
  ) !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"dddddddabc\"\
  , \"abcd\") !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"\
  eabcd\", \"dddddddabc\") !== false) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"abcd\", \"dddddddabcf\") !== false) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") !==\
  \ false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"aabb\"\
  , \"aaccc\") !== false) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $s_length = strlen($s0);\n    $t_length = strlen($s1);\n    if\
    \ ($s_length != $t_length) return false;\n    for ($i=0; $i<$s_length; $i++){\n\
    \        $s0_char = substr($s0, $i, 1);\n        $s1_char = substr($s1, $i, 1);\n\
    \        if ($s0_char != $s1_char) return false;\n    }\n    return true;\n}\n",
  "  return preg_match('/^(.)\\1{2,}$/', $s0) && preg_match('/^(.)\\1{2,}$/', $s1);\n\
    }\n", "  // Strip out non-matching characters if any to speed things up.\n  //\
    \ This is done to speed things up if the strings have a lot of non-matching\n\
    \  // characters (e.g., if each character is equal to a pair of others).\n  if\
    \ (strlen($s0) > strlen($s1)) {\n    $s0 = substr($s0, 1, strlen($s0) - 1);\n\
    \  }\n  if (strlen($s1) > strlen($s0)) {\n    $s1 = substr($s1, 1, strlen($s1)\
    \ - 1);\n  }\n\n  for ($i = 0; $i < strlen($s0); $i++) {\n    if ($s0[$i] !==\
    \ $s1[$i]) {\n      return false;\n    }\n  }\n  return true;\n}", "    $s0 =\
    \ $s0 . \"\"; // To be sure that s0 is string\n    $s1 = $s1 . \"\"; // To be\
    \ sure that s1 is string\n    $s0_length = strlen($s0);\n    $s1_length = strlen($s1);\n\
    \    $same_length = $s0_length == $s1_length;\n    $same = 0;\n\n    for ($i =\
    \ 0; $i < $s0_length; $i++) {\n        if ($s1[$i] == $s0[$i]) {\n           \
    \ $same++;\n        }\n    }\n    return $same_length && $same == $s0_length;\n\
    }", "    $s0 = ltrim($s0, 'aeiouy');\n    $s1 = ltrim($s1, 'aeiouy');\n    return\
    \ count(array_diff($s0, $s1)) == 0;\n}", "  // We need some special handling for\
    \ the beginning of the string.\n  if (strlen($s0) == 0) {\n    return strlen($s1)\
    \ == 0;\n  }\n  // We need some special handling for the beginning of the string.\n\
    \  if (strlen($s1) == 0) {\n    return false;\n  }\n  if ($s0[0] != $s1[0]) {\n\
    \    return false;\n  }\n  $count1 = 0;\n  $count2 = 0;\n  $min1 = strlen($s1);\n\
    \  $min2 = strlen($s2);\n  while ($min1 >= strlen($s1)) {\n    $count1++;\n  \
    \  $min1--;\n  }\n  while ($min2 >= strlen($s2)) {\n    $count2++;\n    $min2--;\n\
    \  }\n  if ($count1 != $count2) {\n    return false;\n  }\n  $m = min(strlen($s1),\
    \ strlen($s2));\n  for ($i = 1; $i < $m; $i++) {\n    if ($s1[$i] != $s2[$i])\
    \ {\n      return false;\n    }\n  }\n  return true;\n}", "    // Count all different\
    \ characters, and compare them.\n    if (strlen($s0) == strlen($s1) && $s0 !=\
    \ $s1) {\n        return true;\n    }\n    $count = preg_match_all('/(.)\\1+/',\
    \ $s0, $matches);\n    return $count === 1;\n}\n", "    $str1 = str_split($s1);\n\
    \    $str0 = str_split($s0);\n    $str1_len = count($str1);\n    $str0_len = count($str0);\n\
    \    $i = 0;\n    $j = 0;\n    $same = 0;\n    while ($i < $str1_len && $j < $str0_len)\
    \ {\n        $a = $str1[$i];\n        $b = $str0[$j];\n        if ($a == $b) {\n\
    \            $same += 1;\n            $i++;\n            $j++;\n        } elseif\
    \ ($a < $b) {\n            $i++;\n        } else {\n            $j++;\n      \
    \  }\n    }\n    return ($i == $str1_len && $j == $str0_len);\n}", "  $s0 = $s0\
    \ . \"\";\n  $s1 = $s1 . \"\";\n  $l0 = strlen($s0);\n  $l1 = strlen($s1);\n \
    \ $i = 0;\n  $j = 0;\n  for (; $i < $l0; $i++) {\n    for ($j = $i + 1; $j < $l1\
    \ && $s0[$i] === $s1[$j]; $j++) {\n    }\n    if ($j === $l1) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}\n", "    $s01 = $s0 . $s1;\n    return\
    \ !preg_match('/' . $s0 . '/i', $s01);\n}\n", "    // Check if the characters\
    \ in the two strings are the same.\n    $i0 = 0;\n    $i1 = 0;\n    while ($i0\
    \ < strlen($s0)) {\n        $i1 = 0;\n        while ($i1 < strlen($s1)) {\n  \
    \          if ($s0[$i0] != $s1[$i1]) {\n                return false;\n      \
    \      }\n            $i1++;\n        }\n        $i0++;\n    }\n\n    return true;\n\
    }", "  if (strlen($s0) == 0) {\n    return true;\n  }\n  if (strlen($s1) != strlen($s0))\
    \ {\n    return false;\n  }\n  $s0_c = array();\n  $s1_c = array();\n  for ($i\
    \ = 0; $i < strlen($s0); $i++) {\n    $s0_c[$i] = $s0[$i];\n    $s1_c[$i] = $s1[$i];\n\
    \  }\n  // If first string is empty, the character set will be the same\n  //\
    \ as second string.\n  if (strlen($s0_c) == 0) {\n    return true;\n  }\n  $i\
    \ = 1;\n  while ($i < strlen($s1_c)) {\n    if ($s1_c[$i] != $s0_c[$i]) {\n  \
    \    return false;\n    }\n    $i++;\n  }\n  return true;\n}\n", "    if ($s0\
    \ === $s1) {\n        return true;\n    }\n    if (!preg_match('/(\\pL)\\1{' .\
    \ (strlen($s0) -1) . ',}/u', $s0) ||\n        !preg_match('/(\\pL)\\1{' . (strlen($s1)\
    \ -1) . ',}/u', $s1)) {\n        return false;\n    }\n    $len0 = strlen($s0);\n\
    \    $len1 = strlen($s1);\n    $s0len = strlen($s0[0]);\n    $s1len = strlen($s1[0]);\n\
    \    $i = 0;\n    $s1lastPos = $len1;\n    $s1PosStart = 0;\n    $s0PosStart =\
    \ 0;\n    while ($i < $len0 && $i < $len1) {\n        $char0 = $s0[$i];\n    \
    \    $char1 = $s1[$i];\n        if ($char0 !== $char1) {\n            if ($char0\
    \ === 'a') {\n                if ($s1PosStart === $i) {\n                    $s1PosStart\
    \ = $i;\n                }\n                $s1lastPos = $i;\n            } elseif\
    \ ($char0 === 'z') {\n                if ($s0PosStart === $i) {\n            \
    \        $s0PosStart = $i;\n                }\n                $s0lastPos = $i;\n\
    \            }\n            return false;\n        }\n        if ($i < $len0 &&\
    \ $i < $len1) {\n            $char0Next = $s0[$i + 1];\n            $char1Next\
    \ = $s1[$i + 1];\n            if ($char0Next === $char1Next) {\n             \
    \   $i++;\n            } else {\n                if ($char0Next === 'a') {\n \
    \                   if ($s1PosStart === $i) {\n                        $s1PosStart\
    \ = $i;\n                    }\n                    $s1lastPos = $i;\n       \
    \         } elseif ($char0Next === 'z') {\n                    if ($s0PosStart\
    \ === $i) {\n                        $s0PosStart = $i;\n                    }\n\
    \                    $s0lastPos = $i;\n                }\n                return\
    \ false;\n            }\n        }\n        $i++;\n    }\n    if ($len0 === $len1)\
    \ {\n        return ($s1PosStart === $s0PosStart);\n    }\n    if ($len0 === $s0len)\
    \ {\n        return ($s1lastPos === $s0lastPos);\n    }\n    if ($len1 === $s1len)\
    \ {\n        return ($s0lastPos === $s1lastPos);\n    }\n    if ($len0 === $s0len\
    \ || $len1 === $s1len) {\n        return false;\n    }\n    $s1lastPos = $s1len;\n\
    \    $s0lastPos = $s0len;\n    for ($i = 0; $i < $len0; $i++) {\n        $char",
  "  $same_count = strlen($s0) - strlen($s1);\n  return $same_count == 0;\n}", " \
    \ if (strlen($s0) == strlen($s1)) {\n    for ($i = 0; $i < strlen($s0); ++$i)\
    \ {\n      if ($s1[$i] != $s0[$i]) return false;\n    }\n    return true;\n  }\n\
    \  return false;\n}\n", "    if (strlen($s0) == 0 || strlen($s1) == 0) {\n   \
    \     return false;\n    }\n    for ($i = 0; $i < min(strlen($s0), strlen($s1));\
    \ $i++) {\n        $c0 = $s0[$i];\n        $c1 = $s1[$i];\n        if ($c0 !==\
    \ $c1) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "    if ($s0 === $s1) {\n        return true;\n    }\n    if (strlen($s0) !== strlen($s1))\
    \ {\n        return false;\n    }\n    $len = strlen($s0);\n    for ($i = 0; $i\
    \ < $len; ++$i) {\n        if ($s0[$i] !== $s1[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\n/**\n * Removes characters from a string\
    \ that match another string, and return the\n * remaining characters.\n *\n *\
    \ @param   string  $s          the string with the characters to remove from\n\
    \ *                           $s\n * @param   string  $characters  the string\
    \ from which to remove characters\n *\n * @return  string  the string with the\
    \ characters removed from $s\n *\n * @access  public\n */", "  return array_count_values(str_split($s0))==array_count_values(str_split($s1));\n\
    }\n", "\tif (strlen($s0) == strlen($s1)) {\n\t\t$c = 0;\n\t\t$s1len = strlen($s1);\n\
    \t\tfor ($i = 0; $i < $s1len; $i++) {\n\t\t\tif ($s1[$i] == $s0[$c++]) {\n\t\t\
    \t\tif (++$c == $s1len) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\treturn false;\n\t} else {\n\t\treturn false;\n\t}\n}\n", "\treturn preg_match('/'\
    \ . preg_quote($s0, '/') . '$/i', $s1) ? $s0 : false;\n}\n", "    $i0 = strlen($s0);\n\
    \    $i1 = strlen($s1);\n    $i = 0;\n    while ($i < $i0) {\n        if ($s1[$i]\
    \ != $s0[$i]) return false;\n        $i++;\n    }\n    return true;\n}\n", " \
    \   if (strlen($s0) == 0 || strlen($s1) == 0) return 0;\n    if (strlen($s0) >\
    \ strlen($s1)) return 0;\n    $s1_copy = str_split($s1);\n    foreach ($s1_copy\
    \ as $c => $c2) {\n        if ( ! isset($s0[$c])) return 0;\n        if ($s0[$c]\
    \ != $s1[$c]) return 0;\n    }\n    return 1;\n}", "  if (!is_string($s0) || !is_string($s1))\
    \ {\n    return false;\n  }\n  // Split each string into an array of characters.\n\
    \  $s0_array = str_split($s0);\n  $s1_array = str_split($s1);\n  foreach ($s0_array\
    \ as $key => $char0) {\n    if ($char0 != $s1_array[$key]) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "    $s0 = preg_replace(\"/[^A-Za-z0-9]/\"\
    , \"\", $s0);\n    $s1 = preg_replace(\"/[^A-Za-z0-9]/\", \"\", $s1);\n    $n\
    \ = min(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $n; $i++) {\n      \
    \  if ($s1[$i] !== $s0[$i]) {\n            return false;\n        }\n    }\n \
    \   return true;\n}\n$s0 = $_POST['s0'];\n$s1 = $_POST['s1'];\n$s1 = preg_replace(\"\
    /[^A-Za-z0-9]/\", \"\", $s1);\n$n = min(strlen($s0), strlen($s1));\nfor ($i =\
    \ 0; $i < $n; $i++) {\n    if ($s1[$i] !== $s0[$i]) {\n        echo \"False\"\
    ;\n        die;\n    }\n}", "    return preg_match('/(.)\\\\1{2,}/', $s0) == preg_match('/(.)\\\
    \\1{2,}/', $s1);\n}\n", "    if (strlen($s0) > strlen($s1)) {\n        $s0 = $s1\
    \ . $s0;\n    }\n    sort($s0);\n    sort($s1);\n    return strcmp($s0, $s1) ===\
    \ 0;\n}\n", "    if ($s0 === $s1) {\n        return true;\n    }\n    if (strlen($s0)\
    \ != strlen($s1)) {\n        return false;\n    }\n    for ($i = 0; $i < strlen($s0);\
    \ ++$i) {\n        if (ord($s0[$i]) != ord($s1[$i])) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    It is a good solution, but it will fail if there is \"aaa\" in `$s0` or `$s1`\n\
    <|/ c |>\n<| c |>\nYes but this was not the case in the original question\n<|/\
    \ c |>\n<| c |>\nYou are right. But if the OP wants to use my solution he should\
    \ give more details on the type of inputs he will provide.\n<|/ c |>\n<| c |>\n\
    What I meant was that if you test \"eabcd\" with his `same_chars` function you\
    \ will get False, not True.\n<|/ c |>\n<| c |>\nYes this is true\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "    if (strlen($s0) != strlen($s1)) {\n        return\
    \ false;\n    }\n    $c0 = $s0;\n    $c1 = $s1;\n    $c0 = preg_replace('/.?$/',\
    \ '', $c0);\n    $c1 = preg_replace('/.?$/', '', $c1);\n    if ($c0 == $c1) {\n\
    \        return true;\n    }\n    if ($c0 == '' && $c1 == '')\n        return\
    \ true;\n    return false;\n}", "    $s0 = str_split($s0);\n    $s1 = str_split($s1);\n\
    \    sort($s0, SORT_STRING);\n    sort($s1, SORT_STRING);\n    if ($s0 === $s1)\
    \ {\n        return true;\n    }\n    $n_chars_s0 = count($s0);\n    $n_chars_s1\
    \ = count($s1);\n    if ($n_chars_s0 !== $n_chars_s1) {\n        return false;\n\
    \    }\n    $i = 0;\n    while ($i < $n_chars_s0 && $i < $n_chars_s1) {\n    \
    \    if ($s0[$i] !== $s1[$i]) {\n            return false;\n        }\n      \
    \  $i++;\n    }\n    if ($n_chars_s0 !== $i) {\n        return false;\n    }\n\
    \    return true;\n}", "    $n0 = strlen($s0);\n    $n1 = strlen($s1);\n    if\
    \ ($n0 === $n1) {\n        $res = TRUE;\n        for ($i = 0; $i < $n0; ++$i)\
    \ {\n            if ($s0 [$i] !== $s1 [$i]) {\n                $res = FALSE;\n\
    \            }\n        }\n        return $res;\n    }\n    return FALSE;\n}\n",
  "  $s0 = preg_replace('/[^a-zA-Z0-9\\s]/', '', $s0);\n  $s1 = preg_replace('/[^a-zA-Z0-9\\\
    s]/', '', $s1);\n  return $s0 === $s1;\n}\n", "    $same = 0;\n    $len0 = mb_strlen($s0,\
    \ 'UTF-8');\n    $len1 = mb_strlen($s1, 'UTF-8');\n    for($i = 0; $i < $len0;\
    \ $i++) {\n        $char = mb_substr($s0, $i, 1, 'UTF-8');\n        $char1 = mb_substr($s1,\
    \ $i, 1, 'UTF-8');\n        if($char !== $char1) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ your answer. This was extremely helpful for me, and I really appreciate it.\
    \ I have added my full answer to the original question. Hopefully this will help\
    \ anyone else who needs this.\n<|/ c |>\n<| c |>\nI agree with you and I think\
    \ this should be an accepted answer.\n<|/ c |>\n<| a tags=php,algorithm |>\nThis\
    \ can be done using preg_replace:\n<code>\n$input = preg_replace('/(\\w)\\1+/',\
    \ '\\\\1', $input);\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for your answer.\
    \ This was extremely helpful for me, and I really appreciate it. I have added\
    \ my full answer to the original question. Hopefully this will help anyone else\
    \ who needs this.\n<|/ c |>\n<| c |>\nI agree with you and I think this should\
    \ be an accepted answer.\n<|/ c |>\n<| a tags=php,algorithm |>\nI wrote this answer,\
    \ which uses strtr function to replace all duplicate chars:\n<code>", "    $s0arr\
    \ = str_split($s0);\n    $s1arr = str_split($s1);\n\n    return count(array_intersect($s0arr,\
    \ $s1arr)) == count($s0arr);\n}\n", "    return preg_match('/(.)\\1{2,}/', $s0)\
    \ && preg_match('/(.)\\1{2,}/', $s1);\n}\n", "  // Create a frequency map of the\
    \ characters.\n  $f0 = count_chars($s0);\n  $f1 = count_chars($s1);\n  // Sort\
    \ $f1 and $f0 by keys in ascending order\n  // to make the code below more readable.\n\
    \  arsort($f1);\n  arsort($f0);\n  // Find out if there are any characters in\
    \ common\n  // between the two strings using $f1.\n  $common = array_intersect_key($f1,\
    \ $f0);\n  // If there are any characters in common, then\n  // return False if\
    \ they're not the same characters,\n  // or True if they're the same characters.\n\
    \  return (count($common) > 0);\n}\n", "  \n  // If the two strings have the same\
    \ length, they are equal.\n  // >>> same_chars('abcd', 'abcd')\n  // True\n  //\
    \ >>> same_chars('abcd', 'abca')\n  // False\n  if (strlen($s0) == strlen($s1))\
    \ {\n    return true;\n  }\n  \n  // Otherwise, try to find all the letters in\
    \ both strings.\n  // >>> same_chars('abca', 'abcd')\n  // False\n  // >>> same_chars('abca',\
    \ 'abca')\n  // True\n  // >>> same_chars('abca', 'abcdab')\n  // True\n  // >>>\
    \ same_chars('abca', 'abcdabc')\n  // False\n  // >>> same_chars('abca', 'abcdac')\n\
    \  // True\n  // >>> same_chars('abca', 'abcdabcde')\n  // True\n  // >>> same_chars('abca',\
    \ 'abcdabcdeef')\n  // True\n  // >>> same_chars('abca', 'abcdabcdeeff')\n  //\
    \ True\n  // >>> same_chars('abca', 'abcdabcdeeffab')\n  // True\n  // >>> same_chars('abca',\
    \ 'abcaabcaa')\n  // True\n  // >>> same_chars('abca', 'abcaabcaaabc')\n  // False\n\
    \  // >>> same_chars('abca', 'abcaabcaadef')\n  // False\n  // >>> same_chars('abca',\
    \ 'abcaabcaadefgh')\n  // False\n  // >>> same_chars('abca', 'abcaabcaadefghij')\n\
    \  // False\n  // >>> same_chars('abca', 'abcaabcaadefghijk')\n  // False\n  //\
    \ >>> same_chars('abca', 'abcaabcaadefghijkl')\n  // False\n  // >>> same_chars('abca',\
    \ 'abcaabcaadefghijklm')\n  // False\n  // >>> same_chars('abca', 'abcaabcaadefghijklmnopq')\n\
    \  // False\n  // >>> same_chars('abca', 'abcaabcaadefghijklmnopqrstuvwxy')\n\
    \  // False\n  // >>> same_chars('abca', 'abcaabcaadefghijklmnopqrstuvwxyu')\n\
    \  // False\n  // >>> same_chars('abca', 'abcaabcaadefghijklmnopqrstuvwxyuv')\n\
    \  // False\n  // >>> same_chars('abca', 'abcaabcaadefghijklmnopqrstuvwxyuvw",
  "    $s0 = preg_replace('/[^a-z0-9A-Z]/', '', $s0);\n    $s1 = preg_replace('/[^a-z0-9A-Z]/',\
    \ '', $s1);\n    if ($s0 === $s1) {\n        return true;\n    }\n    $n = max(strlen($s0),\
    \ strlen($s1));\n    $c = count(str_split($s0));\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        $d = $s1[$i];\n        $j = ($i + 1) % $n;\n        if ($s1[$i] !==\
    \ $s1[$j]) {\n            return false;\n        }\n    }\n    $k = 0;\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        $d = $s1[$i];\n        $j = ($i + 1) % $n;\n\
    \        $k = ($k + $c[$i]) % $n;\n        if ($s1[$i] !== $s1[$j]) {\n      \
    \      return false;\n        }\n    }\n    return ($k !== $n);\n}\n", "    $s0\
    \ = str_replace(' ', '', $s0);\n    $s1 = str_replace(' ', '', $s1);\n    $len0\
    \ = strlen($s0);\n    $len1 = strlen($s1);\n    if ($len0 != $len1) {\n      \
    \  return false;\n    }\n    $sum = 0;\n    for ($i = 0; $i < $len0; $i++) {\n\
    \        $sum += strpos($s0, $s1[$i]) ? 1 : 0;\n    }\n    return $sum == $len0;\n\
    }\n</code>\n<|/ a dscore=1 tags=algorithm,language-agnostic,language-agnostic\
    \ |>\n<| a tags=algorithm,language-agnostic,language-agnostic |>\nAssuming each\
    \ letter can only be used once:\n<code>\na   c   e   h   i   l   l   p   r   r\
    \   r   u   w   y   z\na   b   b   b   b   b   b   b   b   b   b   b   b   b \
    \  b\nc   d   e   e   e   e   e   e   e   e   e   e   e   e   e\nf   g   g   g\
    \   g   g   g   g   g   g   g   g   g   g   g\ni   i   i   i   i   i   i   i \
    \  i   i   i   i   i   i\nl   l   l   l   l   l   l   l   l   l   l   l   l  \
    \ l   l\nm   n   o   p   p   p   p   p   p   p   p   p   p   p   p\nr   s   t\
    \   t   t   t   t   t   t   t   t   t   t   t   t\nu   u   u   v   w   w   w \
    \  w   w   w   w   w   w   w   w\nw   w   w   w   w   w   w   w   w   w   w  \
    \ w   w   w   w\nx   x   x   x   x   x   x   x   x   x   x   x   x   x   x\ny\
    \   z   z   z   z   z   z   z   z   z   z   z   z   z   z\n</code>\n<|/ a dscore=0 ",
  "    $s0 = preg_replace('/[^a-z ]/', '', strtolower($s0));\n    $s1 = preg_replace('/[^a-z\
    \ ]/', '', strtolower($s1));\n    return (strlen($s0) == strlen($s1) && count(array_intersect($s0,\
    \ $s1)) == strlen($s0));\n}\n", "    $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n\
    \    if (strlen($s0) > strlen($s1)) {\n        return false;\n    }\n    for ($i\
    \ = 0; $i < strlen($s0); ++$i) {\n        if ($s1[$i] != $s0[$i]) {\n        \
    \    return false;\n        }\n    }\n    return true;\n}\n", "    $len_s_0  =\
    \ strlen($s0);\n    $len_s_1  = strlen($s1);\n\n    for ($i = 0; $i < $len_s_0;\
    \ $i++){\n        for ($j = 0; $j < $len_s_1; $j++){\n            if ($s0[$i]\
    \ != $s1[$j])\n                return false;\n        }\n    }\n    return true;\n\
    }\n", "  $len0 = strlen($s0);\n  $len1 = strlen($s1);\n\n  for ($i = 0; $i < $len0;\
    \ $i++) {\n    if ($s1[$i] != $s0[$i]) return false;\n  }\n\n  for ($i = 0; $i\
    \ < $len1; $i++) {\n    if ($s1[$i] != $s0[$len0 - $i - 1]) return false;\n  }\n\
    \n  return true;\n}\n", "    $n_s0 = strlen($s0);\n    $n_s1 = strlen($s1);\n\
    \    $len_s0 = mb_strlen($s0);\n    $len_s1 = mb_strlen($s1);\n    for ($i = 0;\
    \ $i < $n_s0; ++$i) {\n        if ($s0[$i] != $s1[$i]) return false;\n    }\n\
    \    for ($i = 0; $i < $len_s0; ++$i) {\n        if ($s0[$i] != $s1[$len_s0 -\
    \ 1 - $i]) return false;\n    }\n    return true;\n}\n", "    $a0 = str_split($s0);\n\
    \    $a1 = str_split($s1);\n    foreach ($a0 as $a => $b0) $a1[$a] == $b0;\n \
    \   return $a1 == $a0;\n}", "  return $s0 == $s1 || $s0 == $s1[strlen($s0)];\n\
    }\n</code>\nThen I created a function for comparing strings ignoring case.\n<code>",
  "    if (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n    $result\
    \ = 0;\n    for ($i = 0; $i < strlen($s0); ++$i) {\n        $result |= ord($s0[$i])\
    \ ^ ord($s1[$i]);\n    }\n    return $result == 0;\n}\n</code>\n<|/ a tags=php,algorithm,combinatorics\
    \ dscore=1 |>\n<| c |>\nPlease read my question again and also the other answers.\n\
    <|/ c |>\n<| c |>\nI read your question again and I edited my answer, hope it\
    \ helps you.\n<|/ c |>\n<| c |>\nI read your question again and I edited my answer,\
    \ hope it helps you.\n<|/ c |>\n<| c |>\nI added a solution with php code that\
    \ works with the words you provided.\n<|/ c |>\n<| c |>\nHm, I see you got two\
    \ downvotes on your answer because you edited it to include a python solution.\
    \ I'm still not convinced you didn't get upvotes. I really want to know why, but\
    \ I'm going to assume because you had an incorrect answer, and I didn't even realise\
    \ you had changed it.\n<|/ c |>\n<| a |>\nThis is an old question, but for those\
    \ coming here from Google, I thought I'd add my answer.\nThere are lots of ways\
    \ to do this, one of which is called dynamic programming.\nDynamic programming\
    \ is about breaking problems down into smaller parts and then solving those parts\
    \ independently of the problem it solves. \nThe way I look at this is breaking\
    \ down problems into simpler problems and solving those simpler problems individually.\n\
    In this case, if you have a problem that consists of two strings and you want\
    \ to find the two strings that result in the same characters, you solve the problem\
    \ by breaking it down to finding pairs of strings and then solving the pairs individually\
    \ by breaking down those pairs.\nHere's a simple PHP implementation:\n<code>",
  "    $s_length1 = strlen($s1);\n    $s_length2 = strlen($s2);\n    $f_length1 =\
    \ strlen($s0);\n    $f_length2 = strlen($s1);\n\n    for ($i = 0; $i < $s_length1;\
    \ $i++)\n        for ($j = 0; $j < $s_length2; $j++)\n            for ($k = 0;\
    \ $k < $f_length2; $k++)\n                if ($s1[$i] == $s2[$j] && $s0[$i] ==\
    \ $s0[$k])\n                    return true;\n    return false;\n}\n", "    if\
    \ (strlen($s0) == 0) {\n        $s0 = $s1;\n    }\n\n    if (strlen($s1) == 0)\
    \ {\n        $s1 = $s0;\n    }\n\n    // Loop over each possible character.\n\
    \    for ($i = 0; $i < strlen($s0); $i++) {\n        for ($j = 0; $j < strlen($s1);\
    \ $j++) {\n            // If both characters are the same, then they're the same.\n\
    \            if ($s0[$i] == $s1[$j]) {\n                continue;\n          \
    \  }\n\n            // If they're different and neither is an empty string, they\
    \ aren't the same.\n            if ($s0[$i] != '' && $s1[$j] != '' && $s0[$i]\
    \ != $s1[$j]) {\n                return false;\n            }\n        }\n   \
    \ }\n\n    // All of the characters are the same.\n    return true;\n}\n", " \
    \   $s0 = preg_replace('/\\W+/', ' ', $s0);\n    $s1 = preg_replace('/\\W+/',\
    \ ' ', $s1);\n    return strcmp($s0, $s1) === 0;\n}", "    $s1 = preg_replace('/(.)\\\
    1+/', \"$1\", '$s1', 1);\n    return ($s0 === $s1);\n}\n", "    $s_a = str_split($s0);\n\
    \    $s_b = str_split($s1);\n\n    $i = 0;\n    $j = 0;\n\n    foreach($s_a as\
    \ $ch) {\n        $i += strlen($ch);\n    }\n\n    foreach($s_b as $ch) {\n  \
    \      $j += strlen($ch);\n    }\n\n    return $i == $j;\n}\n</code>\n<|/ a tags=php,character,string\
    \ |>\n<| c |>\nWhat a beautiful solution! Thanks\n<|/ c |>\n<| c |>\nHappy to\
    \ help! :)\n<|/ c |>\n<| a dscore=5 tags=php,character,string |>\nI did this with\
    \ javascript only using regex. I don't think it's the best solution, but it works\
    \ fine.\n<code>", "    $c = count($s0);\n    $d = count($s1);\n    for($i=0; $i<$c;\
    \ $i++){\n        if ($s1[$i] != $s0[$i]){\n            return false;\n      \
    \  }\n    }\n    return $d == $c;\n}", "  // s0 has more characters\n  if (strlen($s0)\
    \ > strlen($s1)) {\n    return false;\n  }\n  \n  // s1 has more characters\n\
    \  if (strlen($s1) > strlen($s0)) {\n    return false;\n  }\n\n  $diff = strlen($s0)-1;\n\
    \  \n  for($i=0; $i<strlen($s1); $i++) {\n    $c0 = $s1[$i];\n    \n    while($c0\
    \ !== $s1[$i+$diff]) {\n      $diff--;\n      if ($diff < 0) {\n        return\
    \ false; // s1 has more characters than s0\n      }\n      \n      $i--;\n   \
    \   $c0 = $s1[$i];\n    }\n  }\n  \n  return true;\n}\n", "  preg_match_all('/(.)\\\
    1*/', $s0, $s0, PREG_PATTERN_ORDER);\n  preg_match_all('/(.)\\1*/', $s1, $s1,\
    \ PREG_PATTERN_ORDER);\n  return $s0_length == $s1_length && $s0_length == count(array_unique($s0[0]));\n\
    }\n\n/**\n * Check if two words have the same characters in different case.\n\
    \ * Case-insensitive.\n * >>> same_chars_ci('eabcdzzzz', 'dddzzzzzzzddeddabc')\n\
    \ * True\n * >>> same_chars_ci('abcd', 'dddddddabc')\n * True\n * >>> same_chars_ci('dddddddabc',\
    \ 'abcd')\n * True\n * >>> same_chars_ci('eabcd', 'dddddddabc')\n * False\n *\
    \ >>> same_chars_ci('abcd', 'dddddddabce')\n * False\n * >>> same_chars_ci('eabcdzzzz',\
    \ 'dddzzzzzzzddddabc')\n * False\n *\n * @param $s0 The first word.\n * @param\
    \ $s1 The second word.\n * @return True if the two words have the same characters\
    \ in different\n *     case, or False otherwise.\n */", "  return !strcmp(md5($s0,\
    \ TRUE), md5($s1, TRUE));\n}\n", "\t$s0c = strlen($s0);\n\t$s1c = strlen($s1);\n\
    \tif ($s0c != $s1c) return false;\n\t$i = 0;\n\t$j = 0;\n\t$done = false;\n\t\
    while ($i < $s0c || $j < $s1c) {\n\t\tif ($i == $j) $i++;\n\t\tif ($i == $s1c)\
    \ $j++;\n\t\tif ($j == $s0c) $j++;\n\t\tif ($s0[$i] == $s1[$j]) $i++;\n\t\telse\
    \ if ($s0[$i] != $s1[$j]) $done = true;\n\t\telse $j++;\n\t}\n\treturn $done;\n\
    }", "  return strlen($s0) == strlen($s1) && count(str_split($s0)) == count(str_split($s1));\n\
    }\n", "    $len = min(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $len;\
    \ ++$i) {\n        if ($s0 [$i] != $s1 [$i]) {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n", "\t$n = min(strlen($s0), strlen($s1));\n\
    \tfor ($i = 0; $i < $n; $i++)\n\t\tif ($s0[$i] != $s1[$i])\n\t\t\treturn false;\n\
    \treturn true;\n}", "  $s0 = $s0 . '';\n  $s1 = $s1 . '';\n  return $s0 === $s1;\n\
    }\n", "    $s1 = strtolower($s1);\n    $s0 = strtolower($s0);\n    $maxlen = (max(strlen($s0),\
    \ strlen($s1)) + 1);\n    for ($i = 0; $i < $maxlen; ++$i) {\n        if ($s1[$i]\
    \ != $s0[$i]) return false;\n    }\n    return true;\n}", "\treturn ($s0 === $s1)\
    \ || (ctype_alpha($s0) && ctype_alpha($s1) && count(array_filter(str_split($s0))\
    \ == count(str_split($s1)));\n}\n", "    $c1 = count_chars($s1);\n    $c2 = count_chars($s0);\n\
    \    if ($c1 == $c2) {\n        for ($i = 0; $i < $c1; $i++) {\n            if\
    \ ($s1[$i] == $s0[$i]) return true;\n        }\n    }\n    return false;\n}\n",
  "    // Checks if the strings are the same character length.\n    // >>> same_chars('abcd',\
    \ 'abcd')\n    // True\n    // >>> same_chars('eabcd', 'eabcd')\n    // False\n\
    \    // >>> same_chars('eabcd', 'ebcd')\n    // False\n    // >>> same_chars('abcd',\
    \ 'eabcd')\n    // False\n    return strlen($s0) == strlen($s1) && preg_match('/^./',\
    \ str_replace($s0, '', $s1)) && preg_match('/^./', str_replace($s1, '', $s0));\n\
    }\n\n/**\n * Checks if the given password is strong enough to continue.\n * Checks\
    \ for at least 7 characters and has at least one non-alphanumeric character.\n\
    \ * Uses a strong password criteria from Django 1.5.2.\n *\n * >>> is_strong_enough('mypassword')\n\
    \ * True\n * >>> is_strong_enough('mypassword123')\n * True\n * >>> is_strong_enough('mypassword123')\n\
    \ * True\n * >>> is_strong_enough('mypassword123mypassword123')\n * True\n * >>>\
    \ is_strong_enough('mypassword123mypassword123mypassword123')\n * False\n * >>>\
    \ is_strong_enough('mypassword123mypassword123mypassword123mypassword123')\n *\
    \ False\n * >>> is_strong_enough('mypassword123mypassword123mypassword123mypassword123mypassword123')\n\
    \ * True\n *\n * @param string $password\n * @return bool\n */", "    $i0 = strpos($s0,\
    \ 'e');\n    $i1 = strpos($s1, 'e');\n    if ($i0 === false || $i1 === false ||\
    \ $i0 > $i1) {\n        return false;\n    }\n    $d0 = substr($s0, $i0);\n  \
    \  $d1 = substr($s1, $i1);\n    $n = min(strlen($d0), strlen($d1));\n    if ($n\
    \ !== 0) {\n        return $d0 == $d1;\n    }\n    return $s0 == $s1;\n}\n", " \
    \   return preg_match('/^(.)\\1*$/', $s0) == preg_match('/^(.)\\1*$/', $s1);\n\
    }\n", "    $l0 = mb_strlen($s0);\n    $l1 = mb_strlen($s1);\n    for ($i = 0;\
    \ $i < $l0; $i++) {\n        if ($s0[$i] !== $s1[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  $s0 = strtolower($s0);\n  $s1 =\
    \ strtolower($s1);\n  $n0 = strlen($s0);\n  $n1 = strlen($s1);\n  $l0 = $n0 -\
    \ 1;\n  $l1 = $n1 - 1;\n  for ($i = 0; $i < $l0; $i++) {\n    $i0 = ord($s0[$i]);\n\
    \    $i1 = ord($s1[$i]);\n    if ($i0 != $i1) {\n      if ($i0 == $i1) {\n   \
    \     return true;\n      }\n      if ($i0 < $i1) {\n        $i1 = ($i1 - $i0);\n\
    \      } else {\n        $i0 = (($i0 - $i1) + $i1);\n      }\n    }\n  }\n  return\
    \ false;\n}\n", "    if (!is_string($s0) || !is_string($s1) || strlen($s0) !=\
    \ strlen($s1)) {\n        return false;\n    }\n    $result = 0;\n    for ($i\
    \ = 0; $i < strlen($s0); $i++) {\n        $result |= ord($s0[$i]) ^ ord($s1[$i]);\n\
    \    }\n    return ($result == 0);\n}\n</code>\n<|/ a tags=php,algorithm |>\n\
    <| c |>\nThis doesn't work for `0` or `1`\n<|/ c |>\n<| c |>\nIt works exactly\
    \ as the question asked. The code in the question will throw a PHP Parse error\
    \ if it receives something other than a string\n<|/ c |>\n<| c |>\nOkay, that's\
    \ a difference between `is_numeric` and `is_string`.  I always get confused about\
    \ these two things.\n<|/ c |>\n<| c |>\nIt's really just a difference in what\
    \ those function names mean. `is_numeric` is checking if a string contains a number\
    \ while `is_string` is checking if that string is a string. `is_numeric` also\
    \ throws a Parse Error on `0` or `1` while `is_string` does not. `is_numeric`\
    \ is more reliable as it doesn't throw a Parse Error on `0`\n<|/ c |>\n<| c |>\n\
    This works only if both strings are the same length. It also fails when one of\
    \ the strings is longer than the other one.\n<|/ c |>\n<| a dscore=5 |>\nIf you're\
    \ looking for performance (and not just for fun), I would use a bit of XOR instead\
    \ of looping through the strings.\n<code>", "    $s1 = str_replace(array('z','t','e','a','o','i','o','u','n','c','s'),\n\
    \        'ztzetaoiaouync', $s1);\n    $s0 = str_replace(array('z','t','e','a','o','i','o','u','n','c','s'),\n\
    \        'ztzetaoiaouync', $s0);\n\n    return strlen($s0) == strlen($s1) &&\n\
    \        str_repeat($s0, strlen($s1)) == $s1;\n}\n", "    $s0 = strtolower($s0);\n\
    \    $s1 = strtolower($s1);\n    $s0 = preg_replace('/[\u017C\u017A\u0107\u0144\
    \u0118\xD3\u0179\u0143\xD3\u0141\u017B\u0179]/', 'z', $s0);\n    $s1 = preg_replace('/[\u017C\
    \u017A\u0107\u0144\u0118\xD3\u0179\u0143\xD3\u0141\u017B\u0179]/', 'z', $s1);\n\
    \    $s0 = preg_replace('/[\u0105\u0104\u0107\u0119\u0142\u0144\u017C\u017A\u015B\
    \u0118\u0179\u017A\u017C\u0141]/', 'a', $s0);\n    $s1 = preg_replace('/[\u0105\
    \u0104\u0107\u0119\u0142\u0144\u017C\u017A\u015B\u0118\u0179\u017A\u017C\u0141\
    ]/', 'a', $s1);\n    $s0 = preg_replace('/[\u017A\u017C\u0144\u0118\xD3\u0179\u0143\
    \xD3\u0141\u0104\u0107\u0119\u0142]/', 'y', $s0);\n    $s1 = preg_replace('/[\u017A\
    \u017C\u0144\u0118\xD3\u0179\u0143\xD3\u0141\u0104\u0107\u0119\u0142]/', 'y',\
    \ $s1);\n    $s0 = preg_replace('/[\u0141\u0143\xD3\u0179\u017A\u017C\u0104\u0107\
    \u0119\u0142\u0144]/', 'o', $s0);\n    $s1 = preg_replace('/[\u0141\u0143\xD3\u0179\
    \u017A\u017C\u0104\u0107\u0119\u0142\u0144]/', 'o', $s1);\n    $s0 = preg_replace('/[\u015B\
    \u0107\u0144\u017A\u0104\u0118\u0143\xD3\u0179\u017A\u017C\u0118]/', 'e', $s0);\n\
    \    $s1 = preg_replace('/[\u015B\u0107\u0144\u017A\u0104\u0118\u0143\xD3\u0179\
    \u017A\u017C\u0118]/', 'e', $s1);\n    $s0 = preg_replace('/[\u017B\u017A\u0144\
    \u0104\u0118\xD3\u0179\u0143\xD3\u0141\u017B\u0179]/', 's', $s0);\n    $s1 = preg_replace('/[\u017B\
    \u017A\u0144\u0104\u0118\xD3\u0179\u0143\xD3\u0141\u017B\u0179]/', 's', $s1);\n\
    \    $s0 = preg_replace('/[\u0104\u0107\u0119\u0142\u0144\u017C\u017A\u015B\u0118\
    \u0179\u017A\u017C\u0141]/', 'n', $s0);\n", "  $s0len = $s0 ? strlen($s0) : 0;\n\
    \  $s1len = $s1 ? strlen($s1) : 0;\n  if ($s0len == 0 || $s1len == 0) {\n    return\
    \ $s0len == $s1len;\n  }\n  $s0len = max($s0len, 1);\n  $s1len = max($s1len, 1);\n\
    \  $len = max($s0len, $s1len);\n  if ($s0len == 1) {\n    if ($s1len == 1) {\n\
    \      return $s0[0] == $s1[0];\n    }\n    return $s0 != '';\n  }\n  if ($s1len\
    \ == 1) {\n    return $s0 != '';\n  }\n  $len = 0;\n  $s0 = preg_replace('/./',\
    \ '', $s0);\n  $s1 = preg_replace('/./', '', $s1);\n  $len += strlen($s0);\n \
    \ for ($i = 0; $i < $len; $i++) {\n    if ($s0[$i] != $s1[$i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "    $s0 = str_replace(' ', '', $s0);\n\
    \    $s1 = str_replace(' ', '', $s1);\n    \n    if (strlen($s0) != strlen($s1))\
    \ {\n        return false;\n    }\n    \n    foreach (str_split($s0, 1) as $k0\
    \ => $c) {\n        if ($c != $s1[$k0]) {\n            return false;\n       \
    \ }\n    }\n    \n    return true;\n}\n", "\treturn strlen($s0) == strlen($s1)\
    \ && $s0 === $s1;\n}", "    $s0 = str_replace(\" \", \"\", $s0);\n    $s1 = str_replace(\"\
    \ \", \"\", $s1);\n\n    if (count($s0) > count($s1)) {\n        return false;\n\
    \    } elseif (count($s0) < count($s1)) {\n        return true;\n    }\n\n   \
    \ for ($i = 0; $i < count($s0); $i++) {\n        if ($s1[$i] != $s0[$i]) {\n \
    \           return false;\n        }\n    }\n\n    return true;\n}", "    return\
    \ $s0 === $s1 ||\n        ($s0 === '' ||\n         strpos($s0, $s1) !== FALSE);\n\
    }\n</code>\n<|/ a tags=string,php |>\n<| c |>\nYes this is what i want, i will\
    \ try it\n<|/ c |>\n<| c |>\nThank you! I like that way better than mine\n<|/\
    \ c |>\n<| c |>\nBut it still fails tests. You also need to take into account\
    \ that a string can be longer than a word and still be valid\n<|/ c |>\n<| c |>\n\
    But you said that words are of variable length. And this solution is independent\
    \ of the length of a word\n<|/ c |>\n<| c |>\nI mean if the string doesn't contain\
    \ an alphabet it shouldn't fail.\n<|/ c |>\n<| a |>\nYou could do something like\
    \ this:\n<code>", "  if (strlen($s0) != strlen($s1))\n    return false;\n  $res\
    \ = 0;\n  for ($i = 0; $i < strlen($s0); $i++) {\n    $res = ($s1[$i] == $s0[$i])\
    \ ? $res + 1 : $res;\n  }\n  return $res == strlen($s0);\n}\n", "    return strlen($s0)\
    \ == strlen($s1) &&\n        !strcmp($s0, $s1);\n}", "    if (strlen($s0) != strlen($s1))\n\
    \        return false;\n\n    for ($i = 0; $i < strlen($s0); ++$i) {\n       \
    \ if ($s1[$i] != $s0[$i])\n            return false;\n    }\n\n    return true;\n\
    }\n", "    $s_len1 = strlen($s1);\n    $s_len0 = strlen($s0);\n    for ($i = 0;\
    \ $i < $s_len1; $i++) {\n        $d = ord($s0[$i]) - ord($s1[$i]);\n        if\
    \ ($d !== 0)\n            return ($d > 0);\n    }\n    return ($s_len0 < $s_len1);\n\
    }\n\n$s0 = $words[0];\n$s1 = $words[1];\n$s2 = $words[2];\n$s3 = $words[3];\n\
    $s4 = $words[4];\n$s5 = $words[5];\n$s6 = $words[6];\n$s7 = $words[7];\n$s8 =\
    \ $words[8];\n$s9 = $words[9];\n", "    $n0 = strlen($s0);\n    $n1 = strlen($s1);\n\
    \    $sum = 0;\n    for($i = 0; $i < $n0; ++$i)\n        for($j = 0; $j < $n1;\
    \ ++$j)\n            $sum += (ord($s0[$i]) == ord($s1[$j]));\n    return ($sum\
    \ == $n0);\n}\n", "    $s0 = preg_replace('/[^a-z]/',\"\",$s0);\n    $s1 = preg_replace('/[^a-z]/',\"\
    \",$s1);\n    if ($s0 != $s1) {\n        return false;\n    }\n    return count($s0)\
    \ == count($s1);\n}\n$a1 = array(\"ab\",\"ac\",\"bd\",\" \",\"c\");\n$a2 = array(\"\
    ab\",\"ac\",\" \",\"c\",\"bd\",\" \");\n$a3 = array(\"ab\",\"ac\",\"bd\",\" \"\
    ,\" \",\"c\");\n$a4 = array(\"ab\",\" \",\"c\",\"bd\",\" \");\n$a5 = array(\"\
    ab\",\"ac\",\" \",\"c\",\"bd\",\" \",\"ac\");\n$a6 = array(\"ab\",\"ac\",\"bd\"\
    ,\" \",\" \",\"c\",\"ad\",\" \",\"cd\");\n$a7 = array(\"ab\",\"ac\",\"bd\",\"\
    \ \",\" \",\"c\",\"ad\",\" \",\"cd\",\" \",\"ef\");\n$a8 = array(\"ab\",\"ac\"\
    ,\"bd\",\" \",\" \",\"c\",\"ad\",\" \",\"cd\",\" \",\"ef\",\" \",\"gh\");\n$a9\
    \ = array(\"ab\",\"ac\",\"bd\",\" \",\" \",\"c\",\"ad\",\" \",\"cd\",\" \",\"\
    ef\",\" \",\" \");\n\n$a10 = array(\"a\",\"b\",\"c\",\"d\",\"e\");\n$a11 = array(\"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\");\n$a12 = array(\"a\",\"b\"\
    ,\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\" \",\"n\"\
    ,\"o\",\"p\",\"q\",\"r\",\"s\");\n$a13 = array(\"a\",\"b\",\"c\",\"d\",\"e\",\"\
    f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\" \",\"n\",\"o\",\"p\",\"q\",\"\
    r\",\"s\",\" \",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"a\",\"b\",\"c\",\"\
    d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\" \",\"n\",\"o\",\"\
    p\",\"q\",\"r\",\"s\",\" \",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"a\",\"\
    b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\" \",\"\
    n\",\"o\",\"p\",\"q\",\"r\",\"s\",\" \",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\");\n\n", "  return $s0 == $s1 || substr($s0, strlen($s0)) == substr($s1, strlen($s1));\n\
    }\n", "    $s0 = $s0 ? $s0 : '';\n    $s1 = $s1 ? $s1 : '';\n    $count = substr_count($s0,\
    \ $s1);\n    return $count == 0;\n}\n", "    $len = min(strlen($s0), strlen($s1));\n\
    \    $same = 0;\n    for ($i = 0; $i < $len; $i++) {\n        if ($s1[$i] != $s0[$i])\
    \ {\n            return $same;\n        }\n    }\n    return $same == $len;\n\
    }\n\n/**\n * Check if a string contains a given string.\n * >>> string_in_camelcase('hello\
    \ world', 'hello world')\n * True\n * >>> string_in_camelcase('hello world', 'HELLO\
    \ WORLD')\n * False\n * >>> string_in_camelcase('hello world', 'hello-world')\n\
    \ * False\n * >>> string_in_camelcase('hello world', 'HelloWorld')\n * True\n\
    \ * >>> string_in_camelcase('hello world', 'HellO WoRlD')\n * True\n * >>> string_in_camelcase('hello\
    \ world', 'HELLO WORLD !!')\n * True\n * >>> string_in_camelcase('hello world',\
    \ 'Hello World!!')\n * False\n * >>> string_in_camelcase('hello world', 'Hello\
    \ World !!')\n * False\n * >>> string_in_camelcase('hello world', 'Hello-World')\n\
    \ * True\n * >>> string_in_camelcase('hello world', 'HelLO-World')\n * True\n\
    \ * >>> string_in_camelcase('hello world', 'HELLO WORLD!!')\n * False\n * >>>\
    \ string_in_camelcase('hello world', 'Hello World!!!')\n * False\n * >>> string_in_camelcase('hello\
    \ world', 'Hello World !!!')\n * False\n * >>> string_in_camelcase('hello world',\
    \ 'Hello-World')\n * True\n * >>> string_in_camelcase('hello world', 'HellO WoRlD')\n\
    \ * True\n * >>> string_in_camelcase('hello world', 'HelLO WORLD!!')\n * False\n\
    \ * >>> string_in_camelcase('hello world', 'Hello World!!!')\n * False\n * >>>\
    \ string_in_camelcase('hello world', 'Hello World !!!')\n * False\n * >>> string_in_camelcase('hello\
    \ world', 'Hello-World')\n * True\n * >>> string_in_camelcase('hello world', 'HelLO-World')\n\
    \ * True\n * >>> string_in_camelcase('hello world', 'HELLO WORLD!!!')", "  $n0\
    \ = strlen($s0);\n  $n1 = strlen($s1);\n  $c = array();\n  for ($x = 0; $x < $n0;\
    \ $x++) {\n    $c[$x] = 0;\n  }\n  for ($x = 0; $x < $n1; $x++) {\n    $c[$x]\
    \ = 0;\n  }\n  for ($x = 0; $x < $n0; $x++) {\n    for ($y = 0; $y < $n1; $y++)\
    \ {\n      if ($s1[$y] != $s0[$x]) {\n        $c[$x] = 1;\n      }\n    }\n  }\n\
    \  return !($n0 == 0);\n}\n", "    if (strlen($s0) > strlen($s1))\n        return\
    \ false;\n\n    if (strlen($s0) < strlen($s1))\n        return true;\n\n    $s0\
    \ = strtolower($s0);\n    $s1 = strtolower($s1);\n\n    for($i = 0, $s = strlen($s0);\
    \ $i < $s; $i++) {\n        if ($s1[$i] != $s0[$i])\n            return false;\n\
    \    }\n\n    return true;\n}\n</code>\n<|/ a dscore=5 tags=string,php |>\n<|\
    \ a dscore=5 |>\nJust for fun, here's a one-liner that checks whether two strings\
    \ are anagrams. \n<code>\n$s0 = str_split($s0);\n$s1 = str_split($s1);\n\n$diff\
    \ = array_diff($s0, $s1);\n\nif (empty($diff)) {\n    echo \"Anagram.\";\n} else\
    \ {\n    echo \"Not anagram.\";\n}\n</code>\n<|/ a tags=string,php |>\n<| c |>\n\
    A single line answer... Nice!\n<|/ c |>\n<| c |>\nIt works for me, but when I\
    \ am comparing two anagram strings I am getting this message: Not anagram.\n<|/\
    \ c |>\n<| c |>\nI think it does work, but my solution does. I have updated the\
    \ answer. BTW your solution also works just fine.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php\n", "\tif (strlen($s0) == 0) {\n\t\treturn false;\n\t} elseif (strlen($s1)\
    \ == 0) {\n\t\treturn false;\n\t} elseif (strlen($s0) > strlen($s1)) {\n\t\t$s0\
    \ = wordwrap($s0, 2, '');\n\t} elseif (strlen($s1) > strlen($s0)) {\n\t\t$s1 =\
    \ wordwrap($s1, 2, '');\n\t}\n\t\n\t$c0 = strtolower($s0);\n\t$c1 = strtolower($s1);\n\
    \t\n\tfor ($i = 0; $i < strlen($c0); $i++) {\n\t\tif ($c0[$i] != $c1[$i]) {\n\t\
    \t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n", "  // Set up arrays for\
    \ searching.\n  $i0 = strlen($s0);\n  $i1 = strlen($s1);\n  $m0 = array();\n \
    \ $m1 = array();\n  $i = 0;\n\n  // Search each string to see if it matches.\n\
    \  for ($i = 0; $i < $i0; $i++) {\n    $m0[$i] = 0;\n  }\n  for ($i = 0; $i <\
    \ $i1; $i++) {\n    $m1[$i] = 0;\n  }\n\n  // Search for characters in each string.\n\
    \  for ($i = 0; $i < $i1; $i++) {\n    if ($s1[$i] == $s0[$i]) {\n      $m1[$i]\
    \ = $m1[$i] + 1;\n    } else {\n      if ($m1[$i] >= $m0[$i]) {\n        $m1[$i]\
    \ = 1;\n      }\n    }\n  }\n\n  // Check the matches.\n  $result = 0;\n  for\
    \ ($i = 0; $i < $i1; $i++) {\n    if ($m1[$i] >= $m0[$i]) {\n      $result = 1;\n\
    \    }\n  }\n\n  return $result;\n}", "    return preg_match_all('/(?=[^a-zA-Z])/',\
    \ $s0) && preg_match_all('/(?=[^a-zA-Z])/', $s1);\n}\n", "  return preg_match('/'\
    \ . preg_quote($s0) . '|' . preg_quote($s1) . '/', $s0) == 1;\n}", "    $s0_count\
    \ = count($s0);\n    $s1_count = count($s1);\n    if ($s0_count != $s1_count)\
    \ return false;\n    for ($i = 0; $i < $s0_count; $i++) {\n        if (ord($s0[$i])\
    \ != ord($s1[$i])) return false;\n    }\n    return true;\n}\n", "    if (strlen($s0)\
    \ == 0)\n        return strlen($s1) == 0;\n    if (strlen($s1) == 0)\n       \
    \ return strlen($s0) == 0;\n    $same = true;\n    for ($i = 0; $i < strlen($s0);\
    \ $i++)\n        if ($s0[$i] != $s1[$i])\n            $same = false;\n    return\
    \ $same;\n}\n", "    $s1 = strtr($s1, 'a' => '\\0', 'z' => '\\0');\n    $s0 =\
    \ strtr($s0, 'a' => '\\0', 'z' => '\\0');\n    $len = min(strlen($s0), strlen($s1));\n\
    \n    for ($i = 0; $i < $len; $i++) {\n        if ($s1[$i] != $s0[$i]) return\
    \ false;\n    }\n    return true;\n}\n", "\t$c0 = $s0;\n\t$c1 = $s1;\n\t$len0\
    \ = strlen($c0);\n\t$len1 = strlen($c1);\n\tif ($len0 != $len1) {\n\t\treturn\
    \ false;\n\t}\n\tfor ($i = 0; $i < $len0; $i++) {\n\t\tif ($c0[$i] != $c1[$i])\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "    return $s0 ===\
    \ $s1 || str_ireplace($s0, '', $s0) === str_ireplace($s1, '', $s1);\n}\n", " \
    \ $s0 = str_split($s0);\n  $s1 = str_split($s1);\n  $a = count($s0);\n  $b = count($s1);\n\
    \  \n  foreach($s0 as $k => $v)\n    if(!isset($s1[$k]) || $s1[$k] != $v)\n  \
    \    return false;\n  return $a == $b;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\n\
    That's a very interesting approach. Thank you. Could you give an explanation why\
    \ you loop through the characters instead of the string length?\n<|/ c |>\n<|\
    \ c |>\nThe loop through the characters is necessary because the characters in\
    \ the string might not be ASCII characters. If you check the `ord` function in\
    \ PHP, it returns values between -128 and 127. That's why I loop through the characters\
    \ instead of the string length. If you're not interested in Unicode characters\
    \ you can just compare the string lengths. I added an example in my answer which\
    \ checks for the characters with different ASCII values.\n<|/ c |>\n<| c |>\n\
    I think you mean `$a = $s0.length`, no?\n<|/ c |>\n<| c |>\nYes sorry you're correct,\
    \ I think I've fixed that too now :D\n<|/ c |>\n<| a tags=php |>\nThe accepted\
    \ answer works for strings of length 1, but this one works for strings of any\
    \ length:\n<code>\n$str1 = 'test';\n$str2 = 'test123';\n$str3 = 'test123';\n\n\
    $same = count(preg_grep('/.^./', str_split($str1)) == count(preg_grep('/.^./',\
    \ str_split($str2))) && count(preg_grep('/.^./', str_split($str3)) == count(preg_grep('/.^./',\
    \ str_split($str2)));\n</code>\n<|/ a dscore=1 |>\n<| a tags=php |>\nFor string\
    \ with more than 2 chars, this worked for me\n<code>", "  $imax = strlen($s0);\n\
    \  for ($i = 0; $i < $imax; ++$i) {\n    if ($s1[$i] != $s0[$i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a |>\n<| c |>\nGood idea,\
    \ although it would be better to store the length of the strings before comparing\
    \ them.\n<|/ c |>\n<| c |>\nI agree and I edited my answer to include a version\
    \ of code that does this.  Also, while I am at it, I should mention that this\
    \ function is not 100% accurate, and should only be used if there is not a better\
    \ solution (for example, if you can't use PHP).\n<|/ c |>\n<| c |>\nThanks for\
    \ the edit, I never really knew that you could put a comment on the code block.\n\
    <|/ c |>\n<| a |>\nThis problem can be solved with difflib using its ndiff method.\
    \ Here is an example:\n<code>\n>>> import difflib\n>>> seq1 = 'eabcdzzzz'\n>>>\
    \ seq2 = 'dddzzzzzzzddeddabc'\n>>> d = difflib.ndiff(seq1, seq2)\n>>> ''.join(list(d))\n\
    '--- eabcdzzzz\\n'\n'+++ dddzzzzzzzddeddabc\\n'\n'@@ -1,1 +1,5 @@\\n'\n' +abcd\\\
    n'\n'\\n'\n'+dddddddabc\\n'\n</code>\n<|/ a tags=string,algorithm,php dscore=4\
    \ |>\n<| a |>\nUse this regex to split a line by '-' and '+', and check if each\
    \ substring have same characters. \n<code>\npreg_match_all('/[^-+]+/', $line,\
    \ $matches);\n</code>\n<|/ a tags=string,algorithm,php dscore=3 |>\n<| c |>\n\
    The regex is wrong, because it does not match the opposite case of '-+'.\n<|/\
    \ c |>\n<| a |>\nYou can use the strstr() function:\n<code>\n$s1 .= '-';\n$s2\
    \ .= '+';\n$s3 = strstr($s1,$s2); // returns NULL if $s1 is equal to $s2\n</code>\n\
    <|/ a dscore=3 tags=string,algorithm,php |>\n<| a |>\n<code>\n<?php \n$string\
    \ = \"abcdeabcdzzzz\";\n$string2 = substr($string, 0, strrpos($string, 'a'));\n\
    if($string2 === substr($string, strrpos($string, 'a'))) {\n    echo \"same\";\n\
    } else {\n    echo \"not same\";\n", "    $len = max(strlen($s0), strlen($s1));\n\
    \    $i1 = array();\n    $i2 = array();\n    for ($i = 0; $i < $len; ++$i) {\n\
    \        $i1[] = ord($s0[$i]);\n        $i2[] = ord($s1[$i]);\n    }\n    return\
    \ count(array_intersect($i1, $i2)) == $len;\n}", "    global $chars, $charsCount,\
    \ $max_chars, $max_chars_count;\n    global $vowels;\n\n    // Count the number\
    \ of occurences of each character.\n    foreach($s0 as $c) $charsCount[$c]++;\n\
    \    foreach($s1 as $c) $charsCount[$c]++;\n\n    // If number of chars equals\
    \ the maximum number, then the strings are equal.\n    if ($charsCount == $max_chars_count)\
    \ return true;\n\n    // If number of chars is greater than the maximum number,\
    \ then compare the strings.\n    foreach($s0 as $c) if (!isset($charsCount[$c]))\
    \ return false;\n    foreach($s1 as $c) if (!isset($charsCount[$c])) return false;\n\
    \n    // Compare each character in the string.\n    for($c=0; $c<count($s0); $c++)\
    \ {\n        $c0 = $s1[$c];\n        if (!isset($charsCount[$c0])) return false;\n\
    \        $c1 = $s0[$c];\n        if (!isset($charsCount[$c1])) return false;\n\
    \        if ($charsCount[$c0] != $charsCount[$c1]) return false;\n    }\n\n  \
    \  // All characters have the same count, so the strings are equal.\n    return\
    \ true;\n}", "    $s0 = preg_replace(\"/[^A-Za-z]+/\", '', $s0);\n    $s1 = preg_replace(\"\
    /[^A-Za-z]+/\", '', $s1);\n    $s1 = preg_replace(\"/[^A-Za-z]+/\", '', $s1);\n\
    \    return ($s0 == $s1);\n}\n", "    $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n\
    \    $maxLen = max(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $maxLen;\
    \ $i++) {\n        // The first position of different characters is found\n  \
    \      if (($s0[$i] != $s1[$i]) && ($s0[$i] != 'z')) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  // Convert characters to lowercase.\n\
    \  $s0 = strtolower($s0);\n  $s1 = strtolower($s1);\n\n  // Iterate through each\
    \ character.\n  foreach (str_split($s0, 1) as $c0 => $c1) {\n    // Check if character\
    \ at index 0 is the same as the character at index 1.\n    if ($c0 == $c1) {\n\
    \      // Check all characters between them.\n      for ($i = 2; $i <= strlen($s1);\
    \ $i++) {\n        if ($s1[$i - 1] != $s1[$i]) {\n          break;\n        }\n\
    \      }\n      if ($i != strlen($s1)) {\n        // Characters were the same.\n\
    \        return FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}", "    $len =\
    \ strlen($s0);\n    if ($len != strlen($s1)) {\n        return false;\n    }\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\n", "  // Count\
    \ the number of occurrences of each character.\n  // >>> count('a', 'aa')\n  //\
    \ 2\n  // >>> count('a', 'aaaaaa')\n  // 3\n  // >>> count('aa', 'aaaaaa')\n \
    \ // 1\n  $counts = array_count_values(str_split($s0));\n  $counts = array_merge($counts,\
    \ array_count_values(str_split($s1)));\n  $max = max($counts);\n\n  // Use a for\
    \ loop to go through each character, and\n  // see if the count of that character\
    \ is the same as the maximum count.\n  // >>> is_same_chars('aaa', 'aa')\n  //\
    \ True\n  // >>> is_same_chars('a', 'aa')\n  // False\n  // >>> is_same_chars('aaaa',\
    \ 'aa')\n  // False\n  foreach (str_split($s0) as $key => $char) {\n    if ($counts[$char]\
    \ != $max) {\n      return false;\n    }\n  }\n  foreach (str_split($s1) as $key\
    \ => $char) {\n    if ($counts[$char] != $max) {\n      return false;\n    }\n\
    \  }\n\n  // No difference is found.\n  return true;\n}\n", "  // Return True\
    \ if $s0 and $s1 have the same characters.\n  $len = strlen($s0);\n  if ($len\
    \ < strlen($s1)) {\n    $len = $s1;\n  }\n  for ($i = 0; $i < $len; $i++) {\n\
    \    if ($s0[$i] != $s1[$i]) {\n      // Two strings have a different number of\
    \ characters.\n      return false;\n    }\n  }\n  return true;\n}\n", "    $s0\
    \ = str_replace(array(\"\\n\", \"\\r\"), \"\", strtolower($s0));\n    $s1 = str_replace(array(\"\
    \\n\", \"\\r\"), \"\", strtolower($s1));\n    return $s0 === $s1;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\n<?php", "    if (strlen($s0) != strlen($s1))\
    \ {\n        return false;\n    }\n    $a = array();\n    $b = array();\n    for\
    \ ($i = 0; $i < strlen($s0); $i++) {\n        $a[$i] = $s0{$i};\n        $b[$i]\
    \ = $s1{$i};\n    }\n    sort($a);\n    sort($b);\n    if ($a == $b) {\n     \
    \   return true;\n    }\n    $a0 = array_count_values($a);\n    $b0 = array_count_values($b);\n\
    \    foreach ($b0 as $i => $j) {\n        if ($a0[$i] != $j) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "    $c0 = mb_substr($s0,\
    \ 1, mb_strlen($s0, 'UTF-8'), 'UTF-8');\n    $c1 = mb_substr($s1, 1, mb_strlen($s1,\
    \ 'UTF-8'), 'UTF-8');\n    return $c0 == $c1;\n}\n", "    $len = min(strlen($s0),\
    \ strlen($s1));\n    for ($i = 0; $i < $len; $i++) {\n        if ($s0 [$i] !=\
    \ $s1 [$i]) return true;\n    }\n    return false;\n}", "    return preg_match_all('/./u',\
    \ $s0, $m0) &&\n        preg_match_all('/./u', $s1, $m1) &&\n        count(array_unique($m0[0])\
    \ == count(array_unique($m1[0])));\n}", "    $s0 = preg_replace('~\\A\\w~', '',\
    \ $s0);\n    $s1 = preg_replace('~\\A\\w~', '', $s1);\n    return $s0 == $s1;\n\
    }\n", "    if (!isset($s0)) $s0 = '';\n    if (!isset($s1)) $s1 = '';\n    //\
    \ Check if one word is empty.\n    if ($s0 == '' && $s1 == '') return true;\n\
    \    // Check if one word is empty.\n    if ($s0 == $s1 && $s1 == '') return true;\n\
    \    // If the words are empty, the words are the same.\n    if ($s0 == '' &&\
    \ $s1 != '') return false;\n    if ($s0 == $s1 && $s1 != '') return true;\n  \
    \  // Check that both words are the same lengths.\n    if (strlen($s0) > strlen($s1))\
    \ return false;\n    if (strlen($s0) == strlen($s1) && $s1 == '') return true;\n\
    \    // Check for a mix of non-alpha and alpha characters.\n    $s0_non_alpha\
    \ = preg_replace(\"/[^a-zA-Z]/\",\"\",$s0);\n    $s1_non_alpha = preg_replace(\"\
    /[^a-zA-Z]/\",\"\",$s1);\n    if ($s0_non_alpha == $s1_non_alpha) return false;\n\
    \    // Check for a mix of non-alpha and alpha characters.\n    $s0_alpha = preg_replace(\"\
    /[^a-zA-Z]/\",\"\",$s1);\n    $s1_alpha = preg_replace(\"/[^a-zA-Z]/\",\"\",$s0);\n\
    \    if ($s0_alpha == $s1_alpha) return true;\n    // Check the first character\
    \ of the words.\n    if ($s0[0] == $s1[0] && $s1 == '') return false;\n    if\
    \ ($s0[0] == $s1[0] && $s1 != '') return true;\n    // Check the last character\
    \ of the words.\n    if ($s0[strlen($s0)-1] == $s1[strlen($s1)-1] && $s1 == '')\
    \ return false;\n    if ($s0[strlen($s0)-1] == $s1[strlen($s1)-1] && $s1 != '')\
    \ return true;\n    // Check that the words are the same word backwards.\n   \
    \ for ($i = 0; $i <= strlen($s0)-1; $i++) {\n        if ($s0[$i] != $s1[$i]) return\
    \ false;\n    }\n    return true;\n}", "  $s0 = preg_split('/(?<=\\w)[\\W\\s]?/',\
    \ $s0);\n  $s1 = preg_split('/(?<=\\w)[\\W\\s]?/', $s1);\n\n  $len = min(count($s0),\
    \ count($s1));\n  for ($i = 0; $i < $len; $i++) {\n    if ($s0[$i] !== $s1[$i])\
    \ return false;\n  }\n  return true;\n}\n", "  $s_len1 = strlen($s1);\n  $s_len0\
    \ = strlen($s0);\n  if ($s_len0 > $s_len1) {\n    $s0 = substr($s0, 0, $s_len1);\n\
    \  } else {\n    $s1 = substr($s1, 0, $s_len0);\n  }\n  $diff = 0;\n  for ($i\
    \ = 0; $i < $s_len0; $i++) {\n    $diff |= ord($s0[$i]) ^ ord($s1[$i]);\n  }\n\
    \  return $diff === 0;\n}\n", "\t$s1_len = strlen($s1);\n\t$s0_len = strlen($s0);\n\
    \tif ($s1_len == $s0_len) {\n\t\tfor ($i = 0; $i < $s0_len; $i++) {\n\t\t\tif\
    \ ($s0[$i] != $s1[$i]) return false;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\t\
    return false;\n\t}\n}\n", "  $a0 = strlen($s0);\n  $a1 = strlen($s1);\n  for ($i\
    \ = 0; $i < $a0; ++$i) {\n    if ($s1[$i] != $s0[$i]) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "    $chars = array_unique(str_split($s0));\
    \ // get all chars in both strings\n    $chars = array_intersect($chars, array_unique(str_split($s1)));\
    \ // get all chars in first string\n    return count($chars) == strlen($s0); //\
    \ check if all chars are in the second string\n}\n", "  if (!is_string($s0) ||\
    \ !is_string($s1)) {\n    return false;\n  }\n\n  $s0 = strtolower($s0);\n  $s1\
    \ = strtolower($s1);\n  $s0 = preg_replace('/(.)\\1/i', '', $s0);\n  $s1 = preg_replace('/(.)\\\
    1/i', '', $s1);\n\n  if (strlen($s0) == 0) {\n    return strlen($s1) == 0;\n \
    \ }\n  if (strlen($s1) == 0) {\n    return strlen($s0) == 0;\n  }\n\n  return\
    \ ($s0 == $s1);\n}\n\n/**\n * Convert an IP address to a decimal value without\
    \ dots.\n * http://en.wikipedia.org/wiki/Xeno_Address#Binary_address\n *\n * Examples\
    \ generated by http://www.ipaddressguide.com/\n * >>> ip2long('128.204.195.12')\n\
    \ * 2130706433\n * >>> ip2long('192.0.2.44')\n * 24020\n * >>> ip2long('100.64.0.10')\n\
    \ * 100640010\n * >>> ip2long('100.64.10.10')\n * 100641010 # Not correct, assumes\
    \ too big subnet and wrong\n * >>> ip2long('100.64.10.10.10')\n * 100641010 #\
    \ Correct\n * >>> ip2long('100.64.10.10.10.10')\n * 100641010 # Correct\n * >>>\
    \ ip2long('100.64.10.10.10.10.10')\n * 100641010 # Correct\n *\n * @param string\
    \ $ip the IP address to convert\n * @return integer the IP address converted to\
    \ a long integer\n */", "    $s0_len = strlen($s0);\n    $s1_len = strlen($s1);\n\
    \    if ($s0_len != $s1_len) return false;\n    $a1 = str_split($s1);\n    $a0\
    \ = str_split($s0);\n    foreach ($a1 as $k => $a2) {\n        if ($a1[$k] !=\
    \ $a0[$k]) return false;\n    }\n    return true;\n}\n", "    // This implementation\
    \ is very similar to\n    // https://stackoverflow.com/a/62428\n    // but uses\
    \ a different algorithm that runs faster\n    // and uses less memory.\n\n   \
    \ // Remember positions we saw at start of strings.\n    $i0 = 0;\n    $i1 = 0;\n\
    \    $len0 = count($s0);\n    $len1 = count($s1);\n\n    // Start from where the\
    \ strings are different\n    // but still the same length.\n    while (true) {\n\
    \        // Find the end of one string. Also make sure we don't\n        // go\
    \ past the end.\n        $i = min($i1, $len1);\n        if ($i > $len0) {\n  \
    \          return false;\n        }\n\n        // Compare character for character,\
    \ returning\n        // True if equal.\n        if ($s0[$i0] == $s1[$i1]) {\n\
    \            $i1++;\n            $i0++;\n            continue;\n        }\n\n\
    \        // At this point we know the two strings are not equal\n        return\
    \ false;\n    }\n}\n", "  if ($s0 === $s1) return true;\n  if (!isset($s0[$s0]))\
    \ return false;\n  if (!isset($s1[$s1])) return false;\n  $a = $s0[$s0];\n  $b\
    \ = $s1[$s1];\n  for ($i = 0; $i < strlen($a); $i++) {\n    if ($a[$i] !== $b[$i)\
    \ return false;\n  }\n  return true;\n}\n", "  return preg_match('/.{$s0.length}|.{$s1.length}/',\
    \ $s0) ==\n         preg_match('/.{$s0.length}|.{$s1.length}/', $s1);\n}\n\n/**\n\
    \ * Checks whether the given characters are the given type.\n * Given charset\
    \ is '0123456789abcdefghijklmnopqrstuvwxyz',\n * the given string is interpreted\
    \ as the hex-encoded byte sequence\n * of the given charset.\n * >>> is_hex('96969696969696969')\n\
    \ * True\n * >>> is_hex('9696969696969696969696969')\n * True\n * >>> is_hex('96969696969696969696969696969696969')\n\
    \ * False\n * >>> is_hex('9696969696969696969696969696969696969696969')\n * False\n\
    \ * >>> is_hex('96969696969696969696969696969696969696969696969')\n * False\n\
    \ * >>> is_hex('96969696969696969696969696969696969696969696969696969')\n * False\n\
    \ * >>> is_hex('969696969696969696969696969696969696969696969696969696969')\n\
    \ * False\n * >>> is_hex('9696969696969696969696969696969696969696969696969696969696969696969696969696969')\n\
    \ * False\n * >>> is_hex('969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969696969",
  "    return strlen($s0) == strlen($s1) &&\n           substr($s0, strlen($s0)-strlen($s1))\
    \ == $s1;\n}\n", "    \n    $s0l = strlen($s0);\n    $s1l = strlen($s1);\n   \
    \ if ($s0l > $s1l) {\n        $s0 = substr($s0, 1, $s1l);\n    } elseif ($s1l\
    \ > $s0l) {\n        $s1 = substr($s1, 0, $s0l);\n    }\n    \n    return strlen($s0)\
    \ == strlen($s1);\n}\n", "  $i0 = 0; $i1 = 0;\n  while($i0 < strlen($s0)) {\n\
    \    if($s0[$i0] != $s1[$i1]) {\n      break; $i1 = 0; $i0++;\n    } else {\n\
    \      $i0++; $i1++;\n    }\n  }\n  return $i0 == strlen($s0);\n}\n", "  if (strlen($s0)\
    \ > strlen($s1)) {\n    $s1 = $s0 . $s1;\n  }\n  $c0 = preg_split('//', $s0, -1,\
    \ PREG_SPLIT_NO_EMPTY);\n  $c1 = preg_split('//', $s1, -1, PREG_SPLIT_NO_EMPTY);\n\
    \  foreach($c1 as $i => $c) {\n    if (isset($c0[$i])) {\n      $diff = 0;\n \
    \     for($j = 0; $j < strlen($c); $j++) {\n        if ($c0[$i][$j] != $c[$j])\
    \ {\n          $diff = 1;\n          break;\n        }\n      }\n      if ($diff\
    \ != 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n</code>\n\
    The function will return True or False depending on if $s1 and $s0 have the same\
    \ characters or not. I didn't check for anything more than the simple scenario\
    \ you provided, but I think this should work.\n<|/ a |>\n<| c |>\nI don't think\
    \ this checks for the case where one word is the reverse of another. E.g., `same_chars('abcdef',\
    \ 'abcde')` returns true.\n<|/ c |>\n<| c |>\n: Thank you for pointing out that\
    \ scenario. I updated the answer to handle this case as well as the case where\
    \ only one of the two words is longer than the other.\n<|/ c |>\n<| a |>\nThe\
    \ previous answers did not solve the problem for me because I was looking for\
    \ words that could have similar characters in their whole word sequence. \nI have\
    \ written a function that checks if two words have the same sequence of characters.\
    \ The function works for words that are different length and they do not contain\
    \ any characters that are not in their whole word sequence:\n<code>", "    $s0\
    \ = preg_replace('/[^a-z0-9]+/i', '', $s0);\n    $s1 = preg_replace('/[^a-z0-9]+/i',\
    \ '', $s1);\n    if ($s0 !== $s1) {\n        return false;\n    } else {\n   \
    \     return true;\n    }\n}", "    $i0 = $i1 = $j = $k = 0;\n    for ($i = 0;\
    \ $i < min(count($s0), count($s1)); ++$i) {\n        if ($s1[$i] === $s0[$i])\
    \ {\n            $i1++;\n        } else {\n            $i0++;\n        }\n   \
    \ }\n    for ($j = $i0; $j < min(count($s0), count($s1)); ++$j) {\n        if\
    \ ($s0[$j] === $s1[$j]) {\n            $k++;\n        } else {\n            $k\
    \ = 0;\n        }\n    }\n    return ($k === 0);\n}\n\n/**\n * Remove all duplicate\
    \ characters from the input string.\n * \n * @param string $s\n * \n * @return\
    \ string\n */", "    $count = count($s0);\n    for ($i = 0; $i < $count; $i++)\
    \ {\n        if ($s0[$i] != $s1[$i]) return false;\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=0 tags=hash,algorithm,performance,php |>\n<| a dscore=0\
    \ |>\nThe simplest and most efficient solution would be to simply compare each\
    \ letter in the strings. If the first letters differ, then the strings are not\
    \ equal, otherwise they are equal. It's a linear time solution.\n<code>", "  if\
    \ (strlen($s0) == 0) return strlen($s1) == 0;\n  if (strlen($s1) != strlen($s0))\
    \ return false;\n  $i = 0;\n  $j = 0;\n  while ($i < strlen($s0) && $j < strlen($s1))\
    \ {\n    if ($s0[$i] != $s1[$j]) return false;\n    $i++;\n    $j++;\n  }\n  return\
    \ $i == strlen($s0);\n}\n", "  $s0 = preg_replace('/\\W/', '', $s0);\n  $s1 =\
    \ preg_replace('/\\W/', '', $s1);\n  return preg_replace('/.$/', '', $s0) == preg_replace('/.$/',\
    \ '', $s1);\n}\n</code>\nThe first regex replaces all non-word characters with\
    \ nothing, then we test if the last character is also a non-word character. That\
    \ test is done twice: once to remove any trailing characters, then once to see\
    \ if the result has any trailing characters. The regex does its testing in two\
    \ steps and only does the second half if the first half was successful.\nThe second\
    \ regex is more complex but works in all cases. The first regex works because\
    \ when one word is compared with another word, the characters in each word are\
    \ compared in the same order that they appear in the word. Thus, if a word has\
    \ a letter that is missing from the other word, then the two words have different\
    \ letters.\nI added some comments above the function. I tested the function with\
    \ the input string in the comments and the function gives the correct result.\n\
    <|/ a dscore=1 |>\n<| c |>\nI am not sure what this code does, could you explain\
    \ it or give an example?\n<|/ c |>\n<| c |>\nI just added some explanation.\n\
    <|/ c |>\n<| c |>\nI did some testing. It seems the regex `preg_replace('(\\w+)(\\\
    w+)$','$1$2',$s0)` is incorrect. It does not remove the last `+` from the string.\
    \ However, the other one works.\n<|/ c |>\n<| c |>\nThat's strange. It works fine\
    \ for me. Maybe it depends on the PHP version you're using. I've added a test\
    \ to my answer (tested with PHP 7.2.14).\n<|/ c |>\n<| c |>\nI tested in PHP 5.6.29\
    \ and PHP 7.2.14. Both work fine. Thank you for the help.\n<|/ c |>\n<| a |>\n\
    I finally found an answer that works on both versions of PHP:\n<code>\n<?php\n",
  "  return count_chars($s0) === count_chars($s1);\n}", "  if($s0 == '' || $s1 ==\
    \ '')\n    return false;\n  $c = str_split($s0);\n  $d = str_split($s1);\n  if(count($c)\
    \ != count($d) || count($c) > strlen($s0) || count($d) > strlen($s1))\n    return\
    \ false;\n  for($i = 0; $i < count($c); $i++)\n    if($c[$i] != $d[$i])\n    \
    \  return false;\n  return true;\n}\n", "  $s0 = preg_replace('/[^a-z0-9]/', '',\
    \ $s0);\n  $s1 = preg_replace('/[^a-z0-9]/', '', $s1);\n  if(strlen($s0) == strlen($s1))\n\
    \  {\n    for($i = 0; $i < strlen($s0); $i++)\n    {\n      if($s0[$i] != $s1[$i])\n\
    \      {\n        return false;\n      }\n    }\n    return true;\n  }\n  else\n\
    \  {\n    return false;\n  }\n}\n\n$s0 = htmlspecialchars($_POST['s0_1']);\n$s1\
    \ = htmlspecialchars($_POST['s1_1']);\n\necho 'The result of <code>' . $s0 . '</code>\
    \ equals <code>' . $s1 . '</code> and they are the same: ' . (($s0 == $s1) ? 'True'\
    \ : 'False');\n", "  $s1 = strtoupper($s1);\n  $s0 = strtoupper($s0);\n  $s1_len\
    \ = strlen($s1);\n  $s0_len = strlen($s0);\n  if ($s0_len > $s1_len) {\n    $s0\
    \ = substr($s0, 1, $s0_len-1);\n  }\n  return $s1 == $s0;\n}\n\n/**\n * Checks\
    \ if the input URL is broken\n *\n * @param string $url The input URL\n *\n *\
    \ @return bool\n */", "    $len0 = strlen($s0);\n    $len1 = strlen($s1);\n  \
    \  if ($len0 != $len1) {\n        return false;\n    }\n    $count0 = $len0;\n\
    \    for ($i = 0; $i < $len0; $i++) {\n        if ($s0[$i] != $s1[$i]) {\n   \
    \         $count0--;\n        }\n    }\n    if ($count0 > 0) {\n        return\
    \ false;\n    }\n    return true;\n}\n", "  if (!$s1 || !$s0) {\n    return false;\n\
    \  }\n  $len = strlen($s0);\n  if ($len == strlen($s1)) {\n    for ($i = 0; $i\
    \ < $len; $i++) {\n      if ($s1[$i] != $s0[$i]) {\n        return false;\n  \
    \    }\n    }\n    return true;\n  }\n  return false;\n}", "    $s0 = str_split($s0);\n\
    \    $s1 = str_split($s1);\n    for($i = 0; $i < count($s0); $i++) {\n       \
    \ if ($s0[$i] != $s1[$i]) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou just copied my function\
    \ from my answer. Do you really think this is better? I think not\n<|/ c |>\n\
    <| c |>\nI didn't copy it. My function returns `True` if two words have the same\
    \ characters.\n<|/ c |>\n<| c |>\nYour function doesn't work - it returns false\
    \ for two words that are equal but have a different length.\n<|/ c |>\n<| c |>\n\
    It returns False for words that have the same characters and the same length.\
    \ The difference between my answer and your answer is that I have not broken words\
    \ into individual letters but used str_split. That is why I said my function was\
    \ inefficient\n<|/ c |>\n<| c |>\nOh, I thought you were the OP, not me. Thanks\
    \ for your comment.\n<|/ c |>\n<| a |>\nI couldn't find a built-in PHP function\
    \ to do this, so I wrote my own.  It seems to work on all tests I've done.\n<code>",
  "  $s0_len = strlen($s0);\n  $s1_len = strlen($s1);\n  $same = 0;\n  for ($i = 0;\
    \ $i < $s0_len && $i < $s1_len; $i++) {\n    if ($s0[$i] != $s1[$i]) {\n     \
    \ $same++;\n    }\n  }\n  return $same == $s0_len && $same == $s1_len;\n}\n",
  "    $s0 = strtolower($s0);\n    $s1 = strtolower($s1);\n    if (strlen($s0) !=\
    \ strlen($s1)) {\n        return false;\n    }\n    $same = strcmp($s0, $s1);\n\
    \    return $same === 0;\n}\n", "    return preg_match_all('/(.)\\1*/', $s0, $m0)\
    \ && preg_match_all('/(.)\\1*/', $s1, $m1);\n}\n", "    $s0len = mb_strlen($s0,\
    \ '8bit');\n    $s1len = mb_strlen($s1, '8bit');\n    if ($s0len == $s1len) {\n\
    \        for ($i = 0; $i < $s0len; $i++) {\n            if (mb_substr($s0, $i,\
    \ 1) != mb_substr($s1, $i, 1)) {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n    return false;\n}\n", "  $t0 = strlen($s0);\n\
    \  $t1 = strlen($s1);\n\n  // If the two strings are equal, return True\n  if\
    \ ($t0 == $t1)\n    return true;\n\n  // Loop through the characters in the first\
    \ string\n  for ($i = 0; $i < $t0; ++$i) {\n    // Loop through the characters\
    \ in the second string\n    for ($j = 0; $j < $t1; ++$j) {\n      // If this character\
    \ is the same, return True\n      if ($s0[$i] == $s1[$j])\n        return true;\n\
    \    }\n  }\n\n  // If we're here, the two strings are not equal\n  return false;\n\
    }\n", "\tif (strlen($s0) != strlen($s1)) {\n\t\treturn false;\n\t}\n\t$s1 = str_replace('zzzzzzz',\
    \ 'z', $s1);\n\tfor ($i = 0; $i < strlen($s0); $i++) {\n\t\tif ($s0[$i] != $s1[$i])\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "    return strlen($s0)\
    \ == strlen($s1) &&\n           array_intersect(str_split($s0), str_split($s1))\
    \ == $s0;\n}\n", "    $s0 = preg_replace('/[^a-z]+/i', '', $s0);\n    $s1 = preg_replace('/[^a-z]+/i',\
    \ '', $s1);\n    return count($s0) == count($s1) && $s0 == $s1;\n}\n</code>\n\
    This way you are able to search for any string in another string and also find\
    \ strings with repeated characters.\nThe function can be used in any situation\
    \ where you would like to compare the length of a string and check if two strings\
    \ have the same characters and if they do then they have same characters in common.\
    \ \n<code>", "    $s0 = preg_replace('/\\W+/', '', $s0);\n    $s1 = preg_replace('/\\\
    W+/', '', $s1);\n    return strlen($s0) == strlen($s1) && preg_replace('/[^' .\
    \ $s1 . ']/', '', $s0) == '';\n}\n", "    $s1 = array_reverse($s1);\n    $count\
    \ = 0;\n    foreach($s1 as $s2) if ($s0 === $s2) $count++;\n    return $count\
    \ === count($s1);\n}", "  return preg_replace('/(.)\\\\1+/', '$1', $s0) == $s1;\n\
    }", "    $s0_len = strlen($s0);\n    $s1_len = strlen($s1);\n    if ($s0_len ===\
    \ $s1_len) {\n        $result = true;\n        for ($i = 0; $i < $s0_len; $i++)\
    \ {\n            $result &= ($s0[$i] === $s1[$i]);\n        }\n        return\
    \ $result;\n    } else {\n        return false;\n    }\n}\n", "    $s0 = strtolower($s0);\n\
    \    $s1 = strtolower($s1);\n    $count = strlen($s0);\n    for ($i = 0; $i <\
    \ $count; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  if (strlen($s0) != strlen($s1))\
    \ {\n    return false;\n  }\n  $char_map = array_flip(str_split($s0));\n  foreach\
    \ (str_split($s1) as $c) {\n    if ($c != $s0[$char_map[$c]]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a tags=php,character-encoding\
    \ |>\n<| c |>\nThe `ord()` method is only available since PHP 5.3.0. And it has\
    \ been removed in PHP 7.\n<|/ c |>\n<| c |>\n, Yes, thanks for reminding me. I've\
    \ just found out that it was introduced in PHP 5.3.0 as well.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nI see that all the answers here assume that the string is in ASCII\
    \ format, which is not always the case, so this would also work:\n<code>", " \
    \   $s0 = strrev($s0);\n    $s1 = strrev($s1);\n    return $s0 == $s1;\n}\n",
  "    // This function returns True if two words have the same characters, False\n\
    \    // otherwise.\n    $chars0 = strlen($s0);\n    $chars1 = strlen($s1);\n \
    \   if ($chars0 == $chars1) {\n        for ($i = 0; $i < $chars0; $i++) {\n  \
    \          if ($s1[$i] != $s0[$i]) {\n                return false;\n        \
    \    }\n        }\n        return true;\n    }\n    return false;\n}\n", "\treturn\
    \ preg_replace('/(.)\\1+/', \"$1\", $s0) == preg_replace('/(.)\\1+/', \"$1\",\
    \ $s1);\n}", "  $s0 = mb_substr($s0, 1, mb_strlen($s0, $this->mb_enc) - 1, 'UTF-8');\n\
    \  $s1 = mb_substr($s1, 1, mb_strlen($s1, $this->mb_enc) - 1, 'UTF-8');\n  if\
    \ (strlen($s0) != strlen($s1)) {\n    return false;\n  }\n  $chars = preg_split('//u',\
    \ $s1);\n  foreach ($chars as $c) {\n    if ($s0 != $s1) {\n      if (ord($c)\
    \ != ord($s0)) {\n        return false;\n      }\n    }\n  }\n  return true;\n\
    }", "    $s_len = mb_strlen($s0);\n    $s_len2 = mb_strlen($s1);\n    $s_len3\
    \ = $s_len + $s_len2;\n    $s_len4 = 2 * $s_len3;\n    $s_len5 = mb_strlen($s0)\
    \ + mb_strlen($s1);\n    $s_len6 = $s_len4 - $s_len5;\n    return $s_len6 == 0;\n\
    }\n", "    if (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n \
    \   $i0 = 0;\n    $i1 = 0;\n    while ($i0 < strlen($s0)) {\n        if (strpos($s1,\
    \ substr($s0, $i1)) === false) {\n            $i0++;\n        } else {\n     \
    \       $i1++;\n        }\n    }\n    return ($i0 == strlen($s0));\n}", "    if\
    \ (strlen($s0) != strlen($s1)) {\n        return false;\n    }\n    $res = true;\n\
    \    for ($i = 0; $i < strlen($s0); $i++) {\n        if ($s1[$i] != $s0[$i]) {\n\
    \            $res = false;\n            break;\n        }\n    }\n    return $res;\n\
    }\n", "    // Convert each character to its ASCII value. \n    // >>> ord('A')\
    \ == 65\n    // True\n    $s0 = str_replace(' ', '', $s0);\n    $s1 = str_replace('\
    \ ', '', $s1);\n    $s0 = ord($s0);\n    $s1 = ord($s1);\n    $s02 = ord($s02);\n\
    \    $s1 = ord($s1);\n    \n    // Compare each character in each word.\n    //\
    \ >>> for word in ['abcd', 'dddddddabc', 'eeeeeeabbcc', 'dddddddabcc']:\n    //\
    \ ...   print word + ':', same_chars(word, word), '\\n'\n    // ...\n    // abcd:\
    \ True\n    // dddddddabc: True\n    // eeeeeeabbcc: True\n    // dddddddabcc:\
    \ True\n    // >>> for word in ['eabcd', 'dddddddabc', 'eeeeeeabbcc', 'dddddddabce']:\n\
    \    // ...   print word + ':', same_chars(word, word), '\\n'\n    // ...\n  \
    \  // eabcd: True\n    // dddddddabc: True\n    // eeeeeeabbcc: True\n    // dddddddabce:\
    \ False\n    // >>> for word in ['abcd', 'dddddddabcc', 'eeeeeeabbcc', 'dddddddabce']:\n\
    \    // ...   print word + ':', same_chars(word, word), '\\n'\n    // ...\n  \
    \  // abcd: True\n    // dddddddabcc: False\n    // eeeeeeabbcc: True\n    //\
    \ dddddddabce: True\n    return $s0 === $s1 && $s02 === $s1;\n}\n</code>\nI haven't\
    \ run these tests, but I think the ideas should work.\n<|/ a |>\n<| a dscore=0\
    \ |>\nA different way to solve the problem would be to generate a hash map of\
    \ the words, and then compare the hash map's keys and values to find the words\
    \ that are the same.\n<code>\n<?php\n\n$hashes = array();\n\nforeach ($words as\
    \ $word) {\n    $hashes[hash('sha1', $word)] = 1;\n}\n\n$same = [];\n\nforeach\
    \ ($hashes as $hash => $count) {\n    if (count($same) > 1 && $count == 1) {\n\
    \        break;\n    }\n\n    if ($count == 1) {\n        $same[] = $hash;\n \
    \   }\n}\n</code>\n$same will contain an array of hashes that are the same.\n\
    <|/ a tags=string,php,algorithm |>\n<| a |>\n<code>\n<?php\n$words= array(\"word\"\
    ,\"word\",\"word\");\n$words2 = array(\"word\",\"word\",\"word\");\n$words3 =\
    \ array(\"word\",\"word\",\"word\");\n$words4 = array(\"word\",\"word\",\"word",
  "  return preg_match('/(.)\\1/', $s0, $c0) &&\n         preg_match('/(.)\\1/', $s1,\
    \ $c1);\n}\n", "    $t0 = strtoupper($s0);\n    $t1 = strtoupper($s1);\n\n   \
    \ if ($t0 === $t1) {\n        return true;\n    }\n\n    return ($t0 >= 'A' &&\
    \ $t0 <= 'Z') && ($t1 >= 'A' && $t1 <= 'Z') && ($t0 > $t1);\n}\n", "    if (strlen($s0)\
    \ > strlen($s1)) {\n        $s2 = $s1;\n    } else {\n        $s2 = $s0;\n   \
    \ }\n    \n    $a = strlen($s0);\n    $b = strlen($s1);\n    \n    $count = 0;\n\
    \    \n    for ($i = 0; $i < $a; $i++) {\n        for ($j = $a + 1; $j < $b; $j++)\
    \ {\n            if ($s0[$i] === $s1[$j]) {\n                $count++;\n     \
    \           $i = $j;\n            }\n        }\n    }\n    \n    return $count\
    \ === $b;\n}\n", "    $c0 = strlen($s0);\n    $c1 = strlen($s1);\n    if ($c0\
    \ == 0) return $c1 == 0;\n    if ($c1 == 0) return $c0 == 0;\n    return ($c0\
    \ == $c1) && preg_match('/(.)\\1*$/', $s0, $m) && preg_match('/(.)\\1*$/', $s1,\
    \ $m);\n}\n", "    // Create arrays from strings if they aren't already.\n   \
    \ $s0 = str_split($s0);\n    $s1 = str_split($s1);\n    \n    // Iterate through\
    \ characters of both strings\n    $same = count(array_intersect($s0, $s1)) ==\
    \ count($s0);\n\n    return $same;\n}\n</code>\nThe output of this function is\
    \ as follows:\n<code>\neabcdzzzz, dddzzzzzzzddeddabc TRUE\nabcd, dddddddabc TRUE\n\
    dddddddabc, abcd TRUE\neabcdzzzz, dddzzzzzzzddddabc FALSE\nabcd, dddddddabce FALSE\n\
    eabcdzzzz, dddzzzzzzzddddabce FALSE\n</code>\n<|/ a dscore=0 tags=string,php,arrays,boolean\
    \ |>\n<| c |>\nThe other solutions do NOT consider different sets of characters.\n\
    <|/ c |>\n<| a dscore=0 |>\nThis is an old question, but I came across this while\
    \ looking for a way to validate a list of numbers. The following uses two functions\
    \ to validate the input, as well as a few other functions.\nThe input is an array\
    \ of strings. Each string in the array should be a valid number in a specific\
    \ range (including leading zeroes) with a specific number of digits after the\
    \ decimal.\nThe range is from 0 to 999999.99.\nThe input will also contain some\
    \ extra characters which can be ignored by passing an empty array to the second\
    \ parameter of the validator.\n<code>\n<?php", "  // Check the length of the strings.\n\
    \  if (strlen($s0) > strlen($s1)) {\n    $s0 = $s1;\n  }\n\n  // Check each character\
    \ individually.\n  for ($i = 0; $i < strlen($s0); $i++) {\n    if ($s0[$i] !==\
    \ $s1[$i]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "    return\
    \ str_split($s0) == str_split($s1);\n}\n", "    if (strlen($s0) > strlen($s1))\
    \ {\n        $s0 = strrev($s0);\n        $s1 = strrev($s1);\n    }\n    $s0 =\
    \ strrev($s0);\n    $s1 = strrev($s1);\n    $count1 = strlen($s1);\n    $count2\
    \ = strlen($s0);\n\n    for ($i = 0; $i < $count2; $i++) {\n        if (strpos($s0,\
    \ $s1[$i]) === false) {\n            return false;\n        }\n    }\n\n    for\
    \ ($i = 0; $i < $count1; $i++) {\n        if (strpos($s1, $s0[$i]) === false)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n", "  \
    \  $c = array_count_values(str_split($s0)); // Split by character\n    $d = array_count_values(str_split($s1));\
    \ // Split by character\n    return array_diff_assoc($c, $d) == array();\n}\n",
  "    if ($s0 === $s1) {\n        return true;\n    }\n    \n    // If one string\
    \ is longer than the other, return false.\n    if (strlen($s0) > strlen($s1))\
    \ {\n        return false;\n    }\n    \n    $s0_size = strlen($s0);\n    $s1_size\
    \ = strlen($s1);\n    \n    $char_map = array_fill(0, $s1_size + 1, true);\n \
    \   \n    for ($i = 0; $i < $s0_size; ++$i) {\n        // Check if any character\
    \ of the source string is in the target.\n        // If it is, the source characters\
    \ are the same.\n        // If it isn't, return false.\n        if ($s0[$i] >=\
    \ \"a\" && $s0[$i] <= \"z\") {\n            if ($s0[$i] >= \"A\" && $s0[$i] <=\
    \ \"Z\") {\n                $char_map[$i] |= $s0[$i] >= \"a\" && $s0[$i] <= \"\
    z\";\n            } else {\n                $char_map[$i] |= $s0[$i] >= \"A\"\
    \ && $s0[$i] <= \"Z\";\n                $char_map[$i] |= $s0[$i] >= \"a\" && $s0[$i]\
    \ <= \"z\";\n            }\n        }\n    }\n    \n    for ($i = 0; $i < $s1_size;\
    \ ++$i) {\n        // Check if any character of the target string is in the source.\n\
    \        // If it is, the target characters are the same.\n        // If it isn't,\
    \ return false.\n        if ($s1[$i] >= \"a\" && $s1[$i] <= \"z\") {\n       \
    \     if ($s1[$i] >= \"A\" && $s1[$i] <= \"Z\") {\n                $char_map[$i]\
    \ |= $s1[$i] >= \"a\" && $s1[$i] <= \"z\";\n            } else {\n           \
    \     $char_map[$i] |= $s1[$i] >= \"A\" && $s1[$i] <= \"Z\";\n               \
    \ $char_map[$i] |= $s1[$i] >= \"a\" && $s1[$i] <= \"z\";\n            }\n    \
    \    }\n    }\n    \n    // Return true if the characters are the same.\n    //\
    \ If none of the characters are the same, return false.\n    return array_search(false,\
    \ array_fill(0, $s1_size, false)) == array_search(false, array_fill(0, $s0_size,\
    \ false));\n}\n", "    for($i = 0; $i < strlen($s0); $i++) {\n        for($j =\
    \ 0; $j < strlen($s1); $j++) {\n            if($s1[$j] != $s0[$i]) return false;\n\
    \        }\n    }\n    return true;\n}", "    $s0 = $s0 ? trim($s0) : '';\n  \
    \  $s1 = $s1 ? trim($s1) : '';\n    return (strlen($s0) === strlen($s1)) && (strlen($s0)\
    \ === 0 || preg_match('/(.)\\1*/', $s0, $a) == 1);\n}", "  // We only care about\
    \ lowercase characters here.\n  return strcasecmp($s0, $s1) === 0;\n}\n", "  if\
    \ (strlen($s0) != strlen($s1)) {\n    return false;\n  }\n  for ($i = 0; $i <\
    \ strlen($s0); $i++) {\n    if ($s0[$i] != $s1[$i]) {\n      return false;\n \
    \   }\n  }\n  return true;\n}\n", "    $len1 = strlen($s1);\n    $len2 = strlen($s0);\n\
    \    if ($len1 != $len2) return False;\n    for ($i=0; $i<$len1; $i++) if ($s1[$i]\
    \ != $s0[$i]) return false;\n    return True;\n}", "  // http://kevin.vanzonneveld.net\n\
    \  // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n \
    \ // +      input by: Brett Zamir (http://brett-zamir.me)\n  // +   bugfixed by:\
    \ Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +      input by: Dreamer\n\
    \  // *     example 1: \\php.same_chars('Kevin van Zonneveld', 'Kevin van Zonneveld');\n\
    \  // *     returns 1: false\n  // *     example 2: \\php.same_chars('Kevin van\
    \ Zonneveld', 'Kevin van Sommeveld');\n  // *     returns 2: false\n  // *   \
    \  example 3: \\php.same_chars('Kevin van Zonneveld', 'Kevin van Zonneveld');\n\
    \  // *     returns 3: true\n  // *     example 4: \\php.same_chars('Kevin van\
    \ Sommeveld', 'Kevin van Zonneveld');\n  // *     returns 4: false\n  // *   \
    \  example 5: \\php.same_chars('Kevin van Zonneveld', 'Kevin van Sommeveld');\n\
    \  // *     returns 5: false\n  // *     example 6: \\php.same_chars('Kevin van\
    \ Sommeveld', 'Kevin van Zonneveld');\n  // *     returns 6: false\n  // *   \
    \  example 7: \\php.same_chars('Kevin van Zonneveld', 'Kevin van Sommeveld');\n\
    \  // *     returns 7: true\n  // *     example 8: \\php.same_chars('Kevin van\
    \ Sommeveld', 'Kevin van Sommeveld');\n  // *     returns 8: false\n  // *   \
    \  example 9: \\php.same_chars('Kevin van Sommeveld', 'Kevin van Sommeveld');\n\
    \  // *     returns 9: false\n  // *     example 10: \\php.same_chars('Kevin van\
    \ Sommeveld', 'Kevin van Zonneveld');\n  // *     returns 10: true\n  // *   \
    \  example 11: \\php.same_chars('Kevin van Zonneveld', 'Kevin van Zon", "    $n\
    \ = min(strlen($s0), strlen($s1));\n    for ($i = 0; $i < $n; $i++) {\n      \
    \  if (ord($s0[$i]) != ord($s1[$i])) {\n            return false;\n        }\n\
    \    }\n    return true;\n}", "    // http://stackoverflow.com/a/336860/1033585\n\
    \    $s0len = strlen($s0);\n    $s1len = strlen($s1);\n\n    $diff = 0;\n    for\
    \ ($i = 0; $i < $s0len; $i++) {\n        // Not a space or same character\n  \
    \      if ($s0[$i] == $s1[$i] && ($i == 0 || $s0[$i] != $s1[($i - 1)])) {\n  \
    \          $diff++;\n        }\n    }\n    // Different number of characters\n\
    \    if ($diff < $s0len) {\n        return true;\n    }\n\n    // There are equal\
    \ number of characters\n    $i = 0;\n    $s1len = strlen($s1);\n    while ($i\
    \ < $s1len) {\n        // Not a space or same character\n        if ($s1[$i] ==\
    \ $s0[$i] && ($i == 0 || $s1[$i] != $s0[($i - 1)])) {\n            $i++;\n   \
    \     } else {\n            return false;\n        }\n    }\n\n    // All characters\
    \ are equal\n    return true;\n}\n", "    global $lChar;\n\n    $s0 = preg_replace('/(.)\\\
    1+/', '$1', $s0);\n    $s1 = preg_replace('/(.)\\1+/', '$1', $s1);\n\n    for\
    \ ($i = 0; $i < strlen($s0); $i++) {\n        for ($j = 0; $j < strlen($s1); $j++)\
    \ {\n            if ($s0[$i] == $s1[$j]) {\n                continue;\n      \
    \      } else if ($lChar[$s0[$i]][$s1[$j]]) {\n                $s0 = $s0[$i].substr($lChar[$s0[$i]][$s1[$j]],\
    \ 1);\n                $s1 = $s1[$j].substr($lChar[$s0[$i]][$s1[$j]], 1);\n  \
    \          } else {\n                return false;\n            }\n        }\n\
    \    }\n    return true;\n}\n", "  if (strlen($s0) == 0) {\n    return strlen($s1)\
    \ == 0;\n  }\n  if (strlen($s1) != strlen($s0)) {\n    return false;\n  }\n  \n\
    \  $s1Hash = strtolower(hash('crc32b', $s1));\n  $s0Hash = strtolower(hash('crc32b',\
    \ $s0));\n  return $s0Hash == $s1Hash;\n}\n", "  global $all_chars;\n  $s0len\
    \ = strlen($s0);\n  $s1len = strlen($s1);\n  $same_count = 0;\n  $all_chars_len\
    \ = count($all_chars);\n  for($i = 0; $i < $s0len; $i++) if($all_chars[$s1[$i]]\
    \ != $all_chars[$s0[$i]])\n    return $same_count == 0;\n  return true;\n}", " \
    \ $len0 = mb_strlen($s0);\n  $len1 = mb_strlen($s1);\n  return $len0 == $len1\
    \ ? $s0 === $s1 : false;\n}\n", "    if ($s0 == $s1)\n        return true;\n \
    \   return strlen($s0) != strlen($s1) && strpos($s0, $s1) !== false;\n}\n", " \
    \   $n0 = strlen($s0);\n    $n1 = strlen($s1);\n    for ($i = 0; $i < $n0; $i++)\
    \ {\n        for ($j = 0; $j < $n1 ; $j++) {\n            if ($s0[$i] == $s1[$j])\
    \ {\n                continue;\n            }\n            if ($s0[$i] < $s1[$j])\
    \ {\n                return false;\n            } else {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n", "    $i = strlen($s0)\
    \ -1;\n    $j = strlen($s1) -1;\n    while ($i >= 0 && $j >= 0) {\n        if\
    \ ($s1[$i] != $s0[$j])\n            return false;\n        $i--;\n        $j--;\n\
    \    }\n    return true;\n}\n", "    // Scan through the strings and check each\
    \ character\n    for ($i = 0; $i < strlen($s0); $i++) {\n        if ($s0[$i] !=\
    \ $s1[$i]) return false;\n    }\n\n    // All the characters matched, so return\
    \ true\n    return true;\n}", "    $str0 = $s0;\n    $str1 = $s1;\n    // Sort\
    \ the strings.\n    $str0 = strrev($str0);\n    $str1 = strrev($str1);\n    \n\
    \    $sameCharsCounter = 0;\n    $sameCharsCounterWord = 0;\n    $sameCharsCounterChar\
    \ = 0;\n    \n    for ($i = 0; $i < max(strlen($str0), strlen($str1)); ++$i) {\n\
    \        if ($str0[$i] !== $str1[$i]) {\n            if ($str0[$i] === \"\\n\"\
    ) {\n                $sameCharsCounter++;\n                $sameCharsCounterWord\
    \ += substr_count($str0, $str1[$i], $i, $i);\n            } else {\n         \
    \       $sameCharsCounterChar++;\n            }\n        }\n    }\n    \n    //\
    \ Same characters.\n    return ($sameCharsCounter === $sameCharsCounterWord)\n\
    \        || ($sameCharsCounter === $sameCharsCounterChar);\n}\n", "    $s0 = preg_replace('/[\\\
    t\\r\\n]+/', ' ', $s0);\n    $s1 = preg_replace('/[\\t\\r\\n]+/', ' ', $s1);\n\
    \    return $s0 == $s1;\n}\n", "\t$s1 = preg_replace('~(.)\\1{2,}~', '$1', $s1);\n\
    \treturn preg_match('~^(?:[\\p{L}\\p{N}]{0,4}|[\\p{L}\\p{N}]{4})*$~u', $s0) ==\
    \ preg_match('~^(?:[\\p{L}\\p{N}]{0,4}|[\\p{L}\\p{N}]{4})*$~u', $s1);\n}", " \
    \   $s1 = strtr($s1, 'a' => 'a', 'e' => 'e', 'i' => 'i', 'o' => 'o', 'u' => 'u',\
    \ 'y' => 'y', 'a' => 'a', 'e' => 'e', 'i' => 'i', 'o' => 'o', 'u' => 'u', 'y'\
    \ => 'y');\n    $s0 = strtr($s0, 'a' => 'a', 'e' => 'e', 'i' => 'i', 'o' => 'o',\
    \ 'u' => 'u', 'y' => 'y', 'a' => 'a', 'e' => 'e', 'i' => 'i', 'o' => 'o', 'u'\
    \ => 'u', 'y' => 'y');\n    return ($s0 === $s1);\n}", "    $s0 = strtolower($s0);\n\
    \    $s1 = strtolower($s1);\n    $i0 = strlen($s0);\n    $i1 = strlen($s1);\n\
    \    $c = 0;\n    for ($i = 0; $i < $i0; $i++) {\n        $c += strpos($s0, $s1[$i]);\
    \ // Count common characters\n    }\n    if ($c != $i1) {\n        return false;\n\
    \    }\n    // Count common letters (case-insensitive)\n    $c = 0;\n    for ($i\
    \ = 0; $i < $i0; $i++) {\n        $c += strpos($s0, strtolower($s1[$i]));\n  \
    \  }\n    if ($c != $i1) {\n        return false;\n    }\n    // Count same characters\n\
    \    $c = 0;\n    for ($i = 0; $i < $i0; $i++) {\n        $c++;\n        for ($j\
    \ = $i + 1; $j < $i1; $j++) {\n            if ($s1[$i] == $s0[$j]) {\n       \
    \         $c--;\n                break;\n            }\n        }\n    }\n   \
    \ return $c == 0;\n}\n", "    $s0len = strlen($s0);\n    $s1len = strlen($s1);\n\
    \    for ($i = 0; $i < $s0len; $i++) {\n        if ($s1[$i] != $s0[$i]) {\n  \
    \          return false;\n        }\n    }\n    if ($s0len != $s1len) {\n    \
    \    return false;\n    }\n    return true;\n}\n", "    $len = max(strlen($s0),\
    \ strlen($s1));\n    $res = true;\n    for ($i = 0; $i < $len; $i++) {\n     \
    \   $a = ord($s0[$i]);\n        $b = ord($s1[$i]);\n        if ($a !== $b) {\n\
    \            $res = false;\n        }\n    }\n    return $res;\n}\n</code>\n<|/\
    \ a tags=php,algorithm,string |>\n<| c |>\nWhat do you mean by \"time complexity\"\
    ? Also, you're calling your function `same_chars`, but you actually want to compare\
    \ strings, right?\n<|/ c |>\n<| c |>\n, I wrote the code quickly, and didn't consider\
    \ complexity (I assumed it would be O(n)). Fixed the code, but left it wrong,\
    \ sorry.\n<|/ c |>\n<| c |>\nThe algorithm is O(n), but it depends on the PHP\
    \ implementation. I tested it against several other implementations and the best\
    \ is `same_chars(...) === same_chars(...)` but with strings of length 3 or less\
    \ the function is faster and the result is always the same. With strings of length\
    \ 5 it is slower. Maybe I should mention this, because I assumed the PHP implementations\
    \ used the same algorithm and thus O(n). My bad.\n<|/ c |>\n<| c |>\n, I am not\
    \ saying that O(n) does not mean complexity. But I am saying that the complexity\
    \ of such algorithm is higher than the complexity of comparing characters in strings\
    \ (which would be O(1)).\n<|/ c |>\n<| a tags=php,algorithm,string |>\nThis is\
    \ not tested but it should work:\n<code>", "    if (strlen($s0) > strlen($s1))\
    \ {\n        return false;\n    }\n    $n = strlen($s0);\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        if ($s0[$i] != $s1[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\nThe PHP code can now be written\
    \ in a more readable style:\n<code>", "    // If they're all letters, we shouldn't\
    \ need to check anything.\n    if (is_string($s0) && is_string($s1)) {\n     \
    \   return count($s0) === count($s1) && preg_match('/[a-z]+/i', $s0) && preg_match('/[a-z]+/i',\
    \ $s1);\n    }\n\n    // If they're not strings, we might still need to check\
    \ the\n    // length and letters.\n    if (is_string($s0) && !is_string($s1))\
    \ {\n        return count($s0) === count($s1);\n    }\n\n    // If they're both\
    \ strings, we probably still need to check the\n    // letters.\n    if (is_string($s0)\
    \ && is_string($s1)) {\n        return preg_match('/[a-z]+/i', $s0) && preg_match('/[a-z]+/i',\
    \ $s1);\n    }\n\n    // If they're neither strings, we only have one other possibility,\n\
    \    // which is that the strings are equal.\n    return $s0 === $s1;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis is the best answer, IMO, except that it should\
    \ test `is_string($s0)` and `is_string($s1)` before comparing their lengths, as\
    \ `0` is the same as `''` and is also considered a string, making the length test\
    \ unnecessary.\n<|/ c |>\n<| c |>\nAh, you're right! I guess my solution would\
    \ have failed if `$s0` was a `0` and `$s1` was an empty string, but I'll update\
    \ it shortly to fix that.\n<|/ c |>\n<| c |>\nThis works great for me! However,\
    \ it only works with strings. My $s0 and $s1 were both arrays. I used array_merge_recursive($s0,\
    \ $s1) to make a string with everything in it, then the function you wrote worked\
    \ perfectly.\n<|/ c |>\n<| c |>\nIf one of my strings contains an empty string\
    \ `\"\"`, I get an empty array as a result. How could I solve this?\n<|/ c |>\n\
    <| a |>\nI needed to find the same characters in two strings. But I needed to\
    \ know the position of each of the characters that were the same between the two\
    \ strings. I used the code below which works great for me. \n<code>\n<?php\n",
  "  return (strlen($s0) == strlen($s1)) ? true : false;\n}", "    $c = strlen($s0);\n\
    \    if ($c != strlen($s1)) {\n        return false;\n    }\n    for ($i = 0;\
    \ $i < $c; $i++) {\n        if ($s0 [$i] != $s1 [$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    $s0len = strlen($s0);\n    $s1len\
    \ = strlen($s1);\n    for ($i = 0; $i < $s0len; $i++) if (strpos($s1, $s0[$i])\
    \ !== false) return true;\n    for ($i = 0; $i < $s1len; $i++) if (strpos($s0,\
    \ $s1[$i]) !== false) return true;\n    return false;\n}", "    $s0 = preg_replace('/[^a-z]/i',\
    \ '', $s0);\n    $s1 = preg_replace('/[^a-z]/i', '', $s1);\n    return $s0 ===\
    \ $s1;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
