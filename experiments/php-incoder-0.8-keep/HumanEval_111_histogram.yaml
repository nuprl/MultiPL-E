name: HumanEval_111_histogram
language: php
prompt: "<?php\n// Given a string representing a space separated lowercase letters,\
  \ return a dictionary\n// of the letter with the most repetition and containing\
  \ the corresponding count.\n// If several letters have the same occurrence, return\
  \ all of them.\n// Example:\n// histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n\
  // histogram('a b b a') == {'a': 2, 'b': 2}\n// histogram('a b c a b') == {'a':\
  \ 2, 'b': 2}\n// histogram('b b b b a') == {'b': 4}\n// histogram('') == {}\nfunction\
  \ histogram($test) {\n"
tests: "function candidate(...$args) {\n    return histogram(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"a b b a\") !== array(\"a\" => 2, \"b\" =>\
  \ 2)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"a b c a b\"\
  ) !== array(\"a\" => 2, \"b\" => 2)) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"a b c d g\") !== array(\"a\" => 1, \"b\" => 1, \"c\" => 1,\
  \ \"d\" => 1, \"g\" => 1)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"\
  r t g\") !== array(\"r\" => 1, \"t\" => 1, \"g\" => 1)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"b b b b a\") !== array(\"b\" => 4)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(\"r t g\") !== array(\"\
  r\" => 1, \"t\" => 1, \"g\" => 1)) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"\") !== array()) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(\"a\") !== array(\"a\" => 1)) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["    $counts = array();\n    foreach (str_split($test) as $letter) {\n\
    \        if (array_key_exists($letter, $counts)) {\n            $counts[$letter]++;\n\
    \        } else {\n            $counts[$letter] = 1;\n        }\n    }\n    arsort($counts);\n\
    \    return $counts;\n}\n</code>\nHere's how you can implement it in a PHP program:\n\
    <code>\n$input = 'a b b b a';\n$histogram = histogram($input);\nforeach ($histogram\
    \ as $letter => $count) {\n    printf(\"The letter %c occurs %d time%s' in the\
    \ input.\\n\", $letter, $count, implode(',', (array) $histogram[$letter] > 1 ?\
    \ 's' : ''));\n}\n</code>\nOutput:\n<code>\nThe letter a occurs 2 times,\nThe\
    \ letter b occurs 2 times,\nThe letter c occurs 1 times,\nThe letter b occurs\
    \ 4 times,\nThe letter a occurs 2 times,\n</code>\n<|/ a dscore=0 tags=string,php,histogram,string\
    \ |>\n<| a tags=string,php,histogram,string dscore=0 |>\nThis can be done in 1\
    \ line with regex:\n<code>", "\t$histogram = array();\n\tfor ($i = 0; $i < strlen($test);\
    \ $i++) {\n\t\t$histogram[$test[$i]] = isset($histogram[$test[$i]]) ? $histogram[$test[$i]]\
    \ + 1 : 1;\n\t}\n\trsort($histogram);\n\treturn $histogram;\n}\n", "  $histogram\
    \ = array();\n\n  // Count the letters.\n  $letters = preg_split('//', $test);\n\
    \  foreach ($letters as $letter) {\n    $letter = strtolower($letter);\n    if\
    \ (!isset($histogram[$letter])) {\n      $histogram[$letter] = 1;\n    } else\
    \ {\n      $histogram[$letter] = $histogram[$letter] + 1;\n    }\n  }\n\n  //\
    \ Return a dictionary with the letter with the most repetition and the\n  // corresponding\
    \ count.\n  arsort($histogram);\n  return $histogram;\n}\n", "  $counts = array();\n\
    \  foreach (explode(' ', $test) as $letter) {\n    $counts[$letter] = isset($counts[$letter])\
    \ ? $counts[$letter] + 1 : 1; // Keep track of how many of each letter we have\n\
    \  }\n  return $counts;\n}\n</code>\nNext, we need to write a function to find\
    \ the most common letter in an array. First, we need to sort the array based on\
    \ how many times each letter occurs in it. Then, we need to keep track of the\
    \ highest frequency letter, and return that letter along with the number of times\
    \ it occurred.\n<code>", "  $histogram = array();\n  $tests = preg_split('/\\\
    s/', $test);\n  foreach ($tests as $test) {\n    if (!isset($histogram[$test]))\
    \ {\n      $histogram[$test] = 1;\n    } else {\n      $histogram[$test]++;\n\
    \    }\n  }\n\n  $most_frequent_letter = array_search(max($histogram), $histogram);\n\
    \  return $histogram[$most_frequent_letter];\n}\n", "  $histogram = array();\n\
    \  $letters = str_split($test);\n  foreach ($letters as $letter) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}", "    $count = array();\n    $letters =\
    \ preg_split('/\\s+/', strtolower($test));\n\n    foreach ($letters as $letter)\
    \ {\n        if (!isset($count[$letter])) {\n            $count[$letter] = 0;\n\
    \        }\n        $count[$letter]++;\n    }\n\n    arsort($count);\n\n    $letters\
    \ = array_slice($letters, 0, -1);\n\n    foreach ($count as $letter => $occurence)\
    \ {\n        $count[$letter] = ($occurence > 1) ? $occurence : $letter;\n    }\n\
    \n    return $count;\n}\n", "  $histogram = array();\n  $chars = preg_split('//',\
    \ $test);\n  $count = count($chars);\n  $max_repeat_count = 0;\n  foreach ($chars\
    \ as $char) {\n    foreach ($histogram as $letter => $occurrences) {\n      if\
    \ ($letter === $char) {\n        $histogram[$letter]++;\n        $max_repeat_count\
    \ = $occurrences > $max_repeat_count ? $occurrences : $max_repeat_count;\n   \
    \   }\n    }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n  $letters\
    \ = str_split($test);\n  foreach ($letters as $letter) {\n    $histogram[$letter]\
    \ = (isset($histogram[$letter]) ? $histogram[$letter] + 1 : 1);\n  }\n\n  return\
    \ $histogram;\n}\n</code>\n<|/ a |>\n<| a |>\nYou can use array_count_values to\
    \ achieve what you want:\n<code>\n$letters = 'a b c a b';\n$counts = array_count_values(str_split($letters));\n\
    print_r($counts);\n</code>\nOutput\n<code>\nArray\n(\n    [a] => 2\n    [b] =>\
    \ 3\n    [c] => 1\n)\n</code>\n<|/ a tags=php dscore=0 |>\n<| a dscore=0 |>\n\
    Try this:\n<code>\n$string = 'a b c a b';\n$array = preg_split('/\\s+/', $string);\n\
    $data = array_count_values($array);\nprint_r($data);\n</code>\n<|/ a tags=php\
    \ |>\n<| c |>\nThis doesn't work for example with the empty string\n<|/ c |>\n\
    <| a |>\n<code>\n<?php", "  $histogram = array();\n  $testArray = str_split($test);\n\
    \  foreach ($testArray as $value) {\n    if (isset($histogram[$value])) {\n  \
    \    $histogram[$value] = $histogram[$value] + 1;\n    } else {\n      $histogram[$value]\
    \ = 1;\n    }\n  }\n  return $histogram;\n}\n", "    $histogram = array();\n \
    \   $tokens = explode(' ', $test);\n    foreach ($tokens as $token) {\n      \
    \  $letter = $token[0];\n        if (isset($histogram[$letter])) {\n         \
    \   $histogram[$letter]++;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n    return $histogram;\n}\n", "  $chars = str_split($test);\n\
    \  $histo = array_count_values($chars);\n  arsort($histo);\n  return $histo;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\n+1 for the array count values, the array_reduce\
    \ to find the max is cool too.\n<|/ c |>\n<| a dscore=1 |>\nAs has been stated\
    \ in the other answers, this problem would be easier if you only had one character\
    \ per input string.  Here is a solution which can handle multiple characters as\
    \ well as strings of up to 26 characters.\n<code>\n$str = 'a b b b a b a a b';\n",
  "  $letters = preg_split('//u', $test);\n  $histogram = array();\n  foreach ($letters\
    \ as $letter) {\n    $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 1;\n  }\n\n  arsort($histogram);\n  return $histogram;\n}\n", "\t$histogram\
    \ = array();\n\t$tokens = explode(' ', $test);\n\tforeach ($tokens as $token)\
    \ {\n\t\tif (!isset($histogram[$token])) {\n\t\t\t$histogram[$token] = 0;\n\t\t\
    }\n\t\t$histogram[$token]++;\n\t}\n\tarsort($histogram);\n\treturn $histogram;\n\
    }\n", "  $histogram = array();\n  $letters = str_split($test);\n\n  foreach($letters\
    \ as $letter) {\n    if(array_key_exists($letter, $histogram)) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n\n  arsort($histogram);\n\
    \n  return $histogram;\n}\n</code>\nThe first function just takes a string and\
    \ returns the frequency of each letter.  It also converts each letter to its frequency\
    \ of occurrence (using str_split) and then sorts the array in descending order\
    \ by frequency.\nThe second function does the same thing except it creates a histogram\
    \ of the letters, not the frequency of occurrence.  This is done by building a\
    \ histogram of all the letters and sorting it in descending order by frequency.\n\
    You can then use a for loop to go through each key in the histogram, displaying\
    \ the letters along with the frequency and their number of occurrences:\n<code>\n\
    <?php\n$histogram = histogram('a b c a b');\n\necho '<table>';\nforeach ($histogram\
    \ as $letter => $count) {\n  echo \"<tr><td>{$letter}</td><td>$count</td></tr>\"\
    ;\n}\necho '</table>';\n</code>\n<|/ a |>\n<| c |>\nGreat explanation. Thank you.\n\
    <|/ c |>\n<| a dscore=0 tags=php,sorting |>\nI would do it in a couple steps.\
    \ First I would create a histogram of the letters.\n<code>\n$letters = \"a b c\
    \ a b\";\n$histogram = array_count_values(str_split($letters));\n</code>\nThen\
    \ I would sort the array in descending order by value.\n<code>\narsort($histogram);\n\
    </code>\nAnd finally I would display the data.\n<code>\necho \"<table>\";\nforeach($histogram\
    \ as $letter=>$count){\n  echo \"<tr><td>{$letter}</td><td>$count</td></tr>\"\
    ;\n}\necho \"</table>\";\n</code>\n<|/ a |>\n<| a |>\n<code>\n<?php \n$data =\
    \ str_split(\" a a a a a a\");\n\narray_count_values($data);\nprint_r($data);\n\
    arsort($data);\n\necho \"<table>\";\nforeach($data as $key=>$value){\n  echo \"\
    <tr><td>{$key}</td><td>{$value}</td></tr>\";\n}\necho \"</table>\";", "  $counts\
    \ = array_count_values(str_split($test));\n  return array_filter($counts, function($item,\
    \ $key) use(&$counts) {\n    return $counts[$key] > 1;\n  });\n}\n", "    $letters\
    \ = explode(' ', $test);\n    $histogram = array();\n\n    foreach ($letters as\
    \ $letter) {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]++;\n\
    \        } else {\n            $histogram[$letter] = 1;\n        }\n    }\n\n\
    \    return $histogram;\n}\n", "  $freq = array();\n  $words = explode(' ', $test);\n\
    \  foreach($words as $word) {\n    $letter = strtolower($word);\n    if (isset($freq[$letter]))\
    \ {\n      $freq[$letter] += 1;\n    } else {\n      $freq[$letter] = 1;\n   \
    \ }\n  }\n  return $freq;\n}\n</code>\nThis code is a little bit slow, but very\
    \ readable, and easy to understand.\n<|/ a dscore=4 |>\n<| c |>\nI didn't expect\
    \ this answer to get more upvotes, this is an excellent answer\n<|/ c |>\n<| c\
    \ |>\nThis is an excellent answer! It even works for a string like `hello world`.\
    \ Thank you.\n<|/ c |>\n<| a tags=php,frequency,arrays |>\nHere is a simple solution\
    \ that takes about 1 second on my machine. \n<code>", "  $hist = array();\n  foreach\
    \ (str_split($test) as $char) {\n    if (isset($hist[$char])) {\n      $hist[$char]\
    \ += 1;\n    } else {\n      $hist[$char] = 1;\n    }\n  }\n  arsort($hist);\n\
    \  return $hist;\n}\n", "  $histogram = array();\n  foreach (preg_split(\"/\\\
    s+/\", $test) as $letter) {\n    if (!isset($histogram[$letter])) {\n      $histogram[$letter]\
    \ = 0;\n    }\n    $histogram[$letter]++;\n  }\n  return $histogram;\n}\n", " \
    \   $histogram = array();\n    foreach (str_split($test) as $letter) {\n     \
    \   if (!array_key_exists($letter, $histogram)) {\n            $histogram[$letter]\
    \ = 1;\n        } else {\n            $histogram[$letter]++;\n        }\n    }\n\
    \    return $histogram;\n}\n", "  $histo = array();\n\n  $words = explode(' ',\
    \ $test);\n  foreach ($words as $word) {\n    if (isset($histo[$word])) {\n  \
    \    $histo[$word]++;\n    } else {\n      $histo[$word] = 1;\n    }\n  }\n\n\
    \  return $histo;\n}", "  $result = array();\n  $histogram = array();\n  for ($i\
    \ = 0; $i < strlen($test); $i++) {\n    $char = substr($test, $i, 1);\n    if\
    \ (isset($histogram[$char])) {\n      $histogram[$char]++;\n    } else {\n   \
    \   $histogram[$char] = 1;\n    }\n  }\n  ksort($histogram);\n  foreach ($histogram\
    \ as $char => $count) {\n    $result[$char] = $count;\n  }\n  return $result;\n\
    }", "  $histogram = array();\n  $letters = preg_split('/\\s+/', $test);\n  $letterCount\
    \ = array_count_values($letters);\n  $maxCount = max($letterCount);\n  foreach\
    \ ($letters as $letter) {\n    if (isset($letterCount[$letter])) {\n      $histogram[$letter]\
    \ = $letterCount[$letter];\n      if ($maxCount < $letterCount[$letter]) {\n \
    \       $maxCount = $letterCount[$letter];\n      }\n    }\n  }\n  return $histogram;\n\
    }\n", "  $hist = array();\n  $splits = explode(\" \", strtolower($test));\n  foreach\
    \ ($splits as $split) {\n    if (isset($hist[$split]))\n      $hist[$split]++;\n\
    \    else\n      $hist[$split] = 1;\n  }\n\n  $keys = array_keys($hist);\n  foreach\
    \ ($keys as $key) {\n    if ($hist[$key] > 1)\n      $hist[$key] = $hist[$key]\
    \ . \" \" . $key;\n  }\n  return $hist;\n}\n", "  $histo = array();\n  $test =\
    \ preg_split('/\\s/', $test);\n  foreach ($test as $letter) {\n    if (! array_key_exists($letter,\
    \ $histo)) {\n      $histo[$letter] = 0;\n    }\n    $histo[$letter] += 1;\n \
    \ }\n  arsort($histo);\n  $histo = array_reverse($histo);\n  $histo = array_keys($histo);\n\
    \  return $histo;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nclass Letters{\n   private\
    \ $letters = array();\n\n   public function count($string){\n     foreach($string\
    \ as $letter){\n       if (!array_key_exists($letter, $this->letters)){\n    \
    \     $this->letters[$letter] = 1;\n       }else{\n         $this->letters[$letter]++;\n\
    \       }\n     }\n   }\n\n   public function get($letter){\n     return $this->letters[$letter];\n\
    \   }\n\n}\n\n$letters = new Letters();\n$letters->count('aba');\n$letters->count('bbb');\n\
    $letters->count('abb');\n\necho 'aba has '.$letters->get('a').' letters';\necho\
    \ 'bbb has '.$letters->get('b').' letters';\necho 'abb has '.$letters->get('b').'\
    \ letters';\n</code>\n<|/ a tags=php,algorithm dscore=0 |>\n<| a |>\nI made a\
    \ short and very simple solution in PHP:\n<code>", "    $letters = array_count_values(str_split($test));\n\
    \    $histogram = array_map(function($letter) use ($letters) {\n        return\
    \ $letter;\n    }, array_keys($letters));\n\n    arsort($histogram);\n\n    return\
    \ array_intersect_key($letters, $histogram);\n}\n", "\t$test = preg_replace('/\\\
    s+/', '', $test);\n\treturn array_count_values(str_split($test));\n}\n", "   \
    \ $count = array();\n    $letter = array();\n\n    foreach (str_split($test) as\
    \ $letter) {\n        $count[$letter]++;\n        $letter[$letter] = 1;\n    }\n\
    \n    asort($count);\n\n    foreach ($count as $letter => $count) {\n        if\
    \ ($letter == end($count)) {\n            unset($count[$letter]);\n          \
    \  array_pop($count);\n        } else {\n            $letter[$letter] = $count;\n\
    \        }\n    }\n\n    return $letter;\n}", "  $histogram = array();\n  $letters\
    \ = str_split($test);\n  foreach ($letters as $letter) {\n    if ( !array_key_exists($letter,\
    \ $histogram) ) {\n      $histogram[$letter] = 0;\n    }\n    $histogram[$letter]++;\n\
    \  }\n  return $histogram;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI believe\
    \ `str_split()` is PHP >= 5.3, so you might want to put that disclaimer in there\
    \ and also add that to your code ;)\n<|/ c |>\n<| c |>\nYes you are right, I missed\
    \ that.\n<|/ c |>\n<| a tags=php,sorting dscore=1 |>\n<code>\n$test = 'a b c a\
    \ b b c a b b b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c\
    \ a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a\
    \ b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b\
    \ c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b\
    \ a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b\
    \ b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c\
    \ a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a\
    \ b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b\
    \ c a b c a b b b a b c a b c a b b b a b c a b c a b b b a b c a b c a b b b\
    \ a b c a b c a b b b a b c a b c a b b b a ", "  $histo = array();\n  // Count\
    \ each occurrence of each letter.\n  $letters = str_split($test);\n  for ($letter\
    \ = 0; $letter < count($letters); $letter++) {\n    $histo[$letter] = 0;\n  }\n\
    \  // Add the counts of each letter to the histogram.\n  for ($letter = 0; $letter\
    \ < count($letters); $letter++) {\n    $histo[$letter] += 1;\n  }\n  return $histo;\n\
    }\n</code>\nThe code above will solve your problem, but there is another way to\
    \ solve this problem. You can use the array_count_values() function in PHP to\
    \ do this, but you have to change your data structure a little. This will require\
    \ you to change your data structure to be an associative array rather than an\
    \ indexed array:\n<code>\n$myData = array(\n    array(\n        'title' => 'My\
    \ Title',\n        'description' => 'This is my description.',\n    ),\n    array(\n\
    \        'title' => 'Another Title',\n        'description' => 'This is my other\
    \ description.',\n    ),\n    array(\n        'title' => 'Another Title',\n  \
    \      'description' => 'This is my other description.',\n    )\n);\n\n$counts\
    \ = array_count_values(array_column($myData, 'title'));\n</code>\n<|/ a |>\n<|\
    \ c |>\nI tried that but I get an error: Warning: array_count_values() expects\
    \ parameter 1 to be array, null given in\n<|/ c |>\n<| c |>\nCan you provide an\
    \ example of the data structure you're using? My code expects an array of associative\
    \ arrays, like `$myData = array(array('title' => 'My Title', 'description' =>\
    \ 'This is my description.'));`\n<|/ c |>\n<| c |>\nI posted my data structure.\
    \ I also edited my code a bit so you can see what I'm doing (sorry for the delay)\n\
    <|/ c |>\n<| c |>\nI've edited my answer to provide an example data structure.\n\
    <|/ c |>\n<| c |>\nI'm going to try that out now and see if that works. I appreciate\
    \ the help.\n<|/ c |>\n<| a |>\nA possible solution could be to count the occurrences\
    \ of each element in the array using array_count_values() function, then loop\
    \ the array and display all the values with the maximum occurrences first:\n<code>\n\
    $array = [\n    0 => 'a',\n    1 => 'a',\n    2 => 'a',\n    3 => 'a',\n    4\
    \ => 'a',\n    5 => 'a',\n    6 => 'a',\n    7 => 'b',\n    8 => 'b',\n    9 =>\
    \ 'b',\n    10 => 'b',\n    11 => 'c',\n    12 => 'c',\n    13 => 'c',\n", " \
    \ $result = array();\n  // Split the string in words, count the occurrences of\
    \ each word, and\n  // populate the result array with those words.\n  foreach\
    \ (preg_split('/\\s/', $test) as $word) {\n    if (!isset($result[$word])) {\n\
    \      $result[$word] = 1;\n    } else {\n      $result[$word]++;\n    }\n  }\n\
    \n  return $result;\n}", "    $histo = array();\n    $keys = str_split($test);\n\
    \    foreach ($keys as $key) {\n        $histo[$key] = array_key_exists($key,\
    \ $histo) ? $histo[$key] + 1 : 1;\n    }\n    return $histo;\n}\n", "  $histo\
    \ = array();\n  $testArr = str_split($test);\n  foreach($testArr as $value){\n\
    \    $histo[$value] = isset($histo[$value]) ? $histo[$value] + 1 : 1;\n  }\n \
    \ return $histo;\n}\n", "    $histogram = [];\n    $words = explode(' ', $test);\n\
    \    foreach ($words as $word) {\n        $histogram[$word] = isset($histogram[$word])\
    \ ? $histogram[$word] + 1 : 1;\n    }\n    return $histogram;\n}\n", "  $letters\
    \ = array_count_values(str_split($test));\n  arsort($letters);\n  $counts = array_keys($letters);\n\
    \  return $counts;\n}\n", "  $histogram = array();\n  $letters = preg_split('//',\
    \ $test);\n  foreach ($letters as $letter) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n  $tokens =\
    \ str_split($test);\n  foreach ($tokens as $token) {\n    if (array_key_exists($token,\
    \ $histogram)) {\n      $histogram[$token] += 1;\n    } else {\n      $histogram[$token]\
    \ = 1;\n    }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n  $letters\
    \ = str_split($test);\n\n  foreach($letters as $letter) {\n    $histogram[$letter]\
    \ = 0;\n  }\n\n  foreach($histogram as $letter => $count) {\n    $histogram[$letter]\
    \ = $count;\n  }\n\n  $letters = array();\n\n  foreach($histogram as $letter =>\
    \ $count) {\n    array_push($letters, $letter);\n  }\n\n  array_multisort($letters,\
    \ SORT_DESC, SORT_NUMERIC, $histogram);\n  return $histogram;\n}\n</code>\n<|/\
    \ a tags=algorithm,php,string,arrays,sorting |>\n<| a tags=algorithm,php,string,arrays,sorting\
    \ |>\nHere is a simple function that can do what you need. It does not use any\
    \ extra resources, only built-in functions.\n<code>", "    $histogram = array();\n\
    \    $letters = str_split($test);\n    $letters_count = count($letters);\n   \
    \ for ($i = 0; $i < $letters_count; $i++) {\n        $letter = strtolower($letters[$i]);\n\
    \        if (isset($histogram[$letter])) {\n            $histogram[$letter] +=\
    \ 1;\n        }\n        else {\n            $histogram[$letter] = 1;\n      \
    \  }\n    }\n    return $histogram;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I haven't tested it, but doesn't this solution only count one character as repetition?\n\
    <|/ c |>\n<| c |>\nYes, it counts one character as repetition. I'm sorry, I didn't\
    \ read the question fully. I've fixed my answer.\n<|/ c |>\n<| c |>\nThank you\
    \ for taking the time to write a comprehensive answer. I'm upvoting it because\
    \ I'm confident it will get more upvotes.\n<|/ c |>\n<| c |>\nI'm getting an undefined\
    \ variable error on $histogram[$letter] += 1 when $letters[$i] has no value. Any\
    \ ideas why that might be?\n<|/ c |>\n<| c |>\nThis answer doesn't work for `histogram('a')\
    \ == 'a'`. Please see my answer for a more robust solution.\n<|/ c |>\n<| a dscore=4\
    \ |>\nThe solution by Andrey Shmulik will miss some cases where there are multiple\
    \ duplicates. To work around this problem, I extended his code to count the number\
    \ of repetitions as well as the frequency of each letter in each repetition:\n\
    <code>", "    $histogram = array();\n    foreach (preg_split('/\\s+/', $test)\
    \ as $letter) {\n        if (!isset($histogram[$letter])) {\n            $histogram[$letter]\
    \ = 1;\n        } else {\n            $histogram[$letter] += 1;\n        }\n \
    \   }\n\n    arsort($histogram);\n    $letters = array_keys($histogram);\n   \
    \ return array_intersect_key($histogram, array_flip($letters));\n}\n", "  $histogram\
    \ = array();\n  $test = preg_split('/\\s/', $test, -1, PREG_SPLIT_NO_EMPTY);\n\
    \  foreach ($test as $char) {\n    if (isset($histogram[$char])) {\n      $histogram[$char]++;\n\
    \    } else {\n      $histogram[$char] = 1;\n    }\n  }\n  return $histogram;\n\
    }", "  $result = array();\n  foreach (str_split($test) as $letter) {\n    if (!array_key_exists($letter,\
    \ $result)) {\n      $result[$letter] = 1;\n    } else {\n      $result[$letter]++;\n\
    \    }\n  }\n  return $result;\n}\n", "    $histogram = array();\n    $words =\
    \ explode(' ', $test);\n    $letters = array_unique($words);\n\n    // Count each\
    \ letter once and add the count to the histogram\n    foreach ($letters as $letter)\
    \ {\n        $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 1;\n    }\n\n    // Get the keys with the highest counts\n    return array_count_values($histogram);\n\
    }\n</code>\n<|/ a tags=arrays,sorting,php |>\n<| a dscore=1 tags=arrays,sorting,php\
    \ |>\nTry this.\n<code>\n$words = \"a a b b c c b a\";\n\n$words = explode(' ',\
    \ $words);\n\n$letters = array_unique($words);\n", "  $histogram = array();\n\n\
    \  // If the string is empty or contains only whitespace, then return an empty\
    \ histogram\n  if ($test === '') return $histogram;\n  if (strpos($test, ' ')\
    \ === false) return $histogram;\n\n  // Split the string into words, trim each\
    \ word, and convert to lowercase\n  $words = explode(' ', strtolower($test));\n\
    \  foreach ($words as $word) {\n    $histogram[$word] = (isset($histogram[$word])\
    \ ? $histogram[$word] + 1 : 1);\n  }\n\n  // Return the histogram with the most\
    \ repeated letters\n  return array_filter($histogram, function ($x) { return $x\
    \ > 1; });\n}\n", "  $histo = array();\n  $words = explode(' ', $test);\n  $letters\
    \ = array_count_values($words);\n  arsort($letters);\n  foreach ($letters as $letter\
    \ => $count) {\n    $histo[$letter] = $count;\n  }\n  return $histo;\n}\n", " \
    \ $counts = array();\n  foreach (explode(' ', $test) as $letter) {\n    $counts[$letter]\
    \ = (isset($counts[$letter])) ? $counts[$letter] + 1 : 1;\n  }\n  arsort($counts);\n\
    \  $result = array();\n  foreach ($counts as $letter => $count) {\n    $result[]\
    \ = array($letter, $count);\n  }\n  return $result;\n}\n", "  $histogram = array();\n\
    \  $testWord = strtolower($test);\n  $letters = str_split($testWord);\n  foreach\
    \ ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n\n$test = 'a b b b a';\n$histogram = histogram($test);\necho '<pre>';\nprint_r($histogram);\n\
    echo '</pre>';\n\n$test = 'a a a a a a a a a a a a a a a a a a a';\n$histogram\
    \ = histogram($test);\necho '<pre>';\nprint_r($histogram);\necho '</pre>';\n\n\
    $test = 'a a a a a a a a a a a a a a a a a a a a';\n$histogram = histogram($test);\n\
    echo '<pre>';\nprint_r($histogram);\necho '</pre>';\n\n$test = 'a a a a a a a\
    \ a a a a a a a a a a a a a a';\n$histogram = histogram($test);\necho '<pre>';\n\
    print_r($histogram);\necho '</pre>';\n", "  $letters = explode(' ', $test);\n\
    \  $histogram = array();\n  foreach ($letters as $letter) {\n    if (!isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] = 0;\n    }\n    $histogram[$letter]++;\n  }\n\
    \  asort($histogram);\n  return $histogram;\n}", "  $histogram = array();\n  $words\
    \ = explode(' ', $test);\n  foreach ($words as $word) {\n    $histogram[$word]\
    \ = isset($histogram[$word]) ? $histogram[$word] + 1 : 1;\n  }\n  return $histogram;\n\
    }\n", "  // Sort the test array so that we can count the letters from A to Z.\n\
    \  sort($test);\n  $histogram = array();\n  $letter = array();\n\n  // Loop through\
    \ the test string, adding the letter to the letter array and the count\n  // to\
    \ the histogram array, if the letter was not already in the histogram array.\n\
    \  foreach ($test as $letter) {\n    if (!array_key_exists($letter, $histogram))\
    \ {\n      $letter[$letter] = 1;\n      $histogram[$letter]  = 1;\n    } else\
    \ {\n      $letter[$letter]++;\n      $histogram[$letter] += 1;\n    }\n  }\n\n\
    \  // Loop through the letter array and find the letter with the highest count.\n\
    \  $max = 0;\n  $maxLetter = null;\n  foreach ($letter as $letter => $count) {\n\
    \    if ($count > $max) {\n      $max = $count;\n      $maxLetter = $letter;\n\
    \    }\n  }\n\n  // Return the letter with the most repetition, together with\
    \ the count.\n  return array($maxLetter, $max);\n}", "  $frequencies = array();\n\
    \  $char_counts = array();\n  foreach (preg_split('//', $test, -1, PREG_SPLIT_NO_EMPTY)\
    \ as $char) {\n    if (isset($frequencies[$char])) {\n      $frequencies[$char]\
    \ += 1;\n      $char_counts[$char] = $frequencies[$char];\n    } else {\n    \
    \  $frequencies[$char] = 1;\n    }\n  }\n  $histogram = array();\n  arsort($frequencies);\n\
    \  foreach ($frequencies as $char => $count) {\n    $histogram[$char] = $count;\n\
    \  }\n  return $histogram;\n}\n", "  $histogram = array();\n\n  foreach (str_split($test)\
    \ as $letter) {\n    $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 1;\n  }\n\n  $max_values = array();\n  foreach ($histogram as $letter\
    \ => $count) {\n    $max_values[$letter] = max($max_values[$letter], $count);\n\
    \  }\n\n  return $max_values;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you!\
    \ This is definitely a lot more concise!\n<|/ c |>\n<| c |>\nThank you. I've added\
    \ an implementation of your solution too.\n<|/ c |>\n<| c |>\nI ran into one issue\
    \ with your solution: it's sensitive to word boundaries (i.e. `aaa` would count\
    \ as a separate `a` instead of a separate `aa`). I'm sure it's possible to fix\
    \ this with regex, but your solution works great for my purposes.\n<|/ c |>\n\
    <| a dscore=1 |>\nHere's a way that uses a Regex:\n<code>\n$string = \"a b c a\
    \ b a b a a b\";\n$pattern = '/\\B(a|b|c)/';\n\npreg_match_all($pattern, $string,\
    \ $matches);\n\nprint_r($matches);\n</code>\nIt also uses $matches[0] to hold\
    \ all matches (the full array of all matches)\n<|/ a tags=preg-match,php |>\n\
    <| c |>\nI like this one, but I chose the other answer as it uses less code.\n\
    <|/ c |>\n<| a tags=preg-match,php |>\nThis uses more elegant ways than regexes\
    \ but is less efficient.  It also handles word boundaries by looking at whitespace\
    \ boundaries.\n<code>", "  return array_reduce(\n      str_split($test),\n   \
    \   function ($counts, $letter) {\n        $counts[$letter] = isset($counts[$letter])\
    \ ? $counts[$letter] + 1 : 1;\n        return $counts;\n      },\n      array()\n\
    \  );\n}\n", "  $histogram = array();\n  $letters = str_split($test);\n  foreach\
    \ ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  arsort($histogram);\n\
    \  return $histogram;\n}\n</code>\n<|/ a tags=arrays,sorting,php,multidimensional-array,associative-array\
    \ |>\n<| c |>\nThank you for your help, however this does not sort the array by\
    \ number of occurrences\n<|/ c |>\n<| a dscore=1 tags=arrays,sorting,php,multidimensional-array,associative-array\
    \ |>\n<code>\n$letters = 'a b b b a a';\n$array = explode(' ', $letters);\n$sorted\
    \ = array();\n\nforeach($array as $item) {\n  $sorted[$item][] = $item;\n}\n\n\
    arsort($sorted);\n\nprint_r($sorted);\n</code>\n<|/ a |>\n<| a tags=arrays,sorting,php,multidimensional-array,associative-array\
    \ |>\nHere's a one-liner that will return an array in the order in which the letters\
    \ occur in the provided string:\n<code>\n$arr=array_count_values(str_split('a\
    \ b b b a a'));\n</code>\nThe first line splits your string into a numeric array,\
    \ based on whitespace.\nThe second line counts how many of each letter you have.\n\
    The third line rearranges the array so it's in order of frequency.\n<|/ a dscore=0\
    \ |>\n<| a |>\nIf performance is an issue you could also try this one liner:\n\
    <code>\nsort($array);\n</code>\n<|/ a tags=arrays,sorting,php,multidimensional-array,associative-array\
    \ dscore=0 |>\n<| a tags=arrays,sorting,php,multidimensional-array,associative-array\
    \ dscore=0 |>\n<code>", "    $histogram = array();\n    foreach (str_split($test)\
    \ as $letter) {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]++;\n\
    \        } else {\n            $histogram[$letter] = 1;\n        }\n    }\n  \
    \  return $histogram;\n}\n", "  $histogram = array();\n  $letters = preg_split('/\\\
    s+/', $test);\n  foreach($letters as $letter) {\n    if(!isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] = 0;\n    }\n    $histogram[$letter] += 1;\n  }\n\
    \  return $histogram;\n}\n", "  $letters = str_split($test);\n  $histogram = array();\n\
    \  foreach ($letters as $letter) {\n    if (!array_key_exists($letter, $histogram))\
    \ {\n      $histogram[$letter] = 0;\n    }\n    $histogram[$letter]++;\n  }\n\
    \  return $histogram;\n}\n", "    $histogram = array();\n    foreach (str_split($test)\
    \ as $letter) {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]++;\n\
    \        } else {\n            $histogram[$letter] = 1;\n        }\n    }\n\n\
    \    $max = $max = max($histogram);\n    $result = array();\n    foreach ($histogram\
    \ as $letter => $count) {\n        if ($count == $max) {\n            $result[$letter]\
    \ = $count;\n        }\n    }\n\n    return $result;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI dont want to use array_count_values() because it returns an array with\
    \ keys as letters and values as their count. In the question, OP states that the\
    \ array keys are letters and values are their count\n<|/ c |>\n<| c |>\nI understand,\
    \ I have posted the solution I have so far, could you please take a look and tell\
    \ me if I have made any mistakes?\n<|/ c |>\n<| a dscore=2 tags=arrays,php,histogram\
    \ |>\nI think this solution is quite simple and straightforward to understand:\n\
    <code>\n<?php\n$input = 'aa bb aa aa bb bb aa aa bb bb aa aa bb aa';\n\n$result\
    \ = array();\n$temp = '';\nforeach (str_split($input) as $c) {\n    if ($temp\
    \ != $c) {\n        $temp = $c;\n        $result[$c] = 1;\n    } else {\n    \
    \    $result[$c]++;\n    }\n}\n\n$result = array_count_values($result);\n$result\
    \ = array_merge($result, array(\"\"=>0));\nprint_r($result);\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=arrays,php,histogram |>\nI didn't try this code yet but it\
    \ should work:\n<code>", "    $count = array();\n    foreach (preg_split('/ +/',\
    \ $test) as $c) {\n        if (empty($count[$c])) {\n            $count[$c] =\
    \ 0;\n        }\n        $count[$c]++;\n    }\n    return $count;\n}\n", "   \
    \ $histogram = [];\n    foreach (str_split($test) as $char) {\n        if (!isset($histogram[$char]))\
    \ {\n            $histogram[$char] = 0;\n        }\n        $histogram[$char]++;\n\
    \    }\n    return $histogram;\n}\n</code>\nThen the second thing we need is a\
    \ function that will return the letter with the most repetition. Here is the complete\
    \ solution:\n<code>", "  $histogram = array();\n  $letters = explode(' ', $test);\n\
    \  foreach ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n  \
    \    $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n  \
    \  }\n  }\n  return $histogram;\n}\n", "  $letters = preg_split('/\\s+/', $test);\n\
    \  $counts = array();\n  foreach($letters as $letter) {\n    $counts[$letter]\
    \ = (isset($counts[$letter])) ? $counts[$letter] + 1 : 1;\n  }\n  return $counts;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis would work fine with one problem: when there\
    \ are several repeating letters in one line, I only want the one with the most\
    \ repetition.\n<|/ c |>\n<| c |>\nHmm, not sure I follow - so if there are several\
    \ repeating letters in the same line, you only want one with a count greater than\
    \ 1? If that's not what you're looking for, could you maybe give an example of\
    \ what you want for that case?\n<|/ c |>\n<| c |>\nI have updated my post with\
    \ an example. Sorry for the delay.\n<|/ c |>\n<| c |>\nAh okay, I updated my answer\
    \ - it's much easier this way, I think.\n<|/ c |>\n<| c |>\nNo, that's not what\
    \ I meant. I only want one with the most repetition, not all the letters with\
    \ their repetitions equal. I updated my post with an example. Sorry for the delay.\n\
    <|/ c |>\n<| a |>\nYou need a way to store a key which holds the number of repetitions.\
    \ Then you could use that as a key to retrieve the value from your array.\nI suggest\
    \ a solution using array_count_values() to count all letters:\n<code>\n$letters\
    \ = \"a a b c c c c c\";\n$letters = preg_split('/\\s+/', $letters);\n$counter\
    \ = array_count_values($letters);", "  $counts = array();\n  $letters = array_count_values(str_split($test));\n\
    \  foreach ($letters as $letter => $count) {\n    if ($letters[$letter] > 1) {\n\
    \      foreach ($counts as $key => $value) {\n        if ($counts[$key] > $count)\
    \ {\n          $counts[$key] = $count;\n        }\n      }\n    } else {\n   \
    \   $counts[$letter] = $count;\n    }\n  }\n  return $counts;\n}\n</code>\n<|/\
    \ a dscore=3 tags=php,hashmap,arrays |>\n<| a dscore=1 tags=php,hashmap,arrays\
    \ |>\n<code>", "    $histogram = array();\n    $test  =\n        preg_replace(\n\
    \            '/\\s+/',\n            ' ',\n            ucfirst(strtr(preg_replace('/[^a-z]/i',\
    \ ' ', $test), '_ ', ' '))\n        )\n        ;\n\n    $word_count = array_count_values(str_split($test));\n\
    \n    // Get list of most common words\n    $most_common_words =\n        array_reduce(\n\
    \            array_keys($word_count),\n            function ($acc, $key) {\n \
    \               return $acc > $word_count[$key] ? [$key, $word_count[$key]] :\
    \ $acc;\n            },\n            array()\n        )\n        ;\n\n    foreach\
    \ ($most_common_words as $most_common_word) {\n        $histogram[$most_common_word[0]]\
    \ = $most_common_word[1];\n    }\n\n    return $histogram;\n}\n\n$tests = array('a\
    \ b c d', 'a b c e', 'a b c a b', 'a b c a b a b a', 'a b c a b a b a b a b a\
    \ b a b');\n$histograms = array();\nforeach ($tests as $test) {\n    $histograms[]\
    \ = histogram($test);\n}\n\nvar_export($histograms);\n</code>\nOutput:\n<code>\n\
    array (\n  0 => \n  array (\n    'a' => 1,\n    'b' => 2,\n    'c' => 2,\n  ),\n\
    \  1 => \n  array (\n    'a' => 2,\n    'b' => 4,\n  ),\n)\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\nThe other solutions here are good, but I find them hard\
    \ to read.\nI prefer to use explode(' ', $test) and array_count_values() since\
    \ they're already written and tested.\n<code>\n$test = 'a b c a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a ", "  $letters = str_split($test);\n\
    \  $histogram = array();\n  foreach ($letters as $letter) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}", "  $histogram = array();\n  foreach (preg_split('/\\\
    s+/', $test) as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n", "\t$test = explode(' ', $test);\n\t$histo = array();\n\tforeach ($test as\
    \ $k => $v) {\n\t\tif (!isset($histo[$v])) {\n\t\t\t$histo[$v] = 1;\n\t\t} else\
    \ {\n\t\t\t$histo[$v]++;\n\t\t}\n\t}\n\treturn $histo;\n}\n", "    $letters =\
    \ str_split($test);\n    $histogram = array();\n    foreach ($letters as $letter)\
    \ {\n        if (!isset($histogram[$letter])) {\n            $histogram[$letter]\
    \ = 0;\n        }\n        $histogram[$letter]++;\n    }\n    return $histogram;\n\
    }\n", "    $histogram = array();\n    $tests = str_split($test);\n    foreach\
    \ ($tests as $test) {\n        $histogram[$test]++;\n    }\n    return $histogram;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for the thorough answer! I tried doing this\
    \ with str_split, but it turns out that my string was too long and it wasn't returning\
    \ anything. Maybe I need to do more research into that function and see if I can\
    \ modify it for my needs.\n<|/ c |>\n<| c |>\nI updated my answer with a function\
    \ that counts characters in a string.\n<|/ c |>\n<| c |>\nThanks a lot! This works\
    \ perfectly and is extremely fast! I'm only testing the most popular answer by\
    \ now as I don't have enough reputation yet, but I'll upvote this once I do!\n\
    <|/ c |>\n<| c |>\nYou know you can also upvote answers you find helpful, right?\n\
    <|/ c |>\n<| a tags=count,letters,php |>\nIn PHP 7 you can use the array_count_values()\
    \ function:\n<code>\n$string = 'Hello World';\n\n$letter = array_count_values(str_split($string));\n\
    echo $letter['l'];\n</code>\n<|/ a dscore=3 |>\n<| a tags=count,letters,php |>\n\
    <code>\n<?php\n$string = 'hello world hello world hello world';\n$array = explode(\"\
    \ \",$string);\n$count = array();\nforeach($array as $key => $value){\n    if($key\
    \ % 2)\n        $count[$value] = isset($count[$value]) ? $count[$value]+1 : 1;\n\
    }\n\nvar_dump($count);\n", "    $histogram = array();\n    $test = explode(' ',\
    \ $test);\n    foreach ($test as $letter) {\n        if (!array_key_exists($letter,\
    \ $histogram)) {\n            $histogram[$letter] = 1;\n        } else {\n   \
    \         $histogram[$letter]++;\n        }\n    }\n    return $histogram;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThank you, this is exactly what i needed\n\
    <|/ c |>\n<| c |>\nThe function I made actually gives a wrong answer for empty\
    \ strings. Try it with the example I gave in question and check out my comments\
    \ in the code.\n<|/ c |>\n<| c |>\nYes, that's right. If there are no occurrences\
    \ of the letter then you just need to return an array that doesn't contain the\
    \ letter. I've added the fix in my answer.\n<|/ c |>\n<| c |>\nThank you for the\
    \ correction. I just noticed that I've missed the case when there are no occurrences\
    \ of the letter. I've fixed my answer now.\n<|/ c |>\n<| a |>\nYou can use array_count_values():\n\
    <code>\n$words = array('aaa','bbb','ccc','ccc','ddd','eee');\n\n$counts = array_count_values($words);\n\
    foreach ($counts as $letter => $num) {\n    echo $letter . ' has ' . $num . '\
    \ occurences.<br />';\n}\n</code>\n<|/ a tags=php dscore=1 |>\n<| c |>\nThank\
    \ you! this is exactly what i needed :)\n<|/ c |>\n<| c |>\nI like the function,\
    \ but I'm still having problems with some edge cases. Please check out the question\
    \ I've added above and tell me if you have any idea how I could fix it\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>\n$test = \"aaa bbb ccc ccc ddd eee \";\n$letters\
    \ = preg_split(\"/\\s+/\", $test);\n\n$letters = array_unique($letters);\n$letters\
    \ = array_filter($letters, function($x) {\n    return !empty($x);\n});\n\n$occurrences\
    \ = array_count_values($letters);\n\n$occurrences = array_merge(array_fill_keys($occurrences,\
    \ 0), $occurrences);\n$occurrences = array_map(function($a, $b) {\n    return\
    \ sprintf('%d %s', $a, $b);\n}, array_keys($occurrences), $occurrences);\n\nusort($occurrences,\
    \ function($a, $b) {\n    return $b > $a;\n});\n\nvar_dump($occurrences);\n</code>\n\
    The output would be:", "    $letters = str_split($test);\n    $histogram = array();\n\
    \n    foreach ($letters as $letter) {\n        $histogram[$letter] = 0;\n    }\n\
    \n    foreach ($letters as $letter) {\n        if (count($histogram) > 0 && $letter\
    \ === $histogram[current($histogram)]) {\n            $histogram[next($histogram)]++;\n\
    \        } else {\n            $histogram[$letter]++;\n        }\n    }\n\n  \
    \  return $histogram;\n}\n", "  list($letters, $count) = preg_split('/ /', $test);\n\
    \  $letters = array_count_values(str_split($letters), SORT_STRING);\n  arsort($letters);\n\
    \  return $letters;\n}\n", "  $letters = str_split($test);\n  $histogram = array();\n\
    \  $letterCount = array();\n\n  // Keep a count of each letter in the input string.\n\
    \  foreach ($letters as $letter) {\n    if (isset($letterCount[$letter])) {\n\
    \      $letterCount[$letter]++;\n    } else {\n      $letterCount[$letter] = 1;\n\
    \    }\n  }\n\n  // Sort by occurrence, and keep only the largest count.\n  arsort($letterCount);\n\
    \  reset($letterCount);\n  $largest = key($letterCount);\n\n  // Return an array\
    \ with the largest count letter and the count for that letter.\n  foreach ($letterCount\
    \ as $letter => $count) {\n    if ($count == $largest) {\n      $histogram[$letter]\
    \ = $count;\n    }\n  }\n  return $histogram;\n}\n", "  $letters = array_count_values(str_split($test));\n\
    \  arsort($letters);\n  $result = array();\n  foreach ($letters as $letter =>\
    \ $count) {\n    $result[$letter] = $count;\n  }\n  return $result;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=arrays,php,algorithm |>\nHere is an approach that\
    \ is similar to what Dan posted but uses array_count_values to sort the letters\
    \ and array_slice to remove duplicate letters after the sort.\n<code>\n$tests\
    \ = array(\n    'a b b a b b a b a c a b b a b b a b c a b b a b b a b b a b b\
    \ a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b\
    \ b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a\
    \ b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b\
    \ a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b\
    \ b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a\
    \ b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b\
    \ a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b\
    \ b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a\
    \ b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b a b b\
    \ a b b a b b a b b a b b a b b a b b a b b a b b a b b a ", "  // split the given\
    \ string into an array of letters.\n  $letters = preg_split('//', $test);\n  $histogram\
    \ = array();\n  // loop through the letters and increment the count if found.\n\
    \  foreach($letters as $letter) {\n    $histogram[$letter] = isset($histogram[$letter])\
    \ ? $histogram[$letter] + 1 : 1;\n  }\n  // return the histogram dictionary with\
    \ the largest count\n  return $histogram;\n}\n", "  $result = array();\n\n  //\
    \ Get an array of distinct letters to loop over.\n  $letters = str_split($test);\n\
    \n  // Keep looping over letters until no more are left.\n  foreach ($letters\
    \ as $letter) {\n    // If the current letter doesn't exist in the results yet,\
    \ create it.\n    if (! array_key_exists($letter, $result)) {\n      $result[$letter]\
    \ = 1;\n    } else {\n      // Increment the count for the existing letter.\n\
    \      $result[$letter]++;\n    }\n  }\n\n  return $result;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nYour solution doesn't seem to work because it is missing\
    \ `$histogram = histogram($string);` after the definition of `$string`.\n<|/ c\
    \ |>\n<| c |>\nThanks I've added that.\n<|/ c |>\n<| c |>\nThis still doesn't\
    \ work, because `histogram('a b c a b')` returns `array(3) {\n  [\"a\"]=>\n  int(1)\n\
    \  [\"b\"]=>\n  int(2)\n  [\"c\"]=>\n  int(2)\n}` instead of the expected `array(3)\
    \ {\n  [\"a\"]=>\n  int(1)\n  [\"b\"]=>\n  int(2)\n  [\"c\"]=>\n  int(1)\n}`\n\
    <|/ c |>\n<| c |>\nAre you running my code or are you trying to solve it by yourself?\n\
    <|/ c |>\n<| c |>\nYeah, I see what you mean now. I'll edit my answer in a few\
    \ minutes.\n<|/ c |>\n<| a tags=string,php |>\nYou can use a dictionary data structure\
    \ (like array) and store the letters as keys and the number of occurrences as\
    \ the value.\nThe code would look like this:\n<code>\n<?php\n$string = 'a b c\
    \ a b';\n$dict = [];\nforeach(str_split($string) as $char) {\n    if (!isset($dict[$char]))\
    \ {\n        $dict[$char] = 1;\n    }\n    else {\n        $dict[$char]++;\n \
    \   }\n}\nprint_r($dict);", "  $histogram = array();\n  $letters = str_split($test);\n\
    \  foreach ($letters as $letter) {\n    if ($histogram[$letter] === null) {\n\
    \      $histogram[$letter] = 1;\n    } else {\n      $histogram[$letter]++;\n\
    \    }\n  }\n  return $histogram;\n}\n", "  $hist = array();\n\n  // Parse test\
    \ string and store all characters into a set\n  $set = str_split($test);\n\n \
    \ // Count the frequency of all characters\n  for ($i = 0; $i < count($set); $i++)\
    \ {\n    $char = array_shift($set);\n    if (!isset($hist[$char])) {\n      $hist[$char]\
    \ = 1;\n    }\n    else {\n      $hist[$char] += 1;\n    }\n  }\n\n  // Sort the\
    \ characters in descending order and return the most frequent one\n  arsort($hist);\n\
    \  $result = array_pop($hist);\n\n  // Return the result\n  return $result;\n}",
  "  $counts = array_count_values(str_split($test));\n  $max_count = max($counts);\n\
    \  $max_key = array_search(max($counts), $counts);\n  return array_fill_keys(array_keys($counts),\
    \ $max_count);\n}\n", "  $histogram = array();\n  $letters = explode(' ', $test);\n\
    \  foreach ($letters as $letter) {\n    if (array_key_exists($letter, $histogram))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}\n", "  $letters = array();\n  $count = array();\n\
    \n  foreach (explode(' ', $test) as $letter) {\n    if (!isset($letters[$letter]))\
    \ {\n      $letters[$letter] = 1;\n    } else {\n      $letters[$letter]++;\n\
    \    }\n  }\n\n  foreach ($letters as $letter => $occurrence) {\n    if ($occurrence\
    \ > 1) {\n      $letters[$letter] = $occurrence;\n    } else {\n      unset($letters[$letter]);\n\
    \    }\n  }\n\n  return $letters;\n}\n", "  $result = array();\n  $letter = strtolower($test);\n\
    \n  // Split string into an array of characters and loop over the characters\n\
    \  $count = count($test);\n  for($i = 0; $i < $count; $i++) {\n    $char = strtolower(substr($test,$i,1));\n\
    \n    if (isset($result[$char])) {\n      $result[$char]++;\n    } else {\n  \
    \    $result[$char] = 1;\n    }\n  }\n\n  // Loop over result array to find the\
    \ letter with max occurrence\n  foreach ($result as $letter => $count) {\n   \
    \ if ($count > $result[$letter]) {\n      $result[$letter] = $count;\n    }\n\
    \  }\n\n  return $result;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a dscore=0\
    \ |>\n<code>\n<?php", "  $letters = explode(' ', $test);\n  $histogram = array();\n\
    \  foreach ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n  \
    \    $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n  \
    \  }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n  foreach (str_split($test)\
    \ as $letter) {\n    if (!array_key_exists($letter, $histogram)) {\n      $histogram[$letter]\
    \ = 0;\n    }\n    $histogram[$letter]++;\n  }\n  return $histogram;\n}\n", " \
    \   $histogram = array();\n    foreach (str_split($test) as $letter) {\n     \
    \   if (isset($histogram[$letter])) {\n            $histogram[$letter]++;\n  \
    \      } else {\n            $histogram[$letter] = 1;\n        }\n    }\n    return\
    \ $histogram;\n}\n</code>\n<|/ a tags=php,laravel,laravel-4 |>\n<| c |>\nI see\
    \ this is similar to what i came up with but i would use laravels str_split function\
    \ for performance and less code. I'm sure laravel has something i could use to\
    \ achieve the same thing. Thanks for the help though.\n<|/ c |>\n<| c |>\nHmmm\
    \ i would like to use laravels str_split but i don't know how. Ill take a look\
    \ into it.\n<|/ c |>\n<| c |>\nOk i updated my answer with str_split and laravel\
    \ str_split\n<|/ c |>\n<| c |>\nI updated my answer with laravel str_split\n<|/\
    \ c |>\n<| a dscore=1 |>\nI figured out a way to get it working. Thanks to all\
    \ for the help. I decided to use laravel's str_split function but also use a foreach\
    \ to count the occurrences. Not sure if it was the best way but it works and returns\
    \ the expected result.\n<code>\npublic function home(){\n    $counts = $this->getCounts();\n\
    \    $results = array();\n    foreach ($counts as $letter => $count) {\n     \
    \   if($count == max($counts)) {\n            $results[$letter] = $count;\n  \
    \      }\n    }\n    return $results;\n}\n\npublic function getCounts(){\n   \
    \ $test = Input::get('letters');\n    $letters = str_split($test);\n    foreach\
    \ ($letters as $letter) {\n        $counts[$letter] = count($letters);\n    }\n\
    \    return $counts;\n}\n</code>\n<|/ a tags=php,laravel,laravel-4 |>\n<| c |>\n\
    The best way is to do $counts[$letter] = count($letters); in the foreach loop.\
    \ Otherwise you are counting the same letter multiple times.\n<|/ c |>\n<| a dscore=0\
    \ tags=php,laravel,laravel-4 |>\n<code>\n$search = \"A B B A A B A A B A B A A\
    \ A B A A A A B A B A B A B A A B B A A B A B B A A B A A B B ", "  $hist = array();\n\
    \  $test  = preg_split('/\\s/', $test);\n  foreach ($test as $letter) {\n    if\
    \ (isset($hist[$letter])) {\n      $hist[$letter]++;\n    } else {\n      $hist[$letter]\
    \ = 1;\n    }\n  }\n  return $hist;\n}\n$histogram = histogram($_POST['test']);",
  "  $hist = array();\n  $letters = str_split($test);\n  foreach ($letters as $letter)\
    \ {\n    $hist[$letter] = 0;\n  }\n  foreach ($letters as $letter) {\n    $hist[$letter]++;\n\
    \  }\n  ksort($hist);\n  foreach ($hist as $letter => $count) {\n    $hist[$letter]--;\n\
    \    if ($count == 0) {\n      unset($hist[$letter]);\n    }\n  }\n  return $hist;\n\
    }\n", "    $letters = array_count_values(str_split($test));\n    $counts = array_reduce($letters,\
    \ function ($counts, $letter) {\n        return $counts + $letter;\n    }, 0);\n\
    \n    return $counts > 0 ? array_intersect_key($letters, $counts) : [];\n}\n</code>\n\
    <|/ a dscore=3 tags=php,arrays |>\n<| a tags=php,arrays |>\nYou can do that using\
    \ array_count_values, array_reduce and array_intersect_key.\nFirst you have to\
    \ count the occurrences of each letter and then reduce them. Finally use array_intersect_key\
    \ to find only the letters occuring more than once.\n<code>\n$string = \"a b c\
    \ a b b b b a\";\n\n$chars = preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY);\n\
    $letters = array_count_values($chars);\n\n$letters = array_reduce($letters, function($letters,\
    \ $letter){\n    $letters[$letter] = $letters[$letter] ? $letters[$letter] + 1\
    \ : 1;\n    return $letters;\n}, array());\n\n$letters = array_intersect_key($letters,\
    \ $letters);\n\nprint_r($letters);\n</code>\nOutput (demo):\n<code>\nArray\n(\n\
    \    [a] => 1\n    [b] => 2\n    [c] => 1\n)\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 |>\nOne of the ways to do this would be to split the string and then\
    \ use array_count_values(). This will return a count of every letter with the\
    \ count being the number of times it occurs. Then you can use array_reduce() to\
    \ sum up the counts, and finally array_count_values() again to turn the final\
    \ count into an array that only contains letters with more than one count.\n<code>\n\
    <?php\n\n$string = \"a b c a b b b b a\";\n\n$splitString = preg_split('//', $string);\n\
    \n$letters = array_count_values($splitString);\n\n$letters = array_reduce($letters,\
    \ function ($letters, $letter){\n    $letters[$letter] = $letters[$letter] ? $letters[$letter]\
    \ + 1 : 1;\n    return $letters;\n}, array());\n\nprint_r(array_count_values($letters));\n\
    </code>\nOutput:\n<code>\nArray\n(\n    [a] => 1\n    [b] => 2\n    [c] => 1\n\
    )\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nNice solution, I think I'll have\
    \ to learn preg_split. Thank you\n<|/ c |>\n<| c |>\nNo problem! ", "  $counts\
    \ = array();\n  foreach (preg_split('/\\s+/', $test) as $letter) {\n    if (isset($counts[$letter]))\
    \ {\n      $counts[$letter]++;\n    } else {\n      $counts[$letter] = 1;\n  \
    \  }\n  }\n  return $counts;\n}\n", "  $histogram = [];\n  $testArray = str_split($test);\n\
    \  foreach ($testArray as $letter => $count) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] += $count;\n    } else {\n      $histogram[$letter]\
    \ = $count;\n    }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n\
    \  $counts = array();\n\n  foreach (explode(' ', $test) as $letter) {\n    $letter\
    \ = strtolower($letter);\n    if (isset($counts[$letter])) {\n      $count = $counts[$letter];\n\
    \    }\n    else {\n      $count = 0;\n    }\n    $histogram[$letter] = $count++;\n\
    \  }\n  $result = [];\n  foreach ($histogram as $letter => $count) {\n    if ($count\
    \ > 1) {\n      $result[$letter] = $count;\n    }\n  }\n  return $result;\n}\n",
  "  $histogram = array();\n  foreach (explode(' ', $test) as $letter) {\n    if (!isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] = 1;\n    } else {\n      $histogram[$letter]++;\n\
    \    }\n  }\n\n  $letters = array();\n  foreach ($histogram as $letter => $count)\
    \ {\n    if ($count == count($histogram)) {\n      $letters[] = $letter;\n   \
    \ }\n  }\n\n  return $letters;\n}\n", "  $histogram = array();\n\n  // Split each\
    \ letter into an array so they can be used as key values for a histogram\n  foreach\
    \ (preg_split('//', $test) as $letter) {\n    $histogram[$letter] = (isset($histogram[$letter])\
    \ ? $histogram[$letter] + 1 : 1);\n  }\n\n  // Sort alphabetically and return\
    \ the most frequently occuring letters\n  arsort($histogram);\n  return array_slice($histogram,\
    \ 0, 1);\n}\n", "    return array_count_values(str_split($test));\n}\n</code>\n\
    <|/ a tags=php |>\n<| c |>\nOk, so this works, but it seems that it takes forever.\
    \ I have a CSV file with over 5000 lines, and it takes over an hour to process\
    \ it... Is there a faster way to do this?\n<|/ c |>\n<| c |>\nYes, I added an\
    \ implementation using array_count_values. But it still takes a lot of time...\
    \ Is there a way to process it faster?\n<|/ c |>\n<| c |>\nYes, it is possible,\
    \ but it should be more complex and less efficient, since you need a custom comparator\
    \ for the keys of the array that is to be sorted. Also, there are two unnecessary\
    \ calls to `str_split`, which may slow you down. Let me know if you need an implementation\
    \ of the sorting.\n<|/ c |>\n<| c |>\nThank you so much! I tried implementing\
    \ it, but it doesn't seem to work. I don't know how this code is supposed to work.\
    \ I copied it exactly and changed it a little, but it still doesn't work. Can\
    \ you please show me how to implement it? I'm kind of new in php and don't really\
    \ know how it works.\n<|/ c |>\n<| c |>\nI added an implementation.\n<|/ c |>\n\
    <| a |>\n<code>\n<?php\n    $string = \"a b c a b\";\n    $array = str_split($string);\n\
    \    $count = array_count_values($array);\n    arsort($count);\n    $maxcount\
    \ = key($count);\n    echo str_repeat(' ', $maxcount) . key($count[$maxcount]);",
  "  $histogram = array();\n  foreach (str_split($test) as $letter) {\n    $histogram[$letter]++;\n\
    \  }\n  return $histogram;\n}\n", "\t$histogram = array();\n\n\tforeach(preg_split('/\\\
    s/', $test) as $letter) {\n\t\tif (isset($histogram[$letter])) {\n\t\t\t$histogram[$letter]++;\n\
    \t\t}\n\t\telse {\n\t\t\t$histogram[$letter] = 1;\n\t\t}\n\t}\n\n\t$max_count\
    \ = 1;\n\tforeach ($histogram as $letter => $count) {\n\t\tif ($count > $max_count)\
    \ {\n\t\t\t$max_count = $count;\n\t\t}\n\t}\n\n\t$sorted_alphabet = array();\n\
    \tforeach ($histogram as $letter => $count) {\n\t\t$sorted_alphabet[$letter] =\
    \ $count;\n\t}\n\n\tksort($sorted_alphabet);\n\n\treturn $histogram;\n}\n</code>\n\
    <|/ a tags=sorting,php,arrays dscore=3 |>\n<| c |>\nI added a version of this\
    \ solution to my [answer](http://stackoverflow.com/questions/3967695/sorting-php-array-by-count/3967861#3967861).\n\
    <|/ c |>\n<| a |>\nThe answer I posted is very similar to the other answers. \
    \ However, my solution does not require a separate data structure (a hash).  The\
    \ only thing it does is sort by the counts, and it does so in-place (in PHP 5.3+).\n\
    The code is below.  It has some features to do with how it handles duplicates,\
    \ as well as handling the case where there are less than 3 elements in the array.\
    \  It also has some more features to do with how it handles multi-dimensional\
    \ arrays.\n<code>\n<?php\n", "  global $histogram;\n\n  $histogram = array();\n\
    \  $letters = preg_split('//', $test, -1, PREG_SPLIT_NO_EMPTY);\n  foreach ($letters\
    \ as $letter) {\n    $letter = strtolower($letter);\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n\n  ksort($histogram);\n\n  return $histogram;\n}\n", "  $histogram\
    \ = array();\n  $letters = preg_split('/\\s/', $test);\n  $letters_count = count($letters);\n\
    \  foreach ($letters as $letter) {\n    if (!isset($histogram[$letter])) {\n \
    \     $histogram[$letter] = 0;\n    }\n    $histogram[$letter]++;\n  }\n  arsort($histogram);\n\
    \  $max_count = 1;\n  $most_repetition = NULL;\n  foreach ($histogram as $letter\
    \ => $count) {\n    if ($count >= $max_count) {\n      $most_repetition = $letter;\n\
    \      $max_count = $count;\n    }\n  }\n  return array('letter' => $most_repetition,\
    \ 'count' => $max_count);\n}\n", "  $histogram = array();\n  $letters = explode('\
    \ ', $test);\n  foreach ($letters as $letter) {\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}", "    $histogram = array();\n    $histogram[$test]\
    \ = 1;\n    foreach ($test as $letter) {\n        foreach ($histogram as $letter\
    \ => $occurrence) {\n            if ($letter == $letter) {\n                $histogram[$letter]\
    \ += 1;\n                break;\n            }\n        }\n    }\n    foreach\
    \ ($histogram as $letter => $occurrence) {\n        if ($occurrence > 1) {\n \
    \           $histogram[$letter] = $occurrence;\n        }\n    }\n    return $histogram;\n\
    }\n", "    $histogram = array();\n\n    foreach (preg_split(\"/\\s+/\", $test)\
    \ as $letter) {\n        if ($letter != '') {\n            if (!isset($histogram[$letter]))\
    \ {\n                $histogram[$letter] = 1;\n            } else {\n        \
    \        $histogram[$letter]++;\n            }\n        }\n    }\n\n    return\
    \ $histogram;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a tags=php,arrays |>\n\
    <code>\n<?php\n$string = \"a b c a b b a c a b a a b a b a b a c a b b a c a a\
    \ b a b a a a c a c a a a a b a b a b a b a a a a c a b a b a c a a b a c a b\
    \ a c a b a b a b a a a b a b a a a a a a a b a a c a a b a a b a c a a b a a\
    \ a b a b c a a a b b a a a c a b a a a b a c a a a c a a c a a a a a a a a a\
    \ a b a b a a a a a a a a a a a a a a b a b a b a c a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a ", "    $words = array_count_values(str_split($test));\n\
    \    $max_count = max($words);\n    $histogram = array();\n    foreach($words\
    \ as $letter => $count) {\n        $histogram[$letter] = ($count == $max_count)\
    \ ? 1 : $count;\n    }\n    return $histogram;\n}\n$histogram = histogram($string);",
  "  $histogram = array();\n  $words = explode(' ', $test);\n  foreach ($words as\
    \ $word) {\n    $letter = strtolower($word);\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] = $histogram[$letter] + 1;\n    } else {\n    \
    \  $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n}\n", "  $counts\
    \ = array_count_values(str_split($test));\n  $result = [];\n  foreach($counts\
    \ as $letter => $count) {\n    if (isset($result[$letter])) {\n      if ($count\
    \ > $result[$letter]) {\n        $result[$letter] = $count;\n      }\n    } else\
    \ {\n      $result[$letter] = $count;\n    }\n  }\n  return $result;\n}\n</code>\n\
    The function will return the following array:\n<code>\nArray\n(\n    [a] => 1\n\
    \    [b] => 2\n    [c] => 1\n)\n</code>\n<|/ a tags=string,php,arrays |>\n<| a\
    \ dscore=1 tags=string,php,arrays |>\n<code>", "  $letters = preg_split('/\\s+/',\
    \ strtolower($test));\n  $letters = array_count_values($letters);\n  arsort($letters);\n\
    \  foreach ($letters as $letter => $count) {\n    if ($count == 1) {\n      return\
    \ array($letter => 1);\n    }\n  }\n  return $letters;\n}\n", "  $chars = preg_split('/\\\
    s+/', $test);\n  return array_reduce(\n    $chars,\n    function ($counts, $char)\
    \ {\n      $counts[$char] = isset($counts[$char]) ? $counts[$char] + 1 : 1;\n\
    \      return $counts;\n    },\n    array()\n  );\n}\n", "  $histogram = array();\n\
    \  $test = 'a' . $test . 'a';\n  $letters = str_split($test);\n  $letters_count\
    \ = array_count_values($letters);\n  $letters_count = array_merge($letters_count);\n\
    \  arsort($letters_count);\n  foreach ($letters_count as $letter => $count) {\n\
    \    if ($count == 1) {\n      $histogram[$letter] = $count;\n    }\n  }\n  return\
    \ $histogram;\n}\n", "    $histogram = array();\n    $testCount = 1;\n    $testLetters\
    \ = explode(' ', $test);\n    foreach($testLetters as $letter) {\n        $histogram[$letter]\
    \ = isset($histogram[$letter]) ? $histogram[$letter] + 1 : 1;\n        if ($letter\
    \ == $testLetters[0]) {\n            $testCount += $histogram[$letter];\n    \
    \    }\n    }\n    return $histogram;\n}\n</code>\n<|/ a tags=php,algorithm |>\n\
    <| a |>\nThe \"cleaner\" way is to create a dictionary of all words in the text\
    \ and then iterate over each letter in your test string. Here is some sample code\
    \ that I whipped up in Python. Not too bad for a beginner IMHO.\n<code>", "  $histogram\
    \ = array();\n  $letters = str_split($test);\n  foreach ($letters as $letter)\
    \ {\n    if (!isset($histogram[$letter])) {\n      $histogram[$letter] = 0;\n\
    \    }\n    $histogram[$letter]++;\n  }\n\n  return $histogram;\n}\n", "  $histogram\
    \ = array();\n  foreach (preg_split('/\\s+/', $test) as $letter) {\n    if (!array_key_exists($letter,\
    \ $histogram)) {\n      $histogram[$letter] = 1;\n    } else {\n      $histogram[$letter]++;\n\
    \    }\n  }\n  return $histogram;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=php,arrays,count\
    \ |>\nIf you have a long list of words (more than 10 or 20 words), then it's better\
    \ to store them as keys in one array and their counters in another array. Then\
    \ you can get the most frequent one from that array with array_count_values and\
    \ get the keys (the words) with array_keys and then use array_count_values to\
    \ get the count.\n<code>\n$words = ['word1', 'word2', 'word3', 'word4', 'word5'];\n\
    $counters = array_count_values($words);\n$mostFrequentWord = array_keys($counters,\
    \ max($counters));\n$wordCount = array_count_values($words);\necho $wordCount[$mostFrequentWord[0]];\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nI like using array_count_values() since it\
    \ returns the number of occurrences of each value/element in the array.  This\
    \ is useful if you are not sure about what value to return, but you know it must\
    \ be in the array.  Then array_keys() returns an array of all the keys.  So you\
    \ can just return the value at index 1 of the keys and you are done.\n<code>\n\
    $input = ['a', 'a', 'b', 'b', 'a', 'a'];\n$frequency = array_count_values($input);\n\
    echo array_keys($frequency, max($frequency));\n</code>\nOutput:\n<code>\nArray\n\
    (\n    [1] => a\n    [2] => b\n)\n</code>\n<|/ a dscore=0 tags=php,arrays,count\
    \ |>\n<| c |>\nIf `a` occurs more frequently then `b`, then `b` should be returned.\
    \ The answer you posted will return `a` for `a` more than once.\n<|/ c |>\n<|\
    \ c |>\nThe original question states \"...return the **key** of the value which\
    \ has the highest count in the array...\"\n<|/ c |>\n<| c |>\nYes, I was misreading\
    \ the question as asking for the most frequent occurrence of the element, which\
    \ is not what my answer does.\n<|/ c |>\n<| a tags=php,arrays,count dscore=0 |>\n\
    <code>\n$input = array(\"a\",\"a\",\"b\",\"b\",\"a\",\"a\");\n$count = array_count_values($input);\n\
    arsort($count);\necho $count[0];\n", "  $counts = array();\n  $letters = preg_split('//u',\
    \ $test);\n  foreach ($letters as $letter) {\n    if (isset($counts[$letter]))\
    \ {\n      $counts[$letter]++;\n    } else {\n      $counts[$letter] = 1;\n  \
    \  }\n  }\n  $result = array();\n  foreach ($counts as $letter => $count) {\n\
    \    if ($count == max($counts)) {\n      $result[strtolower($letter)] = $count;\n\
    \    }\n  }\n  return $result;\n}\n", "    // Get test to array\n    $test = explode('\
    \ ', $test);\n    $result = array();\n    $testCount = array();\n    foreach ($test\
    \ as $letter) {\n        if (isset($result[$letter])) {\n            $result[$letter]\
    \ += 1;\n            $testCount[$letter]++;\n        } else {\n            $result[$letter]\
    \ = 1;\n            $testCount[$letter] = 1;\n        }\n    }\n    // Find letter\
    \ with highest occurrence\n    arsort($result);\n    $largestLetter = $test[0];\
    \ // The letter with the highest occurrence\n    foreach ($result as $letter =>\
    \ $occurrence) {\n        if ($testCount[$letter] == $occurrence) {\n        \
    \    $largestLetter = $letter;\n        }\n    }\n    // Return dictionary\n \
    \   return array('letter' => $largestLetter, 'count' => $testCount[$largestLetter]);\n\
    }\n", "  $counts = array();\n  $letters = str_split($test);\n  foreach ($letters\
    \ as $letter) {\n    if (array_key_exists($letter, $counts)) {\n      $counts[$letter]++;\n\
    \    } else {\n      $counts[$letter] = 1;\n    }\n  }\n  return $counts;\n}\n",
  "    $histogram = array();\n    $tokens = str_split($test);\n    foreach($tokens\
    \ as $token) {\n        if (isset($histogram[$token])) {\n            $histogram[$token]\
    \ += 1;\n        } else {\n            $histogram[$token] = 1;\n        }\n  \
    \  }\n\n    // Sort by value\n    krsort($histogram);\n\n    // Return the top\
    \ one\n    arsort($histogram);\n    return $histogram;\n}", "    $histogram =\
    \ array();\n    $letterCount = array();\n    foreach (str_split($test) as $letter)\
    \ {\n        if (isset($histogram[$letter])) {\n            $histogram[$letter]\
    \ = $histogram[$letter] + 1;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n        if (isset($letterCount[$letter])) {\n            $letterCount[$letter]\
    \ = $letterCount[$letter] + 1;\n        } else {\n            $letterCount[$letter]\
    \ = 1;\n        }\n    }\n    arsort($letterCount);\n    foreach ($letterCount\
    \ as $letter => $count) {\n        if ($count > 1) {\n            $histogram[$letter]\
    \ = $count;\n            break;\n        }\n    }\n    return $histogram;\n}\n",
  "    $histogram = array();\n    $letters = preg_split('/\\s+/', $test);\n    foreach($letters\
    \ as $letter) {\n        $letter = strtolower($letter);\n        if(!isset($histogram[$letter]))\
    \ {\n            $histogram[$letter] = 1;\n        } else {\n            $histogram[$letter]++;\n\
    \        }\n    }\n    return $histogram;\n}\n", "  $histogram = array();\n  //\
    \ Count occurrences of letters and store in histogram\n  $letterCounts = array_count_values(str_split($test));\n\
    \  // Determine most common letter \n  arsort($letterCounts);\n  $letter = reset($letterCounts);\n\
    \  $histogram[$letter] = $letterCounts[$letter];\n  \n  // Return histogram if\
    \ letters occur more than once\n  foreach($letterCounts as $letter => $count)\
    \ {\n    if ($count > 1) {\n      $histogram[$letter] = $count;\n      break;\n\
    \    }\n  }\n  return $histogram;\n}", "  $letters = explode(' ', $test);\n  $letterCount\
    \ = array();\n  foreach ($letters as $letter) {\n    if (isset($letterCount[$letter]))\
    \ {\n      $letterCount[$letter] += 1;\n    } else {\n      $letterCount[$letter]\
    \ = 1;\n    }\n  }\n  arsort($letterCount);\n  $result = array();\n  foreach ($letterCount\
    \ as $letter => $count) {\n    $result[] = array('letter' => $letter, 'count'\
    \ => $count);\n  }\n  return $result;\n}\n", "  $letters = str_split($test);\n\
    \  $freqs = [];\n  foreach ($letters as $letter) {\n    if (isset($freqs[$letter]))\
    \ {\n      $freqs[$letter] += 1;\n    } else {\n      $freqs[$letter] = 1;\n \
    \   }\n  }\n  return $freqs;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\n\
    Thanks for helping me with the problem. Your solution works great for this problem.\
    \ Unfortunately I forgot to mention that I wanted it to be an array\n<|/ c |>\n\
    <| c |>\nAh, well I edited my answer to make it a little simpler. Let me know\
    \ if this is what you wanted.\n<|/ c |>\n<| c |>\nI'm sorry but I don't quite\
    \ understand this solution. I'm trying to figure it out but I can't seem to figure\
    \ it out. I'm still new to the language so I keep running into syntax errors.\
    \ I'm trying not to take away from you but if you could give an example using\
    \ my code I would be really appreciative.\n<|/ c |>\n<| c |>\nI edited my question\
    \ to include an example that works with your code\n<|/ c |>\n<| c |>\n, did this\
    \ answer your question?\n<|/ c |>\n<| a tags=php,arrays |>\nTry this:\n<code>\n\
    $str = 'a a b b c c a b c c a';\n\n$result = preg_match_all('/(?<=\\s)(\\w)\\\
    K/', $str, $matches, PREG_SET_ORDER);\nprint_r($matches);\n</code>\nThe result\
    \ is:\n<code>\nArray\n(\n    [0] => Array\n        (\n            [0] => a\n \
    \           [1] => b\n            [2] => c\n        )\n\n    [1] => Array\n  \
    \      (\n            [0] => a\n            [1] => b\n            [2] => c\n \
    \       )\n\n    [2] => Array\n        (\n            [0] => a\n            [1]\
    \ => b\n            [2] => c\n        )\n\n)\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nI appreciate your help but when I tried running this in PHPStorm, it gives\
    \ me an undefined variable: str\n<|/ c |>\n<| c |>\nI edited the answer. Now it's\
    \ working.\n<|/ c |>\n<| c |>\nThis answer doesn't give the desired result. The\
    \ OP has clearly said they want a nested array structure.\n<|/ c |>\n<| c |>\n\
    Hi, I didn't check his question as he was ", "  $histogram = array();\n  $tokens\
    \ = preg_split('/\\s+/u', $test, -1, PREG_SPLIT_NO_EMPTY);\n  foreach ($tokens\
    \ as $token) {\n    $histogram[$token] = isset($histogram[$token]) ? $histogram[$token]\
    \ + 1 : 1;\n  }\n  $histogram = array_flip($histogram);\n  return $histogram;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWow, this is amazing! Thank you so much!!\n\
    <|/ c |>\n<| a tags=algorithm,php,data-structures |>\nHere is my solution:\n<code>\n\
    <?php\n$test = ' a b c a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b a b\
    \ a b a b ", "  $histogram = array();\n  $testArray = str_split($test);\n  foreach($testArray\
    \ as $letter){\n    if(array_key_exists($letter, $histogram)){\n      $histogram[$letter]++;\n\
    \    }else{\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }", "  $counts = array();\n  $letters = preg_split('/\\s+/', strtolower($test));\n\
    \n  // Count the number of occurrences of each letter\n  foreach ($letters as\
    \ $letter) {\n    if (!isset($counts[$letter])) {\n      $counts[$letter] = 1;\n\
    \    } else {\n      $counts[$letter]++;\n    }\n  }\n\n  // Get the letter with\
    \ the highest number of occurrences\n  return $counts[max(array_keys($counts))];\n\
    }\n", "    $histogram = array();\n    $splitted = str_split($test);\n    $letters\
    \ = count($splitted);\n    for ($i = 0; $i < $letters; $i++) {\n        $histogram[$splitted[$i]]\
    \ = 0;\n    }\n    for ($i = 0; $i < $letters; $i++) {\n        $histogram[$splitted[$i]]\
    \ += 1;\n    }\n    arsort($histogram);\n    return $histogram;\n}\n$histogram\
    \ = histogram('a b c a b');\nprint_r($histogram);\n</code>\nOutput\n<code>\nArray\n\
    (\n    [a] => 2\n    [b] => 3\n    [c] => 1\n)\n</code>\n<|/ a |>\n<| c |>\nthis\
    \ should be the accepted answer, as it actually answers the question. My answer\
    \ is an addition to that question, just to provide an alternate approach to the\
    \ problem (for those who don't care about the original problem in question)\n\
    <|/ c |>\n<| a tags=php,algorithm,histogram,string |>\n<code>\n<?php\n", "  $histogram\
    \ = array();\n  $words = array_unique(explode(' ', $test));\n  foreach ($words\
    \ as $word) {\n    if (!isset($histogram[$word])) {\n      $histogram[$word] =\
    \ 1;\n    } else {\n      $histogram[$word]++;\n    }\n  }\n\n  // Sort the array\n\
    \  ksort($histogram);\n\n  return $histogram;\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThis fails with `histogram('a b c a b')` - it returns `{'b': 2}` when\
    \ it should be `{'a': 1, 'b': 1, 'c': 1}`.\n<|/ c |>\n<| c |>\n: Yep, I was a\
    \ bit surprised to read that the question was about a space separated lowercase\
    \ letters. And thanks for the comment! I updated the answer, but it took some\
    \ time, so I might not be able to give a better solution at the moment.\n<|/ c\
    \ |>\n<| c |>\nVery nice, though it seems rather expensive to do the `explode`\
    \ for each word. My solution, while a bit slower, is more readable, IMO.\n<|/\
    \ c |>\n<| c |>\n: Yes, that's why I wrote \"might be able to give a better solution\
    \ at the moment\". It might take a bit longer though ;)\n<|/ c |>\n<| c |>\nNicely\
    \ done, thanks! Now if only I could get your code to work :-) `histogram('a b\
    \ c a b')` should yield `{'a': 1, 'b': 1, 'c': 1}` - and no, I'm not interested\
    \ in readability of the code - but in actually understanding the logic behind\
    \ it :-)\n<|/ c |>\n<| a tags=php,algorithm,arrays,sorting |>\nI wrote a solution\
    \ that makes use of the fact that \"every letter appears exactly once\". As a\
    \ result, I only need to count the occurrences of letters, and then sort them\
    \ based on the occurrence count, as you mentioned.\nI wrote the code first in\
    \ Python and I tested it on sample inputs. The code is self-explanatory, so if\
    \ you're not familiar with Python, you're probably better off reading the comments\
    \ I wrote, so you understand what's going on.\n<code>\ndef histogram(s):\n   \
    \ \"\"\"Return a dictionary with the most frequent letters in the string.\n  \
    \  Each key in the dictionary will have a corresponding value that is the\n  \
    \  number of times that letter appears in the string.\"\"\"\n    # Count the occurrences\
    \ of each letter in the input string\n    letter_counts = defaultdict(int)\n \
    \   for letter in s:\n        letter_counts[letter] += 1\n\n    # Sort the letters\
    \ by ", "  $histogram = array();\n  $letters = str_split($test);\n  foreach ($letters\
    \ as $letter) {\n    $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 0;\n  }\n  arsort($histogram);\n  return $histogram;\n}\n\n/**\n * @param\
    \ $test\n * @return array\n */", "  $counts = array_count_values(preg_split('/\\\
    s+/', $test));\n\n  asort($counts);\n\n  $max = 0;\n  $maxValue = null;\n  foreach\
    \ ($counts as $letter => $occurrence) {\n    if ($occurrence > $max) {\n     \
    \ $max = $occurrence;\n      $maxValue = $letter;\n    }\n  }\n\n  return [$maxValue,\
    \ $max];\n}", "  $histogram = array();\n  foreach (explode(' ', $test) as $letter)\
    \ {\n    if (array_key_exists($letter, $histogram)) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n", "    $histogram = array();\n    $testArray = str_split($test);\n\n    foreach\
    \ ($testArray as $letter) {\n        if (isset($histogram[$letter])) {\n     \
    \       $histogram[$letter] += 1;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n\n    arsort($histogram);\n\n    return $histogram;\n\
    }\n\n$histogram = histogram(\"a b b b a c c\");\necho \"<pre>\";\nprint_r($histogram);\n\
    echo \"</pre>\";\n</code>\n<|/ a tags=php |>\n<| c |>\nJust realized that this\
    \ is probably slower than `str_split`, but I'm too lazy to benchmark it now...\n\
    <|/ c |>\n<| a dscore=1 tags=php |>\n<code>\n<?php", "    $counts = array();\n\
    \    foreach (preg_split('/ /', $test) as $char) {\n        $counts[$char] = 0;\n\
    \    }\n    $max = null;\n    foreach ($counts as $char => $count) {\n       \
    \ if ($max === null || $count > $max) {\n            $max = $count;\n        }\n\
    \    }\n    return $counts;\n}\n", "    $count = array_count_values(str_split($test));\n\
    \    $max = $count[0];\n    return array_intersect_key($count, $max, $max);\n\
    }\n", "  $histogram = array();\n  $letters = preg_split('//u', $test);\n  foreach\
    \ ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    }\n    else {\n      $histogram[$letter] = 1;\n    }\n  }\n\n  return $histogram;\n\
    }", "  $letters = array();\n  $counts = array();\n  $result = array();\n  // Go\
    \ over each character in the string\n  for ($i = 0; $i < strlen($test); $i++)\
    \ {\n    $letter = strtolower(substr($test, $i, 1));\n    // If this is the first\
    \ letter of the string, initialize count\n    if (!array_key_exists($letter, $letters))\
    \ {\n      $letters[$letter] = 1;\n    } else {\n      // Increment the count\n\
    \      $letters[$letter]++;\n    }\n  }\n  // Iterate over each letter again to\
    \ find max count and its letter\n  foreach ($letters as $letter => $count) {\n\
    \    // If this is the first time we see this letter, initialize result\n    if\
    \ (!array_key_exists($letter, $result)) {\n      $result[$letter] = array();\n\
    \      $result[$letter][] = $count;\n      // If this letter appears again later,\
    \ increase count\n    } else {\n      if ($count > $result[$letter]) {\n     \
    \   $result[$letter] = $count;\n      }\n    }\n  }\n  return $result;\n}\n",
  "  $freq = array();\n  foreach(preg_split('/ /', $test) as $letter) {\n    if (isset($freq[$letter]))\
    \ {\n      $freq[$letter]++;\n    } else {\n      $freq[$letter] = 1;\n    }\n\
    \  }\n  return $freq;\n}\n", "  $letters = preg_split('/\\s+/', $test);\n  $letter_counts\
    \ = array_count_values($letters);\n  $most_repeated = array_search(max($letter_counts),\
    \ $letter_counts);\n  return array_intersect_key($letter_counts, array_flip($most_repeated));\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for your answer, but I'm sorry,\
    \ I have not said that the array could have repeated letters, for example the\
    \ word \"cake\" can have \"cake\" or \"cakes\".\n<|/ c |>\n<| c |>\n, I've updated\
    \ the answer to take repeated letters into account.\n<|/ c |>\n<| c |>\nThank\
    \ you very much for your answer, it's just what I need! :)\n<|/ c |>\n<| c |>\n\
    Sorry for the delay, I was out of work. Your code looks so perfect, I'm going\
    \ to use it in my project and I will tell you about the results when it's done.\
    \ Thank you very much!\n<|/ c |>\n<| a |>\n<code>\n<?php\n\n$string = \"This sentence\
    \ is full of words and it contains duplicate words such as duplicate, duplicate,\
    \ duplicate, duplicate\";\n\n$letters = str_split($string);\n$count = array();\n\
    foreach($letters as $letter) {\n  $count[$letter] = isset($count[$letter]) ? ++$count[$letter]\
    \ : 0;\n}\nprint_r($count);\n", "  $counts = array_count_values(str_split($test));\n\
    \  $maxKey = null;\n  $maxValue = null;\n  $maxCount = 0;\n  foreach ($counts\
    \ as $key => $value) {\n    if ($value >= $maxCount) {\n      $maxCount = $value;\n\
    \      $maxKey = $key;\n      $maxValue = $value;\n    }\n  }\n  return array($maxKey\
    \ => $maxCount, $maxValue => $maxCount);\n}\n", "  $histogram = array();\n  $count\
    \ = array_count_values(str_split($test));\n  foreach ($count as $letter => $occurrence)\
    \ {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter] += $occurrence;\n\
    \    } else {\n      $histogram[$letter] = $occurrence;\n    }\n  }\n  return\
    \ $histogram;\n}\n", "  $result = array();\n  $words = str_word_count($test, 1);\n\
    \  foreach ($words as $key => $value) {\n    if (!isset($result[$key])) {\n  \
    \    $result[$key] = $value;\n      $result[$key] /= count($words);\n    }\n \
    \   elseif ($result[$key] < $value) {\n      $result[$key] = $value;\n    }\n\
    \  }\n  return $result;\n}\n\n$histogram = histogram($question);\n", "  $occurrences\
    \ = array_count_values(str_split($test));\n  arsort($occurrences);\n  foreach\
    \ ($occurrences as $letter => $frequency) {\n    $result[$letter] = $frequency;\n\
    \  }\n\n  return $result;\n}\n", "\t$letters = preg_split('/\\s+/', $test);\n\t\
    $histogram = array();\n\tforeach ($letters as $letter) {\n\t\t$histogram[$letter]\
    \ = isset($histogram[$letter]) ? $histogram[$letter]+1 : 1;\n\t}\n\t$letters =\
    \ array_count_values($histogram);\n\tarsort($letters);\n\treturn $letters;\n}",
  "  $histogram = array();\n  $words = explode(' ', $test);\n  foreach($words as $word)\
    \ {\n    $letter = strtolower($word);\n    if (!isset($histogram[$letter])) {\n\
    \      $histogram[$letter] = 0;\n    }\n    $histogram[$letter] += 1;\n  }\n \
    \ return $histogram;\n}\n</code>\nThe above code is written in PHP 7.2.\nHere\
    \ is a working example.\n<|/ a |>\n<| c |>\nThis should be the accepted answer.\
    \ One liner with array_count_values function will do the job\n<|/ c |>\n<| c |>\n\
    This is the best answer here, works great for me. I did have to make a small edit,\
    \ because my array was a multidimensional array and I needed to count the occurrences\
    \ of each array element separately. I used array_count_values() with array_column()\
    \ to accomplish this.\n<|/ c |>\n<| a dscore=5 tags=arrays,php,arraylist |>\n\
    This is what I do:\n<code>\n$counter = [];\nforeach ($array as $key => $value)\
    \ {\n   $counter[$key] = array_search($value, array_unique($array));\n}\n</code>\n\
    It just loops through your array and checks if each value is already in the array,\
    \ then it returns the index. Otherwise it adds it. \nI then use array_unique to\
    \ remove the duplicates from the array so that it counts the unique values.\n\
    <|/ a |>\n<| c |>\nThe only answer that actually works! I love the simplicity\
    \ of the solution.\n<|/ c |>\n<| c |>\nThis works great, but be aware that if\
    \ the array contains values different from strings, they will be cast to string\
    \ and you will have some issues.\n<|/ c |>\n<| c |>\nIt doesn't remove duplicates\
    \ when there are duplicated values.\n<|/ c |>\n<| c |>\nUse `array_count_values`\
    \ instead of `array_unique`\n<|/ c |>\n<| a dscore=4 |>\n<code>\n$array = [\n\
    \    'a',\n    'b',\n    'a',\n    'c',\n    'a',\n    'b',\n    'a',\n    'a',\n\
    \    'b',\n    'a'\n];\n\n$uniques = array_count_values(array_map(function($x)\
    \ {\n    return $x;\n}, $array));\n</code>\narray_map will return every element\
    \ in the $array as an array (in this case it is $x), and then array_count_values\
    \ will count the values in the resulting array (in this case it is $x). If you\
    \ have multiple unique elements in a given array this will also count them, but\
    \ you probably only care about unique values.\n<|/ a tags=arrays,php", "    $hash\
    \ = [];\n    $letters = preg_split('//', $test);\n    foreach($letters as $letter)\
    \ {\n        $hash[$letter] = isset($hash[$letter]) ? $hash[$letter] + 1 : 1;\n\
    \    }\n    arsort($hash);\n    return $hash;\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ dscore=0 |>\n<| a tags=php,arrays,sorting |>\nIf you're running PHP 5.6, you\
    \ can use the spaceship operator:\n<code>\n$input = 'a b b b a';\n\n$output =\
    \ array_count_values(str_split($input))\n             ->map(function($value, $key)\
    \ use ($input) {\n                $counts = array_count_values(str_split($input));\n\
    \                return [\n                    $key,\n                    $value,\n\
    \                    $counts[$key] > $counts[$key ^ $value] ? $counts[$key] :\
    \ $counts[$key ^ $value]\n                ];\n             });\n\necho json_encode($output);\n\
    </code>\nThis returns:\n<code>\n[\n    {\"a\":2,\"b\":2},\n    {\"b\":4},\n  \
    \  {\"c\":1}\n]\n</code>\nThe spaceship operator compares two items from the same\
    \ array and returns the higher number. The ^ operation performs a bitwise XOR\
    \ operation. So ^ $value performs a XOR with the value of $value.\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks, this looks great. Unfortunately I don't have access to\
    \ PHP 5.6. But thanks for the explanation of the operator. I will keep this in\
    \ mind for future use.\n<|/ c |>\n<| c |>\nI added a solution that works in PHP\
    \ 5.3\n<|/ c |>\n<| a |>\nI like Nate Ford's answer better, but since you don't\
    \ have access to PHP 5.6, here's an alternative that uses PHP 5.3's closures,\
    \ array_reduce() and anonymous functions:\n<code>", "    // Return an empty dictionary\
    \ if null is given.\n    if ($test === null) return [];\n    // Split the string\
    \ into an array of words.\n    $split = explode(' ', $test);\n    // Sort the\
    \ array and remove duplicates.\n    sort($split);\n    $split = array_unique($split);\n\
    \    // Build an array with the letter counts for each word.\n    $count = array_fill_keys($split,\
    \ '');\n    // Loop through the array again and add each count to the corresponding\
    \ letter.\n    foreach ($split as $letter) {\n        $count[$letter]++;\n   \
    \ }\n    // Return the result array.\n    return $count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThank you for your solution. However, it isn't working for me.\
    \ On my local server I get an error: Parse error: syntax error, unexpected T_FUNCTION\
    \ in /var/www/html/PHP/Count.php on line 8. On the server I get an error: Parse\
    \ error: syntax error, unexpected '(', expecting ',' or ')' in /var/www/html/PHP/Count.php\
    \ on line 9. I've been trying to fix this for hours but still no luck. Do you\
    \ know what's wrong?\n<|/ c |>\n<| c |>\nThis error should be fixed now, as I\
    \ added a missing closing parenthesis and a missing semicolon. However the code\
    \ might not work correctly because I didn't test it with all edge cases.\n<|/\
    \ c |>\n<| c |>\nThe code works perfectly, thanks! But how do I use it in PHP?\
    \ I'm new to PHP and haven't been able to figure it out by myself. I've tried\
    \ several ways of calling the function, but none of them seem to work. I've read\
    \ about it online and I think I need to use an include statement and include the\
    \ file in the php page, but that's all I have been able to do. Any ideas?\n<|/\
    \ c |>\n<| c |>\nI just found out that my web hosting provider doesn't allow the\
    \ use of fopen and fclose and that they only allow file_get_contents and file_put_contents.\
    \ That would explain why my code doesn't work. Is there any way I could use this\
    \ code? Or do I need to find another way?\n<|/ c |>\n<| c |>\nYou can open a file\
    \ using `fopen`. Just add `'w'` as the 2nd parameter when calling fopen. Also\
    \ remember that you need to close the file using `fclose`. I updated the answer\
    \ accordingly.\n<|/ c |>\n<| a |>\nYou can do this using array_count_values().\
    \ Here's an example from php.net:\n<code>\n<?php\n$array = array(\"a\" => 1, \"\
    b\" => ", "\t$histogram = array();\n\t$test  = strtolower($test);\n\t$words =\
    \ explode(' ', $test);\n\tforeach ($words as $word) {\n\t\t$word_count = array_key_exists($word,\
    \ $histogram) ? $histogram[$word]++ : 1;\n\t\t$histogram[$word] = $word_count;\n\
    \t}\n\tarsort($histogram);\n\tforeach ($histogram as $word => $count) {\n\t\t\
    $histogram[$word] = $count;\n\t}\n\treturn $histogram;\n}\n", "    $histo = array();\n\
    \    $testArr = str_split($test);\n    foreach($testArr as $letter) {\n      \
    \  if (array_key_exists($letter, $histo)) {\n            $histo[$letter]++;\n\
    \        }\n        else {\n            $histo[$letter] = 1;\n        }\n    }\n\
    \    return $histo;\n}\n", "  // Split the given test into letters and counts\n\
    \  $test = preg_split('//', $test, -1, PREG_SPLIT_NO_EMPTY);\n  \n  // Sort both\
    \ arrays by decreasing number of repetitions\n  usort($test, function($a, $b)\
    \ {\n    return $b - $a;\n  });\n  \n  // Create a dictionary to store the counts\n\
    \  $occurrences = [];\n  \n  // For each letter in the array\n  foreach ($test\
    \ as $letter) {\n    // See if the letter already occurs in the dictionary\n \
    \   if (!isset($occurrences[$letter])) {\n      // If it doesn't, add it to the\
    \ dictionary and set its count to 1\n      $occurrences[$letter] = 1;\n    } else\
    \ {\n      // Otherwise, increment the count by 1\n      $occurrences[$letter]++;\n\
    \    }\n  }\n  \n  // Return the dictionary\n  return $occurrences;\n}\n</code>\n\
    I believe this solves your problem and is fairly easy to understand.\n<|/ a dscore=1\
    \ |>\n<| c |>\nYou can't use `preg_match_all` without passing an array as the\
    \ third argument. I also think the OP wants to find the *most* repeated letter,\
    \ not the most repeated.\n<|/ c |>\n<| a |>\nIf speed is a concern, you could\
    \ do it like this:\n<code>", "  $histogram = array();\n  $occurrences = array();\n\
    \  // Count the number of times the letters occur\n  for ($i = 0; $i < strlen($test);\
    \ ++$i) {\n    $char = strtolower($test[$i]);\n    if (!isset($histogram[$char]))\
    \ {\n      $histogram[$char] = 1;\n    } else {\n      $histogram[$char] += 1;\n\
    \    }\n  }\n  // Sort the letters based on the number of occurrence\n  arsort($histogram);\n\
    \  // Find the most frequent letter and its corresponding count\n  foreach ($histogram\
    \ as $letter => $count) {\n    $occurrences[$letter] = $count;\n  }\n  return\
    \ $occurrences;\n}\n", "  return array_reduce(array_count_values(str_split($test)),\
    \ function($carry, $item) {\n    return $carry + $item;\n  }, array());\n}\n",
  "\t$count = array();\n\t$keys = array_count_values(str_split(strtolower($test)));\n\
    \tforeach($keys as $letter => $count) {\n\t\t$count[$letter] = isset($count[$letter])\
    \ ? $count[$letter] + 1 : 1;\n\t}\n\treturn $count;\n}\n", "  $letters = str_split($test);\n\
    \  $counts = array_count_values($letters);\n  $result = array();\n\n  // Sort\
    \ by number of occurrences.\n  arsort($counts);\n\n  // Keep track of the letter\
    \ with the highest occurrence.\n  $max = 0;\n\n  // Loop over the sorted letters.\n\
    \  foreach ($counts as $letter => $count) {\n    if ($count > $max) {\n      $max\
    \ = $count;\n      $result = $letter;\n    }\n  }\n\n  // If no letters have the\
    \ highest occurrence, return an empty dictionary.\n  if ($max == 0) {\n    return\
    \ array();\n  }\n\n  // Return the letter with the highest occurrence, and the\
    \ count of it\n  // to match the output of array_count_values().\n  return array($result,\
    \ $max);\n}", "    $histogram = array();\n    $words = preg_split(\"/\\s+/\",\
    \ $test);\n    $total = 0;\n    foreach ($words as $word) {\n        if (!empty($word))\
    \ {\n            $histogram[$word]++;\n            $total++;\n        }\n    }\n\
    \    asort($histogram);\n    return array_count_values($histogram);\n}\n", " \
    \ $histogram = array();\n  foreach (preg_split('/ /', $test) as $letter) {\n \
    \   if (array_key_exists($letter, $histogram)) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  $histogram = array_count_values($histogram);\n\
    \  return $histogram;\n}\n", "  $histogram = array();\n  $letters = explode('\
    \ ', $test);\n  foreach ($letters as $letter) {\n    if (!isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] = 0;\n    }\n    $histogram[$letter]++;\n  }\n\
    \  return $histogram;\n}\n", "\t$counts = array();\n\t$words = explode(' ', $test);\n\
    \tforeach ($words as $word) {\n\t\tif (!array_key_exists($word, $counts)) $counts[$word]\
    \ = 0;\n\t\t$counts[$word]++;\n\t}\n\tarsort($counts);\n\treturn $counts;\n}",
  "  return array_count_values(str_split($test));\n}\n", "  $histogram = array();\n\
    \  foreach(array_count_values(str_split($test)) as $letter => $count) {\n    $histogram[$letter]\
    \ = $count;\n  }\n  return $histogram;\n}\n</code>\nThe code is quite self-explanatory,\
    \ but here you have a live example.\n<|/ a tags=php,arrays |>\n<| c |>\nThis does\
    \ not return the expected output in the case of 'a b a a a'\n<|/ c |>\n<| c |>\n\
    Yeah, the code was not intended to be used in production, but just to show the\
    \ idea. Edited to fix that!\n<|/ c |>\n<| c |>\nThis is good, but I would expect\
    \ it to be much faster if you didn't do `array_count_values()` and instead just\
    \ used `array_count_values` on the original string and iterated over the resulting\
    \ array.\n<|/ c |>\n<| c |>\nThe idea is that you can do the same operation on\
    \ multiple inputs at once (using `array_map()`) or on the input string as a whole.\
    \ Either way, if you apply it to the input string as a whole (instead of individual\
    \ letters), you can easily just `return $histogram` without having to do any iterations.\
    \ If you apply it to each letter individually, then you'll have to do iterations,\
    \ but then it's just one line instead of four.\n<|/ c |>\n<| a dscore=0 |>\nIf\
    \ you don't want to write your own loop, you can write it like this:\n<code>\n\
    $letters = array_count_values(str_split($test));\n$letters = array_flip($letters);\n\
    </code>\nWhich will count the letters as you wish.\n<|/ a tags=php,arrays |>\n\
    <| a dscore=0 |>\n<code>\n<?php\n$test=\"a b a a a\";\n$array=array();\nfor ($i\
    \ = 0; $i < strlen($test); $i++){\n    if($test[$i]==\" \"){\n         $array[$test[$i]]++;\n\
    \    }\n}\nprint_r($array);", "  $histogram = array();\n  foreach(preg_split('/\\\
    s+/', $test) as $letter) {\n    if (!isset($histogram[$letter])) {\n      $histogram[$letter]\
    \ = 0;\n    }\n    $histogram[$letter] += 1;\n  }\n  arsort($histogram);\n  return\
    \ $histogram;\n}\n</code>\nIt runs a bit faster than the other answers, but it\
    \ seems like the best solution for me.\n<|/ a dscore=3 |>\n<| c |>\nI really like\
    \ this solution, just because it makes it so you can easily count the number of\
    \ different letters or words in a given string.  It also runs a bit faster than\
    \ all the other answers on my computer.\n<|/ c |>\n<| a tags=regex,php,text-parsing\
    \ dscore=2 |>\nThis is an interesting problem, and I found a great solution for\
    \ you. I used a technique called \"backtracking\" which allows us to match all\
    \ possible permutations before actually going into the next position. \nThis solution\
    \ also uses recursion, and is therefore very fast.\n<code>", "    $letters = str_split($test);\n\
    \    $histo = array();\n    foreach ($letters as $letter) {\n        $histo[$letter]\
    \ = 0;\n    }\n\n    foreach ($letters as $letter) {\n        $histo[$letter]++;\n\
    \    }\n\n    return $histo;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI do not\
    \ see how your solution is better than mine. Using an associative array seems\
    \ cleaner (at least to me).\n<|/ c |>\n<| c |>\nI don't see any advantage of the\
    \ `array_count_values()` solution. Can you explain please? Is it faster?\n<|/\
    \ c |>\n<| c |>\nYour solution does not output all letters if they are repeated\
    \ more than once. But the array_count_values() solution does. I do not see a reason\
    \ why you do not want to use array_count_values(). Do you really believe that\
    \ it is faster?\n<|/ c |>\n<| c |>\nYour code is slightly slower than mine. Your\
    \ code seems to output the letters repeatedly as many times as they appear. My\
    \ code outputs them only once.\n<|/ c |>\n<| c |>\nThe main advantage of my solution\
    \ is that it will not require any additional memory (array is converted to simple\
    \ associative array), therefore it is more memory efficient.\n<|/ c |>\n<| a tags=algorithm,php,string\
    \ |>\nThis is what i would do:\n<code>\n<?php\n", "    $histogram = array();\n\
    \    $test = preg_replace('/\\s+/', ' ', $test);\n    foreach (str_split($test)\
    \ as $c) {\n        if (isset($histogram[$c])) {\n            $histogram[$c]++;\n\
    \        }\n        else {\n            $histogram[$c] = 1;\n        }\n    }\n\
    \    return $histogram;\n}\n", "\t$occurrences = array();\n\tforeach (str_split($test)\
    \ as $letter) {\n\t\tif (!array_key_exists($letter, $occurrences)) {\n\t\t\t$occurrences[$letter]\
    \ = 0;\n\t\t}\n\t\t$occurrences[$letter] += 1;\n\t}\n\n\t$max = 0;\n\t$best =\
    \ null;\n\tforeach ($occurrences as $letter => $count) {\n\t\tif ($count > $max)\
    \ {\n\t\t\t$best = $letter;\n\t\t\t$max = $count;\n\t\t}\n\t}\n\n\treturn array($best,\
    \ $max);\n}\n", "  $histogram = array();\n  $letters = preg_split('//', $test);\n\
    \  foreach ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n  \
    \    $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n  \
    \  }\n  }\n  return $histogram;\n}\n", "  $histogram = array();\n  $result = array();\n\
    \  $keys = array();\n  $alphabet = str_split($test);\n  foreach ($alphabet as\
    \ $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n\n  // Sort by values\n\
    \  arsort($histogram);\n\n  // Scan through letters to find most common\n  foreach\
    \ ($histogram as $letter => $value) {\n    $result[$letter] = $value;\n  }\n\n\
    \  // Sort letters alphabetically to return result\n  ksort($result);\n\n  return\
    \ $result;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,php |>\n<code>", "  $hist =\
    \ array();\n  // Split $test by space and build histogram\n  foreach (preg_split('/\\\
    s/', $test) as $letter) {\n    $letter = trim($letter);\n    if (isset($hist[$letter]))\
    \ {\n      $hist[$letter]++;\n    } else {\n      $hist[$letter] = 1;\n    }\n\
    \  }\n\n  return $hist;\n}\n", "  $histogram = array();\n\n  foreach (str_split($test)\
    \ as $letter) {\n    $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 1;\n  }\n\n  return $histogram;\n}\n", "  $histogram = array();\n  $counts\
    \ = array();\n  $words = explode(' ', $test);\n  foreach ($words as $word) {\n\
    \    $letter = strtolower($word);\n    if (isset($histogram[$letter])) {\n   \
    \   $histogram[$letter] = $histogram[$letter] + 1;\n    } else {\n      $histogram[$letter]\
    \ = 1;\n    }\n  }\n\n  foreach ($histogram as $letter => $count) {\n    $counts[$letter]\
    \ = $count;\n  }\n\n  $max = 0;\n  foreach ($counts as $letter => $count) {\n\
    \    if ($count > $max) {\n      $max = $count;\n    }\n  }\n\n  $histogram =\
    \ array_map(function($letter) use ($max) { return array($letter, $max); }, array_keys($histogram));\n\
    \  $histogram.sort(function($a, $b) { return $a[1] - $b[1]; });\n  return $histogram;\n\
    }\n\n$histogram = histogram('a b b b a');\nprint_r($histogram);\n", "  $result\
    \ = array();\n  $matches = array();\n  $result = array();\n  preg_match_all('/([a-zA-Z]+)/',\
    \ $test, $matches);\n  $result = $matches[1];\n  arsort($result);\n  $result =\
    \ array_count_values($result);\n  return $result;\n}", "  $histogram = array();\n\
    \  $letters = preg_split('//', $test);\n  foreach($letters as $letter) {\n   \
    \ if (isset($histogram[$letter])) {\n      $histogram[$letter]++;\n    }\n   \
    \ else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work and it only seems\
    \ to work if i remove the `^` from the regex and change it to `/[^A-Za-z]/` which\
    \ i don't understand why this regex does that.\n<|/ c |>\n<| c |>\n`/[^A-Za-z]/`\
    \ means \"match anything that isn't a letter\", which includes the '^' character.\
    \ Since this isn't what you want, use `/[^A-Za-z]/` instead\n<|/ c |>\n<| c |>\n\
    I updated my question, can you explain why this regex doesn't work as expected?\n\
    <|/ c |>\n<| c |>\nLooks like your regex is working to me. Do you mean that you\
    \ get unexpected results for strings like `'a^b^a'` ? The `^` character is a negation\
    \ metacharacter and will cause your regex to match any string that doesn't contain\
    \ any letters. If you remove the `^` it should work.\n<|/ c |>\n<| c |>\nyes,\
    \ i get unexpected results if i input `'a^b^a'` as input\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis might not be the best way to do it, but it does work:\n<code>\n<?php\n\
    \n    $test = \"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\";\n    $array\
    \ = array();\n    $result = array();\n    $i = 0;\n    $length = strlen($test);\n\
    \    while ($i < $length) {\n        $char = substr($test, $i, 1);\n        if\
    \ (ctype_alpha($char)) {\n            $array[$char] = $array[$char] + 1;\n   \
    \     } else {\n            $result = $result;\n        }\n        $i++;\n   \
    \ }\n    asort($array);\n    for ($i = 0; $i < count($array); $i++) {\n      \
    \  if ($array[$i] == 1) {\n            $result[$i] = $i;\n        }\n    }\n \
    \   echo '<pre>';\n    print_r($result);\n    echo '</pre>';", "  $histogram =\
    \ array();\n  $letter = strtolower($test);\n  $histogram[$letter] = count($test);\n\
    \  $letter = strtolower($letter);\n  for ($i = 1; $i < strlen($letter); $i++)\
    \ {\n    $letter = strtolower($letter.$letter);\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter] = $histogram[$letter] + 1;\n    }\n  }\n  return\
    \ $histogram;\n}", "  $letters = array_count_values(str_split($test));\n  $result\
    \ = array();\n  foreach ($letters as $letter => $count) {\n    if ($letter ==\
    \ $letters) {\n      $result[$letter] = $count;\n    }\n  }\n  return $result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe code provided is very simple and nice!\n<|/\
    \ c |>\n<| a |>\nI think you can try this function,\n<code>", "\t$histogram =\
    \ array();\n\t$tests = explode(' ', $test);\n\tforeach ($tests as $test) {\n\t\
    \t$testExploded = explode(' ', $test);\n\t\tforeach ($testExploded as $testExplodedValue)\
    \ {\n\t\t\t$histogram[$testExplodedValue] = isset($histogram[$testExplodedValue])\
    \ ? $histogram[$testExplodedValue] + 1 : 1;\n\t\t}\n\t}\n\tarsort($histogram);\n\
    \t$mostRepeatedLetter = '';\n\tforeach ($histogram as $letter => $count) {\n\t\
    \t$mostRepeatedLetter = $letter . ' (' . $count . ')';\n\t}\n\treturn $histogram;\n\
    }\n", "  $histogram = array();\n  $frequency = array();\n  $tokens = preg_split('/\\\
    s+/', $test);\n  foreach ($tokens as $token) {\n    if (!isset($histogram[$token]))\
    \ {\n      $histogram[$token] = 0;\n    }\n    $histogram[$token]++;\n    if (empty($frequency[$token]))\
    \ {\n      $frequency[$token] = 1;\n    }\n    else {\n      $frequency[$token]++;\n\
    \    }\n  }\n\n  arsort($frequency);\n  $histogram = array_reverse($histogram);\n\
    \  foreach ($frequency as $letter => $count) {\n    if ($count == 1) {\n     \
    \ unset($histogram[$letter]);\n    }\n  }\n  return $histogram;\n}\n</code>\n\
    <|/ a tags=function,php |>\n<| c |>\nThank you, your answer was very helpful and\
    \ you also provided me with some code to learn from. I'll try to implement it\
    \ in my own code when I get home, thanks again!\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is a way which uses counting and preg_replace to solve the problem:\n<code>\n\
    <?php\n\n$input = 'a b b c a b a c b a';\n$pattern = '/(\\s)/';\n$replacement\
    \ = '{$2}';\n$replacement = preg_replace($pattern, $replacement, $input);\n$tokens\
    \ = preg_split('/\\s+/', $replacement);\n", "  $letters = explode(' ', $test);\n\
    \  $counts = array_count_values($letters);\n  $keys = [];\n  foreach ($counts\
    \ as $letter => $count) {\n    $keys[] = $letter;\n  }\n  return $counts == $keys\
    \ ? $counts : $keys;\n}\n", "  $histogram = array();\n  $letters = preg_split('//',\
    \ $test);\n  foreach ($letters as $letter) {\n    $histogram[$letter] = isset($histogram[$letter])\
    \ ? $histogram[$letter] + 1 : 1;\n  }\n  return $histogram;\n}\n</code>\n<|/ a\
    \ tags=functional-programming,php,algorithm,java,scala dscore=2 |>\n<| c |>\n\
    In Java you'd be better off using a HashMap for this, rather than an array.\n\
    <|/ c |>\n<| c |>\nI agree. Java is easier for a beginner at this. But since Scala\
    \ is a superset of Java and provides language features, it might make more sense\
    \ to use Java.\n<|/ c |>\n<| a tags=functional-programming,php,algorithm,java,scala\
    \ |>\nHere is another solution (functional) which does not require you to implement\
    \ your own mapReduce function which may make your code less readable:\n<code>\n\
    scala> val l = List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"c\",\"a\",\"b\",\"a\"\
    ,\"a\")\nl: List[String] = List(a, b, c, d, e, f, c, a, b, a, a)\n\nscala> val\
    \ counts = l.foldLeft(Map[Char,Int]()){ (acc,c) => acc(c) + 1}\ncounts: scala.collection.immutable.Map[Char,Int]\
    \ = Map(a -> 4, b -> 3, c -> 2, d -> 1, e -> 1, f -> 1, c -> 1)\n\nscala> counts.maxBy(_._2)._1\
    \ // e\nres0: Char = c\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nYou can\
    \ write it in Scala as follows:\n<code>\nval myList: List[String] = List(\"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"c\", \"a\", \"b\", \"a\", \"a\")\n\nmyList.foldLeft(Map[Char,\
    \ Int]()){\n    case (acc, s) =>\n        acc + (s.toChar -> (acc.getOrElse(s.toChar,\
    \ 0) + 1))\n}\n</code>\n<|/ a tags=functional-programming,php,algorithm,java,scala\
    \ |>\n<| a tags=functional-programming,php,algorithm,java,scala |>\nA more functional\
    \ Java solution would be:\n<code>\npublic static void main(String[] args) {\n\
    \    List<String> test = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"c\", \"a\", \"b\", \"a\", \"a\");\n    Map<Character, Integer> map = test.stream()\n\
    \            .collect(Collectors.toMap(s -> s.", "    $histogram = array();\n\
    \    foreach (str_split($test) as $letter) {\n        if (isset($histogram[$letter]))\
    \ {\n            $histogram[$letter]++;\n        } else {\n            $histogram[$letter]\
    \ = 1;\n        }\n    }\n    return $histogram;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like it, but I ran into one problem: What if there are repeated letters? For\
    \ example the word \"abba\". The letter \"a\" will appear 2 times in the output\
    \ and each time the frequency is incremented. How can I solve this problem?\n\
    <|/ c |>\n<| c |>\n`count($histogram[$letter])` will return how many times the\
    \ letter has appeared. If you want to return the letter with max number of occurences,\
    \ do `return $letter;` after the foreach loop.\n<|/ c |>\n<| c |>\nI just ran\
    \ into another problem. In the case of \"abba\" it returns \"abba\" but I want\
    \ to return \"a\". How can I do that?\n<|/ c |>\n<| c |>\nWhat do you mean by\
    \ \"I want to return 'a'\"? Do you want to return all letters with the highest\
    \ frequency? Like \"a\" because its frequency is 2 times? Or do you want the most\
    \ frequent letter that appears in the string?\n<|/ c |>\n<| c |>\nI just want\
    \ to return the letter with max frequency. In the case of \"abba\" I want to return\
    \ \"a\". How can I do that?\n<|/ c |>\n<| a dscore=0 |>\nTo find out what letter\
    \ has the most occurrence in a string you can use this function:\n<code>", " \
    \ $histogram = array();\n  $words = explode(' ', $test);\n  foreach ($words as\
    \ $word) {\n    $histogram[$word] = (isset($histogram[$word]) ? $histogram[$word]+1\
    \ : 1);\n  }\n  arsort($histogram);\n  $counts = array_slice($histogram, 0, count($histogram)-1);\n\
    \  foreach ($counts as $letter => $count) {\n    $result[$letter] = $count;\n\
    \  }\n  return $result;\n}\n", "  $histogram = array();\n  foreach (str_split($test)\
    \ as $letter) {\n    $histogram[$letter] = isset($histogram[$letter]) ? $histogram[$letter]\
    \ + 1 : 1;\n  }\n  $histogram = array_count_values($histogram);\n  $histogram\
    \ = array_filter($histogram, function ($count) {\n    return $count > 1;\n  });\n\
    \n  return $histogram;\n}\n</code>\nExample use:\n<code>\n$test = 'a b b b a b';\n\
    print_r(histogram($test));\n</code>\nOutput\n<code>\nArray\n(\n    [a] => 2\n\
    \    [b] => 4\n)\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe result is not sorted\
    \ alphabetically.\n<|/ c |>\n<| c |>\nIt's not sorted alphabetically, but you\
    \ can sort the array by its key, which makes it alphabetically sorted anyway.\n\
    <|/ c |>\n<| c |>\nWhy are you using `+$count`? Why not just `$count++`?\n<|/\
    \ c |>\n<| c |>\nHi Felix, thanks for your solution. I was wondering if there\
    \ was any way to do the same in PHP as you did in C#. Could you please help me\
    \ with this? Thanks again!\n<|/ c |>\n<| c |>\nI think this answer could be improved\
    \ by giving a solution for php's `array_count_values`\n<|/ c |>\n<| a dscore=4\
    \ |>\nJust came across this problem and found a solution I liked. The function\
    \ below will give you the count of every unique letter from the given string.\
    \ In the example below, the result would be:\n<code>\nArray\n(\n    [a] => 3\n\
    \    [b] => 2\n    [c] => 1\n)\n</code>\nThe function:\n<code>", "  $hist = array();\n\
    \  foreach (explode(' ', $test) as $letter) {\n    if ($letter) {\n      $hist[$letter]\
    \ = isset($hist[$letter]) ? $hist[$letter] + 1 : 1;\n    }\n  }\n\n  return $hist;\n\
    }\n", "  $histogram = array();\n  $letters = array_count_values(str_split($test));\n\
    \  foreach ($letters as $letter => $count) {\n    if ($count > 1) {\n      $histogram[$letter]\
    \ = $count;\n    }\n  }\n  return $histogram;\n}", "  $words = array_count_values(str_split(strtolower($test),\
    \ 2));\n  arsort($words);\n  return $words;\n}\n", "  $result = array();\n  $letters\
    \ = preg_split('/\\s+/', $test);\n  foreach ($letters as $letter) {\n    $result[$letter]\
    \ = 0;\n  }\n  foreach ($letters as $letter) {\n    $result[$letter] += 1;\n \
    \ }\n  arsort($result);\n  $letters = array_keys($result);\n  return array_combine($letters,\
    \ $result);\n}\n", "  $histogram = array();\n  $letters = array();\n  $testArray\
    \ = str_split($test);\n  foreach ($testArray as $letter) {\n    $letters[$letter]++;\n\
    \  }\n  arsort($letters);\n  foreach ($letters as $letter => $count) {\n    $histogram[$letter]\
    \ = $count;\n  }\n  return $histogram;\n}\n", "  $test = trim($test);\n  $letters\
    \ = array_unique(str_split(strtolower($test)));\n  $histogram = array();\n  foreach\
    \ ($letters as $letter) {\n    if (isset($histogram[$letter])) {\n      $histogram[$letter]\
    \ += 1;\n    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n", "  $histogram = array();\n  $words = explode(' ', $test);\n  foreach ($words\
    \ as $word) {\n    $letter = strtolower($word);\n    if (isset($histogram[$letter]))\
    \ {\n      $histogram[$letter]++;\n    } else {\n      $histogram[$letter] = 1;\n\
    \    }\n  }\n  return $histogram;\n}\n", "  $histogram = [];\n  $letters = preg_split('/\
    \ /', $test);\n  foreach ($letters as $letter) {\n    $histogram[$letter] = isset($histogram[$letter])\
    \ ? $histogram[$letter] + 1 : 1;\n  }\n  arsort($histogram);\n  return $histogram;\n\
    }\n", "  // Split the input string on spaces\n  $keys = array_unique(preg_split('/\\\
    s+/', $test));\n  // Initialize the result array\n  $result = array();\n  // Go\
    \ through all keys\n  foreach($keys as $key) {\n    // If the key is not in result,\
    \ add it\n    if(!isset($result[$key])) {\n      $result[$key] = 0;\n    }\n \
    \   // Add one to its counter\n    $result[$key]++;\n  }\n  // Return the result\n\
    \  return $result;\n}\n", "  $histogram = array();\n  $words = explode(' ', $test);\n\
    \  $letters = array();\n  foreach ($words as $word) {\n    if (empty($letters[$word]))\
    \ {\n      $letters[$word] = 1;\n    }\n    else {\n      $letters[$word] += 1;\n\
    \    }\n  }\n  arsort($letters);\n  foreach ($letters as $letter => $count) {\n\
    \    $histogram[$letter] = $count;\n  }\n  return $histogram;\n}\n", "  $result\
    \ = array();\n  $words = str_word_count(strtolower($test), 1);\n  foreach ($words\
    \ as $key => $count) {\n    if (isset($result[$key]) && $count > $result[$key])\
    \ {\n      $result[$key] = $count;\n    }\n  }\n  return $result;\n}", "    $letters\
    \ = preg_split('/[\\s]+/', $test);\n    $frequencies = array();\n    $freq = array();\n\
    \    foreach ($letters as $letter) {\n        if (isset($frequencies[$letter]))\
    \ {\n            $frequencies[$letter]++;\n        } else {\n            $frequencies[$letter]\
    \ = 1;\n        }\n    }\n    arsort($frequencies);\n    foreach ($frequencies\
    \ as $letter => $count) {\n        $freq[] = $letter;\n    }\n    $count = count($frequencies);\n\
    \    return array($freq, $count);\n}", "    $result = array();\n    $words = explode('\
    \ ', $test);\n    foreach ($words as $w) {\n        if (isset($result[$w])) {\n\
    \            $result[$w]++;\n        }\n        else {\n            $result[$w]\
    \ = 1;\n        }\n    }\n\n    // Sort the resulting array to make it easier\
    \ to iterate through it.\n    // The last key is the last letter of the word and\
    \ the value is the count of letters.\n    ksort($result);\n    return $result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a great answer. Just one comment,\
    \ you can use `implode()` rather than `foreach`, although this isn't particularly\
    \ important.\n<|/ c |>\n<| a dscore=1 |>\nIf you want a solution that is more\
    \ concise, I suggest using the array_count_values() function in conjunction with\
    \ array_map():\n<code>\n$test = \"abc abc abc abc abc abc abc abc abc\";\n$letters\
    \ = explode(\" \", $test);\n$result = array_map(function($v){\n    return $v;\n\
    }, array_count_values($letters));\n</code>\n<|/ a tags=php,arrays,sorting |>\n\
    <| c |>\nThis looks good, except for the last line which should be: `return $v;`\n\
    <|/ c |>\n<| a tags=php,arrays,sorting |>\nYou will need to loop through each\
    \ letter in the string and keep track of how many times that letter occurs. Then\
    \ you can sort on that. There are several ways to do this. One would be to use\
    \ PHP's explode() function to split the string into an array of letters. Then\
    \ to go through each letter, you can use PHP's array_count_values() function to\
    \ count the occurrences of that letter in the string. Finally, you can use PHP's\
    \ sort() function to sort an array of letters based on how many times each letter\
    \ occurs.\n<|/ a dscore=0 |>\n<| a |>\n<code>\n<?php\n$test = \"abc abc abc abc\
    \ abc abc abc abc abc\";\n$letters = str_split($test);\n$result = array_count_values($letters);\n\
    arsort($result);\nprint_r($result);", "    $counts = array_count_values(str_split($test));\n\
    \    $most_frequent = max($counts);\n    return array_intersect_key($counts, [$most_frequent\
    \ => 1]);\n}\n</code>\nThis code does exactly what you want, and it's simple enough\
    \ to understand.\n<|/ a tags=php,arrays |>\n<| c |>\nThanks for sharing your solution.\
    \ However, I am going to mark my answer as accepted because of the comment. :)\n\
    <|/ c |>\n<| a |>\nYou can use a custom function to sort your array by value.\n\
    <code>", "  $result = array();\n  $words = preg_split('/\\s/', $test);\n  foreach\
    \ ($words as $word) {\n    if (!isset($result[$word])) {\n      $result[$word]\
    \ = 0;\n    }\n    $result[$word]++;\n  }\n  return $result;\n}\n", "    $alphabet\
    \ = str_split($test);\n    $alphabet = array_count_values($alphabet);\n    ksort($alphabet);\n\
    \    $max = 0;\n    foreach($alphabet as $letter => $occurrence) {\n        $max\
    \ = max($occurrence, $max);\n    }\n    \n    return $alphabet;\n}", "  $result\
    \ = array();\n  $letters = str_split($test);\n  $letters_count = array_count_values($letters);\n\
    \  arsort($letters_count);\n  foreach ($letters_count as $letter => $count) {\n\
    \    $result[strtolower($letter)] = $count;\n  }\n\n  return $result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYour \"naive implementation\" is not the naive implementation!\
    \ It has linear complexity and has quadratic memory requirement for longer strings.\
    \ Your solution is correct, but I thought it was obvious that this was an assignment\
    \ task and a naive solution would be a better fit to the assignment.\n<|/ c |>\n\
    <| a |>\n<code>\npublic function findLargestCommonPrefix(array $strings)\n{\n\
    \    $prefixes = array_count_values(array_map(function ($s) { return $s[0]; },\
    \ $strings));\n    arsort($prefixes);\n    foreach ($prefixes as $prefix => $count)\n\
    \    {\n        if ($count == 1) return $prefix;\n    }\n    return '';\n}\n</code>\n\
    <|/ a dscore=1 tags=arrays,php |>\n<| a tags=arrays,php dscore=0 |>\nYou can do\
    \ it with array_count_values and array_slice:\n<code>", "  $occurrences = array();\n\
    \  $letter = array();\n\n  $split = explode(' ', $test);\n  $size = count($split);\n\
    \n  for ($i = 0; $i < $size; $i++) {\n    $letter[$split[$i]] = isset($letter[$split[$i]])\
    \ ? $letter[$split[$i]] + 1 : 1;\n  }\n\n  ksort($letter);\n  foreach ($letter\
    \ as $letter => $count) {\n    $max_count = max($occurrences, array($letter));\n\
    \    $occurrences[$max_count] += $count;\n  }\n\n  return $occurrences;\n}\n",
  "  $histo = array();\n  $tokens = preg_split('/\\s+/', strtolower($test));\n  $count\
    \ = count($tokens);\n  for ($i = 0; $i < $count; $i++) {\n    if (!isset($histo[$tokens[$i]]))\
    \ {\n      $histo[$tokens[$i]] = 1;\n    }\n    else {\n      $histo[$tokens[$i]]\
    \ = $histo[$tokens[$i]] + 1;\n    }\n  }\n  return $histo;\n}", "    $letters\
    \ = preg_split('/\\s+/', $test);\n    $letters = array_count_values($letters);\n\
    \    arsort($letters);\n    $letters = array_keys($letters);\n    $letters = array_combine($letters,\
    \ array_fill(0, count($letters), 0));\n\n    return $letters;\n}", "  $histo =\
    \ array();\n  $i = 0;\n  $max_count = 0;\n  foreach (str_split($test) as $letter)\
    \ {\n    if (!isset($histo[$letter])) {\n      $histo[$letter] = 1;\n      $i++;\n\
    \    } else {\n      $histo[$letter]++;\n    }\n    if ($histo[$letter] > $max_count)\
    \ {\n      $max_count = $histo[$letter];\n    }\n  }\n  return array_count_values($histo);\n\
    }\n", "  return array_reduce(str_word_count($test, 1), function($memo, $count,\
    \ $word) {\n    $memo[$word] = isset($memo[$word]) ? $memo[$word] + 1 : $count;\n\
    \    return $memo;\n  }, array());\n}\n", "    $letters = str_split($test);\n\
    \    $histo = array();\n    $counter = array();\n    foreach($letters as $letter)\
    \ {\n        if(!isset($histo[$letter])) {\n            $histo[$letter] = 1;\n\
    \        } else {\n            $histo[$letter]++;\n        }\n    }\n    foreach($histo\
    \ as $letter => $occurence) {\n        if($occurence > 1) {\n            $counter[$letter]\
    \ = $occurence;\n        }\n    }\n    return $counter;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=sorting,arrays,php,frequency |>\nI have an alternative\
    \ solution which uses array_count_values and sorts the result array by value.\n\
    <code>\n$test = \"a b b c a b b a\";\n\n$letters = str_split($test);\n$histogram\
    \ = array_count_values($letters);\n", "  $histogram = array();\n  foreach (str_split($test)\
    \ as $letter) {\n    if (array_key_exists($letter, $histogram)) {\n      $histogram[$letter]++;\n\
    \    } else {\n      $histogram[$letter] = 1;\n    }\n  }\n  return $histogram;\n\
    }\n\n$test = 'a b a b b a';\n$histogram = histogram($test);\nksort($histogram);\n\
    \nprint '<pre>';\nprint_r($histogram);\nprint '</pre>';\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if the input string is e.g. \"a b b a a c c c\
    \ c c c c a a a b b a a b b a a b a b a a b a a a a b b b b b b b a a a a a a\
    \ a b b b b b a a a a a a a a b a a a a a a a a a a a a b b b b a a a a a a a\
    \ a a a a a b b b b b a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a "]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
