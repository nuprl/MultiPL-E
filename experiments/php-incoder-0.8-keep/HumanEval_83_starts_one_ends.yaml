name: HumanEval_83_starts_one_ends
language: php
prompt: "<?php\n// Given a positive integer n, return the count of the numbers of\
  \ n-digit\n// positive integers that start or end with 1.\nfunction starts_one_ends($n)\
  \ {\n"
tests: "function candidate(...$args) {\n    return starts_one_ends(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(1) !== 1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(2) !== 18) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(3) !== 180) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(4) !== 1800) { throw new Exception(\"Test failed!\"); }\n   \
  \ if (candidate(5) !== 18000) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["  if ($n <= 1) return 0;\n  if ($n == 2) return 1;\n  if ($n == 3)\
    \ return 2;\n  if ($n == 4) return 3;\n  // We know this number is odd\n  if ($n\
    \ & 1) {\n    return 0;\n  }\n\n  $count = 4;\n  $start = 1;\n  while (1) {\n\
    \    if ($n & $start) $count += 2;\n    $start++;\n    if ($start > $n - 1) break;\n\
    \    if ($n & $start) $count += 2;\n    $start++;\n    if ($start > $n - 1) break;\n\
    \    $start++;\n  }\n  return $count;\n}\n", "  return $n - (substr_count($n,\
    \ \"1\") % 10);\n}\n", "  for ($i = 1; $i <= $n; ++$i) {\n    if ($i === 1 ||\
    \ $i === $n || $i % 10 === 1) {\n      return $i;\n    }\n  }\n  return $n;\n\
    }\n\n$starts = starts_one_ends(5);\n$ends = starts_one_ends(9);\n$total = ($starts\
    \ * $ends);\n\necho \"There are $total odd numbers that start or end with 1.\\\
    n\";\n</code>\nOutput:\n<code>\nThere are 46 odd numbers that start or end with\
    \ 1.\n</code>\n<|/ a |>\n<| c |>\nThe question is asking for a single number in\
    \ the range 1 to 9. Not an entire sequence 1 to 9.\n<|/ c |>\n<| c |>\nThanks.\
    \ I missed that distinction. I was trying to make a code snippet that would do\
    \ a single number or single number range. I will edit my answer.\n<|/ c |>\n<|\
    \ c |>\nPlease note that the function will fail on negative numbers or values\
    \ not in the range. The only way around this is to convert it to positive.\n<|/\
    \ c |>\n<| c |>\nI have added a workaround for negative numbers and the input\
    \ check. It should work fine now.\n<|/ c |>\n<| c |>\nI have made a revision.\
    \ The function was still failing on negative numbers because they were still treated\
    \ as zero. Now it will work.\n<|/ c |>\n<| a |>\n<code>", "  $starts = array(1);\n\
    \  for ($i = 1; $i <= $n; ++$i) {\n    $starts[] = $starts[$i - 1] + $starts[$i];\n\
    \  }\n  return $starts[$n];\n}\n", "  $one_starts = 1;\n  $one_ends = 0;\n  for\
    \ ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      $one_starts++;\n\
    \      if ($i % 10 == 1) {\n        $one_ends++;\n      }\n    }\n  }\n  return\
    \ $one_starts - $one_ends;\n}\n", "  // Initialize your counter here to zero.\n\
    \  $count = 0;\n\n  // Use this variable to determine if the number starts or\
    \ ends with 1.\n  $startsOrEnds = false;\n\n  // Use this variable to determine\
    \ the number of digits in the number.\n  $digits = 0;\n\n  // Use a while loop\
    \ to determine how many positive integers there are with\n  // one or fewer digits.\n\
    \  while (is_positive($n) && is_integer($n % 10) === 0) {\n    $n /= 10;\n   \
    \ $digits++;\n  }\n\n  // If the number of digits is greater than 1, we know that\
    \ the number starts\n  // with 1 and ends with 1 (i.e. $digits < $count). Otherwise,\
    \ we've got\n  // to conclude that the number does not start with 1 or end with\
    \ 1. The\n  // rest of this function will need to determine if the number starts\
    \ or ends\n  // with 1.\n  if ($digits >= 1) {\n    $startsOrEnds = $startsOrEnds\
    \ = true;\n  }\n\n  // Use a while loop to determine the number of negative integers\
    \ there are\n  // with one or fewer digits.\n  while (is_negative($n) && is_integer($n\
    \ % 10) === 0) {\n    $n /= 10;\n    $digits++;\n  }\n\n  // If the number of\
    \ digits is greater than 1, we know that the number starts\n  // with 1 and ends\
    \ with -1 (i.e. $digits < $count). Otherwise, we've got\n  // to conclude that\
    \ the number does not start with -1 or end with -1. The\n  // rest of this function\
    \ will need to determine if the number starts or ends\n  // with -1.\n  if ($digits\
    \ >= 1) {\n    $startsOrEnds = $startsOrEnds = false;\n  }\n\n  // Return the\
    \ count of the numbers of n-digit positive integers that start or\n  // end with\
    \ 1.\n  return $count;\n}\n", "  global $counter;\n  $counter = 0;\n  for ($i\
    \ = 1; $i <= $n; $i++) {\n    if (($i % 10) == 1) {\n      if ($i != 1) {\n  \
    \      if ($i == $n || $i == $n - 1) {\n          $counter++;\n        }\n   \
    \   } else {\n        if ($i == 1 || $i == $n) {\n          $counter++;\n    \
    \    }\n      }\n    }\n  }\n  return $counter;\n}\n", "  // Count from 0 to the\
    \ given $n, counting by 1\n  $c = 1;\n  for ($i = 1; $i <= $n; $i++) {\n    if\
    \ ($i % 10 == 1) {\n      $c++;\n    }\n  }\n  return $c;\n}\n$nums = array(4,\
    \ 6, 4, 2, 7, 1, 6, 4, 3);\necho 'starts_one_ends(7) gives ' . starts_one_ends(7);\n\
    echo 'starts_one_ends(10) gives ' . starts_one_ends(10);\n</code>\n<|/ a tags=php\
    \ dscore=0 |>\n<| c |>\nThank you. I've modified the question slightly since I\
    \ didn't need to do this with consecutive integers\n<|/ c |>\n<| c |>\nOK.  Now\
    \ we're getting somewhere.\n<|/ c |>\n<| a tags=php |>\nSo I used the answer posted\
    \ by David VanGasse to get the following code which works for me.\n<code>\n<?php\n",
  "  return preg_match_all('/1{' . $n . '}$/', $n) ? $n : 0;\n}\n</code>\n<|/ a dscore=0\
    \ tags=math,php |>\n<| c |>\nThis won't work for negative numbers. I tested the\
    \ example `starts_one_ends(-2)` and it returns 0.\n<|/ c |>\n<| c |>\nRight. I\
    \ misunderstood the requirements. I've added a solution that works for both positive\
    \ and negative numbers.\n<|/ c |>\n<| c |>\nThat's great. Thanks for that!\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\n<?php", "  if ($n == 1) {\n    return 0;\n \
    \ }\n\n  // If the number is negative, then the digits are all one digit.\n  if\
    \ ($n < 0) {\n    return $n;\n  }\n\n  // If the number is zero, then the digits\
    \ are all zero.\n  if ($n == 0) {\n    return 1;\n  }\n\n  // Add one to the number\
    \ until we encounter an extra 1.\n  for ($i = 1; $i * 10 <= $n; $i++) {\n    if\
    \ ($n % $i == 0) {\n      return $i;\n    }\n  }\n}", "  $ones = $n + 1; // Start\
    \ with 1.\n  $ones_count = starts_ends($ones);\n  // If it isn't a perfect square,\
    \ stop.\n  if ($n % $ones_count != 0) {\n    return 0;\n  }\n  return $ones_count;\n\
    }", "    $n_str = decbin($n);\n    $count = 0;\n    $nlen = strlen($n_str);\n\
    \    for ($i = 0; $i < $nlen; $i++) {\n        if ($n_str[$i] === '1') {\n   \
    \         $count++;\n        }\n    }\n    return $count;\n}\n", "  $count = 0;\n\
    \  for ($i = 1;$i <= $n; ++$i) {\n    if (($i % 10) == 0) {\n      if ($i == 1)\
    \ ++$count;\n      else if ((($i-1) % 10) == 0) ++$count;\n    }\n  }\n  return\
    \ $count;\n}\n", "  $count = 0;\n  for ($i = 1; $i <= $n; ++$i) {\n    if ($i\
    \ % 10 == 1) {\n      $count += $i - 1;\n    }\n  }\n  return $count;\n}", " \
    \ $count = 0;\n  for ($i = 1; $i <= $n; ++$i) {\n    if ($i % 10 == 1) ++$count;\n\
    \    if ($i % 10 == 0) return $count;\n  }\n  return $count;\n}\n", "  if ($n\
    \ == 0)\n    return 0;\n\n  if ($n % 2 == 0)\n    return $n + starts_one_ends(floor($n\
    \ / 2)) - 1;\n\n  else\n    return $n + starts_one_ends(ceil($n / 2)) - 1;\n}\n\
    \n$digits = array_fill(0, 10, 1);\n", "  $count = 0;\n  $one = 1;\n  while ($n\
    \ >= $one) {\n    if ($n % $one == 0) {\n      $n = ($n / $one) * $one;\n    }\
    \ else {\n      $count++;\n      $n = ($n - 1) / $one;\n    }\n  }\n  return $count;\n\
    }", "\t$count_ones = 0;\n\t$n *= 10;\n\tfor ($i = $n - 1; $i >= 0; $i--) {\n\t\
    \tif ($i % 10 == 0) {\n\t\t\tif ($i == 1)\n\t\t\t\t$count_ones += 1;\n\t\t} else\
    \ {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $count_ones;\n}\n", "    $n = abs($n);\n\
    \    return ($n == 0) ? (1) : ($n <= 9) ? (floor($n) + 1) : (floor($n) - 9);\n\
    }\n</code>\nThe above function can be called as:\n<code>\n$count = (starts_one_ends(1235)\
    \ - starts_one_ends(1236));\n</code>\nThe same can be done to calculate the number\
    \ of positive integers that start with 1 and\nend with n.\n<code>\n<?php", " \
    \ $digits = str_pad('', $n, '1');\n  return substr_count($digits, '1');\n}\n",
  "\t$n = abs($n);\n\t$t = 0;\n\tif ($n <= 100) {\n\t\t$t = $n+1;\n\t} elseif ($n\
    \ <= 1000) {\n\t\t$t = $n+2;\n\t} elseif ($n <= 10000) {\n\t\t$t = $n+3;\n\t}\
    \ elseif ($n <= 100000) {\n\t\t$t = $n+4;\n\t} elseif ($n <= 1000000) {\n\t\t\
    $t = $n+5;\n\t} elseif ($n <= 10000000) {\n\t\t$t = $n+6;\n\t} elseif ($n <= 100000000)\
    \ {\n\t\t$t = $n+7;\n\t} elseif ($n <= 1000000000) {\n\t\t$t = $n+8;\n\t} elseif\
    \ ($n <= 10000000000) {\n\t\t$t = $n+9;\n\t} elseif ($n <= 100000000000) {\n\t\
    \t$t = $n+10;\n\t} elseif ($n <= 1000000000000) {\n\t\t$t = $n+11;\n\t} elseif\
    \ ($n <= 10000000000000) {\n\t\t$t = $n+12;\n\t} elseif ($n <= 100000000000000)\
    \ {\n\t\t$t = $n+13;\n\t} elseif ($n <= 1000000000000000) {\n\t\t$t = $n+14;\n\
    \t} elseif ($n <= 10000000000000000) {\n\t\t$t = $n+15;\n\t} elseif ($n <= 100000000000000000)\
    \ {\n\t\t$t = $n+16;\n\t} elseif ($n <= 1000000000000000000) {\n\t\t$t = $n+17;\n\
    \t} elseif ($n <= 10000000000000000000) {\n\t\t$t = $n+18;\n\t} elseif ($n <=\
    \ 100000000000000000000) {\n\t\t$t = $n+19;\n\t} elseif ($n <= 1000000000000000000000)\
    \ {\n\t\t$t = $n+20;\n\t} elseif ($n <= 10000000000000000000000) {\n\t\t$t = $n+21;\n\
    \t} elseif ($n <= 100000000000000000000000) {\n\t\t$t = $n+22;\n\t} elseif ($n\
    \ <= 1000000000000000000000000) {\n\t\t$t = $n+23;\n\t} elseif ($n <= 10000000000000000000000000)\
    \ {\n\t\t$t = $n+24;\n\t} elseif ($n <= 100000000000000000000000000) {\n\t\t$t\
    \ = $n+25;\n\t} elseif ($n <= 1000000000000000000000000000) {\n\t\t$t = $", " \
    \ if ($n == 0)\n    return 0;\n\n  // If n is odd, there is one fewer number which\
    \ ends with 1.\n  if ($n%2 != 0)\n    return count(array_filter(\n      range(2,\
    \ $n+1),\n      function($n) { return $n%2 == 1; }));\n\n  // If n is even, there\
    \ is one fewer number which starts with 1.\n  return count(array_filter(\n   \
    \   range(2, $n+1),\n      function($n) { return $n%2 == 0; }));\n}\n\n$n = 100;\n\
    $ndigits = strlen($n);\n$count = starts_one_ends($n) * $ndigits;\nprint \"$n has\
    \ $count numbers that start with 1 or end in 1.\\n\";\n</code>\n<|/ a tags=algorithm,php\
    \ |>\n<| c |>\nThis doesn't work for n=9 as it will give an incorrect, though\
    \ not excessive, answer. Also, no explanation of what the function is doing.\n\
    <|/ c |>\n<| c |>\nI've added an explanation and also updated my answer.\n<|/\
    \ c |>\n<| a tags=algorithm,php dscore=2 |>\n<code>\n<?php\n", "  if ($n < 9)\
    \ {\n    return 1;\n  }\n  return 1 + ($n / 9) * 9 + ends_one_starts($n % 9 +\
    \ 1);\n}\n", "    $count = 0;\n    while (true) {\n        $x = $n + 1;\n    \
    \    $starts_one = ($x % 10 === 1) && (($x % 100 < 10) || ($x % 100 >= 20));\n\
    \        $ends_one = ($x % 10 === 9);\n        if ($starts_one || $ends_one) {\n\
    \            $count++;\n        }\n        $n++;\n    }\n    return $count;\n\
    }\n", "  $i = 1;\n  while (starts_one_ends($i * 10) == $i * 10) {\n    $i++;\n\
    \  }\n  return $i;\n}\n", "  $count = 0;\n  while ($n != 1) {\n    $n = ($n %\
    \ 10) + 1;\n    if ($n != 1) {\n      $count++;\n    }\n  }\n  return $count;\n\
    }\n</code>\nThis solution has three parts:\n\nThe main part is the recursive function\
    \ which checks if a number is 1 or not. It takes as input the value of a digit\
    \ (digits are indexed from 0 to 9) and the digits that follow it (the digits after\
    \ the current digit are indexed from 1 to 10).\nIt recursively calls itself with\
    \ the next digits and the digits that come after each one, to find the next digits\
    \ that must be checked.\nThe end condition checks if the next digit must be checked,\
    \ and if not, it returns 0 instead of 1.\n\nThe recursive function can also be\
    \ written as a while loop, but I find the recursive way easier to read and understand.\n\
    <|/ a tags=math,php,algorithm,factorial |>\n<| c |>\nThanks for your answer. But\
    \ I cannot use this code as it is. What it does is it returns 1 if given number\
    \ is 1 otherwise returns 0. But I want it to return total number of numbers with\
    \ 1 or 0. I will edit my question to make it more clear.\n<|/ c |>\n<| c |>\n\
    Edited my answer to give a solution that finds the number of 1s that occur before\
    \ the first 0 (and all following ones)\n<|/ c |>\n<| c |>\nI ran your code and\
    \ it returns 0 when given 0. It should return 0.\n<|/ c |>\n<| c |>\nWhat it should\
    \ return is 0, because the next digit must be checked before the current one.\
    \ Since no number starts or ends with 0, the count is 0.\n<|/ c |>\n<| c |>\n\
    I think it returns 0 because you passed 1 as parameter. I passed 0 as parameter\
    \ and it returned 0.\n<|/ c |>\n<| a tags=math,php,algorithm,factorial |>\nA simple\
    \ solution would be to just use some string manipulation and regular expressions:\n\
    <code>\n<?php\n$number = 1;\n$count = 0;\n$count = (string)$number;\nwhile($count[0]\
    \ === \"0\") {\n    $count = (string)$number++;\n}\n$count = substr($count, 0,\
    \ -1);\necho $count;\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer.\
    \ But I cannot use this code as it is. What it does is it returns 1 if given number\
    \ is 1 otherwise returns 0. But I want it to return total number of numbers with\
    \ 1 or 0. I will edit my question to make it more clear.\n<|/ c |>\n<| a tags=math,php,algorithm,factorial\
    \ dscore=1 |>\nTry this\n<code>\n<?php\n$", "  $count = 0; $n *= 10; // convert\
    \ n to base 10\n  for ($i = 1; $n >= $i; $n = ($n % $i) + $i) { $count++; }\n\
    \  return $count;\n}\n", "  $n *= 10;\n  do {\n    $n++;\n    if ($n == $n + 1)\n\
    \      return 1;\n  } while ($n % 10 == 1);\n  return 0;\n}\n", "    $count =\
    \ 0;\n    $start = $n % 10;\n    if ($start == 1) {\n        $count++;\n    }\n\
    \    $end = $n % 10;\n    if ($end == 1) {\n        $count++;\n        $n = $n\
    \ / 10;\n    }\n    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $start\
    \ = $i % 10;\n        $end = $i % 10;\n        if ($start == 1) {\n          \
    \  $count++;\n        }\n        if ($end == 1) {\n            $count++;\n   \
    \         $n = $n / 10;\n        }\n    }\n    return $count;\n}\n\necho \"<br\
    \ />starts_one_ends tests:<br />\";\n\n$arr1 = array(9, 10, 11, 12, 1, 10, 2,\
    \ 12, 12, 1);\n$arr2 = array(9, 10, 11, 12, 1, 10, 2, 12, 12, 1, 11);\n$arr3 =\
    \ array(9, 10, 11, 12, 1, 10, 2, 12, 12, 1, 10, 11);\n$arr4 = array(9, 10, 11,\
    \ 12, 1, 10, 2, 12, 12, 1, 10, 11, 12);\n\n$result1 = starts_one_ends(90);\n$result2\
    \ = starts_one_ends(100);\n$result3 = starts_one_ends(1000);\n$result4 = starts_one_ends(100000);\n\
    \n$result5 = starts_one_ends(100000000);\n$result6 = starts_one_ends(1000000000000);\n\
    \necho \"<pre>\";\nprint_r($arr1);\necho \"<br />\";\nprint_r($arr2);\necho \"\
    <br />\";\nprint_r($arr3);\necho \"<br />\";\nprint_r($arr4);\n\necho \"<br />starts_one_ends\
    \ results:<br />\";\n\nprint_r($result1);\necho \"<br />\";\nprint_r($result2);\n\
    echo \"<br />\";\nprint_r($result3);\necho \"<br />\";\nprint_r($result4);\necho\
    \ \"<br />\";\nprint_r($result5);\necho \"<br />\";\nprint_r($result6);", "  //\
    \ This should probably be optimized using a table or something\n  if ($n<10) {\n\
    \    return 0;\n  }\n  if ($n<100) {\n    return 1;\n  }\n  $nums = array();\n\
    \  for ($i=5; $i<$n; $i++) {\n    if ($i%2 != 0) {\n      continue;\n    }\n \
    \   for ($j=10-$i; $j>=0; $j--) {\n      $t = $i * 10 + $j;\n      if ($t == $n)\
    \ {\n        return $j;\n      }\n      if ($j == 1) {\n        return 0;\n  \
    \    }\n    }\n  }\n  return 0;\n}", "    if ($n == 1) return 1;\n    if ($n ==\
    \ 0) return 0;\n    return ends_one_starts($n) + 1;\n}\n", "  $ndigit = strlen($n)\
    \ - 1;\n  $count = 0;\n  for ($d = 1; $d <= $ndigit; $d++) {\n    $testnum = substr($n,\
    \ $d, 1);\n    if ($testnum != '1') {\n      return $count;\n    }\n    $count++;\n\
    \  }\n  return $count;\n}\n", "    if ($n == 1) return 1;\n    if ($n == 2) return\
    \ 2;\n    return 1 + starts_one_ends(floor($n/10));\n}\n", "    $nstr = (string)\
    \ $n;\n    $starts_ends_ones = array();\n    for ($i = 0; $i < strlen($nstr);\
    \ $i++) {\n        if ($nstr[$i] === 1) {\n            $starts_ends_ones[] = $i\
    \ + 1;\n        }\n    }\n    return count($starts_ends_ones);\n}\n", "  $count\
    \ = 0;\n  while ($n >= 10) {\n    $count += $n % 10;\n    $n = floor($n / 10);\n\
    \  }\n  return $count;\n}\n", "    $ends = array();\n    for($i = 1; $i <= $n;\
    \ $i++) {\n        if($i % 10 == 1 && $i % 100 != 11) {\n            $ends[] =\
    \ $i;\n        }\n    }\n    return count($ends);\n}\n", "  global $count;\n \
    \ $count = 1;\n  for ($i = 0; $i < $n; $i++) {\n    if ($i % 11 == 0) $count +=\
    \ 11;\n    if ($i % 10 == 0) $count += 10;\n    if ($i % 9 == 0) $count += 9;\n\
    \    if ($i % 8 == 0) $count += 8;\n    if ($i % 7 == 0) $count += 7;\n    if\
    \ ($i % 6 == 0) $count += 6;\n    if ($i % 5 == 0) $count += 5;\n    if ($i %\
    \ 4 == 0) $count += 4;\n    if ($i % 3 == 0) $count += 3;\n    if ($i % 2 == 0)\
    \ $count += 2;\n    if ($i % 1 == 0) $count += 1;\n  }\n  return $count;\n}\n",
  "    $start = 0;\n    $end = 0;\n\n    while ($n >= 1) {\n        $start++;\n  \
    \      $n = $n % 10;\n    }\n\n    while ($n >= 1) {\n        $end++;\n      \
    \  $n = $n % 10;\n    }\n\n    return $end + 1;\n}\n", "  $count = 0;\n  for ($i\
    \ = $n; $i > 1; $i--) {\n    if ($i % 10 == 1) {\n      $count++;\n    }\n   \
    \ if ($i % 10 == 0 &&\n        ($i != 11 || $i % 10 == 9)) {\n      $count++;\n\
    \    }\n  }\n  return $count;\n}\n", "  $count = 0;\n  for ($i = 1; ; ++$i) {\n\
    \    if ($n % $i == 0) {\n      if ($i >= $n) {\n        break;\n      }\n   \
    \   ++$count;\n      if ($i == $n) {\n        break;\n      }\n    }\n  }\n  return\
    \ $count;\n}\n\n$n = 1;\nwhile (starts_one_ends($n) < 5) {\n  ++$n;\n}\nprintf(\"\
    %d has %d 1-digit numbers\\n\", $n, starts_one_ends($n));", "  $count = 0;\n \
    \ $i = 1;\n  while($i <= $n) {\n    if($i % 10 == 1) {\n      $count++;\n    }\n\
    \    $i++;\n  }\n  return $count;\n}\n", "  $count = 0;\n  for ($i = 2; $i <=\
    \ $n; $i++) {\n    if ($i % 11 == 1) {\n      $count++;\n    }\n  }\n  return\
    \ $count;\n}\n$starts_one_ends = starts_one_ends($n);\n$starts_one_ends_2 = starts_one_ends($n-2);\n\
    $starts_one_ends_3 = starts_one_ends($n-3);\n$starts_one_ends_4 = starts_one_ends($n-4);\n",
  "  $count = 1;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n    \
    \  if ($i > 1) {\n        $count++;\n      }\n    } else {\n      if ($i >= $n)\
    \ {\n        $count++;\n      }\n    }\n  }\n  return $count;\n}", "  $n = abs($n);\n\
    \  $count = 0;\n  $ones = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10\
    \ == 1)\n      $ones++;\n    else\n      $count++;\n  }\n  return $count - $ones;\n\
    }\n</code>\n<|/ a tags=php,math,algorithm,combinatorics |>\n<| c |>\nThis doesn't\
    \ count the negative ones in the right place, it counts them right in the middle\n\
    <|/ c |>\n<| c |>\nThat's a very nice function! Thanks. How would you change it\
    \ to count negative ones in the right place?\n<|/ c |>\n<| a dscore=3 tags=php,math,algorithm,combinatorics\
    \ |>\nHere is my take on it:\n<code>\n<?php\n", "  for ($i = 2; $i < $n; ++$i)\
    \ {\n    if ($i % $i == 1)\n      return $i;\n  }\n  return 0;\n}\n", "  return\
    \ intval(base_convert($n, 10, 1)) -\n      intval(base_convert($n, 10, 10)) -\
    \ 1;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nThat is what I call a great solution!\
    \ Thank you very much.\n<|/ c |>\n<| a |>\n<code>", "    $count = 0;\n    while($n\
    \ >= 10) {\n        $count++;\n        $n = $n / 10;\n    }\n    if($n == 1 ||\
    \ $n == 0) {\n        return 1;\n    } else {\n        return $count;\n    }\n\
    }\n", "  return intval(log($n) / log(10));\n}\n", "  // Your code here\n}\n\n\
    assert(starts_one_ends(1) == 0);\nassert(starts_one_ends(2) == 1);\nassert(starts_one_ends(3)\
    \ == 2);\nassert(starts_one_ends(4) == 3);\nassert(starts_one_ends(5) == 4);\n\
    assert(starts_one_ends(6) == 5);\nassert(starts_one_ends(7) == 5);\nassert(starts_one_ends(8)\
    \ == 5);\nassert(starts_one_ends(9) == 5);\nassert(starts_one_ends(10) == 5);\n\
    assert(starts_one_ends(99) == 5);\nassert(starts_one_ends(100) == 5);\nassert(starts_one_ends(999)\
    \ == 5);\nassert(starts_one_ends(1000) == 5);\nassert(starts_one_ends(10000) ==\
    \ 5);\nassert(starts_one_ends(100000) == 5);\nassert(starts_one_ends(1000000)\
    \ == 5);\nassert(starts_one_ends(10000000) == 5);\nassert(starts_one_ends(100000000)\
    \ == 5);\nassert(starts_one_ends(1000000000) == 5);\nassert(starts_one_ends(10000000000)\
    \ == 5);\nassert(starts_one_ends(100000000000) == 5);\nassert(starts_one_ends(1000000000000)\
    \ == 5);\nassert(starts_one_ends(10000000000000) == 5);\nassert(starts_one_ends(100000000000000)\
    \ == 5);\nassert(starts_one_ends(1000000000000000) == 5);\nassert(starts_one_ends(10000000000000000)\
    \ == 5);\nassert(starts_one_ends(100000000000000000) == 5);\nassert(starts_one_ends(1000000000000000000)\
    \ == 5);\nassert(starts_one_ends(10000000000000000000) == 5);\nassert(starts_one_ends(100000000000000000000)\
    \ == 5);\nassert(starts_one_ends(1000000000000000000000) == 5);\nassert(starts_one_ends(10000000000000000000000)\
    \ == 5);\nassert(starts_one_ends(100000000000000000000000) == 5);\nassert(starts_one_ends(1000000000000000000000000)\
    \ == 5);\nassert(starts_one_ends(10000000000000000000000000) == 5);\nassert(starts_one_ends(100000000000000000000000000)\
    \ == 5);\nassert(starts_one_ends(1000000000000000000000000000) == 5);\nassert(starts_one_ends(10000000000000000000000000000)\
    \ == 5);\nassert(starts_one_ends(100000000000000000000000000000) == 5);\nassert(starts_one_ends(1000000000000000000000000000000)\
    \ == 5);\nassert(starts_one_ends(10000000000000000000000000000000) == 5);\nassert(starts_one_ends(100000000000000000000000000000000)\
    \ == 5);\nassert(starts_one_ends(1000000000000000000000000000000000) == 5);\n\
    assert(starts_one_ends(1000000000000000000000000000000000", "  if ($n < 1) {\n\
    \    return 0;\n  }\n\n  $ones = array_filter(range(1, $n), function ($x) {\n\
    \    return $x == 1;\n  });\n\n  return count($ones);\n}\n", "    return floor(($n\
    \ - 1) / log10($n) + 1);\n}\n", "  $count = 1;\n  while ($n > 0) {\n    if ($n\
    \ % 10 == 1) {\n      $n = 0;\n      $count++;\n    }\n    $n--;\n  }\n  return\
    \ $count;\n}\n", "  return $n!==0 ? 0 : $n == 1 ? 1 : starts_one_ends(floor($n/10))\
    \ + 1;\n}\n", "  $count = 0;\n  for ($i = 1; $i <= $n; ++$i) {\n    if ($n % 10\
    \ == 1 || $n % 10 == 2) {\n      if ($i == $n) {\n        $count++;\n      }\n\
    \    }\n  }\n  return $count;\n}", "  $n = (int)$n;\n  return $n < 10 ? $n\n \
    \   : 11 - $n % 10\n    + count_digits($n % 10);\n}", "  // We only need to check\
    \ up to $n / 10, since after that we check $n % 10\n  // and $n / 10 must both\
    \ be < $n.\n  $count = 0;\n  for ($i = 1; $i <= $n / 10; $i += 2) {\n    if ($n\
    \ % 10 == 1 && $n / 10 >= $i) {\n      // We found a starting point with a 1 or\
    \ higher.\n      $count++;\n    }\n  }\n\n  return $count;\n}\n", "  return 1\
    \ + intval(log($n) / log(10));\n}\n", "  return preg_match('/^[0-9]{' . $n . ',}$/',\
    \ str_pad($n, strlen($n) + 1, '1', STR_PAD_LEFT)) ? 1 : 0;\n}\n", "  if ($n <=\
    \ 1) return 0;\n  $count = intdiv($n, 10);\n  if ($n % 10 == 1) {\n    $count\
    \ -= 1;\n  }\n  return $count;\n}\n\n$n = 15;\n\n$starts_one_ends(14);\n$starts_one_ends(16);\n\
    $starts_one_ends(17);\n$starts_one_ends(18);\n$starts_one_ends(25);\n$starts_one_ends(29);\n\
    $starts_one_ends(44);\n$starts_one_ends(63);\n$starts_one_ends(71);\n$starts_one_ends(78);\n\
    $starts_one_ends(92);\n", "  $n = abs($n);\n  $sum = 0;\n  for ($i = 1; $i <=\
    \ $n; $i++) {\n    if ($i % $n == 0) {\n      if ($i == 1) {\n        $sum++;\n\
    \      } else if ($i == $n) {\n        $sum += 2;\n      } else {\n        $sum\
    \ += 3;\n      }\n    }\n  }\n  return $sum;\n}\n", "  $count = 0;\n  while (is_int($n))\
    \ {\n    if ($n % 10 == 1) {\n      if ($n != 1) {\n        $count++;\n      }\n\
    \    }\n    $n = ($n-1);\n  }\n  return $count;\n}\n", "  return (int) count(array_filter(range(1,\
    \ $n+1), function ($i) {\n    return ($i === 1 || $i === $n) ? true : false;\n\
    \  }));\n}\n</code>\nAnd to test it:\n<code>\nvar_dump(starts_one_ends(10)); \
    \ // 2\nvar_dump(starts_one_ends(100));  // 3\nvar_dump(starts_one_ends(1000));\
    \ // 2\nvar_dump(starts_one_ends(10000)); // 5\nvar_dump(starts_one_ends(100000));\
    \ // 4\nvar_dump(starts_one_ends(1000000)); // 10\nvar_dump(starts_one_ends(10000000));\
    \ // 9\n</code>\n<|/ a dscore=1 tags=math,algorithm,php |>\n<| a |>\nThis solution\
    \ only requires a few operations.\n<code>", "  $count = 0;\n  for ($i = 1; $i\
    \ <= $n; $i++) {\n    if ($i % 10 == 1) $count++;\n    if ($i % 10 == 0) $count--;\n\
    \  }\n  return $count;\n}\n", "  // Initialize count as 0\n  $count = 0;\n  //\
    \ If the number is zero, return 0\n  if ($n == 0) {\n    return 0;\n  }\n  //\
    \ If the number is negative, return 0\n  if ($n < 1) {\n    return 0;\n  }\n \
    \ // While the number is non-zero, subtract one from it\n  while ($n > 1) {\n\
    \    $count++;\n    $n--;\n  }\n  // Return the count\n  return $count;\n}\n",
  "  $starts = $ends = 0;\n  while ($n != 0) {\n    $starts = $starts * 10 + ($n %\
    \ 10);\n    $ends = $ends * 10 + ($n % 10);\n    $n = floor($n/10);\n  }\n  return\
    \ $starts - $ends;\n}", "  return $n <= 9 ? 1 :\n         $n <= 99 ? 2 :\n   \
    \      $n <= 999 ? 3 :\n         $n <= 9999 ? 4 :\n         $n <= 99999 ? 5 :\n\
    \         $n <= 999999 ? 6 :\n         $n <= 9999999 ? 7 :\n         $n <= 99999999\
    \ ? 8 :\n         $n <= 999999999 ? 9 :\n         $n <= 9999999999 ? 10 :\n  \
    \       $n <= 99999999999 ? 11 :\n         $n <= 999999999999 ? 12 :\n       \
    \  $n <= 9999999999999 ? 13 :\n         $n <= 9999999999999 ? 14 :\n         $n\
    \ <= 9999999999999 ? 15 :\n         $n <= 9999999999999 ? 16 :\n         $n <=\
    \ 9999999999999 ? 17 :\n         $n <= 9999999999999 ? 18 :\n         $n <= 9999999999999\
    \ ? 19 :\n         $n <= 9999999999999 ? 20 :\n         $n <= 9999999999999 ?\
    \ 21 :\n         $n <= 9999999999999 ? 22 :\n         $n <= 9999999999999 ? 23\
    \ :\n         $n <= 9999999999999 ? 24 :\n         $n <= 9999999999999 ? 25 :\n\
    \         $n <= 9999999999999 ? 26 :\n         $n <= 9999999999999 ? 27 :\n  \
    \       $n <= 9999999999999 ? 28 :\n         $n <= 9999999999999 ? 29 :\n    \
    \     $n <= 9999999999999 ? 30 :\n         $n <= 9999999999999 ? 31 :\n      \
    \   $n <= 9999999999999 ? 32 :\n         $n <= 9999999999999 ? 33 :\n        \
    \ $n <= 9999999999999 ? 34 :\n         $n <= 9999999999999 ? 35 :\n         $n\
    \ <= 9999999999999 ? 36 :\n         $n <= 9999999999999 ? 37 :\n         $n <=\
    \ 9999999999999 ? 38 :\n         $n <= 9999999999999 ? 39 :\n         $n <= 9999999999999\
    \ ? 40 :\n         $n <= 9999999999999 ? 41 :\n         $n <= 9999999999999 ?\
    \ 42 :\n         $n <= 9999999999999 ? 43 :\n         $n <= 9999999999999 ? 44\
    \ :\n         $n <= 9999999999999 ? 45 :\n         $n <= 9999999999999 ? 46 :\n\
    \         $n <= 9999999999999 ? 47 :\n         $n <= 9999999999999 ? 48 :\n  \
    \       $n <= 9999999999999 ? 49 :\n         $n <= 9999999999999 ? 50 :\n    \
    \     $n <= 9999999999999", "  $count = 0;\n  for ($i = 1; $i <= $n; $i++) {\n\
    \    if ($n % 10 == 1) {\n      $count++;\n      if ($i == $n) {\n        break;\n\
    \      }\n    }\n    if ($n % 10 == 0 && $i != $n) {\n      $count++;\n    }\n\
    \  }\n  return $count;\n}\n", "  $count = 0;\n  for ($i = 2; $i <= $n; ++$i) {\n\
    \    if ($i%10 == 1) {\n      $count += 1;\n      if ($i / 10 == $n) {\n     \
    \   break;\n      }\n    }\n  }\n  return $count;\n}\n", "  if ($n < 10 || $n\
    \ >= 100) return 0;\n  if ($n % 10 == 1) return 1;\n  if ($n % 10 == 2) return\
    \ 2;\n  // ...\n  if ($n % 10 == 0) return 9;\n}", "  $counter = 0;\n  for ($i\
    \ = 1; $i <= $n; $i++) {\n    if ($i % 10 != 1) {\n      $counter++;\n      if\
    \ ($counter >= 2) {\n        break;\n      }\n    }\n  }\n  return $counter;\n\
    }\n", "  if ($n < 10 || $n > 360 || $n <= 0)\n    return 0;\n  $nstr = strval($n);\n\
    \  return substr_count($nstr, '1') % 2 ? ($nstr[0] == '1' ? 2 : 1) : 0;\n}\n",
  "  $c = 0;\n  if ($n < 0) {\n    return $c;\n  }\n  if ($n == 0) {\n    return 0;\n\
    \  }\n  for ($i = 1; $i <= $n; $i++) {\n    $c = $c + starts_one_ends($n - $i);\n\
    \  }\n  return $c;\n}\necho starts_one_ends(1000) . \"\\n\";\necho starts_one_ends(1001)\
    \ . \"\\n\";", "  return floor(($n + 1) / 3) - (($n % 3) == 1);\n}\n</code>\n\
    The function is trivial to parallelize, using e.g. array_reduce:\n<code>", " \
    \ $ones = 0;\n  $ends = 0;\n  do {\n    $ones++;\n    $one = intval($n % 10);\n\
    \    if ($one == 1) {\n      $ends++;\n    }\n    $n = ($n - $one) / 10;\n  }\
    \ while ($n != 0);\n  return $ends + 1;\n}\n", "    return $n - (($n / 10) * (($n\
    \ % 10) === 0));\n}", "  global $cache;\n  // This variable is initialized once\
    \ in the beginning and then\n  // unchanged, so it does not need to be set as\
    \ a global variable.\n  if (isset($cache[$n])) return $cache[$n];\n  $result =\
    \ 1;\n  for ($i = 1; $i <= $n; ++$i) {\n    if ($i === 1 || $i % 10 === 1) {\n\
    \      ++$result;\n    }\n  }\n  $cache[$n] = $result;\n  return $result;\n}\n",
  "  // Return the number of n-digit positive integers that start or end with 1.\n\
    \  // Only work for n < 10 ^ n.\n  // For example, n = 123:\n  // 123: 1^2 + 1^2\
    \ + 3^2 + 3^2 + 3^2 + 1^2 = 3 + 3 + 3 + 3 + 3\n  // 124: 1^2 + 1^2 + 1^2 + 1^2\
    \ + 1^2 + 1^2 = 5 + 5 + 5 + 5 + 5\n  if ($n < 10) {\n    return 0;\n  }\n  $starts\
    \ = 0;\n  $ends = 0;\n  for ($i = $n; $i > 0; $i--) {\n    if ($i % 10 == 0) {\n\
    \      $starts++;\n    } else if ($i % 10 == 1) {\n      $ends++;\n    }\n  }\n\
    \  return $starts - $ends;\n}\n", "  $count = 0\n  for ($i = 0; $i < $n; $i++)\
    \ {\n    if ($n % 10 == 1) {\n      $count++;\n    }\n    $n = (int) floor($n\
    \ / 10);\n  }\n  return $count;\n}\n\n$starts_ends = starts_one_ends($n);\n",
  "  $count = 0;\n  while ($n >= 10) {\n    $count++;\n    $n = ($n / 10) - 1;\n \
    \ }\n  return $count;\n}", "  if ($n == 1) {\n    return 0;\n  }\n  if ($n ==\
    \ 0) {\n    return 1;\n  }\n  return starts_one_ends(floor($n / 10)) + ends_one_starts(floor($n\
    \ / 10));\n}\n", "  $count = 0;\n  $starts_one = array(1, 2, 3, 5, 7);\n  $ends_one\
    \ = array(0, 1, 1, 3, 5, 5, 7, 9);\n  foreach ($starts_one as $start) {\n    if\
    \ ($n == $start) {\n      $count++;\n    }\n  }\n  foreach ($ends_one as $end)\
    \ {\n    if ($n == $end) {\n      $count++;\n    }\n  }\n  return $count;\n}",
  "  assert(is_int($n));\n  assert($n >= 0);\n  $count = 0;\n  for ($i = 0; $i < $n;\
    \ $i++) {\n    $count++;\n    if ($i % 10 == 1) {\n      // 10\n      $count--;\n\
    \    }\n    if ($i % 10 == 0) {\n      // 1\n      $count--;\n    }\n  }\n  return\
    \ $count;\n}\n", "  $count = 0;\n  $i = 1;\n  while ($i <= $n) {\n    if ($i %\
    \ 10 == 1) {\n      $count++;\n    }\n    $i++;\n  }\n  return $count;\n}\n",
  "    $nn = str_split($n);\n    $n_digits = count($nn);\n    if ($n_digits === 1)\
    \ {\n        return 1;\n    }\n    $ones = substr($n, 0, $n_digits - 1);\n   \
    \ $n_starts_ones = substr_count($ones, 1);\n    return $n_starts_ones;\n}\n",
  "  $count = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1 && $i !=\
    \ 11) {\n      if ($i % 10 == 1 && $i != 10) {\n        $count++;\n      }\n \
    \   }\n  }\n  return $count;\n}\n", "  if ($n == 0) {\n    return 0;\n  }\n\n\
    \  $i = 1;\n  $sum = 0;\n  while ($i <= $n) {\n    $d = $i % 10;\n    $sum +=\
    \ $d + $d * ($n / 10) - $d * $n;\n    $i += $d;\n  }\n  return $sum;\n}\n", " \
    \ // Initialize a count variable and set it to zero. \n  $count = 0;\n  for ($i\
    \ = 1; $i <= $n; $i++) {\n    // If remainder of dividing $i by 10 is equal to\
    \ 1 then that number\n    // is one that starts or ends with 1. \n    if ($i %\
    \ 10 == 1 || $i % 10 == -1) {\n      $count++;\n    }\n  }\n\n  return $count;\n\
    }", "  return intval($n * log($n) / log10);\n}\n", "  $count = 0;\n  for ($x =\
    \ 1; $x <= $n; ++$x) {\n    if ($x % 10 == 1) {\n      $count += 1;\n    }\n \
    \   if ($x % 10 == 0 &&\n        (!($x % 100 == 0) || ($x % 100 == 99))) {\n \
    \     $count += 1;\n    }\n  }\n  return $count;\n}", "  global $starts, $ends;\n\
    \  if ($n <= 1) {\n    return 0;\n  }\n  list($starts, $ends) = array(array(),\
    \ array());\n  for ($i = 2; $i <= $n; $i++) {\n    if ($starts[$i] == 0) {\n \
    \     $starts[$i] = 1;\n      $ends[$i] = $i;\n    } else {\n      if ($i == $starts[$i])\
    \ {\n        $starts[$i] ++;\n      }\n      if ($i == $ends[$i]) {\n        $ends[$i]\
    \ ++;\n      }\n    }\n  }\n  return count($starts) - count($ends);\n}\n", " \
    \ $count = 1;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n   \
    \   if ($i % 100 == 1) {\n        if ($i % 1000 == 1) {\n          $count++;\n\
    \        }\n      }\n    }\n  }\n  return $count;\n}", "  $count = 0;\n  for ($i\
    \ = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) $count++;\n    if ($n % 10 ==\
    \ 1) $count++;\n  }\n  return $count;\n}", "  $digits = str_split($n, 1);\n  return\
    \ count($digits) - ($digits[count($digits) - 1] ? 1 : 0);\n}\n$starts = starts_one_ends(49999);\n\
    assert($starts == 1);\n", "    $total = 0;\n    while ($n > 1) {\n        $total\
    \ += $n & 1;\n        $n = $n >> 1;\n    }\n    return $total;\n}\n", "  if ($n\
    \ < 10)\n    return $n;\n  else\n    return starts_one_ends(floor($n/10)) + (($n\
    \ % 10 == 1) ? 1 : 0);\n}\n", "  if ($n == 0) {\n    return 0;\n  }\n  $ones =\
    \ array_fill(0, $n, 1);\n  return count(array_filter($ones, function($item) {\
    \ return $item === 1; }));\n}\n", "  $count = 0;\n  if ($n > 1) {\n    if ($n\
    \ == 1) {\n      $count = 1;\n    } else {\n      for ($i = 1; $i <= $n; $i++)\
    \ {\n        if ($i % 10 == 1 && $i != $n) {\n          $count++;\n        }\n\
    \      }\n    }\n  }\n  return $count;\n}", "  if ($n < 2)\n    return 0;\n  $count\
    \ = 0;\n  $n = abs($n);\n  while ($n >= 10) {\n    $count += ($n % 10) == 1;\n\
    \    $n /= 10;\n  }\n  return $count;\n}\n", "  // First count the number of 1's\
    \ in the number whose digits are 1 to n.\n  $ones = 0;\n  while (true) {\n   \
    \ $ones++;\n    if ($n >= 10) {\n      $n -= 10;\n    } else {\n      break;\n\
    \    }\n  }\n  $ones = str_pad(str_split($ones)[0], $n, '0');\n  // Then count\
    \ the number of 0's in the number whose digits are 0 to n.\n  $zeros = 0;\n  while\
    \ (true) {\n    $zeros++;\n    if ($n >= 10) {\n      $n -= 10;\n    } else {\n\
    \      break;\n    }\n  }\n  $zeros = str_pad(str_split($zeros)[0], $n, '0');\n\
    \  // Then count the number of 1's and 0's in $ones and $zeros and return the\n\
    \  // sum of the two.\n  return $ones + $zeros;\n}\n", "  if ($n == 0) {\n   \
    \ return 0;\n  }\n  $count = 0;\n  for ($i = 2; $i <= 9; $i++) {\n    if (($n\
    \ / $i) % 1 == 1) {\n      $count++;\n    }\n  }\n  return $count;\n}\n$n = 15;\n\
    print \"$n has $starts_one_ends($n) one-digit numbers that start with 1 or end\
    \ in 1.\\n\";", "    $start = end($n = str_split($n)) + 1;\n    return $n <= $start\
    \ ? 0 : $start + $n - $start;\n}\necho starts_one_ends(100);", "  if ($n < 10)\
    \ {\n    return 1;\n  }\n  if ($n < 100) {\n    return $n - 1;\n  }\n  if ($n\
    \ < 1000) {\n    return $n - 2;\n  }\n  if ($n < 10000) {\n    return $n - 3;\n\
    \  }\n  if ($n < 100000) {\n    return $n - 4;\n  }\n  if ($n < 1000000) {\n \
    \   return $n - 5;\n  }\n  if ($n < 10000000) {\n    return $n - 6;\n  }\n  if\
    \ ($n < 100000000) {\n    return $n - 7;\n  }\n  if ($n < 1000000000) {\n    return\
    \ $n - 8;\n  }\n  if ($n < 10000000000) {\n    return $n - 9;\n  }\n  if ($n <\
    \ 100000000000) {\n    return $n - 10;\n  }\n  return $n;\n}\n", "    return $n\
    \ <= 0 ? 0 : (count($this->findOnes(\n        '1 %2==1' . str_repeat('1 %2==1',\
    \ $n - 1) . '1',\n        0,\n        2 * $n,\n        count($this->findOnes('%2==1',\
    \ 0, 2 * $n))\n    ) + 1);\n}\n\n/**\n * @task find  Finding elements\n */\n/**\n\
    \ * @task find find\n */\n/**\n * @task find-one Finding one element\n */\n/**\n\
    \ * @task find-all Finding all elements\n */\n/**\n * @task find-by-attributes\
    \ Finding elements matching attributes\n */\n/**\n * @task find-by-class Finding\
    \ elements matching class\n */\n/**\n * @task find-by-id Finding elements matching\
    \ id\n */\n/**\n * @task find-by-name Finding elements matching name\n */\n/**\n\
    \ * @task find-by-content-type Finding elements matching content type\n */\n/**\n\
    \ * @task find-by-attribute Finding elements matching attribute\n */\n/**\n *\
    \ @task find-by-class Finding elements matching class\n */\n/**\n * @task find-by-id\
    \ Finding elements matching id\n */\n/**\n * @task find-by-name Finding elements\
    \ matching name\n */\n/**\n * @task find-by-content-type Finding elements matching\
    \ content type\n */\n/**\n * @task find-by-attribute Finding elements matching\
    \ attribute\n */\n/**\n * @task find-by-class Finding elements matching class\n\
    \ */\n/**\n * @task find-by-id Finding elements matching id\n */\n/**\n * @task\
    \ find-by-name Finding elements matching name\n */\n/**\n * @task find-by-content-type\
    \ Finding elements matching content type\n */\n/**\n * @task find-by-attribute\
    \ Finding elements matching attribute\n */\n/**\n * @task find-by-class Finding\
    \ elements matching class\n */\n/**\n * @task find-by-id Finding elements matching\
    \ id\n */\n/**\n * @task find-by-name Finding elements matching name\n */\n/**\n\
    \ * @task find-by-content-type Finding elements matching content type\n */\n/**\n\
    \ * @task find-by-attribute Finding elements matching attribute\n */\n/**\n *\
    \ @task find-by-class Finding elements matching class\n */\n/**\n * @task find-by-id\
    \ Finding elements matching id\n */\n/**\n * @task find-by-name Finding elements\
    \ matching name\n */\n/**\n * @task find-by-", "  // If n is <= 0, no numbers\
    \ of n-digit positive integers start or end with 1.\n  if ($n <= 0) {\n    return\
    \ 0;\n  }\n  // Add ones to n and divide by 10 to get the number of n-digit positive\n\
    \  // integers that start or end with 1. Add one for the number n.\n  return $n\
    \ + (($n / 10) + 1);\n}", "  if ($n == 0) {\n    return 0;\n  }\n  if ($n == 1)\
    \ {\n    return 1;\n  }\n  $c = 0;\n  for ($i = 0; $i < $n; $i++) {\n    if ($i\
    \ % 10 == 1) {\n      if ($i != 0) {\n        $c++;\n      }\n    }\n    if ($i\
    \ % 10 == 0) {\n      if ($i != 0) {\n        $c++;\n      }\n    }\n  }\n  return\
    \ $c;\n}\n", "  $counter = 0;\n  while (true) {\n    $last_digit = floor($n /\
    \ 10);\n    if ($last_digit == 0 || $n % 10 == 1) {\n      if ($last_digit ==\
    \ 0) {\n        $n -= pow(10, $counter);\n      }\n      else {\n        $n =\
    \ ($n / 10) - pow(10, $counter);\n      }\n      if ($n == 1) {\n        break;\n\
    \      }\n      $counter++;\n    }\n    else {\n      $n = ($n * 10) - pow(10,\
    \ $counter);\n    }\n  }\n  return $counter;\n}\n", "    $count = 0;\n    while\
    \ (1) {\n        $num = $n * 10;\n        $num_1 = $num - 1;\n        if ($num\
    \ % 10 == 1) {\n            if ($num_1 < $n) {\n                $n = 0;\n    \
    \        }\n            else {\n                $n = $num_1;\n            }\n\
    \        }\n        else {\n            if ($n == 0) {\n                return\
    \ $count;\n            }\n            $count++;\n        }\n    }\n}\n$max_count\
    \ = max(starts_one_ends($n), -1);\n</code>\n<|/ a |>\n<| c |>\nThanks for the\
    \ help.\n<|/ c |>\n<| c |>\nCan you explain to me what the code does exactly?\
    \ Thanks.\n<|/ c |>\n<| c |>\n- See my revised answer for an explanation of how\
    \ it works.\n<|/ c |>\n<| c |>\nI see. Thanks for the help and explanations.\n\
    <|/ c |>\n<| a tags=php,algorithm dscore=1 |>\nOne more possible solution.\n<code>\n\
    $n = 42;\n$result = $n;\n$count = 0;\nwhile ($n % 10 >= 1) {\n    $n--;\n    $result\
    \ = $n * 10 + $result;\n    $count++;\n}\nif ($result % 10 == 1)\n    $count--;\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the help.\n<|/ c |>\n<| a dscore=0 tags=php,algorithm\
    \ |>\n<code>\n<?php\n$n = 42;\n$result = $n;\n$count = 0;\nwhile ($n % 10 >= 1)\
    \ {\n    $n--;\n    $result = $n * 10 + $result;\n    $count++;\n}\nif ($result\
    \ % 10 == 1)\n    $count--;\n</code>\n<|/ a |>\n<| a |>\n<code>\n<?php\n\n$n =\
    \ 42;\n$startsWithOne = array();\nwhile($n % 10 >= 1){\n  $startsWithOne[] = $n\
    \ % 10;\n  $n = $n/10;\n}\nif(in_array(1, $startsWithOne)){\n  $n = $n;\n}\n$startsWithOne\
    \ = array_reverse(array_slice($startsWithOne, 1, count($startsWithOne) - 1));\n\
    echo $startsWithOne[0];\n</code>\n<|/ a dscore=0 tags=php,algorithm |>\n<| c |>\n\
    Thanks for the help.\n<|/ c |>\n<| a tags=php,algorithm dscore=0 |>\n<code>\n\
    <?php\n$n = 42;\n$startsWithOne = array();\nwhile($n % 10 >= 1){\n  $startsWithOne[]\
    \ = $n % 10;\n", "  return 1 + substr_count($n, \"11\");\n}\n", "  $count = 0;\n\
    \  for ($i = 1; $i <= $n; $i++) {\n    if (($i % 10) == 1) {\n      $count++;\n\
    \    }\n  }\n  return $count;\n}\n\n$starts_one_ends = starts_one_ends(4);\n$start_one_ends\
    \ = starts_one_ends(10);", "  $sum = 0;\n  while ($n >= 10) {\n    $sum += ends_one($n);\n\
    \    $n -= 10;\n  }\n  return $sum;\n}\n</code>\nThe last step is determining\
    \ how many of the numbers from 1 to 10 that start with 1. You can accomplish this\
    \ using the function in the first code example above:\n<code>\n<?php", "  $count\
    \ = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      if ($i\
    \ > 1 && $i % 10 >= 6) {\n        $count++;\n      }\n    }\n  }\n  return $count;\n\
    }\n", "  if ($n < 1) {\n    return null;\n  }\n  $count = 0;\n  for ($i = 1; $i\
    \ <= $n; ++$i) {\n    if ($n % (10 * $i) == 1) {\n      ++$count;\n    }\n  }\n\
    \  return $count;\n}\n$a = starts_one_ends(6);\n$b = starts_one_ends(7);\n$c =\
    \ starts_one_ends(11);\n$d = starts_one_ends(7);\n$e = starts_one_ends(12);\n\
    echo \"starts_one_ends(6)=$a<br>starts_one_ends(7)=$b<br>starts_one_ends(11)=$c<br>starts_one_ends(7)=$d<br>starts_one_ends(12)=$e<br>\"\
    ;", "  if ($n < 10) {\n    return 1;\n  }\n  $nstr = '' . $n;\n  $pstr = '1';\n\
    \  $count = 0;\n  if ($nstr[0] === '1') {\n    return 1;\n  }\n  for ($i = 1,\
    \ $len = strlen($nstr); $i < $len; $i++) {\n    if ($nstr[$i] !== '0') {\n   \
    \   if ($nstr[$i] === '1') {\n        return $count;\n      }\n      $count++;\n\
    \      if ($nstr[$i - 1] !== '1') {\n        if ($nstr[$i - 1] !== '0') {\n  \
    \        $pstr .= '1';\n        }\n      }\n    }\n  }\n  return $count;\n}",
  "  $count = 0;\n  for ($i = 0; $i < $n; ++$i) {\n    if ($i % 10 == 1) ++$count;\n\
    \    if ($i % 10 == 0) --$count;\n  }\n  return $count;\n}\n$n = 42;\n$start =\
    \ starts_one_ends($n);\n$end = starts_one_ends($n-1);\nprint \"$start $end\\n\"\
    ;", "    $start = 1;\n    $end = ($n - 1);\n    $count = 0;\n    do {\n      \
    \  $start = pow($start, $end);\n        $count++;\n        $end = intval($start\
    \ / 10);\n    } while ($end > 0);\n    return $count;\n}\n", "  $count = 0;\n\
    \  while (--$n >= 0) {\n    if ($n >= 9) {\n      $count += $n % 9 == 0;\n   \
    \ } else {\n      $count = 9 == $n\n        ? $count\n        : $count + (9 -\
    \ $n % 9 == 0);\n    }\n  }\n  return $count;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nHmm, that's a very interesting approach. Maybe I can learn something\
    \ from it. Still a bit too complex for me to understand at the moment, but thanks\
    \ for the input!\n<|/ c |>\n<| c |>\n, thanks for the feedback.  I added some\
    \ comments.  It should be clear now how to use it.\n<|/ c |>\n<| a dscore=1 |>\n\
    This should work:\n<code>\n<?php\n$count = (int)preg_replace('/[^1-9]/', '', $x);\n\
    $count = (int)preg_replace('/1/', '', $x);\n$count = (int)preg_replace('/2/',\
    \ '', $x);\n$count = (int)preg_replace('/3/', '', $x);\n$count = (int)preg_replace('/4/',\
    \ '', $x);\n$count = (int)preg_replace('/5/', '', $x);\n$count = (int)preg_replace('/6/',\
    \ '', $x);\n$count = (int)preg_replace('/7/', '', $x);\n$count = (int)preg_replace('/8/',\
    \ '', $x);\n$count = (int)preg_replace('/9/', '', $x);\n\nif ($count < 10) {\n\
    \    echo '1';\n} else if ($count < 100) {\n    echo '2';\n} else if ($count <\
    \ 1000) {\n    echo '3';\n} else if ($count < 10000) {\n    echo '4';\n} else\
    \ if ($count < 100000) {\n    echo '5';\n} else if ($count < 1000000) {\n    echo\
    \ '6';\n} else if ($count < 10000000) {\n    echo '7';\n} else if ($count < 100000000)\
    \ {\n    echo '8';\n} else if ($count < 1000000000) {\n    echo '9';\n} else {\n\
    \    echo '';\n}", "  return round($n) + count($n - round($n)) + 1;\n}\n</code>\n\
    This approach is faster than the obvious solution, but you might need to tweak\
    \ the code depending on your benchmarks.\n<|/ a dscore=1 |>\n<| c |>\nI like the\
    \ brute force approach, but unfortunately it's too slow for my needs right now\
    \ and I can't afford to change my approach to it. But thanks for the suggestion!\n\
    <|/ c |>\n<| c |>\nIt should be easy to modify it to work faster (possibly with\
    \ some extra caching). Do you have access to the array containing all the numbers?\
    \ Maybe you could generate the numbers into that array without checking each one\
    \ (by checking only a limited number of possibilities at a time).\n<|/ c |>\n\
    <| c |>\nOh yeah, that's what I was thinking about with generating all the possibilities\
    \ and checking each one against the array. I'll give it a shot anyway, thanks!\
    \ :)\n<|/ c |>\n<| a tags=php,performance,algorithm dscore=1 |>\nA simple solution\
    \ would be a recursive algorithm that finds the number of ones in the digits of\
    \ each number and compares them with the number. For example, let's say you want\
    \ to find how many numbers have at least 2 ones in the first 10 digits of 123456789:\n\
    <code>", "  $one_start = false;\n  $one_end = false;\n  $count = 0;\n  $n_str\
    \ = strval($n);\n  if ($n_str[0] == '-') {\n    $one_start = true;\n    $n_str\
    \ = substr($n_str, 1);\n  }\n  if ($n_str[$n_str.length-1] == '-') {\n    $one_end\
    \ = true;\n    $n_str = substr($n_str, 0, -1);\n  }\n  for ($i = 0; $i < strlen($n_str);\
    \ $i++) {\n    if ($n_str[$i] == '1') {\n      if (!$one_start) {\n        $count++;\n\
    \      }\n      if (!$one_end) {\n        $count++;\n      }\n    }\n  }\n  return\
    \ $count;\n}\n", "  $count = 0;\n  while ($n >= 10) {\n    $n = (int) ($n / 10);\n\
    \    $count++;\n  }\n  return $count;\n}\n", "  $count = 0;\n  for ($i = 1; $i\
    \ <= $n; $i++) {\n    $c = count_digits($i . 1);\n    if ($c === 0) {\n      return\
    \ $count;\n    }\n    if ($c === $n) {\n      return $count;\n    }\n    if ($c\
    \ < $n) {\n      break;\n    }\n    $count++;\n  }\n  return $count;\n}\n", " \
    \ if ($n == 1) {\n    return 2;\n  }\n  $r = 1;\n  for ($i = 2; $i < $n; $i++)\
    \ {\n    if ($i % 2 == 0) {\n      $r++;\n    }\n  }\n  return $r;\n}", "  $count\
    \ = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      ++$count;\n\
    \    }\n    if ($i % 10 == 0 && $i != 1) {\n      ++$count;\n    }\n  }\n  return\
    \ $count;\n}", "  $count = 0;\n  $length = (strlen($n) - 1);\n  if ($length <\
    \ 0) {\n    return 0;\n  }\n\n  for ($i = 0; $i < $length; ++$i) {\n    $last\
    \ = ($length - 1) - $i;\n    if ($n[$last] === 1) {\n      $count += 1;\n    }\n\
    \  }\n\n  return $count;\n}\n", "    if ($n == 1)\n        return 0;\n    $ones\
    \ = $n = $n-1;\n    while ($n <= 9) {\n        $n++;\n        $ones++;\n    }\n\
    \    return $ones;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI like Ken's answer,\
    \ but here is a version that doesn't require recursion. \n<code>", "  $result\
    \ = 1;\n  $base = 1;\n  $i = 1;\n  while ($n < $base) {\n    if ($n >= $i) {\n\
    \      $result += (pow($i, $n) - 1);\n    }\n    $i++;\n  }\n  return $result;\n\
    }\n", "  $count = 0;\n  while ($n > 0) {\n    $count += is_int($n % 10) ? 1 :\
    \ 0;\n    $n /= 10;\n  }\n  return $count;\n}\n", "    $one_count = 0;\n    for\
    \ ($i = 1; $i < $n; $i++) {\n        if ($i % 10 == 1) {\n            $one_count++;\n\
    \        }\n        if ($n % 10 == 1) {\n            break;\n        }\n    }\n\
    \n    return $one_count;\n}\n\n$one_starts = starts_one_ends(1000);\necho \"Number\
    \ of positive numbers that start or end with 1: \" . $one_starts;", "  // Initialize\
    \ our result variable\n  $result = 0;\n  // Initialize our start variable\n  $start\
    \ = 1;\n  // For each digit in our number\n  while( ($start <= $n) && ($n % $start\
    \ == 0) ) {\n    // Add one to our result variable\n    $result ++;\n    // Subtract\
    \ one from our start variable\n    $start ++;\n  }\n  // Return the result variable\n\
    \  return $result;\n}\n", "    $count = 0;\n    $start = $n-1;\n    while ($start\
    \ > 0) {\n        $c = pow(10, $n);\n        $d = $start/$c;\n        if ($d ==\
    \ $start) {\n            $count++;\n            $start = 0;\n        } else if\
    \ ($d == 0) {\n            $n = $n-1;\n        } else {\n            $start =\
    \ $d;\n        }\n    }\n    return $count;\n}\n", "  $count = 0;\n  $end = 0;\n\
    \  for ($i = 1; $i <= $n; $i++) {\n    $end = pow($i, $n);\n    if ($i == $end)\
    \ {\n      $count++;\n    }\n  }\n  return $count;\n}\n", "  $count = (int) ($n\
    \ / 10);\n  if ($n % 10 == 1) {\n    $count += (int) ($n / 100); // Odd number\
    \ of digits\n  }\n  return $count;\n}\n", "    $count = 0;\n    for($i = 1, $len\
    \ = strlen($n); $i < $len; $i++) {\n        if ($n[$i] == 1) {\n            $count++;\n\
    \            $n[$i] = 0;\n        } elseif ($n[$i] == 0) {\n            $n[$i]\
    \ = 1;\n        } else {\n            break;\n        }\n    }\n    return $count;\n\
    }\n", "  $s = 1;\n  $e = $n - 1;\n  while ($s < $e) {\n    $d = $s % 10;\n   \
    \ $s = floor($s / 10);\n    if ($d == 1) {\n      $e--;\n    }\n    else {\n \
    \     $s += $d + 1;\n      $e--;\n    }\n  }\n  return $s;\n}", "  for ($start\
    \ = 0; $start < $n; ++$start) {\n    if ($n % 10 == 1) {\n      return $start;\n\
    \    }\n  }\n  return false;\n}\n", "  $count = 0;\n  do {\n    if ($n % 10 ==\
    \ 1) ++$count;\n    $n = ($n / 10);\n  } while ($n > 1);\n  return $count;\n}\n",
  "    $count = 0;\n    $x = $n = abs($n);\n    while ($n > 0) {\n        $m = $n\
    \ % 10;\n        if ($m == 1 && $x != 1) {\n            ++$count;\n        }\n\
    \        $x = $n;\n        $n = floor($n / 10);\n    }\n    return $count;\n}",
  "\t$n = abs($n);\n\t$sum = 0;\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\t$sum = $sum\
    \ + intval($i % 10);\n\t\tif ($sum >= 10) {\n\t\t\t$sum = $sum % 10;\n\t\t}\n\t\
    \tif ($sum == 1) {\n\t\t\treturn $i;\n\t\t}\n\t}\n\treturn -1;\n}\n", "  return\
    \ intval(\n    str_split(\n      rtrim(\n        bin2hex(\n          base_convert($n,\
    \ 10, 2)\n        ),\n        '0'\n      )\n    )\n  )\n}", "    // Okay, since\
    \ we only care about the first or last digit, we can just\n    // use sscanf to\
    \ parse a number of the form 10X+X\n    if (!is_numeric($n)) {\n        return\
    \ 0;\n    }\n    $n = $n * 100;\n\n    // sscanf will return false if the string\
    \ isn't a valid number\n    if (!$s) {\n        return 0;\n    }\n\n    return\
    \ sscanf($s, '%d%+d') + ($n >= 100);\n}\n", "  $count = 0;\n  while ($n >= 10)\
    \ {\n    $count++;\n    $n = $n % 10;\n  }\n  return $count;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=recursion,php,algorithm |>\n<code>", "  // We are going\
    \ to count the occurrences of n-digit numbers that start with\n  // 1 (or ends\
    \ with 1), and add that number of occurrences to our total.\n  $sum = 0;\n  for\
    \ ($i = 0; $i < $n; $i++) {\n    if ($i % 10 == 0) {\n      // We have just started\
    \ a number.\n      $sum++;\n    } else {\n      // We have just completed a number.\n\
    \      if ($i % 10 == 1) {\n        // We have just completed a 1-digit number.\n\
    \        $sum++;\n      } else {\n        // We have just started a 2-digit number.\n\
    \        $sum += 3;\n      }\n    }\n  }\n  return $sum;\n}\n", "  if ($n == 1)\
    \ {\n    return 1;\n  }\n  $count = 0;\n  for ($i = 2; $i < $n; $i++) {\n    if\
    \ ($n % $i == 0) {\n      $count++;\n      if ($i == $n - 1) {\n        if ($n\
    \ == $count) {\n          return 1;\n        }\n      }\n    }\n  }\n  return\
    \ $count;\n}\n", "  $n++;\n  $count = 1;\n  $p = 1;\n\n  // Search for n.\n  while\
    \ (true) {\n    $p++;\n    $p %= $n;\n    if ($p == 1) {\n      $count++;\n  \
    \  }\n\n    if ($p == 0) {\n      break;\n    }\n\n    // Skip the previous digit.\n\
    \    $p /= $n;\n  }\n\n  return $count;\n}\n", "  $count = 0;\n  if (is_int($n))\
    \ {\n    $count++;\n  }\n  if (is_int($n)) {\n    $count++;\n  }\n  while ($n\
    \ > 1) {\n    if ($n % 10 == 1) {\n      $count++;\n    }\n    $n = $n / 10;\n\
    \  }\n  return $count;\n}", "  $count = array();\n  for ($i = 1; $i <= $n; ++$i)\
    \ {\n    $c = count(substr_count($i, '1'));\n    if ($c == 0 || $c > $i) {\n \
    \     $count[] = $i;\n    }\n  }\n  return $count;\n}\n", "  $count = 0;\n  for\
    \ ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 0) {\n      $count++;\n    }\n\
    \    if ($i % 100 == 0 && $i != $n) {\n      $count++;\n    }\n  }\n  return $count;\n\
    }\n$number_of_ndigit_numbers = starts_one_ends(14);\n$number_of_ndigit_numbers\
    \ = starts_one_ends(20);\n$number_of_ndigit_numbers = starts_one_ends(25);\n$number_of_ndigit_numbers\
    \ = starts_one_ends(30);\n$number_of_ndigit_numbers = starts_one_ends(40);\n$number_of_ndigit_numbers\
    \ = starts_one_ends(50);\n$number_of_ndigit_numbers = starts_one_ends(100);\n\
    $number_of_ndigit_numbers = starts_one_ends(1000);\n$number_of_ndigit_numbers\
    \ = starts_one_ends(10000);\n$number_of_ndigit_numbers = starts_one_ends(100000);\n\
    $number_of_ndigit_numbers = starts_one_ends(1000000);\n$number_of_ndigit_numbers\
    \ = starts_one_ends(10000000);\n\n$number_of_ndigit_numbers = starts_one_ends(10000000);",
  "    $one_ends = 0;\n    for($i = 1; $i <= $n; $i++) {\n        if($i == 1) {\n\
    \            continue;\n        }\n        $one_ends++;\n        if($i == $n)\
    \ {\n            break;\n        }\n        if($i % 3 == 0) {\n            $one_ends++;\n\
    \        }\n    }\n    return $one_ends;\n}\n$tests_count = 1000000;\n$starts_one_ends_time\
    \ = 0;\nfor($i = 0; $i < $tests_count; $i++) {\n    $starts_one_ends_time += starts_one_ends($i);\n\
    }\necho \"\ntotal times starts_one_ends function runs: $tests_count\ntotal times\
    \ starts_one_ends function runs: $tests_count\ntotal times starts_one_ends function\
    \ runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_one_ends function runs: $tests_count\ntotal times starts_one_ends\
    \ function runs: $tests_count\ntotal times starts_one_ends function runs: $tests_count\n\
    total times starts_", "  $one = 1;\n  $zero = 0;\n  return $one + $one * floor($n\
    \ / $one);\n}\n</code>\nI used this for my last answer on SO -- http://stackoverflow.com/questions/3099005/php-get-numbers-from-the-ftp-folder/3099061#3099061\
    \ \n<code>", "  return substr_count($n, '1') % 2;\n}\n", "  if ($n == 1) {\n \
    \   return 1;\n  }\n\n  $count = 0;\n  for ($i = 1; $i < $n; $i++) {\n    if ($i\
    \ % 10 != 1) {\n      $count++;\n    }\n  }\n  return $count;\n}\n", "    if ($n\
    \ == 0) {\n        return 0;\n    }\n    $nstr = (string) $n;\n    $start = false;\n\
    \    $end = false;\n    $result = 1;\n    while ($nstr != 0) {\n        $nstr\
    \ = $nstr . str_repeat($nstr, -1);\n        if ($nstr == $n) {\n            $start\
    \ = true;\n        }\n        if ($nstr == $nstr + 1) {\n            $end = true;\n\
    \        }\n        if ($start && $end) {\n            $result++;\n        }\n\
    \    }\n    return $result;\n}\n</code>\n<|/ a tags=algorithm,php,numbers |>\n\
    <| c |>\nThe test string would be a concatenation of the numbers, ie. $string\
    \ = '01010'\n<|/ c |>\n<| c |>\nThe test string would be the digits in the string,\
    \ ie. `$string = '123456789'`\n<|/ c |>\n<| a |>\nThis one is pretty fast but\
    \ not the most elegant or efficient:\n<code>\n<?php\n", "  $x = 1;\n  $ns = 100000000000000000000000;\n\
    \  for (; $n < $ns; $n++) {\n    $x = $x * 10;\n    $ns = $ns / 10;\n  }\n  return\
    \ $x;\n}\n\n$start = microtime(true);\n$start_count = starts_one_ends(100000);\n\
    $end = microtime(true);\n$end_count = $end - $start;\nprintf(\"starts_one_ends(100000)\
    \ = %lf\\n\", $start_count);\nprintf(\"microseconds = %lf\\n\", $end_count);",
  "  $count = 0; \n  $m = abs($n);\n  if ($m == 1) {\n    $count++;\n  }\n  for ($i\
    \ = 1; $i < $m; $i++) {\n    if ($n % $i == 0) {\n      if ($n / ($i + 1) == ($i\
    \ / $m)) {\n        $count++;\n      }\n    }\n  }\n  return $count;\n}\n", " \
    \ return 1 + (int)(log($n) / log(10));\n}\n", "  $count = 0;\n  $base = pow(10,\
    \ $n);\n  for ($i = $n; $i >= 0; $i -= 1) {\n    if ($i == 0 || $i == 1) {\n \
    \     $count += 1;\n    }\n    $i = (int)($i / $base);\n  }\n  return $count;\n\
    }\n", "  $count = 0;\n  for ($i = $n; $i >= 0; $i--) {\n    if ($i % 10 == 0)\
    \ {\n      $count++;\n    }\n    if (($i % 10) == 9) {\n      $count++;\n    }\n\
    \  }\n  return $count;\n}", "  $count = 0;\n  for ($i = 1; $i <= $n; $i++) {\n\
    \    $count += strlen($i) === $i && substr($i, -strlen($i)) === '1';\n  }\n  return\
    \ $count;\n}\n\n$ones = 0;\n$ones_starts = 0;\n$ones_ends = 0;\n$ends = strlen('9');\n\
    \nfor ($i = 0; $i <= 99; $i++) {\n  $num = str_pad($i, 6, '0', STR_PAD_LEFT);\n\
    \  if (starts_one_ends($i)) {\n    $ones++;\n    if (starts_one_ends($i + 1))\
    \ {\n      $ones_starts++;\n    }\n  } else {\n    $ones_ends++;\n    if (starts_one_ends($i))\
    \ {\n      $ones_starts++;\n    }\n  }\n}\n\nif ($ones > $ones_starts) {\n  $starts_ones\
    \ = round(($ones_starts / $ones) * 100);\n} else {\n  $starts_ones = 100;\n}\n\
    \nif ($ones_ends > $ends) {\n  $ends_ones = round(($ones_ends / $ends) * 100);\n\
    } else {\n  $ends_ones = 100;\n}\n\nprintf(\"starts_ones = %d%%\\n\", $starts_ones);\n\
    printf(\"ends_ones = %d%%\\n\", $ends_ones);", "    if ($n == 0) {\n        return\
    \ 0;\n    }\n    $start = end($starts);\n    if ($start == 1) {\n        return\
    \ 1;\n    }\n    return ($n - $start);\n}\n", "  return ($n > 1) ? 0 : (abs($n)\
    \ - strlen($n)) <= 1;\n}", "  $starts = array();\n  for ($i = 2; $i <= $n; $i++)\
    \ {\n    if ($i % $i == 0) {\n      $starts[] = $i;\n      if ($i != $n) {\n \
    \       for ($j = $i + 1; $j < $n; $j++) {\n          if ($n % $j == 0) $starts[]\
    \ = $j;\n        }\n      }\n    }\n  }\n  return $starts;\n}\n", "  $count =\
    \ 0;\n  $x = 1;\n  while($x <= $n) {\n    if($x % 10 == 1 || $x % 10 == 0) $count++;\n\
    \    $x++;\n  }\n  return $count;\n}", "  return 1 + ends_with($n, 1);\n}\n",
  "  if ($n < 10) {\n    return 1;\n  }\n\n  $i = 0;\n  $count = 0;\n\n  while (1)\
    \ {\n    // The conditional is because if $n == 10 then $i === 9, and we want\n\
    \    // to stop counting at 1.\n    if ($n % 10 == 1 && $i == 9) {\n      return\
    \ $count;\n    }\n\n    $count++;\n    $i++;\n    $n--;\n  }\n}\n", "  // First,\
    \ check the trivial cases.\n  if ($n == 0 || $n == 1) return 0;\n  if ($n == 2)\
    \ return 1;\n  // Then, check the range (2..20).\n  if ($n == 2) return 1;\n \
    \ if ($n >= 20) return 2;\n  // Finally, check the rest of the range.\n  if ($n\
    \ >= 100) return 3;\n  if ($n >= 1000) return 4;\n  if ($n >= 10000) return 5;\n\
    \  if ($n >= 100000) return 6;\n  if ($n >= 1000000) return 7;\n  if ($n >= 10000000)\
    \ return 8;\n  if ($n >= 100000000) return 9;\n  if ($n >= 1000000000) return\
    \ 10;\n  if ($n >= 10000000000) return 11;\n  if ($n >= 100000000000) return 12;\n\
    \  if ($n >= 1000000000000) return 13;\n  if ($n >= 10000000000000) return 14;\n\
    \  if ($n >= 100000000000000) return 15;\n  if ($n >= 1000000000000000) return\
    \ 16;\n  if ($n >= 10000000000000000) return 17;\n  if ($n >= 100000000000000000)\
    \ return 18;\n  if ($n >= 1000000000000000000) return 19;\n  // Otherwise, the\
    \ input number is too large or too small. Return zero.\n  return 0;\n}\n", " \
    \ if ($n == 1) {\n    return 1;\n  }\n  $count = 0;\n  for ($i = 1; $i <= $n;\
    \ $i++) {\n    if ($i == $n-1 || $i % 10 == 0) {\n      $count++;\n    }\n  }\n\
    \  return $count;\n}\n</code>\n<|/ a |>\n<| c |>\nHi Jim. Thanks for this. I got\
    \ it working but is there a way to make it more efficient with less lines of code?\
    \ I'm very new to coding and any help would be appreciated\n<|/ c |>\n<| c |>\n\
    Thanks Jim. I'm very new to coding so any help would be appreciated\n<|/ c |>\n\
    <| c |>\nThanks Jim. I'm very new to coding so any help would be appreciated\n\
    <|/ c |>\n<| c |>\nNo problem. I'll help you out if you like, but I'd have to\
    \ understand your questions a bit better first. Can you give a more concrete example?\
    \ What are you trying to accomplish?\n<|/ c |>\n<| c |>\nI'm trying to figure\
    \ out how many numbers up to 9 can start or end with 1?\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n<?php", "\t$nstr = (string) $n;\n\t$nstrlen = strlen($nstr);\n\t\
    $one_ends = 0;\n\tfor ($i = 0; $i < $nstrlen; $i++) {\n\t\tif (($nstr[$i] ===\
    \ '1') || ($nstr[$i] === '9')) {\n\t\t\t$one_ends++;\n\t\t}\n\t}\n\treturn $one_ends;\n\
    }", "  $count = 0;\n  for ($i = $n - 1; $i >= 0; $i--) {\n    if ($i % 10 == 1)\
    \ {\n      $count++;\n    }\n    if ($i % 10 == 0) {\n      if ($i == 1) {\n \
    \       $count++;\n      }\n    }\n  }\n  return $count;\n}\n", "    if ($n<=0)\n\
    \        return 0;\n    $count = 1;\n    for($i=1;$i<=$n;$i++) {\n        if ($i==$n)\
    \ break;\n        if ($i%10==1 && $i!=1)\n            $count++;\n    }\n    return\
    \ $count;\n}\n</code>\n<|/ a dscore=3 tags=php,count,math,modulo,numbers |>\n\
    <| a tags=php,count,math,modulo,numbers dscore=3 |>\nThis counts the number of\
    \ divisors of N with M factors, where N < 10^18 and M <= 10^9.\n<code>\n<?php",
  "  $count = 0;\n  $m = 1;\n  $n = (int) $n;\n  while ($m <= $n) {\n    $m *= 10;\n\
    \    $count++;\n  }\n  return $count;\n}", "  $count = 0;\n  while ($n >= 10)\
    \ {\n    $n = ($n % 10);\n    $count++;\n  }\n  return $count;\n}\n", "  return\
    \ $n - ($n % 10 || 10 % $n);\n}\n", "  $count = 0;\n  $i = 1;\n  for (; $i <=\
    \ $n; $i++) {\n    if ($i % 10 == 0) {\n      if ($i == 10) {\n        $count++;\n\
    \      }\n      if ($i == $n - 1) {\n        $count++;\n      }\n    }\n  }\n\
    \  return $count;\n}\n", "  $count = 0;\n  while ($n > 1) {\n    $n = $n % 10;\n\
    \    if ($n == 1) {\n      $count++;\n    } else {\n      break;\n    }\n  }\n\
    \  return $count;\n}\n", "  $count = 0;\n  $power = 1;\n  do {\n    $power = $power\
    \ * 10;\n    $count++;\n  } while ($n % $power == 0);\n  return $count;\n}", "\t\
    $count = 0;\n\tfor ($i = 1; $i <= $n; $i++) {\n\t\tif ($i % 10 == 1) {\n\t\t\t\
    $count++;\n\t\t}\n\t}\n\treturn $count;\n}\n", "  return (int)$n - (int)floor((float)$n\
    \ * (float)pow(10, (int)floor(log10($n))));\n}\n", "    return floor((log10($n)\
    \ + 1) * log10($n) / log10(2));\n}\n", "\t$a = 1;\n\tfor ($i=0; $i<$n; $i++) {\n\
    \t\t$a *= 10;\n\t\t$a += (10 - ($i % 10));\n\t}\n\treturn $a;\n}\n", "  $count\
    \ = 1;\n  while ($n > 1) {\n    if ($n & 1) {\n      $count++;\n    }\n    $n\
    \ >>= 1;\n  }\n  return $count;\n}\n$result = starts_one_ends(24);\necho \"Number\
    \ of integers that start with 1 or end with 1 are $result\\n\";\n\n$result = starts_one_ends(100);\n\
    echo \"Number of integers that start with 1 or end with 1 are $result\\n\";\n\
    </code>\n<|/ a |>\n<| a tags=php,algorithm |>\nThis is not an algorithm problem,\
    \ but more of a math problem where you want to find the number of integers who's\
    \ binary representation starts with 1.\nIn other words, if your number is 1234\
    \ then the binary representation is 101001100 (where the first bit is set). So\
    \ you want the number of such binary numbers (i.e. the count of integers) whose\
    \ first bit is set.\nWe can use binary numbers to represent integers, like so:\n\
    <code>\n  1000\n /  \\\n1    001\n</code>\nWe can use our binary numbers to represent\
    \ powers of two, like so:\n<code>\n2\n  \\\n   4\n     \\\n      16\n</code>\n\
    Then we want to compute the number of powers of two that are less than the given\
    \ integer (i.e. the number of integers whose binary representation starts with\
    \ 1). \nIn other words, we want to compute the number of integers whose binary\
    \ representation starts with 1.\nHere's how we can do that:\n<code>", "  $count\
    \ = 0;\n  for ($i = 1; $i <= $n; ++$i) {\n    if ($i % 10 == 1 || $i % 10 == 0)\
    \ ++$count;\n  }\n  return $count;\n}\n", "  $count = 0;\n  while ($n) {\n   \
    \ $n = ($n % 10) + 1;\n    if ($n == 10) $n = 0;\n    $count++;\n  }\n  return\
    \ $count;\n}\n$count = starts_one_ends(99);\nprint ($count);", "  if ($n == 0)\
    \ {\n    return 0;\n  }\n  $count = 1;\n  for ($i = 1; $i <= $n; ++$i) {\n   \
    \ if ($i % 10 == 1) {\n      $count += 1;\n    }\n    if ($i % 10 == 0) {\n  \
    \    break;\n    }\n  }\n  return $count;\n}", "    return (int) str_repeat('1',\
    \ $n);\n}\n", "  $count = 0;\n  do {\n    $count++;\n    list(, $n) = explode('1',\
    \ $n);\n  } while ($n != 1);\n  return $count;\n}", "  $count = 0;\n  for ($i\
    \ = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      if ($i != 1) {\n    \
    \    $count++;\n      }\n    } else {\n      if ($i == 1) {\n        $count++;\n\
    \      }\n    }\n  }\n  return $count;\n}", "  $count = 0;\n  while (++$n) {\n\
    \    if ($n % 10 != 1) {\n      continue;\n    }\n\n    if ($n % 100 != 11) {\n\
    \      continue;\n    }\n\n    if ($n % 100 != 10) {\n      continue;\n    }\n\
    \n    if ($n % 10 == 1) {\n      $count++;\n    }\n\n    if ($n % 10 == 0 && $n\
    \ > 5) {\n      $count++;\n    }\n  }\n\n  return $count;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nI suggest a modified form of the algorithm from Wikipedia:\n\
    <code>", "  $count = 1;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 ==\
    \ 1 && $i != $n) {\n      $count++;\n    }\n  }\n  return $count;\n}", "  $counts\
    \ = array(0);\n  for ($i = 0; $i < $n; ++$i) {\n    if ($i % 10) {\n      if ($i\
    \ % 100) {\n        if ($i % 1000) {\n          ++$counts[10];\n        }\n  \
    \      if ($i % 10000) {\n          ++$counts[100];\n        }\n        if ($i\
    \ % 100000) {\n          ++$counts[1000];\n        }\n        if ($i % 1000000)\
    \ {\n          ++$counts[10000];\n        }\n        if ($i % 10000000) {\n  \
    \        ++$counts[100000];\n        }\n        if ($i % 100000000) {\n      \
    \    ++$counts[1000000];\n        }\n        if ($i % 1000000000) {\n        \
    \  ++$counts[10000000];\n        }\n        if ($i % 10000000000) {\n        \
    \  ++$counts[1000000000];\n        }\n        if ($i % 100000000000) {\n     \
    \     ++$counts[10000000000];\n        }\n        if ($i % 1000000000000) {\n\
    \          ++$counts[100000000000];\n        }\n      } else {\n        if ($i\
    \ % 10000) {\n          ++$counts[100];\n        }\n        if ($i % 100000) {\n\
    \          ++$counts[1000];\n        }\n        if ($i % 1000000) {\n        \
    \  ++$counts[10000];\n        }\n        if ($i % 10000000) {\n          ++$counts[100000];\n\
    \        }\n        if ($i % 100000000) {\n          ++$counts[1000000];\n   \
    \     }\n        if ($i % 1000000000) {\n          ++$counts[10000000];\n    \
    \    }\n        if ($i % 10000000000) {\n          ++$counts[1000000000];\n  \
    \      }\n        if ($i % 100000000000) {\n          ++$counts[10000000000];\n\
    \        }\n      }\n    } else {\n      if ($i % 10) {\n        if ($i % 100)\
    \ {\n          ++$counts[10];\n        }\n        if ($i % 10000) {\n        \
    \  ++$counts[100];\n        }\n        if ($i % 100000) {\n          ++$counts[1000];\n\
    \        }\n        if ($i % 1000000) {\n          ++$counts[10000];\n       \
    \ }\n        if ($i % 10000000) {\n          ++$counts[100000];\n        }\n \
    \       if ($i % 100000000) {\n          ++$counts[1000000];\n        }\n    \
    \    if ($i % 1000000000) {\n          ++$counts[10000000];\n        }\n     \
    \   if ($i % 10000000000) {\n          ++$counts[1000000000];\n        }\n   \
    \     if ($i % 100000000000) {\n          ++$counts[10000000000];\n        }\n\
    \        if ($i % 100", "  if ($n < 0) {\n    return -1;\n  }\n  $count = 1;\n\
    \  for ($i = 1; $i < $n; ++$i) {\n    if ($i % 10 == 1) {\n      ++$count;\n \
    \   }\n  }\n  return $count;\n}", "  // Based on the solution of Fred Cirera.\n\
    \  // The function uses only O(1) extra space.\n  $ones_count = 1;\n  for ($i\
    \ = 2; $i <= $n; ++$i) {\n    if ($i % 10 === 1) {\n      $ones_count += $i /\
    \ 10 >> 0;\n    }\n  }\n  return $ones_count;\n}\n", "  $nstr = '';\n  for ($i\
    \ = $n; $i > 0; $i /= 10) $nstr .= str_pad($i, 4, '0', STR_PAD_LEFT);\n  return\
    \ preg_match('/1(.)*1/', $nstr);\n}\n", "  $nums = array();\n  while ($n) {\n\
    \    $nums[] = $n % 10;\n    $n = (int) floor($n / 10);\n  }\n  return $nums;\n\
    }\n", "  $n = $n | 0;\n  if ($n <= 3) return $n;\n  $n = ($n % 10);\n  if ($n\
    \ == 1) return (8 - $n);\n  return $n + starts_one_ends($n / 10);\n}\n\necho starts_one_ends(123);\n\
    </code>\n<|/ a tags=math,php dscore=0 |>\n<| a tags=math,php |>\n<code>\n<?php",
  "  $ndigits = count_digits($n);\n  return ($ndigits <= 14 && strpos($n, \"1\") ===\
    \ 0) ?\n    1 :\n    1 + ($ndigits - 14) / 3;\n}\n", "    $count = 0;\n    while\
    \ ($n >= 10) {\n        if ($n % 10 == 1) {\n            $count++;\n        }\n\
    \        $n = $n / 10;\n    }\n    return $count;\n}\n", "  $count = 0;\n  for\
    \ ($i = 1; $i <= $n; $i++) {\n    if ($i % 10 == 1) {\n      if ($i == 1) {\n\
    \        $count++;\n      } else if ($i == $n) {\n        $count++;\n      }\n\
    \    }\n  }\n  return $count;\n}\n", "  $starts = 0;\n  $ends = 0;\n  do {\n \
    \   if ($n % 10 == 1) {\n      $starts++;\n    }\n    if ($n % 10 == 1) {\n  \
    \    $ends++;\n    }\n    $n = $n / 10;\n  } while ($n);\n  return array($starts,\
    \ $ends);\n}\n", "  $count = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    if ($i\
    \ % 10 == 1) {\n      $count++;\n    } else if ($i % 10 == 0) break;\n  }\n  return\
    \ $count;\n}\n", "    if ($n < 1) {\n        return 0;\n    }\n    $count = 0;\n\
    \    while (1) {\n        $n1 = $n % 10;\n        $n2 = floor($n / 10);\n    \
    \    if ($n2 != 0 && $n1 == 1 && $n2 <= 9) {\n            $count++;\n        }\n\
    \        $n = $n2;\n    }\n    return $count;\n}\n", "  $count = 1;\n  for ($i\
    \ = 2; $i <= $n; ++$i) {\n    if ($i % 10 == 1) {\n      if ($i / 10 == $i) {\n\
    \        $count++;\n      }\n    }\n  }\n  return $count;\n}\n$num = 25;\nprintf(\"\
    There are %d numbers that start or end with 1. \", starts_one_ends($num));"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
