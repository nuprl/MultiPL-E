name: HumanEval_34_unique
language: php
prompt: "<?php\n// Return sorted unique elements in a list\n// >>> unique([5, 3, 5,\
  \ 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\nfunction unique($l) {\n"
tests: "function candidate(...$args) {\n    return unique(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(5, 3, 5, 2, 3, 3, 9, 0, 123)) !== array(0,\
  \ 2, 3, 5, 9, 123)) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  return sort(array_unique($l));\n}\n</code>\nAs you can see it works\
    \ well!\n<|/ a |>\n<| a dscore=3 |>\nPHP 5.3 introduced ArrayObject which lets\
    \ you define your own methods that act like methods on an array. In your case\
    \ array_unique should do the trick:\n<code>\nclass uniqueArrayObject extends ArrayObject{\n\
    \    public function unique_elements() {\n        return sort(array_unique($this->getArrayCopy()));\n\
    \    }\n}\n</code>\n<|/ a tags=arrays,functional-programming,php |>\n<| a tags=arrays,functional-programming,php\
    \ |>\nIt might be more elegant to use array_filter with a custom callback, something\
    \ like this:\n<code>", "    return array_filter(array_unique(array_map($this,\
    \ $l)));\n}\n", "  $a = array();\n  foreach ($l as $k) {\n    if (in_array($k,\
    \ $a)) {\n      continue;\n    }\n    $a[] = $k;\n  }\n  return $a;\n}", "\t$result\
    \ = array();\n\t$uniq = array();\n\tforeach($l as $v) {\n\t\tif(!in_array($v,\
    \ $result)) {\n\t\t\t$uniq[] = $v;\n\t\t\t$result[] = $v;\n\t\t}\n\t}\n\treturn\
    \ $uniq;\n}\n", "  return array_filter(array_unique(array_map(__FUNCTION__, $l)));\n\
    }\n</code>\n<|/ a dscore=5 tags=arrays,unique,php |>\n<| a tags=arrays,unique,php\
    \ |>\nThe \"right\" way is to use array_unique().\narray_unique will remove any\
    \ duplicates in an array, but only while still iterating.\nSo, if your array consists\
    \ of 10 items, and all duplicates are next to each other, array_unique will only\
    \ remove 3 of them.\nTo test this, just echo your array before and after the call,\
    \ and you'll see what I mean.\nThe solution provided by Andi will also remove\
    \ duplicates in place, which may be what you want.\n<|/ a dscore=4 |>\n<| a tags=arrays,unique,php\
    \ |>\nIf you want to keep duplicates in order as they appear in the array while\
    \ eliminating duplicates in the array, this is what worked for me:\n<code>\n$a\
    \ = array('a', 'b', 'c', 'd', 'b', 'a', 'a', 'a', 'b', 'c', 'd');\n$unique = array_unique($a,\
    \ SORT_REGULAR);\n</code>\nResult:\n<code>\nArray ( [0] => a [1] => b [2] => c\
    \ [3] => d ) \n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\n<code>\n$array =\
    \ array(\"foo\", \"bar\", \"foo\", \"bar\", \"foo\");\n$array = array_unique($array);\n\
    </code>\nhttp://php.net/manual/en/function.array-unique.php\n<|/ a tags=arrays,unique,php\
    \ |>\n<| c |>\nThis does not work if order is important.\n<|/ c |>\n<| a tags=arrays,unique,php\
    \ dscore=3 |>\n<code>", "  $return = array();\n  foreach ($l as $key => $value)\
    \ {\n    if (!isset($return[$key])) {\n      $return[$key] = $value;\n    }\n\
    \  }\n  return $return;\n}", "  $result = array();\n  foreach ($l as $elm) {\n\
    \    if (!in_array($elm, $result)) {\n      $result[] = $elm;\n    }\n  }\n  return\
    \ $result;\n}\n</code>\n<|/ a tags=sorting,php,arrays,multidimensional-array |>\n\
    <| c |>\nI like your use of recursion to handle any arbitrary depth. But it can\
    \ be optimized a bit by using `return` instead of `exit` in the outer `if` condition.\
    \ And also using `in_array` to check if the element is already in the `$result`\
    \ array instead of `foreach` + `in_array` + `array_search` + `unset`.\n<|/ c |>\n\
    <| a tags=sorting,php,arrays,multidimensional-array |>\nTry this:\n<code>", " \
    \   $o = array();\n    $l = array_merge($l, array_values($l));\n    return array_merge($l,\
    \ array_unique($l));\n}", "    return sort($l);\n}", "\treturn array_intersect(array_unique(sort($l)),\
    \ $l);\n}\n", "    return array_filter($l, function($item) {\n        return in_array($item,\
    \ $l);\n    });\n}", "    return array_unique($l);\n}\n", "  $a = array();\n \
    \ foreach ($l as $i => $e) {\n    $a[$e] = $e;\n  }\n  return array_keys($a);\n\
    }", "    $i = count($l);\n    $result = [];\n    while ($i) {\n        $result\
    \ = array_merge($result, array_slice($l,--$i,true));\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this link may answer the question,\
    \ it is better to include the essential parts of the answer here and provide the\
    \ link for reference.  Link-only answers can become invalid if the linked page\
    \ changes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$array1 = [1, 2, 3, 4, 4, 4];\n\
    $array2 = [1, 2, 3, 3, 4, 5];\n$array3 = [1, 2, 3, 3, 4, 5];\n$array4 = [1, 2,\
    \ 3, 4, 5, 5];\n$array5 = [1, 2, 3, 4, 5, 6];\n$array6 = [1, 2, 3, 4, 5, 6];\n\
    $array7 = [1, 2, 3, 4, 5, 6];\n$array8 = [1, 2, 3, 4, 5, 6];\n\n$array = array();\n\
    if (is_array($array1) || is_array($array2)) {\n    $array[] = $array1;\n    $array[]\
    \ = $array2;\n}\nif (is_array($array3) || is_array($array4)) {\n    $array[] =\
    \ $array3;\n    $array[] = $array4;\n}\nif (is_array($array5) || is_array($array6))\
    \ {\n    $array[] = $array5;\n    $array[] = $array6;\n}\nif (is_array($array7)\
    \ || is_array($array8)) {\n    $array[] = $array7;\n    $array[] = $array8;\n\
    }\n\n$unique = array_unique($array);\n</code>\n<|/ a tags=php,arrays |>\n<| c\
    \ |>\nThis would work, although the condition `is_array` can be replaced with\
    \ `$array instanceof stdClass`, since stdClasses inherit from arrays. But as I\
    \ commented on another answer, this is not a good way to solve the problem. Using\
    \ `is_array` is misleading, and this answer will fail in the general case. You\
    \ can only use `is_array` if the array contains objects (which you shouldn't be\
    \ using in this case).\n<|/ c |>\n<| c |>\nThis is also very inefficient compared\
    \ to using `array_unique`.\n<|/ c |>\n<| c |>\ni agree with you, i just wanted\
    \ to point out that this can be done in a very simple way.\n<|/ c |>\n<| c |>\n\
    I agree with you, and I up-voted your answer. But I didn't want to encourage anyone\
    \ from using the `is_array` check in general. It's not always going to work correctly\
    \ with every array that can ", "    return array_unique(array_map(__FUNCTION__,\
    \ $l));\n}", "\t$a = array();\n\tforeach ($l as $value) {\n\t\tif (in_array($value,\
    \ $a)) {\n\t\t\tcontinue;\n\t\t}\n\t\t$a[$value] = 1;\n\t}\n\treturn array_keys($a);\n\
    }", "    if (empty($l)) {\n        return $l;\n    }\n    // If the list has numeric\
    \ keys, use asort() to sort numerically\n    // Return sorted unique elements\
    \ in a list\n    $a = array();\n    foreach ($l as $item) {\n        if (!is_string($item))\
    \ {\n            $a[$item] = $item;\n        }\n    }\n    asort($a);\n    $r\
    \ = array();\n    foreach ($a as $item) {\n        if (!in_array($item, $r)) {\n\
    \            $r[] = $item;\n        }\n    }\n    return $r;\n}\n", "\t$l = array_map(\"\
    unserialize\", array_unique(array_map(\"serialize\", $l)));\n\tarray_walk($l,\
    \ function(&$v) {\n\t\t$v = serialize($v);\n\t});\n\treturn $l;\n}\n", "    return\
    \ sort($l, true);\n}\n", "    return array_unique(array_map(\"intval\", $l));\n\
    }\n", "  $e = array();\n  foreach ($l as $k => $v) {\n    if (!in_array($v, $e))\n\
    \      $e[] = $v;\n  }\n  return $e;\n}\n", "  return array_values(array_unique($l));\n\
    }", "    $a = array();\n    $l = array_map(\"unserialize\", $l);\n    $l = array_map(\"\
    strval\", $l);\n\n    foreach($l as $key => $value) {\n        if (!in_array($value,\
    \ $a)) {\n            $a[$key] = $value;\n        }\n    }\n\n    return $a;\n\
    }\n", "  $a = array();\n  foreach ($l as $e) $a[$e] = $e;\n  return array_keys($a);\n\
    }\n", "\t$l = array_values($l);\n\tsort($l);\n\t$l = array_unique($l);\n\tsort($l);\n\
    \treturn $l;\n}", "\t$u = array();\n\tforeach($l as $e) {\n\t\t$u[] = $e;\n\t\
    }\n\tsort($u);\n\t$u = array_values($u);\n\treturn $u;\n}\n", "    return array_unique($l);\n\
    }\n", "    return call_user_func_array('array_merge', array_unique(call_user_func_array('array_unique',\
    \ $l)));\n}\n", "  return array_map(\"unserialize\", array_unique(array_map(\"\
    serialize\", $l)));\n}\n</code>\n<|/ a tags=php,arrays,unique |>\n<| c |>\nThe\
    \ above solution works fine with associative arrays but not with indexed arrays.\
    \ If you would like to work with indexed arrays as well then use \n`array_values(\
    \ array_map(\"serialize\", $array) ); `\nbefore calling `unique()`\n<|/ c |>\n\
    <| c |>\nThis doesn't work for me. `array_values() expects parameter 1 to be array,\
    \ object given` on PHP 5.6.23\n<|/ c |>\n<| c |>\n: Your array is probably not\
    \ an associative array. If your array is numerically indexed (as you get from\
    \ MySQL), then just use `array_values($array)`.\n<|/ c |>\n<| c |>\nI came here\
    \ from Google and found this answer. I've added `array_values($array)` before\
    \ the `unique` call and it worked like a charm. Thanks.\n<|/ c |>\n<| a dscore=5\
    \ tags=php,arrays,unique |>\nHere's a generic way to remove duplicates given any\
    \ type of array (associative, numeric, etc.):\n<code>", "\t$a = array_count_values($l);\n\
    \t$l = array_keys($a);\n\tarray_multisort($a);\n\treturn $l;\n}\n", "  $a = $l\
    \ = array_values($l);\n  $u = $a[0]; $v = null;\n  for ($i = 1; $i < count($a);\
    \ ++$i) {\n    $v = ($a[$i] === $v) ? $u : $v;\n    $u = $a[$i]; $a[$i] = $v;\n\
    \  }\n  return $a;\n}\n", "  if (!is_array($l))\n    throw new InvalidArgumentException(__METHOD__\
    \ . \" expects parameter 1 to be array, \" . gettype($l) . \" given.\");\n  $f\
    \ = array_map(function($a) { return serialize($a); }, $l);\n  sort($f);\n  $l\
    \ = array_unique($f);\n  sort($l);\n  return $l;\n}", "    return array_unique($l);\n\
    }\n", "    return array_unique($l);\n}\n", "    return sort(array_unique(sort($l)));\n\
    }\n", "    $a = array();\n    $l = is_array($l) ? $l : array($l);\n    foreach\
    \ ($l as $v) {\n        if (in_array($v, $a)) continue;\n        $a[] = $v;\n\
    \    }\n    return $a;\n}\n", "    return array_unique(array_map(__FUNCTION__,\
    \ func_get_args(), $l));\n}\n", "\t$a = array();\n\tforeach ($l as $e) {\n\t\t\
    if (in_array($e, $a)) continue;\n\t\t$a[$e] = 1;\n\t}\n\treturn array_keys($a);\n\
    }\n", "  return array_filter($l, function($v) {\n    return ! in_array($v, $l);\n\
    \  });\n}", "  // Sort list\n  sort($l);\n  // Remove duplicates\n  $u = array();\n\
    \  foreach($l as $i => $e) {\n    if (in_array($e, $u)) continue;\n    $u[] =\
    \ $e;\n  }\n  // Return sorted unique list\n  return array_unique($u);\n}", "\t\
    asort($l);\n\t$r = [];\n\tforeach ($l as $v) {\n\t\tif (!in_array($v, $r)) {\n\
    \t\t\t$r[] = $v;\n\t\t}\n\t}\n\treturn $r;\n}", "\t$a = array();\n\tforeach ($l\
    \ as $k => $v) {\n\t\tif (!isset($a[$v])) {\n\t\t\t$a[$v] = $k;\n\t\t}\n\t}\n\t\
    asort($a);\n\t$l = array();\n\tforeach ($a as $k => $v) {\n\t\t$l[] = $v;\n\t\
    }\n\treturn $l;\n}\n\n/**\n * Return sorted unique values in a list\n * @see unique\n\
    \ * @param array $l list of values to sort\n * @return array list of unique values\n\
    \ */", "    $a = array();\n    foreach ($l as $item) {\n        if (in_array($item,\
    \ $a)) {\n            continue;\n        }\n        $a[$item] = $item;\n    }\n\
    \    return $a;\n}\n", "  $a = array();\n  foreach($l as $v) {\n    $v = $v ==\
    \ $v ? 0 : $v;\n    $v == $v ? $a[] = $v : $a[$v]++;\n  }\n  return $a;\n}", "\t\
    $a = array();\n\t$l = sort($l);\n\tforeach ($l as $k => $v) $a[$k] = $v;\n\treturn\
    \ array_values($a);\n}", "    $unique = [];\n    foreach ($l as $item) {\n   \
    \     if (!in_array($item, $unique)) {\n            $unique[] = $item;\n     \
    \   }\n    }\n    return $unique;\n}\n", "\tsort($l);\n\t$ret = array();\n\tforeach\
    \ ($l as $i => $v) {\n\t\tif (!isset($ret[$v])) {\n\t\t\t$ret[$v] = $v;\n\t\t\
    }\n\t}\n\treturn $ret;\n}\n", "  $ls = array();\n  foreach ($l as $value) {\n\
    \    if (!isset($ls[$value])) {\n      $ls[$value] = $value;\n    }\n  }\n  return\
    \ $ls;\n}", "  $r = array();\n  foreach ($l as $k => $v) {\n    if ($v !== key($l))\
    \ {\n      $r[] = $v;\n    }\n  }\n  return $r;\n}", "    return array_unique(array_map(\"\
    intval\", $l));\n}\n", "    return array_filter($l, function ($e) use (&$unique)\
    \ {\n        return !in_array($e, $unique);\n    });\n}\n", "    $a = [];\n  \
    \  $l2 = [];\n    foreach ($l as $k => $v) {\n        if (! in_array($v, $a))\
    \ {\n            array_push($a, $v);\n        }\n        else {\n            $x\
    \ = array_search($v, $a);\n            array_push($l2, $x);\n            array_splice($a,\
    \ $x, 1);\n        }\n    }\n    return $l2;\n}\n", "  return array_filter($l,\
    \ 'strnatcmp', SORT_NATURAL);\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI guess\
    \ you can try like this\n<code>\n<?php\n$arrays = [\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n\
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\n[1,2,", "    // Convert\
    \ to array\n    $l = array_values($l);\n    // Remove duplicate values\n    $l\
    \ = array_unique($l);\n    // Sort values\n    sort($l);\n    // Return sorted\
    \ unique values\n    return $l;\n}\n", "  $c = array();\n  foreach ($l as $l)\
    \ $c[$l] = 1;\n  return array_keys($c);\n}\n</code>\n<|/ a dscore=5 tags=php,sorting,arrays\
    \ |>\n<| c |>\nI guess `array_unique` is better than `array_keys`\n<|/ c |>\n\
    <| c |>\n: That depends. `array_unique` makes the array unique, but keeps the\
    \ keys. `array_keys` discards duplicates, but returns an array of keys. There\
    \ are different functional approaches to what you're trying to do. `array_unique`\
    \ isn't really suited for everything.\n<|/ c |>\n<| c |>\nThank you for this suggestion,\
    \ very helpful!\n<|/ c |>\n<| c |>\nThis was the best solution in my opinion.\
    \ Works perfectly for my situation. Thank you.\n<|/ c |>\n<| c |>\nThanks, I really\
    \ liked your solution too.\n<|/ c |>\n<| a dscore=5 tags=php,sorting,arrays |>\n\
    Use this:\n<code>\n$array = array_unique($array);\nsort($array);\n</code>\n<|/\
    \ a |>\n<| c |>\narray_unique doesn't guarantee sorted output\n<|/ c |>\n<| c\
    \ |>\nThat would be the worst solution in most cases.\n<|/ c |>\n<| a |>\nI use\
    \ this function when I need to get the unique items of the array and need to keep\
    \ the keys same:\n<code>", "  $s = array();\n  foreach ($l as $v) $s[] = $v;\n\
    \  asort($s);\n  return $s;\n}\n", "  $a = array();\n  $l = array_reverse($l);\n\
    \  foreach ($l as $v) {\n    if ($v == $a[-1]) continue;\n    else array_push($a,\
    \ $v);\n  }\n  return array_reverse($a);\n}\n", "    $a = array_slice($l,0);\n\
    \    foreach($a as $key => $val) {\n        if(in_array($val, $l)) {\n       \
    \     unset($l[$key]);\n        }\n    }\n    return array_values($l);\n}", "\t\
    sort($l);\n\t$l = array_reverse($l);\n\t$u = array();\n\tforeach ($l as $k =>\
    \ $v)\n\t\t$u[$v] = $k;\n\treturn array_keys($u);\n}\n", "\t$a = array();\n\t\
    foreach ($l as $key => $val)\n\t\tif ($val !== $a) { \n\t\t\t$a[$key] = $val;\
    \ \n\t\t}\n\treturn $a;\n}\n", "    return $l[array_unique(array_keys($l))];\n\
    }", "  $u = [];\n  foreach ($l as $i) {\n    if (in_array($i, $u)) {\n      continue;\n\
    \    }\n    array_push($u, $i);\n  }\n  return $u;\n}", "    $a = array();\n \
    \   foreach($l as $k => $v) $a[] = $k;\n    $a = array_unique($a);\n    return\
    \ $a;\n}\n", "  $a = array();\n  foreach ($l as $e) {\n    if ($e == \"\") continue;\n\
    \    if (!in_array($e, $a)) {\n      $a[] = $e;\n    }\n  }\n  return $a;\n}\n",
  "    return array_values(array_unique(array_values($l)));\n}\n", "\treturn array_unique(array_reverse($l));\n\
    }\n", "\tstatic $checked = [];\n\treturn array_reduce($l, 'array_merge', array_keys($checked));\n\
    }", "\t$u = new SplDoublyLinkedList();\n\tforeach($l as $v)\n\t\t$u->add($v);\n\
    \treturn $u->getIterator();\n}", "  return array_filter(\n      array_unique(array_values($l)),\n\
    \      function ($element) { return !is_int($element); });\n}\n", "  return array_unique($l);\n\
    }", "    asort($l);\n    return array_keys($l);\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nthis answer does not take duplicates\n<|/ c |>\n<| c |>\nSure it does,\
    \ just change array_diff to array_unique\n<|/ c |>\n<| a tags=arrays,php |>\n\
    array_diff is what you need:\n<code>\n$a = array(2,3,1,5);\n$b = array(3,5,7,5,7,9,4,5);\n\
    $c = array_diff($a, $b);\nprint_r($c);\n</code>\nThe output is \n<code>\nArray\n\
    (\n    [2] => 1\n    [3] => 5\n    [5] => 7\n)\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nThis doesn't take into account the duplicates.\n<|/ c |>\n<| a tags=arrays,php\
    \ |>\n<code>", "    $result = array();\n    foreach ($l as $item) {\n        if\
    \ (in_array($item, $result) === false) {\n            $result[] = $item;\n   \
    \     }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=arrays,php |>\n<|\
    \ a dscore=2 tags=arrays,php |>\n<code>\n$result = array();\n$input = array(1,2,2,3,4,4,6,6,6,7,8);\n\
    foreach($input as $k => $v)\n{\n if(!in_array($v, $result))\n {\n  if(is_numeric($v))\n\
    \   $result[] = $v;\n  else\n   $result[] = $k;\n }\n}\nprint_r($result);\n</code>\n\
    <|/ a |>\n<| a tags=arrays,php |>\n<code>\n$input = array(\"3\",\"2\",\"3\",\"\
    2\",\"5\",\"3\",\"2\",\"3\",\"3\",\"9\",\"0\",\"123\");\n\n$result= array();\n\
    $input = array_map('intval',$input);\nforeach($input as $key=>$val){\n    if(!in_array($val,\
    \ $result)){\n        $result[] = $val;\n    }\n}\n\n$result = array_unique($result);\n\
    print_r($result);\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\n$input\
    \ = array(\"3\",\"2\",\"3\",\"2\",\"5\",\"3\",\"2\",\"3\",\"3\",\"9\",\"0\",\"\
    123\");\n\n$input = array_map('intval',$input);\n$unique = array_unique($input);\n\
    print_r($unique);\n</code>\n<|/ a tags=arrays,php |>\n<| a tags=arrays,php dscore=1\
    \ |>\n<code>\n<?php\n$input = array(\"3\",\"2\",\"3\",\"2\",\"5\",\"3\",\"2\"\
    ,\"3\",\"3\",\"9\",\"0\",\"123\");\n$input = array_map('intval',$input);\n$unique\
    \ = array_unique($input);\nprint_r($unique);", "    $s = array();\n    foreach\
    \ ($l as $i => $o) {\n        if (!array_key_exists($i, $s) || $s[$i] !== $o)\
    \ {\n            $s[$i] = $o;\n        }\n    }\n    return array_values($s);\n\
    }\n\n/**\n * Like PHP's `array_map` but preserves keys instead of re-indexing\n\
    \ * @param $callback\n * @param $a\n * @return array\n * @link http://php.net/manual/en/function.array-map.php#77538\n\
    \ */", "  // We use an associative array with the key being the original element\n\
    \  // and the value being the original index in the list\n  return array_map('unserialize',\
    \ array_unique(array_map('serialize', $l)));\n}\n", "  return array_filter($l,\
    \ function($v, $k) {\n    return !in_array($v, $l);\n  });\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\narray_unique (http://php.net/manual/en/function.array-unique.php)\
    \ sorts and filters duplicated values.\n<|/ a dscore=5 tags=arrays,php |>\n<|\
    \ a |>\narray_unique() function removes duplicate values from an array.\n<code>\n\
    <?php\n$array = array(\"blue\", \"red\", \"blue\", \"green\");\nprint_r(array_unique($array));",
  "\t$a = array();\n\tforeach ($l as $key => $value) {\n\t\tif (!isset($a[$value]))\
    \ {\n\t\t\t$a[$value] = $key;\n\t\t}\n\t}\n\treturn $a;\n}\n", "    return array_unique(array_map(__FUNCTION__,\
    \ $l));\n}\n</code>\n<|/ a dscore=5 tags=php,arrays |>\n<| c |>\narray_filter\
    \ is nice, however it removes null values.\n<|/ c |>\n<| c |>\n: you can always\
    \ use `array_filter` with an anonymous function to remove the `null` values, and\
    \ add them back in afterwards.\n<|/ c |>\n<| c |>\n: Ah, I was just trying to\
    \ find a PHP function that would do this for me.  I didn't know about anonymous\
    \ functions.\n<|/ c |>\n<| c |>\nThe only reason I did not try this approach is\
    \ because I saw the answer from Kolink. +1 to his answer too.\n<|/ c |>\n<| c\
    \ |>\n: I didn't know that `array_unique` was so poorly implemented, but it is!\
    \ It doesn't work on associative arrays, though.\n<|/ c |>\n<| a |>\nIf you want\
    \ a function that will remove duplicates, you can use array_unique(). Example:\n\
    <code>\n$a = [5, 3, 5, 2, 3, 3, 9, 0, 123];\nvar_dump(array_unique($a));\n</code>\n\
    Outputs:\n<code>\narray(5) {\n  [0]=>\n  int(5)\n  [2]=>\n  int(3)\n  [3]=>\n\
    \  int(9)\n  [4]=>\n  int(123)\n}\n</code>\n<|/ a dscore=5 tags=php,arrays |>\n\
    <| c |>\nThis is the simplest and most reliable way of doing it. Thanks!\n<|/\
    \ c |>\n<| c |>\nThis will remove only duplicates that are not consecutive, not\
    \ all the duplicates\n<|/ c |>\n<| c |>\nThis does not remove duplicate values.\n\
    <|/ c |>\n<| c |>\nthe question is about \"duplicate values\" which don't appear\
    \ to be consecutive in the array.\n<|/ c |>\n<| c |>\nIf two values are duplicates,\
    \ only the last one will be retained.\n<|/ c |>\n<| a |>\nIf you want to keep\
    \ consecutive duplicates, you can just use array_unique(array_merge($arr1,$arr2))\n\
    <code>\n$arr1 = array(5,5,5,2);\n$arr2 = array(3,3,3);\n$result = array_unique(array_merge($arr1,$arr2));\n\
    print_r($result);\n", "  foreach ($l as $k => $v) {\n    if (in_array($v, $l))\
    \ {\n      unset($l[$k]);\n    } else {\n      if ($v == $l[0]) $l[0] = $v;\n\
    \    }\n  }\n  return array_values($l);\n}\n\n/**\n * Sort an array and keep only\
    \ unique values.\n *\n * Example:\n * >>> uniqueSort([0, 5, 3, 0, 10, 2, 6]);\n\
    \ * [0, 5, 2, 6, 10]\n * >>> uniqueSort([0, 5, 3, 0, 10, 2, 6, 0, 10, 2, 6], true);\n\
    \ * [0, 5, 2, 6, 10]\n */", "    $c = array();\n    $ret=array();\n    foreach\
    \ ($l as $i => $v) {\n        if (!in_array($v, $c)) {\n            $c[] = $v;\n\
    \            $ret[] = $v;\n        }\n    }\n    return $ret;\n}", "    $a = $l\
    \ = array_reverse($l);\n    $u = [];\n    foreach ($l as $v) {\n        if (!in_array($v,\
    \ $u, true)) {\n            $u[] = $v;\n        }\n    }\n    return array_reverse($u);\n\
    }", "    $u = [];\n    foreach($l as $v) {\n        if (!in_array($v, $u)) {\n\
    \            $u[] = $v;\n        }\n    }\n    return $u;\n}\n\n/**\n * Sorted\
    \ list where multiple entries are guaranteed to be unique.\n *\n * @return\n *\
    \   Sorted (unique) list of items in `list`.\n *\n * @see unique()\n */", "  \
    \  return sort(array_unique(call_user_func_array('array_merge', $l)));\n}\n",
  "    $r = [];\n    foreach ($l as $v) $r[++$r[$v]] = $v;\n    return array_values($r);\n\
    }\n\n$list = (\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n  'a',\n\
    \  'a',", "    $a = array();\n    $r = true;\n    foreach ($l as $k => $v) {\n\
    \        if (!isset($a[$v])) {\n            $r  = false;\n            $a[$v] =\
    \ $v;\n        }\n    }\n    return ($r ? $a : array());\n}", "    $u = [];\n\
    \    foreach ($l as $e) {\n        if (in_array($e, $u)) { continue; }\n     \
    \   $u[] = $e;\n    }\n    return $u;\n}\n", "\treturn sort(array_unique($l));\n\
    }\n", "    $d = [];\n    foreach($l as $k => $v) $d[$k] = 1;\n    $result = array_keys($d);\n\
    \    sort($result);\n    return $result;\n}\n", "    $u = [];\n    foreach ($l\
    \ as $i) {\n        if (!in_array($i, $u)) {\n            array_push($u, $i);\n\
    \        }\n    }\n    return $u;\n}\n", "  foreach ($l as $e) {\n    $l2 = array();\n\
    \    foreach ($l as $f) {\n      if ($e == $f) {\n        array_push($l2, $e);\n\
    \      }\n    }\n    $l = $l2;\n  }\n  return $l;\n}", "    $ret = [];\n    foreach($l\
    \ as $e) {\n        $k = array_search($e, $ret);\n        if ($k !== false) {\n\
    \            $ret[$k] = $e;\n        }\n        elseif ($e !== '') {\n       \
    \     $ret[] = $e;\n        }\n    }\n    return $ret;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\n$a = array('5','3','3','2','3','3','9','0','123');\n\
    $b = array();\nforeach ($a as $val) {\n    if (in_array($val, $b)) {\n       \
    \ unset($a[array_search($val, $b)]);\n    } else {\n        $b[] = $val;\n   \
    \ }\n}\nprint_r($a);\n</code>\n<|/ a tags=arrays,php |>\n<| c |>\nI like this\
    \ answer, but you can get away with using `$a` as the array to be searched.\n\
    <|/ c |>\n<| c |>\nHmmm I was thinking about that.. but the code I gave works\
    \ with the array provided by the OP.. and I didn't want to change the OP's code\n\
    <|/ c |>\n<| a dscore=1 tags=arrays,php |>\n<code>\n<?php\n$a=['5','3','3','2','3','3','9','0','123'];\n\
    $b=array_flip($a);\n$a=array_diff($b,array_flip($a));\nprint_r($a);", "  return\
    \ array_keys(array_filter(array_count_values($l)));\n}\n", "\t$u = [];\n\tforeach\
    \ ($l as $e) {\n\t\tif (in_array($e, $u)) continue;\n\t\t$u[] = $e;\n\t}\n\treturn\
    \ $u;\n}\n", "  // Use a set as opposed to a hash\n  $set = new SplPriorityQueue;\n\
    \  foreach ($l as $k => $v) {\n    $set->insert($v, $k);\n  }\n  $l = [];\n  foreach\
    \ ($set->iterator() as $k => $v) {\n    $l[$k] = $v;\n  }\n  return $l;\n}\n",
  "  $a = array();\n  foreach ($l as $item) {\n    if (in_array($item, $a)) continue;\n\
    \    $a[$item] = 1;\n  }\n  return array_keys($a);\n}\n", "    return array_filter($l,\
    \ function($element) {\n        return !in_array($element, $l);\n    });\n}\n",
  "    $seen = array();\n    $result = array();\n    foreach ($l as $key => $value)\
    \ {\n        if (!in_array($value, $seen)) {\n            $seen[] = $value;\n\
    \            $result[] = $value;\n        }\n    }\n    return $result;\n}\n</code>\n\
    <|/ a tags=php |>\n<| c |>\nYeah I know that but if I can do that without array_unique\
    \ that would be better.\n<|/ c |>\n<| c |>\nThe only problem with array_unique\
    \ is when you have the chance of getting duplicates - so if that is the case then\
    \ array_unique would be the best option.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    <?php\n$result = array();\nforeach ($array as $value) {\n   $result[] = $value;\n\
    }\nreturn $result;\n</code>\n<|/ a tags=php |>\n<| c |>\nYou should use `$result[]\
    \ = $value;` instead of `$result[] = array($value);`\n<|/ c |>\n<| c |>\nActually,\
    \ I see I misread your code, the `array()` call would do nothing useful, just\
    \ `$result[] = $value;` will do. So the code as it is is actually correct\n<|/\
    \ c |>\n<| c |>\nIt's actually a waste of time to create a new array if all you\
    \ want to do is append an element to it. It only takes 1 line and 2 function calls.\n\
    <|/ c |>\n<| a |>\nTry this\n<code>\n<?php", "    if (!is_array($l)) {\n     \
    \   return null;\n    }\n    $l = array_map('unserialize', array_unique(array_map('serialize',\
    \ $l)));\n    return array_values($l);\n}\n", "    $a = array();\n    foreach($l\
    \ as $i => $e) {\n        $a[$i] =& $l;\n    }\n\n    $l = array();\n    foreach($a\
    \ as $i => $e) {\n        if(!in_array($e, $l)) {\n            $l[] =& $e;\n \
    \       }\n    }\n\n    return $l;\n}\n\n$s = array( 'aaa', 'bbb', 'ccc', 'dddd'\
    \ );\n$l = unique($s);", "    $a = array();\n    foreach ($l as $e) {\n      \
    \  if (!in_array($e, $a)) {\n            $a[] = $e;\n        }\n    }\n    return\
    \ $a;\n}\n</code>\n<|/ a dscore=1 tags=arrays,php |>\n<| a |>\n<code>\n$string=\"\
    your string goes here\"\n$ar=explode(\" \",$string);\n\n$a=array();\nforeach($ar\
    \ as $val)\n{\n    if(!in_array($val, $a))\n    {\n        $a[$val]=0;\n    }\n\
    }\n\nksort($a);\n$result=array();\nforeach($a as $key=>$val)\n{\n    array_push($result,$key);\n\
    }\n\nprint_r($result);\n</code>\n<|/ a tags=arrays,php dscore=1 |>\n<| c |>\n\
    thanks this is what I was looking for\n<|/ c |>\n<| a tags=arrays,php dscore=0\
    \ |>\narray_map + array_unique + sort:\n<code>\n$string = \"one two three four\
    \ five six seven eight nine\";\n$arr = explode(' ', $string);\n$arr = array_map('trim',\
    \ $arr);\n$arr = array_unique($arr);\nsort($arr);\nvar_dump($arr);\n</code>\n\
    result:\n<code>\narray(8) {\n  [0]=>\n  string(6) \"one\"\n  [1]=>\n  string(6)\
    \ \"two\"\n  [2]=>\n  string(6) \"three\"\n  [3]=>\n  string(6) \"four\"\n  [4]=>\n\
    \  string(6) \"five\"\n  [5]=>\n  string(6) \"six\"\n  [6]=>\n  string(6) \"seven\"\
    \n  [7]=>\n  string(6) \"eight\"\n  [8]=>\n  string(6) \"nine\"\n}\n</code>\n\
    <|/ a |>\n<| a tags=arrays,php |>\nTo find unique and sorted array from string\
    \ you can use following code:\n<code>\n$str = \"one two three four five six seven\
    \ eight nine\";\n$array=explode(\" \",$str);\n$uniqueArray = array();\nforeach($array\
    \ as $key=>$val){\n    if(!in_array($val,$uniqueArray)){\n        $uniqueArray[]=$val;\n\
    \    }\n}\nsort($uniqueArray);\nprint_r($uniqueArray);\n</code>\nOutput:\n<code>\n\
    Array\n(\n    [0] => one", "    $a = array();\n    foreach($l as $i=>$v) {\n \
    \       if (!array_key_exists($v, $a)) {\n            $a[$v] = $v;\n        }\n\
    \    }\n    return $a;\n}\n", "  sort($l);\n  return array_unique($l);\n}", " \
    \   $seen = [];\n    return array_filter(array_unique(array_merge($l, $seen),\
    \ function ($item, $key) use (&$seen) {\n        return !in_array($item, $seen)\
    \ ? $seen[] = $item : false;\n    }));\n}\n", "  $u = [];\n  foreach ($l as $e)\
    \ {\n    if (in_array($e, $u))\n      continue;\n    $u[] = $e;\n  }\n  return\
    \ $u;\n}\n", "\t$u = [];\n\tforeach ($l as $val) {\n\t\tif (in_array($val, $u))\
    \ {\n\t\t\tcontinue;\n\t\t}\n\t\t$u[] = $val;\n\t}\n\treturn $u;\n}\n", "\tsort($l);\n\
    \treturn array_unique($l);\n}\n", "  $a = array();\n  $l = is_array($l) ? $l :\
    \ array($l);\n  foreach ($l as $k) {\n    if ($k) $a[$k] = $k;\n  }\n  return\
    \ array_keys($a);\n}\n", "  // Sort array and remove duplicate elements\n  $sortedArray\
    \ = sort($l);\n\n  // Return unique elements from array\n  return array_unique(array_reverse($sortedArray));\n\
    }\n", "    $s = array();\n    $c = count($l);\n    foreach ($l as $i => $e) {\n\
    \        $l[$i] = $s[$i] ?? $i;\n        $s[$e] = $e;\n    }\n    $l = array_keys($l);\n\
    \    sort($l);\n    return $l;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a dscore=0\
    \ |>\nA more general solution which can work with:\n\nassociative arrays\nnumeric\
    \ arrays\nduplicate keys\nduplicate values\nmixed values (string, array or objects)\n\
    <code>", "\tusort($l, function($a, $b) {\n\t\treturn ($a == $b ? 0 : ($a < $b\
    \ ? -1 : 1));\n\t});\n\t$r = array();\n\tforeach($l as $v) {\n\t\t$r[] = $v;\n\
    \t}\n\treturn $r;\n}\n", "  return array_unique(array_map(\"intval\", $l));\n\
    }\n", "\tsort($l);\n\t$result = [];\n\t$i = 0;\n\tforeach($l as $e) {\n\t\tif($i\
    \ == 0) $result[] = $e;\n\t\telse if(!in_array($e, $result)) $result[] = $e;\n\
    \t\t$i++;\n\t}\n\treturn $result;\n}", "  return array_map('unserialize', array_unique(array_map('serialize',\
    \ $l)));\n}\n", "  if (!is_array($l)) {\n    return array();\n  }\n  $a = array();\n\
    \  foreach ($l as $e) {\n    if (array_key_exists($e, $a)) {\n      continue;\n\
    \    }\n    $a[$e] = $e;\n  }\n  return array_values($a);\n}\n", "\t\n\treturn(\n\
    \t\tarray_unique(\n\t\t\tarray_map(\n\t\t\t\tcreate_function('$e', \"return($e);\"\
    ),\n\t\t\t\t$l\n\t\t\t)\n\t\t)\n\t);\n}", "    if (is_array($l))\n        $l =\
    \ array_slice($l,0,count($l) - 1);\n    return array_unique($l);\n}", "\treturn\
    \ array_diff(\n\t\tarray_unique(\n\t\t\tarray_map(\n\t\t\t\tcreate_function('$a',\
    \ 'return $a;'),\n\t\t\t\t$l\n\t\t\t)\n\t\t),\n\t\t$l\n\t);\n}\n", "    // Use\
    \ set to remove duplicate elements\n    $s = array();\n    foreach ($l as $item)\
    \ {\n        if (!in_array($item, $s)) {\n            $s[] = $item;\n        }\n\
    \    }\n    return $s;\n}\n</code>\n<|/ a |>\n<| c |>\n+1 I like your use of set\
    \ here. I'm going to try implementing that and see if it works out.\n<|/ c |>\n\
    <| c |>\nSorry I meant `$s = array();` instead of `$s = $l;` I'll update the answer.\n\
    <|/ c |>\n<| c |>\nNo worries - I updated my question with your solution. I'm\
    \ getting an error `Parse error: syntax error, unexpected T_VARIABLE`, referring\
    \ to `foreach($s as $item`. I think that's just caused by a missing semi-colon?\
    \ Any idea what caused it?\n<|/ c |>\n<| c |>\n`foreach($s as $item)` -> `foreach($s\
    \ as &$item)`\n<|/ c |>\n<| c |>\nThat's great! And thank you for the explanation\
    \ too. I'm still not too familiar with PHP, so I appreciate the help. :)\n<|/\
    \ c |>\n<| a dscore=1 |>\nIf you need to get rid of duplicates, you can use array_unique\
    \ with SORT_NUMERIC or SORT_REGULAR flags (which both ignore the numeric values).\
    \ \n<code>\narray_unique($l, SORT_NUMERIC);\n</code>\n<|/ a tags=arrays,sorting,php\
    \ |>\n<| a |>\n<code>\n<?php\n$a = array(1,2,3,3,4,5,6,7,8,9);", "  $a = [];\n\
    \  foreach ($l as $k => $v) {\n    if (in_array($v, $a)) {\n      unset($l[$k]);\n\
    \    } else {\n      $a[$v] = 1;\n    }\n  }\n  return array_values($l);\n}\n",
  "    return array_filter(\n        $l,\n        function ($element) {\n        \
    \    return !in_array($element, $l);\n        }\n    );\n}\n", "    $r = [];\n\
    \    $tmp = [];\n    foreach ($l as $e) {\n        if (in_array($e, $r)) {\n \
    \           continue;\n        }\n        $tmp[$e] = true;\n        $r[] = $e;\n\
    \    }\n    return array_keys($tmp);\n}\n", "    sort($l);\n    return array_filter($l);\n\
    }\n", "    if ($l === []) {\n        return [];\n    }\n\n    $keys = array_keys($l);\n\
    \    $values = array_values($l);\n    $last = array_pop($keys);\n    foreach ($keys\
    \ as $k => $v) {\n        $flag = false;\n        foreach ($values as $v) {\n\
    \            if ($v === $last) {\n                $flag = true;\n            \
    \    break;\n            }\n        }\n        if (!$flag) {\n            $keys[]\
    \ = $last;\n        }\n    }\n\n    return array_values($keys);\n}\n</code>\n\
    <|/ a dscore=3 tags=algorithm,php,sorting |>\n<| c |>\nThank you very much, I\
    \ really appreciate your help :) But I haven't downvoted you :P\n<|/ c |>\n<|\
    \ c |>\nI did it because I got downvoted too :P But it is really interesting to\
    \ see how the answers could get better!\n<|/ c |>\n<| c |>\nSorry I forgot one\
    \ important thing I forgot to mention. These are not numbers, but letters. So\
    \ the order is not just 1, 2, 3 etc, but A, B, C, D, E, F, G etc. I am sorry if\
    \ that makes things more complicated.\n<|/ c |>\n<| c |>\n: No problem, just convert\
    \ all letters first to numbers and then sort by the numbers.\n<|/ c |>\n<| c |>\n\
    Thank you very much, it works. But I guess I will have to find another solution\
    \ for letters :)\n<|/ c |>\n<| a tags=algorithm,php,sorting |>\nThe first thing\
    \ you need to do is to sort the array in lexicographic order - a standard sort\
    \ function can do this for you. \nAfter that you'll need to identify the longest\
    \ run in the array and add it to an additional array for that run. \nThen move\
    \ on to the next run of elements until all elements have been processed. \nThe\
    \ resulting code looks like this:\n<code>", "    if ($l == null) { return $l;\
    \ }\n    return array_merge(\n        array_unique(array_filter(array_unique($l))),\n\
    \        $l\n    );\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI'm going to award\
    \ this one to you because it's much more thorough than the accepted answer.  Nice!\n\
    <|/ c |>\n<| a |>\nThis is an extension of Emile Kroon's answer which allows for\
    \ a custom comparison function to be passed in.\n<code>", "    return $l = array_unique(preg_filter('~[0-9]+~',\
    \ serialize($l), ARRAY_FILTER_USE_BOTH));\n}\n", "  if (is_array($l)) {\n    $r\
    \ = $l;\n    array_walk($r, function(&$value, $key) use (&$r) { $value = $key\
    \ % 2 == 0 ? $value : -$value; });\n    $r = array_slice($r, 0, -1);\n  }\n  return\
    \ $r;\n}\n</code>\n<|/ a tags=sorting,algorithm,php |>\n<| c |>\nI don't understand\
    \ that code. Why do you assign the value of $r? Also what does array_walk() do?\
    \ Is it the same as foreach() except it assigns the value to the key?\n<|/ c |>\n\
    <| c |>\n$r is the return value of `array_walk()` -- it is the same thing as `foreach`\
    \ except you access the key instead of the value.\n<|/ c |>\n<| c |>\nAh I see,\
    \ you use the key in the anonymous function because you don't want to overwrite\
    \ the value. Right?\n<|/ c |>\n<| c |>\n: yep, exactly. Although you might be\
    \ able to just use a foreach loop rather than `array_walk()` too.\n<|/ c |>\n\
    <| c |>\n: No, foreach is completely unnecessary here. Just add another parameter\
    \ to your anonymous function and use that.\n<|/ c |>\n<| a dscore=1 tags=sorting,algorithm,php\
    \ |>\nThe code below is not perfectly efficient, but it shows how to use the array\
    \ functions. I recommend reading up on array functions here.\n<code>\n<?php\n\n\
    /**\n * Sort an array based on another array\n * string $array Array to sort\n\
    \ * array $order Array to sort by\n * array $sorted Array of the sorted values\n\
    \ */", "    $a = $l = array_keys($l);\n    sort($a);\n    return array_values($a);\n\
    }\n", "  $result = [];\n  foreach($l as $l) {\n    if(!isset($result[$l])) {\n\
    \      $result[$l] = 1;\n    } else {\n      $result[$l] += 1;\n    }\n  }\n \
    \ return array_keys($result);\n}\n</code>\n<|/ a tags=algorithm,arrays,php,optimization\
    \ |>\n<| a tags=algorithm,arrays,php,optimization dscore=0 |>\n<code>", "    if\
    \ (!is_array($l)) return $l;\n    $sorted = array_unique($l);\n    $sorted = array_slice($sorted,\
    \ 0, -1);\n    return $sorted;\n}", "    $u = [];\n    foreach($l as $v) $u[$v]\
    \ = 1;\n    return array_keys($u);\n}", "    if (is_array($l)) {\n        return\
    \ array_unique(array_map(\"unserialize\", array_unique(array_map(\"serialize\"\
    , $l))));\n    } else {\n        return $l;\n    }\n}\n", "    $result = array();\n\
    \    foreach($l as $item) {\n        if (! in_array($item, $result)) {\n     \
    \       $result[] = $item;\n        }\n    }\n    return $result;\n}", "\t$a =\
    \ array();\n\tforeach($l as $e) {\n\t\tif ($e == $a[$e]) { continue; }\n\t\t$a[$e]\
    \ = true;\n\t}\n\treturn array_keys($a);\n}\n", "\t$u = array();\n\tforeach($l\
    \ as $item) {\n\t\tif ( !in_array($item, $u) ) {\n\t\t\t$u[] = $item;\n\t\t}\n\
    \t}\n\treturn $u;\n}\n", "    return array_unique(array_merge($l));\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nYes, but this is probably not what you want for a\
    \ case where you need to merge two arrays with unique values. Think of `array_merge`\
    \ as `array_merge_recursive` (in some languages) with `ARRAY_COMBINE_KEYS` flag\
    \ set.\n<|/ c |>\n<| c |>\nI like `array_unique` as a shorthand to `array_unique($array);`\
    \ and I like `array_merge_recursive` as a shorthand to `array_merge_recursive($array);`.\n\
    <|/ c |>\n<| a tags=php,arrays,unique |>\nSince this question was the top result\
    \ in Google when I searched for this question, here is one way you can do it:\n\
    <code>\narray_unique($array, SORT_REGULAR);\n</code>\nThis works the same way\
    \ as array_merge except it preserves duplicates.\n<|/ a dscore=5 |>\n<| c |>\n\
    This is the best answer.\n<|/ c |>\n<| c |>\nThis works best for me as well, thanks.\n\
    <|/ c |>\n<| c |>\nNote that this also preserves keys, if you want those to remain,\
    \ use `array_merge_recursive` instead. More here: https://stackoverflow.com/questions/3737139/how-to-merge-two-arrays-without-duplicate-key-and-add-the-value-for-the-key\n\
    <|/ c |>\n<| c |>\nI recommend using `array_merge($array)` because `array_unique`\
    \ has a cost.\n<|/ c |>\n<| c |>\nAwesome! This is so much faster than any `foreach`\
    \ method I've found that I've replaced it with `array_merge_recursive`\n<|/ c\
    \ |>\n<| a |>\n<code>\n$array = ['a', 'b', 'c', 'a', 'b', 'c'];\n$unique = array_unique($array);\n\
    </code>\n<|/ a dscore=5 tags=php,arrays,unique |>\n<| c |>\nThis actually doesn't\
    \ preserve the original keys.\n<|/ c |>\n<| a tags=php,arrays,unique dscore=5\
    \ |>\n<code>\n$array1 = array(\"a\"=>\"red\",\"b\"=>\"green\",\"c\"=>\"blue\"\
    );\n$array2 = array(\"d\"=>\"red\",\"e\"=>\"green\",\"f\"=>\"blue\");\n$result\
    \ = array_unique(array_merge($array1,$array2));\n</code>\n<|/ a |>\n<| c |>\n\
    array_merge_recursive is better for large arrays - as it keeps keys too\n<|/ c\
    \ |>", "    sort($l);\n    return $l;\n}", "    $a1 = array();\n    foreach($l\
    \ as $k => $v) {\n        $a1[$v]++;\n    }\n    $a2 = array();\n    foreach($a1\
    \ as $k1 => $v1) {\n        $a2[--$v1] = &$a1[$k1];\n    }\n    return $a2;\n}",
  "    return array_reduce(\n        $l,\n        function ($carry, $item) use ($l)\
    \ {\n            return $carry[$item] ? false : ($carry[$item] = true);\n    \
    \    },\n        array()\n    );\n}\n</code>\n<|/ a |>\n<| a tags=php,arrays |>\n\
    This question is kind of old, but maybe someone will find it useful.\nI wrote\
    \ this function that takes an array and a key as parameters, sorts the array by\
    \ the key, and removes duplicates and returns the result.\n<code>", "    sort($l);\n\
    \    return array_unique($l);\n}\n", "  $a = array();\n  $l = count($l);\n  if\
    \ ($l === 0) {\n    return $a;\n  }\n  for ($i = 0; $i < $l; ++$i) {\n    $a[$i]\
    \ = $l[$i];\n  }\n  for ($i = $l - 1; $i >= 0; --$i) {\n    $j = $i + 1;\n   \
    \ while ($j<$l && $a[$i] === $l[$j]) {\n      $j++;\n    }\n    if ($j<$l) {\n\
    \      $a[$i] = $l[$j];\n    }\n  }\n  return $a;\n}\n", "    return array_filter(array_unique($l));\n\
    }\n", "    $result = [];\n    foreach ($l as $v) {\n        if (!isset($result[$v]))\
    \ {\n            $result[$v] = $v;\n        }\n    }\n    return $result;\n}\n",
  "\t$u = [];\n\tforeach ($l as $v) {\n\t\tif (in_array($v, $u)) {\n\t\t\tcontinue;\n\
    \t\t}\n\t\t$u[] = $v;\n\t}\n\treturn $u;\n}\n", "  return array_unique(array_reverse($l));\n\
    }\n", "    $seen = array();\n    $out = array();\n    foreach ($l as $value) {\n\
    \        if (!in_array($value, $seen)) {\n            $seen[] = $value;\n    \
    \        $out[] = $value;\n        }\n    }\n    return $out;\n}\n", "  asort($l);\n\
    \  $u = array();\n  foreach ($l as $k => $v) {\n    if ( !in_array($v, $u) ) {\n\
    \      $u[] = $v;\n    }\n  }\n  return $u;\n}", "    if ($l == array()) return\
    \ $l;\n    $m = array();\n    foreach ($l as $e) {\n        if (!isset($m[$e]))\
    \ $m[$e] = $e;\n    }\n    return array_keys($m);\n}", "    $u = array();\n  \
    \  foreach ($l as $e) {\n        if ( ! in_array($e, $u)) {\n            $u[]\
    \ = $e;\n        }\n    }\n    return $u;\n}\n", "\t$l = array_map(\"unserialize\"\
    , array_unique(array_map(\"serialize\", $l)));\n\t$l = array_map(\"intval\", $l);\n\
    \treturn $l;\n}\n</code>\n<|/ a |>\n<| a tags=sorting,php,arrays |>\n<code>",
  "  $a = array_map(\"unserialize\", array_unique(array_map(\"serialize\", $l)));\n\
    \  return array_map(\"unserialize\", $a);\n}\n", "  $s = array();\n  foreach ($l\
    \ as $el) {\n    $el = (string)$el;\n    if (in_array($el, $s)) {\n      continue;\n\
    \    }\n    $s[] = $el;\n  }\n  return $s;\n}\n", "\treturn array_map(\n\t\tfunction\
    \ ($x) { return (int)$x; },\n\t\tarray_unique(array_map(\n\t\t\tfunction ($x)\
    \ { return (string)$x; },\n\t\t\t$l\n\t\t))\n\t);\n}\n", "  if (is_array($l) &&\
    \ count($l) == count($l)) {\n    return array_unique($l);\n  }\n}", "  return\
    \ array_keys(array_flip($l));\n}", "  if ($l instanceof Traversable) {\n    return\
    \ iterator_to_array($l);\n  }\n  $result = array();\n  foreach ($l as $e) {\n\
    \    if (! in_array($e, $result)) {\n      $result[] = $e;\n    }\n  }\n  return\
    \ $result;\n}\n\n", "  return call_user_func_array('array_unique', $l);\n}\n",
  "  $s = array_count_values($l);\n  arsort($s);\n  $l2 = array();\n  foreach ($s\
    \ as $k => $v) {\n    $l2[] = $k;\n  }\n  return $l2;\n}\n\n/**\n * Convert a\
    \ number to a string with up to three decimal places. Useful\n * for displaying\
    \ price range in a human readable format.\n */", "  return array_keys(array_flip($l));\n\
    }\n</code>\n<|/ a tags=sorting,php,arrays |>\n<| c |>\narray_flip() doesn't preserve\
    \ keys.\n<|/ c |>\n<| c |>\nNo it doesn't; it replaces them with the values of\
    \ the array and reverses them. `array_values(array_flip($array))` should work.\n\
    <|/ c |>\n<| c |>\nYou are correct. `array_flip` preserves keys, while `array_values`\
    \ doesn't. My mistake.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "    $o = array();\n\
    \    $l = array_reverse($l);\n    foreach($l as $k=>$v) {\n        if (!in_array($v,\
    \ $o)) {\n            $o[] = $v;\n        }\n    }\n    return array_reverse($o);\n\
    }", "    return array_filter(array_unique($l));\n}\n</code>\n<|/ a tags=arrays,php\
    \ dscore=5 |>\n<| a tags=arrays,php |>\nI always use array_unique:\n<code>\n<?php\n\
    $a = array(1, 5, 3, 6, 6, 3, 6, 8);\n\n$a = array_unique($a);\n\nprint_r($a);",
  "    $r = $l->to_array();\n    array_walk($r, function(&$x, $y) { $x = $y; }, null);\n\
    \    return array_unique($r);\n}\n", "  if (!is_array($l)) return $l;\n  return\
    \ array_unique(array_map(array('PhutilArrayIterator', 'toArray'), $l));\n}\n\n",
  "\t$a = array_map(\"unserialize\", array_unique(array_map(\"serialize\", $l)));\n\
    \treturn array_map(function($v){return unserialize($v);}, $a);\n}", "\treturn\
    \ array_filter($l, 'strnatcmp');\n}\n\n/**\n * Create a HTML link\n *\n * Creates\
    \ a simple html link that looks good on all browsers. It\n * includes an anchor\
    \ tag with an anchor text and optionally a target\n * attribute. The attribute\
    \ is intended for use with forms and\n * linking back to a web site. It is not\
    \ currently intended to be\n * used for any other semantic purposes.\n *\n * @author\
    \ Kalyptus SPRL <mao@kalyptus.biz>\n * @author Enrique Gonzalo <removed@example.com>\n\
    \ * @package Smarty\n * @subpackage Plugins\n */", "\t$unique = [];\n\tforeach\
    \ ($l as $e) {\n\t\tif (in_array($e, $unique)) continue;\n\t\t$unique[] = $e;\n\
    \t}\n\treturn $unique;\n}\n", "  $keys = array_keys($l);\n  $unique = [];\n  foreach\
    \ ($keys as $k) {\n    if (!in_array($l[$k], $unique)) {\n      $unique[] = $l[$k];\n\
    \    }\n  }\n  return $unique;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,php\
    \ |>\nThe array you provided is not ordered by value, so there's no way to get\
    \ an ordered array without sorting, which is a costly operation.\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\n<?php", "    $l = array_filter($l);\n    $l = array_map('unserialize',\
    \ array_unique(array_map('serialize', $l)));\n    return $l;\n}\n</code>\n<|/\
    \ a tags=arrays,php |>\n<| c |>\nThis was so much cleaner than my approach.\n\
    <|/ c |>\n<| a tags=arrays,php |>\nIf you're using php 5.3, you can use the array_filter\
    \ function:\n<code>\n$array = [1, 4, 5];\n$filtered = array_filter(\n    $array,\n\
    \    function ($value) {\n        return $value % 2 === 0;\n    }\n);\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI'm using the last version of PHP, and this seems\
    \ to work great.\n<|/ c |>\n<| c |>\nAh yes, I guess I should have mentioned that.\
    \ I'm glad you found it useful!\n<|/ c |>\n<| a dscore=4 tags=arrays,php |>\n\
    As an alternative, here is some code I use:\n<code>", "\t$a = array();\n\tforeach\
    \ ($l as $k => $v) {\n\t\tif (in_array($v, $a)) {\n\t\t\tunset($l[$k]);\n\t\t\
    } else {\n\t\t\t$a[] = $v;\n\t\t}\n\t}\n\treturn $l;\n}\n", "    $s = array();\n\
    \    foreach ($l as $v) $s[$v] = 1;\n    return array_keys($s);\n}\n", "    $sorted\
    \ = array();\n    $l = array_slice($l);\n    sort($l);\n    foreach ($l as $k\
    \ => $e) {\n        if ($sorted[$e] === true) {\n            continue;\n     \
    \   }\n        $sorted[$e] = true;\n        $r[] = $e;\n    }\n    return $r;\n\
    }\n", "    $a = array();\n    foreach ($l as $v) {\n        if (!in_array($v,\
    \ $a)) {\n            $a[] = $v;\n        }\n    }\n    return $a;\n}", "\t$sorted\
    \ = array_keys(call_user_func_array('array_merge', $l));\n\t$sorted = array_diff($sorted,\
    \ array_unique(array_keys($l)));\n\treturn $sorted;\n}", "    if (is_array($l))\
    \ {\n        return array_unique(array_map('trim', $l));\n    } else {\n     \
    \   return array_unique($l);\n    }\n}\n", "  if ($l == null) {\n    return array();\n\
    \  }\n  if (count($l) === 0) {\n    return $l;\n  }\n\n  $a = array_shift($l);\n\
    \  $seen = array($a);\n  $unique_a = array();\n  while ($a = array_shift($l))\
    \ {\n    if (in_array($a, $seen)) {\n      continue;\n    }\n    $seen[] = $a;\n\
    \    $unique_a[] = $a;\n  }\n  return $unique_a;\n}\n", "    $result = [];\n \
    \   foreach ($l as $v) {\n        if (! in_array($v, $result)) {\n           \
    \ $result[] = $v;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ dscore=0 |>\n<| a tags=php,arrays,sorting dscore=0 |>\nA solution that works\
    \ with nested arrays of arbitrary depth or arbitrary nesting.\nThe algorithm is\
    \ essentially a post-order traversal on a tree.\nIt is implemented as a function\
    \ that accepts an array of values to be sorted, and an optional array of the values\
    \ to be sorted. The function recurses as necessary to visit each of the values\
    \ to be sorted and sorts them using array_multisort. The results are returned\
    \ as an array of the sorted values. The first parameter is the array of values\
    \ to be sorted, which may be a single value or an array of values to be sorted.\
    \ The second parameter is the array of values to be sorted, which may be a single\
    \ value or an array of values to be sorted. These parameters may be omitted if\
    \ the second parameter is not an array.\nThe function uses the values from the\
    \ first array as the sort keys ($val1 is the first value in the array to be sorted,\
    \ $val2 is the second value) then it uses array_multisort to sort them in key\
    \ order. \nThe function works fine with single values or multi-valued arrays.\
    \ As long as the values being sorted can be cast into integers, strings, or DateTime\
    \ objects, it should be fine. Arrays that cannot be cast are ignored.\nThe function\
    \ also works for nested arrays and multi-valued arrays.\n<code>\n<?php\n\n$a =\
    \ [\n    5 => [1, 3],\n    2 => [2],\n    3 => [5],\n    9 => [2],\n    0 => [9,\
    \ 3],\n    123 => [9],\n];\n", "  if (!is_array($l)) {\n    return array();\n\
    \  }\n\n  $l = array_values($l);\n  sort($l);\n  $l = array_unique($l);\n\n  return\
    \ $l;\n}\n", "    $result = array();\n    $a = array();\n    foreach ($l as $e)\
    \ {\n        if ($e !== $result[0]) {\n            $result[] = $e;\n        }\
    \ else {\n            $a[$e] = 1;\n        }\n    }\n    foreach ($a as $k =>\
    \ $v) {\n        unset($result[$k]);\n    }\n    return $result;\n}\n</code>\n\
    <|/ a |>\n<| a tags=php,sorting,arrays,algorithm |>\nA very simple approach to\
    \ this problem is to create a map of each element to its position in the array.\
    \ Then when you sort the array, just sort each element in the map by its position\
    \ in the array then you can sort the map by key.\n<|/ a dscore=1 |>\n<| a |>\n\
    I thought of 2 approaches. Both of them were based on sorting. So I thought of\
    \ a different approach.\nApproach 1:\n<code>", "    return $l instanceof Traversable\n\
    \        ? iterator_to_array(new RecursiveIteratorIterator(new RecursiveArrayIterator($l),\
    \ RecursiveIteratorIterator::LEAVES_ONLY), false)\n        : preg_grep('/^[0-9]*$/',\
    \ $l);\n}\n", "    return array_unique(array_map('unserialize', array_unique(array_map('serialize',\
    \ $l))));\n}", "  return array_filter(array_unique(array_map('serialize', $l)));\n\
    }", "    return array_unique($l);\n}\n", "    return array_unique(call_user_func_array('array_merge',\
    \ array_map(null, $l)));\n}\n", "  $a = array();\n  foreach ($l as $e) {\n   \
    \ if (in_array($e, $a)) {\n      continue;\n    }\n    $a[$e] = 1;\n  }\n  return\
    \ array_keys($a);\n}\n", "    $a = array();\n    $l = strtolower($l);\n    foreach($l\
    \ as $i=>$e) {\n        $a[$i]=$e;\n    }\n    $n = count($a);\n    $i=0;\n  \
    \  $r = array();\n    foreach($a as $e) {\n        $r[] = $e;\n        if ($i++%$n==0)\
    \ {\n            sort($r);\n            $r[] = $a[$i];\n            $a[$i] = $e;\n\
    \        }\n    }\n    return $r;\n}\n", "  $r = array();\n  foreach ($l as $el)\
    \ {\n    if (!array_key_exists($el, $r)) {\n      $r[$el] = true;\n    }\n  }\n\
    \  return array_keys($r);\n}", "    if (!$l) return array();\n    $found = array();\n\
    \    foreach ($l as $item) {\n        if (!in_array($item, $found)) {\n      \
    \      $found[] = $item;\n        }\n    }\n    return $found;\n}\n</code>\n<|/\
    \ a tags=unique,arrays,php,sorting |>\n<| c |>\nHmm, `unique` is *not* a built-in\
    \ function in PHP. It appears in some other answers, but isn't a native function\
    \ in PHP. Maybe I missed it\n<|/ c |>\n<| c |>\nMy mistake, it's not in PHP7 (which\
    \ is what the OP asked for). Will fix the answer\n<|/ c |>\n<| a tags=unique,arrays,php,sorting\
    \ |>\nThis function returns a new array containing unique values.\n<code>", " \
    \ $a = array_unique($l);\n  sort($a);\n  return $a;\n}\n", "\t$unique = array();\n\
    \t$l = array_unique($l);\n\t$l = array_merge($l);\n\treturn $l;\n}", "\t$result\
    \ = array();\n\n\tforeach ($l as $item) {\n\t\tif (!in_array($item, $result))\
    \ {\n\t\t\t$result[] = $item;\n\t\t}\n\t}\n\n\treturn $result;\n}\n", "  $result\
    \ = [];\n  foreach ($l as $value) {\n    if (!array_key_exists($value, $result))\
    \ {\n      $result[$value] = $value;\n    }\n  }\n  return array_values($result);\n\
    }", "  if (!is_array($l)) {\n    throw new \\InvalidArgumentException('First argument\
    \ should be an array');\n  }\n\n  if (is_null($l)) {\n    return $l;\n  }\n\n\
    \  $a = array();\n  foreach ($l as $v) {\n    if ($v !== $a[$v]) {\n      $a[$v]\
    \ = $v;\n    }\n  }\n  return $a;\n}\n", "  return array_filter($l, function($k)\
    \ {\n    return in_array($k, $l);\n  });\n}", "    $result = array();\n    $l\
    \ = array_values($l);\n    usort($l, function ($a, $b) {\n        return $a -\
    \ $b;\n    });\n    foreach ($l as $v) {\n        $result[] = $v;\n    }\n   \
    \ return $result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis one worked for\
    \ me:\n<code>\n$ls = array_unique(array_merge($list1, $list2));\n</code>\n<|/\
    \ a tags=arrays,php,sorting dscore=1 |>\n<| c |>\nThis worked for me after sorting\
    \ on both arrays and then using this solution.  Thank you!\n<|/ c |>\n<| a tags=arrays,php,sorting\
    \ |>\nI believe you could just do:\n<code>", "  $a = array();\n  foreach($l as\
    \ $e) {\n    if (!in_array($e, $a)) $a[$e] = 1;\n  }\n  return array_keys($a);\n\
    }", "    if ($l instanceof Traversable) {\n        $l = iterator_to_array($l);\n\
    \    }\n\n    $a = array();\n    foreach ($l as $e) {\n        if (in_array($e,\
    \ $a)) continue;\n        array_push($a, $e);\n    }\n    return array_unique($a);\n\
    }\n", "    // Return unique elements by value\n    // >>> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n    // [0, 2, 3, 5, 9, 123]\n    return array_values(array_unique($l));\n\
    }\n", "  return array_unique($l);\n}\n", "    $s = array();\n    foreach($l as\
    \ $e) {\n        if (!in_array($e, $s)) $s[] = $e;\n    }\n    return $s;\n}\n",
  "    if ($l == NULL) return array();\n    $a = array();\n    foreach ($l as $e)\
    \ {\n        if (!in_array($e, $a)) {\n            array_push($a, $e);\n     \
    \   }\n    }\n    return $a;\n}", "  $s = $f = 0;\n  foreach($l as $v) {\n   \
    \ if(!isset($s[$v])) $s[$v] = $f++; \n  }\n  foreach($s as $k => $v) $l[$k] =\
    \ $v;\n  return array_unique($l);\n}\n", "    $l = array_keys($l);\n    $f = array_diff($l,\
    \ $l);\n    return array_unique($f);\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=sorting,php,arrays |>\nI really like ChrisF's answer, but I've found it\
    \ quite buggy when dealing with empty values. I solved it by replacing array_unique\
    \ with array_filter. This will remove empty values from $l. array_filter also\
    \ has a callback parameter which you can use, by which you can filter out empty\
    \ values. I also added a check to make sure that the array isn't empty - otherwise\
    \ array_filter will throw an error.\n<code>\n<?php"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
