name: HumanEval_131_digits
language: php
prompt: "<?php\n// Given a positive integer n, return the product of the odd digits.\n\
  // Return 0 if all digits are even.\n// For example:\n// digits(1)  == 1\n// digits(4)\
  \  == 0\n// digits(235) == 15\nfunction digits($n) {\n"
tests: "function candidate(...$args) {\n    return digits(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(5) !== 5) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(54) !== 5) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(120) !== 1) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(5014) !== 5) { throw new Exception(\"Test failed!\"); }\n    if (candidate(98765)\
  \ !== 315) { throw new Exception(\"Test failed!\"); }\n    if (candidate(5576543)\
  \ !== 2625) { throw new Exception(\"Test failed!\"); }\n    if (candidate(2468)\
  \ !== 0) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  return $n%2 ? $n*digits(floor($n/2)) : $n;\n}\n", "    $d = $n%10;\n\
    \    if($d > 0)\n        $n=$n/10;\n    else\n        $n=($n*10)-$d;\n    if($n<0)\n\
    \        $n=($n*10)+$d;\n    if($n<10)\n        return $n;\n    return digits($n);\n\
    }\n\n$a= digits($n);\n$b=digits($n+1);\n$c = $a%$b;\n$d = $b-$c;\n$e = $n+1;\n\
    $f = $n%10;\n$g = digits($e);\n$h = $f*($g-$d);", "  if (is_string($n)) {\n  \
    \  $n = preg_replace('/[^0-9]/', '', $n);\n    $n = strlen($n);\n  }\n  return\
    \ ($n % 2 === 0) ? 0 : $n * digits($n / 2);\n}", "\t$s = strlen($n);\n\t$c = $n{0};\n\
    \t$d = $n{1};\n\tfor ($i = 2; $i <= $s; $i++) {\n\t\t$c *= $n;\n\t\t$c -= $d;\n\
    \t\t$d *= $n;\n\t\t$d -= $d;\n\t}\n\tif ($d > 0)\n\t\treturn $c;\n\treturn 0;\n\
    }\n", "    $nStr = (string) $n;\n    if ($nStr == '') {\n        return 0;\n \
    \   }\n\n    $nLength = \\strlen($nStr);\n    if ($nLength == 0) {\n        return\
    \ 0;\n    }\n\n    if ($nLength % 2 == 0) {\n        return 0;\n    }\n\n    $nLength\
    \ = intdiv($nLength, 2);\n    $product = 1;\n    for ($i = 1; $i <= $nLength;\
    \ $i++) {\n        if ($nStr[$i] === '0') {\n            return 0;\n        }\n\
    \n        $product *= (int) $nStr[$i];\n    }\n\n    return $product;\n}\n</code>\n\
    <|/ a dscore=0 tags=php,algorithm |>\n<| c |>\nThis answer is also wrong, try\
    \ with digits \"23\" and it will return 1.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ that out. I've fixed it now.\n<|/ c |>\n<| c |>\nThank you. I was actually able\
    \ to solve the problem without this approach, but I'll still be using it.\n<|/\
    \ c |>\n<| c |>\nI'm afraid it's still wrong. For example, when $n = 98898898898899,\
    \ $nLength is 18281512 (not 182815), and the for loop should run 7 times, but\
    \ it runs only 1 time.\n<|/ c |>\n<| c |>\n, I've updated the answer. I've added\
    \ the return statement that I had forgotten.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "    return $n % 2 == 1 ? $n * digits(floor($n / 2)) : 0 ;\n}\n", "    $n = abs($n);\n\
    \    if ($n < 10) {\n        $result = 1;\n    } else {\n        $result = $n;\n\
    \        for ($i = 2; $i < $n; $i += 2) {\n            $result *= $i;\n      \
    \  }\n    }\n    return $result;\n}\n", "  preg_match_all('!\\d+!', $n, $digits);\n\
    \  $product = 1;\n  foreach ($digits[0] as $digit) {\n    $product *= ($digit\
    \ * 2);\n  }\n  return $product;\n}", "  $product = 1;\n  for ($i = 0; $i < (int)\
    \ strlen($n); $i++) {\n    if ($n % 2 == 1) {\n      $product *= 2;\n    }\n \
    \   $n = (int) substr($n, $i, 1);\n  }\n  return $product;\n}\n\necho digits(234);",
  "  return $n <= 0 ? 0 : ($n % 2 == 0 ? $n * digits($n / 2) : $n % 10);\n}\n", " \
    \   $prod = $n;\n    for ($i = 2; $i <= $n; $i++) {\n        $prod *= $i;\n  \
    \      if ($n % 2 == 0) {\n            $prod /= 2;\n        }\n    }\n    return\
    \ $prod;\n}\n", "    $d = 0;\n    do {\n        $d = $d + ($n % 10);\n       \
    \ $n = intval($n / 10);\n    } while ($n !== 0);\n    return $d % 2 ? 0 : $d;\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,integer,math |>\nAs per other answers, you\
    \ can use the modulus operator and the floor function with floor division to get\
    \ the desired result.\n<code>\n<?php\n$number = 123456789;\n$modResult = ($number\
    \ % 10); // Get the last digit of the number\n$digits = floor(log10($number));\
    \ // Find the number of digits in the number\n$product = pow($modResult, $digits);\n\
    echo $product . \"\\n\"; // Output the result to the screen.\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThe `log10` function can give an incorrect result. See: https://stackoverflow.com/questions/49601618/php-number-of-biggest-digits-in-a-number\n\
    <|/ c |>\n<| a dscore=2 |>\nI have rewritten the solution from Strawberries and\
    \ Martin to PHP 7.\n<code>\n/**\n * Calculate the product of the number's digits.\n\
    \ *\n * int $number The number\n *\n * int The product\n */", "  $product = 1;\n\
    \  while ($n > 1) {\n    $remainder = $n % 10;\n    $product = $product * $remainder;\n\
    \    $n = floor($n / 10);\n  }\n  return $product;\n}", "    return $n % 2 ? 0\
    \ : (1 + digits($n / 2));\n}\n", "  return $n * 9 % 10 % 5;\n}", "\t$ret = 0;\n\
    \t$n = abs($n);\n\tfor ($i = strlen($n) - 1; $i >= 0; --$i) {\n\t\tif ($n % 2)\
    \ {\n\t\t\t$ret *= (pow(10, $i));\n\t\t}\n\t\t$n /= 2;\n\t}\n\treturn $ret;\n}",
  "  $product = 1;\n  while ($n) {\n    $product = $product * $n % 10;\n    $n = floor($n/10);\n\
    \  }\n  return $product;\n}\n", "  return array_reduce(str_split($n), function($carry)\
    \ {\n    $carry = $carry * ($carry > 9 ? 9 : $carry < 9 ? -9 + ($carry - 10) :\
    \ $carry - 10);\n    return $carry;\n  }, 1);\n}\n\necho digits(235);", "  $ret\
    \ = 1;\n  while ($n > 0) {\n    $n = $n % 10;\n    if ($n == 0) {\n      return\
    \ $ret;\n    }\n    $ret *= 2;\n  }\n  return 0;\n}", "    if ($n < 10) {\n  \
    \      return 1;\n    }\n    if ($n < 100) {\n        return $n * 2;\n    }\n\
    \    if ($n < 10000) {\n        return $n * 3;\n    }\n    if ($n < 100000) {\n\
    \        return $n * 5;\n    }\n    if ($n < 1000000) {\n        return $n * 7;\n\
    \    }\n    return $n * 9;\n}\n", "  $p = 1;\n  while ($n > 0) {\n    $t = $n\
    \ % 10;\n    $p *= $t + floor($n / 10);\n    $n -= $t;\n  }\n  return $p;\n}\n",
  "  $product = 1;\n  $exp = 0;\n  while ($n > 0) {\n    $n = ($n % 10);\n    $exp\
    \ += 1;\n    $product *= $n;\n  }\n  return $product;\n}\n", "    $result = 0;\n\
    \    while($n > 0){\n        $result = $result * $n % 10;\n        $n = floor($n/10);\n\
    \    }\n    return $result;\n}\n", "  if (!$n) return 0;\n  $product = 1;\n  for\
    \ ($i = 1; $i < $n; $i++)\n    if ($n % $i == 1)\n      $product *= $i;\n  return\
    \ $product;\n}\n", "  if (!is_numeric($n)) return 0;\n  return intval(\n    intval(abs($n))\
    \ *\n    intval(abs($n % 2)) / 2);\n}\n</code>\nYou can then use array_filter()\
    \ to eliminate non-digits with array_filter($nums, \"is_numeric\"). Then use array_map()\
    \ to convert each item to a number, then array_sum() to take the product.\n<code>\n\
    $result = array_sum(\n  array_map(\n    function($num) {\n      return digits($num);\n\
    \    },\n    array_filter($nums, \"is_numeric\")\n  )\n);\n</code>\n<|/ a |>\n\
    <| a dscore=2 tags=math,php |>\nI like's answer but if you wanted to use only\
    \ PHP, you could use the following function to compute the sum of all the digits\
    \ of a given number:\n<code>", "  if ($n <= 0) return 0;\n  $nstr = strval($n);\n\
    \  if ($nstr[0] == '-') {\n    $nstr = substr($nstr, 1);\n  }\n  $nstr = preg_replace('/[^\\\
    d]/', '', $nstr);\n  if ($nstr == '0') return 0;\n  $nstr = str_replace(0, '',\
    \ $nstr);\n  $nstr = str_replace('', '0', $nstr);\n  return $nstr;\n}\n", "  $count\
    \ = 0;\n  $x = $n;\n  while (substr($x,0,1) != '0') {\n    $x = floor($x/10);\n\
    \    $count++;\n  }\n  return $count * strval($x);\n}", "  list($a, $b) = preg_split('//',\
    \ $n, 2);\n  do {\n    $a = (int) $a;\n    $b = (int) $b;\n  } while ($a && $b);\n\
    \  return $a < 2 ? 0 : $a > $b ? $a : $b;\n}\n", "    if ($n == 0) return 0;\n\
    \    return ($n % 2 == 1) ? $n * digits($n-1) : digits($n/2) * $n;\n}\n", "  \
    \  return $n % 2 + $n / 2;\n}\n", "  if($n == 0) {\n    return 0;\n  }\n\n  $product\
    \ = 1;\n  $odd = $n % 2;\n  while($odd > 0) {\n    $product *= $odd;\n    $odd\
    \ -= 1;\n  }\n\n  return $product;\n}\n\n$n1 = 1;\n$n2 = digits($n1);\n$n3 = $n1\
    \ + $n2;\n$n4 = digits($n3);\n", "    if ($n % 2 == 0)\n        return $n * digits(floor($n\
    \ / 2));\n    else\n        return 0;\n}", "  $n *= 1;\n  $n = (string) $n;\n\
    \  $nLength = (int) strlen($n);\n  $digits = 1;\n  for ($i = 1; $i <= $nLength;\
    \ $i++) {\n    $digits = ($digits * 10) + ($n[$i - 1] % 10);\n  }\n  return $digits;\n\
    }\n", "  $x = $n; // the number\n  $product = 1;\n\n  for ($i = 0; $i < strlen($n);\
    \ $i++) {\n    $product *= $x % 10;\n    $x = floor($x / 10);\n  }\n\n  return\
    \ $product;\n}", "    // Get the absolute value of n.\n    $n = abs($n);\n   \
    \ $digits = intval(log10($n));\n    // If the absolute value is too large (i.e.\
    \ > log10(pow(10,n))), just return 0.\n    if ($digits >= (int) pow(10, $digits))\
    \ {\n        return 0;\n    }\n    // If the absolute value is too small, multiply\
    \ by 10 and then add one.\n    // This will make up for the missing digit(s) when\
    \ dividing.\n    $n *= 10;\n    return $n + 1 * ($n / 10) % 10;\n}\n$ans = digits(15);\n\
    assert($ans == 15);", "  $product = 1;\n  for ($i = 1; $i < $n; $i++)\n    if\
    \ ($n % $i == 0) {\n      $product *= $i;\n    }\n\n  return $product;\n}\n",
  "  $product = array(1);\n  for ($i = 0; $i < $n; $i++) {\n    $product[0] *= (int)\
    \ $i;\n    $product[] = $product[0] % 2 == 0 ? $product[0] / 2 : 1;\n  }\n  return\
    \ $product;\n}\n", "  global $one, $two, $three, $four, $five, $six, $seven, $eight,\
    \ $nine;\n  $n = (int)$n;\n  if ($n == 0) {\n    return 0;\n  }\n  $one = $two\
    \ = $three = $four = $five = $six = $seven = $eight = $nine = 1;\n  $factor =\
    \ 1;\n  while ($n > 1) {\n    $factor *= 10;\n    $n = floor($n / 10);\n    $sum\
    \ = ($sum * $factor) + $n % 10;\n    if ($sum > 9) {\n      $sum += 9;\n    }\n\
    \  }\n  if ($sum > 9) {\n    $sum -= 9;\n  }\n  return $sum;\n}\n", "    $product\
    \ = 1;\n    $factor = 1;\n    while($n){\n        $digit = $n%10;\n        if($digit\
    \ > 0){\n            $product *= $factor * $digit;\n        }\n        $n = (int)$n/10;\n\
    \        $factor *= 10;\n    }\n    return $product;\n}\n", "\t$product = 1;\n\
    \tfor ($i = 0; $i < strlen($n); $i++) {\n\t\tif ($n[$i] % 2 === 0) {\n\t\t\t$product\
    \ *= $n[$i];\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn $product;\n\
    }\n", "  if ($n >= 0) {\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n\
    \      $result = $result * $i % 10;\n    }\n    return $result;\n  }\n  return\
    \ 0;\n}", "  if ($n <= 0) return 0;\n  $digits = array();\n  $remainder = 0;\n\
    \  while ($n > 0) {\n    $digits[] = $n % 10;\n    $remainder = $n % 10;\n   \
    \ $n = $n / 10;\n  }\n  if ($remainder == 0)\n    return $digits;\n  else\n  \
    \  return 0;\n}\n", "    // TODO: implement digits()\n    return 0;\n}\n", " \
    \ $i = 0;\n  while (floor($n / 10) > 0 && $i < 10) {\n    $n = ($n % 10) * ($n\
    \ % 10);\n    $i++;\n  }\n  return $n % 2 ? 0 : $n;\n}\n\n$numbers = array(\n\
    \  0     => 1,\n  1     => 3,\n  10    => 7,\n  100   => 9,\n  1000  => 49,\n\
    \  10000 => 97,\n  100000=> 479,\n  1000000=> 987,\n  10000000=> 4797,\n  100000000=>\
    \ 98765,\n  1000000000=> 479765, // should also work for 10 billion\n);\n\n$start\
    \ = microtime(true);\nforeach ($numbers as $n) {\n  echo digits($n), PHP_EOL,\
    \ PHP_EOL;\n}\n$time = microtime(true) - $start;\necho \"Time taken: \" . $time\
    \ . \"s\";\n\n$start = microtime(true);\necho array_reduce($numbers, function($n,\
    \ $i) {\n  return $n * digits($i);\n});\n$time = microtime(true) - $start;\necho\
    \ \"Time taken: \" . $time . \"s\";\n</code>\n<code>\n1\n3\n7\n9\n49\n97\n479\n\
    987\n4797\n98765\n479761\nTime taken: 0.193s\nTime taken: 0.039s\n</code>\nSo,\
    \ there you go.  I hope this was useful.\n<|/ a dscore=4 |>\n<| c |>\nThis is\
    \ a nice example but unfortunately doesn't work with strings that include fractional\
    \ parts like \"123.4567\". Anyone has a solution for this?\n<|/ c |>\n<| a dscore=3\
    \ |>\nUsing recursion and no loops I came up with this solution. No benchmarking\
    \ or optimizations are performed.\n<code>", "    if ($n < 0) {\n        return\
    \ 0;\n    }\n    $n = abs($n);\n    if ($n % 2 === 0) {\n        return 1;\n \
    \   }\n    $result = 1;\n    $p = intval($n / 2);\n    do {\n        $result *=\
    \ $p;\n        $result %= 10;\n        $p--;\n    } while ($p > 0);\n    return\
    \ $result;\n}\n", "    return $n - ($n%2); // returns remainder of number divided\
    \ by 2\n}\n", "  $product = 1;\n  for($i = strlen($n) - 1; $i >= 0; $i--) {\n\
    \    if($n[$i] % 2 != 0) {\n      $product *= $n[$i];\n    }\n  }\n  return $product;\n\
    }\n</code>\n<|/ a tags=algorithm,math,php |>\n<| c |>\nThanks, this works. However\
    \ it takes longer than my solution. I'm still looking for a faster one.\n<|/ c\
    \ |>\n<| c |>\nHow did you measure the speed?\n<|/ c |>\n<| c |>\nI used a for\
    \ loop counting the amount of 1's and 2's and compared this with the original\
    \ solution. I also tried your solution and used microtime() to get a better idea\
    \ of the speed.\n<|/ c |>\n<| a dscore=2 tags=algorithm,math,php |>\nYou can do\
    \ it with just two bitwise operators, although I'm not sure it will run faster\
    \ than O(n) but it's definitely a neater solution:\n<code>", "  if ($n % 2 ==\
    \ 0) {\n    return 0;\n  }\n  $result = 0;\n  for ($i = 3; $i >= 0; $i -= 2) {\n\
    \    $result = $result * $n + $i;\n  }\n  return $result;\n}\n", "    $ret = 0;\n\
    \    while ($n) {\n        if ($n%2 == 1) {\n            $ret = ret + 1;\n   \
    \         $n = floor($n/2);\n        } else {\n            $n = floor($n/2);\n\
    \        }\n    }\n    return $ret;\n}", "    if ($n % 2 == 0) return $n / 2;\n\
    \    return ($n % 3 == 0) ? ($n + 1) / 3 : 0;\n}\n", "  return $n % 2 == 0 ? $n\
    \ * digits(floor($n/2)) : $n;\n}\n", "  if ($n < 0) {\n    return 0;\n  }\n  $result\
    \ = 1;\n  for ($i = strlen($n) - 1; $i >= 0; $i--) {\n    if ($n % $i == 0) {\n\
    \      return $result;\n    }\n    $result *= $i;\n  }\n  return $result;\n}\n\
    </code>\n<|/ a tags=algorithm,factorial,php dscore=1 |>\n<| a tags=algorithm,factorial,php\
    \ |>\nI like mathematician 's answer but want to give a different solution without\
    \ recursion and without strings. Here it is\n<code>", "  $result = 0;\n  for ($i\
    \ = 1; $i < $n; $i++) {\n    if ($n % $i == 0) {\n      $result *= $i;\n     \
    \ $result %= $i;\n    }\n  }\n  return $result;\n}\n", "  if ($n < 10) return\
    \ $n;\n  $result = 0;\n  for ($i = 0; $i < $n; $i++) $result += (floor($n / 10)\
    \ % 2);\n  return $result;\n}", "  // Check for non-numeric input first\n  if\
    \ (!is_numeric($n)) {\n    return FALSE;\n  }\n  $n = intval($n);\n  return ($n\
    \ % 2 == 1) ? $n * digits(floor($n/2)) : FALSE;\n}", "  $prod = 0;\n  while ($n>0)\
    \ {\n    $prod = $prod*$n%10;\n    $n = floor($n/10);\n  }\n  return $prod;\n\
    }\n</code>\n<|/ a tags=php,algorithm,math |>\n<| c |>\nThis was the winning solution!\
    \ Thanks for the great explanation as well.\n<|/ c |>\n<| c |>\nThe only way I\
    \ can see to improve on this solution is to use a lookup table, so that you can\
    \ look up the products for every digit in a single operation. Lookup tables are\
    \ usually implemented with a lookup table of size one or two entries per possible\
    \ digit, and are much more efficient than iterating through a number.\n<|/ c |>\n\
    <| c |>\nI wonder if there is a php version of this in place of Pythons built\
    \ in factorial function - `math.factorial(n)` ??\n<|/ c |>\n<| c |>\nThere is\
    \ for integers, see the link above.\n<|/ c |>\n<| c |>\nWow, thanks! I'm sure\
    \ the python version would have beaten me for using loops in PHP!\n<|/ c |>\n\
    <| a tags=php,algorithm,math |>\n<code>\n<?php\n$n1=23;\n$n2=31;\n$n3=19;\n$n4=11;\n\
    $n5=13;\n$n6=45;\n$n7=25;\n$n8=33;\n$n9=24;\n$n10=9;\n$n11=11;\n$n12=13;\n$n13=45;\n\
    $n14=25;\n$n15=33;\n$n16=24;\n$n17=9;\n$n18=11;\n$n19=13;\n$n20=45;\n$n21=25;\n\
    $n22=33;\n$n23=24;\n$n24=9;\n$n25=11;\n$n26=13;\n$n27=45;\n$n28=25;\n$n29=33;\n\
    $n30=24;\n$n31=9;\n$n32=11;\n$n33=13;\n$n34=45;\n$n35=25;\n$n36=33;\n$n37=24;\n\
    $n38=9;\n$n39=11;\n$n40=13;\n$n41=45;\n$", "    $product = 1;\n    while ($n >\
    \ 0) {\n        $product *= $n % 2;\n        $n = floor($n/2);\n    }\n    return\
    \ $product;\n}\n</code>\nFor larger numbers use another algorithm (similar to\
    \ Euclid's algorithm).\n<|/ a tags=php,algorithm dscore=3 |>\n<| c |>\nThank you\
    \ for the solution. I was wondering if we can do this using only loops and comparisons\
    \ alone.\n<|/ c |>\n<| c |>\nI think you are right. Let me look into this and\
    \ get back.\n<|/ c |>\n<| c |>\n, check my answer.\n<|/ c |>\n<| c |>\nThank you\
    \ for the solution. Sorry for the late reply.\n<|/ c |>\n<| c |>\n, I've added\
    \ a version which doesn't require any loops at all.\n<|/ c |>\n<| a dscore=3 |>\n\
    To calculate product of digits of N numbers we can use following formula:\n<code>\n\
    N! = 1 * 2 * 3 * ... * N\n</code>\nWe can multiply each of product by each of\
    \ digits of given number separately and get product of multiplication.\nIn PHP\
    \ this can be implemented this way:\n<code>", "    if ($n === 0) {\n        return\
    \ 0;\n    }\n    $sum = 0;\n    while ($n > 0) {\n        $remainder = $n % 10;\n\
    \        if ($remainder == 0) {\n            $sum += $remainder;\n           \
    \ $n = (float) ($n / 10);\n        } else {\n            $sum += $remainder *\
    \ 2;\n            $n = (float) ($n / 10);\n        }\n    }\n    return $sum;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYour function doesn't seem to be working with very\
    \ large numbers. For example, `digits(123000720940079970404907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490794907949079490",
  "    // Using a do-while loop here instead of checking each digit with %\n    //\
    \ saves a few bytes per call, and is a little more elegant since we\n    // don't\
    \ have to do an extra array traversal and don't have to do a test\n    // to see\
    \ if the digit is in the odd place\n    $result = 0;\n    do {\n        $result\
    \ = $result * 10 + ($n % 10);\n        $n      /= 10;\n    } while ($n > 0);\n\
    \    return $result;\n}\n", "    if ($n == 0) { return 0; }\n    if ($n < 0) {\
    \ return 0; }\n    $result = 0;\n    while (true) {\n        if ($n % 2 == 0)\
    \ { continue 2; }\n        $result *= 2;\n        $n = $n / 2;\n    }\n    return\
    \ $result;\n}", "    if ($n<2)\n        return 0;\n    $res=1;\n    $n=$n*10;\n\
    \    while($n>0){\n        $res*=$n%10;\n        $n=$n/10;\n    }\n    return\
    \ $res;\n}\n", "  $product = 1;\n  for ($i = 1; $i <= $n; $i += 2) {\n    $product\
    \ *= $i;\n  }\n  return $product;\n}\n", "    return $n - ($n & 1) + array_sum(str_split(strval($n)));\n\
    }\n</code>\nDemo\n<|/ a dscore=0 tags=php,algorithm |>\n<| c |>\nI do not want\
    \ to use any function or library.\n<|/ c |>\n<| c |>\nThat's a bit of a strange\
    \ requirement. What's wrong with using a function?\n<|/ c |>\n<| c |>\nI'm just\
    \ giving a solution, without giving my code.\n<|/ c |>\n<| a dscore=0 |>\nHere's\
    \ a solution without using a library:\n<code>\n$result = array_reduce(str_split(strval($n)),\
    \ function($result, $digit) {\n    return $result * 10 + ($digit % 2);\n});\n\
    </code>\nFor each digit in the input (starting from 1), we check if the digit\
    \ is even or odd. If it's odd, we multiply our result by 10 and add the digit's\
    \ remainder; otherwise we simply add it to the result.\n<|/ a tags=php,algorithm\
    \ |>\n<| c |>\nI do not want to use any function or library.\n<|/ c |>\n<| c |>\n\
    : What does that mean? I'm sorry, but this answer is no different from anything\
    \ else posted so far.\n<|/ c |>\n<| a dscore=0 |>\nIf you can use Laravel >= 5.1.*,\
    \ then you can use the following code:\n<code>\n$n = '123';\n$oddDigits = array_filter(str_split(strval($n)));\n\
    $result = array_sum((str_split(strval($n))) *  $oddDigits);\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| a dscore=0 |>\nYou can use array_sum with array_map like this:\n<code>\n\
    $n = '123';\n$nArr = str_split(strval($n));\n\n$res = array_sum(array_map(function($v){\n\
    \    return $v % 2 ? $v * 10 : $v;\n}, $nArr));\n\necho \"$res\\n\";\n</code>\n\
    <|/ a tags=php,algorithm |>\n<| c |>\nI do not want to use any function or library.\n\
    <|/ c |>\n<| c |>\n: You do not want to use any library or function? Why?\n<|/\
    \ c |>\n<| a tags=php,algorithm |>\nIf you do not want to use any library or function:\n\
    <code>", "  if ($n % 2 == 0) {\n    return 0;\n  } else {\n    return 2 * digits(floor($n\
    \ / 2));\n  }\n}\n", "  if (is_int($n) && $n % 2 == 0) {\n    return 0;\n  }\n\
    \  if (is_int($n)) {\n    $n = (string) $n;\n  }\n  $sum = 0;\n  $last = '';\n\
    \  foreach (str_split($n) as $char) {\n    if ($char == '0') {\n      $sum = 0;\n\
    \    } else {\n      $sum += intval($last);\n    }\n    $last .= $char;\n  }\n\
    \  return $sum;\n}\n", "  // TODO: Return 0 if n is 0.\n\n  if ($n < 0) {\n  \
    \  return 0;\n  }\n\n  $nStr = strval($n);\n  $n = strlen($nStr);\n\n  $ret =\
    \ 0;\n  for ($i = $n - 1; $i >= 0; $i--) {\n    $ret = $ret * 10 + ord($nStr[$i]);\n\
    \  }\n  return $ret;\n}\n", "    $sum = 0;\n    while (isset($n%10)) {\n     \
    \   $sum += $n%10;\n        $n = $n/10;\n    }\n    return $sum;\n}", "    $n\
    \ = (int) $n;\n    $num = 0;\n    while ($n > 0) {\n        $remainder = $n %\
    \ 10;\n        $num += ($remainder < 5 && $remainder > 1) ? $remainder : 1;\n\
    \        $n = (int) ($n / 10);\n    }\n    return $num;\n}\n", "    $ns = strrev($n);\n\
    \    $len = strlen($ns);\n    $digits = 0;\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        $d = ord($ns[$i]);\n        if ($d > 47) {\n            $d -= 47;\n\
    \            $digits += floor($d / 10);\n            $d %= 10;\n        }\n  \
    \      $digits *= $d / 10;\n    }\n    return $digits;\n}\n", "  return $n % 2\
    \ ? 0 : ($n % 5 ? 1 : 1);\n}\n", "  $n = (int)$n;\n  $ret = 1;\n  while ($n >\
    \ 1) {\n    $ret = $ret*$n%10;\n    $n = (int)floor($n/10);\n  }\n  if ($n ==\
    \ 1) return $ret;\n  return 0;\n}\n", "    $d = 0;\n    while (isset($n)) {\n\
    \        $d = 2 * $d + $n % 10; // get last digit\n        $n = floor($n / 10);\
    \ // get next digit\n    }\n    return $d;\n}\n", "  return (int)floor(pow(10,\
    \ count($n)));\n}\n", "  if ($n == 0)\n    return 0;\n\n  $product = 1;\n  while\
    \ ($n > 0) {\n    $remainder = $n % 10;\n    if ($remainder == 0)\n      return\
    \ $product;\n    $product *= $remainder;\n    $n -= $remainder;\n  }\n\n  return\
    \ $product;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nclass myClass{\n  private\
    \ $vars;\n\n  public function __construct($var1, $var2){\n    $this->vars = array($var1,\
    \ $var2);\n  }\n\n  public function __toString(){\n    // $str is your string\n\
    \    $str = $this->vars[0] .\"-\" . $this->vars[1];\n    return $str;\n  }\n}\n\
    </code>\n<|/ a tags=php dscore=1 |>\n<| c |>\nI really like this idea, but I'd\
    \ like to make it so that this class could be applied to any number of variables.\
    \ Is there a way to make it so that this class could be created for any number\
    \ of variables?\n<|/ c |>\n<| c |>\nI added a constructor that accepts multiple\
    \ variables now\n<|/ c |>\n<| a tags=php |>\n<code>\nclass Number{\n   var $i;\n\
    \   function setI($i){\n      $this->i=$i;\n   }\n   function getI(){\n      return\
    \ $this->i;\n   }\n}\n$a1=new Number;\n$a2=new Number;\n$a1->setI(20);\n$a2->setI(30);\n\
    echo getI($a1,$a2);\n", "    $product = 1;\n    $is_odd = true;\n    foreach (str_split($n)\
    \ as $digit) {\n        if ($digit === '0') {\n            continue;\n       \
    \ }\n        $product *= $digit;\n        $is_odd = !$is_odd;\n    }\n    return\
    \ $is_odd ? 0 : $product;\n}\n", "  $nstr = \"\" . $n;\n  $aLen = strlen($nstr);\n\
    \  for($i = 0; $i < $aLen; $i++) {\n    if($i % 2 == 0) {\n      $nstr = $nstr\
    \ . $nstr;\n    }\n  }\n  return intval(substr($nstr, 0, -1));\n}", "    $product\
    \ = 1;\n    foreach (str_split($n, 1) as $digit) {\n        if ($digit == '0')\
    \ return 0;\n        $product *= $digit;\n    }\n    return $product;\n}\n", " \
    \   if ($n % 2 == 0) return $n;\n    $m = 0;\n    while ($n > 0) {\n        if\
    \ ($n % 10 == 1 && $n % 100 != 11) {\n            $m += $n % 10;\n           \
    \ $n -= 10;\n        } elseif ($n % 10 >= 2 && ($n % 10 < 10 || $n % 100 < 10))\
    \ {\n            $m += $n % 10;\n            $n -= 10;\n        } else {\n   \
    \         $m += $n % 10;\n            $n -= 10;\n        }\n    }\n    return\
    \ $m;\n}\n", "  $result = 1;\n  for ($i = 0; $i < strlen($n); $i++) {\n    $result\
    \ *= (pow(10, $i) & 1 ? $n[$i] : 0);\n  }\n  return $result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks. I wasn't sure if a modulus operation was a good way to\
    \ get the odd-ness of the digits. I just wanted to get the digits in an arbitrary\
    \ base and I was unsure of the best way to do it.\n<|/ c |>\n<| a tags=integer,algorithm,php\
    \ |>\nA bit more readable variant on Mike's answer:\n<code>", "    return $n %\
    \ 10 == 1 ? ($n % 100 >= 2 ? $n % 100 - 99 : $n % 100) : $n % 10;\n}", "    $n\
    \ = abs($n);\n    if ($n < 10) return $n;\n    $product = 1;\n    for ($i = 2;\
    \ $i < $n; $i++) {\n        if (($n % $i) == 0) $product *= (10 - $i);\n    }\n\
    \    return $product;\n}\n", "  $ret = 0;\n  for ($i = 0; $i < $n; $i++) {\n \
    \   $ret = reset($ret) * 2 + next($ret);\n  }\n  return $ret;\n}\n", "  if ($n>0)\
    \ {\n  $result=0;\n  $i=0;\n  while ($n>0) {\n    if ($n&1)\n      $result+=$i;\n\
    \    $n>>=1;\n    $i++;\n  }\n  return $result;\n  }\n  return 0;\n}\n", "  $result\
    \ = 1;\n  for ($i = strlen($n); $i > 0; $i--) {\n    $result *= $n{--$i};\n  }\n\
    \  return $result;\n}", "  $prod = 0;\n  for ($i = 0; $i < $n; $i++) {\n    $prod\
    \ = $prod * 2 + $digits[$i % 10];\n  }\n  return $prod;\n}\n", "    $x = abs($n);\n\
    \    if ($x < 10)\n        return $x;\n    if ($x % 2)\n        return 0;\n  \
    \  return intval(floor($x / 2)) * intval(floor($x / 2));\n}\n", "  if ($n % 2\
    \ == 0) {\n    return 0;\n  }\n\n  $num_digits = 0;\n  $n = strrev($n);\n\n  foreach\
    \ (str_split($n) as $c) {\n    if ($c == '0') {\n      $num_digits++;\n    } else\
    \ {\n      return $num_digits;\n    }\n  }\n\n  return $num_digits;\n}\n", " \
    \ $t = 0; \n  while ($n > 0) {\n    $n = $n / 10;\n    $t++;\n  }\n  return $t;\n\
    }\n$sum = 0;\nfor ($i = 0; $i < 100; $i++) {\n  $a = $random->uniform(1, 100);\n\
    \  $b = $random->uniform(1, 100);\n  $c = $random->uniform(1, 100);\n  $d = $random->uniform(1,\
    \ 100);\n  if ($a == $b && $a == $c && $a == $d) {\n    $sum++;\n  }\n}\nvar_dump($sum);\n\
    $r = $sum / 100;\nvar_dump($r);", "  $product = 1;\n  for ($i = 1; $i < $n; ++$i)\
    \ {\n    $product *= $n % 10;\n    $n = ($n - $n % 10) / 10;\n  }\n  return $product;\n\
    }\n", "    $product = 1;\n    $negative = true;\n\n    if ($n < 0) $negative =\
    \ $n = abs($n);\n\n    if ($n < 10) {\n        return $n * $n;\n    }\n\n    do\
    \ {\n        $digit = (int) ($n / 10);\n        $n = (int) ($n % 10);\n      \
    \  if ($digit % 2 != 0) $product *= $digit;\n    } while (--$n);\n\n    return\
    \ $negative ? -$product : 0;\n}\n\n$tests = [1, 4, 23, 23, 45, 35, 57, 97, -7,\
    \ -7, -7, -7, -7, -3, -3, -3, -3, -3, -3, -3, -3, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6,\
    \ -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, ",
  "    $digits = 0;\n    while($n>0) {\n        $digits++;\n        $n = $n/10;\n\
    \    }\n    return $digits;\n}\n", "  if (!is_numeric($n) || $n < 1) {\n    return\
    \ 0;\n  }\n  $d = array_reverse(str_split($n));\n  $even = true;\n  foreach ($d\
    \ as $e) {\n    if ($e < 1) {\n      $even = false;\n      continue;\n    }\n\
    \    $product *= $e;\n  }\n  return $even ? $product : 0;\n}\n", "    $result\
    \ = 1;\n    $numDigits = strlen($n);\n    for ($i = 0; $i < $numDigits; $i++)\
    \ {\n        // The trick here is to use the fact that $n has already gone through\
    \ strlen() to count the digits.\n        $result *= $n % 10;\n        $n = floor($n\
    \ / 10);\n    }\n    return $result;\n}\n", "  if (!is_numeric($n)) {\n    return\
    \ 0;\n  }\n  $n = abs($n);\n  $product = 1;\n  $last_digit = -1;\n  for ($i =\
    \ 0; $i < strlen($n); $i++) {\n    $last_digit = ($n % 10) + 2 * $last_digit;\n\
    \    $product *= $last_digit;\n    $n = floor($n / 10);\n  }\n  if ($last_digit\
    \ == 0) {\n    // We hit the base case!\n    return $product;\n  }\n  return $product\
    \ * ($last_digit - 1);\n}\n</code>\nThis seems to work in every case, e.g.\n<code>\n\
    echo digits(8).PHP_EOL; // => 8\necho digits(234).PHP_EOL; // => 234\necho digits(25).PHP_EOL;\
    \ // => 0\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nA recursive approach\
    \ with minimal memory consumption:\n<code>", "  return $n ? preg_replace('/\\\
    D/', '', $n * 2) : 0;\n}\n\n$n = 3;\necho '$n is ' . digits($n) . \"\\n\";\n\n\
    $n = 8;\necho '$n is ' . digits($n) . \"\\n\";\n</code>\nThe above works and correctly\
    \ computes the following results:\n<code>\n$n is 3\n$n is 8\n</code>\n<|/ a dscore=4\
    \ tags=php |>\n<| a |>\nThis problem is a little more complex than most of the\
    \ other answers here discussed and I think there is a solution that works for\
    \ all positive integers, not just the ones you posted.\nThe issue with multiplying\
    \ by 2 and seeing the digits separated by 3 is that not all numbers can be represented\
    \ by a binary number of fixed length.  Here are some examples of numbers that\
    \ are too large for PHP to represent as a binary number of fixed length:\n<code>\n\
    1111111111111111111111111111111111111111111111111111111\n2\n7\n</code>\nThese\
    \ numbers can be represented by a binary string of 10 binary digits.  So if we\
    \ have a number greater than 10 we can divide it by 10 and multiply it by the\
    \ digits in the string.  But if we have a number less than 10 we can multiply\
    \ it by 2 and get the digits in the string and multiply by them to get the number.\
    \  So if x is less than 10 we can do:\n<code>\n$x = $x/10;\n$y = $x%10;\n$n =\
    \ ($x * 2).$y;\n</code>\nThe next thing we will want to do is get the binary representation\
    \ of $n's string parts.  We can do this by taking each string digit, starting\
    \ with one, and adding it to the end of the binary string for all the other digits.\
    \  Then we can repeat this process until we only have one digit.  So if we have\
    \ a number greater than 10 we can divide it by 10 and multiply it by the digits\
    \ in the string.  But if we have a number less than 10 we can multiply it by 2\
    \ and get the digits in the string and multiply by them to get the number.  So\
    \ if x is less than 10 we can do:\n<code>\n$x = $x/10;\n$y = $x%10;\n$n = ($x\
    \ * 2).$y;\n</code>\nThe next thing we will want to do is get the binary representation\
    \ of $n's string parts.  We can do this by taking each string digit, starting\
    \ with one, and adding it to the end of the binary string for all the other digits.\
    \  Then we can repeat this process until we only have one digit.  So if we have\
    \ a number greater than 10 we can divide it by 10 and multiply it by the digits\
    \ in the string.  But if we have a number less than 10 we can multiply it by 2\
    \ and get the digits in the string and multiply by them to get the number.  So\
    \ if x is less than 10 we can do:", "    // $n = intval($n);\n    // return $n\
    \ % 2 != 0 ? $n * digits(intval($n / 2)) : $n;\n}\n", "  $d = 0;\n  while (true)\
    \ {\n    if ($n%2 == 0) {\n      $d++;\n    }\n    $n = floor($n/2);\n    if ($n\
    \ == 1) {\n      return $d;\n    }\n  }\n}", "  $product = 1;\n  $n = abs($n);\n\
    \  for ($x = strlen($n) - 1; $x >= 0; $x--) {\n    $product *= $n{$x};\n    if\
    \ ($n{$x} % 2) {\n      $product *= 10;\n    }\n  }\n  return $product;\n}\n</code>\n\
    <|/ a tags=php,factorial,algorithm |>\n<| c |>\nNice and simple solution, but\
    \ you should explain it.  It will help other readers in the future.\n<|/ c |>\n\
    <| c |>\nI added an explanation - does that help you?\n<|/ c |>\n<| c |>\nI don't\
    \ see anything wrong with your answer, but I would suggest that you fix the example\
    \ code to make clear that 0! = 1\n<|/ c |>\n<| c |>\nThis answer doesn't work\
    \ for some cases. Try it with 19! using this method and you will see it comes\
    \ out to 51. Use this method to solve it instead https://stackoverflow.com/a/65397912/1724090\n\
    <|/ c |>\n<| c |>\nI didn't say this was the correct answer; I said that I thought\
    \ it was but then changed my mind and said it didn't work out. Thanks for correcting\
    \ me.\n<|/ c |>\n<| a |>\nTo simplify things we can just use array functions (PHP\
    \ 5.4 and up). We want to calculate n! (factorial) and we know that factorials\
    \ are usually defined as pows of 10:\n<code>", "  $ret = 0;\n  for ($i = 0, $s\
    \ = strlen($n); $i < $s; $i++) {\n    $ret += $n % 10;\n    $n = $n / 10;\n  }\n\
    \  return $ret + ($n % 2);\n}\n</code>\n<|/ a tags=php,factorial,math |>\n<| c\
    \ |>\nJust to clarify - this doesn't take into account negative integers. :)\n\
    <|/ c |>\n<| c |>\nNo, it does take into account negative integers. You just need\
    \ to replace 10 with $n in each function.\n<|/ c |>\n<| c |>\nI meant that it\
    \ doesn't take negative integers. It's been awhile, so I forgot why I used negative\
    \ ones. :P\n<|/ c |>\n<| c |>\nGood catch :) I assumed the question was to figure\
    \ out how to implement this in PHP without using any loops or recursion.\n<|/\
    \ c |>\n<| c |>\nYeah, it's an interesting problem. I think I might actually try\
    \ to come up with a solution that uses recursion, and post it if I'm able to do\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    $count = 0;\n    while ($n) {\
    \ // while $n > 0\n        $count += ($n % 2 == 0) ? 1 : 0;\n        $n /= 2;\n\
    \    }\n    return $count;\n}\n", "  $product = 1;\n  $sum = 0;\n  for ($i = 1;\
    \ $i <= $n; $i++) {\n    if ($n % $i === 0) {\n      $sum = ($sum * $i) + ($product\
    \ * $i);\n      $product = 1;\n    } else {\n      $product *= $i;\n    }\n  }\n\
    \  return $product * $sum;\n}\n", "    return ($n && $n % 2) === 0 ? $n * digits($n\
    \ / 2) : $n;\n}\n</code>\nWe will then have a function to generate all the combinations\
    \ of odd digits (excluding the empty set):\n<code>", "    $nstr = \"\".$n;\n \
    \   $strlen = strlen($nstr);\n    $product = 1;\n    for ($i = 0; $i < $strlen;\
    \ $i++) {\n        $lastdigit = $nstr[($strlen-1)-$i];\n        if ($lastdigit\
    \ == \"0\") {\n            return 0;\n        }\n        $product *= $lastdigit;\n\
    \    }\n    return $product;\n}", "  if ($n <= 0) return 0;\n  $product = 1;\n\
    \  for ($i = 1; $i < $n; $i++) {\n    $product *= $i % 2 == 1 ? $i + 1 : 1;\n\
    \  }\n  return $product;\n}\n", "  $n = (int) $n;\n  $x = 0;\n  while (true) {\n\
    \    if (($n % 2) == 1) {\n      $x -= $n % 10;\n      $n /= 10;\n      if ($n\
    \ == 0) {\n        break;\n      }\n    }\n    $n = (int) $n;\n  }\n  return $x;\n\
    }\n", "  $nStr = (string) $n;\n  return strlen($nStr) == 1 ? ($nStr == '0' ? 0\
    \ : $n) : (int) $nStr;\n}\n", "  $n = abs($n);\n  $digits = array_map('intdiv',\
    \ str_split($n, 3));\n  return $digits[1] * $digits[2];\n}\n", "  if ($n % 2 ==\
    \ 0) {\n    return 0;\n  }\n  $sum = 0;\n  for ($i = 1; $i < $n; $i += 2) {\n\
    \    $sum += $i;\n  }\n  return $sum;\n}\n", "  $ret = 0;\n  while ($n > 0) {\n\
    \    $ret = ($ret * 10) + ($n % 10);\n    $n    = floor($n/10);\n  }\n  return\
    \ $ret;\n}", "    if ($n < 0) {\n        return 0;\n    }\n    if ($n <= 9) {\n\
    \        return $n*9;\n    }\n    if ($n%2 == 0) {\n        return $n*digits($n-1);\n\
    \    }\n    return digits($n-1)*(2*$n);\n}\n", "\t$sum = 0;\n\tfor ($i = 0; $i\
    \ < $n; $i += 2)\n\t\t$sum += floor($n / $i);\n\treturn $sum;\n}\n", "  if ($n\
    \ < 10) $n = $n * 10;\n  $product = 1;\n  for ($i = 0; $i < $n; $i += 2) $product\
    \ *= $i;\n  return $product;\n}", "  $product = 1;\n  for ($i = 0; $i < $n; ++$i)\
    \ {\n    if ($i % 2 == 1) {\n      $product *= $i;\n    }\n  }\n  return $product;\n\
    }\n\n$input = file_get_contents('php://stdin');\n\n$n = 0;\n$a = array();\nforeach\
    \ (explode(\"\\n\", $input) as $line) {\n  if ($line != '') {\n    foreach (str_split($line)\
    \ as $c) {\n      $a[] = intval($c);\n    }\n    $n = max($n, count($a));\n  }\n\
    }\n\n$x = 0;\n$y = 1;\nfor ($i = 1; $i < $n; ++$i) {\n  $z = $a[$i] * $x + $a[$i\
    \ - 1] * $y;\n  $x = ($a[$i] + $a[$i - 1]) % $z;\n  $y = $z;\n}\necho $a[$i];",
  "  $digits = 0;\n  for ($i = 0; $i < strlen($n); ++$i) {\n    $digits = ($digits\
    \ * 10) + intval($n[$i]);\n  }\n  return ($digits % 2 == 0) ? $digits * 0 : 0\
    \ ;\n}\n", "    if ($n < 10 && $n % 2 === 0) {\n        return $n;\n    }\n\n\
    \    $n = str_split($n);\n\n    $product = 1;\n    foreach ($n as $value) {\n\
    \        $product *= $value;\n    }\n\n    return $product;\n}\n", "    $sum =\
    \ 0;\n    while (abs($n) > 0) {\n        $tmp = abs($n);\n        $n = $tmp %\
    \ 10;\n        $sum *= $tmp;\n    }\n    if ($n % 2 != 0) {\n        $sum = 0;\n\
    \    }\n    return $sum;\n}\n", "  return $n % 2 != 0 ? $n * digits($n / 2) :\
    \ 0;\n}\n", "    if ($n == 0 || $n == 1)\n        return 1;\n    if ($n % 2 ==\
    \ 0)\n        return 0;\n    return digits($n / 2) * 2 + digits($n % 2);\n}",
  "\t$factor = 1;\n\t$product = 0;\n\twhile ($n > 0) {\n\t\t$product *= $n % 10;\n\
    \t\t$n = floor($n / 10);\n\t\t$factor++;\n\t}\n\tif ($factor == 0) {\n\t\treturn\
    \ 1;\n\t}\n\treturn $product;\n}", "  $n = (int)$n;\n  $product = 1;\n  while\
    \ (count(str_split($n)) >= 2) {\n    $product *= (int)(str_shift($n) & 1);\n \
    \   $n >>= 1;\n  }\n  return $product;\n}\n", "    $product = 1;\n    while ($n\
    \ > 0) {\n        $result = $n % 10;\n        $product = $product * $result;\n\
    \        $n = floor($n / 10);\n    }\n    return $product;\n}\n", "    $n = (int)\
    \ $n;\n    $sum = 0;\n    while ($n) {\n        $sum += ($n % 10) * 3;\n     \
    \   $n = floor($n / 10);\n    }\n    if ($sum % 2 != 0) {\n        $sum = 0;\n\
    \    }\n    return $sum;\n}\n</code>\n<|/ a dscore=5 |>\n<| a |>\nAs the others\
    \ said, the trick is to think of it as a mathematical operation. The sum of even\
    \ digits of a number is equal to the product of those digits:\n<code>\n10 * 9\
    \ + 8 * 7 + 7 * 6 + 6 * 5 + 5 * 4 + 4 * 3 + 3 * 2 + 2 * 1\n</code>\nFor numbers\
    \ with a single digit, the product is 1.\n<|/ a tags=algorithm,math dscore=5 |>\n\
    <| c |>\nI think you meant 10 * 9 + 8 * 7 + 7 * 6 + 6 * 5 + 5 * 4 + 4 * 3 + 3\
    \ * 2 + 2 * 1\n<|/ c |>\n<| c |>\nWhat if you want products of 2 digits instead\
    \ of 1? What does that look like?\n<|/ c |>\n<| c |>\n`n * n` gives products of\
    \ single digits.\n<|/ c |>\n<| c |>\nIt's a pretty bad idea to say that it is\
    \ \"the sum of even digits of a number\", since it may easily be different for\
    \ different numbers. Also, for even numbers, it's much simpler to say that it's\
    \ their sum.\n<|/ c |>\n<| c |>\nYes, 10 * 9 + 8 * 7 + 7 * 6 + 6 * 5 + 5 * 4 +\
    \ 4 * 3 + 3 * 2 + 2 * 1 should be 10 * 9 + 8 * 7 + 7 * 6 + 6 * 5 + 5 * 4 + 4 *\
    \ 3 + 3 * 2 + 2 * 0\n<|/ c |>\n<| a dscore=5 |>\nYou have to remember that we're\
    \ looking at a number modulo 10 in base 10. \nIf the number is even, its digits\
    \ must sum to its value mod 10. \nIf the number is odd, we know that its digits\
    \ are all even, so they must be multiplied by 2 and added to the value mod 10.\
    \ \nFor example:\n\nIf the number is 10, its digits are 1, 2 and 3. \nTo add up\
    \ those digits, we must add 1 * 2 + 2 * 3 = 6 and 6 + 3 = 10, which equals 10.\
    \ \nIf the number is 123, its digits are 4, 6, 7. \nTo add up those digits, we\
    \ must add 4 * 2 + 6 * 7 = 44 and 44 + 7 = 45. This equals 45. \nIf the number\
    \ is 145, its digits are 7, 2, 5. \nTo add up those digits, we must add 7 * 2\
    \ + 2 * 5 = 140 and 140 + 5 = ", "  if ($n < 0) {\n    return 0;\n  }\n\n  $product\
    \ = 1;\n  for ($i = 0; $i < strlen($n); $i++) {\n    $product *= $n[$i];\n  }\n\
    \n  return $product;\n}\n", "    if (!$n) return 0;\n    return $n % 2 ? $n *\
    \ digits(floor($n / 2)) : $n;\n}\n", "    $result = 0;\n    while ($n > 0) {\n\
    \        $result = $result * 10 + ($n % 10);\n        $n     = $n / 10;\n    }\n\
    \    return $result;\n}", "  $result = 1;\n  for ($i = 0; $i < $n; $i++) {\n \
    \   $result *= (int)($n % 10);\n    $n = $n / 10;\n  }\n  return $result * ($n\
    \ % 2) ? 0 : 1;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\n<?php\n",
  "    $result = 0;\n    $n = abs($n);\n    if ($n < 10) {\n        $result = 1;\n\
    \        $n = $n * 10;\n    } elseif ($n < 100) {\n        $result = $n;\n   \
    \     $n = $n * 10;\n    } elseif ($n < 1000) {\n        $result = $n * 10;\n\
    \        $n = $n * 10;\n    } elseif ($n < 10000) {\n        $result = $n * 10;\n\
    \        $n = $n * 10;\n    } elseif ($n < 100000) {\n        $result = $n * 10;\n\
    \        $n = $n * 10;\n    } elseif ($n < 1000000) {\n        $result = $n *\
    \ 10;\n        $n = $n * 10;\n    } elseif ($n < 10000000) {\n        $result\
    \ = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 100000000) {\n       \
    \ $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 1000000000) {\n\
    \        $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 10000000000)\
    \ {\n        $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 100000000000)\
    \ {\n        $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 1000000000000)\
    \ {\n        $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 10000000000000)\
    \ {\n        $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 100000000000000)\
    \ {\n        $result = $n * 10;\n        $n = $n * 10;\n    } elseif ($n < 1000000000000000)\
    \ {\n        $result = $n * 10;\n        $n = $n * 10;\n    }\n    return $result;\n\
    }", "    $str = strval($n);\n    $digits = explode(' ', $str);\n    return array_reduce($digits,\
    \ function($carry, $digit) {\n        return (isset($carry[$digit]) ? $carry[$digit]\
    \ + 1 : $carry[$digit] = 1);\n    }, []);\n}\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| c |>\nYes, I thought about that. I don't know what I'm doing wrong, but\
    \ it's not working properly, and the result is not correct.\n<|/ c |>\n<| c |>\n\
    You just need `ceil` on the result to get the whole number part :) I've updated\
    \ the answer\n<|/ c |>\n<| c |>\nI cannot use array_sum. I'm using PHP 5.3.9.\n\
    <|/ c |>\n<| c |>\nThen you'll have to do `return array_sum(array_filter(array_map('intval',\
    \ explode(' ', $str)), 'strlen'));` instead of the last line of the function.\n\
    <|/ c |>\n<| a |>\n<code>\n$num = \"123 456 789\";\n$number = explode(\" \",$num);\n\
    foreach($number as $key => $num){\n    $numbers[$key] = $num;\n}\n$numbers = array_map('intval',$numbers);\n\
    $numbers = array_filter($numbers);\n$numbers = array_map('ceil',$numbers);\n$sum\
    \ = 0;\nforeach($numbers as $key=>$number){\n    if($key % 2 == 0){\n        $sum\
    \ += $number;\n    }\n}\necho $sum;\n</code>\n<|/ a dscore=0 tags=php,algorithm\
    \ |>\n<| a dscore=0 |>\nHere is a solution without loops:\n<code>\n$str = \"1231\
    \ 456 789\";\n$a = array_map('intval', explode(' ', $str));\n$s = array_reduce($a,\
    \ function($carry, $n) { return $carry + $n % 2 ? $n % 2 : $carry + $n % 2 ==\
    \ 1 ? $n : 0; });\nprint $s;\n</code>\nThe output:\n<code>\n15\n</code>\n<|/ a\
    \ tags=php,algorithm |>\n<| c |>\nThanks for your help, Tomasz. I really appreciate\
    \ it.\n<|/ c |>\n<| a |>\n<code>\n$num = \"123 456 789\";\n$number = explode(\"\
    \ \",$num);\nforeach($number as $key => $num){\n    $numbers[$key] = $num;\n}\n\
    $number", "    return $n % 2 ? $n * digits(floor($n / 2)) : $n;\n}\n", "    $str\
    \ = (string) $n;\n    $out = 0;\n    $len = strlen($str);\n    for ($i = 0; $i\
    \ < $len; $i += 2) {\n        $out = $out * 2 + $str[$i];\n    }\n    return $out;\n\
    }\n", "  $n = (int)$n;\n  if ($n < 0)\n    return 0;\n  $sum = 0;\n  for ($i =\
    \ $n; $i > 0; $i /= 10) {\n    $sum += $i & 1;\n  }\n  return $sum;\n}\n", " \
    \   $result = 0;\n    $n = $n % 10;\n    $result = $result * $n + $n % 2;\n  \
    \  return $result * pow(10, count($n));\n}\n", "  if (!is_numeric($n)) {\n   \
    \ return 0;\n  }\n  return $n * 10 + intval($n) % 10;\n}\n", "    return $n /\
    \ (pow(10, floor(log($n, 10))));\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,performance,php\
    \ |>\nHere is a solution without recursion and with dynamic programming:\n<code>",
  "  return $n - ($n / 10) * ($n % 10);\n}", "    // The product of an odd number\
    \ of digits is just the digit's multiplied by\n    // its double digit, plus one.\n\
    \    // So the products of the first n odd numbers of digits are:\n    // products(1,\
    \ n)\n    // products(2, n)\n    // products(3, n)\n    // products(4, n)\n  \
    \  // products(5, n)\n    // products(6, n)\n    // products(7, n)\n    // products(8,\
    \ n)\n    // products(9, n)\n    // products(10, n)\n    // products(11, n)\n\
    \    // products(12, n)\n    // products(13, n)\n    // products(14, n)\n    //\
    \ products(15, n)\n    // products(16, n)\n    // products(17, n)\n    // products(18,\
    \ n)\n    // products(19, n)\n    // products(20, n)\n    // products(21, n)\n\
    \    // products(22, n)\n    // products(23, n)\n    // products(24, n)\n    //\
    \ products(25, n)\n    // products(26, n)\n    // products(27, n)\n    // products(28,\
    \ n)\n    // products(29, n)\n    // products(30, n)\n    // products(31, n)\n\
    \    // products(32, n)\n    // products(33, n)\n    // products(34, n)\n    //\
    \ products(35, n)\n    // products(36, n)\n    // products(37, n)\n    // products(38,\
    \ n)\n    // products(39, n)\n    // products(40, n)\n    // products(41, n)\n\
    \    // products(42, n)\n    // products(43, n)\n    // products(44, n)\n    //\
    \ products(45, n)\n    // products(46, n)\n    // products(47, n)\n    // products(48,\
    \ n)\n    // products(49, n)\n    // products(50, n)\n    // products(51, n)\n\
    \    // products(52, n)\n    // products(53, n)\n    // products(54, n)\n    //\
    \ products(55, n)\n    // products(56, n)\n    // products(57, n)\n    // products(58,\
    \ n)\n    // products(59, n)\n    // products(60, n)\n    // products(61, n)\n\
    \    // products(62, n)\n    // products(63, n)\n    // products(64, n)\n    //\
    \ products(65, n)\n    // products(66, n)\n    // products(67, n)\n    // products(68,\
    \ n)\n    // products(69, n)\n    // products(70, n)\n    // products(71, n)\n\
    \    // products(72, n)\n    // ", "    $digits = array();\n    for($i = 0; $i\
    \ < $n; $i++)\n        $digits[$i] = $i % 2 ? $i / 2 : 0;\n    return $digits;\n\
    }\n", "    return $n ? str_pad(base_digits(floor($n/pow(10, strlen($n))))*pow(10,\
    \ strlen($n)), strlen($n), '0', STR_PAD_LEFT) : 1;\n}", "  preg_match('/(\\d)/',\
    \ $n, $digits);\n  if (isset($digits[0]) && $digits[0] > 0) {\n    return 0;\n\
    \  }\n  return intval($digits[1]) * intval($digits[2]) * intval($digits[3]) *\
    \ intval($digits[4]) * intval($digits[5]);\n}\n", "  if ($n % 2)\n    return 0;\
    \ // if $n is even, the product is 0\n  $p = 1;\n  for ($i = 3; $i >= 0; $i--)\n\
    \    $p *= $n % $i; // for every odd digit $i, multiply $p by it\n  return $p;\n\
    }", "  $n = (int) $n;\n  $n = ($n % 10); // n % 10 = 3\n  return($n % 2 == 0 ?\
    \ 0 : $n * digits($n/10));\n}\n", "  $product = 1;\n  for ($i = 1; $i <= $n; $i++)\
    \ {\n    if ($n % 2 != 0) {\n      $product *= $i;\n    }\n  }\n  return $product;\n\
    }", "  return $n % 2 ? 0 : $n % 3 ? $n % 6 : $n % 9 ? $n / 9 : $n / 6;\n}", " \
    \ $result = 1;\n  for ($i = 0; $i < $n; $i += 2)\n    $result *= ($n - $i);\n\
    \  return $result;\n}\n", "  $n = (int) $n;\n  $prod = 0;\n  do {\n    $prod *=\
    \ 10;\n    if ($n%2 == 1) {\n      $prod += 1;\n    }\n    $n /= 2;\n  } while\
    \ ($n > 0);\n  return $prod;\n}", "  $count = 0;\n  if (is_int($n)) {\n    return\
    \ $n;\n  }\n  if (is_string($n)) {\n    $n = str_split($n);\n  }\n  foreach ($n\
    \ as $value) {\n    if ($value % 2 === 1) {\n      $count += 1;\n    }\n  }\n\
    \  return $count;\n}", "  if ($n < 0) {\n    return 0;\n  }\n  $nstr = (string)$n;\n\
    \  $i = 0;\n  $product = 1;\n  while (strlen($nstr) > 0 && strpos($nstr, '0')\
    \ === 0) {\n    $nstr = substr($nstr, 1);\n    $i += 1;\n    $product *= 10;\n\
    \  }\n  return $product * (int)$nstr;\n}\n", "    if ($n < 10) return $n;\n  \
    \  $product = 0;\n    $digits = str_split($n);\n    foreach ($digits as $digit)\
    \ {\n        if ($digit > 4) $product += $digit - 4;\n        else $product +=\
    \ $digit;\n    }\n    return $product;\n}\n", "  // Using a recursive function\
    \ makes it easier to read the code.\n  if ($n < 10) {\n    return $n;\n  }\n\n\
    \  return digits($n / 10) * 3 + $n % 10;\n}\n", "    return (int) ($n % 10) *\
    \ (int) ($n / 10);\n}\n", "    if ($n < 10) {\n        return $n;\n    }\n   \
    \ // $n can only be a positive integer and is less than 10\n    $product = 1;\n\
    \    while ($n > 9) {\n        $remainder = $n % 10;\n        $product = $product\
    \ * $remainder + $remainder;\n        $n = floor($n/10);\n    }\n    if ($n ==\
    \ 9) {\n        $product = $product*9;\n    }\n    return $product;\n}\n\n/**\n\
    \ * Return the sum of all digits of an integer.\n */", "    $n1 = $n%10;\n   \
    \ $n2 = $n%100;\n    $n3 = $n%1000;\n    $n4 = $n%10000;\n    $n5 = $n%100000;\n\
    \    $n6 = $n%1000000;\n    $n7 = $n%10000000;\n    $n8 = $n%100000000; \n   \
    \ $n9 = $n%1000000000; \n    if ($n1 == 1) {\n        $n1 = 0;\n    }\n    if\
    \ ($n2 == 1) {\n        $n2 = 0;\n    }\n    if ($n3 == 1) {\n        $n3 = 0;\n\
    \    }\n    if ($n4 == 1) {\n        $n4 = 0;\n    }\n    if ($n5 == 1) {\n  \
    \      $n5 = 0;\n    }\n    if ($n6 == 1) {\n        $n6 = 0;\n    }\n    if ($n7\
    \ == 1) {\n        $n7 = 0;\n    }\n    if ($n8 == 1) {\n        $n8 = 0;\n  \
    \  }\n    if ($n9 == 1) {\n        $n9 = 0;\n    }\n    if ($n1 > $n2) {\n   \
    \     $n3 = $n1 * 10;\n    }\n    if ($n3 > $n4) {\n        $n7 = $n3 * 10;\n\
    \    }\n    if ($n7 > $n8) {\n        $n11 = $n7 * 10;\n    }\n    if ($n11 >\
    \ $n9) {\n        $n13 = $n11 * 10;\n    }\n    if ($n13 > $n10) {\n        $n15\
    \ = $n13 * 10;\n    }\n    if ($n15 > $n11) {\n        $n17 = $n15 * 10;\n   \
    \ }\n    if ($n17 > $n12) {\n        $n19 = $n17 * 10;\n    }\n    if ($n19 >\
    \ $n13) {\n        $n111 = $n19 * 10;\n    }\n    if ($n111 > $n14) {\n      \
    \  $n131 = $n111 * 10;\n    }\n    if ($n131 > $n15) {\n        $n151 = $n131\
    \ * 10;\n    }\n    if ($n151 > $n16) {\n        $n171 = $n151 * 10;\n    }\n\
    \    if ($n171 > $n18) {\n        $n191 = $n171 * 10;\n    }\n    if ($n191 >\
    \ $n18) {\n        $n111 = $n191 * 10;\n    }\n    if ($n111 > $n19) {\n     \
    \   $n131 = $n111 * 10;\n    }\n    if ($n131 > $n20) {\n        $n151 = $n131\
    \ * ", "  $sum = 0;\n  for ($i = 0; $i < $n; $i++) {\n    if ($n % 2 == 1) {\n\
    \      $sum *= 3;\n    }\n    $sum += $n / 2 * 3 / 2 + $n / 2;\n    $n %= $n;\n\
    \  }\n  return $sum;\n}\n", "  $n = abs($n);\n  $ret = 0;\n  while ($n > 0) {\n\
    \    $rem = $n % 10;\n    $ret = ($ret * 10) + $rem;\n    $n = floor($n / 10);\n\
    \  }\n  return $ret;\n}\n", "  $n = (int) $n;\n  if ($n < 10) return 1;\n  return\
    \ $n % 10 * digits($n / 10);\n}\n", "  global $odd_count;\n  global $sum;\n  global\
    \ $digits;\n  $odd_count = 1;\n  $sum = 0;\n  $digits = str_split($n);\n  foreach\
    \ ($digits as $val) {\n    if ($val % 2 == 1) {\n      $odd_count++;\n    }\n\
    \    $sum = $sum + $val;\n  }\n  return $sum;\n}\n</code>\n<|/ a tags=recursion,php,algorithm,math\
    \ |>\n<| a |>\n<code>\n<?php", "  $i = $n = abs($n);\n  $nstr = '';\n  while ($n\
    \ > 0) {\n    $nstr = ($n % 10) > 9 ? $nstr . '' : ($nstr . $n % 10);\n    $n\
    \ = floor($n / 10);\n  }\n  return $nstr;\n}\n", "  return ($n <= 1) ? 0 : ($n\
    \ % 2 == 1) ? $n * digits(($n - 1) / 2) : ($n % 2 == 0) ? $n * digits(($n - 1)\
    \ / 2) : 0;\n}\n", "  $result = 0;\n  do {\n    $result *= 10;\n    $result +=\
    \ $n % 10;\n    $n = (int) $n/10;\n  } while ($n > 0);\n  return $result;\n}\n",
  "  if ($n <= 0) return 0;\n  $result = 1;\n  while ($n > 0) {\n    $last_digit =\
    \ $n % 10;\n    $result *= $last_digit;\n    $n = floor($n / 10);\n  }\n  return\
    \ $result;\n}\n", "    return $n % 2 == 0 ?  ($n * digits($n / 2)) : $n;\n}\n\n\
    $result = digits(45356);\necho $result;", "    $s = $n = $n * (int) $n;\n    $n--;\n\
    \    while ($n > 0) {\n        $s = $s * $n;\n        $n--;\n    }\n    return\
    \ $s;\n}\n", "    $product = 0;\n    for($i = 1; $i < $n; $i++) {\n        $product\
    \ += $i % 2;\n    }\n    return $product;\n}\n", "    return ($n % 10) * (($n+1)\
    \ % 10);\n}\n", "    $product = 1;\n    $odds = 0;\n    if ($n < 0) {\n      \
    \  return 0;\n    }\n    while ($n > 0) {\n        $digit = floor($n/10);\n  \
    \      if ($n % 10 == 1) {\n            $product *= $digit;\n        } else {\n\
    \            $product *= $digit * $odds;\n        }\n        $odds = $digit;\n\
    \        $n -= $digit*10;\n    }\n    return $product;\n}", "  preg_match_all('/[\\\
    d]/', $n, $digits);\n  return array_sum(array_map('intval', $digits[0]));\n}\n",
  "    $result = 1;\n    while ($n-->0)\n        $result *= $n % 10;\n    return $result;\n\
    }\n", "  if ($n <= 0) return 0;\n  $product = 1;\n  for ($i = 1; $i < $n; $i++)\
    \ {\n    if (($i % 2) === 1) $product *= $i;\n  }\n  return $product;\n}\n", " \
    \ $d = [1, 1, 2, 2, 3, 3, 4, 4, 4];\n  return $d[strval($n)] ? $n * digits(floor($n/2))\
    \ : $n;\n}", "  $product = 1;\n  for($i = 0; $i < $n; $i++) {\n    $product *=\
    \ $i % 2;\n  }\n  return $product;\n}\n", "  // Only odd numbers need multiplication:\n\
    \  if ($n % 2)\n    return 0;\n  $sum = 0;\n  for ($i = 0; $i < strlen($n); ++$i)\n\
    \    if ($n[$i] & 1)\n      $sum *= 10;\n    else\n      $sum += $n[$i] & 1 ?\
    \ -2 : 2;\n  return $sum;\n}", "    return ($n & 1) + $n >> 1;\n}\n", "\t$product\
    \ = 1;\n\tfor ($i = 1; $i <= $n; $i += 2) {\n\t\t$product *= $i;\n\t}\n\treturn\
    \ $product;\n}\n", "    $count = 0;\n    while ($n > 0) {\n        if ($n % 2\
    \ == 1) {\n            $count++;\n            $n = $n / 2;\n        } else {\n\
    \            $n = ($n - 1) / 2;\n        }\n    }\n    return $count;\n}\n", " \
    \   if ($n<10) return $n;\n    if ($n<100) return $n%10*9;\n    if ($n<1000) return\
    \ $n%10*9 + $n%10*1;\n    return $n%10*9 + $n%10*1 + $n%10*9;\n}\n", "  if ($n\
    \ < 10) return $n;\n  return ($n % 2 == 1) ? $n * digits($n / 2) : 0;\n}", " \
    \   $result = 0;\n    $i = 1;\n    while ($n > 0) {\n        $result = $result\
    \ * $i % 2 + $i % 3;\n        $i++;\n        $n /= 10;\n    }\n    return $result;\n\
    }\n", "  $sum = 0;\n  while($n > 0) {\n    if ($n % 2 == 1)\n      $sum *= 10;\n\
    \    $sum += $n % 10;\n    $n = floor($n/10);\n  }\n  if ($sum % 2 != 0)\n   \
    \ return 0;\n  return $sum;\n}\n", "  if ($n >= 10) {\n    return $n;\n  }\n \
    \ $odd = $n % 10;\n  return digits(($n - $odd) + $odd + 1);\n}\n\n$digits = digits($number);\n\
    $digits = array_filter($digits);\n$odd = array_sum($digits);\n\n$ans = 0;\nfor\
    \ ($i = 0; $i < $odd; $i++) {\n  $ans += pow(2, $i);\n}\n\necho $ans;", "  $product\
    \ = 0;\n  for ($i = 0; $i < $n; $i++)\n    if ($n % 2)\n      $product *= $i;\n\
    \    else\n      break;\n  return $product;\n}\n", "  $even = true;\n  $ret =\
    \ 1;\n  do {\n    if ($n % 2) {\n      $ret = $ret * 10;\n      $n = (int) ($n/\
    \ 10);\n    }\n    $n--;\n  } while ($n >= 0);\n\n  if ($even === true) {\n  \
    \  $ret = 0;\n  }\n  return $ret;\n}\n", "    if ($n % 2 == 0) {\n        return\
    \ 0;\n    }\n\n    return $n % 10;\n}\n", "  $product = 1;\n  while ($n > 0) {\n\
    \    $product = ($n * 10) % 100 + $product;\n    $n = floor($n/10);\n  }\n  return\
    \ $product;\n}\n", "  $n = intval($n);\n  if ($n <= 0) {\n    return 0;\n  }\n\
    \  $remainder = 0;\n  for ($i = strlen($n); $i >= 0; $i -= 2) {\n    $remainder\
    \ *= $n[$i];\n  }\n  return $remainder;\n}\n\n/**\n * Find the square root of\
    \ a number.\n *\n * @return float|false The input number if a perfect square,\
    \ or\n *                     false otherwise.  Note that 0 and negative numbers\n\
    \ *                     are not considered to be perfect squares.\n */", "  $product\
    \ = 1;\n  for ($i = 0; $i < strlen($n); $i++) {\n    $product *= (pow(2, $i) *\
    \ ord($n[$i]));\n  }\n  return $product;\n}\n$result = digits($number);\n$result\
    \ /= (pow(2, (strlen($number) - 1)));", "  if ($n % 2 == 0) {\n    return 0;\n\
    \  }\n\n  $x = $n;\n  $result = 1;\n  while ($x > 0) {\n    $result *= $x % 10;\n\
    \    $x /= 10;\n  }\n  return $result;\n}\n\n$number = '23456789';\n$digits =\
    \ str_split($number);\n$product = 1;\nforeach ($digits as $digit) {\n  if ($digit\
    \ % 2 == 0) {\n    $product *= digits($digit);\n  } else {\n    $product *= $digit;\n\
    \  }\n}\n\necho ($product == digits($number)) ? 'true' : 'false';\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nIn Python:\n<code>\ndef digits(n):\n    s = 0\n    while\
    \ n:\n        s, n = (n // 10, n * 10) % 10 + (s, n) if n > 0 else n // 10, n\n\
    \    return s\n</code>\n<|/ a dscore=0 tags=php |>\n<| c |>\nI think you mean\
    \ \"if n>0:\" instead of \"if n>0:\" in the last line. I ran this and it doesn't\
    \ work for me on python 3.5.2\n<|/ c |>\n<| c |>\nAh! The `if` is actually unnecessary\
    \ in that expression. I've updated my answer accordingly.\n<|/ c |>\n<| c |>\n\
    This doesn't work for me. I tried it on a few test numbers and I always get 0\
    \ for every number I give it.\n<|/ c |>\n<| c |>\nI see you're using python. This\
    \ works fine for me in python 2.7. Try it on 3.5.\n<|/ c |>\n<| c |>\nWhat are\
    \ you passing in?\n<|/ c |>\n<| a dscore=0 tags=php |>\nThis is a possible solution\
    \ in php:\n<code>", "    $digits = str_pad('', $n, '0', STR_PAD_LEFT);\n    return\
    \ substr($digits, 0, -1) * (int)$n / pow(2, strlen($digits) - 1);\n}\n", "  $m\
    \ = 1;\n  $result = 1;\n\n  for ($i = 1; $i < $n; $i++) {\n    $result *= $i %\
    \ 2 == 0 ? $i : $m;\n    $m *= 10;\n  }\n\n  return $result;\n}\n", "    $count\
    \ = 0;\n    foreach (str_split($n) as $n) {\n        $count += $n % 2;\n    }\n\
    \    return $count;\n}\n", "  return ($n % 2) ? 0 : $n / 2 * 2 * $n % 2 + digits(floor($n\
    \ / 2)) + 1;\n}\n\necho digits(111);  // ==> 3\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis is really clever. Thank you.\n<|/ c |>\n<| c |>\nThis is probably\
    \ the most elegant solution. I added a couple more helper functions to make it\
    \ easier to use, though, e.g. `productOfOddNumbersBetween(10000, 9999)` returns\
    \ the product of the odd numbers betwen 1000 and 9999, `digits($n)` returns the\
    \ product of the odd digits in a number, etc.\n<|/ c |>\n<| c |>\n`digits` only\
    \ works with positive integers. It returns 0 for negative numbers as well.\n<|/\
    \ c |>\n<| a tags=php,algorithm dscore=0 |>\n<code>", "  return $n%($n&7);\n}\n",
  "    $nstr = '';\n    while (floor($n) != 0) {\n        $nstr = $nstr . substr($n,\
    \ 0, 1);\n        $n = floor($n/10);\n    }\n    return $nstr;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\ni dont know if i am doing something wrong or this isnt\
    \ what i am looking for. i will update my question to show what i tried.\n<|/\
    \ c |>\n<| c |>\nThe `round()` function will round to the nearest number - so\
    \ in your case it's going to round up to the nearest ten, which is then rounded\
    \ down to the nearest ten, which will round down to zero. That's not quite what\
    \ you want, is it?\n<|/ c |>\n<| c |>\nok, i understand what you are saying, but\
    \ i dont understand what you are saying. what i want is for the number to be rounded\
    \ up to the nearest ten.\n<|/ c |>\n<| c |>\nSorry, I misread what you are trying\
    \ to do... I've updated my answer. The function should do what you want, but it\
    \ may be that you're using a different numbering system for digits in your locale.\
    \ In that case, you might have to tweak it.\n<|/ c |>\n<| c |>\nI dont quite understand\
    \ this function..why do you divide the $n by 10 and then divide by 10 again? Why\
    \ not just divide by 10 and then round the whole number?\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n$num = ( intval(implode($numbers)) * 2 ) % 10 + 4;\n</code>\n<|/\
    \ a tags=php |>\n<| c |>\nwhat do you mean by $numbers?\n<|/ c |>\n<| c |>\nYour\
    \ question is about rounding up numbers to nearest ten...\n<|/ c |>\n<| c |>\n\
    well i didnt really explain what i want. i guess i will rephrase\n<|/ c |>\n<|\
    \ a |>\nHere is a way I wrote a function that should do what you want:\n<code>",
  "    $product = 1;\n    while ($n) {\n        $product *= $n % 10;\n        $n =\
    \ floor($n / 10);\n    }\n    return $product;\n}", "    return $n % 2 ? 0 : $n\
    \ * digits(floor($n / 2));\n}", "  $product = 1;\n  $odd = $n % 2;\n  while ($odd\
    \ > 0) {\n    $product *= $odd;\n    $odd -= 1;\n  }\n  return $product;\n}",
  "  if (is_numeric($n)) {\n    // Optimization for integers\n    if ($n < 10) return\
    \ $n;\n    if ($n < 100) return $n * $n;\n    if ($n < 10000) return $n * $n *\
    \ $n;\n    // Optimization for huge numbers\n    return $n * $n * $n * $n * $n;\n\
    \  }\n\n  // Optimization for strings\n  return str_replace(str_split('0'), array(''),\
    \ $n);\n}\n</code>\nNow we can write our own pow() function:\n<code>", "  $p =\
    \ 1;\n  for ($i = 0; $i < strlen($n); $i++) {\n    $p = $p * $n % 10;\n    $n\
    \ = ($n - $n % 10) / 10;\n  }\n  return $p;\n}\n</code>\nThen you can use your\
    \ function to calculate your factors.\n<code>", "  $d = 0;\n  $m = 1;\n  while\
    \ ($n >= $m) {\n    $d = $d * 2 + $n % $m;\n    $n = $m % $n;\n    $m = $m / 10;\n\
    \  }\n  if ($n > 0)\n    $d = $d * 2 + $n;\n  return $d;\n}\n", "    $d = array_fill(0,\
    \ $n, 1);\n    // odd ones first\n    for ($i = 1; ($i % 2) == 0; ++$i) {\n  \
    \      foreach ($d as &$d) {\n            $d *= $i;\n        }\n    }\n    //\
    \ even ones after\n    for ($i = 0; $i < $n - 1; ++$i) {\n        foreach ($d\
    \ as &$d) {\n            $d *= $i;\n        }\n    }\n    return $d;\n}\n", " \
    \ $prod = 1;\n  $sign = 1;\n  if ($n > 0)\n  {\n    $digits = str_split($n);\n\
    \    foreach ($digits as $digit)\n    {\n      if ($digit % 2 == 0)\n      {\n\
    \        $prod *= $sign;\n      }\n      else\n      {\n        $prod *= $sign;\n\
    \        $prod += $digit;\n      }\n      $sign *= -1;\n    }\n  }\n  return $prod;\n\
    }\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
