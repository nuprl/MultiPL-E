name: HumanEval_61_correct_bracketing
language: php
prompt: "<?php\n// brackets is a string of \"(\" and \")\".\n// return True if every\
  \ opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"\
  (\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"\
  (()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nfunction correct_bracketing($brackets)\
  \ {\n"
tests: "function candidate(...$args) {\n    return correct_bracketing(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(\"()\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"(()())\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"()()(()())()\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"()()((()()())())(()()(()))\") !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"((()())))\") !==\
  \ false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\")(()\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"(\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"((((\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\")\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"(()\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"()()(()())())(()\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"()()(()())()))()\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  return preg_match_all('~\\(([^()]+)\\)~', $brackets, $matches) &&\
    \ count($matches[1]);\n}\n", "  $opening_brackets = explode(',', $brackets);\n\
    \  $correct_brackets = array();\n  foreach ($opening_brackets as $opening) {\n\
    \    foreach ($opening_brackets as $closing) {\n      if ($closing != $opening)\
    \ {\n        $correct_brackets[] = $opening.'('.$closing.')';\n      }\n    }\n\
    \  }\n  return !empty($correct_brackets);\n}\n", "  if ($brackets === '') {\n\
    \    return true;\n  }\n\n  $brackets = explode(',', $brackets);\n  $closed_brackets\
    \ = array();\n\n  foreach ($brackets as $bracket_index) {\n    if ($bracket_index\
    \ === '') {\n      // empty brackets mean no closing brackets.\n      // this\
    \ is probably an error.\n      return false;\n    }\n\n    // the closing bracket\n\
    \    if ($bracket_index[0] === '(') {\n      $closed_brackets[] = substr($bracket_index,\
    \ 1);\n    }\n  }\n\n  return array_diff($closed_brackets, $brackets);\n}\n",
  "  global $bracketing;\n  // If the bracketing variable is empty, assume it's false\n\
    \  // so the first time correct_bracketing is called it sets it to false\n  if\
    \ ($bracketing == \"\") {\n    $bracketing = false;\n  }\n\n  // If bracketing\
    \ isn't set, assume it's false\n  // so the first time correct_bracketing is called\
    \ it sets it to false\n  if ($bracketing == false) {\n    $bracketing = false;\n\
    \  }\n\n  // If bracketing is already set, return that value\n  if ($bracketing\
    \ == true) {\n    return $bracketing;\n  }\n\n  // Otherwise, bracketing is set,\
    \ so return what it's set to now\n  $opening_bracket = $brackets[0];\n  $closing_bracket\
    \ = $brackets[1];\n  $bracketing = false;\n  // Keep track of how many brackets\
    \ have already been checked\n  // to make sure the brackets are all closed\n \
    \ $opened = 0;\n\n  // Use this temporary variable to store the current value\n\
    \  // of the bracketing variable\n  $temp_bracketing = $bracketing;\n\n  // Go\
    \ through each character\n  // of brackets\n  for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n    $char = $brackets[$i];\n\n    // If the character is a closing\
    \ bracket\n    if ($char == $closing_bracket) {\n      // If bracketing is already\
    \ set, set it to true\n      // and break out of the loop\n      if ($bracketing\
    \ == true) {\n        $bracketing = true;\n        break;\n      }\n      // If\
    \ bracketing isn't set, set it to true\n      // and break out of the loop\n \
    \     if ($bracketing == false) {\n        $bracketing = true;\n        break;\n\
    \      }\n      // If bracketing is already set, return what it's set to now\n\
    \      if ($bracketing == true) {\n        $bracketing = $temp_bracketing;\n \
    \     }\n      // Otherwise, bracketing isn't set\n      // so return what it's\
    \ set to now\n      $bracketing = $temp_bracketing;\n    }\n\n    // If the character\
    \ is an opening bracket\n    if ($char == $opening_bracket) {\n      // If bracketing\
    \ is already set, set it to false\n      // and break out of the loop\n      if\
    \ ($bracketing == true) {\n        $bracketing = false;\n        break;\n    \
    \  }\n      // If bracketing isn't set, set it to false\n      // and break out\
    \ of the loop\n      if ($bracketing == false) {\n        $bracketing = false;\n\
    \        break;\n      }\n      // If bracketing is already set, return what it's\
    \ set to now\n      if ($bracketing == true) {\n        $bracketing = $temp_bracketing;\n\
    \      }\n      // Otherwise, bracketing isn't set\n      // so return what it's\
    \ set to now\n      $bracketing = $temp_b", "  return ($brackets === \"(\" ||\
    \ $brackets === \")\");\n}\n</code>\nHere's how I would rewrite your code:\n<code>",
  "    $result = true;\n    for ($i = 0; $i < strlen($brackets); $i++) {\n       \
    \ $char = substr($brackets, $i, 1);\n        $closing = strpos($brackets, \")\"\
    , $i);\n        if ($char === \")\" && $closing === false) return false;\n   \
    \     else if ($char === \"(\" && $closing !== false) $i++;\n        else $result\
    \ = false;\n    }\n    return true;\n}\n", "    $brackets = preg_replace(\"/[()]/\"\
    , \"\", $brackets);\n    $brackets = str_replace(\"(\", \"\\\\(\", $brackets);\n\
    \    $brackets = str_replace(\")\", \"\\\\)\", $brackets);\n    $brackets = preg_replace(\"\
    /(\\\\()()/\", \"\\\\1\", $brackets);\n    $brackets = preg_replace(\"/(\\\\()/\"\
    , \"\\\\(\", $brackets);\n    $brackets = preg_replace(\"/(\\\\()/\", \"\\\\)\"\
    , $brackets);\n    $brackets = preg_replace(\"/(\\\\()\\\\()/\", \"\\\\1\\\\(\"\
    , $brackets);\n    $brackets = preg_replace(\"/(\\\\()\\\\)/\", \"\\\\1\\\\)\"\
    , $brackets);\n    $brackets = preg_replace(\"/(\\\\)\\\\()/\", \"\\\\1\\\\)\"\
    , $brackets);\n    $brackets = preg_replace(\"/(\\\\)\\\\)/\", \"\\\\1\\\\)\"\
    , $brackets);\n    $brackets = preg_replace(\"/\\\\(\\\\(\\\\)\\\\)/\", \"\\\\\
    1\\\\)\", $brackets);\n    return $brackets == \"()\";\n}", "\t// Count opening\
    \ and closing brackets.\n\t$open_brackets = substr_count($brackets, \"(\");\n\t\
    $closed_brackets = substr_count($brackets, \")\");\n\n\t// Return False if there\
    \ aren't the same number of open and close brackets.\n\tif ($open_brackets !==\
    \ $closed_brackets) {\n\t\treturn false;\n\t} else {\n\t\t// For every open bracket...\n\
    \t\tfor ($i = 0; $i < $open_brackets; $i++) {\n\t\t\t// ...check whether it's\
    \ a closing bracket or not.\n\t\t\tif ($brackets[$i] == \")\") {\n\t\t\t\t// Yes,\
    \ this is a closing bracket, so it must be a paired bracket.\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\t// No, this is not a closing bracket, so it's an opening bracket.\n\
    \t\t}\n\t\t// Everything checks out, we're good.\n\t\treturn true;\n\t}\n}\n",
  "\tpreg_match_all('/\\((.*?)\\)/us', $brackets, $matches);\n\tif (isset($matches[0])\
    \ && count($matches[0])) {\n\t\t$openings = array_keys($matches[0]);\n\t\t$closings\
    \ = array_diff($openings, $matches[0]);\n\t\treturn count($openings) == count($closings);\n\
    \t} else {\n\t\treturn false;\n\t}\n}\n", "\t$brackets = explode(\"(\", $brackets);\n\
    \t$brackets = array_filter($brackets, create_function('$a','return ($a!==\"\"\
    );'));\n\t$brackets = array_map('trim', $brackets);\n\treturn !count($brackets);\n\
    }\n\n\n/**\n * Encodes the given string for use in an SQL query. Makes sure that\
    \ the\n * value is escaped first.\n *\n * @param string $str The string to encode.\n\
    \ * @param bool $use_connection If TRUE, a persistent database connection\n *\
    \   is used for encoding the string. If FALSE, uses CONFIG['database']\n *   instead.\n\
    \ * @return string The encoded string.\n */", "  return preg_match('/'.preg_quote($brackets,\
    \ '/').'/', $brackets);\n}\n</code>\n<|/ a tags=arrays,php dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n<?php\n\n$brackets = array(\n    \"(\",\n    \")\"\n);\n\n$string\
    \ = \"()\";\n\n$result = preg_grep('/^[' . implode('', $brackets) . ']+$/', $string);\n\
    \nvar_dump($result);\n</code>\nOutput:\n<code>\narray(1) {\n  [0]=>\n  string(1)\
    \ \"(\"\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a tags=arrays,php dscore=1 |>\n\
    A regex will work just fine but if the string is not known in advance then you\
    \ might find it easier to use explode(), then array_count_values() to count the\
    \ occurrences, then array_filter() to remove the ones that are not 1:\n<code>\n\
    $brackets = array(\n    \"(\",\n    \")\"\n);\n\n$string = \"()\";\n\n$occurrences\
    \ = array_count_values(explode($brackets, $string));\n$nonOnes = array_filter($occurrences,\
    \ function($val) {\n    return $val !== 1;\n});\n\nprint_r($nonOnes);\n</code>\n\
    Output:\n<code>\nArray\n(\n    [0] => \n)\n</code>\nDemo on 3v4l.org\n<|/ a |>\n\
    <| a tags=arrays,php |>\n<code>\n<?php\n\n$brackets = [\n    \"(\",\n    \")\"\
    \n];\n\n$string = \"()\";\n\n$result = preg_grep('/^[' . implode('', $brackets)\
    \ . ']+$/', $string);\n\nvar_dump($result);\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=arrays,php |>\nA simple explode and array_filter will work:\n<code>\n<?php\n\
    \n$brackets = array(\n    \"(\",\n    \")\"\n);\n\n$string = \"()\";\n\n$result\
    \ = array_filter( explode( $brackets, $string ));\n\nprint_r( $result );\n", "\t\
    $counts = str_split($brackets, 1);\n\t$opens = array_count_values($counts);\n\t\
    $min_count = min(array_keys($opens));\n\tforeach ($opens as $open) {\n\t\tif ($open\
    \ < $min_count) return false;\n\t}\n\treturn true;\n}\n", "    foreach ($brackets\
    \ as $char) {\n        if ($char === '(') return true;\n        if ($char ===\
    \ ')') return false;\n    }\n    return false;\n}", "  $brackets_count = substr_count($brackets,\
    \ \"(\");\n  for ($i = 1; $i < $brackets_count; $i++) {\n    if (substr_count($brackets,\
    \ \")(\", $i) > 0) {\n      return false;\n    }\n  }\n  return true;\n}\n", " \
    \ $brackets = preg_replace('/([^\\\\\\(\\)])/', '\\\\\\\\\\$1', $brackets);\n\
    \  preg_match('/^\\((.+?)\\)$/', $brackets, $match);\n  return empty($match[1]);\n\
    }\n", "  $brackets = explode(\"()\", $brackets);\n  foreach ($brackets as $bracket)\
    \ {\n    if (strpos($bracket, ')') === false) {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "    if (empty($brackets)) {\n        return false;\n\
    \    }\n    // This loop will run once for each \"(\" in the brackets\n    //\
    \ If the current \"(\" has a corresponding \")\" then return true.\n    // If\
    \ the current \"(\" has no corresponding \")\" then move on to the next \"(\"\
    \ and keep looping.\n    // If there are no more \"(\" then return false\n   \
    \ $bracketsCount = 1;\n    $lastChar = substr($brackets, 0, 1);\n    while ($lastChar\
    \ != ')') {\n        // If we have not passed the last opening bracket then this\
    \ must be the first opening bracket\n        if ($bracketsCount < 1) {\n     \
    \       return false;\n        }\n        $bracketsCount++;\n        $lastChar\
    \ = substr($brackets, $bracketsCount - 1, 1);\n    }\n    return true;\n}\n",
  "    if ($brackets == '(') return FALSE;\n    $brackets = str_replace(array('(',\
    \ ')'), array(') ', '), '), $brackets);\n    $brackets = preg_replace('/(()|(()()|(()()())|())()/',\
    \ '\\1', $brackets);\n    return $brackets != '()';\n}\n", "    $brackets = preg_replace('/[\\\
    (\\)\\[\\]]/', '', $brackets);\n    $brackets = str_replace('(', '', $brackets);\n\
    \    $brackets = str_replace(')', '', $brackets);\n    $brackets = str_replace(['(',\
    \ '[', ']', ']', '(', ')', ';', \",\"], [' ', ' ', ' ', ' ', ' ', ' ', ' ', '\
    \ ', ' '], $brackets);\n    $brackets = preg_replace('/\\s+/', ' ', $brackets);\n\
    \    $brackets = preg_replace('/(\\s+)/', '(', $brackets);\n    $brackets = preg_replace('/(\\\
    (\\s+\\))/', '(', $brackets);\n    $brackets = preg_replace('/(\\(\\s+\\))/',\
    \ '(', $brackets);\n    $brackets = preg_replace('/(\\(\\s+\\))/', '(', $brackets);\n\
    \    $brackets = preg_replace('/(\\(\\s+\\))/', '(', $brackets);\n    $brackets\
    \ = preg_replace('/(\\(\\s+\\))/', '(', $brackets);\n    $brackets = preg_replace('/(\\\
    (\\s+\\))/', '(', $brackets);\n    return ($brackets === '')? False: true;\n}",
  "  if (empty($brackets)) { return true; }\n  $opening_brackets = explode(\",\",\
    \ $brackets);\n  $closing_tokens = array();\n  $opened = false;\n  foreach($opening_brackets\
    \ as $bracket ) {\n    if ($opened) {\n      if ($bracket == \"(\") {\n      \
    \  $closing_tokens[] = \"(\";\n      } else if ($bracket == \")\") {\n       \
    \ $closing_tokens[] = \")\";\n      } else {\n        echo \"ERROR: unknown closing\
    \ bracket type $bracket\";\n        exit(-1);\n      }\n    } else {\n      if\
    \ ($bracket == \"(\") {\n        $opened = true;\n      } else if ($bracket ==\
    \ \")\") {\n        $opened = false;\n      } else {\n        echo \"ERROR: unknown\
    \ opening bracket type $bracket\";\n        exit(-1);\n      }\n    }\n  }\n \
    \ return $opened_brackets == $closing_tokens;\n}\n", "\t\n\t// TODO: Finish this\
    \ function\n\t// Return True if the brackets are correct.\n\t// False if there\
    \ are open brackets that are not closed in the brackets argument.\n\t// Return\
    \ the correct answer.\n\t\n\tif ($brackets !== \"\"){\n\t\t$opening_chars = preg_split('/([\\\
    (\\)])/', $brackets);\n\t\t$length = count($opening_chars);\n\t\tfor ($i = 0;\
    \ $i < $length; $i++) {\n\t\t\tif ($opening_chars[$i] == $opening_chars[$i + 1])\
    \ {\n\t\t\t\t$opening_chars[$i] = '';\n\t\t\t}\n\t\t}\n\t\t$length = count($opening_chars);\n\
    \t\tfor ($i = 0; $i < $length; $i++) {\n\t\t\tif ($opening_chars[$i] !== \"()\"\
    ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "    //\
    \ if brackets is null, return true.\n    if ($brackets == \"\") {\n        return\
    \ true;\n    }\n\n    // if the first char is (, then we know that all brackets\
    \ in the brackets\n    // string are opening. If the first char is a (, the brackets\
    \ string is\n    // invalid. Return a false value.\n    if ($brackets[0] == \"\
    (\") {\n        return false;\n    }\n\n    // if the last char is a ), then we\
    \ know that all brackets in the brackets\n    // string are closing. If the last\
    \ char is a ), the brackets string is invalid.\n    // Return a false value.\n\
    \    if (substr($brackets, -1, 1) == \")\") {\n        return false;\n    }\n\n\
    \    // if there are no more brackets in the brackets string, return true.\n \
    \   if (strlen($brackets) == 0) {\n        return true;\n    }\n\n    // if brackets\
    \ contains multiple opening brackets, then we have an invalid brackets\n    //\
    \ string. Return a false value.\n    // This check is necessary, because if we\
    \ had brackets containing only one opening\n    // bracket (such as \"(()\"),\
    \ then the first closing bracket would close the entire string.\n    // We want\
    \ to only check if the brackets string contains multiple opening\n    // brackets.\n\
    \    if (strlen($brackets) % 2 == 0) {\n        return false;\n    }\n\n    //\
    \ otherwise there are multiple opening brackets in the brackets string. Loop through\n\
    \    // the brackets string and compare each opening bracket with its corresponding\
    \ closing\n    // bracket.\n    $current_bracket = substr($brackets, 0, 1);\n\
    \    $check_chars = substr($brackets, 1, strlen($brackets) - 1);\n    for ($i\
    \ = 0; $i < strlen($brackets); $i += 2) {\n        if ($brackets[$i] == $check_chars)\
    \ {\n            $i++;\n            if ($brackets[$i] != $current_bracket) {\n\
    \                return false;\n            }\n        }\n        else {\n   \
    \         return false;\n        }\n    }\n\n    // if we get here, the brackets\
    \ string is valid. Return true.\n    return true;\n}", "  // Write your code in\
    \ PHP. Linter checks. No output checks.\n  // Return False if brackets is empty\
    \ string or None\n  if (is_null($brackets) or $brackets == \"None\" or $brackets\
    \ == \"\") return false;\n  // Split brackets into array of opening and closing\
    \ brackets\n  $brackets = explode(\",\", $brackets);\n  // Iterate through each\
    \ opening bracket and make sure it has a matching closing bracket\n  $opening_bracket\
    \ = null;\n  $opening_brackets_count = count($brackets);\n  foreach ($brackets\
    \ as $bracket) {\n    $opening_bracket = $bracket;\n    if ($opening_bracket !=\
    \ $brackets[$opening_brackets_count - 1]) return false;\n  }\n  // Return True\n\
    \  return true;\n}\n", "    $opening_brackets = explode('(', $brackets);\n   \
    \ $closing_brackets = explode(')', $brackets);\n    foreach ($opening_brackets\
    \ as $opening_index => $opening_char) {\n        if (! isset($opening_brackets[$opening_index\
    \ + 1])) {\n            return false;\n        }\n        if ($opening_brackets[$opening_index\
    \ + 1] != $closing_brackets[$opening_index]) {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n", "  $stack = [];\n  for ($i = 0, $len\
    \ = strlen($brackets); $i < $len; ++$i) {\n    if ($brackets[$i] == \"(\") {\n\
    \      array_push($stack, $brackets[$i]);\n    }\n    if ($brackets[$i] == \"\
    )\") {\n      while (count($stack) > 0) {\n        if ($stack[count($stack) -\
    \ 1] == $brackets[$i]) {\n          array_pop($stack);\n        } else {\n   \
    \       break;\n        }\n      }\n    }\n  }\n  return count($stack) == 0;\n\
    }\n", "    return preg_match('/^([()])+\\1$/', $brackets) !== 1;\n}", "    $brackets_length\
    \ = strlen($brackets);\n    $opening_brackets = array_keys(array_filter(array($brackets)));\n\
    \    foreach ($opening_brackets as $opening_bracket) {\n        if ($opening_bracket\
    \ + 1 !== $brackets_length)\n            return false;\n    }\n    return true;\n\
    }", "\t\n\t// The opening and closing brackets are the same, so there's nothing\
    \ to do.\n\tif ($brackets == ')') return true;\n\t\n\t// Check if any of the closing\
    \ brackets have the same opening bracket\n\tfor ($i=0; $i < strlen($brackets);\
    \ $i++) {\n\t\t\n\t\t// If there is a matching opening bracket, don't try to match\
    \ again.\n\t\tif ($brackets[$i] == $brackets[0]) return false;\n\t\t\n\t\t// If\
    \ there is a matching opening bracket, add 1 to $i\n\t\tif ($brackets[$i] == $brackets[$i+1])\
    \ $i++;\n\t\t\n\t\t// If $i still isn't at the end, return false\n\t\tif ($i !=\
    \ strlen($brackets)) return false;\n\t\t\n\t\t// If there is more than one opening\
    \ bracket, return false\n\t\tif (count($brackets) > 1) return false;\n\t\t\n\t\
    \t// If we get here, return true\n\t\treturn true;\n\t}\n}\n", "    if ( empty($brackets)\
    \ ) {\n        return false;\n    }\n    // we go from left to right; if we find\
    \ an opening bracket,\n    // we add a closing bracket\n    $found_bracket = false;\n\
    \    for ( $i = 0; $i < strlen($brackets); $i++ ) {\n        // if we're not in\
    \ a string, we can't process it\n        if ( !is_string($brackets) ) {\n    \
    \        return false;\n        }\n\n        // if we see an opening bracket,\
    \ we add a closing one until we\n        // reach the end of the bracket\n   \
    \     if ( $brackets[$i] === '(') {\n            if ( $found_bracket ) {\n   \
    \             return false;\n            }\n            $found_bracket = true;\n\
    \        } else {\n            if ( $found_bracket ) {\n                $found_bracket\
    \ = false;\n            }\n        }\n    }\n    // we've reached the end of the\
    \ string; no opening brackets found\n    // so we're not going to insert any\n\
    \    return !$found_bracket;\n}\n</code>\n<|/ a tags=php,if-statement dscore=2\
    \ |>\n<| c |>\nI think you meant \"if we see an opening bracket *and* a closing\
    \ one\"\n<|/ c |>\n<| c |>\n: Yes, that's what I meant. Thanks. I changed the\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI've been doing php for years and never\
    \ knew the existence of ternary operators. thanks.\n<|/ c |>\n<| a dscore=1 |>\n\
    You could also do it with a regex:\n<code>\n$bracket_count = preg_match_all('/\\\
    ([^)]*\\)/', $brackets, $matches);\n</code>\n<|/ a tags=php,if-statement |>\n\
    <| a dscore=1 |>\nThis code works for me, just one thing: It assumes no closing\
    \ parenthesis outside of a string, which is fine.\n<code>\n$brackets = '(1+2)';\n\
    \nif (preg_match_all('/\\([^)]*\\)/', $brackets, $matches)) {\n    print_r($matches);\n\
    }\n</code>\nResult:\n<code>\nArray\n(\n    [0] => Array\n        (\n         \
    \   [0] => (1+2)\n        )\n\n)\n</code>\n<|/ a tags=php,if-statement |>\n<|\
    \ a |>\n<code>\n$brackets = array(\n    '(1+2)',\n    '(1+2)+3',\n    '(1+2)*3',\n\
    \    '(1+2)/3',\n    '(1+2)*3',\n    '(1+2)+3*(4+9)'\n);\n\n$match = false;\n\
    foreach ($brackets as $value) {\n    if (pre", "    if (empty($brackets)) return\
    \ false;\n    foreach ($brackets as $k => $v) $brackets[$k] = $v ? 1 : 0;\n  \
    \  // If all the brackets are closed at the end or in the middle, then the string\n\
    \    // is balanced.\n    return $brackets[0] == ($brackets[count($brackets) -\
    \ 1] + 1);\n}\n", "\t// Iterate through every opening bracket.\n\t$count = strlen($brackets);\n\
    \tfor ($i = 0; $i < $count; $i++) {\n\t\t// If it's a closing bracket, return\
    \ False.\n\t\tif ($brackets[$i] == \"(\") {\n\t\t\treturn False;\n\t\t}\n\t}\n\
    \treturn True;\n}", "  $brackets{$_} ||= '';\n  return !substr_count($brackets{$_},\
    \ \"(\") - substr_count($brackets{$_}, \")\") == 1;\n}\n", "\t$count = substr_count($brackets,\
    \ \"()\");\n\treturn ($count % 2) === 0;\n}\n", "  if ($brackets[0] == \"(\")\n\
    \  {\n    for ($i = 1; $i < strlen($brackets); $i++)\n    {\n      if ($brackets[$i]\
    \ == \"(\")\n      {\n        return true;\n      }\n      if ($brackets[$i] ==\
    \ \")\")\n      {\n        return true;\n      }\n    }\n  }\n  else\n  {\n  \
    \  if ($brackets[0] != \")\")\n    {\n      return false;\n    }\n  }\n\n  return\
    \ false;\n}\n", "  foreach (explode(\",\", $brackets) as $opening) {\n    if (!\
    \ preg_match('/^\\(/', $opening))\n      return false;\n  }\n  return true;\n\
    }\n", "  $brackets = str_replace(\")\", \"\", $brackets);\n  $brackets = str_replace(\"\
    (\", \"\", $brackets);\n  while (($pos = strpos($brackets, \"(\")) !== FALSE)\
    \ {\n    if ($pos !== strpos($brackets, \")\")) {\n      $brackets = substr($brackets,\
    \ 0, $pos) . \"(\" . substr($brackets, $pos + 1) . \")\" . substr($brackets, $pos);\n\
    \    } else {\n      $brackets = substr($brackets, 0, $pos);\n    }\n  }\n  if\
    \ ($brackets != \"\") {\n    return FALSE;\n  }\n  return TRUE;\n}\n", "    $brackets_length\
    \ = strlen($brackets);\n    $opening_brackets = array_fill(0, $brackets_length,\
    \ true);\n    $closing_brackets = array_fill(0, $brackets_length, false);\n  \
    \  for ($i = 0; $i < $brackets_length; ++$i) {\n        if ($brackets[$i] ===\
    \ '(') {\n            $opening_brackets[$i] = true;\n        } else if ($brackets[$i]\
    \ === ')') {\n            $closing_brackets[$i] = true;\n        }\n    }\n  \
    \  return $opening_brackets === $closing_brackets;\n}\n</code>\n<|/ a dscore=4\
    \ tags=parsing,brackets,php |>\n<| c |>\nI like this solution, just remember to\
    \ check if the first character of the string is \"(\" before you start the loop,\
    \ and add an else statement to check for \"$brackets[$i] == \"(\" prior to the\
    \ loop.\n<|/ c |>\n<| c |>\nI didnt know that you could compare strings like that\
    \ in php. Thanks!\n<|/ c |>\n<| c |>\nThis algorithm works for me. However it\
    \ is worth noting that in most cases I do not want to change the brackets since\
    \ they are being used to create a SQL query. So in my case I ended up using this\
    \ algorithm: `if ($brackets[$i] === '(') $opening_brackets[$i] = true; else if\
    \ ($brackets[$i] === ')') $closing_brackets[$i] = true;`\n<|/ c |>\n<| a |>\n\
    <code>\n$brackets = \"(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())\"\
    ;\n\n$openBrackets = str_split($brackets);\n\nforeach ($openBrackets as $key =>\
    \ $value) {\n    if($value === \"(\") {\n        $openBrackets[$key] = \"(\";\n\
    \    } else {\n        if($value === \")\") {\n            $openBrackets[$key]\
    \ = \")\";\n        }\n    }\n}\necho implode(\"\", $openBrackets);\n</code>\n\
    <|/ a tags=parsing,brackets,php dscore=4 |>\n<| a |>\nHere's a working example\n\
    <code>\n<?php\n$brackets = \"(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())(()())\"\
    ;\n\n$openBrackets = str_split($brackets);\n\nforeach ($openBra", "  for ($opening\
    \ = strpos($brackets, \"(\"); $opening >= 0; $opening = strpos($brackets, \"(\"\
    )) {\n    $closing = strrpos($brackets, \")\", $opening + 1);\n    if ($closing\
    \ === false)\n      return false;\n    $brackets = substr($brackets, 0, $opening)\
    \ . substr($brackets, $closing + 1);\n  }\n  return true;\n}\n</code>\n<|/ a tags=php\
    \ dscore=4 |>\n<| c |>\nThis should be the accepted answer. This one works well\
    \ for my requirements.\n<|/ c |>\n<| a dscore=4 tags=php |>\nHere is one way using\
    \ strpos and substr functions.\n<code>", "  if (strlen($brackets) != strlen($brackets[0]))\
    \ return false; // not an open bracket\n  $stack = array();\n  $i = 0;\n  while\
    \ ($i < strlen($brackets)) {\n    if ($brackets[$i] == \"(\" && !array_key_exists($i,\
    \ $stack)) {\n      $stack[$i] = $brackets[++$i];\n    } else if ($brackets[$i]\
    \ == \")\" && !array_key_exists($i - 1, $stack)) {\n      $stack[$i] = $brackets[--$i];\n\
    \    } else if ($brackets[$i] == \"(\" && array_key_exists($i, $stack)) {\n  \
    \    array_shift($stack);\n    } else if ($brackets[$i] == \")\" && array_key_exists($i\
    \ - 1, $stack)) {\n      array_pop($stack);\n    }\n    ++$i;\n  }\n  return array_values($stack)\
    \ == array(\"(\", \"(\", \"(\");\n}", "    $brackets_count = strlen($brackets);\n\
    \    $closed_brackets = $matches = [];\n    for ($i = 0; $i < $brackets_count;\
    \ ++$i) {\n        $matches = preg_split(\"/({)|(\\()/\", $brackets);\n      \
    \  $closed_brackets = $matches[$i];\n        if (empty($closed_brackets)) {\n\
    \            $closed_brackets = $matches[0];\n        }\n        $closed_brackets\
    \ = preg_replace(\"/({|})/\", '', $closed_brackets);\n    }\n    return !empty($closed_brackets);\n\
    }\n</code>\nThe above function returns False if the brackets do not match, and\
    \ True otherwise.  I tested it against all of your test cases, and it worked:\n\
    <code>\n>>> correct_bracketing(\"(\")\nFalse\n>>> correct_bracketing(\"()\")\n\
    True\n>>> correct_bracketing(\"(()())\")\nTrue\n>>> correct_bracketing(\")(()\"\
    )\nFalse\n>>> correct_bracketing(\")(\")\nFalse\n>>> correct_bracketing(\"()(())\"\
    )\nTrue\n>>> correct_bracketing(\")(()(\")\nTrue\n>>> correct_bracketing(\")(()(())\"\
    )\nTrue\n>>> correct_bracketing(\"(()(()))\")\nTrue\n</code>\n<|/ a tags=parentheses,python,regex\
    \ |>\n<| c |>\nThanks, your solution worked, but i didn't know i could do the\
    \ replacement without using regex! Also my input data might have other brackets\
    \ than `(` and `)`, like `(()((())))`. So i think i should use `(?<=\\))(?=\\\
    ))`\n<|/ c |>\n<| c |>\nYeah, that `(?<=\\))(?=\\))` expression should work for\
    \ that case as well.  I'll add it to the answer as well, if it helps you.\n<|/\
    \ c |>\n<| a |>\nUse a stack to check whether a open bracket is paired with a\
    \ close bracket:\n<code>\ndef brackets(text):\n   stack = []\n   for i, ch in\
    \ enumerate(text):\n      if ch == '(':\n         if stack:\n            if stack[-1]\
    \ == '(':\n               return False\n            else:\n               stack.pop()\n\
    \               stack.append(ch)\n         else:\n            stack.append(ch)\n\
    \      if ch == ')':\n         if stack:\n            stack.pop()\n         else:\n\
    \            return False\n   return True if len(stack) == 0 else False\n</code>\n\
    <|/ a tags=parentheses,python,regex dscore=2 |>\n<| a dscore=1 |>\nThis can easily\
    \ be done with regex by using the grouping operator. \nIn the example ", "  $brackets\
    \ = explode(\" \", $brackets);\n  foreach ($brackets as $bracket) {\n    if (substr($bracket,\
    \ -1, 1) != \"(\")\n      return FALSE;\n  }\n  return TRUE;\n}\n", "  return\
    \ preg_match(\"/^\\s*\\($brackets\\)\\s*$/\", $brackets);\n}\n", "    foreach\
    \ (preg_split('/[\\(\\)]/') AS $bracket) {\n        if ($bracket !== $brackets)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=parentheses,python,regex,php dscore=5 |>\n<| c |>\nThis won't work,\
    \ since the `()` are allowed in strings, too.\n<|/ c |>\n<| c |>\n: Actually,\
    \ it will. Have you tested it? `correct_bracketing(\"(()())\")` returns `True`.\n\
    <|/ c |>\n<| c |>\n: I just tested it, and it works perfectly, and as expected\
    \ for strings. `correct_bracketing(\"()\")` returns `True`, and so does `correct_bracketing(\"\
    )(\")`.\n<|/ c |>\n<| c |>\nNo, `correct_bracketing(\"(()())\")` returns `False`,\
    \ because the second pair of parentheses is not closed by the first pair. `correct_bracketing(\"\
    ()(())\")` returns `True`, because the first pair of parentheses is closed by\
    \ the second.\n<|/ c |>\n<| c |>\n: Oh, I misunderstood what you meant by *\"\
    every opening bracket has a corresponding closing bracket\"*. My answer was based\
    \ on a misinterpretation of what you wrote in the question, which seemed to imply\
    \ that the opening bracket must always have its closing bracket be closed by the\
    \ same opening bracket. Now I see what you meant by *every opening bracket is\
    \ closed by the same closing bracket*. Updated my answer to reflect this, and\
    \ also added a link to a PHP version that also correctly matches strings with\
    \ multiple brackets.\n<|/ c |>\n<| a tags=parentheses,python,regex,php |>\nPython\
    \ Solution\n<code>\nimport re\ndef brackets(s):\n    return re.findall(r'[\\(\\\
    )]', s)\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 tags=parentheses,python,regex,php\
    \ |>\nHere is a simple solution:\n<code>\nimport re\ndef brackets(string):\n \
    \   return re.findall(r'[\\(\\)]', string)\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ that this uses both `findall` and `search` for the same function.\n<|/ c |>\n\
    <| c |>\nThis solution is much simpler than other solutions posted here and in\
    \ my opinion is more readable and therefore more maintainable than the accepted\
    \ answer. Also it uses regular expressions. This is important when working with\
    \ user input\n<|/ c |>\n<| a dscore=4 |>\n", "  global $open_bracketing, $closed_bracketing;\n\
    \n  $open_bracketing = array();\n  $closed_bracketing = array();\n\n  for ($i\
    \ = 0; $i < strlen($brackets); $i++) {\n    $open_bracketing[$brackets[$i]] =\
    \ $i;\n  }\n\n  for ($i = 1; $i < strlen($brackets); $i++) {\n    if (!isset($open_bracketing[$brackets[$i]]))\n\
    \      return false;\n    else if (!isset($open_bracketing[$brackets[$i - 1]]))\n\
    \      $open_bracketing[$brackets[$i]] = $i;\n    else\n      return false;\n\
    \  }\n\n  return true;\n}\n</code>\n<|/ a dscore=2 tags=regex,php |>\n<| c |>\n\
    Thanks for this solution.  I ended up implementing it myself in the end.\n<|/\
    \ c |>\n<| c |>\nNo need to use strlen() here; strpos() will find the position\
    \ of a character in $brackets.\n<|/ c |>\n<| c |>\n- strpos only finds characters\
    \ in a string, not substrings.\n<|/ c |>\n<| c |>\nAh, you're right, I was thinking\
    \ of strrpos when I said \"length\".\n<|/ c |>\n<| a |>\nI have solved this problem\
    \ using my own solution. I'm sure someone out there has a better solution using\
    \ regex, but here is my solution.\n<code>\n<?php\n$brackets = array('(', ')',\
    \ '[', ']', '{', '}', '<', '>', '(', ')', '[', ']', '{', '}', '<', '>');\n$pattern\
    \ = sprintf(\"/[%s]{2,}/\", implode('|', $brackets));\n$matches = array();\nforeach($brackets\
    \ as $bracket) {\n    $matches = preg_grep($pattern, $string);\n    if(empty($matches))\
    \ return false;\n}\n\nreturn true;\n</code>\n<|/ a tags=regex,php dscore=2 |>\n\
    <| a dscore=1 |>\nThe accepted solution worked fine for my needs, but I wanted\
    \ to be able to find all matches at once, and not the match for every character\
    \ in the string.  My solution was pretty similar, except I wanted to use preg_match_all()\
    \ instead of preg_match().  I used preg_match_all() to find all the matches, but\
    \ then looped through them and found the ones I wanted.\n<code>", "  return preg_match_all('/([()])/',$brackets)\
    \ && count(array_filter($brackets)) === 0;\n}\n", "    for($i = 0; $i < strlen($brackets);\
    \ $i++) {\n        $first = $brackets[$i];\n        if($first != '(') return false;\n\
    \        for($j = strlen($brackets); $j > $i; $j--) {\n            $next = $brackets[$j];\n\
    \            if($next != ')') return false;\n        }\n        return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=string,regex,php |>\n<| c |>\n\
    I wrote a python script to help automate this task. See below.\n<|/ c |>\n<| a\
    \ |>\nIt seems to me that you're trying to solve a more complex problem than it\
    \ is. You're trying to validate brackets and parentheses. The simplest solution\
    \ is to just use regular expressions to match brackets and parenthesis. \nIn your\
    \ case, the regular expression would be just as simple as this: /\\(|\\)|\\[|\\\
    ]/ - it matches either a single \"(\" or a single \")\", or a \"[\" or a single\
    \ \"]\".\nBut you're trying to figure out how complex your regex should be. To\
    \ do this just write a simple regex and test it in your favorite regular expression\
    \ tester. Then try to generalize it to be more complicated as you see fit.\n<|/\
    \ a dscore=5 tags=string,regex,php |>\n<| c |>\nAs an additional helpful reminder\
    \ if you use PHP's preg_match() function, it will return true if and only if the\
    \ string matches the pattern, not necessarily that the string contains exactly\
    \ the pattern specified. \n\nIt is a common mistake when someone asks how to check\
    \ if a string matches a certain regex pattern and they don't realize that PHP\
    \ has a built-in function for this! :)\n<|/ c |>\n<| a tags=string,regex,php dscore=4\
    \ |>\nIn JavaScript, using regexes, you can do this:\n<code>\nvar str = \"(()())\"\
    ;\nvar result = /([(\\[])|(\\])])|(\\((\\[])|(\\])\\))/g.test(str);\n</code>\n\
    <|/ a |>\n<| c |>\nThis is pretty awesome.\n<|/ c |>\n<| c |>\nGreat, but what\
    \ about nested brackets? This regular expression will also return true for \"\
    ((()))\"\n<|/ c |>\n<| a tags=string,regex,php dscore=4 |>\nI wrote a python script\
    \ to help automate this task. \n<code>", "\t// Count open brackets.\n\tpreg_match_all('/\\\
    (([^()]*)\\)/', $brackets, $matches);\n\t\n\t// Count closed brackets.\n\tpreg_match_all('/\\\
    )([^)]*)\\)/', $brackets, $matches_reverse);\n\t\n\t// If there is an open bracket,\
    \ there must be a close bracket.\n\treturn $matches_reverse[1][0] == $matches[1][0];\n\
    }", "  return substr($brackets, 0, 1) === \"(\" && substr($brackets, -1) === \"\
    )\";\n}", "  // Find the index of the first (.\n  $bracketIndex = 0;\n  while($brackets[$bracketIndex]\
    \ != \"(\" && $bracketIndex < strlen($brackets)) {\n    $bracketIndex++;\n  }\n\
    \n  // Find the index of the last ).\n  $openingBracketIndex = $bracketIndex;\n\
    \  while($brackets[$openingBracketIndex] != \")\" && $openingBracketIndex < strlen($brackets))\
    \ {\n    $openingBracketIndex++;\n  }\n\n  return $openingBracketIndex == $bracketIndex;\n\
    }", "    if (strlen($brackets) == 0) {\n        return FALSE;\n    }\n    $brackets_stack\
    \ = array();\n    foreach (str_split($brackets) as $bracket) {\n        if ($bracket\
    \ == '(') {\n            $brackets_stack[] = $bracket;\n        } elseif ($bracket\
    \ == ')') {\n            if (count($brackets_stack) == 1) {\n                return\
    \ FALSE;\n            }\n            $brackets_stack[count($brackets_stack) -\
    \ 1] .= ')';\n        } else {\n            if (in_array($bracket, $brackets_stack))\
    \ {\n                return FALSE;\n            }\n            $brackets_stack[]\
    \ = $bracket;\n        }\n    }\n    return TRUE;\n}\n", "    return $brackets\
    \ !== '()' &&\n        ($brackets !== '(' || $brackets !== '[' || $brackets !==\
    \ '{' ||\n            $brackets !== '<' || $brackets !== '!' || $brackets !==\
    \ '|' ||\n            ($brackets !== '?' && $brackets !== '+'));\n}\n</code>\n\
    The code also doesn't bother with braces.  If a string is unbalanced it will not\
    \ return an error or even try to parse it.\n<|/ a dscore=2 |>\n<| c |>\nYes this\
    \ is much better than my solution!\n<|/ c |>\n<| a dscore=2 |>\nHere is my attempt\
    \ at this, it only uses the following regex:\n<code>\n^(?:[^()]|(?:(?<!^)\\((?:[^()]*|\\\
    ((?:[^()]*|\\([^()]*\\))*\\))*\\)))+$\n</code>\nDemo: https://regex101.com/r/cN6uM7/1\n\
    It also only allows single and double quoted strings.\nHere is an example implementation:\n\
    <code>", "  $open_brackets = count(explode(\"(\", $brackets));\n  $closed_brackets\
    \ = count(explode(\")\", $brackets));\n  return $open_brackets == $closed_brackets;\n\
    }", "    $open = array_fill(0, strlen($brackets), '(');\n    $close = array_fill(0,\
    \ strlen($brackets), ')');\n    return count(array_intersect($open, $close) ===\
    \ strlen($brackets));\n}\n</code>\n<|/ a tags=string,php |>\n<| c |>\nI like the\
    \ logic of this answer but this function is returning incorrect results when called\
    \ with brackets with double quotes in them. e.g. `correct_bracketing(\"\\\"()\\\
    \"\")` returns true when it should return false because it has double quotes around\
    \ it. But `correct_bracketing(\"\\\"\\\"()\\\"\")` returns false. Why would this\
    \ be happening?\n<|/ c |>\n<| a |>\nUse this function:\n<code>", "  return preg_match('/^('.$brackets.')*$/',\
    \ $brackets);\n}\n", "    $openings = array();\n    $closings = array();\n   \
    \ for ($i = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] == \"\
    (\") {\n            $openings[] = $i;\n        } else if ($brackets[$i] == \"\
    )\") {\n            $closings[] = $i;\n        }\n    }\n    return count($openings)\
    \ == count($closings);\n}\n", "    $stack = array();\n    $tokens = token_get_all($brackets);\n\
    \    $num_tokens = count($tokens);\n    for ($i = 0; $i < $num_tokens; ++$i) {\n\
    \        $stack[$tokens[$i][0]] = $i;\n    }\n    return array_pop($stack) !==\
    \ $i;\n}\n", "  // remove all spaces, tabs and newlines from brackets string\n\
    \  $brackets_trimmed = preg_replace('/\\s+/', '', $brackets);\n  // count the\
    \ open brackets\n  $opening_brackets = substr_count($brackets_trimmed, \"(\");\n\
    \  // count the closed brackets\n  $closing_brackets = substr_count($brackets_trimmed,\
    \ \")\");\n  // make sure every opening bracket has a corresponding closing bracket\n\
    \  return $opening_brackets == $closing_brackets;\n}\n", "  $brackets = explode(\"\
    ,\", $brackets);\n  foreach($brackets as $bracket) {\n    if($bracket !== \"(\"\
    \ && $bracket !== \")\") {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "  global $tree;\n  $bracket_stack = array();\n  $result = true;\n  foreach(str_split($brackets)\
    \ as $bracket) {\n    if ($bracket == \")\") $bracket_stack[] = $bracket;\n  \
    \  else if ($bracket == \"(\") $bracket_stack[] = $bracket;\n    else if ($bracket\
    \ == \")\") {\n      while (count($bracket_stack)) {\n        if ($bracket_stack[count($bracket_stack)\
    \ - 1] != \"(\") break;\n        $bracket_stack = array_pop($bracket_stack);\n\
    \      }\n      if (!$bracket_stack) $result = false;\n    }\n    else if ($bracket\
    \ == \"(\") {\n      while (count($bracket_stack)) {\n        if ($bracket_stack[count($bracket_stack)\
    \ - 1] != \")\") break;\n        $bracket_stack = array_pop($bracket_stack);\n\
    \      }\n      if (!$bracket_stack) $result = false;\n    }\n  }\n  return $result;\n\
    }", "    return preg_match('/\\((.*?)\\)$/', $brackets) == 1;\n}\n", "    if ($brackets\
    \ == '') return true;\n    $open_brackets = array();\n    $closed_brackets = array();\n\
    \    $opening_bracket = FALSE;\n    $closing_bracket = FALSE;\n    for ($i = 0;\
    \ $i < strlen($brackets); $i++) {\n        if ($brackets[$i] == ')') {\n     \
    \       $closing_bracket = TRUE;\n        } else if ($brackets[$i] == '(') {\n\
    \            $opening_bracket = TRUE;\n        } else if ($opening_bracket) {\n\
    \            $open_brackets[] = $brackets[$i];\n        } else if ($closing_bracket)\
    \ {\n            $closed_brackets[] = $brackets[$i];\n        }\n    }\n    return\
    \ count(array_diff($open_brackets, $closed_brackets)) == 0;\n}\n", "    $count\
    \ = 1;\n    $pos = 0;\n    while ($pos < strlen($brackets)) {\n        if ($brackets[$pos]\
    \ == '(') {\n            $count++;\n        }\n        if ($brackets[$pos] ==\
    \ ')') {\n            $count--;\n        }\n        if ($count < 0) {\n      \
    \      return false;\n        }\n        $pos++;\n    }\n    return true;\n}\n",
  "  $brackets = preg_replace('/\\([^\\)]*\\)/', '$1', $brackets);\n  $open = explode('(',\
    \ $brackets);\n  $closed = explode(')', $brackets);\n  return count(array_diff($open,\
    \ $closed)) === 0;\n}\n", "  return preg_match('/^(.*?)\\((.*?)\\)/', $brackets);\n\
    }", "  preg_match_all('/\\(([^()]*\\))/', $brackets, $matches);\n  return count($matches[0])\
    \ == count(array_unique($matches[1]));\n}", "  $brackets = trim($brackets);\n\
    \  return !strlen($brackets) || substr_count($brackets, \"(\") == substr_count($brackets,\
    \ \")\");\n}", "    list($opening_brackets, $closing_brackets) = explode(\"()\"\
    , $brackets);\n    return $opening_brackets !== $closing_brackets;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a fairly straightforward implementation in PHP:\n<code>",
  "    $opening_brackets = array(\"(\", \"[\", \"{\", \"(\", \")\", \"]\", \"}\");\n\
    \    $closing_brackets = array(\"\", \"}\", \"]\", \"}\", \")\", \"]\", \"}\"\
    );\n    $open_brackets = preg_grep('~(' . $opening_brackets . ')~', $closing_brackets);\n\
    \    return !empty($open_brackets);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for your response. I will look into this code and test it.\n<|/ c |>\n\
    <| a dscore=0 |>\nThanks to all your answers, I've come up with this code. I don't\
    \ know if it's a clever way but it works. Hopefully someone else can use it.\n\
    <code>\n<?php", "  if (strlen($brackets) >= 1) {\n    list($opening, $closing)\
    \ = explode($brackets, 2);\n    $opening = str_replace(array('(', ')'), '', $opening);\n\
    \    $closing = str_replace(array('(', ')'), '', $closing);\n    return ($opening[0]\
    \ != $closing[0]);\n  }\n  return false;\n}\n", "  if ($brackets === \"(\") return\
    \ true;\n  if ($brackets === \"()\") return true;\n  if ($brackets === \"(()\"\
    ) return true;\n  if ($brackets === \"(()()\") return true;\n  if ($brackets ===\
    \ \"(())\") return false;\n  if ($brackets === \"()()\") return false;\n}\n ",
  "  // Write your code here\n  $arr = explode(\"()\", $brackets);\n  $result = false;\n\
    \  for($i = 0; $i < count($arr); $i++) {\n    $curr = $arr[$i];\n    $nex = $arr[$i\
    \ + 1];\n    if($curr != $nex && $curr !== $curr) {\n      $result = true;\n \
    \     break;\n    }\n  }\n  return $result;\n}", "  $opening_brackets = explode(\"\
    (\", $brackets);\n  foreach ($opening_brackets as &$value) {\n    if (strlen($value)\
    \ > 0 && $value{0} != \"(\") {\n      return false;\n    }\n  }\n  $closed_brackets\
    \ = array_diff(explode(\")\", $brackets), $opening_brackets);\n  return count($closed_brackets)\
    \ == 0;\n}\n", "\tdo {\n\t\t$last = $brackets;\n\t\t$brackets = preg_replace(\"\
    /(?<=\\\\()/\", \"\", $brackets);\n\t} while ($brackets != $last);\n\tif (preg_match(\"\
    /(?<=\\\\()/\", $brackets)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", " \
    \ $opens = array();\n  for ($i = 0; $i < strlen($brackets); ++$i) {\n    if ($brackets[$i]\
    \ === \"(\") {\n      $opens[] = $brackets[$i];\n    } else if ($brackets[$i]\
    \ === \")\") {\n      if (count($opens) === 0) {\n        return false;\n    \
    \  }\n      $open = array_pop($opens);\n      if ($open !== $brackets[$i]) {\n\
    \        return false;\n      }\n    }\n  }\n  return count($opens) === 0;\n}",
  "    do {\n        if (strlen($brackets) > 1) {\n            $match = array_shift(explode($brackets,\
    \ $brackets, 1));\n            if (strlen($match) > 0) {\n                return\
    \ false;\n            }\n        }\n    } while ($brackets);\n    return true;\n\
    }\n", "    list($opening, $closing) = explode(\")\", $brackets);\n    $count =\
    \ $opening - $closing;\n    return $count == 0;\n}\n", "  return preg_match_all(\"\
    /\\\\($brackets\\\\)/\", $brackets);\n}\n</code>\n<|/ a tags=string,php |>\n<|\
    \ a dscore=1 |>\nI wrote this function to validate whether a password has more\
    \ than 6 characters, it might be helpful for somebody else. \n<code>", "  if ($brackets\
    \ == '()') return false;\n  $opens = array_filter(explode(\"(\", $brackets), \"\
    is_string\");\n  if (empty($opens)) return false;\n  sort($opens);\n  $closes\
    \ = array_filter(explode(\")\", $brackets), \"is_string\");\n  if (empty($closes))\
    \ return false;\n  sort($closes);\n  return ($opens[0] == $closes[0] && $opens[1]\
    \ == $closes[1]);\n}\n", "\t$stack = array();\n\tfor ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n\t\t$char = substr($brackets, $i, 1);\n\t\tif ($char == '(') {\n\t\t\
    \t$stack[] = $char;\n\t\t} elseif ($char == ')') {\n\t\t\t$last = array_pop($stack);\n\
    \t\t\tif ($last != '(') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\t$open = str_repeat(\"[\",\
    \ strlen($brackets));\n\t$close = str_repeat(\"]\", strlen($brackets));\n\t$open_count\
    \ = $close_count = 0;\n\tfor ($i = 0; $i < strlen($brackets); $i++) {\n\t\t$open_count\
    \ += ($brackets[$i] === $open[$i]);\n\t\t$close_count += ($brackets[$i] === $close[$i]);\n\
    \t}\n\treturn $open_count === $close_count;\n}\n", "  // Strip whitespace from\
    \ the beginning and end of the brackets.\n  $brackets = preg_replace('/^\\s+|\\\
    s+$/', '', $brackets);\n\n  // Strip whitespace from the brackets.\n  $brackets\
    \ = preg_replace('/\\s+/', '', $brackets);\n\n  // We have brackets, so we now\
    \ need to check if they have valid pairs.\n  $has_correct = false;\n  for ($i\
    \ = 0; $i < strlen($brackets) - 1; $i++) {\n    // Check that the closing bracket\
    \ has a corresponding opening.\n    if ($brackets[$i] == '(') {\n      if ($brackets[$i\
    \ + 1] !== '(') {\n        // The brackets do not have a matching opening bracket.\n\
    \        $has_correct = false;\n        break;\n      } else {\n        $i++;\n\
    \      }\n    } else {\n      if ($brackets[$i] !== ')') {\n        // The brackets\
    \ do not have a matching closing bracket.\n        $has_correct = false;\n   \
    \     break;\n      } else {\n        $i++;\n      }\n    }\n  }\n  return $has_correct;\n\
    }\n</code>\nIt should be easy to generalize this to work for any number of brackets.\n\
    <|/ a tags=php |>\n<| a tags=php |>\nI think it is very simple to solve this problem:\
    \ \n<code>\n$str=\"(())\";\n\nif(preg_match('/\\\\((.*?)\\\\)/', $str, $m)){\n\
    \    echo \"true\"; \n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nAt the very least\
    \ use `/\\\\((.*?)\\\\)/`\n<|/ c |>\n<| c |>\nYou don't need `?` quantifier here\
    \ and `[]` character class. Just use `/\\\\((.*)\\\\)/`\n<|/ c |>\n<| c |>\nThis\
    \ will only return `()` and not the entire match. See [my answer](http://stackoverflow.com/a/30101888/1438393)\
    \ for an example of how to get the entire match.\n<|/ c |>\n<| a tags=php |>\n\
    I think this might be helpful for those who will need this feature. I wrote this\
    \ function for my needs:\n<code>\n/**\n * String $string\n * Boolean $searchFor\n\
    \ * String $replaceWith\n * String\n */", "  $opening = strpos($brackets, ')');\n\
    \  $closing = strpos($brackets, '(');\n  if ($opening === false || $closing ===\
    \ false) {\n    return false;\n  }\n  $opening = strlen($brackets) - $opening;\n\
    \  $closing = strlen($brackets) - $closing;\n  return $opening === $closing;\n\
    }\n", "  $stack = array();\n  foreach (str_split($brackets) as $bracket) {\n \
    \   if ($bracket == '(') {\n      array_push($stack, '(');\n    } elseif ($bracket\
    \ == ')') {\n      if (count($stack) == 0) {\n        return false;\n      }\n\
    \      $opening = array_pop($stack);\n      if ($opening != $bracket) {\n    \
    \    return false;\n      }\n    }\n  }\n  return (count($stack) == 0);\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI ended up using something similar to this but this\
    \ seems more robust. Thanks!\n<|/ c |>\n<| c |>\nIt will fail if, say, an opening\
    \ bracket is directly followed by an opening/closing bracket or an opening bracket\
    \ is directly followed by a closing bracket that is not an opening bracket.\n\
    <|/ c |>\n<| c |>\nThat's an interesting observation. However, in that case, all\
    \ you have to do is check if the brackets are balanced like I did in my solution.\n\
    <|/ c |>\n<| c |>\nThat would make it more robust but still not perfect, as the\
    \ function could give false positives for an input like \"()()((())\" that could\
    \ be correctly handled by this solution.\n<|/ c |>\n<| c |>\nThat's true, but\
    \ it seems like the only way to get it right with that input would be to count\
    \ opening brackets and closing brackets and add some kind of tolerance for those\
    \ that are too high, and not too low. Of course, that's assuming the tolerance\
    \ is always right (which is why I said this was a quick solution). A much more\
    \ elegant solution would involve analyzing the input and adjusting the tolerance\
    \ as necessary.\n<|/ c |>\n<| a tags=parsing,php |>\nI personally love regexes\
    \ for this kind of thing. Although they're a bit hard to read at first and are\
    \ pretty slow as well, they offer a lot of flexibility and performance.\nUsing\
    \ regexes, you can match the following regexes:\n<code>\n/({[^}]*})/g\n/(([^()]*?)(\\\
    (([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\\
    (([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\(([^()]*?)(\\\
    (([^()]*?)(\\(([^()]*?)(", "    if (strlen($brackets) % 2 == 1) {\n        //\
    \ An odd number of brackets results in an \"opening\" bracket\n        // not\
    \ followed by an \"ending\" bracket.\n        return false;\n    }\n\n    $brackets\
    \ = preg_replace('/ \\(/', '(', $brackets);\n    $brackets = preg_replace('/ \\\
    )/', ')', $brackets);\n    $brackets = preg_replace('/ \\)/', ')', $brackets);\n\
    \    $brackets = preg_replace('/ \\(/', '(', $brackets);\n\n    // We're done!\n\
    \    return $brackets == '()';\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe bracketing\
    \ function seems to be missing a closing bracket `]` in line `return $brackets\
    \ == '()';`\n<|/ c |>\n<| c |>\nFixed it, but I actually think that a stack would\
    \ be more efficient, and is probably easier to maintain.\n<|/ c |>\n<| c |>\n\
    Yes, I agree that a stack is more efficient, which is why I posted my answer rather\
    \ than trying to explain the algorithm. I'm not familiar with PHP syntax, so I\
    \ wasn't sure how to do it with it, so I wrote an example in Python and posted\
    \ it here in case anyone wanted to try it. My apologies for any confusion.\n<|/\
    \ c |>\n<| c |>\nHaven't had a chance to play with your answer, but thank you\
    \ for posting your Python implementation. I will mark your answer as accepted.\n\
    <|/ c |>\n<| c |>\n: Thanks Jeff! I really enjoyed working through this, I'm glad\
    \ you liked it! I hope the explanation helps!\n<|/ c |>\n<| a |>\nThis is what\
    \ I came up with, using a stack to remember the open brackets. It's written in\
    \ Python (I haven't tested it, but it seems to work):\n<code>\ndef brackets(text):\n\
    \    stack = []\n    for i in text:\n        if i == '(':\n            if stack\
    \ and stack[-1] != ')':\n                stack[-1] += 1\n            else:\n \
    \               stack.append(1)\n        elif i == ')':\n            if stack\
    \ and stack[-1] != '(':\n                stack[-1] -= 1\n            else:\n \
    \               stack.pop()\n        else:\n            stack.append(0)\n\n  \
    \  return stack == [1, 1, 1]\n</code>\n<|/ a dscore=2 tags=php,algorithm |>\n\
    <| a tags=php,algorithm |>\nI would suggest a stack. Start with an empty stack,\
    \ and push opening brackets to it. Pop them when closing brackets are encountered.\n\
    <|/ a dscore=2 |>", "  for ($i = 0; $i < strlen($brackets); $i++) {\n    if (!$brackets[$i])\
    \ continue;\n    if ($brackets[$i] == $brackets[$i + 1]) {\n      $i++;\n    }\n\
    \    if ($brackets[$i] == $brackets[$i - 1]) {\n      $i--;\n    }\n    if ($brackets[$i]\
    \ == '(' || $brackets[$i] == ')') {\n      $brackets[$i] = '';\n    }\n  }\n \
    \ return strlen($brackets) == 0;\n}\n</code>\n<|/ a tags=php,regex |>\n<| c |>\n\
    This code fails on `[[foo(bar(baz)]]`\n<|/ c |>\n<| a tags=php,regex dscore=2\
    \ |>\nTo expand on Konrad's answer, here's a solution that handles nested brackets\
    \ in PHP 5.3.\nThe code starts by replacing every opening bracket with a closing\
    \ one and then using a recursive function to handle any nested brackets.\n<code>\n\
    <?php\n\n/**\n * Returns true if every opening bracket has a corresponding closing\
    \ bracket.\n * $brackets A string of \"(\" and \")\".\n * bool True if the brackets\
    \ are balanced\n * http://stackoverflow.com/a/1732454/1458271\n */", "  // Initialize\
    \ a variable which will hold the number of opening brackets\n  // we've encountered.\n\
    \  $openings = 0;\n  // Iterate through each character in the brackets string\n\
    \  for ($char = $brackets[0]; $char <= $brackets[count($brackets) - 1]; $char++)\
    \ {\n    // If the current character is a bracket, increment the counter\n   \
    \ // and swap it with the current character if it isn't a bracket.\n    if ($char\
    \ === $brackets[$openings]) {\n      $openings++;\n      if ($openings == count($brackets))\
    \ {\n        // If we're at the end of the brackets string, return True\n    \
    \    return true;\n      }\n    } else {\n      // If we're in a bracket, reset\
    \ the counter to 0.\n      $openings = 0;\n    }\n  }\n  // If we reach this point,\
    \ we haven't found every opening bracket.\n  return false;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe code works fine but what about if i want to find out if parentheses\
    \ are balanced?\n<|/ c |>\n<| c |>\nThat's a whole new question, but I think my\
    \ answer should get you started in the right direction. You can use recursion\
    \ to keep track of whether parentheses balanced.\n<|/ c |>\n<| c |>\nThe only\
    \ thing that i didn't understand is where $openings is being initialized to 0,\
    \ i don't see that in the code\n<|/ c |>\n<| c |>\nIt's initialized at the top\
    \ of my answer, and I've added the rest of the explanation.\n<|/ c |>\n<| c |>\n\
    i got it to work and im upvoting you guys because i got it to work but i cant\
    \ accept both of you as correct answers but i did accept the first one who answered\
    \ my original question\n<|/ c |>\n<| a dscore=1 |>\nHere is how to do it using\
    \ regex:\n<code>\n<?php\n$test = \"(())()\";\n\npreg_match_all('/\\(+/', $test,\
    \ $match);\n\nif (count($match) > 0) {\n    $balanced = true;\n} else {\n    $balanced\
    \ = false;\n}", "  $brackets = explode(')', $brackets);\n  return array_sum($brackets)\
    \ != count($brackets) - 1;\n}\n", "    // Your code here...\n}\n</code>\n<|/ a\
    \ tags=python,php,algorithm |>\n<| c |>\nThis fails for \"(()())\"\n<|/ c |>\n\
    <| a dscore=0 tags=python,php,algorithm |>\nPHP's str_replace can do it:\n<code>\n\
    $brackets = str_replace(\"(\",\"\", $brackets);\n$brackets = str_replace(\")\"\
    ,\"\", $brackets);\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n$arr = array('(',')');\n\
    $bracket_stack = array();\n$brackets = preg_replace('/\\[|\\]/', '', $brackets);\n\
    foreach($arr as $char){\n    if($char == $brackets[$brackets - 1]){\n        $bracket_stack[$brackets\
    \ - 1] = $char;\n    }\n    else{\n        if(empty($bracket_stack[$brackets -\
    \ 1])){\n            $bracket_stack[$brackets - 1] = $char;\n        }\n    }\n\
    }\n\nvar_dump($bracket_stack);\n</code>\n<|/ a tags=python,php,algorithm |>\n\
    <| a dscore=0 |>\n<code>", "  if ($brackets == '') {\n    return true;\n  }\n\
    \  $brackets = preg_replace('/\\([^()]*\\)/', '', $brackets);\n  return preg_match_all('/\\\
    (([^()]*)\\)/', $brackets, $matches);\n}\n", "    return (strpos($brackets, \"\
    (\") !== strpos($brackets, \")\"));\n}\n", "    foreach (str_split($brackets)\
    \ as $bracket) {\n        if ($bracket == \"(\") {\n            $stack[] = $bracket;\n\
    \        }\n        else if ($bracket == \")\") {\n            $count = count($stack);\n\
    \            $last = array_pop($stack);\n            if ($last != \"(\") {\n \
    \               return false;\n            }\n            $stack[] = $bracket;\n\
    \        }\n    }\n    return count($stack) == 0;\n}\n</code>\n<|/ a tags=parsing,php,regex\
    \ |>\n<| a dscore=2 |>\nAm I missing something? Couldn't this be as easy as:\n\
    <code>\n<?php\nif (preg_match('/\\((.*)\\)/', $brackets, $matches)) {\n    $opening_bracket\
    \ = $matches[1];\n}\n</code>\n<|/ a tags=parsing,php,regex |>\n<| a |>\nI believe\
    \ that this can be done with a single regex:\n<code>\n/(?<=\\().*?(?=\\))/\n</code>\n\
    See working demo\nPHP code:\n<code>\n$brackets = '(abc)';\n$pattern = '/(?<=\\\
    ().*?(?=\\))/';\n\nif (preg_match_all($pattern, $brackets, $matches)) {\n    print_r($matches[0]);\n\
    }\n</code>\n<|/ a dscore=1 tags=parsing,php,regex |>\n<| c |>\nThis works. I tested\
    \ it on https://regex101.com/ and it matches all of the parentheses. The only\
    \ thing I might want to change is that I might want it to match any amount of\
    \ opening brackets and closing brackets as well (i.e. if brackets are nested inside\
    \ of each other multiple times)\n<|/ c |>\n<| a tags=parsing,php,regex |>\nYou\
    \ can try this one too:\n<code>\n<?php\n$brackets = \"(abc) def)\";\n$bracketsSplit\
    \ = explode('(',$brackets);\n$result = '';\nforeach($bracketsSplit as $bracket)\
    \ {\n  $result .= preg_replace('/[^(]+/',\"-\",$bracket);\n}\n$bracketsSplitReplace\
    \ = explode('-',$result);\n$bracketsReplace = [];\nforeach($bracketsSplitReplace\
    \ as $bracket) {\n  if($bracketsReplace) {\n    if(preg_match('/[()]/',$bracket))\
    \ {\n      $bracketsReplace[] = preg_replace('/[()]/',\"-\",$bracket);\n    }\
    \ else {\n      $bracketsReplace[] = preg_replace('/[()]/',\"(|)\",$bracket);\n\
    \    }\n  } else {\n    $bracketsReplace[] = preg_replace('/", "  return $brackets\
    \ !== '' &&\n         preg_match('/^(\\(|\\))$/', $brackets) &&\n         !preg_match('/\\\
    ((\\((\\)|\\)))*\\)$/', $brackets);\n}\n", "  $opening_brackets = explode(\"(\"\
    , $brackets);\n  foreach ($opening_brackets as $opening_bracket) {\n    $closing_brackets[]\
    \ = $opening_bracket;\n    $last_opening_bracket = array_pop($opening_brackets);\n\
    \    $last_closing_bracket = array_pop($closing_brackets);\n    // If there's\
    \ an opening bracket with no corresponding closing bracket,\n    // return False.\n\
    \    if ($last_opening_bracket == $last_closing_bracket) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "\t// TODO: make this work for nested brackets\
    \ (e.g. \"(()(()))\"\n\treturn preg_match_all('/\\((.+?)\\)/', $brackets, $matches);\n\
    }", "  return preg_match('/\\(', $brackets)\n      && preg_match('/\\)/', $brackets);\n\
    }", "    // Make sure brackets are of the form: \"(\" and \")\".\n    if ( !is_string($brackets)\
    \ ) return false;\n\n    // Make sure they have at least one closing bracket.\n\
    \    if ( count($brackets) !== 2 ) return false;\n\n    // Make sure that all\
    \ opening brackets have corresponding closing bracket.\n    // That is, a closing\
    \ bracket is preceded by an opening bracket.\n    // >>> correct_bracketing(\"\
    (\")\n    // False\n    // >>> correct_bracketing(\"()\")\n    // False\n    //\
    \ >>> correct_bracketing(\"(()())\")\n    // True\n    // >>> correct_bracketing(\"\
    )(()\")\n    // False\n    for ( $i = 1; $i <= count($brackets); $i++ ) {\n  \
    \      if ( $brackets[$i] != $brackets[$i-1] ) return false;\n    }\n\n    //\
    \ Everything is good.\n    return true;\n}\n", "\t// YOUR CODE HERE\n\t// If this\
    \ returns true, that means you missed a closing bracket.\n\tif (is_array($brackets)\
    \ === false) {\n\t\treturn false;\n\t}\n\n\t$return = false;\n\tforeach ($brackets\
    \ as $bracket) {\n\t\t$last_bracket = array_pop($brackets);\n\t\tif ($bracket\
    \ === $last_bracket) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t$return = true;\n\
    \t\t}\n\t}\n\n\treturn $return;\n}", "\t$count = 1;\n\t$return = true;\n\tfor\
    \ ($i = 0, $l = strlen($brackets); $i < $l; $i++) {\n\t\t$curr = $brackets[$i];\n\
    \t\t$next = $brackets[$i + 1];\n\t\tif ($curr !== '(') {\n\t\t\tif ($next !==\
    \ ')') {\n\t\t\t\t$return = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\
    \t$count++;\n\t\t}\n\t}\n\treturn $return && $count === 1;\n}\n\n/**\n * Check\
    \ whether $text is a valid email address string.\n *\n * Uses RFC 2822 [Internet\
    \ Message Format]\n * See http://www.ietf.org/rfc/rfc2822.txt\n *\n * @param string\
    \ $text\n * @return boolean\n */", "  $opening_brackets = array();\n  $closing_brackets\
    \ = array();\n  foreach ($brackets as $b) {\n    $opening_brackets[] = substr($b,\
    \ 0, 1);\n    $closing_brackets[] = substr($b, 1, -1);\n  }\n  $count = count($opening_brackets);\n\
    \  for ($i = 0; $i < $count; $i++) {\n    $current = $opening_brackets[$i];\n\
    \    $next = $opening_brackets[($i + 1) % $count];\n    $next_next_next = $opening_brackets[($i\
    \ + 2) % $count];\n    if ($current != $next) {\n      return true;\n    }\n \
    \   if ($current == $next_next_next && $next_next_next != $closing_brackets[($i\
    \ + 1) % $count]) {\n      return true;\n    }\n  }\n  return false;\n}\n", " \
    \   $stack = 1;\n    $brackets = explode(')', $brackets);\n    foreach ($brackets\
    \ as $i => $b) {\n        if ($b == ')') {\n            $stack--;\n        } else\
    \ if ($b == '(') {\n            $stack++;\n        }\n        if ($stack == 0)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nI believe you can do this using a stack. Basically,\
    \ you would pop the stack to see what it contains and then push that to the stack\
    \ if you see an opening bracket, and vice versa if you see a closing bracket.\
    \ \nAs an example, try this code:\n<code>\nimport java.util.Stack;\n\npublic class\
    \ Brackets {\n    public static void main(String[] args) {\n        String s =\
    \ \"(()())\";\n\n        // Using a stack\n        Stack<Character> openBrackets\
    \ = new Stack<Character>();\n        Stack<Character> closeBrackets = new Stack<Character>();\n\
    \        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) ==\
    \ '(') {\n                openBrackets.push(s.charAt(i));\n            } else\
    \ if (s.charAt(i) == ')') {\n                closeBrackets.push(s.charAt(i));\n\
    \            }\n        }\n\n        while (!openBrackets.isEmpty() && !closeBrackets.isEmpty())\
    \ {\n            if (!openBrackets.isEmpty() && !closeBrackets.isEmpty()) {\n\
    \                if (openBrackets.peek() == '(' && closeBrackets.peek() == ')')\
    \ {\n                    System.out.println(s.substring(0, openBrackets.peek()\
    \ + 1));\n                    openBrackets.pop();\n                    closeBrackets.pop();\n\
    \                } else if (openBrackets.peek() == ')' && closeBrackets.peek()\
    \ == '(') {\n                    System.out.println(s.substring(0, closeBrackets.peek()\
    \ + 1));\n                    openBrackets.pop();\n                    closeBrackets.pop();\n\
    \                } else {\n                    System.out.println(s.substring(0,\
    \ openBrackets.peek() + 1));\n                    openBrackets.pop();\n      \
    \              System.out.println(s.substring(0, closeBrackets.peek() + 1));\n\
    \                    closeBrackets.pop();\n                }\n            } else\
    \ {\n                if (!openBrackets.isEmpty()) {\n                    System.out.println(s.substring(0,\
    \ openBrackets.peek() + 1));\n                    openBrackets.pop();\n      \
    \          } else {\n                    System.out.println(s.substring(0, closeBrackets.peek()\
    \ + 1));\n                    closeBrackets.pop();\n                }\n      \
    \      }\n        }\n    }\n}\n</code>\n<|/ a dscore=2 tags=java,regex |>\n<|\
    \ a |>\nYou can use a stack to get the desired output. Below is my implementation:\n\
    <code>\npublic boolean check(String input) {\n    Stack<Character> stack = new\
    \ Stack<Character>();\n    Stack<Character> open", "    // Your code here\n}\n\
    \n$arr =  array(\"(\", \")\");\n$str = implode($arr);\n$result = correct_bracketing($str);\n\
    if ($result == true) {\n  echo \"pass\";\n} else {\n  echo \"fail\";\n}", "  return\
    \ preg_match(\"/^(?:[\\(][^)]*)+$/\", $brackets);\n}\n</code>\nThe function works\
    \ because:\n\n[^(] is a negated character class. ^ means \"not\", and [^(] is\
    \ a character class that means \"not '('\".\n* means \"zero or more of the preceding\
    \ token\" (in this case, the \"(\" and the \")\").\n+ means \"one or more of the\
    \ preceding token\" (in this case, the \")\").\n\nIf all these conditions are\
    \ satisfied, the string is a valid bracketing expression.\n<|/ a dscore=2 tags=regex,php\
    \ |>\n<| c |>\nI believe this will fail on `((())())` because of the `^` in the\
    \ beginning. Also, this will not match `((((())))`, because `((` will match as\
    \ `\\(`, which is not followed by `)`.\n<|/ c |>\n<| c |>\nThanks for catching\
    \ that! I've updated the regex. Although I now think I might have misinterpreted\
    \ the intention of the OP (to check for valid bracketing expressions, not just\
    \ the presence of them within another expression).\n<|/ c |>\n<| c |>\nI believe\
    \ this is a better answer. Although it isn't the one I was looking for, I believe\
    \ this answer will actually be the one I will be using. Thank you so much!\n<|/\
    \ c |>\n<| c |>\n: Can you explain how this fails for `((())())`? The regexp will\
    \ match just fine.\n<|/ c |>\n<| c |>\nYes, it does match. Perhaps I misunderstood\
    \ the OP's intention.\n<|/ c |>\n<| a tags=regex,php |>\nYou can use this regex:\n\
    <code>\n^(?(DEFINE)\n    (?<open>\\((?>[^()]+|(?&open))+\\))\n    (?<close>\\\
    )))(?&open)(?&close)*$\n</code>\nIt has this explanation:\n<code>\n^         \
    \                  beginning of line\n(?(DEFINE)                  define a named\
    \ subpattern open\n    (?<open>\\((?>[^()]+|(?&open))+\\))\n    (?<close>\\)))\
    \                 define a named subpattern close\n    (?&open)(?&close)*    \
    \      match the opening subpatterns once or none at all\n$                  \
    \         end of line\n</code>\n<|/ a dscore=2 |>\n<| a tags=regex,php |>\nThis\
    \ is one way to do it:\n<code>\n<?php\n\n$tests = array(\n", "    if ($brackets[0]\
    \ != \"(\")\n        return false;\n\n    $stack = [];\n    foreach (preg_split(\"\
    /[()]/\", $brackets, -1, PREG_SPLIT_NO_EMPTY) as $token) {\n        if ($token\
    \ == \"(\") {\n            $stack[] = $token;\n        } elseif ($token == \"\
    )\") {\n            while (!empty($stack) && $stack[count($stack) - 1] != \"(\"\
    ) {\n                $result .= array_shift($stack);\n            }\n        \
    \    $stack[] = $token;\n        } else {\n            $stack[] = $token;\n  \
    \      }\n    }\n\n    return count($stack) == 0;\n}\n</code>\n<|/ a tags=php,brackets,parentheses\
    \ dscore=5 |>\n<| c |>\nThis is excellent, thank you. It even works with nested\
    \ brackets properly, like \"()())()()\".\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for brackets with mixed types (i.e. {()()()})\n<|/ c |>\n<| c |>\nThe code doesn't\
    \ even seem to return anything when I give it \"(()()()\" and \"()())()\"\n<|/\
    \ c |>\n<| a tags=php,brackets,parentheses |>\n<code>", "  preg_match_all(\"/(\\\
    (|\\))/\", $brackets, $matches);\n  return count($matches[0]) == count($matches[1]);\n\
    }\n", "\t$brackets = preg_replace('/\\s+/', '', $brackets);\n\t$brackets = preg_replace('/[^\\\
    S\\(]+/', '', $brackets);\n\t$brackets = preg_replace('/\\(([^()]+)\\)/', '$1',\
    \ $brackets);\n\t$brackets = preg_replace('/\\([^()]+\\)/', '', $brackets);\n\t\
    return ($brackets === '()') ? true : false;\n}\n", "  if ($brackets == '(') return\
    \ true;\n  if ($brackets == '[' || $brackets == '(' || $brackets == '{' || $brackets\
    \ == '<') return true;\n  if ($brackets == '[' || $brackets == '<') return true;\n\
    \  if ($brackets == '{' || $brackets == '>') return true;\n  return false;\n}\n",
  "  $brackets = explode(\",\", $brackets);\n  foreach ($brackets as $b) {\n    if\
    \ (substr($b, -1) != ')') {\n      return false;\n    }\n    if (substr($b, 0,\
    \ 1) != '(') {\n      return false;\n    }\n  }\n  return true;\n}\n", "    return\
    \ count($brackets) === strlen(preg_replace('~[\\(\\)]~', '', $brackets)); \n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=regex,php |>\nHere is a simple approach\n\
    <code>\n$str = '(([abc])|[ef])';\npreg_match_all('/^\\(|\\)$/', $str, $m);\nif\
    \ (count($m[0]) === 1) return false; \nreturn count($m[0]) === count($m[1]);\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\n+1 This could probably be improved with a\
    \ `return count($m[0]) === count($m[1]);` at the end.\n<|/ c |>\n<| c |>\nI believe\
    \ `count()` returns 0 when there are no matches.\n<|/ c |>\n<| c |>\nHmm, didn't\
    \ know that -- I thought it would throw a warning.  Thanks!\n<|/ c |>\n<| c |>\n\
    It returns `0` but returns false because `preg_match_all` returns a boolean not\
    \ a count of the number of matches.\n<|/ c |>\n<| a |>\nYou can't do this with\
    \ a single regular expression.  It can certainly be done with a series of tests,\
    \ but you'd have to test each character individually.\n<|/ a tags=regex,php dscore=0\
    \ |>\n<| a dscore=0 tags=regex,php |>\nThe simplest way would be to use preg_match\
    \ or preg_match_all to check each opening or closing bracket individually. \n\
    <code>\n$brackets = array(\"(\", \")\");\n$open = preg_match_all('/['.$brackets.']/',\
    \ $string);\n\n$string = str_replace(array_flip($brackets), $brackets[0], $string);\n\
    $close = preg_match_all('/['.$brackets.']/', $string);\n\nreturn $open + $close\
    \ == count($brackets);\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis should do the\
    \ trick:\n<code>\n$str = '(((()())))';\n\n$count = preg_match_all('~\\(([)\\(\\\
    )\\]])~', $str, $m);\n\nif ($count === 1) {\n    return false;\n}\nreturn $count\
    \ === strlen($m[0]);\n</code>\n<|/ a tags=regex,php |>\n<| a tags=regex,php |>\n\
    This might be overkill but here is what I've come up with since I was curious\
    \ about how to do this\n<code>\n$str = '(((()())))';\n\n$count = ", "  return\
    \ preg_match('/^('. preg_quote($brackets, '/') .\n                     ')?/',\
    \ function($m) {\n    return $m[0];\n  }) !== null;\n}\n</code>\n<|/ a dscore=5\
    \ tags=regex,php |>\n<| c |>\nWon't this fail for `([)](abc))`?\n<|/ c |>\n<|\
    \ c |>\n: No, since `[...]` does not match `(...)`.\n<|/ c |>\n<| a tags=regex,php\
    \ dscore=4 |>\nSince I asked this question PHP has added a strrpos() function\
    \ that returns the offset of a needle in a haystack.\n<code>", "    $opening =\
    \ strpos($brackets, \"(\");\n    $closing = strpos($brackets, \")\");\n    return\
    \ $opening !== false && $closing !== false;\n}\n", "    $opens = explode(\")\"\
    , $brackets);\n    foreach ($opens as $key => $val) {\n        if (preg_match(\"\
    /\\)/\", $opens[$key + 1])) {\n            $opens[$key + 1] = \")\";\n       \
    \ }\n    }\n    return count(array_unique($opens)) === count($opens);\n}\n", " \
    \ $brackets_length = strlen($brackets);\n  \n  for ($i = 0; $i < $brackets_length;\
    \ $i++) {\n    $char = substr($brackets, $i, 1);\n    if ($char != '(' && $char\
    \ != ')') {\n      return false;\n    }\n  }\n  \n  return true;\n}\n</code>\n\
    <|/ a tags=php,regex dscore=1 |>\n<| c |>\nThank you for your answer, but unfortunately\
    \ it doesn't work for me. I'll try to explain my situation a bit better.\nWhat\
    \ I need to check is if there are opening brackets left and right of another,\
    \ and if they are separated by a specific symbol. For example: ()()\n<|/ c |>\n\
    <| a tags=php,regex |>\n<code>\n<?php\n\n$brackets = '()';\n\n$bracketsArray =\
    \ preg_split('/\\(([^)]+)\\)/', $brackets);\n$bracketsArray = array_filter(array_map(function($el){\n\
    \    return trim($el);\n}, $bracketsArray));\n\nvar_dump($bracketsArray);\n",
  "    return preg_match_all('/[()]/', $brackets);\n}\n", "  foreach (explode($brackets)\
    \ as $bracket) {\n    // if brackets aren't balanced, return False.\n    if (!is_balanced(\"\
    $bracket\")) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  return\
    \ preg_match('/^('.$brackets.'*)\\1$/', $brackets);\n}\n", "  for ($i = 0; $i\
    \ < strlen($brackets); $i++) {\n    if ($brackets[$i] !== \"(\" && $brackets[$i]\
    \ !== \")\") return false;\n  }\n  return true;\n}\n", "  $opening_brackets =\
    \ preg_split(\"/(\\(\\))/\", $brackets);\n  $closing_brackets = preg_split(\"\
    /(\\(\\))/\", $brackets);\n  return ($opening_brackets == $closing_brackets);\n\
    }\n</code>\n<|/ a tags=php,regex,brackets,string |>\n<| a |>\nHere's a regular\
    \ expression that should work for any number of open brackets. In PHP you can\
    \ use this with preg_replace():\n<code>\n/[()]*(?![^(]*\\))/\n</code>\nThis regular\
    \ expression will find an open bracket followed by any number of zero or more\
    \ characters that are not an open bracket, followed by zero or more close brackets.\n\
    <|/ a dscore=3 tags=php,regex,brackets,string |>\n<| c |>\nThanks to everyone\
    \ that answered or even gave answers on my last questions. Thank you everyone\
    \ for helping me with my questions. I really appreciate it.\n<|/ c |>\n<| c |>\n\
    Thank you for your answer but I did it like this. I used str_replace and found\
    \ out all the brackets and replaced them with a space and then I did a strlen\
    \ to check for brackets. I just wanted to find a way to do it with preg replace\
    \ but I couldn't get it working. Thanks to everyone else who answered!\n<|/ c\
    \ |>\n<| a tags=php,regex,brackets,string |>\nThis is an alternative to the other\
    \ answers that uses preg_match_all():\n<code>\n$string = strtr($string, array('[']=>'\
    \ ', ']'=>'', '('=>'', ')'=>''));\npreg_match_all('/(\\([^\\)]+\\))/', $string,\
    \ $matches);\n$opening_brackets = $matches[0][0];\n$closing_brackets = $matches[0][1];\n\
    </code>\nThis takes advantage of the fact that preg_match_all will return every\
    \ match it finds in a sub-array that matches every bracket pair in $string, even\
    \ if it's outside a pair (it only returns the substring it matches).  By replacing\
    \ [ and ] with spaces, it becomes easier to get all of the substring matches.\n\
    <|/ a dscore=3 |>\n<| c |>\nThis answer would be better if you explained how it\
    \ works.\n<|/ c |>\n<| c |>\nI've added an explanation.\n<|/ c |>\n<| c |>\nJust\
    \ to be clear, your regular expression also allows spaces between the brackets\n\
    <|/ c |>\n<| a tags=php,regex,", "\t$opening = substr($brackets, 0, 1);\n\t$closing\
    \ = substr($brackets, 1, 1);\n\t$correct = false;\n\tfor ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n\t\t$current = substr($brackets, $i, 1);\n\t\t$next = substr($brackets,\
    \ $i + 1, 1);\n\t\tif ($opening == $current) {\n\t\t\tif ($closing != $next) {\n\
    \t\t\t\t$correct = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$closing = '';\n\t\t\
    } else {\n\t\t\tif ($closing != $next) {\n\t\t\t\t$correct = true;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t\t$closing = '';\n\t\t}\n\t}\n\treturn $correct;\n}\n", "  return\
    \ preg_match('/\\('.str_repeat('|', $brackets).'\\)/', $brackets);\n}", "  $brackets_array\
    \ = array();\n  $brackets_string = \"\";\n  foreach ($brackets as $bracket) {\n\
    \    if ($brackets_string != \"\") {\n      $brackets_string .= \")\";\n    }\n\
    \    $brackets_string .= $bracket;\n    $brackets_array[] = $brackets_string;\n\
    \    $brackets_string = \"\";\n  }\n  return count($brackets_array) == count($brackets);\n\
    }\n", "\treturn preg_match('/\\((\\))/', $brackets);\n}\n", "  if (strlen($brackets)\
    \ % 2 == 1)\n    return False;\n  $opening_brackets = str_split($brackets, 2);\n\
    \  $closed_brackets = array_reverse($opening_brackets);\n  foreach ($closed_brackets\
    \ as $opening_closed_bracket) {\n    if ($opening_closed_bracket[0] != \"(\" ||\
    \ $opening_closed_bracket[1] != \")\")\n      return False;\n  }\n  return True;\n\
    }\n", "  return count(explode($brackets, $brackets)) % 2 == 1;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work if brackets are balanced, but then\
    \ it's just a matter of counting the number of open brackets. So the solution\
    \ is `return strlen($brackets) % 2 == 0;`. :-P\n<|/ c |>\n<| c |>\nWhat if your\
    \ brackets are in the wrong order, like \"(()())\"?\n<|/ c |>\n<| c |>\nWhat if\
    \ your brackets are in the wrong order, like \"(()())\"?\n<|/ c |>\n<| c |>\n\
    Yes, this solution is better for balanced brackets. But it doesn't work for nested\
    \ brackets (i.e. \"()()\") because the function will find an additional pair of\
    \ parentheses and return \"True\". My function solves the problem, and I explained\
    \ it in my answer. :-)\n<|/ c |>\n<| c |>\nYou're right. It doesn't work. My bad.\
    \ I was in a hurry when wrote the function. Thanks!\n<|/ c |>\n<| a tags=php dscore=2\
    \ |>\n<code>\n<?php\n\n$string = '(()()())';\n\n$array = explode('()', $string);\n\
    \nfor ($i = 0; $i < count($array); $i++) {\n    $array[$i] .= $array[$i];\n}\n\
    \n$array[0] .= '()';\n\n$string = implode('()', $array);\n\necho $string;\n</code>\n\
    <|/ a |>\n<| c |>\nYes, it's simple and easy. Why should we complicate things?\n\
    <|/ c |>\n<| c |>\nIt's not that complicated ;)\n<|/ c |>\n<| c |>\n`strlen` is\
    \ O(N), so this solution will cause a performance issue. It's also slower than\
    \ other solutions, because you're making two extra function calls (`strlen`, `explode`)\
    \ and the PHP `foreach` loop.\n<|/ c |>\n<| a |>\nAs others have noted, regular\
    \ expressions are the way to go, but here's a recursive PHP version (which is\
    \ pretty fast):\n<code>\n<?php", "  $opens = $openings = array();\n  $closes =\
    \ $closings = array();\n  for ($i = 0; $i < strlen($brackets); $i++) {\n    $open\
    \ = $brackets[$i];\n    if ($open === '(') {\n      $openings[] = $open;\n   \
    \   $closed = false;\n      for ($j = 0; $j < count($openings); $j++) {\n    \
    \    $op = $openings[$j];\n        if (!$closed) {\n          if ($closings[$op]\
    \ !== $open) {\n            $closes[$op] = $open;\n            $closings[$op]\
    \ = $open;\n          }\n        } else if ($closings[$op] === $open) {\n    \
    \      unset($closings[$op]);\n        }\n      }\n    } else if ($open === ')')\
    \ {\n      $closings[] = $open;\n      $closed = false;\n      for ($j = 0; $j\
    \ < count($openings); $j++) {\n        $op = $openings[$j];\n        if (!$closed)\
    \ {\n          if ($openings[$j] !== $close) {\n            $openings[$j] = $close;\n\
    \            $opens[$op] = $close;\n          }\n        } else if ($openings[$j]\
    \ === $close) {\n          unset($openings[$j]);\n        }\n      }\n    }\n\
    \  }\n  // if every opening bracket has a corresponding closing bracket,\n  //\
    \ then return True\n  for ($i = 0; $i < count($openings); $i++) {\n    if ($closings[$i]\
    \ === $opens[$i]) {\n      return true;\n    }\n  }\n  return false;\n}\n", " \
    \   $brackets = explode(\",\", $brackets);\n    foreach ($brackets as $bracket)\
    \ {\n        if (substr($bracket, 0, 1) != '(') return false;\n        if (substr($bracket,\
    \ -1, 1) != ')') return false;\n    }\n    return true;\n}\n\n$files = new RecursiveIteratorIterator(new\
    \ RecursiveDirectoryIterator(\".\"));\n\n$file_count = 0;\n$file_count_incorrect\
    \ = 0;\n$file_count_correct = 0;\n$file_count_correctly_closed = false;\n\nforeach\
    \ ($files as $file) {\n    if ($file->isFile() && ! $file->isLink()) {\n     \
    \   $file_count++;\n        $correctly_closed = correct_bracketing($file->getRealPath());\n\
    \        if ($correctly_closed) {\n            $file_count_correctly_closed++;\n\
    \        } else {\n            $file_count_incorrect++;\n        }\n    } else\
    \ {\n        $file_count++;\n    }\n}\n\n$percent_correct = ($file_count_correct\
    \ / $file_count) * 100;\n$percent_incorrect = ($file_count_incorrect / $file_count)\
    \ * 100;\n\n$file_count_correctly_closed\n    = $file_count_correctly_closed ?\
    \ \"$file_count_correctly_closed\" : 0;\n", "  $open_count = 1;\n  $close_count\
    \ = 1;\n  for ($i = 1; $i < strlen($brackets); ++$i) {\n    $bracket = $brackets[$i];\n\
    \    if ($bracket == \"(\") {\n      ++$open_count;\n    } elseif ($bracket ==\
    \ \")\") {\n      ++$close_count;\n    } else {\n      return false;\n    }\n\
    \  }\n  return $open_count == $close_count;\n}\n\n/**\n * Removes comments from\
    \ the contents of a file.\n * @param string $filename\n * @return string\n */",
  "  $length = strlen($brackets);\n  for ($i = 0; $i < $length; $i++) {\n    if ($brackets[$i]\
    \ == \"(\") {\n      if ($brackets[$i+1] == \")\") {\n        $i++;\n        if\
    \ ($brackets[$i] == \"(\") {\n          if ($brackets[$i+1] == \")\") {\n    \
    \        $i++;\n          }\n        }\n      }\n    }\n  }\n  return !($i ==\
    \ $length);\n}\n</code>\n<|/ a tags=regex,php |>\n<| a tags=regex,php |>\nThis\
    \ is what I came up with:\n<code>", "  if (strlen($brackets) < 2) return False;\n\
    \  $brackets_array = array_fill(1, strlen($brackets), '(');\n  $brackets_array\
    \ = array_reverse($brackets_array);\n  list($opening_brackets, $closing_brackets)\
    \ = array_map('trim', explode(')', $brackets));\n  foreach ($brackets_array as\
    \ $index => $bracket) {\n    if ($bracket == $opening_brackets[$index]) {\n  \
    \    $brackets_array[$index] = $opening_brackets[$index];\n      $closing_brackets[$index]\
    \ = ')';\n    } else if ($bracket != $closing_brackets[$index]) {\n      return\
    \ False;\n    }\n  }\n  return $closing_brackets[count($brackets_array)-1] ==\
    \ '(';\n}\n</code>\n<|/ a tags=regex,php,code-cleanup,coding-style |>\n<| c |>\n\
    I think you should do $opening_brackets = preg_replace('/(\\s+)/', \"\\(\\1\"\
    , $opening_brackets); so that you don't get an empty string for $opening_brackets\
    \ when the closing bracket is at the end of the line.\n<|/ c |>\n<| c |>\nGood\
    \ point, will edit. I believe it's because of the `array_fill` which returns an\
    \ empty string for a 0-length string if the length is 0.\n<|/ c |>\n<| a tags=regex,php,code-cleanup,coding-style\
    \ dscore=2 |>\nNot that it's necessarily better or worse than yours, but a similar\
    \ pattern I sometimes use to replace a whole line is as follows\n<code>\n$pattern\
    \ = '/\\/\\*([^*]+)\\*\\/[\\r\\n]+/';\n$new_file= preg_replace($pattern, '', file_get_contents($old_file));\n\
    </code>\nThis is basically reading the file line-by-line and replacing anything\
    \ between two /* */ tags with an empty string.\n<|/ a |>\n<| a dscore=2 |>\nThe\
    \ first thing I would do is to replace the for loop with a foreach loop.  Then\
    \ I would put the opening bracket on the end of the line.  Now the opening bracket\
    \ is on one line and the closing bracket is on the next.\n<code>\n$output = array();\n\
    \nforeach ($fileContent as $line) {\n  $lineClean = trim(str_replace(array(\"\\\
    t\", \"\\n\", \"\\r\", \"!\"), ' ', $line));\n  $bracket = substr($lineClean,\
    \ -1);\n  if(!in_array($bracket, array(\"(\", \")\", \"{\", \"}", "    return\
    \ (strpos($brackets, \"))\") === strlen($brackets) - 1);\n}\n", "\t$brackets =\
    \ trim($brackets);\n\t$brackets = preg_replace('/\\(\\)/', '(', $brackets);\n\t\
    $brackets = preg_replace('/\\(\\(/', '(', $brackets);\n\treturn preg_match('/\\\
    (\\)/', $brackets);\n}\n", "    // The brackets parameter can be empty if all\
    \ brackets are correct!\n    if (empty($brackets)) return true;\n    \n    //\
    \ Initialize $bracketsCount with number of opening brackets.\n    $bracketsCount\
    \ = preg_match_all(\"/\\(([^()]+)\\)/\", $brackets, $matches);\n    $bracketsCount\
    \ = $matches[1];\n    \n    // If there are no closing brackets, return true.\n\
    \    if (count($bracketsCount) == 0) return true;\n    \n    // If $bracketsCount\
    \ does not equal the number of closing brackets, return false.\n    if (count($bracketsCount)\
    \ != count($bracketsCount)) {\n        return false;\n    }\n    \n    // Go through\
    \ every opening bracket and count how many of them have corresponding closing\
    \ brackets.\n    foreach ($bracketsCount as $i => $bracket) {\n        // If this\
    \ opening bracket does not have a corresponding closing bracket, return false.\n\
    \        if ($bracket != \"(\") {\n            return false;\n        }\n    \
    \    \n        // Otherwise, increment $bracketsCount.\n        $bracketsCount[$i]\
    \ = $bracketsCount[$i] + 1;\n    }\n    \n    // If all bracketsCount are equal,\
    \ return true.\n    if (count($bracketsCount) == count($bracketsCount)) {\n  \
    \      return true;\n    }\n    \n    // If there are any brackets that don't\
    \ match, or there are any brackets that do match, return false.\n    return false;\n\
    }\n</code>\n<|/ a tags=brackets,php,string dscore=1 |>\n<| a |>\nI suggest a solution\
    \ that uses a regex to match the brackets:\n<code>\n$s = \"(()())()\";\npreg_match_all('/\\\
    (([^\\)]+)\\)/', $s, $matches, PREG_SET_ORDER);\nvar_export($matches);\n</code>\n\
    Output\n<code>\narray (\n  0 => \n  array (\n    0 => '(()()',\n  ),\n  1 => \n\
    \  array (\n    0 => '(()',\n  ),\n  2 => \n  array (\n    0 => '()',\n  ),\n\
    )\n</code>\nThen you can do an array_map to count the matches.\n<code>\n$s = $matches[0];\n\
    $count = array_count_values($s);\nvar_export($count);\n</code>\nOutput\n<code>\n\
    array (\n  '(' => 2,\n  ')' => 2,\n)\n</code>\n<|/ a dscore=0 tags=brackets,php,string\
    \ |>\n<| a dscore=0 |>\nYou asked for regex to count brackets but you said you\
    \ didn't want regex, so here", "  if (strlen($brackets)!=2) return false;\n  $opening\
    \ = substr($brackets,0,1);\n  $closing = substr($brackets,1,1);\n  if ($opening=='('\
    \ && $closing==')') return true;\n  if ($opening=='[' && $closing==']') return\
    \ true;\n  if ($opening=='{' && $closing=='}') return true;\n  return false;\n\
    }\n", "    $opens = array();\n    $closes = array();\n    for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n        if ($brackets[$i] == \"(\") $opens[] = $i;\n        if ($brackets[$i]\
    \ == \")\") $closes[] = $i;\n    }\n    if (count($opens) < count($closes)) return\
    \ false;\n    for ($i = 0; $i < count($opens); $i++) {\n        if ($opens[$i]\
    \ != $closes[$i]) return false;\n    }\n    return true;\n}\n", "\t$brackets =\
    \ explode(')', $brackets);\n\t$n = 0;\n\tforeach ($brackets as $b) {\n\t\twhile\
    \ ($n >= count($brackets) - 1 &&\n\t\t    $brackets[$n + 1] == $b) { $n++; }\n\
    \t\tif ($n == count($brackets) - 1) return false;\n\t\tif ($brackets[$n + 1] !=\
    \ $b) {\n\t\t\tif ($b == '(') return true;\n\t\t\tif ($b == ')') return false;\n\
    \t\t}\n\t\t$n++;\n\t}\n\treturn false;\n}\n", "    $opens = preg_match_all('/\\\
    ((.*)\\)/', $brackets, $matches);\n    $closes = preg_match_all('/\\((.*)\\)/',\
    \ $brackets, $matches);\n    return ($opens == $closes)? true: false;\n}\n", " \
    \   $count = count($brackets);\n    if ($count < 2) {\n        return false;\n\
    \    }\n\n    for ($i = 1; $i < $count; $i++) {\n        if (!is_pair($brackets[$i],\
    \ $brackets[$i - 1])) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n", "    $stack = 0;\n    $stackPtr = -1;\n    for($i = 0; $i < strlen($brackets);\
    \ $i++) {\n        if($brackets[$i] == \")\") {\n            $stack--;\n     \
    \       if($stack == 0) {\n                $stackPtr = $i;\n            }\n  \
    \      } else {\n            $stack++;\n        }\n        if($stack == 0) {\n\
    \            if($brackets[$i] != \"(\") {\n                return false;\n   \
    \         }\n        }\n    }\n    return ($stackPtr == -1);\n}\n", "  if ($brackets\
    \ == '()') {\n    return true;\n  }\n  foreach (str_split($brackets) as $bracket)\
    \ {\n    if (preg_match('/' . $bracket . '/', $brackets)) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nYour solution\
    \ does appear to be more elegant than the one I came up with on my own, but I\
    \ would have to agree that the second solution would be more elegant (at least\
    \ to some extent).\n<|/ c |>\n<| c |>\nIt depends on the context -- I find this\
    \ more readable than a regular expression. I'm no regex expert, so I suppose it\
    \ could be argued that it's more elegant, but also more readable, too.\n<|/ c\
    \ |>\n<| a |>\n<code>\n<?php", "  // Convert string to a character array and remove\
    \ any whitespace.\n  $brackets = array_map('trim', str_split($brackets));\n  $numOpeningBrackets\
    \ = count($brackets) - 1;\n  for ($i = 0; $i < $numOpeningBrackets; $i++) {\n\
    \    // If this opening bracket doesn't have a corresponding closing bracket,\n\
    \    // then we are done.\n    if ($brackets[$i] !== \"(\") {\n      return true;\n\
    \    }\n  }\n  for ($i = 0; $i < $numOpeningBrackets; $i++) {\n    // If this\
    \ closing bracket doesn't have an opening bracket, then we\n    // are done.\n\
    \    if ($brackets[$i] !== \")\") {\n      return true;\n    }\n  }\n  return\
    \ false;\n}\n", "  $open_brackets = 0;\n  $open_brackets_chars = array();\n  $open_brackets_depth\
    \ = 0;\n  foreach ($brackets as $char) {\n    if ($char === '(') {\n      $open_brackets++;\n\
    \      $open_brackets_chars[] = $char;\n      $open_brackets_depth++;\n    } else\
    \ {\n      if ($char === ')') {\n        $open_brackets--;\n        if (!$open_brackets)\
    \ {\n          $open_brackets_chars = array_merge($open_brackets_chars, array_reverse($open_brackets_chars));\n\
    \          $open_brackets_depth--;\n        }\n      } else {\n        if ($open_brackets_depth\
    \ === 0) {\n          return false;\n        }\n      }\n    }\n  }\n  if ($open_brackets_depth\
    \ === 0) {\n    return true;\n  }\n  return false;\n}\n", "  $brackets = trim($brackets);\n\
    \  $open = 0;\n  $closed = 0;\n  for ($i=0; $i<strlen($brackets); $i++) {\n  \
    \  if ($brackets[$i] == \"(\") {\n      $open++;\n    } else if ($brackets[$i]\
    \ == \"(\") {\n      $open--;\n    } else {\n      $closed++;\n    }\n    if ($open\
    \ == 0 && $closed == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n",
  "  // We don't care about whether there are any brackets at all.\n  if (strpos($brackets,\
    \ \")\") === false || strpos($brackets, \"(\") === false) {\n    return false;\n\
    \  }\n\n  // Keep an index so we can keep track of how many brackets we have seen.\n\
    \  $open_brackets = 0;\n  // Keep a running total of the number of closing brackets\
    \ we have.\n  $closing_brackets = 0;\n  // Keep track of whether or not the brackets\
    \ match up.\n  $brackets_match = false;\n\n  // Loop through all the characters\
    \ in the brackets.\n  foreach (str_split($brackets) as $character) {\n    // Is\
    \ the character an opening bracket?\n    if ($character === \"(\") {\n      //\
    \ If so, increment our counter and set $brackets_match to true.\n      $open_brackets++;\n\
    \      $brackets_match = true;\n    }\n    else if ($character === \")\") {\n\
    \      // If so, decrement our counter and set $brackets_match to true.\n    \
    \  $closing_brackets++;\n      if ($open_brackets !== $closing_brackets) {\n \
    \       $brackets_match = false;\n      }\n    }\n  }\n\n  // If we have an incorrect\
    \ number of brackets, return false.\n  if ($open_brackets !== $closing_brackets)\
    \ {\n    return false;\n  }\n\n  // If we have the same number of brackets, and\
    \ the brackets match,\n  // return true.\n  return $brackets_match;\n}\n", " \
    \ if(strlen($brackets)!=1) {\n    return false;\n  }\n  $brackets = strtolower($brackets);\n\
    \  for($i = 0; $i < strlen($brackets); $i++) {\n    if($brackets[$i] != ')' &&\
    \ $brackets[$i] != '(') {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "  return preg_match(\"/^(.*\\()$/\", $brackets) !== false;\n}\n", "    $opening\
    \ = preg_match(\"/\\(([^\\)]*)\\)/\", $brackets, $match);\n    $closing = preg_match(\"\
    /\\(([^()]*\\))/\", $brackets, $match2);\n    return $opening === $closing;\n\
    }\n", "  // Write your code here\n  $brackets = explode(\",\", $brackets);\n \
    \ for ($i = 0; $i < count($brackets); $i++) {\n    for ($j = count($brackets);\
    \ $j > 0; $j--) {\n      if ($brackets[$i] == $brackets[$j - 1]) {\n        unset($brackets[$j]);\n\
    \      }\n    }\n  }\n  $brackets = implode(\",\", $brackets);\n  echo $brackets;\n\
    }", "    return preg_match('/^\\(([^()]+)\\)$/', $brackets, $matches);\n}", " \
    \   $brackets = preg_replace('/(.*)/', '$1', $brackets);\n    if (strlen($brackets)\
    \ == 0) {\n        return false;\n    }\n    $brackets = array_flip($brackets);\n\
    \    for ($i = 0; $i < strlen($brackets); ++$i) {\n        if (!isset($brackets[$i]))\
    \ return false;\n        if (!isset($brackets[$i+1])) return true;\n        if\
    \ ($brackets[$i] >= $brackets[$i+1]) return false;\n    }\n    return true;\n\
    }\n</code>\n<|/ a tags=php,syntax-error |>\n<| c |>\nThis seems like the best\
    \ solution so far as I can tell. The only thing is that the first check passes\
    \ if $brackets is just '()', so I removed it altogether and everything works fine.\
    \ Thanks!\n<|/ c |>\n<| a tags=php,syntax-error |>\nThe PHP interpreter doesn't\
    \ understand that $brackets is the end of a string, but rather that it's a string\
    \ of characters that end in parenthesis. This is what the error is telling you\
    \ when it comes to parsing it.\n<code>\nif ($brackets == \")((\")) {\n</code>\n\
    is actually\n<code>\nif ($brackets == \")((\") ==> if ($brackets == \")((\") ==\
    \ true) {\n</code>\nYou need to add some logic that looks to see if the brackets\
    \ string is complete, such as\n<code>\nif ($brackets == \")((\") || $brackets\
    \ == \")((\") == true)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI don't believe that\
    \ will work, considering that he needs to check for both matching brackets.\n\
    <|/ c |>\n<| c |>\n: You mean like `if ($brackets == \")((\") && $brackets ==\
    \ \")((\") == true)`?\n<|/ c |>\n<| a tags=php,syntax-error |>\nI realise I'm\
    \ late to the party, but this problem comes up a lot, and I'm surprised no one\
    \ has brought up this yet. \nThe solution is to just add a \\ to the opening parenthesis.\
    \ \n<code>\nif (strlen($brackets) == 3 && $brackets == '\\(')\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=php,syntax-error |>\nI came across this question while\
    \ trying to solve a similar problem. My goal was to determine if my data was valid\
    \ (no invalid characters, no missing brackets) and also determine if it was \"\
    nested\" (inside another set of parentheses). To do this, I first removed all\
    \ non-numeric characters and then did a preg_match ", "    $stack = array();\n\
    \    $brackets = preg_replace('!\\(+!', '(', $brackets);\n    $brackets = preg_replace('!\\\
    )+!', ')', $brackets);\n    $brackets = preg_replace('!\\(|\\)+!', '', $brackets);\n\
    \    $brackets = preg_replace('!\\)+!', '', $brackets);\n    return $brackets\
    \ == '';\n}\n</code>\n<|/ a tags=php,validation |>\n<| c |>\nThat's a good idea.\
    \ I've got many other checks, but this one might be the most difficult to implement.\
    \ I'll give it a shot, thanks!\n<|/ c |>\n<| c |>\nI've been trying to implement\
    \ this, but I keep getting the following error: `PHP Fatal error:  Call to undefined\
    \ function array_map()`. Could you give me a bit more direction on how to do that?\n\
    <|/ c |>\n<| c |>\nWhat version of PHP do you have?\n<|/ c |>\n<| c |>\nI added\
    \ a PHP 5.3 solution to the answer, since `array_map` was added in 5.3.\n<|/ c\
    \ |>\n<| c |>\nI have 5.3.14. Sorry for all the questions, but how do I go about\
    \ installing 5.3?\n<|/ c |>\n<| a dscore=1 tags=php,validation |>\nI thought of\
    \ one possible solution. Try using regular expressions to verify your input.\n\
    <code>\n<?php\n$brackets = '(((())(())(())(())(())))';\n\n$brackets = preg_replace('/[()]/',\
    \ '', $brackets);\n$brackets = preg_replace('/[()]/', '', $brackets);\n$brackets\
    \ = preg_replace('/\\)/', '', $brackets);\n\n$brackets = preg_replace('/\\)/',\
    \ '', $brackets);\n$brackets = preg_replace('/\\)/', '', $brackets);\n$brackets\
    \ = preg_replace('/\\)/', '', $brackets);\n$brackets = preg_replace('/\\)/', '',\
    \ $brackets);\n$brackets = preg_replace('/\\)/', '', $brackets);\n$brackets =\
    \ preg_replace('/\\)/', '', $brackets);\n$brackets = preg_replace('/\\)/', '',\
    \ $brackets);\n$brackets = preg_replace('/\\)/', '', $brackets);\n$brackets =\
    \ preg_replace('/\\)/', '', $brackets);\n$brackets = preg_replace('/\\)/', '',\
    \ $brackets);\n", "  $count = count($brackets);\n  $opening_brackets = preg_match_all('/\\\
    (/', $brackets);\n  $closing_brackets = preg_match_all('/\\)/', $brackets);\n\n\
    \  return $opening_brackets == $count && $closing_brackets == $count;\n}\n</code>\n\
    The above code was tested and works as intended.\n<|/ a tags=arrays,php |>\n<|\
    \ c |>\nThanks! This helped me a lot!\n<|/ c |>\n<| c |>\nThank you for your reply.\
    \ Strangely enough, your code didn't work for me (it only works for some input\
    \ strings). However, the following code worked: \n`function check_brackets ($string)\
    \ {\n  $opening_brackets = preg_match_all('/\\(/', $string);\n  $closing_brackets\
    \ = preg_match_all('/\\)/', $string);\n  $opening_brackets = $opening_brackets\
    \ ? $opening_brackets : 0; $closing_brackets = $closing_brackets ? $closing_brackets\
    \ : 0; \n  return $opening_brackets + $closing_brackets == count($string);\n}`\n\
    <|/ c |>\n<| a dscore=3 |>\nHere is my solution:\n<code>", "  foreach (str_split($brackets)\
    \ as $b) {\n    if (in_array($b, \"(\")) {\n      if (!in_array($b, \")\")) {\n\
    \        return true;\n      }\n    }\n  }\n  return false;\n}\n", "  $opening_brackets\
    \ = array_count_values(str_split($brackets));\n  foreach ($opening_brackets as\
    \ $opening_bracket => $count) {\n    if ($count != 1) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "  return preg_match('/^([' . $brackets . '])+$/',\
    \ $brackets);\n}\n</code>\n<|/ a |>\n<| c |>\nI wouldn't worry too much about\
    \ that regex. If it works for your purposes then you know that you are good.\n\
    <|/ c |>\n<| c |>\nI agree with you on this. I have used similar approaches in\
    \ the past and this one seems to do the job quite well. I added some comments\
    \ to my answer so you could follow the way I did.\n<|/ c |>\n<| c |>\nThanks for\
    \ this, I appreciate the comments and I'm going to try this out. I'm new to php\
    \ so I'm still digesting the code.\n<|/ c |>\n<| c |>\nI went ahead and implemented\
    \ this and it works, thanks again. I'm going to take a deeper look at this solution\
    \ tomorrow and will update this question with any findings.\n<|/ c |>\n<| a |>\n\
    Here's a more general solution:\n<code>", "  $stack = array();\n  $brackets =\
    \ trim($brackets);\n  foreach (str_split($brackets) as $char) {\n    if ($char\
    \ == '(') {\n      $stack[] = $char;\n    }\n    else if ($char == ')') {\n  \
    \    if (empty($stack)) {\n        return false;\n      }\n      $stack = array_pop($stack);\n\
    \    }\n  }\n  return empty($stack);\n}\n</code>\n<|/ a |>\n<| c |>\nYour code\
    \ doesn't actually work on the example: \"(()())\" returns true and should be\
    \ false. That's because you are counting open brackets not closing brackets.\n\
    <|/ c |>\n<| a tags=php,regex dscore=4 |>\nTry this regex with preg_match :\n\
    <code>\n/[\\(\\)]/\n</code>\n<|/ a |>\n<| c |>\nThis will also match `()`\n<|/\
    \ c |>\n<| c |>\nYes, but i think this is unnecessary because this string can\
    \ only have one open bracket and only one close bracket.\n<|/ c |>\n<| a dscore=4\
    \ |>\nThe below regex will check for brackets matching your specification (i.e.\
    \ no nested brackets and no multiple opening and closing brackets)\n<code>\npreg_match('/\\\
    \\([^()]*\\\\)/', $subject, $matches);\n</code>\nThe regex basically means: Match\
    \ (, then zero or more characters that are not ( or ) followed by another ) and\
    \ save the result in the $matches array.\n<|/ a tags=php,regex |>\n<| c |>\nThe\
    \ regex works for me in Python with re.compile (Python 2.7.13), but in PHP it\
    \ does not seem to work. Does it work for you in PHP?\n<|/ c |>\n<| a tags=php,regex\
    \ |>\nI did a quick test with some test cases and found that using [^()] as per\
    \ the other answers did not work, instead this worked for me \n<code>\n/(\\(|\\\
    )|(\\(|\\)|(\\(|\\))|(\\(|\\)))/\n</code>\nTest cases: \n\n(())(()()) \n(())(()()())\
    \ \n(()()()) \n(()) \n() \n()()()() \n()) \n()()()) \n())(()) \n())) \n(()) \n\
    (()()) \n(()()) \n(()()()) \n(()()())\n\nIt did not work with multiple opening\
    \ and closing parentheses though.\n<|/ a dscore=4 |>\n<| c |>\nIt does not work\
    \ with multiple opening and closing brackets in PHP", "    // your code here\n\
    \    foreach($brackets as $bracket){\n        if($bracket == '(' || $bracket ==\
    \ '[' || $bracket == '{' || $bracket == '<'){\n            return false;\n   \
    \     }\n    }\n    return true;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nYour\
    \ code is failing for cases like \"(()())\", which should return true.\n<|/ c\
    \ |>\n<| c |>\nYes, it is now fixed.\n<|/ c |>\n<| c |>\nThis is still wrong.\
    \ Try \"()((())))\" and it will return true when it should be returning false.\
    \ Also you haven't checked for $brackets.\n<|/ c |>\n<| a |>\n<code>", "    if\
    \ (strlen($brackets) === 0) {\n        return false;\n    }\n    if ($brackets[0]\
    \ !== '(') {\n        return false;\n    }\n    for ($i = 1; $i < strlen($brackets);\
    \ $i++) {\n        if ($brackets[$i] !== ')') {\n            return false;\n \
    \       }\n    }\n    return true;\n}\n", "    foreach ($brackets as $b) {\n \
    \       if ($b == '(') return false;\n        if ($b == ')') return false;\n \
    \   }\n    return true;\n}", "    return ($brackets == \"(())\") ||\n        (($brackets\
    \ == \"(())()\") &&\n        correct_bracketing($brackets[2])) ||\n        (($brackets\
    \ == \"(()()\") &&\n        correct_bracketing($brackets[3]));\n}", "  return\
    \ preg_match('/^('.$brackets.')*$/', $brackets);\n}\n\n/**\n * Return the list\
    \ of all possible prefixes for the word.\n *\n * @param string $word\n *  The\
    \ word to get prefixes for.\n * @return array\n *  The list of all possible prefixes\
    \ for the word. The returned array is ordered\n *  from the shortest to the longest.\n\
    \ */", "  $bracketsArr = explode(\"()\", $brackets);\n  $bracketsArr2 = explode(\"\
    (\", $bracketsArr);\n  $bracketsArr3 = array_unique($bracketsArr2);\n  return\
    \ !count($bracketsArr3);\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is another\
    \ possible solution.\n<code>", "  $brackets = strtoupper($brackets);\n  preg_match_all('/^\\\
    (+|\\)$/', $brackets, $match);\n  return array_diff_assoc($match[0], [\"\",\"\"\
    ]);\n}\n</code>\n<|/ a tags=php dscore=1 |>\n<| c |>\nThanks, this looks like\
    \ a good solution. The regex expression doesn't appear to work for me. I'm getting\
    \ \"Warning: preg_match_all() [function.preg-match-all]: Unknown modifier '('\
    \ in C:\\xampp\\htdocs\\test.php on line 3\"\n<|/ c |>\n<| c |>\nThe syntax is\
    \ `preg_match('/^\\(+|\\)$/', $brackets)`\n<|/ c |>\n<| c |>\nWorks perfectly.\
    \ Thanks so much!\n<|/ c |>\n<| c |>\nGlad it worked! :) Please click the check\
    \ mark to accept the answer.\n<|/ c |>\n<| c |>\nThis doesn't work for me. `correct_bracketing(\"\
    ()\")` returns true, but the OP's example returns false. Does this algorithm work\
    \ for you?\n<|/ c |>\n<| a |>\n<code>\n$str = \"()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()",
  "  if (strpos($brackets, \")\") !== false) {\n    return strpos($brackets, \") \"\
    ) === false;\n  }\n  if (strpos($brackets, \"(\") !== false) {\n    return strpos($brackets,\
    \ \") (\") === false;\n  }\n  return false;\n}\n", "  if ($brackets == '()') return\
    \ false;\n  $stack = array();\n  for ($i = 0; $i < strlen($brackets); $i++) {\n\
    \    $stack[] = $brackets[$i];\n  }\n  for ($i = 1; $i < strlen($brackets); $i++)\
    \ {\n    if ($brackets[$i] == $stack[$i-1]) {\n      $stack[$i] = '[';\n     \
    \ $stack[] = ')';\n    } else {\n      if ($brackets[$i] == '(') {\n        if\
    \ ($stack[$i-1] != '[') return false;\n        $stack[$i] = '[';\n        $stack[]\
    \ = ']';\n      } else {\n        if ($stack[$i-1] != '[') return false;\n   \
    \     $stack[$i] = ']';\n      }\n    }\n  }\n  for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n    if ($stack[$i] != ']') return false;\n  }\n  return true;\n}",
  "  // Find the matching closing bracket\n  $close_bracket = strpos($brackets, \"\
    )\");\n  // If the closing bracket does not exist, return false\n  if ($close_bracket\
    \ === false) {\n    return false;\n  }\n  // If the opening bracket is immediately\
    \ after a closing bracket, return false\n  if ($close_bracket > 0 && $close_bracket\
    \ < strlen($brackets) - 1) {\n    return false;\n  }\n  // If the opening bracket\
    \ is after a non-closing bracket, return false\n  if ($close_bracket > strlen($brackets)\
    \ - 1) {\n    return false;\n  }\n  // If the closing bracket is preceded by a\
    \ non-opening bracket, return false\n  if ($close_bracket < strpos($brackets,\
    \ \"(\")) {\n    return false;\n  }\n  // If the closing bracket is preceded by\
    \ a non-closing bracket, return false\n  if ($close_bracket < strpos($brackets,\
    \ \")\")) {\n    return false;\n  }\n  // If the closing bracket is followed by\
    \ a non-opening bracket, return false\n  if ($close_bracket < strpos($brackets,\
    \ \"(\")) {\n    return false;\n  }\n  // If we got this far return true.\n  return\
    \ true;\n}\n", "\treturn preg_match(\"/^(.*?)\\($brackets$/\", $brackets);\n}\n",
  "    $stack = array();\n    $brackets = preg_replace(\"/\\(|\\)/\", \"\", $brackets);\n\
    \n    if ($brackets == \"\")\n        return true;\n\n    foreach ($brackets as\
    \ $b) {\n        if ($b == \")\") {\n            $last = array_pop($stack);\n\
    \            if ($last != \"(\")\n                return false;\n        } else\
    \ {\n            $stack[] = $b;\n        }\n    }\n\n    return true;\n}\n", " \
    \ for ($i = 0; $i < strlen($brackets); $i++) {\n    if ($brackets[$i] === \"(\"\
    ) {\n      for ($j = $i + 1; $j < strlen($brackets); $j++) {\n        if ($brackets[$j]\
    \ === \")\") {\n          return true;\n        }\n      }\n    }\n  }\n  return\
    \ false;\n}\n", "    $brackets_counter = 0;\n    for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n        if ($brackets[$i] == $brackets[$i + 1]) {\n            $brackets_counter++;\n\
    \        } else {\n            if ($brackets_counter == 0) {\n               \
    \ return false;\n            }\n            $brackets_counter--;\n        }\n\
    \    }\n    return ($brackets_counter == 0);\n}", "  $brackets = str_split($brackets);\n\
    \  $brackets = array_map('trim', $brackets);\n  $opens = array_count_values($brackets);\n\
    \  for ($i = 1; $i < count($brackets); $i++) {\n    if ($opens[$i] == 0) {\n \
    \     return false;\n    }\n  }\n  return true;\n}\n", "    $openings = array_flip(str_split($brackets,\
    \ 1));\n    $closings = array_flip(str_split($brackets, 1));\n    foreach ($openings\
    \ as $i => $open) {\n        if (empty($closings[$i])) {\n            return false;\n\
    \        }\n        if ($open != $closings[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  return preg_match(\"/$brackets\\\
    )/\", $brackets);\n}", "  return $brackets !== '' && ($brackets === '(' || $brackets\
    \ === ')');\n}\n", "    return preg_match('/\\((\\()|(\\)\\))/', $brackets) ===\
    \ 0;\n}\n</code>\nYou can test this by running this code:\n<code>\n<?php\n   \
    \ echo correct_bracketing(\"(\");\n    echo correct_bracketing(\"()\");\n    echo\
    \ correct_bracketing(\"(()())\");\n    echo correct_bracketing(\")(())\");\n \
    \   echo correct_bracketing(\"())\");\n    echo correct_bracketing(\"()())\");\n\
    \    echo correct_bracketing(\"(()\");\n    echo correct_bracketing(\"((())\"\
    );\n    echo correct_bracketing(\"()((()))\");\n    echo correct_bracketing(\"\
    ()(())()\");\n    echo correct_bracketing(\"(()())(())\");\n    echo correct_bracketing(\"\
    ()()((()))\");", "  foreach ($brackets as $b) {\n    if ($b !== \"(\") {\n   \
    \   return false;\n    }\n  }\n  return true;\n}\n", "  $brackets = str_replace(\"\
    )\", \"\", $brackets);\n  $brackets = str_replace(\"(\", \"\", $brackets);\n \
    \ return $brackets == \"()\";\n}\n", "  $brackets = str_replace(\"(\", \"($a)\"\
    , $brackets);\n  $brackets = str_replace(\")\", \")($a)\", $brackets);\n  return(strlen($brackets)\
    \ == strpos(\"($a)\", $brackets));\n}\n</code>\n<|/ a tags=parsing,php |>\n<|\
    \ c |>\nThis seems like a great idea, but it appears that this solution would\
    \ return false for `()()`. http://codepad.org/P6Q1uZgP\n<|/ c |>\n<| c |>\nThe\
    \ `if` statement at the end should be `return (count($brackets) == strpos(\"($a)\"\
    , $brackets));`\n<|/ c |>\n<| c |>\n: Sorry, I made a typo in the `count()`. I\
    \ meant `strpos`. I corrected my answer.\n<|/ c |>\n<| a dscore=2 |>\nI realize\
    \ this isn't PHP, but it might be of interest to anybody who is trying to solve\
    \ this problem in PHP: http://www.codeproject.com/KB/recipes/balancedparenthesis.aspx\n\
    <|/ a tags=parsing,php |>\n<| a tags=parsing,php |>\nA solution is to use regex\
    \ to split the string into ( and ) characters.\nThen count the number of times\
    \ the number of ('s matches the number of )'s and determine if there is a mismatch.\n\
    If there is a mismatch, then there is a missing parentheses.  (If they aren't\
    \ mismatched, the string could be correct.)\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ works well as long as the parentheses are balanced. But when there are nested\
    \ parentheses, this won't work.\n<|/ c |>\n<| a dscore=2 |>\nThis problem has\
    \ been addressed many times in computer science. Here's a very simple algorithm\
    \ that does just that:\n\nRead one character at a time.\nWhen you encounter an\
    \ opening bracket, increase the number of open brackets encountered and when you\
    \ encounter a closing bracket, decrease the number of open brackets.\n\nIf there\
    \ are more open brackets than close brackets, then there is a missing opening\
    \ bracket.\nThere are many ways of doing this, but here's a simple implementation,\
    \ which you can probably tweak to your liking:\n<code>", "\tif (strlen($brackets)\
    \ == 0)\n\t\treturn false;\n\n\t$brackets_array = explode(\",\", $brackets);\n\
    \n\t// If the first character is a right bracket that doesn't close\n\t// a previous\
    \ bracket, it's an error.\n\tif ($brackets_array[0] == \"(\")\n\t\treturn false;\n\
    \n\t// If the last character is a left bracket that doesn't open\n\t// a next\
    \ bracket, it's an error.\n\tif ($brackets_array[count($brackets_array) - 1] ==\
    \ \")\")\n\t\treturn false;\n\n\tfor ($i = 1; $i < count($brackets_array); $i++)\
    \ {\n\t\tif ($brackets_array[$i-1] == $brackets_array[$i]) {\n\t\t\t// Close a\
    \ bracket if opening a new one.\n\t\t\tif ($brackets_array[$i-1] != \"(\") {\n\
    \t\t\t\t$brackets_array[$i-1] = \")\";\n\t\t\t}\n\t\t} else {\n\t\t\t// Open a\
    \ bracket if closing one.\n\t\t\tif ($brackets_array[$i-1] != \"(\") {\n\t\t\t\
    \t$brackets_array[$i] = \"(\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (str_replace(\"\
    ,\", \"\", implode(\",\", $brackets_array)) == $brackets);\n}\n", "  // Return\
    \ True if every opening bracket has a corresponding closing bracket.\n  // >>>\
    \ correct_bracketing(\"(\")\n  // False\n  // >>> correct_bracketing(\"()\")\n\
    \  // True\n  // >>> correct_bracketing(\"(()())\")\n  // True\n  // >>> correct_bracketing(\"\
    )(()\")\n  // False\n  if (preg_match('/^\\((.+)\\)$/', $brackets, $match))\n\
    \    return preg_match('/\\((.+)\\)$/', $brackets, $match);\n  else\n    return\
    \ false;\n}\n", "\t$brackets_arr = explode(',', $brackets);\n\t$brackets_len =\
    \ count($brackets_arr);\n\tfor ($i = 0; $i < $brackets_len; $i++) {\n\t\t$brackets_arr[$i]\
    \ = trim($brackets_arr[$i]);\n\t}\n\tif ($brackets_len == 2) {\n\t\treturn true;\n\
    \t}\n\tif ($brackets_len == 1) {\n\t\treturn false;\n\t}\n\t$brackets_arr[0] =\
    \ trim($brackets_arr[0]);\n\t$brackets_arr[1] = trim($brackets_arr[1]);\n\tif\
    \ ($brackets_arr[0] == \"(\") {\n\t\tif ($brackets_arr[1] == \"(\") {\n\t\t\t\
    return true;\n\t\t}\n\t\treturn false;\n\t}\n\tif ($brackets_arr[1] == \"(\")\
    \ {\n\t\treturn false;\n\t}\n\treturn false;\n}\n", "  $brackets = strtoupper($brackets);\n\
    \  foreach(str_split($brackets) as $b) {\n    if ($b !== \"(\") {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "  global $bracketed;\n  if ($bracketed)\
    \ {\n    return false;\n  }\n  $brackets_stack = array();\n  $brackets_stack[]\
    \ = $brackets;\n  do {\n    $last = array_pop($brackets_stack);\n    if ($last\
    \ == $brackets) {\n      return true;\n    }\n    if ($last == '(') {\n      $brackets_stack[]\
    \ = '(';\n    }\n    if ($last == ')') {\n      $brackets_stack[] = ')';\n   \
    \ }\n  } while ($last != '(');\n  return false;\n}\n", "    $brackets = strtolower($brackets);\n\
    \    $brackets = str_replace(\"(\", \"\\\\(\", $brackets);\n    $brackets = str_replace(\"\
    )\", \"\\\\)\", $brackets);\n    $brackets = \"~^\" . $brackets . \"$~\";\n  \
    \  $brackets = preg_quote($brackets, \"~\");\n    $brackets = preg_replace(\"\
    ~\\\\\\\\~\", \"\\\\\", $brackets);\n    $brackets = preg_replace(\"~\\^~\", \"\
    ^\", $brackets);\n    $brackets = preg_replace(\"~\\$$~\", \"$\", $brackets);\n\
    \    $brackets = preg_replace(\"~\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\", $brackets);\n\
    \    $brackets = preg_replace(\"~\\\\(\\\\)\\\\(\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\\\\(\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\\
    )\", $brackets);\n    $brackets = preg_replace(\"~\\\\(\\\\)\\\\(\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\\\\(\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\\\\\
    (\\\\)\\\\(\\\\)\", $brackets);\n    $brackets = preg_replace(\"~\\\\(\\\\)~\"\
    , \"\\\\(\\\\)\", $brackets);\n    $brackets = preg_replace(\"~\\\\(\\\\)\\\\\
    (\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\", $brackets);\n    $brackets = preg_replace(\"\
    ~\\\\(\\\\)\\\\(\\\\(\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\", $brackets);\n\
    \    $brackets = preg_replace(\"~\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)~\", \"\\\\(\\\\\
    )\\\\(\\\\)\\\\(\\\\)\\\\(\\\\)\", $brackets);\n    $brackets = preg_replace(\"\
    ~\\\\(\\\\)\\\\(\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\", $brackets);\n    $brackets\
    \ = preg_replace(\"~\\\\(\\\\)~\", \"\\\\(\\\\)\", $brackets);\n    $brackets\
    \ = preg_replace(\"~\\\\(\\\\)\\\\(\\\\)~\", \"\\\\(\\\\)\\\\(\\\\)\", $brackets);\n\
    \    $brackets = preg_replace(\"~\\\\(\\\\)~\", \"\\\\(\\\\)\", $brackets);\n\
    \    $brackets = preg_replace(\"~\\\\(\\\\)\\\\(\\\\)~\", \"\\\\(\\\\)\\\\(\\\\\
    )\", $brackets);\n    return !preg_match($brackets, $brackets);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nI had to ", "  $brackets_count = substr_count($brackets,\
    \ '()');\n  return $brackets_count % 2 == 0;\n}", "  $stack = [];\n  $brackets_length\
    \ = strlen($brackets);\n  for ($i = 0; $i < $brackets_length; $i++) {\n    $char\
    \ = $brackets[$i];\n    // If the current character is opening bracket.\n    if\
    \ (isset($stack[$i]) && $stack[$i] == $char) {\n      // If the current stack\
    \ is empty (no previous opening bracket).\n      if ($stack[$i] == '') {\n   \
    \     // The current opening bracket is a closing bracket.\n        $stack[$i]\
    \ = $char;\n      } else {\n        // The current opening bracket is not the\
    \ closing bracket.\n        return false;\n      }\n    } else {\n      // The\
    \ current character is opening or closing bracket.\n      $stack[$i] = $char;\n\
    \    }\n  }\n  return $stack[0] == ''; // return true only if the stack is empty\n\
    }\n", "\t$brackets = preg_replace(\"/[\\(\\)]/\", \"\", $brackets);\n\t$brackets\
    \ = preg_replace(\"/\\(/\", \"|(\", $brackets);\n\t$brackets = preg_replace(\"\
    /\\)/\", \"|)\", $brackets);\n\t$brackets = preg_replace(\"/\\|/\", \" \", $brackets);\n\
    \treturn ($brackets == \"() () () | ()\");\n}", "    $brackets = array_map(\n\
    \        'trim', // remove whitespace\n        explode(')', $brackets) // split\
    \ into an array of brackets\n    );\n    $brackets_count = count($brackets);\n\
    \    $brackets_before = array_shift($brackets);\n    for ($i = 0; $i < $brackets_count;\
    \ $i++) {\n        if ($brackets[$i] == $brackets_before) {\n            $brackets[$i]\
    \ = array_shift($brackets);\n        }\n    }\n    return array_shift($brackets)\
    \ == array_shift($brackets);\n}\n</code>\n<|/ a tags=string,arrays,php dscore=2\
    \ |>\n<| c |>\nI like how you explained this algorithm!\n<|/ c |>\n<| a tags=string,arrays,php\
    \ dscore=2 |>\nThe regex is very simple and effective:\n<code>\n/^(\\s*)(\\w+)(\\\
    s*)(\\w+)(\\s*)(\\w+)(\\s*)$/.test(\"(()())\")\n</code>\nThe first group matches\
    \ any amount of spaces, then the word group, then any amount of spaces, then the\
    \ word group, then any amount of spaces again and finally the word group.\nThe\
    \ second group will match any amount of spaces then word groups, each one of them\
    \ matching any amount of spaces.\n<|/ a |>\n<| a dscore=2 |>\nThis should work:\n\
    <code>\n$brackets = \"(()())\";\n$result = preg_match('~^\\s*(?:\\(\\s*)?([^()]+)(?:\\\
    s*\\))?\\s*(?:\\(\\s*)?([^()]+)(?:\\s*\\))?\\s*(?:\\(\\s*)?([^()]+)(?:\\s*\\))?\\\
    s*(?:\\(\\s*)?([^()]+)(?:\\s*\\))?$~', $brackets);\nvar_dump($result);\n</code>\n\
    It basically does the same as's answer but uses preg_match.\nThe regex basically\
    \ looks for 4 groups:\n\nthe first group is optional (?:\\(\\s*)?\nthe next group\
    \ is one or more non-( or )\nthe third group is optional (?:\\s*\\))\nthe next\
    \ group is one or more non-( or )\nthe fourth group is optional (?:\\s*\\))\n\n\
    As you can see it can be simplified, since we know that each of the groups has\
    \ to be non-empty, the first group is optional.\nThe regex is very simple:\n<code>\n\
    (?:          # non capturing group\n  \\(\\s*\\)? # optional spaces before an\
    \ opening parenthesis\n)?           # optional\n([^()]+)  # one or more non (\
    \ or ) characters \n(?:          # non capturing group\n  \\s*        # optional\
    \ spaces\n  \\(\\s*\\)? # optional spaces before another opening parenthesis\n\
    )?           # optional", "  return preg_match('/\\((?!\\))/', $brackets);\n}",
  "  foreach($brackets as $opening_bracket => $closing_bracket) {\n    if($opening_bracket\
    \ != $closing_bracket) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "    return is_array($brackets) && count($brackets) && count(array_filter(array_map('trim',\
    \ $brackets))) === count($brackets);\n}\n", "    $brackets = str_replace(\" \"\
    , \"\", $brackets);\n    $brackets = preg_replace('/[()]/', '', $brackets);\n\
    \    $opening = array();\n    $closing = array();\n    $opening = $closing = explode(\"\
    ,\", $brackets);\n    $count = count($opening);\n    for ($i = 0; $i < $count;\
    \ $i++) {\n        $opening[$i] = trim($opening[$i]);\n        $closing[$i] =\
    \ trim($closing[$i]);\n    }\n\n    if ($opening[0] != '(') return false;\n  \
    \  if ($closing[$count - 1] != ')') return false;\n    if ($count < 2) return\
    \ false;\n\n    for ($i = 1; $i < $count - 1; $i++) {\n        if ($opening[$i]\
    \ != $closing[$i - 1]) return false;\n    }\n    return true;\n}\n</code>\n<|/\
    \ a tags=python,php,algorithm,php-openssl |>\n<| c |>\nThis does not provide an\
    \ answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post.\n<|/ c |>\n<| c |>\nI actually ran into a\
    \ similar issue with some php and had a similar solution. My solution didn't work\
    \ if the string was \"()()()()\" for example. I'm sorry if this isn't the solution\
    \ that you were looking for, but I thought it might be helpful. Maybe I can explain\
    \ how my solution works.\n<|/ c |>\n<| c |>\nWhat about `(())`? I think it should\
    \ be valid but it will return `false`.\n<|/ c |>\n<| c |>\n`()` = False \n`(())`\
    \ = True\n<|/ c |>\n<| c |>\nI believe that is the correct answer. `(())()()`\
    \ is also valid and will return True as `(())` does not have a corresponding closing\
    \ bracket.\n<|/ c |>\n<| a tags=python,php,algorithm,php-openssl |>\nI thought\
    \ of another idea that might work.\nFirst, split the brackets and put them into\
    \ a map:\n<code>\n[opening, closing] = map(str.strip, bracket_string[1:-1].split(',\
    \ '))\n</code>\nNow, check that the opening brackets are the same as the closing\
    \ brackets:\n<code>\nassert opening == closing\n</code>\nNow, we know that they're\
    \ the same, so we can loop over the list of opening brackets and see if any pair\
    \ match any of the closing brackets, and if they do, we know that they're the\
    \ same bracket:\n<code>\nfor opening in openings:\n    if closing in closings:\n\
    \        print(opening == closing)\n        break\nelse:\n    print('The brackets\
    \ are not the same", "    $stack = array();\n    for ($i=0; $i<strlen($brackets);\
    \ $i++) {\n        if ($brackets[$i]=='(') {\n            $stack[] = $i;\n   \
    \     } else if ($brackets[$i]==')') {\n            while (count($stack)>0) {\n\
    \                --$i;\n                if ($stack[$i]<$i) {\n               \
    \     break;\n                }\n                $stack[$i]=$i;\n            }\n\
    \            if (count($stack)==0) {\n                return false;\n        \
    \    }\n        } else if (in_array($brackets[$i],$stack)) {\n            return\
    \ false;\n        } else {\n            $stack[] = $i;\n        }\n    }\n   \
    \ return true;\n}", "\t$brackets_reversed = array_reverse($brackets);\n\t$opening_brackets\
    \ = array_keys($brackets_reversed);\n\t$closing_brackets = array_keys($brackets);\n\
    \treturn count($opening_brackets) == count($closing_brackets);\n}\n", "  $open_brackets\
    \ = preg_split(\"/[\\(\\)]/\", $brackets);\n  $open_brackets_length = count($open_brackets);\n\
    \  for ($i = 0; $i < $open_brackets_length; $i++) {\n    $open_bracket = $open_brackets[$i];\n\
    \    for ($j = $i + 1; $j < $open_brackets_length; $j++) {\n      $close_bracket\
    \ = $open_brackets[$j];\n      if ($open_bracket != $close_bracket) {\n      \
    \  return false;\n      }\n    }\n  }\n  return true;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\nI wanted to add an answer that handles strings with multiple\
    \ delimiters\n<code>\n$delimiters = [',', '(', ')', ';', \"'\", '\"'];\n", "\t\
    $brackets = preg_replace(\"/([\\(]+)([^\\)]+?)(\\)]+?)/\", \"\\\\1\\\\3\", $brackets);\n\
    \t$brackets = preg_replace(\"/([\\(]+)(.+?)(\\)]+?)/\", \"\\\\1\\\\4\", $brackets);\n\
    \treturn $brackets !== $brackets;\n}\n\t", "    $brackets_size = count($brackets);\n\
    \    $i = 0;\n    $inside_bracket = false;\n    while ($i < $brackets_size) {\n\
    \        if (!$inside_bracket) {\n            if ($brackets[$i] === '(') {\n \
    \               $inside_bracket = true;\n            } else {\n              \
    \  return false;\n            }\n        } else {\n            if ($brackets[$i]\
    \ === ')') {\n                $inside_bracket = false;\n                $i++;\n\
    \            } else {\n                return false;\n            }\n        }\n\
    \        $i++;\n    }\n    return true;\n}\n", "    $opening_brackets = array();\n\
    \    $closing_brackets = array();\n    $brackets_open = strpos($brackets, \")\"\
    );\n    $brackets_close = strpos($brackets, \")\");\n    while ($brackets_open\
    \ !== false && $brackets_close !== false) {\n        $opening_brackets[] = substr($brackets,\
    \ 0, $brackets_open);\n        $closing_brackets[] = substr($brackets, $brackets_open\
    \ + 1);\n        $brackets = substr($brackets, $brackets_close + 1);\n       \
    \ $brackets_open = strpos($brackets, \")\");\n        $brackets_close = strpos($brackets,\
    \ \")\");\n    }\n    return count($opening_brackets) == count($closing_brackets);\n\
    }\n", "  $brackets_array = array();\n  for ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n    $brackets_array[] = substr($brackets, $i, 1);\n  }\n  $opening_brackets_count\
    \ = count(array_count_values($brackets_array));\n  if ($opening_brackets_count\
    \ !== count($brackets_array)) {\n    // There was a character other than a bracket\
    \ so we couldn't have brackets.\n    return false;\n  }\n\n  for ($i = 0; $i <\
    \ count($brackets_array); $i++) {\n    if ($brackets_array[$i] !== \"(\") {\n\
    \      return false;\n    }\n  }\n\n  return true;\n}\n", "  if (substr($brackets,\
    \ 0, 1) != '(') return false;\n  if (substr($brackets, -1, 1) != ')') return false;\n\
    \  return true;\n}\n", "  $count = substr_count($brackets, '(');\n  for ($i =\
    \ 0; $i < $count; ++$i) {\n    if (strpos($brackets, ')') !== false) {\n     \
    \ // Found an opening bracket.\n      return true;\n    }\n  }\n  return false;\n\
    }\n</code>\n<|/ a |>\n<| a tags=php dscore=0 |>\nThis code works fine for me.\n\
    <code>\n<?php\n$brackets = str_replace(array(\"(\", \")\"), array('\"(\" . \"\
    \ . \")\"', '\"(\" . \")\"'), $brackets);\n$brackets = str_replace(\"'('\" . \"\
    )'\", \"'(\" . \")'\", $brackets);\n\necho $brackets;", "  if (is_string($brackets)\
    \ && $brackets[0] == '(' && $brackets[strlen($brackets) - 1] == ')') {\n    return\
    \ TRUE;\n  }\n\n  return FALSE;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
