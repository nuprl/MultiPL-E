name: HumanEval_59_largest_prime_factor
language: php
prompt: "<?php\n// Return the largest prime factor of n. Assume n > 1 and is not a\
  \ prime.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n\
  // 2\nfunction largest_prime_factor($n) {\n"
tests: "function candidate(...$args) {\n    return largest_prime_factor(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(15) !== 5) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(27) !== 3) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(63) !== 7) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(330) !== 11) { throw new Exception(\"Test failed!\"); }\n   \
  \ if (candidate(13195) !== 29) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["    $i = 2;\n    $ps = [];\n    while ($i <= sqrt($n)) {\n        if\
    \ ($n % $i == 0) {\n            $ps[] = $i;\n            if ($n / $i == $i) {\n\
    \                break;\n            }\n            $ps[$i] = $n / $i;\n     \
    \   }\n        $i++;\n    }\n    return $ps[count($ps) - 1];\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks a lot. I will try the code and let you know.\n<|/ c |>\n\
    <| c |>\n: You need *$i* to be defined before entering the loop though.\n<|/ c\
    \ |>\n<| c |>\n: Fixed.\n<|/ c |>\n<| c |>\nI'm getting this error: Fatal error:\
    \ Allowed memory size of 134217728 bytes exhausted (tried to allocate 72 bytes)\
    \ in /var/www/html/demo/demo.php on line 14. How should I fix this?\n<|/ c |>\n\
    <| a dscore=3 tags=php,primes |>\nI came up with this one. I'm not sure if it's\
    \ the best way to go about it but it works and it's fast. The only thing left\
    \ is to figure out how long the prime number should be. I'll let you figure that\
    \ out.\n<code>", "    if ($n <= 1) return 1;\n    \n    $result = 1;\n    \n \
    \   do {\n        $result = $result * $n % $result % $result;\n        $n--;\n\
    \    } while ($n > 1);\n    \n    return $result;\n}", "    $i = 3;\n    $max\
    \ = $n;\n    while ($i < $max) {\n        $i = $i * 2;\n        if ($n % $i ==\
    \ 0) {\n            $max = $i;\n        } else {\n            $n /= $i;\n    \
    \    }\n    }\n    return $max;\n}\n$n = $largest_prime_factor(13195);\nprintf(\"\
    Largest prime factor is %d\\n\", $n);\n", "  // Easy case: Is n odd? If so, the\
    \ answer must be odd.\n  if ($n % 2 == 0) return $n;\n  // Harder case: Find any\
    \ odd factor.\n  $x = 1;\n  for ($i = 3; $i <= $n; $i += 2) if ($n % $i == 0)\
    \ $x *= $i;\n  return $x;\n}\n</code>\n<|/ a dscore=4 tags=primes,php |>\n<| c\
    \ |>\nThe [wikipedia article](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ has a much better Sieve than this one.  Might help someone out who finds this\
    \ post in the future.\n<|/ c |>\n<| c |>\nThis answer doesn't seem to take into\
    \ account a prime factorization of a number greater than 2 -- i.e. the factor\
    \ to test for being prime is the greatest common divisor of the prime factors.\n\
    <|/ c |>\n<| c |>\nI've added the missing piece to the code.\n<|/ c |>\n<| a tags=primes,php\
    \ dscore=3 |>\nHere's a modified version of the Sieve of Eratosthenes, which I've\
    \ found is quite efficient (when it's working correctly, according to this page:\
    \ http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf):\n<code>", "    $sieve =\
    \ array(2, 3);\n    for ($i = 5; $i >= 1; --$i) {\n        if ($n % $i == 0) {\n\
    \            $sieve[$i] = $i;\n            while ($n % $i == 0) {\n          \
    \      $sieve[$i] ^= $sieve[$i >> 1];\n                $n = $n / $i;\n       \
    \     }\n        }\n    }\n    return $sieve[1]; // ie. 2^6\n}\n", "    if ($n\
    \ < 2) return null;\n    if ($n == 1) return 2;\n    if ($n == 2) return 3;\n\
    \    if ($n % 2 == 0 || $n <= 4) return $n;\n    if ($n % 3 == 0 || $n % 5 ==\
    \ 0) return $n;\n    \n    $result = $primes[1];\n    \n    for ($i = 2; $i *\
    \ $i <= $n; $i++) {\n        $result = $n % $result != 0\n                ? $result\
    \ + ($i ? $i : 1)\n                : $result;\n    }\n    \n    return $result;\n\
    }\n", "    list($num, $n_squared) = n_square_and_square($n);\n    $n_squared =\
    \ sqrt($n_squared);\n    for($i = 0; $i <= $num; $i++) {\n        if($n % $i ==\
    \ 0) {\n            $n_divided = $i / $n_squared;\n            if($n_divided !=\
    \ floor($n_divided)) break;\n            $n_divided = sqrt($n_divided);\n    \
    \        return $n_divided;\n        }\n    }\n    return 1;\n}\n", "  if ($n\
    \ <= 1) return $n;\n\n  $r = $n % 2;\n  $a = $n - $r;\n  while ($a <= 1) {\n \
    \   $r = $r * $n % $n; // % is mod 2 \n    $a = $a - $r; // $a is divided by $n\n\
    \  }\n\n  return $r;\n}\n", "    $primes = array(\n        2,\n    );\n    $limit\
    \ = 2;\n    $m = $n;\n    while (array_search($m, $primes) !== false && $m !=\
    \ 1) {\n        $limit++;\n        for ($i = 2; $i <= $limit; $i++) {\n      \
    \      if ($n % $i == 0) {\n                $primes[] = $i;\n                $m\
    \ = $n / $i;\n                break;\n            }\n        }\n    }\n    return\
    \ $limit;\n}\n", "    if ($n <= 1) return $n;\n    // Check up to sqrt(n)\n  \
    \  for ($i = 2; $i * $i <= $n; $i++) {\n        if ($n % $i == 0) return $i;\n\
    \    }\n    return $n;\n}", "  $primes = [];\n  $is_prime = true;\n  for ($i =\
    \ 3; $i <= $n; $i += 2) {\n    if (isset($primes[$i])) {\n      $primes[$i]++;\n\
    \      if ($primes[$i] > 1) {\n        $is_prime = false;\n      }\n    } else\
    \ {\n      $primes[$i] = 1;\n    }\n  }\n  return $is_prime ? $n : false;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis algorithm is horribly inefficient, and\
    \ it also doesn't check prime numbers.\n<|/ c |>\n<| c |>\n: It does not check\
    \ for primes. The algorithm as it is now checks prime numbers and only prints\
    \ out the largest prime factor if there are more than 1 occurrences of that factor.\n\
    <|/ c |>\n<| c |>\nSorry, I didn't see that at the time I posted my comment. \
    \ It does now check for primes.  It also doesn't check for factors smaller than\
    \ 2, which doesn't matter for most people these days.  It also doesn't check for\
    \ a prime factor smaller than 2 or one less than the square root of the number.\n\
    <|/ c |>\n<| c |>\nI realize that it doesn't check for factors smaller than 2\
    \ but how about a factor of 1? I think this should cover that case.\n<|/ c |>\n\
    <| c |>\n: I think you mean \"factors of 2\" rather than \"factors of 1\" because\
    \ factors of 1 do not exist.  The reason that I don't check for factors of two\
    \ is that in most cases, 1 is not a factor of 2, and in most cases, 2 is not a\
    \ factor of any number.  Of course, it's not really a factor of any number if\
    \ it isn't a factor of 2.\n<|/ c |>\n<| a |>\nYou don't need a library to do this,\
    \ only a loop. Try this:\n<code>", "  if ($n == 1) return 2;\n  if ($n % 2 ==\
    \ 0) return $n % 2 == 0 ? 3 : 2;\n  // Find the largest factor of n that is smaller\
    \ than n.\n  $f = 3;\n  $t = $n;\n  while ($t % $f != 0) {\n    $f = $t + 1;\n\
    \  }\n  $f = $t + 1;\n  // Since $t is obviously a prime, the largest factor is\
    \ $f.\n  return $f;\n}\n", "  $max_factor = 1;\n  $p = 2;\n  while ($p <= $n)\
    \ {\n    while ($n % $p == 0) {\n      $max_factor = max($max_factor, $p);\n \
    \     $n /= $p;\n    }\n    $p++;\n  }\n  return $max_factor;\n}\n\n/**\n * Return\
    \ the power of $base to the power of $exponent. Assume $base and $exponent > 0.\n\
    \ * See http://en.wikipedia.org/wiki/Exponentiation_by_squaring for an explanation\
    \ of why this is\n * useful.\n * >>> power_of_two(8, 2)", "    $factors = array();\n\
    \    for($i = 2; $i <= $n; $i++) {\n        $factors[] = $i;\n        $m = $n\
    \ % $i;\n        if($m === 0) {\n            $factors[] = $i;\n            $n\
    \ = $i / 2;\n        }\n    }\n    return $factors[count($factors)-1];\n}\n",
  "    if ($n <= 1) return 1;\n    if ($n % 2==0) {\n        return 2;\n    }\n\n\
    \    $i = $n;\n    while ($i%2==0) {\n        $i = floor($i/2);\n    }\n    return\
    \ $i;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks very much for you answer. I don't\
    \ really understand why you use modulus and floor functions. I guess I don't fully\
    \ understand how PHP works.\n<|/ c |>\n<| c |>\nOkay, I got that all out. Thanks\
    \ again\n<|/ c |>\n<| c |>\nThe modulus is used to get the largest factor of $n\
    \ which is not divisible by 2. floor is used to get rid of the last two zeros\
    \ of the division.\n<|/ c |>\n<| a dscore=1 |>\nHere's my version of the above\
    \ solution in PHP:\n<code>\n<?php\n    function largest_prime_factor($n) {\n \
    \       if ($n <= 1) return 1;\n        if ($n % 2 == 0) {\n            return\
    \ 2;\n        }\n        $i = $n;\n        while ($i%2 == 0) {\n            $i\
    \ = floor($i/2);\n        }\n        return $i;\n    }\n\n    print_r(largest_prime_factor(13195));\n\
    \    print_r(largest_prime_factor(2048));", "  $largest = $n;\n  $i = $largest;\n\
    \  while ($i != 1) {\n    $i--;\n    $f = $i;\n    while (!($i % $largest)) {\n\
    \      $i /= $largest;\n      $f++;\n    }\n    if ($i != 1) {\n      $largest\
    \ = $f;\n    }\n  }\n  return $largest;\n}\n", "    if ($n == 1) {\n        return\
    \ $n;\n    }\n\n    // Calculate the exponent.\n    $e = Math::log($n, 2);\n\n\
    \    // Find the smallest integer larger than the exponent.\n    $i = 1;\n   \
    \ while (Math::pow(Math::max($i, $e), $i) <= $n) {\n        $i++;\n    }\n\n \
    \   // See if n is prime.\n    $fp = 1;\n    while ($fp * $i <= $n) {\n      \
    \  if ($n % $fp == 0) {\n            break;\n        }\n        $fp++;\n    }\n\
    \n    if ($fp * $i > $n) {\n        return $fp * $i;\n    } else {\n        return\
    \ $n;\n    }\n}\n", "    $n = abs($n);\n    $test = 2;\n    $result = 1;\n   \
    \ while ($n > 1) {\n        if ($n % $test == 0) {\n            $result++;\n \
    \       }\n        $test++;\n        $n--;\n    }\n    if ($result > 1) {\n  \
    \      echo \"error\";\n    }\n    return $result;\n}\n", "    if ($n<2) { return\
    \ $n; }\n    $m = $n;\n    $i = 2; $prime = true;\n    while ($prime) {\n    \
    \    if ($m%$i == 0) { $prime = false; } else { $i++; }\n    }\n    $result =\
    \ $i;\n    if ($n%$i == 0) { $prime = false; } else { $i++; }\n    while($prime)\
    \ {\n        $result = $i*$result;\n        if ($n%$i == 0) { $prime = false;\
    \ } else { $i++; }\n    }\n    return $result;\n}", "    $n = abs($n);\n    $primes\
    \ = array(2, 3, 5, 7, 11, 13, 17, 19);\n    $factor = 2;\n    foreach ($primes\
    \ as $prime) {\n        while ($n % $prime == 0) {\n            $factor = $prime;\n\
    \            $n /= $prime;\n        }\n        if ($n > 1) {\n            break;\n\
    \        }\n    }\n    return $factor;\n}\n</code>\n<|/ a tags=php,biginteger,factorial\
    \ dscore=2 |>\n<| a |>\nI took Jack's code and tweaked it a little bit to make\
    \ it work with a BigInteger in PHP (BigInteger class from PEAR):\n<code>\n<?php\n\
    \nclass BigInteger extends PEAR_Integer {\n\n    private $value;\n\n    public\
    \ function __construct($value) {\n        if (is_numeric($value)) {\n        \
    \    $value = str_pad(base_convert($value, 10, 36), 36, '0', STR_PAD_LEFT);\n\
    \        }\n        if (substr($value, 0, 1) === '-') {\n            $value =\
    \ substr($value, 1);\n            $this->value = -$this->value;\n        } else\
    \ {\n            $this->value = $value;\n        }\n    }\n\n    public static\
    \ function fromBase($base) {\n        $result = new BigInteger('');\n        $factor\
    \ = 1;\n        while($base > 1) {\n            if ($base % 2 == 0) {\n      \
    \          $result .= $factor;\n                $factor = 2;\n            } else\
    \ {\n                $result .= $factor--;\n                $factor = -1;\n  \
    \          }\n            $base = $base>>1;\n        }\n        return $result;\n\
    \    }\n\n    public function getBigInteger() {\n        return $this->value;\n\
    \    }\n\n    public function toBase($base) {\n        return str_pad($this->value,\
    \ $base, 36, '0', STR_PAD_LEFT);\n    }\n\n    public function toString() {\n\
    \        return $this->toBase($base);\n    }\n\n    public function __toString()\
    \ {\n        return $this->toString();\n    }\n\n    public function gcd($b) {\n\
    \        $a = new BigInteger($this);\n        $b = new BigInteger($b);\n     \
    \   if ($a->value == 0 || $b->value == 0) {\n            $result = new BigInteger('0');\n\
    \        } else {\n            $result = $a->gcdBigInteger($b);\n        }\n \
    \       return $result;\n    }\n\n    public function lcm($b) {\n        $a =\
    \ new BigInteger($this);\n        $b = new BigInteger($b);\n        if ($a->value\
    \ == 0 || $b->value == 0) {\n            $result = new BigInteger('0');\n    \
    \    } else {\n            $result = $a->lcmBigInteger($b);\n        }\n     \
    \   return $result;\n    }\n\n    public function gcdBigInteger($b) {\n      \
    \  $a = new BigInteger($this);\n        $", "  if ($n <= 1)\n    return $n;\n\n\
    \  $x = $a = 2;\n  for ($i = 3; $i <= $n; $i += $x) {\n    while (!($n % $x))\
    \ {\n      $x++;\n    }\n    $a++;\n  }\n\n  return $a;\n}\n", "  if ($n == 2)\
    \ return 2;\n  if ($n == 1) return $n;\n\n  // Calculate the largest factor of\
    \ n that's <= sqrt(n)\n  $max_factor = 2;\n  $i = 3;\n  while (1) {\n    if ($n\
    \ % $i == 0) $max_factor = $i;\n    if ($i > $n) break;\n    $i++;\n  }\n\n  //\
    \ Return the largest prime factor of n\n  for ($i = 2; $i <= $max_factor; $i++)\
    \ {\n    if ($n % $i == 0) return $i;\n  }\n  return $n;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=math,php,primes dscore=2 |>\n<code>\n<?php\n\n    function isPrime($n)\n\
    \    {\n      if($n == 1) return false;\n      if($n == 2) return true;\n    \
    \  if($n % 2 == 0) return false;\n\n      for($i = 3; $i < sqrt($n); $i += 2)\n\
    \        if($n % $i == 0) return false;\n\n      return true;\n    }\n\n    function\
    \ primesOverN($n)\n    {\n      $primes = array();\n      for($i = 0; $i < $n;\
    \ $i++)\n      {\n        if(isPrime($i)) $primes[] = $i;\n      }\n      return\
    \ $primes;\n    }", "    if ($n == 1) return $n;\n    $max_possible = (int) sqrt($n);\n\
    \    $factor = 1;\n    for($i = 2; $i <= $max_possible; $i++) {\n        if ($n\
    \ % $i == 0) {\n            $factor = $i;\n            break;\n        }\n   \
    \ }\n    return $factor;\n}\n</code>\n<|/ a tags=python,php,algorithm |>\n<| a\
    \ dscore=2 tags=python,php,algorithm |>\nHere is a simple way using list comprehension:\n\
    <code>\n>>> n=int(raw_input())\n>>> [i for i in range (1,n) if n%i == 0]\n[2]\n\
    </code>\n<|/ a |>\n<| c |>\nYour algorithm is better than mine, and I learned\
    \ a thing or two about list comprehensions, but it doesn't work when n is prime\
    \ (ie, when n is 2).  For example, the following returns an empty list `[ i for\
    \ i in range (1,2) if n%i == 0]`.\n<|/ c |>\n<| c |>\nThat's why I said 'a simple\
    \ way' which meant to be a more readable one-liner. :) But you're right, this\
    \ algorithm doesn't work with prime numbers. I've edited my answer to include\
    \ another solution.\n<|/ c |>\n<| c |>\nYou meant `range(1, n // 2)`, not `range(1,\
    \ n / 2)`\n<|/ c |>\n<| a dscore=1 |>\nFor prime factorizations, you may want\
    \ to try the following:\n<code>\n>>> def prime_finder(limit):\n...     primes\
    \ = [2]\n...     for n in range(3, limit, 2):\n...         if n%2 != 0:\n... \
    \            continue\n...         if all(n % p for p in primes):\n...       \
    \      primes.append(n)\n...     return primes\n...\n>>> prime_finder(100)\n[2,\
    \ 5, 17, 29, 31]\n</code>\nIf you want all the prime factors:\n<code>\n>>> def\
    \ prime_finder(limit):\n...     primes = [2]\n...     for n in range(3, limit,\
    \ 2):\n...         if n%2 != 0:\n...             continue\n...         if all(n\
    \ % p for p in primes):\n...             primes.append(n)\n...     return primes\n\
    ...\n>>> prime_factors = []\n>>> for n in range(1, 100):\n...     if n in prime_finder(n):\n\
    ...         prime_factors.append(n)\n...\n>>> prime_factors\n[2, 5, 17, 29, 31,\
    \ 71, 73, 79, 89, 97]\n</code>\n<|/ a tags=python,php,algorithm |>\n<| a tags=python,php,algorithm\
    \ |>\n<code>\ndef largest", "    if ($n < 2) {\n        return $n;\n    }\n\n\
    \    // See http://www.javascripter.net/math/primegen.htm for a description and\
    \ sieve\n    // tests. Seems to give reasonable results for n < 10^8.\n    $i\
    \ = $j = 2;\n    $root = $n = $n_copy = $n_copy_2 = $max_prime = 2 + $n / 2;\n\
    \n    do {\n        while ($n % $n_copy != 0 && $n_copy < $max_prime) {\n    \
    \        $n_copy += $n_copy_2;\n            $j++;\n        }\n\n        $max_prime\
    \ = $n_copy < $n ? $n_copy : (int)$n;\n        $n_copy_2 = (int)$n / $j;\n   \
    \     $n = (int)($j * ($j + 1) / 2);\n\n        if ($n_copy == $max_prime) {\n\
    \            break;\n        }\n\n        if ($i > $j) {\n            $root +=\
    \ $j;\n            $i = $j = $n;\n        }\n    } while ($n > 1);\n\n    return\
    \ (int)$root;\n}\n", "    if ($n < 3) {\n        return $n;\n    }\n\n    $a =\
    \ $n = 2; // n > 0\n    while ($n % $a != 0) {\n        $a = $a * $n--;\n    }\n\
    \    return $a;\n}\n</code>\n<|/ a |>\n<| c |>\nThe only problem with this is\
    \ it uses recursion. I didn't mention that in my answer but I was hoping I could\
    \ find a solution without recursion but this does the job nicely.\n<|/ c |>\n\
    <| c |>\nI didn't even know PHP had a built in function for this. I learned something\
    \ new today!\n<|/ c |>\n<| c |>\nHow did you find this out? I'd like to know for\
    \ my own future reference. :)\n<|/ c |>\n<| c |>\nI tried some code but it was\
    \ too slow so I got bored and googled for some code I found online and started\
    \ reading it. I was able to find this [link](https://gist.github.com/philstan/4775604)\
    \ and rewrote it to be PHP. After a few hours of coding, I came up with some code\
    \ that does the same thing.\n<|/ c |>\n<| a dscore=1 tags=primes,php |>\nJust\
    \ wanted to mention that this problem has since been solved. It can be found here.\n\
    <|/ a |>\n<| c |>\nCould you explain how you \"solved\" this problem?  If it's\
    \ only meant to be a \"fun fact\" and not actually useful I suppose you could\
    \ say \"I rewrote the code\".  If it's actually useful I suppose you could add\
    \ it to the answer.\n<|/ c |>\n<| c |>\nI actually solved it by modifying the\
    \ code from that link to my own preferences. I rewrote the code to be as compact\
    \ as possible. I was able to do that because I already know PHP and know how the\
    \ code works. I didn't realize I could run a script on the PHP command line to\
    \ solve this problem. After I wrote it, I realized how fast it ran and was able\
    \ to write some more compact code that solved the problem within a minute or so\
    \ on my computer.\n<|/ c |>\n<| c |>\n\"After I wrote it, I realized how fast\
    \ it ran and was able to write some more compact code that solved the problem\
    \ within a minute or so on my computer.\"\n\nCan you share your rewrite?  It might\
    \ make it more useful to future visitors.\n<|/ c |>\n<| c |>\n: I wish I could,\
    \ but the code I rewrote was written in 2006 so I don't have my original code\
    \ in front of me anymore", "  global $primes;\n  $n = abs($n);\n  $m = 1;\n  $k\
    \ = 0;\n  while ($n % $m === 0) {\n    ++$k;\n    $m = $primes[$k];\n  }\n  return\
    \ $m;\n}\n</code>\n<|/ a dscore=1 tags=prime-factoring,php |>\n<| c |>\nA couple\
    \ of notes about this: 1) The `array_search` method will do _way_ better with\
    \ PHP 5.5+ as you can use the `array_search` function directly, and 2) the algorithm\
    \ you're using is quite inefficient. You're using way too much memory.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nThis is my solution, using PHP5.5's array_search function:\n\
    <code>", "    $n = abs($n);\n    $n_limit = $n;\n    $factor = 1;\n\n    // While\
    \ n is greater than or equal to one...\n    while (--$n_limit) {\n        // Set\
    \ a flag to signify whether a factor is found.\n        $found = false;\n\n  \
    \      // Find the next factor starting from two.\n        for ($i = 2; $i * $i\
    \ <= $n; $i++) {\n            // If this factor is prime...\n            if ($n\
    \ % $i == 0) {\n                // ...and its not already a factor of n...\n \
    \               if ($factor * $i != $n) {\n                    // ...then update\
    \ n to the square root of i and mark\n                    // it as a factor.\n\
    \                    $n = sqrt($i);\n                    $factor = $i;\n     \
    \               $found = true;\n                    break;\n                }\n\
    \            }\n        }\n\n        // If the flag has not been set, this n is\
    \ not a prime factor of\n        // n.  So test to see whether we can find one.\n\
    \        if (!$found) {\n            // If n is 1, then there is no prime factor\
    \ 1.  Therefore\n            // n is greater than 1.  If n is 2 or 3, then the\
    \ smallest\n            // prime greater than 1 is 3.  So 2 is the only prime\n\
    \            // factor greater than 1, so we set n to 3 and factor\n         \
    \   // accordingly.\n            if ($n == 1) {\n                $factor = 3;\n\
    \            } else {\n                // n > 1 and n is not a prime number. \
    \ So if n\n                // divides evenly into three numbers, then n is prime\n\
    \                // to factor.  So we set n to half of n, set the\n          \
    \      // factor to 2, and continue our search.\n                if ($n / 2 %\
    \ 2 == 0) {\n                    $factor = 2;\n                } else {\n    \
    \                $factor = 3;\n                }\n            }\n        }\n \
    \   }\n    return $factor;\n}\n\n$prime = largest_prime_factor(2000);\necho \"\
    Largest prime factor of 2000 is $prime\\n\";\n</code>\nThis code is also available\
    \ as PHP Code Sandbox Demo.\n<|/ a dscore=4 |>\n<| a dscore=3 tags=php,primes\
    \ |>\nI see that you have already made an attempt at solving this problem yourself.\
    \ However, I would like to share a link to the Wikipedia article on the prime\
    \ number theory, which has already been given a lot of attention in an earlier\
    \ answer:\nhttp://en.wikipedia.org/wiki/Prime_number_theory\nIn particular, the\
    \ article states that the largest prime factor can be found by starting at 2 and\
    \ then incrementing by odd numbers.\nHere is a PHP code example that does just\
    \ that:\n<code>\n<?php\n", "  $i = 2;\n  while ($n % $i && $i < $n) { // Keep\
    \ searching with this number.\n    $i++;\n  }\n  return $i;\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 |>\nHere is my solution in PHP\n<code>", "    if ($n<2) return\
    \ null;\n    if ($n<3) return 1;\n    \n    // Create a prime factors array of\
    \ size n\n    // and put n prime factors in it\n    // The algorithm is O(n)\n\
    \    $factors = array();\n    for ($i=1; $i<=$n; $i++) {\n        if (isPrime($i))\
    \ {\n            $factors[$i] = $i;\n            $primes[$i] = 1;\n        }\n\
    \    }\n    $max = $n;\n    while (!isPrime($max)) {\n        for ($i = $n; $i>=2;\
    \ $i--) {\n            // If the current number is less than $max,\n         \
    \   // it divides the current prime factor\n            // and put the new number\
    \ in its place\n            // unless the new number is smaller than current number\n\
    \            // then it doesn't change it\n            if ($factors[$i] > $max)\
    \ {\n                $factors[$i] = $factors[$i] / $max;\n                $primes[$i]\
    \ = 1;\n                $max = $factors[$i]*$max;\n            } else {\n    \
    \            $primes[$i] = 0;\n            }\n        }\n    }\n    $largest_prime_factor\
    \ = $max;\n    \n    return $largest_prime_factor;\n}\n", "    if ($n < 2) {\n\
    \        return $n;\n    }\n\n    $i = $j = 2;\n    $max_i = $n / 2;\n\n    while\
    \ ($i <= $max_i && $n % $i == 0) {\n        $i++;\n    }\n\n    if ($i > $max_i)\
    \ {\n        $j++;\n    }\n\n    return $j;\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThanks for your answer, but this doesn't return what the OP is looking\
    \ for, since it returns the greatest prime factor of n, but doesn't necessarily\
    \ have the highest power of 2 that it might be. i.e. 2^3 > 2^6 > 2^12 > 2^24 >\
    \ 2^48.\n<|/ c |>\n<| c |>\nThanks, I updated my answer. I had misinterpreted\
    \ the question. Anyway, I suggest you give another try to my solution.\n<|/ c\
    \ |>\n<| c |>\nHi, please note that the maximum powers of 2 that the original\
    \ code would have returned are 2^7, 2^9, and so on - not 2^25 and so on. I think\
    \ you meant to write 2^24 > 2^48\n<|/ c |>\n<| a |>\n<code>", "\t$n = abs($n);\n\
    \t$i = 1;\n\twhile ($i < $n) {\n\t\tif ($n % $i == 0)\n\t\t\t$i += 2;\n\t\telse\n\
    \t\t\t$i++;\n\t}\n\treturn $i;\n}\n", "  if ($n < 2) return $n;\n  $rootOfN =\
    \ 1; // The number 1 to the first power of n that is > n.\n  for ($i = 3; $i *\
    \ $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      $rootOfN = lcm($rootOfN, $i);\n\
    \    }\n  }\n  return $rootOfN;\n}\n", "  $prime = 2;\n  $factor = 3;\n  while\
    \ ($n % $factor === 0) {\n    $prime = $factor;\n    $factor++;\n  }\n  return\
    \ $prime;\n}", "  if ($n < 2) return 1;\n  $r = 2;\n  for ($i = 3; $i * $i <=\
    \ $n; $i += 2) {\n    $f = ($n % $i) / $i;\n    if ($f > $r) {\n      $r = $f;\n\
    \    }\n  }\n  return $r;\n}\n\n$t = microtime(true);\n\n$start = $t;\n\nfor ($i\
    \ = 0; $i < 1e5; $i++) {\n  largest_prime_factor(pow(2, $i));\n}\n\n$time = microtime(true)\
    \ - $start;\necho 'largest_prime_factor('.$i.') took ', $time, ' seconds.';",
  "    $test = 2;\n    $factor = 2;\n    $largest_prime_factor = 1;\n    while($test\
    \ * $test <= $n) {\n        if($n % $test == 0) {\n            $factor += $test;\n\
    \            $n = ($n / $test) | 0;\n            $test = 2 * $test + 2;\n    \
    \    }\n        else {\n            $test++;\n            $factor++;\n       \
    \     $n = ($n / $test) | 0;\n            $test = 2 * $test + 2;\n        }\n\
    \    }\n    return $largest_prime_factor * $factor;\n}\n", "    $smallest_factor\
    \ = 1;\n    $max_factor = $n;\n    $i=2;\n    while($n%$i == 0) {\n        $smallest_factor\
    \ = $i;\n        $n = $n/$i;\n        $i++;\n    }\n    while($n % $smallest_factor\
    \ == 0) {\n        $max_factor = $smallest_factor;\n        $smallest_factor =\
    \ $i--;\n    }\n    return $max_factor;\n}\n", "    $sieve = array(\n        3,\n\
    \        3,\n        3,\n        5,\n        7,\n        11,\n        13,\n  \
    \      17,\n        19,\n        23,\n        29,\n        31,\n        37,\n\
    \        41,\n        43,\n        47,\n        53,\n        59,\n        61,\n\
    \        67,\n        71,\n        73,\n        79,\n        83,\n        89,\n\
    \        97,\n        101,\n        103,\n        107,\n        109,\n       \
    \ 113,\n        127,\n        131,\n        137,\n        139,\n        149,\n\
    \        151,\n        157,\n        163,\n        167,\n        173,\n      \
    \  179,\n        181,\n        191,\n        193,\n        197,\n        199,\n\
    \        211,\n        223,\n        227,\n        229,\n        233,\n      \
    \  239,\n        241,\n        251,\n        257,\n        263,\n        269,\n\
    \        271,\n        277,\n        281,\n        283,\n        293,\n      \
    \  307,\n        311,\n        313,\n        317,\n        331,\n        337,\n\
    \        347,\n        349,\n        353,\n        359,\n        367,\n      \
    \  373,\n        379,\n        383,\n        389,\n        397,\n        401,\n\
    \        409,\n        419,\n        421,\n        429,\n        433,\n      \
    \  439,\n        443,\n        449,\n        457,\n        461,\n        463,\n\
    \        467,\n        479,\n        483,\n        487,\n        491,\n      \
    \  499,\n        503,\n        509,\n        521,\n        523,\n        541,\n\
    \        547,\n        557,\n        563,\n        569,\n        571,\n      \
    \  577,\n        587,\n        593,\n        599,\n        601,\n        607,\n\
    \        613,\n        617,\n        619,\n        631,\n        641,\n      \
    \  643,\n        647,\n        653,\n        659,\n        661,\n        673,\n\
    \        677,\n        683,\n        691,\n        701,\n        709,\n      \
    \  719,\n        ", "    $n = intval($n);\n    if ($n < 2) {\n        return $n;\n\
    \    }\n    $ret = 1;\n    $primes = array();\n    for($i = 2; $i < intval($n);\
    \ $i++) {\n        if ($n % $i == 0) {\n            $primes[] = $i;\n        \
    \    $n = $n / $i;\n        } else {\n            if ($primes && $primes[count($primes)-1]\
    \ * $i >=  $n) {\n                $ret = $i;\n                $n = $n * $ret;\
    \ // make the number smaller\n                break;\n            }\n        }\n\
    \    }\n    return $ret;\n}\n", "    $result = $n;\n    $factor = 1;\n    $i =\
    \ 3;\n    do {\n        while ($i ** 2 <= $n) {\n            $result = $i;\n \
    \           $factor++;\n            $i++;\n        }\n        $i--;\n    } while\
    \ ($i > 1);\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe reason why\
    \ I said it was `O(n)` is because there are a lot more factors. But of course\
    \ you're right, I shouldn't have said that.\n<|/ c |>\n<| c |>\nSorry, I meant\
    \ `O(log n)`.\n<|/ c |>\n<| c |>\nIt seems that `O(log n)` is actually slower\
    \ than `O(n)`. On my system it's almost 50x slower! Can you post the code you're\
    \ testing on?\n<|/ c |>\n<| c |>\nStrange! When I first tested this, my first\
    \ solution ran in about 10 seconds and mine took about 1.3 seconds.\n<|/ c |>\n\
    <| c |>\nAh, I didn't realise you used the function as a parameter. Thanks for\
    \ clarifying that! I've edited my post accordingly.\n<|/ c |>\n<| a |>\nI created\
    \ a function which returns the factors of a number, in an array (so you don't\
    \ have to keep track of the factors yourself, if you just need the largest one\
    \ or something).\n<code>", "  $n--;\n  \n  // Start at 3 and go up until you reach\
    \ sqrt(n).\n  for ($i = 3; $i < sqrt($n); $i++) {\n    // See if n is divisible\
    \ by $i.\n    if ($n % $i == 0) {\n      // Since n is composite and even ($i\
    \ is a perfect square),\n      // and greater than or equal to sqrt($i), n is\
    \ congruent to $i.\n      // Therefore, $n is congruent to $i * $i for some i.\n\
    \      return $i * $i;\n    }\n  }\n\n  // If $i reaches sqrt($n), then $n does\
    \ not have any factors.\n  return 1;\n}\n</code>\n<|/ a tags=math,php,algorithm\
    \ |>\n<| a tags=math,php,algorithm |>\nThis is not a PHP solution but I found\
    \ a solution that seems to work using Excel. The function will return the largest\
    \ prime factor of an integer. Here is a picture of what it looks like in Excel:\
    \ \n\nThe code is below (I used Excel to find the number of columns for every\
    \ row in the matrix):\n<code>\nFunction PrimeFactors(n) As Integer\n    PrimeFactors\
    \ = 1\n    For i = 2 To n\n        For j = i To n / i\n            If n = j *\
    \ (i ^ 2) Then\n                PrimeFactors = PrimeFactors + 1\n            \
    \    Exit For\n            End If\n        Next j\n    Next i\nEnd Function\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nI got this solution using Excel, thanks for\
    \ the help but can you please tell me how can i use this function in php?\n<|/\
    \ c |>\n<| c |>\n: You just copy the function into the VBA module of your excel\
    \ sheet. In the function you need to replace \"Integer\" with \"Integer\".\n<|/\
    \ c |>\n<| a dscore=3 |>\n<code>\n<?php", "  if ($n % 2 == 0) {\n    return $n;\n\
    \  }\n  $result = $n;\n  for ($i = 3; $i <= sqrt(($n ** 0.5)); ++$i) {\n    if\
    \ ($n % $i == 0) {\n      $result *= $i;\n      if ($result > $n) {\n        return\
    \ $result;\n      }\n    }\n  }\n  return $result;\n}\n\n/**\n * Generates a random\
    \ password.\n * $length is optional, if null it will be set to 12.\n */", "  $n2\
    \ = $n;\n  $n3 = $n % $n2;\n  $n4 = $n % $n3;\n  $n5 = intval($n4^$n3);\n  return\
    \ ($n5*5*5*5*5) == $n4 ? 5 : intval(($n5*5*5*5*5*5)/$n4);\n}\n", "  // Using sieve\
    \ of Eratosthenes\n  if ($n <= 1) return 1;\n  if ($n % 2==0) { $n = ($n / 2);\
    \ return largest_prime_factor($n); }\n  else {\n    for($i=3; $i*i<= $n; $i+=2)\
    \ {\n      if($n % $i == 0) { $n = ($n / $i); return largest_prime_factor($n);\
    \ }\n    }\n  }\n}", "  $prime = 2;\n  $p = $n;\n\n  for (; $prime > 1; $prime++)\
    \ {\n    $is_prime = true;\n    $multiple = 7;\n\n    while ($multiple != $p)\
    \ {\n      if ($n % $multiple == 0) {\n        $is_prime = false;\n      }\n \
    \     $multiple = $multiple + $multiple;\n    }\n\n    if ($is_prime) {\n    \
    \  $p = $prime;\n    }\n  }\n\n  return $p;\n}", "  if ($n<2) { return 1; }\n\
    \  $max = 2;\n  for ($i=3;$i<=sqrt($n);$i++) {\n    if ($n%$i == 0) { $max++;\
    \ break; }\n  }\n  return $max;\n}", "    if ($n < 2) {\n        return 1;\n \
    \   }\n\n    $i = 2; $m = 3;\n    while ($i <= $n) {\n        if ($n % $i == 0)\
    \ {\n            $m++;\n            while (!(is_prime($m) && $n % $m == 0)) {\n\
    \                $m++;\n            }\n        }\n        $i++;\n    }\n\n   \
    \ return $m;\n}\n", "  $n = abs($n);\n  $n = $n < 2 ? $n : 2;\n  for ($x = 2;\
    \ $n >= $x; $x++) {\n    if ($n % ($x + 1) == 0) {\n      continue;\n    }\n \
    \   else {\n      $p = $x;\n      break;\n    }\n  }\n  return $p;\n}\n", "  //\
    \ Limit to first trial division after which it is obvious that\n  // n is not\
    \ prime to avoid wasting time. Assume n is prime.\n  $limit = $num_iterations\
    \ = trial(sqrt($n));\n\n  // Repeatedly try to divide n by prime factors.\n  while\
    \ (--$num_iterations > 2) {\n    $last_pf = $last_pf == 0 ? 1 : $last_pf * $last_pf;\n\
    \    $d = gcd($last_pf, $n);\n    if ($d == $last_pf) {\n      return $last_pf;\n\
    \    } else if ($d == $n) {\n      return $last_pf;\n    } else {\n      $last_pf\
    \ = $d;\n    }\n  }\n\n  // Trial division did not find any factor because $n\
    \ was prime\n  // or composite.\n  return $last_pf;\n}\n\n/**\n * Return the sum\
    \ of the numbers from 1 to $n, inclusive, raised to the given\n * power.\n *\n\
    \ * @param int $n The integer power that should be raised to the $sum to.\n *\
    \ @return int $sum\n */", "    $max_factor = 1;\n    for($i = 2; $i <= $n; $i++)\
    \ {\n        if ($n % $i == 0) {\n            $max_factor = $i;\n            break;\n\
    \        }\n    }\n    return $max_factor;\n}\n", "    if ($n % 2 == 0) {\n  \
    \      return 2;\n    }\n    $max_factor = 2;\n    $min_factor = 4;\n    while\
    \ ($n % $min_factor == 0) {\n        $max_factor = $min_factor;\n        $min_factor\
    \ = $min_factor * 2;\n    }\n    while ($n % $max_factor == 0) {\n        $max_factor\
    \ = $max_factor * 2;\n    }\n    return $max_factor;\n}", "    $i = 2;\n    while\
    \ (true) {\n        if ($n % $i == 0) {\n            $test = $i;\n        } else\
    \ {\n            $test++;\n        }\n        if ($test <= 1) {\n            break;\n\
    \        }\n        $i += 2;\n    }\n    return $i;\n}", "  $n = abs($n);\n\n\
    \  // Test for small factors first\n  if($n < 4) {\n    return $n;\n  }\n\n  //\
    \ Test for easy primes\n  if($n == 2) { return 2; }\n  if($n == 3) { return 3;\
    \ }\n\n  // Test for composites, i.e. factors that are only evenly divisible by\
    \ their first factor\n  for($x = 2; $x * $x <= $n; $x++) {\n    if($n % $x ==\
    \ 0) { return $x; }\n  }\n\n  // Test for larger factors\n  for($x = $n % 4; $x\
    \ > 0; $x++) {\n    if($n % $x == 0) { return $x; }\n  }\n\n  // If we got here,\
    \ it's because $n is larger than four, so it's impossible to be larger than two\n\
    \  return 2;\n}", "  $factor = 2;\n  $n = abs($n);\n  $i = 3;\n  while ($i <=\
    \ sqrt($n)) {\n    while ($n % $i === 0) {\n      $factor = $i;\n      $n /= $i;\n\
    \    }\n    $i++;\n  }\n  return $factor;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ |>\nThis is my solution:\n<code>\npublic function largestPrimeFactor($num)\n\
    \    {\n        if ($num < 1)\n        {\n            return 0;\n        }\n\n\
    \        for ($i = 1; $i <= sqrt($num); $i++)\n        {\n            if ($num\
    \ % $i == 0)\n            {\n                $fat = $i;\n            }\n     \
    \   }\n\n        return $fat;\n    }\n</code>\n<|/ a tags=primes,math,php dscore=0\
    \ |>\n<| a tags=primes,math,php |>\nThe largest prime factor of a number is defined\
    \ as the largest integer k such that there exists an integer m such that 2k +\
    \ 1 is divisible by m.\nYou can find the largest prime factor for a number n by\
    \ performing the following steps:\n\nIf the number is 1, return 1.\nIf the number\
    \ is divisible by 2, return 2.\nIf the number is divisible by 3, return 3.\nIf\
    \ n is divisible by all integers from 2 to sqrt(n), then n is divisible by one\
    \ of the integers from 2 to sqrt(n), so you can divide the number by one of its\
    \ prime factors and recurse.\nIf n is divisible by all integers from 3 to sqrt(n),\
    \ then n is divisible by one of the integers from 3 to sqrt(n), so you can divide\
    \ the number by one of its prime factors and recurse.\nIf n is divisible by any\
    \ integer from 2 to sqrt(n), then n is divisible by all the integers from 2 to\
    \ sqrt(n), so you can divide the number by all the integers from 2 to sqrt(n)\
    \ and recurse.\nIf n is divisible by any integer from 3 to sqrt(n), then n is\
    \ divisible by all the integers from 3 to sqrt(n), so you can divide the number\
    \ by all the integers from 3 to sqrt(n) and recurse.\nIf n is divisible by all\
    \ integers from 4 to sqrt(n), then n is divisible by all the integers from 4 to\
    \ sqrt(n), so you can divide the number by all the integers from 4 to sqrt(n)\
    \ and recurse.\nIf n is divisible by all integers from 5 to sqrt(n), then n is\
    \ divisible by all the integers from 5 to sqrt(n), so you can divide the number\
    \ by all the integers from 5 to sqrt(n) and recurse.\nIf n is divisible by any\
    \ integer from ", "  $n = abs($n);\n  if ($n <= 2) return 1;\n  if ($n <= 3) return\
    \ 2;\n  $i = 2;\n  while (true) {\n    $i += $n % $i;\n    if ($i <= 1) return\
    \ $i;\n    $n = (int) ($n/$i);\n  }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I like this because it doesn't rely on preg_match. But the regex is unnecessary:\
    \ any divisor greater than 2 can be written as 1\xD7(2\u2217), which is much faster\
    \ to compute.\n<|/ c |>\n<| c |>\nGood point. I would also say that the current\
    \ algorithm would work much faster than that given by Jorge. A prime factor is\
    \ just another divisor. So you can change `$i += $n % $i;` to `$i += $n%$i;`\n\
    <|/ c |>\n<| c |>\nThanks for your answer. I tried your script but found it gives\
    \ wrong results when I used the number \"3358489472\". The largest prime factor\
    \ is 3358489471 whereas the result is 2. The largest prime factor must be larger\
    \ than the input.\n<|/ c |>\n<| c |>\nYes it does return the wrong result. I'll\
    \ fix it.\n<|/ c |>\n<| c |>\nThanks for your help. I've found the answer in another\
    \ post here:\nhttp://stackoverflow.com/questions/1517582/which-prime-factors-of-a-given-number-do-not-exceed-one-other/2184739#2184739\n\
    <|/ c |>\n<| a |>\nTo answer your second question:\n<code>\n<?php", "    if ($n\
    \ <= 1) return 2;\n\n    $m = $n;\n    $i = 1;\n\n    while ($i <= $m) {\n   \
    \     $m = $n % $i;\n\n        if ($m == 0) return $i;\n\n        $i++;\n    }\n\
    \n    return $m;\n}\n", "  if ($n < 4) return $n;\n  $result = 1;\n  for ($i =\
    \ 3; $i <= ceil(sqrt($n)); $i += 2)\n    if ($n % $i == 0)\n      $result *= $i;\n\
    \  return $result;\n}\n</code>\n<|/ a tags=primes,php,math,algorithm |>\n<| a\
    \ tags=primes,php,math,algorithm |>\nUse Sieve of Eratosthenes algorithm. It is\
    \ efficient and fast.\n<code>\n<?php", "    $n = $n + 1; // Make sure we don't\
    \ go below 1.\n    $i = 1; $limit = sqrt($n);\n    while($i <= $limit) {\n   \
    \     $isprime = isPrime($i);\n        $isprime = isPrime($n);\n        if($isprime)\
    \ {\n            return $i;\n        }\n        $i++;\n    }\n}\n", "    $n =\
    \ abs($n);\n    $l = array();\n    for($i = 2; $i <= $n; ++$i) {\n        $l[$i]\
    \ = pow($i, $n - $i, $n);\n    }\n    asort($l);\n    return $l[count($l)-1];\n\
    }\n\n$x = largest_prime_factor(8327);\necho 'The largest prime factor of 8327\
    \ is ' . $x . '.';", "  $n = abs($n);\n  $result = 1;\n  while ($n > 1) {\n  \
    \  if ($n % $result === 0) {\n      $result = $result;\n    }\n    $n--;\n  }\n\
    \  return $result;\n}\n", "    $n = $n ? $n : 1;\n    if ($n % 2) {\n        return\
    \ $n;\n    }\n    $n--;\n    $m = $n;\n    while ($m % 2 == 0) {\n        $m--;\n\
    \    }\n    while (true) {\n        if ($m % 3 == 0) {\n            $m = $m /\
    \ 3;\n            return $m * 3 * $n;\n        }\n        if ($m % 5 == 0) {\n\
    \            $m = $m / 5;\n            return $m * $n * $n;\n        }\n     \
    \   $m--;\n    }\n}", "    $i = 1;\n    $res = 1;\n    while(true) {\n       \
    \ if ($n % $i == 0) {\n            if ($i > $res) {\n                $res = $i;\n\
    \            }\n            $i++;\n        } else {\n            break;\n    \
    \    }\n    }\n    return $res;\n}\n\n/**\n * Creates HTML form with user data\
    \ and request for adding new user\n */", "  $n = $n - 1;\n  for ($i = 2; $i *\
    \ $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      break;\n    }\n  }\n  return\
    \ $n + $i;\n}\n", "  $n = abs($n);\n  $m = $n;\n  $i = 2;\n  while ($m % $i ==\
    \ 0) {\n    $m = $i * $i;\n    $i++;\n  }\n  return $m > $n ? $n : $m;\n}\n",
  "  $n = $n | 0; // force integer on 32-bit machines\n\n  assert($n > 1);\n\n  for\
    \ ($i = 3; $i <= sqrt($n); $i+=2) {\n    if ($n % ($i * 2) == 0) {\n      return\
    \ $i;\n    }\n  }\n\n  return 1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not a\
    \ code dump, but a working code dump.\n<|/ c |>\n<| c |>\nSorry, I was unable\
    \ to get the code snippet working in php 5.3.5, but I was able to get it to run\
    \ on php 5.2.17.  Updated my answer with the working php code.\n<|/ c |>\n<| c\
    \ |>\nThanks for adding the PHP version to your answer! It saved me a lot of time.\
    \ Upvote for you!\n<|/ c |>\n<| c |>\nA few things are missing. Why do you use\
    \ the `intval($n)` cast? What is `$n` supposed to be? Why do you have a `$i` counter,\
    \ when you can just use the loop's `for` construct?\n<|/ c |>\n<| a tags=php dscore=5\
    \ |>\n<code>", "    if ($n <= 1)\n        return $n;\n    // Find the highest\
    \ power of 2 that's the same or larger than $n.\n    $p = 1;\n    while ($p *\
    \ 2 <= $n) {\n        $p++;\n    }\n    $max = (int) ($n / $p);\n    // Find the\
    \ largest divisor of $n smaller than the greatest power of 2.\n    for ($i = 1;\
    \ $i <= $p; $i++) {\n        if ($n % $i == 0) {\n            $max = (int) ($n\
    \ / $i);\n            break;\n        }\n    }\n    return $max;\n}\n</code>\n\
    <|/ a |>\n<| a |>\n<code>\n<?php\n", "    $n = abs($n);\n\n    $factor = 1;\n\
    \    do {\n        $n1 = $n >> 1;\n        $n = $n % $n1;\n        $factor++;\n\
    \    } while ($n);\n\n    return $factor;\n}\n", "    if ($n % 2) {\n        return\
    \ 0;\n    }\n\n    $i = 2;\n    while ($i <= $n) {\n        if ($n % $i === 0)\
    \ {\n            $i++;\n        }\n        else {\n            $n = $n / $i;\n\
    \            return $i;\n        }\n    }\n}", "    $n = abs($n);\n    $i = 2;\n\
    \    $max_i = null;\n    while ($i <= sqrt($n)) {\n        if ($n % $i == 0) {\n\
    \            $max_i = $i;\n        }\n        $i++;\n    }\n    return $max_i\
    \ == null ? 1 : $max_i;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks so much\
    \ for the answer. However, I'm looking for a more simple and effective way to\
    \ code this problem, which is not to calculate large prime factors of a number.\
    \ I'm looking for an algorithm to find prime numbers in an array and save them\
    \ into another array. For example, if you have a list of prime numbers and want\
    \ to find if any of these numbers are factors of another number, we can do that.\n\
    <|/ c |>\n<| c |>\nI see, I see. Yes, I suppose that you can find the factors\
    \ of a number in O(1) time using `Fermat's little theorem`. I have updated my\
    \ answer with a better algorithm that can solve your problem.\n<|/ c |>\n<| c\
    \ |>\nThanks so much, I really appreciate your help. However, can you please elaborate\
    \ on how Fermat's little theorem works? Also, would you be able to write an example\
    \ in PHP of how to get prime numbers from an array and save them into another\
    \ array, using your algorithm?\n<|/ c |>\n<| c |>\nFermat's little theorem is\
    \ just that it is true that for any number `n`, if `n` is prime then `Fermat's\
    \ little theorem` holds. So you just need to find the prime numbers and store\
    \ them in a list. After that, you just need to check if your number is prime or\
    \ not. Also, if you want to know how to find the prime numbers in an array, you\
    \ can use [this](https://www.geeksforgeeks.org/find-prime-numbers-in-an-array-using-sieve-method/).\n\
    <|/ c |>\n<| c |>\nAwesome. Thanks so much! Sorry I didn't understand your reply\
    \ before, but I really appreciate your help.\n<|/ c |>\n<| a dscore=0 tags=php,math,algorithm\
    \ |>\nI have found a way to code it without needing a bigger function but with\
    \ your code:\n<code>\n$array = array(1, 12, 7, 11);\nforeach($array as $number){\n\
    \    echo largest_prime_factor($number);\n}\n</code>\nI hope this works for you!\n\
    <|/ a |>\n<| c |>\nThank you, however that did not work. Do you know how I could\
    \ get it to work? Also, I have edited my ", "    // Initialization.\n    $result\
    \ = 2;\n    $factor = 3;\n\n    // Iteration.\n    while ($n != 1) {\n       \
    \ $result = $factor;\n        $factor = $n % $factor;\n        $n = ($n / $factor)\
    \ - 1;\n    }\n\n    return $result;\n}\n", "    $n->is_prime() !== TRUE or $n->is_even()\
    \ ? return 0 : ($n = $n->clone(), $n->is_prime() ? 1 : 2);\n    foreach ($n->subtract(2)\
    \ as $i) {\n        $n->is_prime() != TRUE or $n->is_even() ? return 0 : $n->subtract($i);\n\
    \    }\n    return $n->factors()->count;\n}\n", "  $i = 2;\n  $p = 1;\n  while\
    \ (!is_prime($n)) {\n    if ($n % $i == 0) {\n      $p = $i;\n    } else {\n \
    \     $i++;\n    }\n  }\n  return $p;\n}\n", "  for ($x = 2; $x < $n; $x++)\n\
    \    if ($n % $x == 0)\n      return $x;\n  return $n;\n}\n", "  $n = $n - 1;\n\
    \  $max_factor = 1;\n  $sqrt_n = sqrt($n);\n  for($i = 2; $i <= $sqrt_n; $i++)\
    \ {\n    $f = 1; // i!\n    for($j = 2; $j <= $i; $j++) {\n      if ($n % $j ==\
    \ 0) {\n        $f = 0; // Not prime.\n        break;\n      }\n    }\n    if\
    \ ($f) {\n      $max_factor = $i;\n    }\n  }\n  return $max_factor;\n}\n</code>\n\
    <|/ a tags=php |>\n<| c |>\ni tried this one but its not giving me the right answer\
    \ when i give input as 1000 its showing output as 2 but i want output as 4 but\
    \ when i input 1000 it showing the correct output\n<|/ c |>\n<| a tags=php dscore=2\
    \ |>\nTo find the largest prime factor of $n, I suggest you use the prime sieve\
    \ of Eratosthenes - here is the PHP code (from here - https://primes.utm.edu/lists/small/millions/\
    \ ):\n<code>", "  list($max_factor, $min_factor) = prime_factors($n);\n\n  return\
    \ $max_factor > $min_factor\n    ? $max_factor\n    : $min_factor;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>\n<?php", "    $result=1;\n    for($i=2;$i<=$n/$result;$i++)\
    \ {\n        if($n%$i==0) {\n            $result=$i;\n            break;\n   \
    \     }\n    }\n    return $result;\n}\n", "  $n = abs($n);\n  $factors = array_filter(range(2,\
    \ $n), function ($n) use ($n) {\n    return $n % $n == 0;\n  });\n  return count($factors)\
    \ > 0 ? $factors[0] : $n;\n}\n", "    if ($n < 2) {\n        $return = 1;\n  \
    \  } else {\n        $return = $this->largest_prime_factor($n-1);\n        $return\
    \ = $return * $n;\n    }\n    return $return;\n}\n", "  $n = abs($n);\n  if ($n\
    \ == 1)\n    return 1;\n  if ($n <= 2)\n    return 2;\n  // Finding largest factor\
    \ of an odd number greater than 1\n  // uses formula for Sieve of Eratosthenes:\
    \ https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Finding_the_greatest_prime_factor\n\
    \  for ($n = 3; $n <= sqrt($n); $n += 2)\n    if (isPrime($n)) $n = $n % 2 ==\
    \ 0 ? $n : 3 * $n + 1;\n  return $n;\n}\n", "    $i = 2; \n    while (true) {\n\
    \        if ($n % $i == 0) { \n            break;\n        } \n        $i += 2;\n\
    \    }\n    return $i;\n}\n", "  $primes = range(1, $n); // Generate a list of\
    \ all prime factors of n\n  $result = 1; // Start with 1 (the largest prime)\n\
    \  for ($i = 0; $i < count($primes); $i++) {\n    if ($n % $primes[$i] == 0) {\
    \ // If n is divisible by one of the prime factors, divide n by that prime factor\n\
    \      $result *= $primes[$i];\n      $n = ($n / $primes[$i]); // n is now divisible\
    \ by that prime factor\n    }\n  }\n  return $result; // Return the largest prime\
    \ factor in $primes\n}\n", "\t$i = 2;\n\twhile (true) {\n\t\tif ($n % $i == 0)\
    \ {\n\t\t\t$n /= $i;\n\t\t} else {\n\t\t\treturn $i;\n\t\t}\n\t\t++$i;\n\t}\n\
    }\n", "  if ($n <= 1) {\n    return 1;\n  }\n  $i = 2;\n  while (1) {\n    $square\
    \ = $i * $i;\n    $is_prime = !$n & $i;\n    if ($is_prime) {\n      return $i;\n\
    \    }\n    if ($square < $n) {\n      break;\n    }\n    $i += $i;\n  }\n  return\
    \ 1;\n}\n", "    $i = 2; $n *= $n; $n -= $i; while ($i < $n) $i += $i;\n    return\
    \ $i;\n}\n", "    $n = abs($n);\n    $i = 2;\n    while (true) {\n        if ($n\
    \ % $i == 0)\n            return $i;\n        $i++;\n    }\n}\n</code>\n<|/ a\
    \ tags=algorithm,php,math |>\n<| c |>\nThis is not going to be very efficient\
    \ for a big number...\n<|/ c |>\n<| c |>\nThe number we are talking about is going\
    \ to be pretty large, so the time complexity won't be very large, but your point\
    \ still stands. Also, this is still not a very good approach.\n<|/ c |>\n<| c\
    \ |>\nYeah, this answer doesn't work for big numbers. But I added another answer\
    \ that is a much better approach for this problem.\n<|/ c |>\n<| c |>\nHow would\
    \ you use this to get the number of divisors of a big number, let's say $n? I\
    \ don't understand the logic here.\n<|/ c |>\n<| c |>\n: This answer does not\
    \ work. The problem asks for \"the highest prime factor of n\". Your answer returns\
    \ \"the highest prime factor of 2\".\n<|/ c |>\n<| a dscore=5 |>\nFor a non-prime\
    \ number:\n<code>\n<?php\n$n = 3000;\n$primeFactors = array();\n\nfor($i = 2;\
    \ $i <= $n; $i++) {\n  if($n % $i == 0) {\n    $primeFactors[] = $i;\n  }\n}\n\
    \n$maxPrimeFactor = array_shift($primeFactors);\n\necho \"The highest prime factor\
    \ of $n is: $maxPrimeFactor\\n\";", "    if ($n < 2)\n        return 1;\n    if\
    \ ($n <= 6)\n        return 2;\n    $result = 2;\n    $p = $n = 2 ;\n    while\
    \ (1) {\n        while ($n % $p) {\n            $result++;\n            $p++;\n\
    \        }\n        if ($p == $n)\n            break;\n        $p++;\n       \
    \ $n = $n * $p;\n    }\n    return $result;\n}\n", "  $i = 2; $p = 1; $factor\
    \ = 1;\n  while ($i <= $n) { \n    if ($n % $i == 0) { $i = $i + 1; $p = $p *\
    \ $i; }\n    $factor = $i * $factor;\n    $n = $n / $i;\n  }\n  return $factor;\n\
    }", "    $i = 2; \n    while ($n % $i == 0) { \n        $i += 2; \n    } \n  \
    \  if ($n % $i == 0) { \n        return $i; \n    } \n    $m = $i + (int) $i;\
    \ \n    while ($n % $m == 0) { \n        $m += $i; \n    } \n    if ($n % $m ==\
    \ 0) { \n        return $m; \n    } \n    return $n; \n}\n", "  $highest = 2;\n\
    \  $n = abs($n);\n  while ($n > 1) {\n    $f = $n % $highest;\n    $n = floor($n/$highest);\n\
    \    if ($f <= 0) {\n      break;\n    }\n    $highest = $f;\n  }\n  return $highest\
    \ ? $highest + 1 : 2;\n}\n", "  if ($n < 2) {\n    return $n;\n  }\n\n  $sqrtn\
    \ = sqrt($n);\n  while ($sqrtn % 2) {\n    $sqrtn--;\n  }\n\n  for ($i = 1; $i\
    \ <= $sqrtn; $i++) {\n    if ($n % $i == 0) {\n      return $i;\n    }\n  }\n\n\
    \  return $n;\n}\n", "    if ($n < 2) {\n        return 0;\n    }\n    $p = $n\
    \ = 2; // the candidate prime factor\n    $max_p = 0; // largest candidate factor\
    \ found\n    while ($n % $p != 0) {\n        $p = $p * 3 + 1;\n    }\n    $max_p\
    \ = $p; // greatest prime factor\n    while (true) {\n        if ($n == $max_p)\
    \ return $max_p;\n        $next_p = ($n / $max_p) | 0; // next potential prime\
    \ factor\n        if ($next_p * $max_p < $n) break; // overflow protection\n \
    \       $p = $next_p; // update p\n        $max_p = $p; // update max_p\n    }\n\
    }\n", "    $n = abs($n);\n    $start = 2;\n    $end = $n - 1;\n    $factor = $start;\n\
    \    while (true) {\n        if ($n % $factor == 0) {\n            $factor = $end;\n\
    \        }\n        else if ($n == $factor) {\n            break;\n        }\n\
    \        $start += 1;\n        $end -= 1;\n    }\n    return $factor;\n}\n", " \
    \   $i = 2;\n    $largest_prime = ceil($n / 2);\n\n    while ($i <= $largest_prime)\
    \ {\n        if ($n % $i == 0) {\n            $largest_prime = $i;\n        }\n\
    \n        ++$i;\n    }\n\n    return $largest_prime;\n}\n", "  $max = 0;\n  for\
    \ ($i = 2; $i * $i < $n; $i++) {\n    if ($n % $i == 0) {\n      $max = $i;\n\
    \      break;\n    }\n  }\n  return $max;\n}\n</code>\n<|/ a tags=php,math |>\n\
    <| c |>\nNice. That's a nice way of thinking about it! Thanks for that :)\n<|/\
    \ c |>\n<| c |>\nThis algorithm is wrong. Consider $n=5; it will say that the\
    \ largest prime factor is 3, while 5 is clearly not prime. Try this with $n=13671\
    \ and you'll see the problem (it returns 2 for 13671 instead of 3).\n<|/ c |>\n\
    <| c |>\nGood point and yes, it does say that. However, the prime factorization\
    \ algorithm only considers factors up to the square root of the number. That should\
    \ fix it because 5 is clearly not divisible by any prime greater than 2.\n<|/\
    \ c |>\n<| c |>\n`large_prime_factors` has become an integral part of the [Mathematics](http://en.wikipedia.org/wiki/Mathematics)\
    \ proposed in the Wikipedia article, so a comment here should be enough to say\
    \ that this is Mathematics ;) I like the fact that we can easily change `$max`\
    \ to `$min` because we know that n>1, and we know that no prime factor is greater\
    \ than the square root of n. Though I agree that your solution is more elegant.\
    \ Also the problem of finding the largest *prime* factor is solvable with only\
    \ a single loop, and it is still among the fastest solutions.\n<|/ c |>\n<| c\
    \ |>\nYes, sorry. I've just seen that `largest` means `largest` :)\n<|/ c |>\n\
    <| a |>\n<code>", "    $factors = 0;\n    $n = abs($n);\n    for($i = 2; $i <\
    \ $n; $i++) {\n        $factors = $i * $factors;\n        if($n % $i == 0) {\n\
    \            $factors = 0;\n            break;\n        }\n    }\n    return $factors;\n\
    }\n", "  $max = count($factors) * 2;\n  for ($i = 2; $i <= $max; ++$i) {\n   \
    \ if ($n % $i == 0) {\n      if ($i !== $n) {\n        $n = $i / $n;\n      }\n\
    \      return $n;\n    }\n  }\n}\n", "    static $largest = array(2);\n    if\
    \ ($n > 1) {\n        $largest[0] = 1;\n        $largest[1] = 1;\n        for\
    \ ($i = 2; $i < $n; ++$i) {\n            if ($n % $i == 0) {\n               \
    \ $largest[1] += $largest[0];\n                $largest[0] *= $i;\n          \
    \  } else {\n                if ($largest[0] > $largest[1]) {\n              \
    \      $largest[1] = $largest[0];\n                }\n                $largest[0]\
    \ = $i;\n            }\n        }\n    }\n    return $largest[1];\n}\n</code>\n\
    <|/ a tags=php,primes,performance |>\n<| c |>\nThis is probably the best answer\
    \ here. It does it in a single linear pass and doesn't have to keep track of all\
    \ the previous factors. It's very clever.\n<|/ c |>\n<| c |>\n+1. Not sure if\
    \ it would be faster, but it's quite clever, and very easy to understand what\
    \ it does.\n<|/ c |>\n<| a tags=php,primes,performance |>\nYou could do something\
    \ like this :\n<code>", "  if ($n < 2) {\n    return 1;\n  }\n\n  for ($d = 2;\
    \ $d <= $n / 2; ++$d) {\n    if ($n % $d === 0) {\n      return $d;\n    }\n \
    \ }\n\n  return 1;\n}\n ", "  if ($n == 2)\n    return 2;\n\n  if ($n < 2)\n \
    \   return null;\n\n  $s = 2;\n  $t = $n;\n\n  while (true) {\n    if (($t % $s)\
    \ == 0) {\n      return $s;\n    }\n    $s = $s + $t; // s = 2t + 1 always\n \
    \   $t = $s / $s;\n  }\n}\n", "    $n = $n % 2; //Ensure $n is odd\n    if ($n\
    \ <= 1) return 2;\n    \n    $i = $j = 2;\n    while ($i * $i <= $n) {\n     \
    \   if ($n % $i == 0) {\n            $j++;\n            $i /= $j;\n        }\n\
    \        elseif ($i % $j == 0) {\n            $j++;\n        }\n        elseif\
    \ ($j > $i) {\n            $i = $j;\n        }\n    }\n    return $j;\n}", " \
    \   $nstr = $this->str_pad($n, '0', $this->lg_digits);\n    // if n is less than\
    \ 2 then return 0\n    if ($n < 2) {\n        return 0;\n    }\n    $n = intval($n);\n\
    \    // If n is prime then return the number\n    if ($n <= 1) {\n        return\
    \ $n;\n    }\n    // See if n is a prime already by checking the factors\n   \
    \ $a = $this->sieve_of_eratosthenes($n);\n    if (array_key_exists($n, $a)) {\n\
    \        return $a[$n];\n    }\n    // If n is not prime then proceed to square\
    \ root n\n    $d = $this->safe_sqrt($n);\n    if ($d !== 1) {\n        return\
    \ $d;\n    }\n    // If a square root does not exist, return 1\n    // This can\
    \ occur if $d is a long decimal number with many digits\n    return 1;\n}\n",
  "  $primes = array(\n    2,\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n\
    \    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n\
    \    59,\n    61,\n    67,\n    71,\n    73,\n    79,\n    83,\n    89,\n    97,\n\
    \    101,\n    103,\n    107,\n    109,\n    113,\n    127,\n    131,\n    137,\n\
    \    139,\n    149,\n    151,\n    157,\n    163,\n    167,\n    173,\n    179,\n\
    \    181,\n    191,\n    193,\n    197,\n    199,\n    211,\n    223,\n    227,\n\
    \    229,\n    233,\n    239,\n    241,\n    251,\n    257,\n    263,\n    269,\n\
    \    271,\n    277,\n    281,\n    283,\n    293,\n    307,\n    311,\n    313,\n\
    \    317,\n    331,\n    337,\n    347,\n    349,\n    353,\n    359,\n    367,\n\
    \    373,\n    379,\n    383,\n    389,\n    397,\n    401,\n    409,\n    419,\n\
    \    421,\n    431,\n    433,\n    439,\n    443,\n    449,\n    457,\n    461,\n\
    \    463,\n    467,\n    479,\n    487,\n    491,\n    499,\n    503,\n    509,\n\
    \    517,\n    519,\n    523,\n    529,\n    533,\n    541,\n    547,\n    553,\n\
    \    569,\n    571,\n    577,\n    587,\n    593,\n    599,\n    601,\n    607,\n\
    \    613,\n    617,\n    619,\n    631,\n    641,\n    643,\n    647,\n    653,\n\
    \    659,\n    661,\n    673,\n    677,\n    683,\n    691,\n    701,\n    709,\n\
    \    719,\n    727,\n", "    if ($n <= 1) return $n;\n\n    $i = 2;\n    $limit\
    \ = sqrt($n);\n    while ($i <= $limit) {\n        $limit = ceil($limit / $i);\n\
    \        $i++;\n    }\n    return $i;\n}\n", "    $result = $n;\n    for ($divisor\
    \ = 2; $divisor <= $n; $divisor++) {\n        if ($n % $divisor == 0) {\n    \
    \        $result = $divisor;\n            break;\n        }\n    }\n    return\
    \ $result;\n}\n", "    static $cache;\n    $num = isset($cache[$n]) ? $cache[$n]\
    \ : $cache[$n] = $n; // Cache primes smaller than the square root of $n.\n\n \
    \   if ($num < 2) {\n        return $num;\n    }\n    $i = $num - 1;\n    while\
    \ ($num % $i === 0) {\n        $i--;\n    }\n    if ($num % $i !== 0 && $num !=\
    \ $i) {\n        return $num;\n    }\n    $count = 2;\n    while (!is_prime($i))\
    \ {\n        if (++$count > 1000) {\n            return $num;\n        }\n   \
    \     $i--;\n    }\n    return $i;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe\
    \ first function works, but the second function gives the wrong answer when used\
    \ with large numbers. For example, largest_prime_factor(19000) returns 17, but\
    \ the correct answer is 19.\n<|/ c |>\n<| a dscore=3 |>\nAs far as I know, there\
    \ isn't a PHP function as such (AFAIK) that can do this.  I'd suggest using a\
    \ few lines of C code as a starting point.  You'll want to use gmp or some other\
    \ BigInteger library to perform the actual math.\n<|/ a tags=primes,math,php |>\n\
    <| c |>\nGMP isn't a native PHP extension, you have to use extension.\n<|/ c |>\n\
    <| c |>\nYou're right.  I assumed he was already using GMP.  I hadn't realized\
    \ until I read your post that he wasn't :-)\n<|/ c |>\n<| c |>\nActually his first\
    \ example shows GMP being used :-)\n<|/ c |>\n<| c |>\n- He could use GMP but\
    \ it would be a lot more work to set it up and get it working.  Just to make it\
    \ clear, I'm suggesting a C library that can be compiled into a PHP extension.\
    \  But I guess it all comes down to whether he wants to use GMP or not.\n<|/ c\
    \ |>\n<| c |>\nWell, since you're right about GMP being a lot more work, I'll\
    \ go with your answer for now. =)\n<|/ c |>\n<| a tags=primes,math,php dscore=3\
    \ |>\nThis is an old thread, but I wrote some simple PHP code that might help\
    \ someone in the future.  I wrote this in PHP 5.3.x on Windows using XAMPP.\n\
    <code>", "    $n = abs($n);\n    $i = $j = 2;\n    $factor = 2;\n    while ($i\
    \ <= $n) {\n        $i += $j;\n        while ($n % $factor === 0)\n          \
    \  $factor++;\n        $j += $i + 1;\n    }\n    return $factor;\n}\n</code>\n\
    <|/ a tags=sieve-of-eratosthenes,primes,php |>\n<| a dscore=0 |>\n<code>\n<?php",
  "    // http://comments.gmane.org/gmane.comp.programming.mathematics.misc/16376\n\
    \    // http://math.stackexchange.com/questions/55744/number-of-primes-under-x-100\n\
    \    // http://primes.utm.edu/notes/faq/faq.html#PLT\n    $n = 3*$n + 2;\n   \
    \ $m = 4;\n    while(!($n & 1)) {\n        if($m <= $n) $m++;\n        $n >>=\
    \ 1;\n    }\n    $n += 2;\n    while($m <= $n) {\n        if($n % $m == 0) {\n\
    \            $n /= $m;\n            $m++;\n        } else {\n            break;\n\
    \        }\n    }\n    return $n;\n}\n", "    $f1 = $f2 = $f3 = 1;\n    $isprime\
    \ = 0;\n    // sqrt(n)\n    while ($n) { // If n is 0 or 1, there is nothing to\
    \ do.\n        if ( ! $n%2) {\n            ++$n; // Only odd factors are prime.\n\
    \            if ($n==1) $isprime = 1;\n            $isprime = 1;\n        }\n\
    \        else {\n            // 3n+1 or 2n+1 are not prime; only even factors\
    \ are\n            // prime.\n            $f3 = 1;\n            $f2 = 2;\n   \
    \         while ($n%$f3) {\n                $f3 *= $f2;\n            }\n     \
    \       if ($n%$f2) $f2 *= $f2;\n            if ($n%$f1) $f1 *= $f1;\n       \
    \ }\n        --$n;\n    }\n    return $f1 - ($isprime*2);\n}", "  $result = 1;\n\
    \  $p = 2;\n  for (; $p * p <= $n; $p++) {\n    if ($n % $p == 0) {\n      if\
    \ ($p > $result) {\n        $result = $p;\n      }\n      break;\n    }\n  }\n\
    \  return $result;\n}\n", "    $p = 2;\n    while ($n != 1) {\n        if ($n\
    \ % $p === 0) {\n            break;\n        }\n        $p++;\n        $n = (int)($n\
    \ / $p);\n    }\n    return $p;\n}\n", "  $i = 2;\n  while (!is_prime($i)) $i++;\n\
    \  return $i;\n}\n", "  $n2 = $n * 2;\n  while ($n2 >= 2) {\n    if ($n2 % 2)\
    \ {\n      $n2 = $n2 / 2;\n    } else {\n      while ($n2 % 5 == 0 && ($n2 % 7\
    \ == 0 || $n2 % 3 == 0)) {\n        $n2 = $n2 / 5;\n      }\n    }\n  }\n  return\
    \ $n2;\n}", "  $n = $n | 0;\n  $x = $n = $n % 12;\n\n  while (!($x++))\n    if\
    \ ($x %= 12) $x = 6;\n\n  return($x * $n);\n}\n", "    // n is greater than 2\n\
    \    if ($n > 2) {\n        // n is odd\n        if ($n % 2 == 0) {\n        \
    \    // n is even and greater than 3\n            if ($n % 4 == 0) {\n       \
    \         // n is even and greater than 5\n                if ($n % 6 == 0) {\n\
    \                    // n is odd\n                    return false;\n        \
    \        }\n            }\n        }\n        // n is even\n        if ($n % 2\
    \ == 0) {\n            // n is odd but greater than 3\n            if ($n % 4\
    \ == 0) {\n                // n is even and greater than 5\n                if\
    \ ($n % 6 == 0) {\n                    // n is odd\n                    return\
    \ false;\n                }\n            }\n        }\n    }\n    // n is less\
    \ than or equal to 2\n    return $n;\n}\n</code>\n<|/ a tags=math,php,algorithm,performance\
    \ |>\n<| a dscore=1 tags=math,php,algorithm,performance |>\nI made a solution\
    \ which uses mathematics and is faster:\n<code>", "  // Return the largest prime\
    \ factor of n. Assume n > 1 and is not a prime.\n  if ($n < 2) {\n    return 1;\n\
    \  }\n\n  $result = $n;\n  $factor = 2;\n\n  while (true) {\n    // Divide n by\
    \ $factor. While n >= $factor, keep $factor as $result.\n    // $n % $factor may\
    \ have already been tested as well.\n    if ($n % $factor === 0) {\n      // If\
    \ $result divided by $factor has no remainder, increase $factor.\n      if ($result\
    \ % $factor === 0) {\n        $factor++;\n      }\n    } else {\n      $result\
    \ = $result / $factor;\n      if ($result % $factor === 0) {\n        // If $result\
    \ divided by $factor has no remainder, increase $factor.\n        if ($result\
    \ % $factor === 0) {\n          $factor++;\n        }\n      }\n    }\n    if\
    \ ($result > $n) {\n      return $factor;\n    }\n  }\n}", "    $f = 1;\n    $p\
    \ = 0;\n    while ($n % $f) {\n        $f *= ($p + 1);\n        $p++;\n    }\n\
    \    return $f;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe function is named\
    \ `largest_prime_factor` and doesn't actually return the largest prime factor,\
    \ but rather checks the *largest* prime factor of the input.\n<|/ c |>\n<| c |>\n\
    Thank you for your comment. I'll try to make it more clear.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is a simple program to find largest prime factor of a number.\n<code>",
  "    $result = $n; // Largest prime factor is n\n    $factor = 2;\n    while ($result\
    \ % $factor == 0) {\n        $result = $result;\n        $factor++;\n    }\n \
    \   return $result;\n}", "  $n = abs($n);\n  $i = 2;\n  while ($n > 1) {\n   \
    \ $m = $i * 2;\n    while ($m <= $n) {\n      $n = $m * 2;\n      $m++;\n    }\n\
    \    $i+= 1;\n  }\n  return $i;\n}\n", "    $i = 2;\n    $t = $x;\n    while ($i\
    \ < $n) {\n        if ($n % $i == 0) {\n            $x = $i;\n            $i +=\
    \ 1;\n        } else {\n            $i = $i * 2 + 1;\n        }\n    }\n    return\
    \ $x;\n}\n", "    if ($n <= 1) return $n;\n    $i = 2;\n    while (!is_prime($i)\
    \ && $i <= $n) {\n        $i += $i;\n    }\n    return $i;\n}\n", "    $n = max($n,\
    \ 2); // Make sure $n doesn't get any smaller.\n    $max_num = 2;\n    while ($n\
    \ != 1) {\n        $max = 2;\n        while ($n % $max == 0) {\n            $max++;\n\
    \        }\n        if ($max_num < $max) {\n            $max_num = $max;\n   \
    \     }\n        $n /= $max_num;\n    }\n    return $max_num;\n}", "    $f = 2;\n\
    \    while ($n != 1) {\n        $f = $n % $f;\n        $n = (int) ($n/$f);\n \
    \   }\n    return $f;\n}", "  $n = abs($n);\n  $i = 2;\n  while ($n % $i == 0)\
    \ {\n    $i++;\n  }\n  if ($i == $n) {\n    return $i;\n  }\n  // If n is larger\
    \ than the square root of $i, return $i (the largest factor of n).\n  if ($i *\
    \ 2 == $n) {\n    return $i;\n  }\n  return largest_prime_factor($n / $i);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis has nothing to do with the question.\n<|/ c |>\n\
    <| c |>\nThis is not an answer to the question\n<|/ c |>\n<| c |>\nIt answers\
    \ the question, if you read it closely. It's a question of programming style and\
    \ efficiency rather than actual computational complexity.\n<|/ c |>\n<| a |>\n\
    There are some pretty decent answers here, but I wanted to share one that involves\
    \ some maths.\nWe can find the largest prime factor by dividing the number by\
    \ all prime factors. To make this more efficient, we should store the prime factors.\
    \ I use a dictionary to store the prime factors.\n<code>\n$primeFactors = array();\n\
    \nfor ($i = 2; $i <= $n; $i++) {\n    if (!isset($primeFactors[$i])) {\n     \
    \   $primeFactors[$i] = $i;\n    }\n}\n</code>\nWe can then use the following\
    \ logic:\n<code>\n$maxFactor = 1;\n$maxPrimeFactor = null;\n\nforeach ($primeFactors\
    \ as $primeFactor) {\n    $divisor = sqrt($n);\n    while ($divisor * $primeFactor\
    \ < $n) {\n        $divisor *= $primeFactor;\n    }\n    $maxFactor = max($maxFactor,\
    \ $divisor);\n    if ($n % $divisor) {\n        $maxFactor = count($primeFactors);\n\
    \    }\n}\n</code>\n<|/ a tags=php dscore=2 |>\n<| a |>\nIf your goal is to find\
    \ the largest prime factor of your number, then this algorithm is better (I tested\
    \ it): \n<code>", "    // http://projecteuler.net/problem=32\n    // http://www.primavera.org/working_solutions/primenumbers/archive/2007/10/31/composite_prime_numbers.php\n\
    \    // http://primalgorithm.wikia.com/wiki/Largest_prime_factor\n\n    // Initializations\n\
    \    $m = $n;\n    $sqm = $m & $m;\n    $z = $m;\n    $r = 1;\n    $c = 2;\n\n\
    \    // Finding LCM\n    while ($sqm != 0) {\n        $p = $m / $c;\n        $m\
    \ = $c;\n        $c *= $p;\n        $sqm += $p * $p;\n    }\n    $m = $z * $r\
    \ + $m;\n\n    // Finding LCM2\n    while ($sqm != 0) {\n        $p = $m / $c;\n\
    \        $m = $c;\n        $c *= $p;\n        $sqm += $p * $p;\n    }\n    $m\
    \ = $z * $r + $m;\n\n    return $m; // return m\n}\n", "    // Leave this implementation\
    \ as a reference - it will be correct.\n    $n = abs($n);\n    $highest = 2; \n\
    \    $factor = 2; \n    while($n >= $highest) { \n        if($n % $factor == 0)\n\
    \            $highest = $factor; \n        else\n            $factor++; \n   \
    \ } \n    return $factor; \n}\n", "    if ($n == 1)\n        return 1;\n    $i\
    \ = 2;\n    do {\n        while ($n % $i == 0)\n            $i++;\n        $n\
    \ = $i << 1;\n    } while (!($n % 2));\n    return $n;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=php,math |>\nI know this is a late answer, but I had the same\
    \ problem (although my code was in javascript) and I came up with this solution:\n\
    <code>", "  $i = 2;\n  while (true) {\n    if ($n % $i == 0) {\n      $m = $i;\n\
    \      $x = $n / $i;\n      while ($x * $x != $n) {\n        $x++;\n        $m++;\n\
    \      }\n      if ($m == $i) {\n        return $x;\n      }\n    }\n    $i++;\n\
    \  }\n}\n", "    $max = $n;\n    $factor = 2;\n    $found = false;\n    while\
    \ ($max > 1) {\n        if ($n % $factor == 0) {\n            $found = true;\n\
    \            $max = $max / $factor;\n        } else {\n            $factor++;\n\
    \        }\n    }\n    if ($found == false) {\n        return $max;\n    } else\
    \ {\n        return $factor;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    It is not the optimal solution. For example, if the input is the number 12, it\
    \ returns 1 as there is no factor larger than 1. But the largest factor of 12\
    \ is 8. As 8 is not prime but a factor of it.\n<|/ c |>\n<| c |>\nIt's not an\
    \ optimal solution, it's just an easy one - which is what he asked for.  Also,\
    \ the question is asking for \"the largest prime factor\", which means (as you\
    \ point out) there's no reason to return 1. As I pointed out above, 8 is not prime\
    \ but a factor of it.\n<|/ c |>\n<| a |>\n<code>\n<?php", "  $nfactors = array(2);\
    \ // Any prime greater than 2\n  for ($i = 3; $i <= $n; ++$i) {\n    while ($n\
    \ % $i == 0) {\n      ++$nfactors[$i];\n      $n /= $i;\n    }\n  }\n  if ($n\
    \ > 2) {\n    return $nfactors[$n - 1];\n  }\n  return 1;\n}", "  if ($n<2)\n\
    \    return 2;\n  $result = $n-1;\n  while ($result % $n == 0)\n    $result/=$n;\n\
    \  return $result;\n}\n", "  $i = 2;\n  $p = 1;\n  while ($i * $i <= $n) {\n \
    \   if ($n % $i == 0) {\n      $p++;\n    }\n    $i += $i;\n  }\n  return $p;\n\
    }\n", "  if ($n <= 1) return $n;\n  if ($n % 2 == 0) return $n * largest_prime_factor(floor($n\
    \ / 2));\n  $m = $n;\n  for ($i = 2; $i * $i <= $m; $i *= 2) while ($m % $i ==\
    \ 0);\n  return $m;\n}\n", "    // Get a list of all prime factors of n.\n   \
    \ $factors = array_filter(range(1, $n), function($num){ return !is_prime($num);\
    \ });\n    sort($factors);\n    \n    return $factors[count($factors)-1];\n}\n",
  "    $max_factor = 2;\n    $max_factor = 2;\n    for ($i = 3; $i <= $n; $i++) {\n\
    \        if ($n % $i == 0) {\n            while ($n % $i == 0) {\n           \
    \     $max_factor++;\n                $n /= $i;\n            }\n        }\n  \
    \  }\n    return $max_factor;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    <code>", "    if ($n<2) {\n        return 1;\n    }\n    \n    for ($i = 2; $i<$n;\
    \ $i++) {\n        if ($n % $i == 0) {\n            return $i;\n        }\n  \
    \  }\n    return $n;\n}\n", "  $n = abs($n);\n  $t = $n->copy();\n  $factor =\
    \ 1;\n  $p = 0;\n  while ($t->is_prime()) {\n    $t = $t->copy();\n    if ($t->is_prime())\
    \ {\n      $p++;\n    } else {\n      if ($p == 0) {\n        $factor = $t->copy();\n\
    \        $factor->is_prime(false);\n      } else {\n        $t->is_prime(false);\n\
    \      }\n    }\n  }\n  return $factor;\n}\n", "    $n2 = $n * $n;\n    $np1 =\
    \ $n2 + 1;\n    while (!is_prime($np1)) {\n        $np1 = $n2 + 1;\n        $n2\
    \ = $np1 * $n;\n    }\n    return $np1;\n}\n", "    $f = 2;\n    while(!is_prime($n))\
    \ {\n        $f += 2;\n        $n = ($n % $f) / $f;\n    }\n    return $f;\n}\n",
  "    $i = 2; $f = 2; $k = 2; while ($i <= $n) {\n        if ($n % $i == 0) { $f\
    \ = $i; break; }\n        while ($n % $k == 0) { $k++; }\n        $i++;\n    }\n\
    \    return $f;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n+1. For `largest_prime_factor`\
    \ function I used this one: `$i = 2; $f = 2; $k = 2; while ($i <= $n) {if ($n\
    \ % $i == 0) { $f = $i; break; } while ($n % $k == 0) { $k++; }}`\n<|/ c |>\n\
    <| a tags=primes,php,algorithm |>\nI believe this question is a duplicate of finding-the-highest-prime-factor\n\
    The accepted answer has a very clever algorithm that has a very simple implementation\
    \ written in Python.\n<code>\ndef largest_prime_factor(x):\n    '''\n    Find\
    \ the largest prime factor of x\n    using trial division.\n    '''\n    if x\
    \ > 1:\n        for i in range(2, int(math.sqrt(x)) + 1):\n            if x %\
    \ i == 0:\n                return i\n    return 1\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is indeed a great algorithm if you use python. Unfortunately the\
    \ OP asked for PHP :)\n<|/ c |>\n<| a |>\nI came up with this PHP function based\
    \ on other answers, but without using a loop.\n<code>", "    $result = 2;\n  \
    \  for($factor = 2; $factor <= $n; $factor++) {\n        if($n % $factor == 0)\
    \ {\n            $result = $factor;\n        }\n    }\n    return $result;\n}",
  "    $n = $n - 1;\n    while($n%2 == 0 && $n != 1){\n        $n/=2;\n    }\n   \
    \ if($n == 1)\n        return 2;\n    for($x = 2; $x < $n; $x += 2){\n       \
    \ if($n%$x == 0)\n            return $x;\n    }\n    return 1;\n}\n", "    $n\
    \ = abs($n);\n    $n_2 = $n * 2;\n    $n_4 = $n_2 * 4;\n    $n_6 = $n_4 * 6;\n\
    \    $n_8 = $n_6 * 8;\n    $n_12 = $n_8 * 12;\n    $n_16 = $n_12 * 16;\n    $n_20\
    \ = $n_16 * 20;\n    $n_24 = $n_20 * 24;\n    $n_30 = $n_24 * 30;\n    if ($n_12\
    \ <= $n) {\n        return $n_12;\n    } else if ($n_6 <= $n) {\n        return\
    \ $n_6;\n    } else if ($n_4 <= $n) {\n        return $n_4;\n    } else if ($n_2\
    \ <= $n) {\n        return $n_2;\n    } else if ($n_8 <= $n) {\n        return\
    \ $n_8;\n    } else if ($n_4 <= $n) {\n        return $n_4;\n    } else if ($n_6\
    \ <= $n) {\n        return $n_6;\n    } else if ($n_8 <= $n) {\n        return\
    \ $n_8;\n    } else if ($n_12 <= $n) {\n        return $n_12;\n    } else if ($n_16\
    \ <= $n) {\n        return $n_16;\n    } else if ($n_20 <= $n) {\n        return\
    \ $n_20;\n    } else if ($n_24 <= $n) {\n        return $n_24;\n    } else if\
    \ ($n_30 <= $n) {\n        return $n_30;\n    } else if ($n <= 1) {\n        return\
    \ $n;\n    }\n}\n</code>\n<|/ a dscore=1 tags=php |>\n<| c |>\nYou should use\
    \ Big Integer instead of int to calculate those values\n<|/ c |>\n<| c |>\nHe\
    \ will still need to cast the results to int for the return though.\n<|/ c |>\n\
    <| c |>\n: It will still be a BigInt or something implementing the `__int__` magic\
    \ method.\n<|/ c |>\n<| c |>\nYeah I know, I was just saying that the answer was\
    \ not completely right. I meant that it needs a cast in the return to int.\n<|/\
    \ c |>\n<| c |>\nThe point is that `int` will work for large numbers, but `bigint`\
    \ won't.\n<|/ c |>\n<| a tags=php |>\n<code>", "  $n = abs($n);\n  $result = 1;\n\
    \  $i = 3;\n  while ($i <= sqrt($n)) {\n    while ($n % $i == 0) {\n      $result\
    \ *= $i;\n      $n /= $i;\n    }\n    $i++;\n  }\n  return $result;\n}\n", " \
    \   static $cache, $sieve;\n\n    if (!isset($sieve)) {\n        $sieve = range(3,\
    \ (int) ($sqrt(($n + 1) / 2)), -1);\n        sort($sieve);\n    }\n\n    // check\
    \ for small factors first\n    for ($i = 2; $i < $n; $i++) {\n        if ($sieve[$i]\
    \ <= 1) {\n            continue;\n        }\n\n        if ($n % $i == 0) {\n \
    \           return $i;\n        }\n\n        $n = $n / $i;\n    }\n\n    // check\
    \ for double factors (smaller than the prime factor)\n    $m = $sieve[count($sieve)\
    \ - 1];\n    for ($i = 2; $i <= $m; $i++) {\n        if ($sieve[$i] <= 1) {\n\
    \            continue;\n        }\n\n        $m = $m / $i;\n\n        if ($n %\
    \ $i == 0) {\n            return $i;\n        }\n    }\n\n    // finally, look\
    \ for all composite numbers\n    for ($i = 2; $i <= $n; $i++) {\n        if ($sieve[$i]\
    \ <= 1) {\n            continue;\n        }\n\n        if ($n % $i == 0) {\n \
    \           return $i;\n        }\n\n        $t = $sieve[($i - 1) * $i] + 1;\n\
    \        if ($t % $i == 0) {\n            return $i;\n        }\n\n        $m\
    \ = $i - ($n / $i);\n        if ($m % $i == 0) {\n            return $i;\n   \
    \     }\n    }\n}\n", "    $n = abs($n);\n    $prime = 2;\n    $x = $n;\n    while(!is_prime($x))\
    \ {\n        if($x % $prime == 0) {\n            return $prime;\n        }\n \
    \       $x++;\n        $prime += 2;\n    }\n    return $prime;\n}\n</code>\n<|/\
    \ a tags=python,php,primes |>\n<| c |>\nThe code does not work for **n = 2**,\
    \ it returns  ```2```\n<|/ c |>\n<| c |>\nI have edited my answer to show a way\
    \ to find that value with PHP. Of course, if you don't understand how it works,\
    \ then you probably shouldn't use it.\n<|/ c |>\n<| a tags=python,php,primes |>\n\
    I wrote this in PHP for finding the largest prime factor of a number with some\
    \ help, but you can do this in Python as well. It will find the largest prime\
    \ factor of any number given to the function (I tested up to 10^15 - the largest\
    \ prime factor of 11).\n<code>", "  $a = $b = $n = $n->copy();\n  for ($i = 0;\
    \ $i <= $n; $i++) {\n    if ($n % $i == 0) {\n      $n->square();\n      if ($n->compare($a)\
    \ > 0 || $n->compare($b) > 0) {\n        $a = $n;\n      }\n      $n = $n->divide($i);\n\
    \    }\n  }\n  return $n->compare($a) > 0 ? $a : $b;\n}", "    $i = 2;\n    while(true)\
    \ {\n        if(!($n % $i)) {\n            $i = $i * 2;\n        } else {\n  \
    \          $n = $n / $i;\n        }\n        if($i !== 2) {\n            break;\n\
    \        }\n    }\n    return $i;\n}\n", "  if ($n <= 1) return 1;\n  $m = $n->modPrime(2);\n\
    \  if ($m->compare(2) == 0) {\n    return $m->random(2);\n  }\n  if ($m->compare(2)\
    \ == -1) {\n    $m = $m->divPrime(2);\n    if ($m->compare(2) == -1) {\n     \
    \ return $m->random(2);\n    }\n  }\n  return 2;\n}\n", "  $is_prime = ($n ==\
    \ 1) || ($n == 2);\n  $i = 1;\n  $max = $n;\n  while (!($is_prime & ($n % $i)))\
    \ {\n    $i++;\n  }\n  if ($i < $max) {\n    $i++;\n  }\n  return $i;\n}", " \
    \   if ($n < 2) {\n        return 1;\n    }\n    // See http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \    $test = 2;\n    do {\n        $prime = 2;\n        while ($test * $prime\
    \ < $n) {\n            $prime++;\n        }\n        if ($prime > sqrt($n)) {\n\
    \            return $prime;\n        }\n        $test++;\n    } while ($n > 1);\n\
    \    return 1;\n}\n", "    $n = abs($n);\n    $t = sqrt($n);\n    $f = 1;\n  \
    \  do {\n        $f++;\n        while ($t % $f == 0) {\n            $t /= $f;\n\
    \        }\n    } while ($t != 1);\n    return $f;\n}", "    if ($n < 3)\n   \
    \     return $n;\n    $max_factor = 1;\n    $smallest_factor = 2;\n    foreach\
    \ (range(1, $n) as $factor) {\n        if ($n % $factor == 0) {\n            if\
    \ ($factor > $max_factor) {\n                $max_factor = $factor;\n        \
    \    } else {\n                $smallest_factor = $factor;\n            }\n  \
    \      }\n    }\n    return $smallest_factor;\n}\n\n$big = int(input(\"Enter a\
    \ number to be converted to a binary number:\"));\n$bit = largest_prime_factor($big);\n\
    print(\"The binary number $big, converted to a $bit base number is:\");\nprint(decbin($big));\n",
  "    $n--;\n    $i = 0;\n    while ($n != 1) {\n        $i++;\n        if ($n %\
    \ $i == 0) {\n            $n /= $i;\n        }\n    }\n    return $i;\n}", " \
    \   if ($n < 2) return 2; // by definition\n    $m = $n;\n    while ($n % $m ===\
    \ 0) {\n        $m += $m + 1; // make sure $m is odd\n    }\n    $m = $n % $m;\
    \ // $m is now the largest\n    if ($m == 1) return $m;\n    // No luck? Let the\
    \ caller try again with another $m.\n    return $n . $largest_prime_factor($m);\n\
    }\n", "    $n++; $n = $n * $n;\n    $i = 2;\n    while ($i <= sqrt($n)) {\n  \
    \      if ($n % $i == 0) {\n            $n = ($n / $i) | 0;\n            $i  =\
    \ 0;\n        } else {\n            $i++;\n        }\n    }\n    return $n;\n\
    }\n", "  $result = 0;\n\n  while ($n % 2 == 0) {\n    $n /= 2;\n    $result++;\n\
    \  }\n\n  for ($i = 3; $i <= sqrt($n); $i += 2) {\n    while ($n % $i == 0) {\n\
    \      $n /= $i;\n      $result++;\n    }\n  }\n\n  return $result;\n}", "   \
    \ $i = 2; $isprime = true;\n    while ($i <= $n-1) {\n        if ($n % $i == 0)\
    \ {\n            $isprime = false;\n            break;\n        }\n        $i\
    \ += 2;\n    }\n    if ($isprime)\n        return $n;\n    else\n        return\
    \ largest_prime_factor($n-2);\n}\n\n$input = \"\n    1 4\n    1 3 1 4 2\n    2\
    \ 3 2 5 2 3 1 3 1 4 1 5 1 4 2 3 2 3 1\n    3 4 1 2 1 2 1 2 1 3 1\n\";\n\n$pattern\
    \ = \"/^\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+$/\";\n\n$matches = array();\n\npreg_match($pattern,\
    \ $input, $matches);\n\nvar_dump($matches);\n", "  $result = $n;\n  $i = 2;\n\
    \  while (true) {\n    ++$result;\n    if ($result % $i == 0) {\n      if ($result\
    \ > 2) {\n        return $result;\n      }\n      $result--;\n    }\n    ++$i;\n\
    \  }\n}\n", "    $result = 2;\n    $p = 5;\n    while ($p * $p <= $n) {\n    \
    \    if ($n % $p == 0) {\n            $result *= $p;\n        }\n        $p +=\
    \ 6;\n    }\n    return $result;\n}\n", "    // https://gist.github.com/ShirtlessKirk/2134376\n\
    \    if ($n < 2) {\n        return $n;\n    }\n    // If the number is even, then\
    \ it has two factors: 1 and itself.\n    if ($n % 2 == 0) {\n        return 2;\n\
    \    }\n    // Divide n by 2 to get the largest factor of n\n    if ($n % 2 ==\
    \ 1) {\n        return largest_prime_factor($n / 2);\n    }\n    // If we haven't\
    \ returned yet and we haven't found a factor, then\n    // our number is very\
    \ small (it is smaller than the smallest prime\n    // factor of any smaller prime).\n\
    \    //\n    // If we haven't found a factor for half the number, then our number\n\
    \    // is very small, and half is no factor.\n    if ($factor_count[$n] == 0)\
    \ {\n        return $n / 2;\n    }\n    // If we found a factor for half the number,\
    \ then our number is\n    // smaller than the smallest prime factor of any smaller\
    \ prime.\n    if ($factor_count[$n] == 1) {\n        return $n;\n    }\n    //\
    \ If we already know the smallest prime factor of any smaller prime,\n    // then\
    \ we can skip the search for a factor of the number.\n    $smallest_pf = $smallest_pf[$smallest_pf[$n]\
    \ >> 5] >> ($smallest_pf[$n] & 31) << 1;\n    // Try multiplying n by that smallest\
    \ prime factor.\n    $res = $smallest_pf[$n] * largest_prime_factor($smallest_pf[$smallest_pf[$n]\
    \ >> 5]);\n    // If a factor is found, return it.\n    if ($res != 0) {\n   \
    \     return $res;\n    }\n    // If we haven't found a factor, then the smallest\
    \ prime factor of\n    // any smaller prime is probably larger than n.  That's\
    \ why\n    // we haven't found a factor for the larger number; it's not\n    //\
    \ smaller than any smaller prime factor of any smaller prime.\n    //\n    //\
    \ This only works for odd numbers; for evens, we would have found a\n    // factor\
    \ by now, so we would have had to search for a factor of 2.\n    if ($n % 2 ==\
    \ 1) {\n        return $n / 2;\n    }\n}", "  $f = 1;\n  $n2 = $n - 1;\n  while\
    \ ($n2 !== 0) {\n    $m = $n2 >> 1;\n    $f = $f + $m + 1; \n    $n2 = $n2 - ($m\
    \ << 1);\n  }\n  return $f;\n}\n", "    if ($n < 2) return $n;\n    $f = 2; $n--;\n\
    \    while ($n % $f == 0) {\n        $f *= $f;\n        --$n;\n    }\n    return\
    \ $f;\n}\n", "    \n    if ($n < 2) {\n        return 1;\n    }\n\n    $largest\
    \ = 2;\n    $next_largest = 2 << (int)(log($n) / log(2));\n    \n    while ($next_largest\
    \ <= $n) {\n        $factor = $next_largest;\n        $n = ($n - $factor) / 2;\n\
    \        $next_largest = 2 << (int)(log($n) / log(2));\n        $largest++;\n\
    \    }\n\n    return $largest;\n}\n</code>\n<|/ a dscore=2 tags=primes,php |>\n\
    <| a tags=primes,php |>\nHere is a very fast and simple code that uses sieve of\
    \ eratosthenes algorithm in C for finding prime numbers:\n<code>", "    $n = abs($n);\n\
    \    if ($n <= 1)\n        return $n;\n\n    // See \"Integer Factorization Using\
    \ Sieve of Eratosthenes\" by W. Kahan and G.A. Ceder\n    // http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5718\n\
    \    $m = $n - 1;\n    $m2 = ($n >> 1) + ($n & 1);\n    $a = 2;\n    $b = sqrt($n);\n\
    \n    while ($b <= $m) {\n        $c = (($b & 1) == 1);\n        $d = (($b & 2)\
    \ != ($c & 1)) ? sqrt($n) : (($b & 1) == 1);\n        $m = $m2;\n        $m2 =\
    \ $b;\n\n        while ($d <= $m) {\n            $n = $a;\n            $a++;\n\
    \            $b = $c ? $b : $d;\n            $c = (($b & 1) == 1);\n         \
    \   $d = (($b & 2) != ($c & 1)) ? sqrt($n) : (($b & 1) == 1);\n            $m\
    \ = $m2;\n            $m2 = $b;\n            $n++;\n        }\n\n        if ($m\
    \ != $m2)\n            $b = $d;\n        $m2 = $m;\n    }\n\n    return $a;\n\
    }\n", "  if ($n < 2) {\n    return $n;\n  }\n  // Make sure n is odd to avoid\
    \ an infinite loop.\n  $n = $n - 2;\n  // Factor n-1 to n+2 by doubling then tripling,\
    \ starting from 3.\n  for ($i = 3; $i * $i + $n < $n; $i += 2) {\n    $n = ($n\
    \ * $i) % $n;\n  }\n  return $n;\n}\n\n/**\n * Tests a number to see if it is\
    \ prime.\n *\n * @param int $number Number to test.\n * @return bool Prime number\
    \ if $number is prime, false otherwise.\n */", "  $n = intval($n);\n  $is_prime\
    \ = ($n !== 2 && $n !== 3);\n  $max_factor = 2;\n  for ($i = 3; $i <= $n; $i++)\
    \ {\n    if ($n % $i === 0) {\n      $f = $i;\n      while ($n % $i === 0) {\n\
    \        $f = $i * $max_factor;\n        $max_factor++;\n      }\n      if ($max_factor\
    \ > $i) {\n        $is_prime = false;\n      }\n      if ($is_prime) {\n     \
    \   return $f;\n      }\n    }\n  }\n  return $max_factor;\n}\n", "  if ($n <=\
    \ 3) return $n;\n  if ($n % 2 == 0 || $n % 3 == 0) return $n % 2 == 0 ? 3 : 2;\n\
    \  $m = $n = floor(($n % 6) / 2)+1;\n  while ($n > 2) {\n    $m = $n;\n    for\
    \ ($i = 3; $i * $i <= $n; $i += 2) {\n      $n = $i * $i;\n      if ($n <= $m)\
    \ return $n;\n    }\n  }\n}\n</code>\n<|/ a |>\n<| c |>\nAh, I see what you did\
    \ there. That's more efficient than the PHP method I was using. I like how you\
    \ just did it in PHP, and I like how it solves the problem. Thanks!\n<|/ c |>\n\
    <| c |>\nI did some speed tests and this method is definitely the fastest! Thanks\
    \ so much.\n<|/ c |>\n<| a dscore=2 tags=algorithm,factorization,php,prime-factoring\
    \ |>\n<code>\n<?php", "    // http://en.wikipedia.org/wiki/Primality_test#Naive_method\n\
    \    // http://primality-test.org/wiki/Sieve_of_Eratosthenes\n    $sieve_of_eratosthenes\
    \ = array();\n    $primes_not_found = 0;\n\n    $m = $n = $num_primes = 0;\n \
    \   while (!$num_primes || $primes_not_found != $n) {\n        ++$num_primes;\n\
    \        $m++;\n\n        if ($n % 2 == 0) {\n            $sieve_of_eratosthenes[$n]\
    \ = $n;\n            ++$num_primes;\n            $n = $n / 2;\n        } else\
    \ {\n            while (!isset($sieve_of_eratosthenes[$n])\n                &&\
    \ $m * $m <= $n\n                && $n % $m == 0) {\n                $sieve_of_eratosthenes[$n]\
    \ = $m;\n                ++$num_primes;\n                $n = $n / $m;\n     \
    \           ++$m;\n            }\n        }\n    }\n\n    $primes = $sieve_of_eratosthenes;\n\
    \    $num_primes = count($primes);\n\n    if ($num_primes == 0) {\n        return\
    \ $primes[$n];\n    } else {\n        $i = 0;\n        foreach ($primes as $prime)\
    \ {\n            if ($prime == $n) {\n                return $primes[$n];\n  \
    \          }\n            if ($i % $prime == 0) {\n                $i++;\n   \
    \         }\n        }\n    }\n\n    return $num_primes;\n}\n", "  // Sieve of\
    \ Eratosthenes from http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n  $primes\
    \ = range(3, $n, 2);\n  $factors = range(1, $n);\n  foreach ($primes as $p) {\n\
    \      foreach ($factors as $factor) {\n          if ($p % $factor === 0) {\n\
    \              unset($factors[$factor]);\n              $factors[] = $p;\n   \
    \           break;\n          }\n      }\n  }\n  sort($factors);\n  return array_pop($factors);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi Eric, I have tried your code but I\
    \ still get the same error:  Fatal error: Call to a member function filter() on\
    \ a non-object in\n<|/ c |>\n<| c |>\nYes I have, I am not sure what is wrong\
    \ with my code. I thought the problem was with the $n variable, but when I use\
    \ your number I get the same error.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n<?php\n",
  "    $nToThePower = $n;\n    $result = $n;\n    $i = 2;\n    while($i <= $nToThePower)\
    \ {\n        if($n % $i == 0) {\n            $nToThePower = $nToThePower * $i;\n\
    \            $result = $result;\n        }\n        $i++;\n    }\n    if($n >\
    \ 2) {\n        $nToThePower = $nToThePower / $result;\n    }\n    return $result;\n\
    }\n", "    if ($n < 2) {\n        return 1;\n    }\n    if ($n == 2 || $n == 3)\
    \ {\n        return $n;\n    }\n    $i = 2;\n    $max = 0;\n    while ($i <= sqrt($n))\
    \ {\n        if ($n % $i == 0) {\n            $max = max($max, $i);\n        }\n\
    \        $i += 2;\n    }\n    return $max;\n}\n", "    if ($n == 1) {\n      \
    \  return 2;\n    }\n\n    $i = 2;\n    $factor = 2;\n\n    while ($i * $i <=\
    \ $n) {\n        while ($n % $i == 0) {\n            $factor++;\n            $n\
    \ /= $i;\n        }\n\n        $i++;\n    }\n\n    return $factor;\n}\n\n$prime_factors\
    \ = array();\n$prime_factors_count = array();\n$prime_factors_counts = array();\n\
    $prime_factors_table = array();\n$prime_factors_table_temp = array();\n$prime_factors_count\
    \ = array();\n$prime_factors_counts = array();\n$prime_factors_table = array();\n\
    $prime_factors_table_temp = array();\n$prime_factors_count = array();\n$prime_factors_counts\
    \ = array();\n$prime_factors_table = array();\n$prime_factors_table_temp = array();\n\
    $prime_factors_count = array();\n$prime_factors_counts = array();\n$prime_factors_table\
    \ = array();\n$prime_factors_table_temp = array();\n$prime_factors_count = array();\n\
    $prime_factors_counts = array();\n$prime_factors_table = array();\n$prime_factors_table_temp\
    \ = array();\n$prime_factors_count = array();\n$prime_factors_counts = array();\n\
    $prime_factors_table = array();\n$prime_factors_table_temp = array();\n$prime_factors_count\
    \ = array();\n$prime_factors_counts = array();\n$prime_factors_table = array();\n\
    $prime_factors_table_temp = array();\n$prime_factors_count = array();\n$prime_factors_counts\
    \ = array();\n$prime_factors_table = array();\n$prime_factors_table_temp = array();\n\
    $prime_factors_count = array();\n$prime_factors_counts = array();\n$prime_factors_table\
    \ = array();\n$prime_factors_table_temp = array();\n$prime_factors_count = array();\n\
    $prime_factors_counts = array();\n$prime_factors_table = array();\n$prime_factors_table_temp\
    \ = array();\n$prime_factors_count = array();\n$prime_factors_counts = array();\n\
    $prime_factors_table = array();\n$prime_factors_table_temp = array();\n$prime_factors_count\
    \ = array();\n$prime_factors_counts = array();\n$prime_factors_table = array();\n\
    $prime_factors_table_temp = array();\n$prime_factors_count = array();\n$prime_factors_counts\
    \ = array();\n$prime_factors_table = array();\n$prime_factors_table_temp = array();\n\
    $prime_factors_count = array();\n$prime_factors_counts = array();\n$prime", " \
    \   if ($n < 2) {\n        return $n;\n    }\n    $i = 0;\n    while ($n % $i\
    \ == 0) {\n        $i++;\n    }\n    while ($n % $i == 0) {\n        $n = $n /\
    \ $i;\n        $i++;\n    }\n    return $n;\n}\n", "  if ($n <= 1) {\n    return\
    \ $n;\n  }\n  $factor = 2;\n  for ($i=3; $i*$i <= $n; $i++) {\n    if ($n % $i\
    \ == 0) {\n      $factor = $i;\n      break;\n    }\n  }\n  return $factor;\n\
    }\n", "    $largestPrimeFactor = null;\n    for($x = 2; $x < $n; $x++) {\n   \
    \     $lastPrimeFactor = floor(sqrt($x));\n        if ($lastPrimeFactor * $lastPrimeFactor\
    \ > $x) {\n            $largestPrimeFactor = $lastPrimeFactor;\n        }\n  \
    \  }\n    return $largestPrimeFactor;\n}\n", "\tif ($n == 1) {\n\t\treturn 2;\n\
    \t}\n\n\t$factor = 2;\n\tfor ($i = 2; $i <= ceil(log($n, 2)); $i++) {\n\t\tif\
    \ (($n % $i) == 0) {\n\t\t\t$n = $n / $i;\n\t\t\t$factor = $i + 1;\n\t\t}\n\t\
    }\n\treturn $factor;\n}", "    if ($n<2) { return 1; }\n    // http://prismatic.com/prime-factors-and-the-longest-prime-factor-of-each-prime-factor-of-an-integer/\n\
    \    $candidates = range(2,$n);\n    sort($candidates);\n    foreach($candidates\
    \ as $i) { if ($n % $i == 0) { return $i; }}\n    return $n;\n}", "    if ($n\
    \ < 2) {\n        return 1;\n    }\n    $m = $n; //starts at n\n    $a = 2; //starts\
    \ at 2\n    $b = 2; //starts at 2\n    while ($a <= $m) {\n        $c = 1;\n \
    \       for ($i = 0; $i <= $m; $i++) {\n            $c = $c * ($i + 1);\n    \
    \    }\n        if ($a == $n) {\n            return $b;\n        }\n        $b\
    \ = ($a + $b) / 2;\n        $a = $b;\n    }\n    return 1;\n}", "  if ($n<=1)\n\
    \    return 1;\n  else if ($n%2==0 || $n%3==0 || $n%5==0)\n    return $n;\n  $m\
    \ = $n%6;\n  while ($m!=1) {\n    if ($m%2==0 || $m%3==0 || $m%5==0)\n      return\
    \ $m;\n    $m = $m%6;\n  }\n  return $n;\n}\n", "    if ($n == 1) return 2;\n\
    \    if ($n % 2 == 0) return $n; // n is even\n    $root = $n; // 2\n    $p =\
    \ 2;\n    while (true) {\n        $p++;\n        if ($n % $p == 0) {\n       \
    \     $root = $p;\n            break;\n        }\n    }\n    // Check $p because\
    \ it's guaranteed to not have been\n    // reduced below 1.\n    if ($n % $p ==\
    \ 0) {\n        return $p;\n    }\n    else return $root;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is very slow for large numbers. A `while` loop would probably\
    \ be better.\n<|/ c |>\n<| c |>\n: Yes, that's why I pointed it out. But, of course,\
    \ for such a simple problem, `while` might be better than `for`.\n<|/ c |>\n<|\
    \ c |>\nWell, actually I didn't get what you meant by `while` being better. Of\
    \ course it is better than `for` loop in every way. But the main point here is\
    \ efficiency. Also, for such a simple problem a `while` loop would certainly be\
    \ better than a `for` loop.\n<|/ c |>\n<| c |>\n: Yes, you're right. I meant `for`\
    \ loop. My mistake.\n<|/ c |>\n<| c |>\nThe algorithm is O(sqrt(n)) and not O(n).\
    \ For larger values it becomes less efficient.\n<|/ c |>\n<| a dscore=0 tags=php,math,primes,algorithm\
    \ |>\nI found a solution for my problem:\n<code>\n<?php", "  $nfactors = range(3,\
    \ $n+1, 2);\n  $product = 1;\n  foreach ($nfactors as $factor) {\n    $test =\
    \ $product * $factor;\n    if ($test < $n) {\n      $product = $test;\n    }\n\
    \  }\n  return $product;\n}\n", "    if ($n <= 1)\n        return $n;\n    $i\
    \ = $a = $n->integer($n);\n    while ($a) {\n        $b = $n->gcd($i);\n     \
    \   if ($b) {\n            $i = $b;\n        } elseif (--$i && $i->equals($n->integer($i)))\
    \ {\n            $a = $i;\n        }\n    }\n    return $n ? $i : 1;\n}\n", " \
    \   // Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ \n    // to find primes less than or equal to a given number\n    $sieve = array(\n\
    \        2 => 2,\n        3 => 3,\n        4 => 2,\n        5 => 5,\n        6\
    \ => 7,\n        7 => 11,\n        8 => 5,\n        9 => 11,\n        10 => 13,\n\
    \        11 => 17,\n        12 => 19,\n        13 => 23,\n        14 => 29,\n\
    \        15 => 31,\n        16 => 39,\n        17 => 41,\n        18 => 59,\n\
    \        19 => 61,\n        20 => 67,\n        21 => 71,\n        22 => 73,\n\
    \        23 => 79,\n        24 => 83,\n        25 => 89,\n        26 => 97,\n\
    \        27 => 101,\n        28 => 103,\n        29 => 107,\n        30 => 113,\n\
    \        31 => 117,\n        32 => 127,\n        33 => 131,\n        34 => 137,\n\
    \        35 => 139,\n        36 => 149,\n        37 => 151,\n        38 => 157,\n\
    \        39 => 163,\n        40 => 167,\n        41 => 173,\n        42 => 179,\n\
    \        43 => 181,\n        44 => 191,\n        45 => 193,\n        46 => 197,\n\
    \        47 => 199,\n        48 => 211,\n        49 => 223,\n        50 => 227,\n\
    \        51 => 229,\n        52 => 233,\n        53 => 239,\n        54 => 241,\n\
    \        55 => 243,\n        56 => 247,\n        57 => 251,\n        58 => 253,\n\
    \        59 => 257,\n        60 => 263,\n        61 => 269,\n        62 => 271,\n\
    \        63 => 277,\n        64 => 281,\n        65 => 283,\n        66 => 293,\n\
    \        67 => 297,\n        68 => 311,\n        69 => 313,\n        70 => 317,\n\
    \        71 => 331,\n        72 => 337,\n        73 => 347,\n        74 => 349,\n\
    \        75 => 353,\n        76 => 359,\n        77 => 367,", "  $factors = array();\n\
    \  $n++;\n  for ($i = 1; $i <= $n; $i++) {\n    $test = floor($n / $i);\n    if\
    \ ($test == $n / $i) {\n      // prime!\n      $factors[] = $i;\n    } else if\
    \ ($test > $n) {\n      // not a prime!\n      break;\n    } else {\n      //\
    \ test > n but no primes <= n / i\n      // test > n / i (prime) and i > n/i (not\
    \ prime)\n      // test <= n/i\n      // i > n/i and test > n / i (not prime)\n\
    \      // i == 1\n      // i == 2\n      // i == 3\n      // i == 5\n      //\
    \ i == 8\n      // ...\n      break;\n    }\n  }\n  if (count($factors) > 0) {\n\
    \    return max($factors);\n  } else {\n    return 1;\n  }\n}\n</code>\n<|/ a\
    \ tags=php,primes |>\n<| c |>\nYes, it is. I got this from Wikipedia :)\n<|/ c\
    \ |>\n<| c |>\nOh sorry. I didn't realize it was a PHP function. I'll edit the\
    \ code.\n<|/ c |>\n<| c |>\nI guess it's just me but I dont think any of those\
    \ numbers exist in PHP\n<|/ c |>\n<| c |>\nYeah, I guess so. No idea why they\
    \ aren't there, but this should work for most cases.\n<|/ c |>\n<| c |>\n: Your\
    \ code will not work for 7 or 9 since they will never get marked as prime. Your\
    \ code works only for small primes.\n<|/ c |>\n<| a |>\n<code>\n<?php\n", "  \
    \  if ($n < 2) {\n        return $n;\n    }\n\n    $n = $n - 1;\n    $i = 2;\n\
    \    $max_number = $n;\n\n    // Store the result of the trial division so we\
    \ can use it in the while loop\n    $result = $n;\n\n    while (true) {\n    \
    \    // Find the next highest factor of the number, and divide by it.\n      \
    \  $next_highest_factor = 2;\n        while ($i <= $n && $next_highest_factor\
    \ <= $max_number) {\n            $next_highest_factor *= $i;\n            $i++;\n\
    \        }\n\n        // If there's no factors left to trial the number, we're\
    \ done.\n        if ($i > $n) {\n            break;\n        }\n\n        // Trial\
    \ factors of 2 are by definition prime, thus we know that the\n        // number\
    \ must be composite and larger than 1.\n        if ($next_highest_factor == 2)\
    \ {\n            $result++;\n        }\n\n        // Test to see if the current\
    \ number is prime.\n        if ($i == $n) {\n            break;\n        }\n\n\
    \        // If it is, then this factor is the largest factor so far found so far\
    \ and\n        // we can break out of the loop.\n        if ($i % $i == 0) {\n\
    \            $max_number = $i;\n        }\n\n        // Only factors smaller than\
    \ the square root can possibly be prime\n        if ($i <= sqrt($n)) {\n     \
    \       $result++;\n        }\n    }\n\n    return $result;\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=java,php |>\nMy solution in PHP for nth number factorization:\n\
    <code>\n<?php\n", "  if ($n < 2) {\n    return 1;\n  }\n  if ($n <= 3) {\n   \
    \ return $n;\n  }\n\n  $max_factor = 1;\n  for ($i = 2; $i <= ceil(sqrt($n));\
    \ ++$i) {\n    // Largest prime factor of $n is less than or equal to $max_factor.\n\
    \    if ($n % $i == 0) {\n      $max_factor = $i;\n      break;\n    }\n  }\n\
    \  return $max_factor;\n}\n", "  // Limit to six-digit numbers.\n  $n = min($n,\
    \ PHP_INT_MAX);\n  $x = range(2, $n + 1);\n\n  // First primality test. Test all\
    \ odd composites up to sqrt(n).\n  // Trial division is only concluded if it leaves\
    \ at least one prime factor.\n  $y = array_map('intdiv', $x, $n);\n  foreach ($x\
    \ as $k) {\n    if (count($y) == 1 || !isset($y[$k - 1])) {\n      return $k;\n\
    \    }\n  }\n\n  // Second primality test. There are several possible n and n+1\n\
    \  // such that n and n+1 are both composite numbers. Since n is odd\n  // and\
    \ n-1 is even, only one of the possible n+1 is a prime.\n  $a = $n = $n + 1; //\
    \ Start with n and n+1.\n  do {\n    $x = range(2, $a + 1);\n    $y = array_map('intdiv',\
    \ $x, $n);\n    if ($y != array(0)) { $n = $a; break; }\n    $a = $a + 2; // Step\
    \ over multiples of 2.\n  } while ($a <= $n);\n\n  return $n == $n ? $n : $n +\
    \ 1;\n}\n\n\n/**\n * Generates a random string of specified length which contains\
    \ only alphabetic and\n * digits. Used for passwords or other forms of encryption.\n\
    \ *\n * @param int $len Length of string to return.\n * @return string Random\
    \ string of the specified length.\n * @throws \\InvalidArgumentException If string\
    \ length is less than 1.\n */", "    if ($n <= 1) {\n        return 1;\n    }\n\
    \    $i = 0;\n    do {\n        if ($n % $i == 0) {\n            return $i;\n\
    \        }\n        $i = $i + 1;\n    } while (is_prime($n));\n    return $n;\n\
    }\n", "    $max = 1;\n    $i = 2; // = 2\n    while ($i <= sqrt($n)) {\n     \
    \   if (isPrime($n) && $n >= $max) {\n            $max = $i;\n        }\n    \
    \    $i++;\n    }\n    return $max;\n}\n", "    $prime_factors = array(2=>1,3=>2);\n\
    \    for($i=3;$i<$n;$i++) {\n        if($n % $i == 0) {\n            while($n\
    \ % $i == 0) {\n                $prime_factors[++$i] = $i;\n                $n\
    \ /= $i;\n            }\n        }\n    }\n    return $prime_factors[$n];\n}",
  "    $is_prime = array(2);\n    for($i = 3; $i <= $n/2; $i++) {\n        if($n %\
    \ $i == 0) {\n            $is_prime[] = $i;\n            if ($n % ($i * $i) ==\
    \ 0) {\n                break;\n            }\n        }\n    }\n    if ($n >\
    \ 1 && $n != $is_prime[0]) {\n        return $is_prime[0];\n    } else {\n   \
    \     return count($is_prime);\n    }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This is not an answer. Just another way how you can optimize your code and make\
    \ it faster\n<|/ c |>\n<| c |>\nSorry for that, I updated the answer with a working\
    \ code.\n<|/ c |>\n<| c |>\n`if($n % ($i * $i) == 0) { return $i; }` can be replaced\
    \ by `if($n % $i == 0) { return $i; }`\n<|/ c |>\n<| a tags=algorithm,php,primes\
    \ |>\nI agree with user366699 that the algorithm is incorrect. I've implemented\
    \ an algorithm that checks the factors in sequence. It finds the first factor\
    \ bigger than the product of the given number and itself. \nHere's a PHP code\
    \ that returns the biggest prime factor of a given number:\n<code>", "  $a = intval(sqrt($n));\n\
    \  for ($i = 2; $i <= $a; $i++) {\n    if ($n % $i == 0) {\n      $b = intval($i\
    \ / $n);\n      return $b <= $a ? $b : $a;\n    }\n  }\n  return 1;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nHi I used your answer and made a few changes due to\
    \ my specific needs. I used `sqrt($n)` instead of `$n`, also I only used `$n`\
    \ once and used it everywhere. I also added a base case to return 1 if the value\
    \ passed is 0 (I didn't want to have to do if($n==0)), here is the final code\
    \ `<?php", "  $result = 1;\n  $factor = 2;\n  while (!is_prime($n)) {\n    $result\
    \ = $factor;\n    $factor++;\n    $n *= $factor;\n  }\n  return $result;\n}",
  "  if ($n == 2)\n    return 3;\n\n  $num_factors = $n; // Store the factor count\
    \ for n > 2\n  while ($num_factors % 2 == 0) {\n    $num_factors /= 2;\n  }\n\
    \  $factor = 2;\n  while ($num_factors % $factor == 0) {\n    $num_factors /=\
    \ $factor;\n    $factor++;\n  }\n  return $factor;\n}", "  $i = 2; $p = 0; $p_found\
    \ = false; $limit = min($n, intval($n / 2)); while ($i <= $limit && !$p_found)\
    \ {\n    $p++;\n    $p_found = !($n % $i);\n    $i++;\n  }\n  return $p > 1 ?\
    \ $p : false;\n}\n</code>\n<|/ a |>\n<| a |>\nI wrote this little routine to find\
    \ prime numbers in python, but I'm not sure it really works correctly:\n<code>\n\
    def isPrime(n):\n    for x in range(2, n):\n        if n % x == 0:\n         \
    \   return False\n    return True\n</code>\nThis is how I tested it out in python:\n\
    <code>\n>>> isPrime(6)\nTrue\n>>> isPrime(11)\nFalse\n>>> isPrime(12)\nFalse\n\
    >>> isPrime(13)\nFalse\n</code>\n<|/ a dscore=2 tags=primes,php,sieve-of-eratosthenes\
    \ |>\n<| a dscore=2 |>\n<code>", "    $factor = 2;\n    for($i = 3; $i <= sqrt($n);\
    \ $i += 2) {\n        if($n % $i == 0) {\n            $factor = $i;\n        }\n\
    \    }\n    return $factor;\n}\n</code>\n<|/ a dscore=1 tags=php |>\n<| a dscore=1\
    \ tags=php |>\nThe prime factors of 13195 are 2 and 3, as per the definition of\
    \ a prime number.\n<code>\n<?php", "    $result = $n;\n    for($i = 2; $i <= $n/2;\
    \ $i++) {\n        if($n % $i == 0) {\n            $result *= $i;\n          \
    \  $result /= $n;\n        }\n    }\n    return $result;\n}\n", "  $n = abs($n);\n\
    \  if ($n < 2)\n    return -1;\n  $sqrt_n = sqrt($n);\n  $is_prime = true;\n \
    \ for ($i = 1; $i <= ceil($sqrt_n); $i++) {\n    if ($n % $i == 0) {\n      $is_prime\
    \ = false;\n      break;\n    }\n  }\n  if ($is_prime) {\n    return $i;\n  }\
    \ else {\n    return 1;\n  }\n}\n", "  if ($n <= 3) return $n;\n  $roots = array(2);\n\
    \  for ($i = 3; $i <= sqrt($n); $i++) {\n    while ($n % $i == 0) {\n      $roots[]\
    \ = $i;\n      $n = $n / $i;\n    }\n  }\n  return $roots[count($roots) - 1];\n\
    }\n", "  $n = abs($n);\n  assert($n > 2);\n  $i = 2;\n  while ($i <= $n/2) {\n\
    \    if ($n % $i == 0) {\n      $primes[$i] = $i;\n      $n = $n/$i;\n    }\n\
    \    $i += 2;\n  }\n  return $primes[count($primes)-1];\n}", "    $test = 2;\n\
    \    $x = 2;\n    $y = 3;\n    $p = 3;\n    while ($test <= $n) {\n        if\
    \ ($n % $test === 0) {\n            $test = $x * $y;\n            $p = $x;\n \
    \           $x++;\n        } else {\n            $test++;\n        }\n\n     \
    \   if ($test > $n) break;\n\n        $y++;\n    }\n    return $y;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
