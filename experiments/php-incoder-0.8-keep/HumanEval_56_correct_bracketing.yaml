name: HumanEval_56_correct_bracketing
language: php
prompt: "<?php\n// brackets is a string of \"<\" and \">\".\n// return True if every\
  \ opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"\
  <\")\n// False\n// >>> correct_bracketing(\"<>\")\n// True\n// >>> correct_bracketing(\"\
  <<><>>\")\n// True\n// >>> correct_bracketing(\"><<>\")\n// False\nfunction correct_bracketing($brackets)\
  \ {\n"
tests: "function candidate(...$args) {\n    return correct_bracketing(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(\"<>\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"<<><>>\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"<><><<><>><>\") !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"<><><<<><><>><>><<><><<>>>\") !== true)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<<<><>>>>\") !==\
  \ false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"><<>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<<<<\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\">\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<<>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<><><<><>><>><<>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"<><><<><>><>>><>\"\
  ) !== false) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    // your code here\n    // loop through the brackets and add one\
    \ to each one found\n    for($i = 0; $i < strlen($brackets); $i++) {\n       \
    \ if($brackets[$i] == \"<\") {\n            $brackets[$i] = \"{\";\n        }\n\
    \        if($brackets[$i] == \">\") {\n            $brackets[$i] = \"}\"; \n \
    \       }\n    }\n    // if the brackets match up\n    if ($brackets == \"<>\"\
    ) {\n        return false;\n    } else {\n        return true;\n    }\n}\n", " \
    \ $openers = array_count_values(explode(\"<\", $brackets));\n  $closers = array_count_values(explode(\"\
    >\", $brackets));\n  foreach ($openers as $i => $count) {\n    if ($count == $closers[$i])\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI ran into this problem myself with a legacy database. I wrote\
    \ a script to fix it and it was pretty easy.\n<|/ c |>\n<| c |>\nI was thinking\
    \ of a script too. But how do you know what \"<<><>>\" means?\n<|/ c |>\n<| c\
    \ |>\ni used this in one my projects and it worked well for me\n<|/ c |>\n<| c\
    \ |>\nThanks, I used something similar and I wondered why it doesn't work.\n<|/\
    \ c |>\n<| c |>\nJust a note. This algorithm works only for balanced brackets,\
    \ i.e. it won't work for unbalanced ones like <(<) or <((<.\n<|/ c |>\n<| a tags=regex,php\
    \ |>\nTry something like this :\n<code>\n<?php\n$subject = \"<<><>>\";\n$pattern\
    \ = \"~<(?!(<|>))(\\w+|&\\w+;)+>~\";\nif(preg_match_all($pattern, $subject, $match))\
    \ {\n    var_dump($match);\n}", "  $open_brackets = array_keys(preg_split(\"/([<>])/\"\
    , $brackets));\n  sort($open_brackets);\n  $closed_brackets = array_keys(preg_split(\"\
    /([<>])/\", $brackets, -1, PREG_SPLIT_NO_EMPTY));\n  sort($closed_brackets);\n\
    \  return $open_brackets == $closed_brackets;\n}\n", "  $len = strlen($brackets);\n\
    \  if ($len <= 0) {\n    // empty string or not a brackets string.\n    return\
    \ false;\n  }\n  $brackets_array = array();\n  for ($i = 0; $i < $len; ++$i) {\n\
    \    $brackets_array[] = substr($brackets, $i, 1);\n  }\n  return check_brackets(implode(',',\
    \ $brackets_array));\n}\n", "  foreach (explode(\"<\", $brackets) as $open) {\n\
    \    foreach (explode(\">\", $brackets) as $close) {\n      if ($open != $close)\
    \ {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "    return\
    \ !($brackets = preg_replace(\"/^<|>$|<>|\\|\\|$/\", '', $brackets));\n}\n", " \
    \ return $brackets === '<' || $brackets === '>';\n}\n", "    if (strlen($brackets)\
    \ == 0)\n        return FALSE;\n\n    $brackets = explode(\"<\", $brackets);\n\
    \    $brackets = array_reverse($brackets);\n\n    foreach ($brackets as $b) {\n\
    \        if (strlen($b) > strlen($brackets[0]))\n            return FALSE;\n \
    \   }\n\n    return TRUE;\n}\n", "  $brackets = str_replace(array(\"<\", \"<<\"\
    , \">>\", \">>\"), array(\"\", \"\", \"\", \"\"), $brackets);\n  $brackets = explode(\"\
    <<<\", $brackets);\n  return count($brackets) == count(array_unique($brackets));\n\
    }\n", "\tglobal $counter;\n\tif (empty($brackets))\n\t\treturn false;\n\t$brackets\
    \ = array_flip($brackets);\n\t$stack = array($counter);\n\t$count = 0;\n\tfor\
    \ ($i = count($brackets) - 1; $i >= 0; $i--) {\n\t\tif (empty($stack[$i])) {\n\
    \t\t\tif ($brackets[$i]) { // opening\n\t\t\t\t$stack[$i] = 1;\n\t\t\t\t$count++;\n\
    \t\t\t\tcontinue;\n\t\t\t} else { // closing\n\t\t\t\t$stack[$i] = -1;\n\t\t\t\
    \t$count++;\n\t\t\t\t$i--;\n\t\t\t}\n\t\t}\n\t\twhile (!empty($stack[$i])) { //\
    \ pop\n\t\t\t$stack[$i]--;\n\t\t\t$count--;\n\t\t}\n\t\tif ($count == 0) { //\
    \ closing bracket\n\t\t\t$i--; // pop one item from stack\n\t\t\t$count++;\n\t\
    \t}\n\t\t$counter++;\n\t}\n\treturn ($count == 0);\n}\n", "  if ($brackets[0]\
    \ === \"<\" && $brackets[strlen($brackets) - 1] === \">\") {\n    return true;\n\
    \  }\n  return false;\n}\n", "\t$brackets = str_replace(array(\"<<\",\"<\"), array(\"\
    >\",\"<\"), $brackets);\n\t$brackets = str_replace(array(\">>\", \">>\"), array(\"\
    <\", \">\"), $brackets);\n\treturn preg_match(\"/^<\\s*\\/\\s*\\w+\\s*>$/\", $brackets);\n\
    }\n", "    $open = str_replace(\">\", \"\", $brackets);\n    $closed = str_replace(\"\
    <<\", \"\", $brackets);\n    $opened = str_replace(\"<\", \"\", $brackets);\n\
    \    $closed_reversed = str_replace(\"<<>\", \"\", $brackets);\n    return $open\
    \ == $opened && $opened == $closed_reversed;\n}\n", "\tfor ($i = 0, $len = strlen($brackets);\
    \ $i < $len; $i++) {\n\t\tif ($brackets[$i] === \"<\" && strpos($brackets, \"\
    <$i\", 1) === false) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($brackets[$i] ===\
    \ \">\" && strpos($brackets, \">$i\", 1) === false) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\treturn true;\n}\n", "  list($opening_brackets, $closing_brackets)\
    \ = explode('>', $brackets);\n  foreach ($opening_brackets as $opening_bracket)\
    \ {\n    if (!isset($closing_brackets[$opening_bracket])) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "    $stack = Array();\n    foreach($brackets\
    \ as $bracket) {\n        // Look at current bracket and make sure it matches\
    \ the last character\n        // on the stack.\n        if($bracket != $stack[count($stack)\
    \ - 1]) {\n            return false;\n        }\n        // Push the current bracket\
    \ onto the stack.\n        $stack[] = $bracket;\n    }\n    return true;\n}\n",
  "    $brackets = str_replace('>', '', $brackets);\n    $brackets = str_replace('<',\
    \ '', $brackets);\n    $brackets = str_replace('<<', '<<', $brackets);\n    $brackets\
    \ = str_replace('>>', '>>', $brackets);\n    if (strpos($brackets, '<<') === false)\
    \ {\n        return false;\n    }\n    $opening_brackets = explode('<<', $brackets);\n\
    \    $closing_brackets = explode('>>', $brackets);\n    for ($i = 0; $i < count($opening_brackets);\
    \ $i++) {\n        if ($opening_brackets[$i] !== '>>') {\n            for ($j\
    \ = $i + 1; $j < count($opening_brackets); $j++) {\n                if ($opening_brackets[$j]\
    \ === '>>') {\n                    return false;\n                }\n        \
    \    }\n            return true;\n        }\n    }\n    for ($i = 0; $i < count($closing_brackets);\
    \ $i++) {\n        if ($closing_brackets[$i] !== '<<') {\n            for ($j\
    \ = $i + 1; $j < count($closing_brackets); $j++) {\n                if ($closing_brackets[$j]\
    \ === '<<') {\n                    return false;\n                }\n        \
    \    }\n            return true;\n        }\n    }\n    return false;\n}", " \
    \ $counts = str_split($brackets);\n  $open_brackets = 0;\n  foreach ($counts as\
    \ $count) {\n    if ($count == \"<\") {\n      $open_brackets++;\n    } else {\n\
    \      if ($count != \">\") {\n        return false;\n      }\n    }\n  }\n  return\
    \ $open_brackets == count($counts);\n}\n</code>\n<|/ a tags=php,python |>\n<|\
    \ c |>\nHi thank you for your answer!  I'm going to try and implement this today\
    \ and let you know how it goes.\n<|/ c |>\n<| c |>\nHey Rob, I have been trying\
    \ to implement your code, however when I run the code nothing is happening.  I'm\
    \ running PHP version 7.1.  Am I doing something wrong?\n<|/ c |>\n<| c |>\nThis\
    \ was my problem: I was not including the '$counts = str_split($brackets);' line.\
    \  Thank you for your help!\n<|/ c |>\n<| a dscore=1 |>\nI like using regular\
    \ expressions for this sort of thing:\n<code>\n$pattern = '~(?>\\<{2}|(?!<)>)~';\n\
    if (preg_match($pattern, $input)) {\n    // brackets don't match\n}\n</code>\n\
    This checks for any pairs of '<' and '>' that don't start with '>', or that start\
    \ with '<', but don't end with '>', which means that an even number of < and >\
    \ will match. If you're willing to accept an even number of '<' at the start and\
    \ end, you could just check for an even number of '>'.\n<|/ a tags=php,python\
    \ |>\n<| a tags=php,python dscore=0 |>\nNot a RegEx solution, but I prefer to\
    \ do string manipulation rather than RegEx. \n<code>\nvar input = \"<\";\nvar\
    \ brackets = \"<>\";\n\nvar result = false;\n\nfor (var i=0; i < brackets.length;\
    \ i++) {\n   result += (input[i] == \"<\");\n}\n</code>\n<|/ a |>\n<| c |>\nI\
    \ assume you mean `var input = \"<\";`. You're missing quotes and a semicolon\
    \ ;)\n<|/ c |>\n<| c |>\nThanks, edited to fix that.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php\n$tests = array(\n    \"<\",\n    \"<>\",\n    \"<<>\",\n    \"<>\",\n \
    \   \"<<><>>\",\n    \"><<>\",\n);\n", "    $brackets = explode(\"<<\", $brackets);\n\
    \    foreach ($brackets as $key => $bracket) {\n        if ($bracket > $brackets[$key\
    \ + 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "  global $brackets_open, $brackets_closed;\n  $found = 0;\n  for ($opening = 0,\
    \ $closing = 0; $opening < strlen($brackets); $opening ++) {\n    if ($brackets_open[$brackets[$opening]])\
    \ {\n      ++$brackets_open[$brackets[$opening]];\n      if ($brackets_closed[$brackets[$opening]])\
    \ {\n        --$brackets_closed[$brackets[$opening]];\n      }\n    }\n    else\
    \ {\n      $brackets_open[$brackets[$opening]] = 1;\n      if ($brackets_closed[$brackets[$opening]])\
    \ {\n        $brackets_closed[$brackets[$opening]] = 0;\n      }\n    }\n    if\
    \ ($brackets_open[$brackets[$opening]]) {\n      if ($brackets_closed[$brackets[$opening]])\
    \ {\n        --$brackets_closed[$brackets[$opening]];\n      }\n      else {\n\
    \        $brackets_closed[$brackets[$opening]] ++;\n      }\n    }\n    if ($brackets_closed[$brackets[$opening]]\
    \ < 0) {\n      ++$found;\n      if ($brackets_open[$brackets[$opening]]) {\n\
    \        --$brackets_open[$brackets[$opening]];\n      }\n    }\n  }\n  return\
    \ $found == 0;\n}\n\n\n/**\n * Returns the position of a character in a string,\
    \ handling UTF8, UTF16, and HTML\n * @param string $text\n * @param int $position\n\
    \ * @param string $encoding\n * @return int position of $character in $text\n\
    \ */", "  $result = preg_match('/<[<>]{2}/', $brackets);\n  return ($result ==\
    \ 0);\n}\n\n", "  for ($i = 0; $i < strlen($brackets); $i++) {\n    if (!isset($brackets[$i]))\
    \ return false;\n    if (!isset($brackets[$i + 1])) return true;\n  }\n  return\
    \ false;\n}\n", "    $open_brackets = array('<', '>');\n    foreach ($open_brackets\
    \ as $open_bracket) {\n        $check = $brackets;\n        while (strlen($check)\
    \ > 1) {\n            // move the character\n            list($check, $new_check)\
    \ = explode($open_bracket, $check, 2);\n            // is the string empty?\n\
    \            if (strlen($new_check) == 0) {\n                return false;\n \
    \           }\n        }\n    }\n    return true;\n}\n", "    $stack = array();\n\
    \    foreach(preg_split('//', $brackets) as $char) {\n        if ($char === \"\
    >\") $stack[] = $char;\n        else if ($char === \"<\") $stack[] = $char;\n\
    \        else if ($stack && $stack[$stack.length-1] === \"<\") {\n           \
    \ $stack[] = $char;\n        } else {\n            return false;\n        }\n\
    \    }\n    return $stack === array(\"<\", \"<\");\n}\n", "  $brackets = str_replace(\"\
    \ \", \"\", $brackets);\n  for ($i = 0; $i < strlen($brackets); $i++) {\n    if\
    \ ($brackets[$i] !== \"<\" && $brackets[$i] !== \">\") {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "    $brackets = preg_split('/[\\<\\>]/', $brackets);\n\
    \    foreach ($brackets as $bracket) {\n        if (!array_search($bracket, $brackets))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=php,regex,brackets dscore=2 |>\n<| c |>\nWhat is the purpose of \"\
    return false;\" at the end of correct_bracketing() function?\n<|/ c |>\n<| c |>\n\
    It makes sure there are no other opening brackets in the given string.\n<|/ c\
    \ |>\n<| c |>\nAren't brackets supposed to be [balanced](https://en.wikipedia.org/wiki/Balanced_parentheses)?\n\
    <|/ c |>\n<| c |>\nYes, they are. But there are plenty of other examples of unbalanced\
    \ brackets.\n<|/ c |>\n<| c |>\nI wouldn't worry about the efficiency and readability\
    \ of this code. I've added some additional test cases to my answer.\n<|/ c |>\n\
    <| a dscore=2 |>\nHere is my solution to this problem in Java. Hope it helps you.\n\
    <code>\npublic boolean bracketsValidator(String expression) {\n        int openBracket\
    \ = expression.indexOf(\"(\");\n        int closeBracket = expression.indexOf(\"\
    )\");\n        if (openBracket == -1 || closeBracket == -1) {\n            return\
    \ false;\n        }\n        int brackets = 0;\n        for (int i = 0; i < expression.length();\
    \ i++) {\n            switch (expression.charAt(i)) {\n                case ')':\n\
    \                    brackets--;\n                    break;\n               \
    \ case '(':\n                    brackets++;\n                    break;\n   \
    \             default:\n                    break;\n            }\n          \
    \  if (brackets == 0) {\n                break;\n            }\n        }\n  \
    \      if (brackets == 0) {\n            return true;\n        }\n        return\
    \ false;\n    }\n</code>\n<|/ a tags=php,regex,brackets |>\n<| a |>\nIf you want\
    \ the fastest and most readable solution, use Regular Expressions. I tried to\
    \ keep it as close to the original as possible, with comments for explanation.\n\
    <code>", "    // Create an empty stack of brackets\n    $stack = array();\n  \
    \  // Add \"<\" to the stack\n    $stack[] = $brackets;\n    // While the stack\
    \ is not empty\n    while (count($stack)) {\n        // Pop a bracket off of it\n\
    \        $brackets = array_pop($stack);\n        // If the brackets has a corresponding\
    \ closing bracket\n        if ($brackets[0] == '>') {\n            // If there\
    \ isn't a corresponding opening bracket\n            if (count($stack) == 0) {\n\
    \                return false;\n            }\n            // Pop the last bracket\
    \ off of the stack\n            $brackets = array_pop($stack);\n            //\
    \ If the second bracket is a closing bracket\n            if ($brackets[0] ==\
    \ '>') {\n                // The second bracket is closed, so return true\n  \
    \              return true;\n            }\n            // If the second bracket\
    \ is opening, so add the second bracket to the stack\n            $stack[] = $brackets;\n\
    \        } else {\n            // If the brackets has a corresponding opening\
    \ bracket\n            if (count($stack) == 0) {\n                return true;\n\
    \            }\n            // Pop the last bracket off of the stack\n       \
    \     $brackets = array_pop($stack);\n            // If the second bracket is\
    \ a closing bracket\n            if ($brackets[0] == '>') {\n                //\
    \ The second bracket is closed, so return false\n                return false;\n\
    \            }\n            // If the second bracket is opening, so add the second\
    \ bracket to the stack\n            $stack[] = $brackets;\n        }\n    }\n\
    \    // If the stack isn't empty\n    return false;\n}\n", "  $brackets = preg_replace('/([<>])/',\
    \ '\\\\1', $brackets);\n  $brackets = explode('\\\\1', $brackets);\n  foreach\
    \ ($brackets as &$bracket) {\n    if (!$bracket || !isset($brackets[$bracket-1]))\n\
    \      return FALSE;\n  }\n  return TRUE;\n}\n\n", "  $brackets = explode(\",\"\
    , $brackets);\n  foreach ($brackets as $k => $bracket) {\n    $brackets[$k] =\
    \ trim($bracket);\n  }\n  return !array_diff($brackets, array(\"<>\", \"<\", \"\
    >\"));\n}", "    // Count how many brackets there are.\n    $brackets_count =\
    \ substr_count($brackets, \">\");\n    // Iterate through brackets.\n    for($i\
    \ = 0; $i < $brackets_count; $i++) {\n        // Look for the next \">\" in the\
    \ string.\n        $opening_bracket = strpos($brackets, \">\", $i);\n        //\
    \ Find the position of the next \"<\".\n        $closing_bracket = strpos($brackets,\
    \ \"<\", $opening_bracket);\n        // Check if there is a next \">\".\n    \
    \    if ($closing_bracket === false) {\n            // No more \">\"'s in the\
    \ string so return false.\n            return false;\n        }\n        // Check\
    \ if the closing bracket has a corresponding \"</\".\n        $closing_tag = strpos($brackets,\
    \ \"</\", $closing_bracket);\n        // Check if there is a next \"</\".\n  \
    \      if ($closing_tag === false) {\n            // No more \"</\"'s in the string\
    \ so return false.\n            return false;\n        }\n        // If the closing\
    \ bracket has a corresponding \">\" then return false.\n        if ($closing_bracket\
    \ < $opening_bracket) {\n            return false;\n        }\n        // If the\
    \ opening bracket has a corresponding \"<\" then return false.\n        if ($opening_bracket\
    \ < $closing_tag) {\n            return false;\n        }\n    }\n    // All brackets\
    \ are well balanced.\n    return true;\n}\n</code>\nThis works with any string.\
    \ For example, if you put \"<\" and \">\" in the brackets string above it will\
    \ return False for both strings. However, if you put \"<>\" it will return True\
    \ for the first string and False for the second.\n<|/ a |>\n<| a dscore=1 |>\n\
    If your goal is to find and count any nested brackets in your given string, try\
    \ the following regex:\n<code>\n/((<[^>]*>)|(<[^<]+>))+/\n</code>\nThe first group\
    \ will match any tag that is nested. The second group will match any tag that's\
    \ a direct child of another tag.\n<|/ a tags=string,php,algorithm |>\n<| a dscore=0\
    \ tags=string,php,algorithm |>\n<code>\n$string = \"abc<123<45678>xyz\";\npreg_match_all('/<(.*?)>/i',$string,\
    \ $matches);\nvar_dump($matches);\n</code>\n<|/ a |>\n<| c |>\nIf you post code,\
    \ XML or data samples, **PLEASE** highlight those lines in the text editor and\
    \ click on the \"code samples\" button ( `{  }` ) on the editor toolbar to nicely\
    \ format and syntax highlight it!\n<|/ c |>", "  $brackets_count = substr_count($brackets,\
    \ '<');\n  return $brackets_count % 2 == 1;\n}", "  $opening_brackets = preg_split(\"\
    /[\\<\\>]+/\", $brackets);\n  $closing_brackets = preg_split(\"/[\\<\\>]+/\",\
    \ $brackets);\n  return array_intersect($opening_brackets, $closing_brackets);\n\
    }\n</code>\n<|/ a tags=string,php |>\n<| c |>\nHmm, you're right. It only works\
    \ with brackets around an expression. Good point!\n<|/ c |>\n<| c |>\nYeah, that\
    \ works too. Hmmm... I don't really know how it works, but it does. I'm still\
    \ learning my way around Stack Overflow, so it's cool to get a few answers that\
    \ I learn from. Thanks!\n<|/ c |>\n<| a |>\nA simple regexp would suffice:\n<code>\n\
    <?php\n$string = '<<>>';\n$pattern = '/^<(?:<<>>|>|<<)?$/m';\nif (preg_match($pattern,\
    \ $string)) {\n    echo 'Match';\n} else {\n    echo 'No match';\n}\n</code>\n\
    <|/ a tags=string,php dscore=1 |>\n<| c |>\nThat would work great for matching\
    \ the opening brackets, but how would you match one or more?\n<|/ c |>\n<| c |>\n\
    Then you need `^<(?:<<>>|>|<<)?+$` (or `^<(?:<<>>|>|<<)+$`)\n<|/ c |>\n<| c |>\n\
    Or just `^<(?:<<>>|>|<<)++$` (or `^<(?:<<>>|>|<<)+$`)\n<|/ c |>\n<| c |>\nYou're\
    \ a genius! That worked beautifully, and it's amazing how simple something can\
    \ be. :)\n<|/ c |>\n<| c |>\nI tested it in regex101.com and it worked fine, but\
    \ when I run it in PHP, it doesn't work. Perhaps it's some kind of weird character\
    \ that PHP's preg_match doesn't like.\n<|/ c |>\n<| a dscore=0 |>\nThis may work\
    \ too:\n<code>\nif(preg_match('/(<)|(>>)/',$string)) {\n    echo 'Match';\n} else\
    \ {\n    echo 'No Match';\n}\n</code>\n<|/ a tags=string,php |>\n<| a dscore=0\
    \ |>\nA simpler method than using regex is to split the string up into the individual\
    \ characters and then check that the string is empty ", "  $count = substr_count($brackets,\
    \ \"<\");\n  for ($i = 0; $i < $count; $i++) {\n    if (substr($brackets, $i,\
    \ $i + 2) != \"<<\") {\n      return false;\n    }\n  }\n\n  $count = substr_count($brackets,\
    \ \">\");\n  for ($i = 0; $i < $count; $i++) {\n    if (substr($brackets, $i,\
    \ $i + 2) != \">>\") {\n      return false;\n    }\n  }\n\n  return true;\n}\n\
    \n", "  $brackets = str_replace(\"<<\", \"<\", $brackets);\n  $brackets = str_replace(\"\
    >>\", \">\", $brackets);\n  $brackets = str_replace(\"<<<\", \"<<\", $brackets);\n\
    \  $brackets = str_replace(\">>>>\", \">>\", $brackets);\n  $brackets = str_replace(\"\
    <<><>>\", \"<\", $brackets);\n  $brackets = str_replace(\"><<<\", \">>\", $brackets);\n\
    \  $brackets = str_replace(\"<<<>>>\", \"<<\", $brackets);\n  $brackets = str_replace(\"\
    ><<<>>\", \">>\", $brackets);\n  return ($brackets[0] == $brackets[1]);\n}\n",
  "    $brackets = preg_replace(\"/<(\\/)?([^>]*)>/i\", \" <$1$3>\", $brackets);\n\
    \    $brackets = preg_replace(\"/(<\\/([^>]*)>)/i\", \" $1<\", $brackets);\n \
    \   $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\",\
    \ \" <$1$4$5$6>\", $brackets);\n    $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\\
    /\\2>)([^>]*)(>))/s\", \" <$1$4$5$6>\", $brackets);\n    $brackets = preg_replace(\"\
    /(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\", \" <$1$4$5$6>\", $brackets);\n\
    \    $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\"\
    , \" <$1$4$5$6>\", $brackets);\n    $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\\
    /\\2>)([^>]*)(>))/s\", \" <$1$4$5$6>\", $brackets);\n    $brackets = preg_replace(\"\
    /(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\", \" <$1$4$5$6>\", $brackets);\n\
    \    $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\"\
    , \" <$1$4$5$6>\", $brackets);\n    $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\\
    /\\2>)([^>]*)(>))/s\", \" <$1$4$5$6>\", $brackets);\n    $brackets = preg_replace(\"\
    /(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\", \" <$1$4$5$6>\", $brackets);\n\
    \    $brackets = preg_replace(\"/(<([^>]*)(>)([^>]*)(<\\/\\2>)([^>]*)(>))/s\"\
    , \" <$1$4", "  $open = explode(\"<\", $brackets);\n  $close = explode(\">\",\
    \ $brackets);\n\n  foreach($open as $index => $val) {\n    if($val != $close[$index])\
    \ {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "    // Count how\
    \ many brackets there are.\n    $count = substr_count($brackets, \"<\");\n   \
    \ if ($count > 1) {\n        // There were multiple brackets.\n        return\
    \ false;\n    }\n    $count = substr_count($brackets, \">\");\n    if ($count\
    \ > 1) {\n        // There were multiple brackets.\n        return false;\n  \
    \  }\n    if ($count == 0) {\n        // No brackets were present.\n        return\
    \ true;\n    }\n    // Count how many brackets were properly closed, including\
    \ the one\n    // that opened it.\n    return $brackets[$count-1] == \">\";\n\
    }\n", "    $brackets = preg_replace(\"/<\\/*>/\", '<', $brackets);\n    $brackets\
    \ = preg_replace(\"/<[^>]+>\", '>', $brackets);\n    $brackets = preg_replace(\"\
    /<\\/[^>]+>/\", '</', $brackets);\n    return ($brackets == \"<>\");\n}\n", " \
    \ $opens = preg_match_all('/<+/', $brackets);\n  $closes = preg_match_all('/>/+/',\
    \ $brackets);\n  return ($opens == $closes && $opens > 0);\n}", "    $opening_brackets\
    \ = str_replace(\"<>\", \"\", $brackets);\n    $closing_brackets = str_replace(\"\
    >\", \"\", $brackets);\n    for ($i = 0; $i < count($opening_brackets); $i++)\
    \ {\n        if ($opening_brackets[$i] != $closing_brackets[$i]) {\n         \
    \   return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nTry this:\n<code>\n$opening_brackets = '<>(){}[]';\n$closing_brackets\
    \ = '<?>{}[]()';\n$string = \"<<><>><>>\";\nif (preg_match_all(\"/$opening_brackets/i\"\
    , $string) != strlen($opening_brackets)) {\n    echo \"Not all opening brackets\
    \ are paired correctly!\";\n}\nif (preg_match_all(\"/$closing_brackets/i\", $string)\
    \ != strlen($closing_brackets)) {\n    echo \"Not all closing brackets are paired\
    \ correctly!\";\n}\n</code>\n<|/ a dscore=1 tags=php,regex |>\n<| c |>\nYour regex\
    \ will match if string contains invalid brackets `<>(){}[]`, it will also match\
    \ string with invalid brackets, for example `<<><>><>>` will match on `<>`\n<|/\
    \ c |>\n<| c |>\nOh, of course :) I overlooked that.\n<|/ c |>\n<| a dscore=0\
    \ tags=php,regex |>\nYou can do this using the function preg_match_all:\n<code>\n\
    <?php\n\n$opening_brackets = '<>(){}[]';\n$closing_brackets = '<?>{}[]()';\n$string\
    \ = \"<<><>><>>\";\n\nif(preg_match_all('/'.$opening_brackets.'/', $string) !=\
    \ count($opening_brackets)) {\n    echo \"Not all opening brackets are paired\
    \ correctly!\";\n}\n\nif(preg_match_all('/'.$closing_brackets.'/', $string) !=\
    \ count($closing_brackets)) {\n    echo \"Not all closing brackets are paired\
    \ correctly!\";\n}\n</code>\nOutput:\n<code>\nNot all opening brackets are paired\
    \ correctly!\nNot all closing brackets are paired correctly!\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>\n<?php\n\n$opening_brackets = '<>(){}[]';\n$closing_brackets\
    \ = '<?>", "    $stack = array();\n    for($i = 0; $i < strlen($brackets); $i++)\
    \ {\n        if ($brackets[$i] === \"<\") {\n            $stack[] = $i;\n    \
    \    } else if ($brackets[$i] === \">\") {\n            $opening = $stack[count($stack)-1];\n\
    \            if ($opening === $i) {\n                return false;\n         \
    \   }\n            $stack[] = $i;\n        }\n    }\n    return true;\n}\n", " \
    \ foreach (preg_split('/[\\-><\\>]/', $brackets) as $i => $bracket) {\n    //\
    \ If this bracket doesn't have a corresponding closing bracket, it's invalid.\n\
    \    if (!preg_match('/'.str_repeat('\\h*', strlen($bracket)).'\\h*$/', $bracket))\
    \ {\n      return false;\n    }\n  }\n  return true;\n}", "    $stack = array();\n\
    \    $open = false;\n    for ($i = 0; $i < strlen($brackets); $i++) {\n      \
    \  $char = substr($brackets, $i, 1);\n        if (!$open) {\n            if ($char\
    \ === \"<\") {\n                $stack[] = $char;\n                $open = true;\n\
    \            }\n        }\n        else {\n            if ($char === \">\") {\n\
    \                if ($stack[0] !== \"<\") {\n                    return false;\n\
    \                }\n                $open = false;\n            }\n        }\n\
    \    }\n    return !$open;\n}\n", "  $left_brackets = array(\"<\");\n  $right_brackets\
    \ = array(\">\");\n  return array_search($brackets, $left_brackets) === false\
    \ &&\n    array_search($brackets, $right_brackets) === false &&\n    count($left_brackets)\
    \ == count($right_brackets);\n}\n", "  $open_brackets = explode(\"<<\", $brackets);\n\
    \  $closed_brackets = explode(\">>\", $brackets);\n  $open_count = count($open_brackets);\n\
    \  $closed_count = count($closed_brackets);\n  for ($i = 0; $i < $open_count;\
    \ $i++) {\n    if ($open_brackets[$i] != $closed_brackets[$i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}", "  $brackets = str_replace(\"<<\", \"\
    \", $brackets);\n  $brackets = str_replace(\">>\", \"\", $brackets);\n  preg_match_all('/\\\
    <(.*?)\\>/', $brackets, $matches);\n  return count(array_unique($matches[1]))\
    \ <= 1;\n}\n", "\t$level = 0;\n\tfor ($i = 0; $i < strlen($brackets); $i++) {\n\
    \t\t$bracket = $brackets[$i];\n\t\tif (!$level) {\n\t\t\tif ($bracket === \"<\"\
    ) {\n\t\t\t\t$level = 1;\n\t\t\t} else if ($bracket === \">\") {\n\t\t\t\t$level\
    \ = 2;\n\t\t\t} else if ($bracket === \"<<\") {\n\t\t\t\t$level = 3;\n\t\t\t}\
    \ else if ($bracket === \">>\") {\n\t\t\t\t$level = 4;\n\t\t\t}\n\t\t} else {\n\
    \t\t\t$level--;\n\t\t}\n\t}\n\tif ($level > 0) {\n\t\treturn false;\n\t} else\
    \ if ($level < 0) {\n\t\treturn true;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n\
    /**\n * Converts HTML elements to entities, e.g. converts `<` to `&lt;`, `>` to\
    \ `&gt;`.\n *\n * If the `use_reusable_entity` option is enabled, it will convert\
    \ all HTML elements to entities.\n *\n * @param string $text The text to convert\
    \ HTML elements into.\n * @param string $element The element to convert (e.g.\
    \ `<em>`, `<strong>`, `<i>`).\n * @param string $attributes Any attributes on\
    \ the element (e.g. `class=\"...\"`).\n * @param string $text The text to replace\
    \ the element with (e.g. `<em>Hello!</em>`).\n * @param array $tagAttributes An\
    \ array of attributes to add for the tag\n * @return string The input text with\
    \ converted HTML elements.\n */", "  global $brackets;\n  $brackets = str_replace(array('<',\
    \ '>'), '', $brackets);\n  foreach (explode('>', $brackets) as $b) {\n    if ($b\
    \ == '<') {\n      return true;\n    }\n  }\n  return false;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nYes, but my answer does not require any additional libraries\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is a solution without regex:\n<code>", "  global\
    \ $open_tags, $closing_brackets;\n\n  if (strlen($brackets) == 0) {\n    return\
    \ FALSE;\n  }\n\n  $correct = TRUE;\n  $length = strlen($brackets);\n\n  for($i\
    \ = 0; $i < $length; ++$i) {\n    $bracket = $brackets[$i];\n    if ($bracket\
    \ == \"<\") {\n      if (!$open_tags) {\n        $correct = FALSE;\n        break;\n\
    \      }\n      else {\n        $open_tags--;\n      }\n    }\n    else if ($bracket\
    \ == \">\") {\n      if (!$closing_brackets) {\n        $correct = FALSE;\n  \
    \      break;\n      }\n      else {\n        $closing_brackets--;\n      }\n\
    \    }\n  }\n\n  return $correct;\n}\n", "  // TODO(ben): Can this be done by\
    \ iterating over each char in $brackets?\n  return strpos($brackets, \">\") ===\
    \ FALSE;\n}\n\n/**\n * Returns the number of unclosed angle brackets in the given\
    \ bracket\n * string.\n * >>> count_unclosed_brackets(\"<\")\n * 0\n * >>> count_unclosed_brackets(\"\
    <x>\")\n * 1\n * >>> count_unclosed_brackets(\"<<x>>\")\n * 2\n * >>> count_unclosed_brackets(\"\
    <x<<y>>z\")\n * 2\n * >>> count_unclosed_brackets(\"<<<x>>\")\n * 1\n * >>> count_unclosed_brackets(\"\
    <<<x>>>\")\n * 3\n * >>> count_unclosed_brackets(\"<<<x>>>y\")\n * 2\n * >>> count_unclosed_brackets(\"\
    <<<<x>>>>\")\n * 2\n * >>> count_unclosed_brackets(\"<<<<x>>>>y\")\n * 1\n * >>>\
    \ count_unclosed_brackets(\"<<<<x>>>>y\")\n * 1\n * >>> count_unclosed_brackets(\"\
    <<<<x>>>>yz\")\n * 1\n */", "    // If there are no brackets, return False (no\
    \ opening brackets).\n    if (strlen($brackets)==0) {\n        return false;\n\
    \    }\n    foreach (str_split($brackets) as $b) {\n        if ((strlen($b)==0)\
    \ || ($b==\"<\") || ($b==\">\")) {\n            return false;\n        }\n   \
    \ }\n    return true;\n}\n", "  return preg_match_all(\"/<(.?)(?>)/\", $brackets,\
    \ $matches);\n}\n", "  for ($i = 0; $i < strlen($brackets); $i++) {\n    $opening\
    \ = $brackets[$i];\n    $closing = ($i + 1 < strlen($brackets)) ? $brackets[$i\
    \ + 1] : \"\";\n    if ($opening === $closing) {\n      $opening = stripcslashes($opening);\n\
    \      $closing = stripcslashes($closing);\n      $brackets = substr_replace($brackets,\
    \ $opening, $i, 1);\n      $brackets = substr_replace($brackets, $closing, $i\
    \ + 1, 1);\n      continue;\n    }\n    if ($opening === \"<\") {\n      // Find\
    \ the previous \">\".\n      $close = false;\n      for ($j = strlen($brackets)\
    \ - 2; $j >= 0; $j--) {\n        if ($brackets[$j] === \">\") {\n          $close\
    \ = true;\n          break;\n        }\n      }\n      if (!$close) {\n      \
    \  // No previous \">\".\n        $brackets = substr_replace($brackets, \"<\"\
    , $i, 1);\n        $brackets = substr_replace($brackets, $closing, $i, 1);\n \
    \       continue;\n      }\n    }\n    if ($opening === \">\") {\n      // Find\
    \ the next \"<\"\n      $open = false;\n      for ($j = strlen($brackets) - 2;\
    \ $j >= 0; $j--) {\n        if ($brackets[$j] === \"<\") {\n          $open =\
    \ true;\n          break;\n        }\n      }\n      if (!$open) {\n        //\
    \ No next \"<\"\n        $brackets = substr_replace($brackets, $opening, $i, 1);\n\
    \        $brackets = substr_replace($brackets, \"<\", $i, 1);\n        continue;\n\
    \      }\n    }\n  }\n  return (strlen($brackets) == 0);\n}", "\t$stack = array();\n\
    \tfor ($i = 0, $len = strlen($brackets); $i < $len; $i++) {\n\t\t$char = $brackets[$i];\n\
    \t\tif ($char == \"<\") {\n\t\t\tif (empty($stack)) {\n\t\t\t\treturn False;\n\
    \t\t\t}\n\t\t\t$stack[] = $char;\n\t\t\tcontinue;\n\t\t}\n\t\t$last = array_pop($stack);\n\
    \t\tif ($char != \">\") {\n\t\t\treturn ($last == \"<\");\n\t\t}\n\t}\n\treturn\
    \ False;\n}\n", "  // Get a list of opening brackets.\n  $brackets = preg_split(\"\
    /[\\<\\>]/\",$brackets);\n  // See if every opening bracket has a corresponding\
    \ closing bracket.\n  $num_opening_brackets = count($brackets);\n  for ($i=0;\
    \ $i < $num_opening_brackets; ++$i) {\n    if ($brackets[$i] != \"<<\" && $brackets[$i]\
    \ != \">>\") {\n      return false;\n    }\n  }\n  return true;\n}\n</code>\n\
    <|/ a tags=regex,php,validation |>\n<| c |>\n+1 I like this answer (the other\
    \ is quite good), but I don't think it's very robust. For example, what do you\
    \ do if there are multiple nested brackets? What if the brackets are missing from\
    \ some text? What if a text has a newline at the end?\n<|/ c |>\n<| c |>\nThat\
    \ is true, I wasn't thinking about the case of the brackets being nested for sure.\
    \ There could be some cases to consider. I guess you could try to implement some\
    \ kind of stack to validate this as well.\n<|/ c |>\n<| a dscore=1 |>\nThis is\
    \ not exactly a solution in PHP, but if you can use the .net regex engine, this\
    \ is how you can do it using a named group so that you can use it later for error\
    \ checking:\n<code>\n^(?<opening_bracket>\\<\\<)(?<bracket>\\>\\>)(?<closing_bracket>\\\
    >\\<)$\n</code>\nThis regex will check for 4 different scenarios: \n\nA < then\
    \ a < then a > then a >\nA <> then a > then a <> then a >\nA < then a > then a\
    \ < then a >\n<|/ a tags=regex,php,validation |>\n<| a tags=regex,php,validation\
    \ |>\nIf you can rely on the fact that your brackets will always be correctly\
    \ nested, and you don't need it to be super elegant, this solution might work:\n\
    <code>", "    $open_brackets = preg_match_all(\"/<([^>]*)>/\", $brackets, $matches);\n\
    \    $closed_brackets = preg_match_all(\"/<([^>]*)>/\", $brackets, $matches);\n\
    \    return $open_brackets == $closed_brackets;\n}\n", "\t$brackets = preg_replace(\"\
    /[^<>]+/\", \"\", $brackets);\n\tforeach(explode(\"<>\", $brackets) as $opening)\
    \ {\n\t\t$closing = array_search($opening, $brackets);\n\t\tif ($opening != $closing)\
    \ return false;\n\t}\n\treturn true;\n}", "  $openers = array();\n  $closers =\
    \ array();\n  $openers_len = strlen($brackets) - 1;\n  for ($i = 0; $i < $openers_len;\
    \ $i++) {\n    if ($brackets[$i] != \"<\" && $brackets[$i] != \">\") {\n     \
    \ return false;\n    }\n    $openers[] = $i;\n  }\n  for ($i = $openers_len; $i\
    \ > 0; $i--) {\n    if ($brackets[$i] != \"<\" && $brackets[$i] != \">\") {\n\
    \      return false;\n    }\n    $closers[] = $i;\n  }\n  $matches = array_intersect($openers,\
    \ $closers);\n  if (count($matches) != count($openers) || count($matches) != count($closers))\
    \ {\n    return false;\n  }\n  for ($i = 0; $i < count($matches); $i++) {\n  \
    \  if ($openers[$i] != $closers[$i]) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}", "  return preg_match('/[' . $brackets . ']+/', $brackets) === 1;\n\
    }\n", "    $opening_brackets = explode(\"<\", $brackets);\n    $opening_brackets_count\
    \ = count($opening_brackets);\n    $closing_brackets = explode(\">\", $brackets);\n\
    \    $closing_brackets_count = count($closing_brackets);\n    for ($i = 0; $i\
    \ < $opening_brackets_count; $i++) {\n        if ($closing_brackets_count > $i)\
    \ {\n            if ($opening_brackets[$i] == $closing_brackets[$i]) {\n     \
    \           continue;\n            }\n            return false;\n        }\n \
    \   }\n    return true;\n}\n", "  for ($i = 0; $i < strlen($brackets); $i++) {\n\
    \    if ($brackets[$i] == \"<\") {\n      preg_match('/^<(.+)>$/', $brackets,\
    \ $match);\n      if (isset($match[1])) {\n        $brackets = substr($brackets,\
    \ 0, $i).$match[1].substr($brackets, $i);\n      }\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "  foreach (explode(\"<\", $brackets) as $open) {\n\
    \    $last = array_pop(explode(\">\", $open));\n    if ($open === $last) return\
    \ false;\n  }\n  return true;\n}\n\n$text = <<<END\nThis is a paragraph. This\
    \ is the second paragraph. This is the third.\nEND;\n\n$text = explode(\"<\",\
    \ $text);\n", "  $brackets = str_replace(\"<<\", \">>\", $brackets);\n  return\
    \ preg_match(\"/<<<\\s*(.*?)\\s*>>/\", $brackets, $match) > 0;\n}\n", "    $stack\
    \ = array();\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        $char\
    \ = $brackets[$i];\n        if ($char === \"<\") {\n            if ($stack) {\n\
    \                if ($stack[count($stack) - 1] === \"<\") {\n                \
    \    array_pop($stack);\n                } else {\n                    return\
    \ false;\n                }\n            } else {\n                $stack[] =\
    \ $char;\n            }\n        } else {\n            if (!$stack) {\n      \
    \          return false;\n            }\n            $last = array_pop($stack);\n\
    \            if ($last !== $char) {\n                return false;\n         \
    \   }\n        }\n    }\n    return $stack === array();\n}\n", "  global $brackets;\n\
    \  foreach (str_split($brackets) as $i => $bracket) {\n    if ($bracket !== $brackets[$i\
    \ + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "    return\
    \ preg_match_all(\"/(^|[><])[^<]+(?=[>$])/\", $brackets, $matches);\n}\n", " \
    \ $openings = preg_split('/[><]+/', $brackets);\n  foreach ($openings as $opening)\
    \ {\n    $closed = preg_replace('/^(<+)/', '', $opening);\n    if ($closed !=\
    \ $opening) {\n      return FALSE;\n    }\n  }\n  return TRUE;\n}\n", "    for\
    \ ($i = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] !== \"<\"\
    \ && $brackets[$i] !== \">\") return false;\n    }\n    return true;\n}\n", " \
    \   $stack = array();\n    for ($i = 0; $i < strlen($brackets); $i++) {\n    \
    \    $bracket = $brackets[$i];\n        if ($bracket == \"<\") {\n           \
    \ if ($stack) {\n                // closing brackets have to match opening brackets\n\
    \                return ($stack[count($stack) - 1] == \"<\");\n            }\n\
    \            return false;\n        }\n        if ($bracket == \">\") {\n    \
    \        if (count($stack)) {\n                // opening brackets have to match\
    \ closing brackets\n                return ($stack[count($stack) - 1] == \">\"\
    );\n            }\n            return false;\n        }\n        $stack[] = $bracket;\n\
    \    }\n    // no brackets matched\n    return true;\n}", "  $open_brackets =\
    \ array_map('trim', explode('>', $brackets));\n  return array_intersect_key($open_brackets,\
    \ array_flip($open_brackets));\n}\n", "    $stack = [];\n    for ($i=0; $i<strlen($brackets);\
    \ $i++) {\n        $x = $brackets[$i];\n        if ($x == '<') {\n           \
    \ // <\n            if (empty($stack)) return False;\n            $stack[] = $x;\n\
    \        } elseif ($x == \">\") {\n            // >\n            if (empty($stack))\
    \ return False;\n            $last_x = array_pop($stack);\n            if ($last_x\
    \ != '>') return False;\n        } else {\n            # other characters.\n \
    \           if (empty($stack)) return False;\n            $last_x = array_pop($stack);\n\
    \            if ($last_x != $x) return False;\n        }\n    }\n    return empty($stack);\n\
    }\n", "\t$correct = true;\n\t$open_brackets = array('<', '>');\n\tfor ($i = 0;\
    \ $i < count($brackets); $i++) {\n\t\t$closed = substr($brackets, $i, 1);\n\t\t\
    if ($closed != $open_brackets[$i]) {\n\t\t\t$correct = false;\n\t\t}\n\t}\n\t\
    return $correct;\n}\n", "    $bracket_stack = [];\n    $bracket_level = 0;\n \
    \   for($i=0; $i<strlen($brackets); $i++) {\n        if ($brackets[$i] == \"<\"\
    ) {\n            if (! isset($bracket_stack[$bracket_level])) {\n            \
    \    $bracket_level = 0;\n            }\n            if ($bracket_level == count($bracket_stack)\
    \ - 1) {\n                return false;\n            }\n            $bracket_stack[$bracket_level]++;\n\
    \        } else {\n            if ($brackets[$i] == \">\") {\n               \
    \ if ($brackets[$i-1] != \">\") {\n                    return false;\n       \
    \         }\n                if ($bracket_level == count($bracket_stack) - 1)\
    \ {\n                    return false;\n                }\n                $bracket_stack[$bracket_level]--;\n\
    \            }\n        }\n        $bracket_level++;\n    }\n    return count($bracket_stack)\
    \ == 0;\n}", "  if (empty($brackets)) return TRUE;\n  $stack = array();\n  $has_opening\
    \ = FALSE;\n  foreach (preg_split('/[\\<\\>]/' ,$brackets) as $open) {\n    if\
    \ (!$has_opening && $open===\"<\") $has_opening = TRUE;\n    $stack[] = str_repeat(\"\
    ~\", count($stack));\n    if ($open===\"$\") {\n      if (!empty($stack)) return\
    \ FALSE;\n      return TRUE;\n    }\n    if ($open==\"~\") {\n      $s = array_pop($stack);\n\
    \      if ($s===\"~\") return TRUE;\n      return FALSE;\n    }\n  }\n  return\
    \ FALSE;\n}\n</code>\n<|/ a tags=regex |>\n<| c |>\nThis seems really close to\
    \ what I would have done, but in javascript instead of php. I ended up using the\
    \ regex I put in my question as the accepted answer. Thank you for the help.\n\
    <|/ c |>\n<| c |>\nActually it is even more correct than your regex which does\
    \ not allow nested pairs (the example `<<><>>` you give is a problem because it\
    \ has 3 opening brackets followed by 2 closing brackets instead of 2). In fact\
    \ your regex does not allow balanced brackets like `()`, `[]`, `{}` or `<>`. Nor\
    \ does it allow unbalanced `>` or `<` like `<<>`\n<|/ c |>\n<| a dscore=1 |>\n\
    I know this is an old question, but I came across it while searching for a similar\
    \ solution to this, so I thought I'd share my code for the JavaScript equivalent\
    \ of the accepted answer, in case anyone else comes across this question looking\
    \ for an answer.\n<code>", "    return preg_match_all(\"~<(.*?)>~\", $brackets,\
    \ $matches) && count($matches[0]) === count($matches[1]);\n}\n", "    $brackets\
    \ = preg_replace(\"(<|>)\", \"\\\\1\", $brackets);\n    for($i = 0; $i < count($brackets);\
    \ $i++) {\n        if($brackets[$i] == \"<\")\n            return $brackets[$i\
    \ + 1] == \">\";\n        if($brackets[$i] == \"<\")\n            return $brackets[$i\
    \ - 1] == \">\";\n    }\n    return false;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nThis is not the solution you are looking for, but here is a way to accomplish\
    \ this in bash:\n<code>\n$ cat file\n<\n>\n<<\n><<\n><<<\n</code>\nRun this command:\n\
    <code>\n$ sed -n 's/\\([<>]\\)/\\1/p' file\n</code>\nOutput:\n<code>\n<\n>\n<\n\
    >\n<\n</code>\n<|/ a tags=php,regex |>\n<| a tags=php,regex |>\nHere is another\
    \ one\n<code>\n<?php\n\n$str = '<><><><>';\n\necho preg_replace('/^<+|\\<+$|<+\\\
    >/', '', $str);\n", "  $bracketsArray = str_split($brackets);\n  $openingBracketCount\
    \ = array();\n  $closingBracketCount = array();\n  foreach ($bracketsArray as\
    \ $bracket) {\n    if ($bracket == \"<\")\n      $openingBracketCount[] = 1;\n\
    \    elseif ($bracket == \">\")\n      $closingBracketCount[] = 1;\n    else\n\
    \      throw new Exception(\"Bracketing error: Found unexpected <$bracket>\");\n\
    \  }\n  $noMatchingBrackets = count($openingBracketCount) - count($closingBracketCount);\n\
    \  return $noMatchingBrackets == 0;\n}\n", "  $open_brackets = preg_split(\"/[\\\
    <\\>]/\", $brackets);\n  return $open_brackets[0] == $open_brackets[count($open_brackets)\
    \ - 1];\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer, but I\
    \ don't think this will work. In the first example, both `<` and `>` aren't actually\
    \ adjacent brackets, but are in the correct order. So the function returns `true`.\
    \ In the second example, there is an extra `<` at the beginning, which is also\
    \ not in the correct order. So the function returns `false`.\n<|/ c |>\n<| c |>\n\
    I guess I misunderstood your examples. My code was intended to find out whether\
    \ two brackets are adjacent or not.  In your first example, `<><>` would return\
    \ false.  It was my understanding that you were asking whether `<><` returns true,\
    \ which it would not.  Is that not the case?\n<|/ c |>\n<| c |>\nYour question\
    \ was unclear. The original question was \"Is <><> true?\", and I answered \"\
    no\".\n<|/ c |>\n<| c |>\nYes, I apologize. My original question was \"Is <><>\
    \ true?\", and I answered \"no\". My comment was to clarify the difference between\
    \ the two examples. I apologize for the confusion.\n<|/ c |>\n<| c |>\nNo apologies\
    \ needed! Your question was clear and well received, so I appreciate your explanation!\n\
    <|/ c |>\n<| a dscore=0 |>\nI believe the best way is to use regular expressions,\
    \ and in this case you need to specify two separate patterns. Something like this:\n\
    <code>\nif(preg_match('/(<)(>)/', '><<>', $matches)) {\n    if(!preg_match('/(<)(>)/',\
    \ '<<><>>', $matches)) {\n        echo \"false\";\n    } else {\n        echo\
    \ \"true\";\n    }\n}\n</code>\nAnd that will output \"true\". This is a very\
    \ simple example, and it can be made much more robust. For example, you can specify\
    \ more patterns in the first preg_match or in the second preg_match. Or, you can\
    \ specify that some patterns are allowed at the beginning and some patterns are\
    \ allowed at the end. Or, you can specify that a character may only appear at\
    \ the beginning and only at the end (but this would probably be unnecessarily\
    \ complicated).\n<|/ a tags=regex,php |>\n<| a |>\nI wrote a function that will\
    \ do this. It assume", "  $open_brackets = preg_split('/<<<>>/s', $brackets);\n\
    \  $closed_brackets = preg_split('/<<<>>/s', str_replace(\"<<<>>\", '', $brackets));\n\
    \  $open_brackets = array_diff($open_brackets, $closed_brackets);\n  return empty($open_brackets);\n\
    }\n", "    // Create stack of brackets.\n    $brackets_stack = array($brackets);\n\
    \    // Keep track of how many brackets are currently opened.\n    $open_brackets\
    \ = count($brackets_stack);\n    // Keep track of which opening bracket we're\
    \ currently on.\n    $open_bracket = $brackets;\n    // Keep track of whether\
    \ we found a closing bracket.\n    $found_bracket = false;\n    // Keep track\
    \ of whether we found an opening bracket.\n    $found_open_bracket = false;\n\
    \    // Loop through brackets, popping them off the stack and checking for\n \
    \   // matching closing brackets.\n    while($open_brackets > 0) {\n        //\
    \ If the opening bracket we're currently on has already been\n        // popped\
    \ off the stack, that's an error.\n        if(!$found_open_bracket) {\n      \
    \      echo 'ERROR: The opening bracket \"' . $open_bracket .\n              \
    \  '\" does not have a corresponding closing bracket.';\n            die();\n\
    \        }\n        // Pop the opening bracket off the stack (if we're at it).\n\
    \        $open_bracket = array_pop($brackets_stack);\n        // See if this opening\
    \ bracket matches the closing bracket we just\n        // popped off.\n      \
    \  if($open_bracket == $found_open_bracket) {\n            // Yes. We're done!\n\
    \            $found_open_bracket = false;\n            $found_bracket = true;\n\
    \        } else {\n            // No. The next opening bracket doesn't match this\
    \ closing bracket.\n            $open_brackets = $open_brackets + 1;\n       \
    \ }\n    }\n    // Did we find every opening bracket?\n    return !$found_bracket;\n\
    }\n", "    foreach($brackets as $b) {\n        $opening = substr($b, 0, 1);\n\
    \        $closing = substr($b, 1, 1);\n        if ($opening != $closing) {\n \
    \           return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI guess I oversimplified my problem a bit. The brackets are not\
    \ always in pairs. It can be more complicated than that. Take a look at this example:\
    \ `<abc<def<ghi<klm<nop>qrs>>uvw>xyz>`. How will you parse this correctly? Do\
    \ you know how a compiler would go about solving this?\n<|/ c |>\n<| c |>\nI don't\
    \ think you're going to find a solution without knowing what kind of grammar you're\
    \ trying to parse. Do you have an example?\n<|/ c |>\n<| c |>\n: That's not valid\
    \ XML. You've got invalid `<` characters inside `<` characters.\n<|/ c |>\n<|\
    \ c |>\n: It can be done with XML. See the \"XML Practice\" section of my answer\
    \ below.\n<|/ c |>\n<| c |>\n: It's not valid XML. XML is `<tag>value</tag>`,\
    \ and it looks like you're not thinking of it as such.\n<|/ c |>\n<| a dscore=0\
    \ |>\nIf you have a syntax tree of the input, then this problem would be trivial.\n\
    If there is no syntax tree, you will need to define a lexical grammar and write\
    \ a custom parser generator for that.\n<|/ a tags=php,parsing |>\n<| a |>\nWell,\
    \ you could do this:\n<code>\n<?php", "\t$stack = array();\n\tfor ($i = 0; $i\
    \ < strlen($brackets); $i++) {\n\t\t$char = $brackets[$i];\n\t\tif ($char ===\
    \ '<') {\n\t\t\t$stack[] = $char;\n\t\t} else if ($char === '>') {\n\t\t\tif ($stack)\
    \ {\n\t\t\t\t$open = $stack;\n\t\t\t\t$stack = array();\n\t\t\t\tif (in_array('>',\
    \ $open)) {\n\t\t\t\t\t$stack[] = $char;\n\t\t\t\t}\n\t\t\t\tforeach ($open as\
    \ $o) {\n\t\t\t\t\t$stack[] = $o;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t} else {\n\t\t\tif ($stack) {\n\t\t\t\t$stack[] = $char;\n\t\t\t\
    } else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn (count($stack)\
    \ == 0);\n}\n", "  $opening = strpos($brackets, '<');\n  $closing = strpos($brackets,\
    \ '>');\n  if ($opening !== false && $closing !== false) {\n    return ($opening\
    \ - $closing) == 0;\n  }\n  return false;\n}\n", "  return preg_match('/([<>]+)/',\
    \ $brackets);\n}\n", "  // Only correct bracketing if they are balanced.\n  if\
    \ ( ! is_balanced_bracketing($brackets)) {\n    return false;\n  }\n\n  $open_brackets\
    \ = array();\n  $closed_brackets = array();\n\n  $num_open_brackets = 0;\n  for\
    \ ($i = 0; $i < strlen($brackets); $i++) {\n    if ($brackets[$i] == '<') {\n\
    \      $open_brackets[] = $i;\n      $num_open_brackets++;\n    }\n  }\n\n  $num_closed_brackets\
    \ = 0;\n  for ($i = 0; $i < count($open_brackets); $i++) {\n    $open_len = strlen($brackets)\
    \ - $num_open_brackets - $num_closed_brackets - $i;\n    if ($brackets[$open_brackets[$i]]\
    \ != '>') {\n      $closed_brackets[] = $open_brackets[$i];\n      $num_closed_brackets++;\n\
    \    }\n  }\n\n  // Check the number of closed brackets matches the number of\
    \ open brackets.\n  if (count($closed_brackets) != count($open_brackets)) {\n\
    \    return false;\n  }\n\n  // Check the number of closed brackets are in the\
    \ correct order.\n  foreach ($closed_brackets as $i => $closed_bracket) {\n  \
    \  if ($closed_bracket < $open_brackets[$i]) {\n      return false;\n    }\n \
    \ }\n\n  // If we make it here the brackets are balanced.\n  return true;\n}\n\
    \n/**\n * Checks if bracketing is correct (using stack).\n *\n * A pair of brackets\
    \ [] indicates depth, and a pair of parentheses ()\n * indicates grouping -- these\
    \ count as one bracket.\n *\n * Examples:\n * [][][][((((())))(())))(())([])[])\n\
    \ *\n * [[[[([]]]]]]\n *\n * [][][[[[([])]]]]\n *\n * [[[(()[])]]]\n *\n * [[[(())[]]]]\n\
    \ *\n * [(()())]\n */", "    // remove whitespace and newlines from the brackets\n\
    \    $brackets = preg_replace('/[\\r\\n]+/', '', $brackets);\n    $brackets =\
    \ preg_replace('/\\s+/', ' ', $brackets);\n    \n    // find the number of open\
    \ brackets\n    $open_brackets = substr_count($brackets, '<');\n    \n    // find\
    \ the number of closed brackets\n    $closed_brackets = substr_count($brackets,\
    \ '>');\n    \n    // if the number of open brackets is equal to the number of\
    \ closed brackets there were no open brackets\n    // therefore the brackets are\
    \ correctly closed\n    if ($open_brackets == $closed_brackets) {\n        return\
    \ true;\n    }\n    // if the number of open brackets is greater than the number\
    \ of closed brackets\n    // there were more brackets than closing brackets. Therefore\
    \ the brackets are incorrectly opened.\n    else if ($open_brackets > $closed_brackets)\
    \ {\n        return false;\n    }\n    // the number of open brackets is less\
    \ than the number of closed brackets\n    // there are more open brackets than\
    \ closing brackets.\n    // therefore the brackets are incorrectly opened.\n \
    \   else {\n        return false;\n    }\n}\n", "  $brackets_count = count($brackets);\n\
    \  for ($i = 0; $i < $brackets_count; ++$i) {\n    $opening = $brackets[$i];\n\
    \    $closing = array_pop($brackets);\n    if ($opening != $closing) {\n     \
    \ return false;\n    }\n  }\n  return true;\n}\n</code>\n<|/ a |>\n<| c |>\nI\
    \ actually think this is better than the accepted answer (from my perspective).\
    \ You don't have to keep track of opening and closing brackets, just test if one\
    \ is a prefix of the other.\n<|/ c |>\n<| a tags=regex,php |>\nHow about using\
    \ a stack? A stack is like a queue, but with two major differences:\n\nYou can\
    \ push onto the stack while popping from the stack (this is called a LIFO stack)\n\
    The last item popped off the stack will be your final result.\n\nFor example:\n\
    <code>\n<?php\n$string = \"<>\";\n\n$stack = [];\n$stack[] = $string;\n\nwhile\
    \ ($stack) {\n    $string = array_pop($stack);\n    if ($string === '<') {\n \
    \       $stack[] = '<';\n    }\n    if ($string === '>') {\n        $stack[] =\
    \ '>';\n    }\n}\n\nvar_dump($stack);\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ is brilliant, thank you. My only quiktion would be to ensure $string does not\
    \ get added to the stack twice, i.e. if $string == \"<\", $stack is [], and if\
    \ $string == \">\", $stack is [].\n<|/ c |>\n<| c |>\nThis solution doesn't work\
    \ when two or more consecutive opening and closing tags are found. For example,\
    \ `<><>`\n<|/ c |>\n<| a dscore=3 tags=regex,php |>\n<code>\n$string = \"<>\"\
    ;\n$string = \"<><><>\";\n$string = \"<><>\";\n$string = \"<>\";\n$string = \"\
    <>\";\n$string = \"<><>\";\n$string = \"<>\";\n$string = \"<>\";\n$string = \"\
    <>\";\n$string = \"<>\";\n$string = \"<>\";\n$string = \"<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "  if (preg_match(\"/<\\(([^<>]+)\\)>([^<>]+)<\\/\\1>/\", $brackets, $matches))\n\
    \    return $matches[1] == $matches[2];\n  else\n    return FALSE;\n}\n</code>\n\
    <|/ a tags=php,recursion,brackets |>\n<| a |>\n<code>", "\treturn preg_match(\"\
    /\\<\\<$brackets\\>\\>/\", $brackets);\n}\n", "  $open_brackets = preg_match_all(\"\
    /<([^>]+)(?=<)([^>]+>)/\", $brackets, $matches);\n  if (!$open_brackets) {\n \
    \   return false;\n  }\n  return array_pop($matches) == array_pop($open_brackets);\n\
    }\n", "\t$length = strlen($brackets);\n\tfor ($i = 0; $i < $length; $i++) {\n\t\
    \t$a = $brackets[$i];\n\t\t$b = $brackets[$i+1];\n\t\tif ($a !== $b) {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n", "    // Write your code here.\n\
    \    // Return the value.\n}\n\n/**\n * Return the number of opening brackets\
    \ in a given string.\n * >>> count_brackets(\"ab\")\n * 2\n * >>> count_brackets(\"\
    <ab>xyz\")\n * 4\n */", "    $open = substr_count($brackets, \"<\");\n    $close\
    \ = substr_count($brackets, \">\");\n    if ($open !== $close) {\n        return\
    \ false;\n    }\n    $pos = 0;\n    $open_brackets = array();\n    while ($pos\
    \ < strlen($brackets)) {\n        if ($brackets[$pos] === \"<\") {\n         \
    \   $open_brackets[] = $pos;\n        }\n        if ($brackets[$pos] === \">\"\
    ) {\n            $close_bracket = array_pop($open_brackets);\n            if ($close_bracket\
    \ === false) {\n                return false;\n            }\n        }\n    \
    \    $pos++;\n    }\n    $end_pos = $open_brackets[count($open_brackets) - 1];\n\
    \    if ($open_brackets !== array_slice($open_brackets, 0, $close)) {\n      \
    \  return false;\n    }\n    if ($brackets !== substr($brackets, $end_pos + 1))\
    \ {\n        return false;\n    }\n    return true;\n}\n", "    if (strpos($brackets,\
    \ \"<\") === false) return true;\n    $brackets_stack = array();\n    $brackets_stack[0]\
    \ = $brackets;\n    $brackets_stack_len = count($brackets_stack);\n    for ($i\
    \ = 1; $i < $brackets_stack_len; ++$i) {\n        if ($brackets_stack[$i] !==\
    \ substr($brackets_stack[$i - 1], 1, strlen($brackets_stack[$i - 1]))) return\
    \ true;\n        $brackets_stack[$i] = $brackets_stack[$i - 1];\n    }\n    return\
    \ false;\n}", "    $stack = array();\n    foreach ($brackets as $bracket) {\n\
    \        if (in_array($bracket, $stack)) {\n            // Closing bracket was\
    \ already seen. OK.\n        } else {\n            $stack[] = $bracket;\n    \
    \    }\n    }\n    return count($stack) == 0;\n}\n", "\t$brackets = explode(\"\
    <<\", $brackets);\n\t$correct = true;\n\tforeach ($brackets as $bracket) {\n\t\
    \tif ($bracket != \">\") {\n\t\t\t$correct = false;\n\t\t}\n\t}\n\treturn $correct;\n\
    }\n", "  global $brackets;\n  $opens = explode(\"<\", $brackets);\n  $closes =\
    \ explode(\">\", $brackets);\n  foreach ($opens as $key => $open) {\n    if (!isset($closes[$key]))\
    \ {\n      return false;\n    }\n    $openLen = strlen($open);\n    $closeLen\
    \ = strlen($closes[$key]);\n    if ($openLen != $closeLen) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "  // Handle the special case of the empty\
    \ string.\n  if (strlen($brackets) === 0) return false;\n  // Split on angle brackets.\n\
    \  $angle_brackets = explode('<', $brackets);\n  // Check each item of the array.\n\
    \  foreach ($angle_brackets as $item) {\n    if (strpos($item, '>') !== false)\
    \ return false;\n  }\n  // Split on brackets.\n  $brackets = explode('>', $brackets);\n\
    \  // Check each item of the array.\n  foreach ($brackets as $item) {\n    if\
    \ (strpos($item, '<') !== false) return false;\n  }\n  // Yes, they're all correct.\n\
    \  return true;\n}\n", "\t$bracketed = array();\n\t$bracket_depth = 0;\n\t$found\
    \ = false;\n\tfor ($i = 0; $i < strlen($brackets); $i++) {\n\t\t$bracket_char\
    \ = substr($brackets, $i, 1);\n\t\t$found_bracket = false;\n\t\tif ($bracket_char\
    \ == \"<\") {\n\t\t\tif ($bracket_depth == 0) {\n\t\t\t\t$found = true;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t\t$bracket_depth--;\n\t\t\t$found = false;\n\t\t} elseif\
    \ ($bracket_char == \">\") {\n\t\t\tif ($bracket_depth == 0) {\n\t\t\t\t$found\
    \ = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$bracket_depth++;\n\t\t\t$found = false;\n\
    \t\t} else {\n\t\t\tif ($bracket_depth == 0) {\n\t\t\t\t$bracketed[] = $bracket_char;\n\
    \t\t\t\t$found = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn $found;\n}\n", "    // \"\
    Aha!\" is a pattern that will match any non-empty string.\n    // See http://www.php-einfach.de/php/regular-expression-aufruf-zahlen.html\n\
    \    // for more information about regular expressions.\n    return preg_match('/^\\\
    s*?[^<>]*?$/', $brackets);\n}\n", "  $num_opens = count($brackets) - 1;\n  $num_closes\
    \ = count($brackets) - 2;\n  if ($num_opens < $num_closes)\n    return false;\n\
    \  else\n    return true;\n}\n", "  $brackets = explode(\"<\", $brackets);\n \
    \ foreach ($brackets as $key => $bracket) {\n    if ($bracket != '>') {\n    \
    \  $brackets[$key] = '>';\n    }\n  }\n  return $brackets == array_reverse($brackets);\n\
    }\n</code>\n<|/ a tags=php,html |>\n<| c |>\nThanks, but I don't need to check\
    \ validity, the code I have should already detect it before it gets anywhere near\
    \ the HTML code, correct?\n<|/ c |>\n<| c |>\nYes, that code will do that. Are\
    \ you asking how to do it with a regex?\n<|/ c |>\n<| c |>\nYes, I would like\
    \ to use a regex, but I have no idea how or where to begin. :)\n<|/ c |>\n<| a\
    \ dscore=0 |>\nI hope this would help you\n<code>\n$string = 'asdf<<><>><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "  // TODO: use regexps.\n  $correct_brackets = false;\n  if (strpos($brackets,\
    \ \"<\") === false) {\n    return $correct_brackets;\n  }\n  $opening_brackets\
    \ = explode(\"<\", $brackets);\n  for ($i = 0; $i < count($opening_brackets);\
    \ $i++) {\n    $opening_bracket = $opening_brackets[$i];\n    if (strpos($brackets,\
    \ \">\" . $opening_bracket . \">\") === false) {\n      return $correct_brackets;\n\
    \    }\n  }\n  return $correct_brackets;\n}\n</code>\n<|/ a dscore=1 tags=php,regex,xml\
    \ |>\n<| c |>\nThat's a nice solution. But it doesn't solve the problem of nested\
    \ brackets. It's OK for XML, but it can't parse HTML.\n<|/ c |>\n<| c |>\nIf it's\
    \ acceptable to have nested tags, this regex will work as intended. The `(?s)`\
    \ modifier makes . match newlines.\n<|/ c |>\n<| c |>\nI never said it should.\
    \ I am only saying that regex is not the best solution to parse XML.\n<|/ c |>\n\
    <| c |>\nThis is definitely the best answer for this problem. I don't understand\
    \ why it received so many downvotes. It's really clever. Thank you very much.\n\
    <|/ c |>\n<| a tags=php,regex,xml dscore=0 |>\nI would try something like this:\n\
    <code>\n$xml = '<a b=\"c\">d<e f=\"g\">h<i>i</i> j</e></a>';\n\n$regex = '~<\\\
    s*[^>]*>~';\n$xml = preg_replace_callback($regex, 'match', $xml);\n", "  $brackets\
    \ = explode(\"<\", $brackets);\n  foreach ($brackets as &$bracket) {\n    $opening\
    \ = strpos($bracket, \"<\");\n    $closing = strpos($bracket, \">\");\n    if\
    \ ($opening === false || $closing === false) {\n      return false;\n    }\n \
    \   $bracket = $closing + 1;\n  }\n  return true;\n}\n</code>\n<|/ a dscore=0\
    \ tags=php |>\n<| c |>\nThis doesn't work when the brackets are nested: `(<)<(<)<(<)<(<)<(<)>()<(<)>()<(<)>(>)`\n\
    <|/ c |>\n<| c |>\nSure. It returns true for every input I tested it with. I'll\
    \ update my answer to handle nested brackets.\n<|/ c |>\n<| c |>\nIt returns false\
    \ for me with that example. `function correct_bracketing($brackets) {\n  $brackets\
    \ = explode(\"<\", $brackets);\n  foreach ($brackets as &$bracket) {\n    $opening\
    \ = strpos($bracket, \"<\");\n    $closing = strpos($bracket, \">\");\n    if\
    \ ($opening === false || $closing === false) {\n      return false;\n    }\n \
    \   $bracket = $closing + 1;\n  }\n  return true;\n}`\n<|/ c |>\n<| a tags=php\
    \ |>\n<code>", "    // Loop through each character in the brackets string.\n \
    \   for($i = 0; $i < strlen($brackets); $i++) {\n        // If we find another\
    \ opening bracket, return false.\n        if($brackets[$i] == \"<\") {\n     \
    \       if($brackets[$i + 1] == \">\") {\n                return false;\n    \
    \        } else {\n                return true;\n            }\n        }\n  \
    \  }\n    // If we get here, we either found no brackets at all, or we found two\
    \ or more\n    // that don't match. Either way, return true.\n    return true;\n\
    }\n", "  return preg_match('/<([^<>]*<)*\\/([^<>]*<)*>/i', $brackets) === 1;\n\
    }\n</code>\n<|/ a tags=regex,php |>\n<| c |>\nThe bracketing rules are a little\
    \ different, e.g. `<><><>` should be false, but your solution would return true.\
    \ Also, it only works if the `<>` is at the beginning or end of the string.\n\
    <|/ c |>\n<| c |>\nI thought the only requirement was to return True if every\
    \ opening bracket has a corresponding closing bracket. I've added a regex that\
    \ would handle this requirement at the bottom of my answer. Let me know if that\
    \ works.\n<|/ c |>\n<| a |>\nTry this:\n<code>\n<?php\n$string = \"<> <>\";\n\
    $string = preg_replace('/<([^<]*)>/', '<$1> ', $string);\n$string = preg_replace('/<([^<]*)>/i',\
    \ '<$1> ', $string);\necho $string;", "    // The stack stores unmatched closing\
    \ brackets so that the program knows if\n    // it reached the end of a valid\
    \ substring.\n    $stack = array();\n    $lastChar = null;\n    $matches = array();\n\
    \    // The loop searches for unmatched opening and closing brackets. Each loop\
    \ is\n    // \"unmatched\" because the program doesn't know if there will be a\
    \ matching\n    // opening and closing bracket in the same substring. Once it\
    \ is \"unmatched\"\n    // it will never be matched again.\n    for ($i = 0; $i\
    \ < strlen($brackets); $i++) {\n        // The string that we are searching for\
    \ has an opening bracket at $i.\n        $string = $brackets;\n        // If the\
    \ opening bracket at $i is not the same as the previous character\n        //\
    \ then we can assume that we have found an unmatched opening bracket.\n      \
    \  if ($lastChar !== $brackets[$i]) {\n            $matches[] = $i;\n        }\n\
    \        // Add the opening bracket to our stack.\n        $stack[] = $brackets[$i];\n\
    \        // Set the current character as the next character.\n        $lastChar\
    \ = $brackets[$i];\n    }\n    // If we were unmatched then we are at the end\
    \ of the string.\n    if (empty($matches)) {\n        return true;\n    }\n  \
    \  // Iterate through each closing bracket in our stack and make sure that it\
    \ is\n    // on the same line as our matching opening bracket.\n    $j = 0;\n\
    \    for ($i = 0; $i < count($stack); $i++) {\n        // If the closing bracket\
    \ at this position is the same as the\n        // opening bracket then we are\
    \ at the end of the string and can return.\n        if ($stack[$i] === $matches[$j])\
    \ {\n            $j++;\n        }\n        // If this closing bracket is on a\
    \ different line then we are not on the\n        // correct line.\n        if\
    \ ($stack[$i] !== $brackets[$i]) {\n            return false;\n        }\n   \
    \ }\n    // If we were unmatched then we are at the end of the string.\n    if\
    \ ($j >= count($matches)) {\n        return true;\n    }\n    // If we were unmatched\
    \ then we are at the end of the string.\n    return ($j >= count($matches));\n\
    }\n", "\t$brackets = explode(\"<\", $brackets);\n\t$return = true;\n\tforeach\
    \ ($brackets as $key => $value) {\n\t\t$return = $return && ($key + 1 < count($brackets));\n\
    \t}\n\treturn $return;\n}\n", "    // If brackets is an empty string, return true\n\
    \    if ($brackets == \"\") {\n        return true;\n    }\n    // If brackets\
    \ is \"<<\", return false\n    if ($brackets == \"<<\") {\n        return false;\n\
    \    }\n    // If brackets is just \">\", return true\n    if ($brackets == \"\
    >\") {\n        return true;\n    }\n    // If brackets begins with \"<<<\", return\
    \ false\n    if ($brackets == \"<<<\") {\n        return false;\n    }\n    //\
    \ If brackets begins with \">>>\", return false\n    if ($brackets == \">>>\"\
    ) {\n        return false;\n    }\n    // Otherwise, return true\n    return true;\n\
    }", "    // Loop through brackets\n    foreach ($brackets as $b) {\n        if\
    \ ($b == '<') {\n            // If opening bracket is found with a closing bracket,\
    \ return false\n            if (isset($brackets[strpos($brackets, '>') + 1]))\
    \ {\n                return false;\n            }\n        } elseif ($b == '>')\
    \ {\n            // If closing bracket is found with an opening bracket, return\
    \ false\n            if (isset($brackets[strpos($brackets, '<') + 1])) {\n   \
    \             return false;\n            }\n        } else {\n            // Otherwise\
    \ return true\n            return true;\n        }\n    }\n    // If no brackets\
    \ are found, return true\n    return true;\n}\n", "    $level = 0;\n    for ($i\
    \ = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] == \"<\") {\n\
    \            $level++;\n        } else if ($brackets[$i] == \">\") {\n       \
    \     $level--;\n        }\n        if ($level < 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    $brackets = explode(\"<\", $brackets);\n\
    \    $brackets = array_reverse($brackets);\n    $brackets = array_filter($brackets,\
    \ function($e) {\n        return $e !== \"\";\n    });\n    foreach($brackets\
    \ as $b) {\n        if(!in_array($b, $brackets)) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    $brackets = explode('>', $brackets);\n\
    \    foreach ($brackets as $key => $bracket) {\n        $open = $brackets[$key-1];\n\
    \        $closed = $brackets[$key+1];\n        if ($open != $closed) {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n\n$bracketing =\
    \ \"<<><>><>\";\nif (correct_bracketing($bracketing)) {\n    echo \"Bracketing\
    \ is correct\";\n} else {\n    echo \"Bracketing is incorrect\";\n}", "    foreach($brackets\
    \ as $opening_bracket) {\n        $closing_brackets = array();\n        for($i\
    \ = 1; $i < strlen($brackets); $i++) {\n            if($brackets[$i] == $opening_bracket)\
    \ {\n                array_push($closing_brackets, $brackets[$i]);\n         \
    \   }\n        }\n        $result = count($closing_brackets) === count(array_unique($closing_brackets));\n\
    \        if(!$result) echo \"Bad bracketing: $opening_bracket\\n\";\n        return\
    \ $result;\n    }\n}\n", "    $opening_brackets = preg_match_all(\"/<+/\",$brackets);\n\
    \    $closing_brackets = preg_match_all(\"/>+/\",$brackets);\n    return $opening_brackets\
    \ === $closing_brackets;\n}\n", "\t$brackets = preg_replace(\"/ +/\",\" \", $brackets);\n\
    \tpreg_match_all('/<\\/?[^<>]+>/',$brackets,$matches);\n\treturn count($matches[0]);\n\
    }\n", "    if (strlen($brackets) <= 1) {\n        return false;\n    }\n\n   \
    \ for ($i = 0; $i < strlen($brackets) - 1; $i++) {\n        if ($brackets[$i]\
    \ == \"<\" && $brackets[$i + 1] == \">\") {\n            return true;\n      \
    \  }\n\n        if ($brackets[$i] == \"<\" && $brackets[$i + 1] == \"<\") {\n\
    \            return true;\n        }\n\n        if ($brackets[$i] == \">\" &&\
    \ $brackets[$i + 1] == \"<\") {\n            return true;\n        }\n\n     \
    \   if ($brackets[$i] == \"<\" && $brackets[$i + 1] == \">\") {\n            return\
    \ true;\n        }\n    }\n\n    return false;\n}\n", "  $stack = array();\n \
    \ $opening = array(\"(\",\")\",\"[\",\"]\",\"{\",\"}\",\"(\",\")\",\"[\",\"]\"\
    ,\"{\",\"}\",\"<\",\">\",\"<<\",\">>\",\"->\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\",\"->>\"\
    ,\"->>\",\"->>", "    $brackets_count = substr_count($brackets, \">\");\n    foreach\
    \ ($brackets_count as $b) {\n        if ($b != 1) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "    $brackets = explode(\"<<\", $brackets);\n\
    \    foreach ($brackets as $b) {\n        if (substr($b, -2) !== \">>\") {\n \
    \           return false;\n        }\n    }\n    return true;\n}\n", "  $len =\
    \ strlen($brackets);\n  for ($i = 0; $i < $len; ++$i) {\n    $c = $brackets[$i];\n\
    \    // This logic could be simplified if we knew that the opening and closing\
    \ brackets\n    // were always the same type.\n    if ($c === \"<\" && substr($brackets,\
    \ $i + 1, 1) === \">\") {\n      $i++;\n    }\n    if ($c === \">\" && substr($brackets,\
    \ $i - 1, 1) === \"<\") {\n      $i--;\n    }\n  }\n  return $i === 0;\n}\n",
  "  for ($i = 0; $i < strlen($brackets); $i++) {\n    $opening_bracket = substr($brackets,\
    \ $i, 1);\n    $closing_bracket = substr($brackets, $i, 1);\n    if ($opening_bracket\
    \ != $closing_bracket) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "    // initialize variables to hold information about opening/closing brackets\n\
    \    $open_brackets = array();\n    $close_brackets = array();\n\n    // iterate\
    \ over the brackets and check for correct formatting\n    foreach ($brackets as\
    \ $bracket) {\n        // only check for brackets at start and end\n        if\
    \ ($bracket == \"<\") {\n            if (!array_key_exists($bracket, $open_brackets))\
    \ {\n                return false;\n            }\n        }\n\n        if ($bracket\
    \ == \">\") {\n            if (!array_key_exists($bracket, $close_brackets)) {\n\
    \                return false;\n            }\n        }\n\n        // if brackets\
    \ are correctly formatted, add it to the list of opening/closing brackets\n  \
    \      $open_brackets[$bracket] = true;\n        $close_brackets[$bracket] = true;\n\
    \    }\n\n    // return true if every opening bracket has a corresponding closing\
    \ bracket\n    // OR if brackets are correctly formatted\n    return count($open_brackets)\
    \ == count($close_brackets);\n}\n</code>\n<|/ a dscore=3 tags=regex,php |>\n<|\
    \ c |>\nThis works great, thank you very much. Just one more question about your\
    \ function. I know this might be a bit obvious, but I'm still learning the ropes\
    \ of PHP and I'm a bit confused about how the function works. When you say \"\
    return true if every opening bracket has a corresponding closing bracket\", does\
    \ this mean that if an opening bracket is not closed, it automatically returns\
    \ false? Also, what exactly does the line \"$open_brackets[$bracket] = true;\"\
    \ do? Also, does it matter if brackets are inside of double quotes? Thanks again\
    \ for your help.\n<|/ c |>\n<| c |>\nCorrect. An opening bracket is closed by\
    \ setting a corresponding closing bracket to true. When you say \"does this mean\
    \ that if an opening bracket is not closed, it automatically returns false\",\
    \ then yes - if an opening bracket is not closed, it automatically returns false.\
    \ The line `$open_brackets[$bracket] = true;` simply sets a key in the array for\
    \ each opening bracket, i.e. each opening bracket has a corresponding closing\
    \ bracket. Without the `= true;` part, PHP would just set `$open_brackets[$bracket]`\
    \ with whatever the value was - which would be the closing bracket in this case.\n\
    <|/ c |>\n<| c |>\nAs for double quotes, it doesn't really matter. As long as\
    \ your brackets are surrounded by opening and closing brackets, it shouldn't matter\
    \ whether or not they are in double quotes. You could always try removing them\
    \ and see how it works :)\n<|/ c |>\n", "  // Remove leading and trailing whitespace,\
    \ and convert $brackets to lower case.\n  $brackets = trim($brackets);\n  $brackets\
    \ = strtolower($brackets);\n\n  // If no brackets found, return false.\n  if ($brackets\
    \ === '<') {\n    return false;\n  }\n  else if ($brackets === '>') {\n    return\
    \ false;\n  }\n\n  // Loop through brackets, adding opening brackets until you\
    \ reach a closing bracket.\n  $open_bracket = '';\n  $closed_bracket = false;\n\
    \  foreach ($brackets as $bracket_char) {\n    // Add a closing bracket if it\
    \ hasn't been added yet.\n    if (!$closed_bracket) {\n      $open_bracket .=\
    \ $bracket_char;\n      continue;\n    }\n\n    // Otherwise, check if the current\
    \ opening bracket matches the closing bracket.\n    if ($open_bracket === $bracket_char)\
    \ {\n      $open_bracket = '';\n      $closed_bracket = true;\n    }\n  }\n\n\
    \  // Make sure you aren't missing any brackets.\n  return $closed_bracket;\n}",
  "    for($i = 0; $i < strlen($brackets); $i++) {\n        if($brackets[$i] != \"\
    <\") return false;\n    }\n    for($i = strlen($brackets) - 1; $i >= 0; $i--)\
    \ {\n        if($brackets[$i] != \">\") return false;\n    }\n    return true;\n\
    }\n", "  $opening_brackets = str_split($brackets);\n  $closing_brackets = array_diff($opening_brackets,\
    \ ['<', '>']);\n  return !empty($closing_brackets);\n}\n", "  global $pairwise;\n\
    \  $open_brackets = preg_match_all(\"/<[\\/]*>/g\", $brackets);\n  return ($open_brackets\
    \ == $pairwise->count);\n}\n", "    $open_brackets = array_filter(explode(\"<\"\
    , $brackets));\n    $closed_brackets = array_filter(explode(\">\", $brackets));\n\
    \    foreach($open_brackets as $i => $open_bracket) {\n        if (!isset($closed_brackets[$i]))\
    \ {\n            return false;\n        }\n        if ($open_bracket[0] != \"\
    <\") {\n            return true;\n        }\n        if ($closed_brackets[$i]\
    \ != \">\") {\n            return true;\n        }\n    }\n    // If no brackets\
    \ are unmatched, then brackets are balanced.\n    return false;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhy are you using `array_filter()` and then iterating\
    \ the result? Just use `in_array()` and be done.\n<|/ c |>\n<| c |>\n`array_filter()`\
    \ returns an array of matching elements. You then use `foreach` to loop through\
    \ them, which iterates through them one at a time. `in_array()` is probably a\
    \ better way to write this. And you're right, there's no need for `foreach`, just\
    \ use `in_array()`.\n<|/ c |>\n<| a tags=php |>\nYou are not considering escaped\
    \ < and > characters, so you need to consider them too.\n<code>", "    $opening\
    \ = array_filter(explode(\"<\", $brackets), function($v) { return $v != \"\";\
    \ });\n    $closing = array_filter(explode(\">\", $brackets), function($v) { return\
    \ $v != \"\"; });\n    return count($opening) == count($closing);\n}\n</code>\n\
    <|/ a tags=php dscore=2 |>\n<| a |>\nThis question is a bit old, but here is my\
    \ attempt at solving this same problem. While the other answers here have some\
    \ potential for efficiency, this implementation does not require you to have your\
    \ HTML stored as a string and does not require you to parse or clean the HTML\
    \ or CSS.\nFirst, you would have to create a function to return the correct closing\
    \ bracket. Let's call this the correct closing bracket:\n<code>", "  // Remove\
    \ any whitespace.\n  $brackets = preg_replace(\"/\\s+/\", \"\", $brackets);\n\
    \  // Remove any punctuation.\n  $brackets = preg_replace(\"/[\\.,;:\\[\\]]/\"\
    , \"\", $brackets);\n  // Remove any double brackets.\n  $brackets = preg_replace(\"\
    /(\\[|\\])/\", \"\", $brackets);\n  // Remove any empty brackets.\n  $brackets\
    \ = preg_replace(\"/(\\[|\\])/\", \"\", $brackets);\n  // Remove any single brackets.\n\
    \  $brackets = preg_replace(\"/(\\[|\\])/\", \"\", $brackets);\n  // Remove any\
    \ open brackets with no corresponding closing bracket.\n  // >>> correct_bracketing(\"\
    [\")\n  // True\n  // >>> correct_bracketing(\"[]\")\n  // True\n  // >>> correct_bracketing(\"\
    [[]\")\n  // False\n  // >>> correct_bracketing(\"[[]]<<><>>\")\n  // True\n \
    \ // >>> correct_bracketing(\"[[]]<<><>>\")\n  // False\n  if ($brackets === \"\
    []\" || $brackets === \"[]\") {\n    return false;\n  }\n  // Remove any open\
    \ brackets with no corresponding closing bracket.\n  // >>> correct_bracketing(\"\
    [<\")\n  // False\n  // >>> correct_bracketing(\"[<[<\")\n  // False\n  // >>>\
    \ correct_bracketing(\"[<[<[<\")\n  // False\n  // >>> correct_bracketing(\"[<[<[<[<\"\
    )\n  // False\n  // >>> correct_bracketing(\"[<[<[<[<[<\")\n  // False\n  // >>>\
    \ correct_bracketing(\"[<[<[<[<[<[<[<\")\n  // True\n  // >>> correct_bracketing(\"\
    [<[<[<[<[<[<[<[<[<\")\n  // True\n  // >>> correct_bracketing(\"[<[<[<[<[<[<[<[<[<[<[<[<\"\
    )\n  // True\n  // >>> correct_bracketing(\"[<[<[<[<[<[<[<[<[<[<[<[<[<\")\n  //\
    \ True\n  // >>> correct_bracketing(\"[<[<[<[<[<[<[<[<[<[<[<[<[<[<[<\")\n  //\
    \ True\n  // >>> correct_bracketing(\"[<[<[<[<[<[<[<[<[<[<[<[", "  return preg_match(\n\
    \    \"/(^|\\s)[$brackets]($|\\s|\\W)/\", $brackets, $matches);\n}", "  return\
    \ preg_match('/<(\\w+)>/', $brackets, $matches);\n}\n", "\t$count = 0;\n\t$brackets\
    \ = explode(\"<\", $brackets);\n\tforeach ($brackets as $b) {\n\t\t$c =- 1;\n\t\
    \twhile ($c >= 0) {\n\t\t\tif ($brackets[$c] == $b) {\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t\tif ($brackets[$c] == \">\" && $b == \">\") {\n\t\t\t\t$count++;\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\tif ($brackets[$c] == \">\" && $b == \"<\") {\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t\t$c--;\n\t\t}\n\t}\n\treturn $count == count($brackets)\
    \ / 2;\n}\n", "  $brackets = preg_replace('/<$/', '', $brackets);\n  return preg_match('/^\\\
    </', $brackets);\n}\n", "    $brackets = explode(\"<\", $brackets);\n    foreach($brackets\
    \ as $i => $b) {\n        // each opening bracket should be followed by one or\
    \ more\n        // closing brackets and vice versa\n        $c = $i + 1 < count($brackets)\
    \ ? $i + 1 : 0;\n        $ops = array(\">\", \"<\");\n        $cOps = array(\"\
    <<\", \"<\");\n        if($ops[$b] != $brackets[$c]) continue;\n        if($cOps[$brackets[$c]]\
    \ == $brackets[$b]) return true;\n    }\n    return false;\n}\n\n$string = \"\
    <html><head><title>Test</title></head><body><p>This is a <b style=\\\"color:red\\\
    \">test</b></p></body></html>\";\n$parsed = parse_html($string);\n", "  $brackets_array\
    \ = explode(\" \", $brackets);\n  $opening_brackets = array();\n  $closing_brackets\
    \ = array();\n  foreach ($brackets_array as $bracket) {\n    if (substr($bracket,\
    \ 0, 1) === \"<\") {\n      $opening_brackets[] = $bracket;\n    }\n    else {\n\
    \      $closing_brackets[] = $bracket;\n    }\n  }\n  return !empty($opening_brackets)\
    \ && !empty($closing_brackets);\n}", "  $brackets_count = substr_count($brackets,\
    \ '<');\n  \n  for ($i = 0; $i < $brackets_count; $i++) {\n    if (substr_count($brackets,\
    \ '<' . $brackets[$i] . '>') < 1) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n", "    // Your code here.\n}\n", "  $opening = strpos($brackets,\
    \ \"<\");\n  $closing = strpos($brackets, \">\");\n  return $opening !== false\
    \ && $closing !== false && $opening - $closing === 1;\n}\n</code>\n<|/ a tags=python,javascript,php\
    \ dscore=1 |>\n<| c |>\nVery nice, but this doesn't handle the case where `<`\
    \ and `>` aren't next to each other.\n<|/ c |>\n<| c |>\nThis doesn't handle `<<><>>`\
    \ correctly.\n<|/ c |>\n<| c |>\nI made some changes to allow for that.  Thanks\
    \ for catching it!\n<|/ c |>\n<| c |>\nThis now handles `<<><>>` correctly.\n\
    <|/ c |>\n<| a dscore=0 tags=python,javascript,php |>\nI made this in javascript\
    \ :\n<code>", "  // Your code here\n  foreach (explode(\"<\", $brackets) as $key\
    \ => $value) {\n    if ($key < count($brackets) - 1) {\n      if ($value != \"\
    <\" && $value != \">\") {\n        return false;\n      }\n    }\n  }\n  return\
    \ true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=php dscore=0 |>\nWhat about\
    \ something like:\n<code>", "  $stack = array();\n  $bracketCount = substr_count($brackets,\
    \ '<>');\n  for ($i = 0; $i < $bracketCount; $i++) {\n    $char = substr($brackets,\
    \ $i, 1);\n    // If this bracket is escaped, it is part of a larger expression\n\
    \    if ($char == '\\\\') {\n      $closingBracket = array_pop($stack);\n    \
    \  $openingBracket = array_pop($stack);\n      if ($closingBracket == '<' && $openingBracket\
    \ == '>') {\n        // We have a valid closing bracket and opening bracket\n\
    \        $stack[] = $char;\n      } else { // We have invalid closing bracket\n\
    \        return false; // False means that we have unclosed brackets\n      }\n\
    \    } else { // If this bracket is unescaped, it is part of a larger expression\n\
    \      $stack[] = $char;\n    }\n  }\n\n  // If we get here, we are left with\
    \ an empty stack.\n  // We need to return false\n  return empty($stack);\n}\n\n",
  "  // Write your code here.\n}", "  // Split the brackets into an array and sort\
    \ it.\n  $brackets = explode(\">\", $brackets);\n  sort($brackets);\n\n  // If\
    \ the first element of the array is not \">\", then there were no brackets.\n\
    \  if ($brackets[0] != \">\") {\n    return false;\n  }\n\n  // If the last element\
    \ of the array is not \"<\", then there were no brackets.\n  if ($brackets[count($brackets)\
    \ - 1] != \"<\") {\n    return false;\n  }\n\n  // Loop through the array and\
    \ see if each element has matching opening and closing brackets.\n  for ($i =\
    \ 1; $i < count($brackets); $i++) {\n    if ($brackets[$i] == $brackets[$i - 1])\
    \ {\n      // The brackets match.\n    } else {\n      // The brackets do not\
    \ match.\n      return false;\n    }\n  }\n\n  // All brackets are matched!\n\
    \  return true;\n}", "    $stack = array();\n    $inside_pair = false;\n    $opening\
    \ = str_repeat($brackets, 1);\n    $closing = str_repeat($brackets, -1);\n   \
    \ $count = count($brackets);\n    for ($i = 0; $i < $count; $i++) {\n        $c\
    \ = $brackets[$i];\n        if ($c == \"<\" || $c == \">\") {\n            $stack[]\
    \ = $c;\n        } else {\n            if ($inside_pair && $c == \"(\") {\n  \
    \              $inside_pair = false;\n            } elseif (!$inside_pair && $c\
    \ == \")\") {\n                $inside_pair = true;\n                if (empty($stack))\
    \ {\n                    // Found the last closing bracket\n                 \
    \   break;\n                }\n            } elseif ($inside_pair && $c == $closing[$i])\
    \ {\n                $stack[] = $c;\n            } elseif (!$inside_pair) {\n\
    \                // Opening bracket without closing bracket, not a syntax error.\n\
    \                // Therefore, assume that the bracketing was correct.\n     \
    \           $inside_pair = false;\n            }\n        }\n    }\n    return\
    \ empty($stack);\n}\n", "  // Write your code here.\n  for($i = 0; $i < strlen($brackets);\
    \ $i++){\n    $opening_bracket = substr($brackets, $i, 1);\n    $next_opening_bracket\
    \ = substr($brackets, $i + 1, 1);\n    if($next_opening_bracket != \"\" && $opening_bracket\
    \ != \">\" && $opening_bracket != \"<\"){\n      return false;\n    }\n  }\n \
    \ return true;\n}\n", "  $brackets_set = array_flip(str_split($brackets));\n \
    \ $input_set = array_flip(str_split($input));\n\n  foreach ($input_set as $i =>\
    \ $letter) {\n    if (array_key_exists($letter, $brackets_set)) {\n      if ($brackets_set[$letter]\
    \ !== $input_set[$i]) {\n        return false;\n      }\n    }\n  }\n  return\
    \ true;\n}", "\tfor ($i = 0; $i < strlen($brackets); $i++) {\n\t\tif ($brackets[$i]\
    \ !== '<' && $brackets[$i] !== '>') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn\
    \ true;\n}\n", "    $open_brackets = array();\n    $closed_brackets = array();\n\
    \    for ($i = 0; $i < strlen($brackets); $i++) {\n        if ($brackets[$i] ==\
    \ \"<\") {\n            if (empty($open_brackets)) {\n                return false;\n\
    \            }\n            $open_brackets[count($open_brackets) - 1]++;\n   \
    \     } else {\n            $closed_brackets[count($closed_brackets) - 1]++;\n\
    \        }\n    }\n    for ($i = 0; $i < count($open_brackets); $i++) {\n    \
    \    if ($open_brackets[$i] != $closed_brackets[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=brackets,php,regex,python,string\
    \ dscore=2 |>\n<| a dscore=0 |>\nI solved this problem by writing this simple\
    \ regex to find and replace pairs of brackets. It is based on this answer: https://stackoverflow.com/a/13481113/1067371\n\
    The code is not perfect and probably could be improved, but this is the best solution\
    \ I could find.\nThe code:\n<code>\n$input = \"<<<\"; // Input string\n", "  $stack\
    \ = array();\n  foreach ($brackets as $char) {\n    if ($char === '<') {\n   \
    \   $stack[] = $char;\n    } else if ($char !== '>') {\n      return false;\n\
    \    }\n  }\n  return count($stack) === 0;\n}\n", "  global $brackets;\n\n  if\
    \ (!is_string($brackets)) return false;\n\n  $brackets = explode(\"<>\", $brackets);\n\
    \n  foreach ($brackets as $b) {\n    if ($b !== substr($brackets, 0, $i)) {\n\
    \      return false;\n    }\n    $i = $i + 1;\n  }\n\n  return true;\n}", "  \
    \  if (strlen($brackets) < 1 || strlen($brackets) > 2)\n        return false;\n\
    \n    for ($i = 0; $i < strlen($brackets); $i++) {\n        $left = substr($brackets,\
    \ 0, $i);\n        $right = substr($brackets, $i, 1);\n        if ($left != '>'\
    \ && $left != '<' && $left != '>>' && $left != '<<')\n            return false;\n\
    \        if ($right != '>' && $right != '<' && $right != '>>' && $right != '<<')\n\
    \            return false;\n    }\n\n    return true;\n}\n", "  preg_match_all(\"\
    /(\\<|\\>)\\/\", $brackets, $matches);\n  return !empty($matches[0]);\n}\n", " \
    \   $openings = array();\n    $closings = array();\n    foreach ($brackets as\
    \ $i => $char) {\n        if ($char == '<') {\n            $openings[] = $i;\n\
    \        } else {\n            $closings[] = $i;\n        }\n    }\n\n    return\
    \ array_sum($closings) == count($openings);\n}\n</code>\n<|/ a dscore=5 tags=php,parsing,html,regex\
    \ |>\n<| c |>\nthank you for the answer. Your solution doesn't work with, e.g.,\
    \ \"<<><>>\", but it seems to be the most elegant and flexible solution so far.\
    \ Do you know which regex engine PHP uses?\n<|/ c |>\n<| c |>\nI tested it on\
    \ [regex 101](https://regex101.com/r/5yZYlO/1), and it seemed to work. I'll test\
    \ it out again and get back to you.\n<|/ c |>\n<| c |>\nThe one in PHP is probably\
    \ not optimized for that kind of regex.\n<|/ c |>\n<| c |>\nAh, I didn't see that\
    \ they were using PCRE. That's interesting.\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it turns out that it's indeed PCRE that performs the regex operation. https://3v4l.org/0P3j4\n\
    <|/ c |>\n<| a tags=php,parsing,html,regex |>\nAs a complement to answer, I wanted\
    \ to show how one could parse a whole HTML document without having to use regex.\
    \ \n<code>\n$dom = new DOMDocument();\n$dom->loadHTML($html);\n\n$xpath = new\
    \ DOMXPath($dom);\n$elements = $xpath->query('//body/descendant::h1/following-sibling::p[count(*)\
    \ = 0]');\n$text = [];\nforeach ($elements as $element) {\n    $text = implode('\
    \ ', $element->childNodes);\n}\n", "  $brackets = preg_replace('!<', '!\\\\<',\
    \ $brackets);\n  $brackets = preg_replace('/!\\\\>!', '!>\\\\>', $brackets);\n\
    \  return preg_match('!^!', $brackets);\n}\n", "  for ($i = 0; $i < strlen($brackets);\
    \ $i++) {\n    $match = $brackets[$i];\n    if ($match !== \"<\" && $match !==\
    \ \">\") {\n      return false;\n    }\n  }\n  return true;\n}", "    foreach\
    \ (explode(\"<\", $brackets) as $key => $value) {\n        if ($value === '<')\
    \ {\n            $brackets = str_replace($value, '>', $brackets);\n        }\n\
    \    }\n    return ($brackets === '<>');\n}\n", "  for ($i = 0; $i < strlen($brackets)\
    \ - 1; $i++) {\n    $opening = substr($brackets, 0, $i + 1);\n    $closing = substr($brackets,\
    \ $i + 1);\n    if ($opening != $closing) {\n      return false;\n    }\n  }\n\
    \  return true;\n}\n", "  $brackets_arr = explode(\"<>\", $brackets);\n  foreach\
    \ ($brackets_arr as $pair) {\n    if (!preg_match('([<>])\\1', $pair)) {\n   \
    \   return false;\n    }\n  }\n  return true;\n}\n", "    $openers = preg_split('/(?<!^)(?!$)/',\
    \ $brackets);\n    $correct_brackets = array_fill(0, count($openers), 0);\n  \
    \  $correct_brackets = array_fill_keys($correct_brackets, 0);\n    $i = 0;\n \
    \   foreach ($openers as $opener) {\n        $closed = false;\n        for ($j\
    \ = 0; $j < count($openers); $j++) {\n            if ($opener == $openers[$j])\
    \ {\n                $correct_brackets[$j] += 1;\n                $closed = true;\n\
    \            }\n        }\n        if ($closed) {\n            $i++;\n       \
    \ }\n    }\n    $missing_brackets = array_fill(0, $i, 0);\n    for ($j = 0; $j\
    \ < count($openers); $j++) {\n        if ($correct_brackets[$j] > 0) {\n     \
    \       $missing_brackets[$j] = count($openers) - $j;\n        }\n    }\n    return\
    \ $missing_brackets == array_fill(0, count($openers), 0);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=php,parsing,algorithm dscore=0 |>\nI'm sure that this is not the\
    \ most efficient solution, but it should be easy to follow. If I missed something\
    \ (I don't), please let me know.\n<code>\n<?php", "  // We only want to do this\
    \ for brackets that are not escaped.\n  if (!preg_match(\"~([<>])~\", $brackets))\
    \ {\n    return false;\n  }\n  // We only want to do this if the brackets are\
    \ contiguous.\n  if (preg_match(\"~^[<>]*$~\", $brackets)) {\n    return false;\n\
    \  }\n  // We only want to do this if the brackets are adjacent.\n  if (preg_match(\"\
    ~^.+[<>]~\", $brackets)) {\n    return false;\n  }\n  // We only want to do this\
    \ if there are no openers or closers in the brackets.\n  if (preg_match(\"~^(?:[<>]|$)~\"\
    , $brackets)) {\n    return false;\n  }\n  return true;\n}\n</code>\n<|/ a tags=algorithm,perl,python\
    \ |>\n<| c |>\nI like the elegance of your code, but doesn't work if the brackets\
    \ are like <<>>. I don't think that's what the OP wants, but the OP may clarify.\n\
    <|/ c |>\n<| c |>\nThat is also not what the OP wants. But thank you for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nIt doesn't work with <<>>, but I think it does\
    \ with <<<>>> (which I assume is a valid use case).\n<|/ c |>\n<| c |>\nThe OP\
    \ wants <<><>> to evaluate to False, but your solution evaluates to True. That's\
    \ not what the OP wants, but the OP may clarify. Btw, I don't see any advantage\
    \ to using regex over string methods. It's just confusing and unreadable.\n<|/\
    \ c |>\n<| c |>\nI agree with you that string methods are cleaner, but they are\
    \ much less powerful.  Since you're only dealing with two simple cases (brackets),\
    \ that hardly matters.  Regex can get complicated, and is often more powerful\
    \ than string methods.  My answer was a quick fix and doesn't attempt to solve\
    \ the problem in a more elegant way.  But maybe I should have left my answer unchanged\
    \ since a more elegant solution may come up in the future.  I didn't feel like\
    \ writing it myself because I thought the OP would learn from my answer anyway.\n\
    <|/ c |>\n<| a |>\nYou do not need regex.  Try this Perl one-liner\n<code>\nperl\
    \ -0777 -ne 'print  ! /\\G</ && print /</ && print />/ && print /></ && print\
    \ />/>/' file\n</code>\n<|/ a dscore=0 tags=algorithm,per", "  $opening_brackets\
    \ = explode(\"<\", $brackets);\n  $closing_brackets = explode(\">\", $brackets);\n\
    \  foreach ($opening_brackets as $key => $opening_bracket) {\n    if ($opening_bracket\
    \ == $closing_brackets[$key]) {\n      $opening_brackets = array_slice($opening_brackets,\
    \ 0, $key);\n      $opening_brackets[] = $opening_bracket;\n    }\n  }\n  return\
    \ count(array_unique($opening_brackets)) == count($opening_brackets);\n}\n</code>\n\
    <|/ a tags=codeigniter,php |>\n<| c |>\nI didn't try it, but I'm guessing it's\
    \ going to be slower than my answer.\n<|/ c |>\n<| c |>\nThank you very much for\
    \ the detailed answer, it works! I still wonder though, how would I go about doing\
    \ this on multiple arrays of different length? Do I have to create a new foreach\
    \ loop?\n<|/ c |>\n<| c |>\nI've added a solution that does it for two arrays\
    \ of different lengths.\n<|/ c |>\n<| c |>\nNice one! Thank you for the great\
    \ solution, I have one last question though, how would I go about doing this with\
    \ a foreach loop in a foreach loop? Like the example I just posted in the original\
    \ post?\n<|/ c |>\n<| c |>\nI added a foreach to my answer.\n<|/ c |>\n<| a |>\n\
    Here's a one-liner, without loops (and possibly with a little more performance):\n\
    <code>\n$brackets = \"<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "    $brackets = explode(\"<\", $brackets);\n    $correct_bracketing = false;\n\
    \    foreach ($brackets as $key => $value) {\n        $bracket = substr($value,\
    \ 1);\n        if (!isset($brackets[$key + 1])) {\n            $correct_bracketing\
    \ = true;\n        }\n    }\n    return $correct_bracketing;\n}\n", "  $opening_brackets\
    \ = array_diff(explode(\"<>\", $brackets), array(\"<\"));\n  $closing_brackets\
    \ = array_diff(explode(\"<<>>\", $brackets), array(\">\"));\n\n  return !empty($opening_brackets)\
    \ && !empty($closing_brackets);\n}\n\n/**\n * Finds the line number corresponding\
    \ to a text position relative to a file.\n * This is useful for debugging.\n *\n\
    \ * @param $text   The text to examine.\n * @param $file   The filename whose\
    \ line the text position relative to.\n * @param $pos    The text position relative\
    \ to the file.\n * @return       The line number of the text position.\n */",
  "  $brackets = preg_replace('/<<>|<>>/', '', $brackets);\n  return strlen($brackets)\
    \ % 2 == 0;\n}\n</code>\n<|/ a |>\n<| c |>\nI'm sorry but I do not understand\
    \ how this works.\n\nWhat does it mean to match <<< and >>>? And why does it only\
    \ match one level deep?\n\nI suppose that means <<< is just \"<<\" and >>> is\
    \ just \">>\"?\n<|/ c |>\n<| c |>\n`<<<` and `>>>` are **not** just `<<` and `>>`.\
    \ They are **not** `<<` and `>>`. They are `<` and `>`.\n<|/ c |>\n<| c |>\nThank\
    \ you for your explanation. I understand now. I did not know that <<< is equal\
    \ to <\n<|/ c |>\n<| c |>\n: Yes, that's how you type `<` in HTML. The `<<` just\
    \ means `<`, not `<<`. The `<<<` just means `<`. The `>>>` just means `>`. The\
    \ `<<<` just means `<`.\n<|/ c |>\n<| c |>\n: I just updated my answer to show\
    \ how it might help you. Hopefully this helps you in your situation!\n<|/ c |>\n\
    <| a tags=regex,php dscore=2 |>\nUse this regex:\n<code>\n/<\\w.*?>[<>]<\\w.*?>[<>]/\n\
    </code>\n<|/ a |>\n<| c |>\nThis regex does not allow unescaped brackets like\
    \ `<>`\n<|/ c |>\n<| a dscore=1 tags=regex,php |>\nIt seems to me that if you\
    \ have to use regular expressions, you should probably use a context-free grammar\
    \ parser, such as PLY.\n<code>", "  $opening = substr($brackets, 0, 1);\n  $closing\
    \ = substr($brackets, -1);\n  if ($opening !== $closing) {\n    return false;\n\
    \  }\n  $opening = substr($brackets, 0, 1);\n  $closing = substr($brackets, 1);\n\
    \  if ($opening !== $closing) {\n    return false;\n  }\n  return true;\n}", " \
    \ return preg_match(\"/<([^>]+)>/\", $brackets);\n}\n", "    $opening_brackets\
    \ = array();\n    $closing_brackets = array();\n    foreach (preg_split('/(<\\\
    /?[a-z]+[^>]*>)/', $brackets) as $opening) {\n        if ($opening == '<') {\n\
    \            $opening_brackets[] = $opening;\n        } else {\n            $closing_brackets[]\
    \ = $opening;\n        }\n    }\n    $correct = (count($opening_brackets) == count($closing_brackets));\n\
    \    return $correct;\n}\n", "    $brackets_open = explode(\"<\", $brackets);\n\
    \    $brackets_close = explode(\">\", $brackets);\n    $num_open = count($brackets_open);\n\
    \    $num_close = count($brackets_close);\n    for($i = 0; $i < $num_open; $i++)\
    \ {\n        if($brackets_close[$i] != $brackets_open[$i]) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 tags=php,string,algorithm,arrays\
    \ |>\n<| c |>\nHmm, I'm curious about your use of the `array_search` function.\
    \  I haven't used that before, but it doesn't seem to be doing what I expect.\
    \  Maybe you could explain how it works?\n<|/ c |>\n<| c |>\n`array_search` searches\
    \ the array for a value.  It returns the key of the first match it finds.  So\
    \ we search for the first opening bracket and if it's not a closing bracket we\
    \ know we're at the end of a set of brackets.\n<|/ c |>\n<| a tags=php,string,algorithm,arrays\
    \ |>\nIt seems you want a regex solution. Check out the comments for explanation:\n\
    <code>\n<?php", "  return preg_match_all('/(<[<>])/', $brackets) > 0;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\n+1 This is great for me. I had never heard of the\
    \ regex functions like `preg_match()` before. Thanks!\n<|/ c |>\n<| c |>\n+1 Awesome,\
    \ i used a similar regex to solve this issue, however, I noticed that for my specific\
    \ issue, there were times where the closing bracket was missing, for example:\
    \ `<` `<p` `<p id=\"blah\">` `<p id=\"blah\"><p>` `<p id=\"blah\"></p><p>` `<p><p\
    \ id=\"blah\"></p></p>`\n<|/ c |>\n<| c |>\nThis is not the answer to the question\
    \ asked. Plus, how would you extend this solution if there are more characters\
    \ in brackets than just `<` and `>`?\n<|/ c |>\n<| c |>\nIt depends on what your\
    \ goal is. If it were for a situation where you needed to count how many `<` and\
    \ `>` were in the string, you could use a `preg_match_all` of `/(<[<>]*)([<>]*>)/`\
    \ and count the number of matches. `preg_match_all` returns the number of times\
    \ that it found a match in a string. Using your example: `preg_match_all('/(<[<>]*)([<>]*>)/',\
    \ $str, $matches);\n$opening_brackets = count($matches[1]);\n$closing_brackets\
    \ = count($matches[2]);`\n<|/ c |>\n<| c |>\nI'm sorry, I do not understand what\
    \ you mean.\n<|/ c |>\n<| a dscore=5 |>\nI believe this is what you are looking\
    \ for.\n<code>\n<?php\n$string = \"foo<bar<foo>\";\n\n$matches = preg_split('/(<[^>]+>)/',\
    \ $string);\n\n$opening_brackets = count($matches[0]);\n\necho 'Opening brackets:\
    \ ' . $opening_brackets . \"\\n\";\necho 'Closing brackets: ' . ($opening_brackets\
    \ - 1) . \"\\n\";", "  $brackets = str_split($brackets);\n  for ($i = 0; $i <\
    \ count($brackets); $i++) {\n    if ($brackets[$i] !== \"<\" && $brackets[$i]\
    \ !== \">\") {\n      return false;\n    }\n  }\n  return true;\n}\n", "  return\
    \ preg_match('/<[^<>]*>/', $brackets) === 1;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the answer. I am looking for something to handle edge cases as well.\
    \ For example, it does not work for \"<<><>>\".\n<|/ c |>\n<| c |>\n: Please see\
    \ my edits. I've added a function that will correctly handle edge cases.\n<|/\
    \ c |>\n<| a tags=regex,php |>\nA regex based solution will be too slow, but you\
    \ can try using strpos() to find the indices of each bracket pair and check if\
    \ they're next to each other:\n<code>\nif (preg_match('/\\<\\<+.*?\\>\\>/', $string))\
    \ {\n    // Do something\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the\
    \ answer. I am looking for something to handle edge cases as well. For example,\
    \ it does not work for \"<<><>>\".\n<|/ c |>\n<| c |>\n- I see, you accepted an\
    \ answer that works just fine with edge cases, just not in the way you described\
    \ it. But if you do need more performance for your project, consider implementing\
    \ one of the other solutions (especially if you can do it with PCRE, rather than\
    \ a custom regex), since `strpos()` can easily get pretty slow for large strings,\
    \ and `preg_match()` can still get pretty slow for large strings.\n<|/ c |>\n\
    <| c |>\n- Also, if you're going to be doing lots of these checks, you might consider\
    \ using something like [`preg_split`](http://php.net/manual/en/function.preg-split.php)\
    \ or [`preg_match_all`](http://php.net/manual/en/function.preg-match-all.php)\
    \ (depending on how many of these checks you need to do) to avoid having to re-scan\
    \ the whole string multiple times.\n<|/ c |>\n<| a dscore=0 |>\nAnother solution:\n\
    <code>\npreg_match('/<<<+(.+)>>>/s', $text, $matches);\n$matches[1];\n</code>\n\
    <|/ a tags=regex,php |>\n<| a dscore=0 |>\nThe easiest and fastest way is\n<code>\n\
    if (strpos($string, '<') !== false) {\n   $string = str_replace('<', '', $string);\n\
    }\nif (strpos($string, '>') !== false) {\n   $string = str_replace('>', '', $string);\n\
    }\n</code>\nThe first line removes the < and > from the string, the second one\
    \ removes ", "    $brackets_array = explode(\"<<>>\", $brackets);\n    $returnVal\
    \ = true;\n    $open_brackets = array();\n    foreach ($brackets_array as $bracket)\
    \ {\n        if ($bracket == \"<\") {\n            $open_brackets[] = \"(\";\n\
    \        } else if ($bracket == \">\") {\n            $open_brackets[] = \")\"\
    ;\n        } else {\n            $open_brackets[] = $bracket;\n        }\n   \
    \ }\n    foreach ($open_brackets as $bracket) {\n        if (!in_array($bracket,\
    \ $brackets_array)) {\n            $returnVal = false;\n            break;\n \
    \       }\n    }\n    return $returnVal;\n}\n", "    $openings = preg_match_all('/<+/',$brackets);\n\
    \    $closings = preg_match_all('/<+>/',$brackets);\n    return ($openings ==\
    \ $closings);\n}\n", "    $pos = 0;\n    for($i = 0; $i < strlen($brackets); $i++)\
    \ {\n        if ($brackets[$i] == \"<\") {\n            $closed = substr($brackets,\
    \ $i+1, 1);\n            $opened = substr($brackets, $i, 1);\n            $pos\
    \ = $i;\n        }\n    }\n    return $pos == strlen($brackets)-1;\n}\n", "  \
    \  return $brackets === '<' || $brackets === '>';\n}\n", "\treturn preg_match_all('/<(?!\\\
    /)(.*)>/', $brackets, $matches);\n}\n", "    foreach ($brackets as $open_bracket\
    \ => $close_bracket) {\n        if (!(substr($brackets, $open_bracket, 1) ===\
    \ $close_bracket)) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a tags=php,regex dscore=2 |>\n<| c |>\nInteresting idea.\
    \ Although I feel like it's too simple. Having to add one more line to parse all\
    \ the brackets would be a hassle and would make it less readable.\n<|/ c |>\n\
    <| a |>\n<code>\npreg_match('#<((?=<)|(?!>))#', $str)\n</code>\nor\n<code>\npreg_match('#<((?!>)|(?!>))#',\
    \ $str)\n</code>\n<|/ a dscore=2 tags=php,regex |>\n<| c |>\nNice, although it\
    \ returns `true` for all the examples that I tested. I'm not sure how this would\
    \ handle the cases where a closing bracket is missing, but I do like the look-ahead.\n\
    <|/ c |>\n<| c |>\nWell, actually it works, I just forgot to add `>` inside the\
    \ look-behind assertions. I will edit the post.\n<|/ c |>\n<| c |>\nThe second\
    \ one works for me. Thanks for the answer! Although I feel like it's too simple.\
    \ Having to add one more line to parse all the brackets would be a hassle and\
    \ would make it less readable.\n<|/ c |>\n<| c |>\nThe second one works. But the\
    \ first one doesn't. Can you explain how the first one works?\n<|/ c |>\n<| c\
    \ |>\nFirst one doesn't work because it will match all opening brackets that are\
    \ not followed by another opening bracket. Second one works like a charm.\n<|/\
    \ c |>\n<| a dscore=1 tags=php,regex |>\n<code>\n$re = \"#<(?!>)#\";\n$str = \"\
    <><>\";\n\n$result = preg_match($re, $str);\n\nvar_dump($result);\n</code>\nSee\
    \ it work here: http://ideone.com/Ll0vZ\n<|/ a |>\n<| c |>\nThe second one works\
    \ for me. Thanks for the answer! Although I feel like it's too simple. Having\
    \ to add one more line to parse all the brackets would be a hassle and would make\
    \ it less readable.\n<|/ c |>\n<| a |>\nJust to answer my own question, I got\
    \ something that ", "  $brackets = preg_replace(\"/^>+$/\", \"\", $brackets);\n\
    \  $brackets = preg_replace(\"/<+$/\", \"\", $brackets);\n  return $brackets ==\
    \ \"<\";\n}\n", "  return preg_match('/<+>+/', $brackets);\n}\n", "  global $open_brackets,\
    \ $closed_brackets;\n  $brackets = array_unique($brackets);\n  $brackets = array_map(\"\
    htmlspecialchars\", $brackets);\n  $open_brackets = array_flip($open_brackets);\n\
    \  $closed_brackets = array_flip($closed_brackets);\n\n  // if the brackets are\
    \ ok, then we're done here.\n  foreach ($brackets as $i => $bracket) {\n    //\
    \ if the opening bracket hasn't been closed,\n    if (!isset($open_brackets[$bracket]))\
    \ {\n      return true;\n    }\n\n    // if the closing bracket hasn't been opened,\
    \ and\n    // the brackets are the same, then we're done here.\n    if (isset($closed_brackets[$bracket])\
    \ && $open_brackets[$bracket] == $closed_brackets[$bracket]) {\n      return true;\n\
    \    }\n\n    // if the closing bracket hasn't been opened and\n    // the brackets\
    \ are different, we're done here.\n    if (!isset($closed_brackets[$bracket])\
    \ || $open_brackets[$bracket] != $closed_brackets[$bracket]) {\n      return false;\n\
    \    }\n\n    // if the opening bracket is followed by another opening bracket,\n\
    \    // then we're done here.\n    if ($open_brackets[$bracket] == $brackets[$i\
    \ + 1]) {\n      return true;\n    }\n  }\n}\n</code>\n<|/ a tags=regex,php |>\n\
    <| c |>\nIt is not working properly when there is more than one opening bracket\
    \ in a row i.e. <<< >><> this should return true but it is returning false\n<|/\
    \ c |>\n<| c |>\nThank you for reporting. I've edited my answer according to this\
    \ comment.\n<|/ c |>\n<| a dscore=2 |>\nThis expression should do the job\n<code>\n\
    <(?!\\?[^>]*>)\n</code>\nIt just matches <.\n<|/ a tags=regex,php |>\n<| c |>\n\
    It is not working properly when there is more than one opening bracket in a row\
    \ i.e. <<< >><> this should return true but it is returning false\n<|/ c |>\n\
    <| a |>\nTo match the full < > pairs you could use something like this\n<code>\n\
    <([A-Za-z0-9]+)>\n</code>\n<|/ a tags=regex,php dscore=2 |>\n<| c |>\nIt is not\
    \ working properly when there is more than one opening bracket in a row i.e. <<<\
    \ >><> this should return true but it is returning false\n<|/ c |>\n<| c |>\n\
    As a matter of fact it worked for me on the ", "  foreach ($brackets as $opening_bracket)\
    \ {\n    foreach ($brackets as $closing_bracket) {\n      if ($opening_bracket\
    \ == $closing_bracket) {\n        continue;\n      }\n      if ($opening_bracket\
    \ == '<' && $closing_bracket == '>') {\n        $brackets = preg_replace('/' .\
    \ $opening_bracket . '/', '$' . $opening_bracket . '/', $brackets);\n        $brackets\
    \ = preg_replace('/' . $closing_bracket . '/', '$' . $closing_bracket . '/', $brackets);\n\
    \        continue;\n      }\n    }\n  }\n  return preg_match_all('/<[^>]*>/',\
    \ $brackets, $matches) > 0;\n}\n", "  return (strpos($brackets, \">\") !== strlen($brackets)\
    \ - 1);\n}\n", "\tfor ($i = 0, $len = strlen($brackets); $i < $len; $i++) {\n\t\
    \tif ($brackets[$i] !== \"<\") {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\n", "    $brackets = array_flip($brackets);\n    foreach ($brackets as $open_bracket\
    \ => $close_bracket) {\n        if ($open_bracket === $close_bracket) {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\n", "  $correct_brackets\
    \ = array();\n  $open_counts = count($brackets);\n  for($i = 0; $i < $open_counts;\
    \ $i++) {\n    $close_pos = strpos($brackets, \">\", $i);\n    if($close_pos ===\
    \ false) {\n      array_push($correct_brackets, false);\n    } else {\n      $close_pos\
    \ += 1;\n      array_push($correct_brackets, $close_pos === $open_counts);\n \
    \   }\n  }\n  return !array_sum($correct_brackets);\n}", "  return preg_match_all(\"\
    /<([^>]+)>/\",$brackets) !== false;\n}\n", "    foreach($brackets as $c) {\n \
    \       $n = strpos($brackets, $c);\n        if ($n !== false) {\n           \
    \ $brackets = substr($brackets, 0, $n) . substr($brackets, $n + 1);\n        }\n\
    \    }\n    return $brackets === \"<>\";\n}\n</code>\nThe algorithm is simple:\n\
    \nTake each bracket and find the first closing bracket\nIf there is no closing\
    \ bracket after the current bracket, insert a closing bracket\nIf there is a closing\
    \ bracket after the current bracket, remove the first character\n<|/ a tags=php,algorithm,python,parentheses\
    \ |>\n<| a tags=php,algorithm,python,parentheses dscore=4 |>\nThis can be done\
    \ by creating an array of each parentheses pair as well as their indexes, and\
    \ then iterating through each character in string. In the example below, I will\
    \ use '(' and ')' as my parenthesis delimiters.\n<code>\n$arr = [\n    '(',\n\
    \    ')',\n    '(',\n    ')',\n    '(',\n    ')',\n    '(',\n    ')',\n];\n\n\
    $string = '(()()((()))';\n\n$newString = '';\n$index = 0;\n\nforeach(str_split($string)\
    \ as $ch){\n    if($ch == '('){\n        $newString .= $arr[$index++];\n    }\n\
    \n    if($ch == ')'){\n        $newString .= $arr[$index];\n        unset($arr[$index--]);\n\
    \    }\n\n    if($index == -1){\n        throw new Exception('Invalid parenthesis\
    \ string: ' . $string);\n    }\n\n    $newString .= $ch;\n}\n\nvar_dump($newString);\n\
    </code>\n<|/ a |>\n<| c |>\nIf you use a counter like this, it works fine for\
    \ brackets, but not for parentheses.\n<|/ c |>\n<| c |>\nIt works for me with\
    \ the example string provided. If you have a string with an invalid parenthesis,\
    \ it will throw a warning. The code above will not throw an exception for invalid\
    \ parenthesis.\n<|/ c |>\n<| a dscore=2 |>\nThis question has already been answered\
    \ but I think there is a more elegant solution with regular expressions.\n<code>\n\
    $string = '(()()((()))';\n$regex = preg_replace('/(.*?\\()/', '\\\\1', $string);\n\
    </code>\n<|/ a tags=php,algorithm,python,parentheses |>\n<| c |>\nThe question\
    \ is tagged PHP. I wonder if you meant `preg_replace('/(.*?\\()/", "    $opening_brackets\
    \ = $brackets_array = explode(\"<\", $brackets);\n    $closing_brackets = $brackets_array[0];\n\
    \    $brackets_array = array_slice($brackets_array, 1, count($brackets_array));\n\
    \    $opening_brackets = array_flip($opening_brackets);\n    $closing_brackets\
    \ = array_flip($closing_brackets);\n    $all_brackets = array_keys(array_merge($opening_brackets,\
    \ $closing_brackets));\n    foreach ($brackets_array as $bracket) {\n        if\
    \ (!isset($all_brackets[$bracket])) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n", "    $brackets = explode(\"<\", $brackets);\n\
    \    foreach ($brackets as $b) {\n        if (strrpos($brackets, $b . \"<\") ===\
    \ false) {\n            return false;\n        }\n    }\n    return true;\n}",
  "\treturn $brackets === \"<\" && strrpos($brackets, \"<\") === strlen($brackets)\
    \ - 1;\n}\n", "    // YOUR CODE HERE\n    if ($brackets != '<') {\n        return\
    \ false;\n    }\n\n    $counter = 0;\n    for ($i = 0; $i < count($brackets);\
    \ $i++) {\n        if ($brackets[$i] == \"<\") {\n            $counter++;\n  \
    \      } else if ($brackets[$i] == \">\") {\n            $counter--;\n       \
    \ }\n        if ($counter == 0) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n", "    for($x = 0; $x < strlen($brackets); $x++) {\n \
    \       if($brackets[$x] == \"<\") {\n            if($brackets[$x-1] == \">\"\
    ) {\n                return true;\n            } else {\n                return\
    \ false;\n            }\n        } else {\n            return false;\n       \
    \ }\n    }\n}\n", "  $found = false;\n  for ($i = 0; $i < strlen($brackets); $i++)\
    \ {\n    if ($brackets[$i] == \"<\") {\n      $found = true;\n    } else if ($brackets[$i]\
    \ == \">\") {\n      $found = false;\n    } else {\n      $found = false;\n  \
    \  }\n    if (!$found) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "    $opening = strpos($brackets, '<');\n    if ($opening === false) {\n       \
    \ return false;\n    }\n    $closing = strrpos($brackets, '>');\n    if ($closing\
    \ === false) {\n        return false;\n    }\n    $opening = intval($opening);\n\
    \    $closing = intval($closing);\n    if ($opening >= $closing) {\n        return\
    \ false;\n    }\n    return ($opening + 1) === $closing;\n}\n\n/**\n * Gets the\
    \ content of the header that should be used by PHPMailer.\n * @access private\n\
    \ * @return string\n */", "    $brackets = preg_replace('/(<\\/?)(\\W)*/', '',\
    \ $brackets);\n    $brackets = preg_replace('/(<\\/?)(\\W)*/', '', $brackets);\n\
    \    $brackets = preg_replace('/(<\\/?)(\\W)*/', '', $brackets);\n    $brackets\
    \ = preg_replace('/(<\\/?)(\\W)*/', '', $brackets);\n    $brackets = preg_replace('/(<\\\
    /?)(\\W)*/', '', $brackets);\n    return ($brackets === \"<>\");\n}\n</code>\n\
    <|/ a tags=python,regex |>\n<| a |>\nTry this one:\n<code>\n(^|<\\/?)(\\W)*(\\\
    <)\n</code>\n<|/ a dscore=1 tags=python,regex |>\n<| c |>\nThis won't match `<<><>>`.\n\
    <|/ c |>\n<| c |>\nIt won't match `<<><>>` because `<<><>>` isn't a word.\n<|/\
    \ c |>\n<| c |>\nAh, the second set of word characters is supposed to be a word.\n\
    <|/ c |>\n<| a dscore=1 |>\nFor your problem statement try this regex\n<code>\n\
    (<\\w.*>)(<\\w.*>)(<\\w.*>)(<\\w.*>)(<\\w.*>)(<\\w.*>)\n</code>\nand replace by\
    \ this \n<code>\n$1$5$3$7$2$5$8$2$6\n</code>\nDemo\n<|/ a tags=python,regex |>\n\
    <| c |>\nIt won't match `<<><>>`.\n<|/ c |>\n<| c |>\nIt will match `<<><>>`\n\
    <|/ c |>\n<| c |>\nNo, my regex doesn't match `<<><>>`. Your regex will match\
    \ `<<<>>`, but not `<<<><>>`.\n<|/ c |>\n<| c |>\nNo it won't... OP didn't mention\
    \ he wanted to match `<<><>>` this regex only matches single `<>` not multiple.\n\
    <|/ c |>\n<| c |>\nIt doesn't match `<<<><>>`, but OP didn't say it needs to match\
    \ multiple `<>`. Your regex will match `<<<>>`, but not `<<<><>>`.\n<|/ c |>\n\
    <| a tags=python,regex |>\n<code>\nimport re\n\npattern = r\"<(?!\\W)[^>]+>\"\n\
    \nprint re.findall", "  return preg_match_all('/<[^<>]+>/i', $brackets, $match)\
    \ == 1;\n}\n", "\tfor ($open_bracket = 1, $closed_bracket = 0, $pos = 0; $pos\
    \ < strlen($brackets); $pos++) {\n\t\t$char = substr($brackets, $pos, 1);\n\t\t\
    switch ($char) {\n\t\t\tcase '<':\n\t\t\t\t$closed_bracket++;\n\t\t\t\tbreak;\n\
    \t\t\tcase '>':\n\t\t\t\t$closed_bracket--;\n\t\t\t\tbreak;\n\t\t}\n\t\tif ($closed_bracket\
    \ < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  $brackets_map\
    \ = array(\n      \"<\" => \">\",\n      \"<\" => \"\",\n      \"<\" => \"\",\n\
    \      \">\" => \"\",\n      \">\" => \"\",\n      \">\" => \"\",\n    );\n  $found\
    \ = false;\n  foreach ($brackets as $key => $char) {\n    if (strlen($char) ==\
    \ 1) {\n      $found = true;\n    }\n    if ($char == \"<\") {\n      if ($found)\
    \ {\n        $brackets[$key] = $brackets_map[$char];\n      }\n    }\n  }\n  return\
    \ !$found;\n}\n", "    // \"<<><>>\" -> \"<><>\"\n    $brackets = preg_replace(\"\
    /<<([^>]*)>>/\", \"<\\\\1\\\\>\", $brackets);\n\n    // \"<><>\" -> True\n   \
    \ // \"<>\" -> False\n    return preg_match_all(\"/\\<([^>]*)\\>/\", $brackets,\
    \ $matches);\n}\n", "  $brackets = explode(\"<>\", $brackets);\n  foreach ($brackets\
    \ as &$string) {\n    $open = strpos($string, \"<\");\n    $close = strrpos($string,\
    \ \">\");\n    $open = max(1, $open);\n    $close = min($close, $close);\n   \
    \ $string = substr($string, 0, $open) . substr($string, $close);\n  }\n  return\
    \ count($brackets) == 1;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
