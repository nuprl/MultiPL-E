name: HumanEval_10_make_palindrome
language: php
prompt: "<?php\n// Find the shortest palindrome that begins with a supplied string.\n\
  // Algorithm idea is simple:\n// - Find the longest postfix of supplied string that\
  \ is a palindrome.\n// - Append to the end of the string reverse of a string prefix\
  \ that comes before the palindromic suffix.\n// >>> make_palindrome('')\n// ''\n\
  // >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n// 'catac'\n\
  function make_palindrome($string) {\n"
tests: "function candidate(...$args) {\n    return make_palindrome(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(\"\") !== \"\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"x\") !== \"x\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"xyz\") !== \"xyzyx\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"xyx\") !== \"xyx\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"jerry\") !== \"jerryrrej\") { throw new\
  \ Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $postfix = $string;\n    $longest_postfix = '';\n    $prefix_length\
    \ = 0;\n    while ($postfix != '' && $postfix != $longest_postfix) {\n       \
    \ $longest_postfix = $postfix;\n        $prefix_length = strlen($postfix, $prefix_length);\n\
    \        $postfix = substr($string, $prefix_length + 1);\n    }\n    if ($postfix\
    \ != '' && $postfix != $longest_postfix) {\n        $longest_postfix = $postfix;\n\
    \        $postfix = strrev($postfix, $prefix_length);\n    }\n    $longest_postfix\
    \ = trim($longest_postfix, $prefix_length);\n    return $postfix . $longest_postfix;\n\
    }\n", "    $reverse_string = strrev($string);\n    $postfix = $reverse_string;\n\
    \    $result = $string;\n    while (substr($postfix, 0, strlen($string)) === $reverse_string\
    \ && substr($postfix, 0, strlen($reverse_string)) !== '') {\n        $postfix\
    \ = substr($postfix, 0, strlen($string)) + $reverse_string;\n        $result =\
    \ $string.$postfix;\n    }\n    return $result;\n}\n", "  $prefix_len = strlen($string);\n\
    \  $postfix_len = strlen($string);\n\n  for ($i = 0; $i < $postfix_len; $i++)\
    \ {\n    if ($string[$i] === $string[$prefix_len - $i - 1]) {\n      $postfix_len--;\n\
    \      $prefix_len--;\n    } else {\n      break;\n    }\n  }\n\n  return substr($string,\
    \ 0, $prefix_len).str_repeat($string[$prefix_len - $postfix_len], $postfix_len);\n\
    }\n</code>\nI got it working using this function:\n<code>\n<?php", "    $length\
    \ = strlen($string);\n    // Find the longest postfix that is palindrome.\n  \
    \  $post_length = 0;\n    $postfix_start = 0;\n    while ($post_length < $length)\
    \ {\n        // Find first palindrome of $length postfix that begins with $string.\n\
    \        // If one doesn't exist, we're done.\n        $found_postfix = 1;\n \
    \       while ($found_postfix) {\n            if ($postfix_start < $length) {\n\
    \                // Reverse substring from $postfix_start until $post_length.\n\
    \                $postfix = substr($string, $postfix_start, $post_length);\n \
    \               $found_postfix = rpl($postfix, $postfix, $string);\n         \
    \   } else {\n                // No palindrome of $length postfix exists so we're\
    \ done.\n                $found_postfix = false;\n            }\n            $postfix_start++;\n\
    \        }\n        $post_length++;\n    }\n    // Now add the reverse of the\
    \ postfix before the postfix that begins with $string.\n    $return_string = substr($string,\
    \ 0, $postfix_start);\n    $return_string .= rpl($string, $postfix, $string);\n\
    \    return $return_string;\n}\n", "    $longestPalindrome = '';\n    $suffix\
    \ = '';\n    for($i=0; $i<strlen($string); $i++) {\n        $lengthOfPalindrome\
    \ = $i;\n        $reversedString = strrev($string);\n        $reversedString =\
    \ $reversedString[$lengthOfPalindrome];\n        $reversedString = strrev($reversedString);\n\
    \        if(strlen($reversedString) == strlen($string)) {\n            $suffix\
    \ = ($reversedString . $suffix);\n        } else {\n            $longestPalindrome\
    \ = ($string . $longestPalindrome);\n            break;\n        }\n    }\n  \
    \  return ($longestPalindrome . $suffix);\n}\n", "    $str = strrev($string);\n\
    \    if ($str == $string) return $string;\n    $pali = '';\n    $plen = strlen($string);\n\
    \    $postfix = substr($string, 0, $plen - 1);\n    for ($i = 0; $i < strlen($postfix);\
    \ $i++) {\n        $pali .= substr($postfix, $i, 1);\n    }\n    return $pali\
    \ . $str;\n}\n", "  if (!$string) {\n    return '';\n  }\n\n  // Find the longest\
    \ postfix of supplied string that is a palindrome.\n  $postfix = substr($string,\
    \ -1);\n  $postfix = substr($postfix, 0, strlen($string) - 1);\n  $palindrome\
    \ = substr($string, 0, strlen($string) - 1) . $postfix;\n  $palindrome = strrev($palindrome);\n\
    \  if ($string == $palindrome) {\n    return $string;\n  }\n  return $string .\
    \ $palindrome;\n}", "  $result = $string;\n  $length = strlen($string);\n  for\
    \ ($i = 0; $i < $length; ++$i) {\n    $reverse = strrev($string);\n    $reverse\
    \ = substr($reverse, 0, $i);\n    $result .= $reverse;\n  }\n  return $result;\n\
    }\n", "    $strlen = strlen($string);\n    if ($strlen == 0) {\n        return\
    \ '';\n    }\n    $string_rev = '';\n    $prefix = substr($string, 0, -1);\n \
    \   for ($i = $strlen - 1; $i >= 0; $i--) {\n        $string_rev .= $prefix[$i];\n\
    \    }\n    return $string_rev . $string . $strlen;\n}\n", "  $llen = strlen($string);\n\
    \  $post = array();\n  for ($i = 0; $i < $llen; $i++) {\n    $post[] = substr($string,\
    \ $i, 1);\n  }\n  $post = array_reverse($post);\n  return $string . $post[0];\n\
    }", "    $string = preg_replace('/[^a-z0-9]/', '', $string);\n    $len = strlen($string);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        for ($j = $i; $j < $len; $j++) {\n\
    \            if ($string[$i] == $string[$j]) {\n                $string[$i] =\
    \ $string[$j] = $string[$len-1];\n                $len--;\n            }\n   \
    \     }\n    }\n    return implode('', str_split($string));\n}\n", "  list($prefix_string,\
    \ $suffix_string) = find_longest_postfix_and_prefix($string);\n  $postfix_string\
    \ = reverse($prefix_string);\n  return $postfix_string . $suffix_string;\n}\n",
  "    $longest = find_longest_postfix_palindrome($string);\n    if (!$longest) {\n\
    \        return $string;\n    }\n    return $string . $string . str_reverse($longest);\n\
    }\n", "  $palindrome = '';\n  $suffix = '';\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    $palindrome .= $string[$i];\n    $suffix .= $string[$i];\n  }\n\
    \  $palindrome .= strrev(substr($string, 0, strlen($palindrome)));\n  return $palindrome;\n\
    }\n", "  $string = preg_replace('/([^\\W_]+)/', '', $string); // remove non-alphanumeric\
    \ chars\n  $palindrome = $string;\n  $chars = str_split($string);\n  sort($chars);\n\
    \  foreach ($chars as $i => $char) {\n    if ($i == 0) {\n      if ($char == $chars[$i])\
    \ {\n        continue;\n      }\n    }\n    if ($char != $chars[$i]) {\n     \
    \ $palindrome = substr($palindrome, 0, -strlen($char)) + str_repeat($char, $i);\n\
    \    }\n  }\n  return $palindrome;\n}", "  $chars = str_split($string);\n  return\
    \ $chars[count($chars)-1] . $string . $chars[count($chars)-2];\n}\n$string = 'asdasda';\n\
    $test = make_palindrome($string);\necho $test;", "  $longest = strrpos($string,\
    \ $string[0]);\n  for ($i = 1, $l = strlen($string); $i < $l; $i++) {\n    $reversed_string\
    \ = substr($string, 0, $longest) . strrev(substr($string, 0, $i));\n    if ($reversed_string\
    \ === $string) {\n      return $string;\n    }\n    $longest = $i;\n  }\n  return\
    \ $string;\n}\n", "  // Check for an empty string, no need to reverse an empty\
    \ string.\n  if ($string === '') {\n    return '';\n  }\n\n  // Find longest palindromic\
    \ suffix.\n  // Example: 'abc' is a palindromic suffix of 'abcd'.\n  // Find the\
    \ longest postfix of $string that is a palindrome:\n  // Example: 'ab' is a palindromic\
    \ suffix of 'abc'.\n  $palindrome_length = strlen(strrev($string));\n  // Example:\
    \ 'c' is a palindromic suffix of 'cc'.\n  $palindrome_length ++;\n\n  // Add postfix\
    \ of $string that is a palindrome to the end of $string.\n  // Example: make_palindrome('abc')\
    \ yields 'abcdc'.\n  return strrev($string).$palindrome_length.strrev($string);\n\
    }", "  global $start;\n  $longest = find_longest($string);\n  $start = substr($string,\
    \ 0, -1);\n  $end = substr($string, 0, -$longest);\n  return $start . $end;\n\
    }\n", "    $postfix = $string;\n    while (strlen($postfix) > strlen($string))\
    \ {\n        $postfix = strrev($postfix);\n    }\n    return $string.$postfix.strrev($string);\n\
    }\n", "    $string_palindrome = '';\n    // Find length of longest postfix of\
    \ string.\n    $length = strlen($string);\n    // Find the longest postfix that\
    \ is a palindrome.\n    while ($length > 0) {\n        // Find index of first\
    \ character that is different.\n        $first_difference = strrpos($string, 'a',\
    \ $length - 1);\n        // Remove first character of string.\n        $string\
    \ = substr($string, $first_difference);\n        // Add character to postfix.\n\
    \        $string_palindrome .= $string[0];\n        // Remove first character\
    \ from string.\n        $string = substr($string, 1);\n        // Remove first\
    \ character from length.\n        --$length;\n    }\n    return $string_palindrome;\n\
    }\n", "    // TODO: Implement function\n    $string_palindrome = $string;\n  \
    \  $palindrome = $string;\n    $max_string_len = 0;\n    $max_length = 0;\n\n\
    \    foreach (str_split($string) as $char) {\n        $max_string_len = max($max_string_len,\
    \ strlen($char));\n        $max_length = max($max_length, strlen($string_palindrome));\n\
    \        $string_palindrome .= $char;\n        $palindrome .= strrev($string_palindrome);\n\
    \    }\n\n    $max_length = max($max_string_len, $max_length);\n\n    if ($max_string_len\
    \ != $max_length) {\n        return null;\n    }\n\n    return $palindrome;\n\
    }\n\n$string_palindrome = make_palindrome($string);\nif ($string_palindrome !==\
    \ $palindrome) {\n    echo \"Palindrome could not be created\";\n} else {\n  \
    \  echo \"Palindrome created\";\n}\n</code>\n<|/ a tags=php,string |>\n<| c |>\n\
    How is it a palindrome? The reverse is `catt`.\n<|/ c |>\n<| c |>\n\"cat\" is\
    \ a palindrome and `cata` is not. See [here](http://www.careercup.com/question?id=5102584878456616)\
    \ and [here](http://www.careercup.com/question?id=51025848982781296).\n<|/ c |>\n\
    <| c |>\nYes, I see that. Surely `cat` is palindrome, though? Your code doesn't\
    \ check that.\n<|/ c |>\n<| c |>\nWell, I just checked it and `cat` is indeed\
    \ a palindrome. See the second link, the algorithm is explained there.\n<|/ c\
    \ |>\n<| c |>\nI believe you're missing the fact that `cat` is also a palindrome\
    \ - `cata` is a palindrome but not `cat`.\n<|/ c |>\n<| a tags=php,string |>\n\
    You can do so using preg_match() and strrev()\n<code>\n<?php\n$string = 'cat';\n\
    if (preg_match('/\\B' . strrev($string) . '\\B/', $string)) {\n    echo \"Palindrome\"\
    ;\n} else {\n    echo \"Not a palindrome\";\n}\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nThanks for showing me how to use `\\B` and `\\K`", "    if (strlen($string)\
    \ < 2) {\n        return $string;\n    }\n    $postfix_string = $string;\n   \
    \ $reverse_string = '';\n    while (substr($postfix_string, 0, 1) === 'c') {\n\
    \        $postfix_string = substr($postfix_string, 1);\n        $reverse_string\
    \ .= substr($reverse_string, 0, -1) . substr($reverse_string, -1);\n    }\n  \
    \  $reverse_string .= $postfix_string;\n    return $reverse_string;\n}", "  $suffixes\
    \ = $lengths = array();\n  foreach(str_split($string) as $char) {\n    $suffixes[]\
    \ = $char;\n    $lengths[] = strlen($char);\n  }\n  sort($suffixes);\n  sort($lengths);\n\
    \n  $longest = 0;\n  $longestLength = 0;\n  foreach ($suffixes as $suffix) {\n\
    \    $len = strlen($suffix);\n    if ($len > $longestLength) {\n      $longest\
    \ = $suffix;\n      $longestLength = $len;\n    }\n  }\n\n  $reversed = $string;\n\
    \  for ($i = 0; $i < $longestLength; $i++) {\n    $reversed = $reversed . strrev($suffixes[$i]);\n\
    \  }\n\n  return $reversed . $longest;\n}\n</code>\n<|/ a tags=algorithm,palindrome,php\
    \ |>\n<| c |>\nI like this solution, its simple and effective! The only problem\
    \ would be if $string is very long. Maybe the best thing to do is split the string\
    \ into chunks smaller and find all the possible pairs of palindromes within each\
    \ chunk. This would save having to search the whole string once the chunks are\
    \ smaller.\n<|/ c |>\n<| c |>\nIf you're going to test whether a string is a palindrome,\
    \ you may as well just check the first and last letters of the string.\n<|/ c\
    \ |>\n<| c |>\nNice work. Nice job with the recursive function!\n<|/ c |>\n<|\
    \ c |>\nThis is a good answer but not an answer. Not trying to get my rep points\
    \ down just to say this but you might want to explain to people reading the code\
    \ why you're using recursion here. It will help them and probably most of them\
    \ elsewhere in the future. :)\n<|/ c |>\n<| c |>\nI wrote this answer nearly 20\
    \ years ago and now that I am more proficient with my coding skills I do not think\
    \ that I needed to explain the algorithm to anyone. The question was a little\
    \ vague and I did not want to give the impression that I was not interested in\
    \ understanding the algorithm or any programming at all. I only wanted to give\
    \ the algorithm a little context so people who are searching for the same thing\
    \ could find my answer. :)\n<|/ c |>\n<| a |>\n<code>\n<?php\n$string = \"abcba\"\
    ;\n$reverseString = \"\";\n\nfor($i = strlen($string) - 1; $i >= 0; $i--){\n \
    \ $reverseString .= $string[$i];\n}\n\n$string = ", "  $len  = strlen($string);\n\
    \  $rev  = strrev($string);\n  $mid  = $len - 1;\n  $str  = '';\n  for ($i=0;\
    \ $i <= $mid; $i++) {\n    $str .= substr($string, 0, $i+1).$rev.substr($string,\
    \ $i+1);\n  }\n  return $str;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,string,java\
    \ |>\n<| c |>\nThanks, I tried your approach but the problem here is that this\
    \ approach is not scalable. Say I need to check up to 5 strings in an array. What\
    \ would be the best approach? The approach that I found was to break down the\
    \ string into chunks of 5 chars and check each chunk in the array for its palindrome,\
    \ which would work for up to 5 strings. But this approach would not be scalable\
    \ for higher numbers.\n<|/ c |>\n<| a tags=algorithm,string,java |>\nYou cannot\
    \ use Java to solve this problem. The best you can do, is to write a recursive\
    \ algorithm that can handle arbitrarily long inputs, and then handle each case\
    \ individually. Recursion can be quite a tricky concept to get your head around\
    \ at first, but once you get used to it, you will be able to solve this problem\
    \ in just a few lines of code.\nThe algorithm is as follows:\n\nSplit the input\
    \ string in half at each character position.\nIf the first half of the split is\
    \ equal to the reverse of the second half, return the first half.\nElse, return\
    \ the first half + the reverse of the second half.\n\nThe recursive algorithm\
    \ is as follows:\n<code>\npublic String reverseStringHelper(String input, String\
    \ previousResult) {\n    // Split input in half at each character position.\n\
    \    int halfLength = input.length() / 2;\n\n    // If the first half of the split\
    \ is equal to the reverse of the second half, return the first half.\n    if (input.substring(halfLength,\
    \ halfLength).equals(previousResult.substring(previousResult.length() - halfLength,\
    \ previousResult.length()))) {\n        return input.substring(0, halfLength);\n\
    \    }\n\n    // Else, return the first half + the reverse of the second half.\n\
    \    return previousResult + input.substring(halfLength, halfLength).reverse();\n\
    }\n</code>\nYou can implement this method in Java as follows:\n<code>\npublic\
    \ String reverseString(String input) {\n    String previousResult = \"\";\n\n\
    \    // Split the input in half at each character position.\n    for (int i =\
    \ 0; i < input.length(); i++) {\n        previousResult = reverseStringHelper(input,\
    \ previousResult);\n    }\n\n    return previousResult;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nHe needs a scalable solution, that's why he needs a recursive solution.\n\
    <|/ c |>", "    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
    \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
    \    // 'catac'\n    $postfix = $string;\n    $suffix = '';\n    do {\n      \
    \  $reversed = strrev($postfix);\n        $suffix = $reversed . $suffix;\n   \
    \     $postfix = strrev($postfix);\n    } while (!is_palindrome($string));\n \
    \   return $string . $suffix;\n}\n</code>\nAs you can see, we keep two variables:\
    \ $postfix and $suffix.\nThe first variable is always the string we are interested\
    \ in.\nThe second variable is always reversed and appended to $string.\nWe start\
    \ by reversing $postfix, which is a postfix of a string.\nIf $postfix is not a\
    \ palindrome, we can stop there.\nIf $postfix is a palindrome, we reverse it using\
    \ strrev(), and append it to $suffix.\nWe keep doing this until we find one that\
    \ is not the palindrome.\nAfter we find the longest postfix we can reverse it\
    \ and append it to $string.\n<code>\n$postfix = $string;\n$suffix = '';\ndo {\n\
    \    $reversed = strrev($postfix);\n    $suffix = $reversed . $suffix;\n    $postfix\
    \ = strrev($postfix);\n} while (!is_palindrome($string));\n</code>\n<|/ a tags=php,algorithm,string\
    \ |>\n<| c |>\nThe question states that \"we must determine the longest palindrome\"\
    \n<|/ c |>\n<| c |>\n, you are right :) I read it as \"we must determine longest\
    \ palindrome that begins with a string\"\n<|/ c |>\n<| c |>\nBut it also says\
    \ nothing about longest postfix length. So I think it means that we have to find\
    \ longest postfix of string\n<|/ c |>\n<| c |>\n, I have edited my answer to include\
    \ a code that should do what OP asks for\n<|/ c |>\n<| c |>\nBut why is `cata`\
    \ palindrome but `cataa", "  // Store a variable that stores the length of the\
    \ palindrome.\n  $len = 0;\n  // Store a variable that stores the index of the\
    \ longest postfix of the palindrome.\n  $longest = 0;\n  // Store a variable that\
    \ stores the length of the longest postfix.\n  $postFix = 0;\n  // Store the length\
    \ of the string.\n  $length = (strlen($string) > 1 ? strlen($string) : 1);\n \
    \ // Loop through the string.\n  for ($i = 0; $i < $length; $i++) {\n    // If\
    \ the character is a lowercase letter add it to the palindrome.\n    if ($string[$i]\
    \ < \"a\" || $string[$i] > \"z\") {\n      $palindrome .= $string[$i];\n    }\
    \ else {\n      // Else determine if the characters are a letter and whether they\
    \ are capitals.\n      if (ctype_alpha($string[$i]) && ctype_upper($string[$i]))\
    \ {\n        // If the current character is a letter but not capitalized, store\
    \ that index.\n        $palindromeIndex = $i;\n        // If the current character\
    \ is a capital letter store that index.\n        $palindromeCapital = ctype_upper($string[$i]);\n\
    \        // If the current character is a letter but not capitalized, increment\
    \ the longest postfix length.\n        $postFix += 1;\n        // If the current\
    \ character is a capital letter increment the longest postfix length.\n      \
    \  $postFixCapital = ctype_upper($string[$i]);\n      }\n    }\n  }\n  // Store\
    \ the longest postfix.\n  $longestPostFix = $postFix;\n  // Loop through the string.\n\
    \  for ($i = 0; $i < $length; $i++) {\n    // If the character is a lowercase\
    \ letter add it to the palindrome.\n    if ($string[$i] < \"a\" || $string[$i]\
    \ > \"z\") {\n      $palindrome .= $string[$i];\n    } else {\n      // Else determine\
    \ if the characters are a letter and whether they are capitals.\n      if (ctype_alpha($string[$i])\
    \ && ctype_upper($string[$i])) {\n        // If the current character is a letter\
    \ but not capitalized, store that index.\n        $palindromeIndex = $i;\n   \
    \     // If the current character is a capital letter store that index.\n    \
    \    $palindromeCapital = ctype_upper($string[$i]);\n        // If the current\
    \ character is a letter but not capitalized, increment the longest postfix length.\n\
    \        $postFix += 1;\n        // If the current character is a capital letter\
    \ increment the longest postfix length.\n        $postFixCapital = ctype_upper($string[$i]);\n\
    \      }\n    }", "  // Find the longest postfix string that is palindromic.\n\
    \  $post_length = strlen($string);\n  $max_length = 0;\n  for ($i = 0; $i < $post_length;\
    \ $i++) {\n    if ($string[$i] === $string[$post_length - 1 - $i]) {\n      $max_length\
    \ = $i + 1;\n    } else {\n      break;\n    }\n  }\n\n  // Create the palindrome.\n\
    \  $palindrome = '';\n  for ($i = 0; $i < $max_length; $i++) {\n    $palindrome\
    \ .= $string[$max_length - 1 - $i];\n  }\n\n  // Reverse the string and append\
    \ to the palindrome.\n  for ($i = 0; $i < $max_length; $i++) {\n    $palindrome\
    \ .= $string[$i];\n  }\n\n  return $palindrome;\n}", "    $postfix_string = $string\
    \ . 'a';\n    // Find the longest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    $longest_postfix = longest_postfix_from_palindrome($postfix_string);\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    return $string . $longest_postfix;\n}\n",
  "  if ($string === '' || $string === null)\n  {\n    return '';\n  }\n\n  $string\
    \ = $string.'';\n\n  $len        = strlen($string);\n  $postfix_len = strlen($string);\n\
    \  $postfix_str = '';\n\n  for ($i = 0; $i < $len; $i++)\n  {\n    if ($i ===\
    \ ($len - 1) && $string[$i] === $string[$len - 1])\n    {\n      $postfix_str\
    \ .= $string[$i];\n      $postfix_len--;\n    }\n    else\n    {\n      if ($postfix_len\
    \ > 0)\n      {\n        $postfix_str .= $string[$i];\n      }\n      $postfix_len--;\n\
    \    }\n  }\n\n  if ($postfix_len > 0)\n  {\n    $postfix_str .= $string[$i];\n\
    \  }\n\n  $palindrome = $postfix_str;\n\n  while ($palindrome !== '')\n  {\n \
    \   $palindrome = strrev($palindrome);\n  }\n\n  $palindrome = $palindrome;\n\
    \  $palindrome = strrev($palindrome);\n\n  return $palindrome;\n}\n", "    $reversed_string\
    \ = '';\n\n    // If there is no string, return an empty string\n    if (! $string)\
    \ {\n        return $string;\n    }\n\n    // Convert the string to an array\n\
    \    $string = strtolower($string);\n\n    // Find all possible prefixes of the\
    \ string\n    $possible_prefixes = array();\n    for ($i=0; $i<strlen($string);\
    \ $i++) {\n        // Add all possible prefixes of our string\n        $possible_prefixes[]\
    \ = $string[$i];\n\n        // Find the first character after the prefix\n   \
    \     $j = strlen($string) - $i;\n        while (true) {\n            $reverse_substr\
    \ = substr($string, $j, $i);\n            if ($reverse_substr !== $string[$i])\
    \ {\n                break;\n            }\n            $j--;\n        }\n   \
    \     $possible_prefixes[] = $reverse_substr;\n    }\n\n    // Find the shortest\
    \ palindrome\n    $shortest = '';\n    $shortest_length = 0;\n    foreach ($possible_prefixes\
    \ as $possible_prefix) {\n        $reverse_possible_prefix = strrev($possible_prefix);\n\
    \        $reverse_possible_prefix_length = strlen($reverse_possible_prefix);\n\
    \n        // Is the reverse of the prefix longer than the length?\n        if\
    \ ($reverse_possible_prefix_length > $shortest_length) {\n            $shortest_length\
    \ = $reverse_possible_prefix_length;\n            $shortest = $possible_prefix;\n\
    \        }\n\n        // If the reverse is equal to the prefix and longer, keep\
    \ going\n        // otherwise stop\n        if ($shortest === $possible_prefix\
    \ && $reverse_possible_prefix_length >= $shortest_length) {\n            break;\n\
    \        }\n    }\n\n    return $shortest.$reversed_string;\n}\n", "    $suffix\
    \ = '';\n    while ($string !== $suffix = strrev($string)) {\n        $string\
    \ .= $suffix;\n    }\n    return $string;\n}", "    if (!$string) {\n        return\
    \ '';\n    }\n    $chars = str_split($string);\n    $postfix_palindromes = array();\n\
    \    $reverse_string = '';\n    foreach ($chars as $char) {\n        if ($char\
    \ == $string[$chars - 1]) {\n            $reverse_string = $reverse_string.$char;\n\
    \        } else {\n            $postfix_palindromes[] = $reverse_string.$char;\n\
    \        }\n    }\n    return substr($string, 0, -1).implode('', array_reverse($postfix_palindromes));\n\
    }\n", "    $postfix = substr($string, -1);\n    $prefix_length = strlen($string)\
    \ - strlen($postfix);\n    $reversed = strrev($string);\n    $palindrome = $string.$reversed.$postfix;\n\
    \    return $palindrome;\n}\n</code>\n<|/ a tags=palindrome,php |>\n<| a tags=palindrome,php\
    \ |>\nTry this\n<code>\n<?php\n", "  // Make sure the string is at least 1 character\n\
    \  if (strlen($string) < 1) {\n    return '';\n  }\n  $palindrome = '';\n  $length\
    \ = strlen($string);\n\n  for($i = 0; $i < $length; ++$i) {\n    $palindrome .=\
    \ $string[$i];\n  }\n\n  $suffix = substr($palindrome, 0, strlen($palindrome)\
    \ - 1);\n  $prefix = substr($palindrome, 0, strlen($suffix));\n  $reversed = strrev($prefix);\n\
    \n  $palindrome = $suffix . $reversed;\n\n  return $palindrome;\n}", "    $prefix_length\
    \ = 0;\n    $postfix_length = 0;\n    $max_length = strlen($string);\n\n    for\
    \ ($i = 0; $i < $max_length; ++$i) {\n        $prefix = substr($string, 0, $i);\n\
    \        $suffix = substr($string, $i);\n\n        if (strlen($prefix) > $prefix_length\
    \ || strlen($suffix) > $postfix_length) {\n            break;\n        }\n   \
    \     if ($prefix != $suffix) {\n            break;\n        }\n\n        $prefix_length\
    \ = $i;\n        $postfix_length = $max_length - $i;\n    }\n\n    return substr($string,\
    \ 0, $postfix_length) . str_repeat($string[$postfix_length], $prefix_length +\
    \ 1) . substr($string, $max_length);\n}\n\n$string = 'cafebabe';\necho make_palindrome($string)\
    \ . \"\\n\";\n", "  if (strlen($string) < 2) return $string;\n  $postfix = substr($string,\
    \ 0, strrpos($string, $string[0]));\n  $rev = substr($postfix, strlen($postfix),\
    \ strlen($string));\n  return $string.$rev;\n}\n", "  // Find the length of the\
    \ prefix before the palindrome is found.\n  // Since the string must be at least\
    \ as long as the longest prefix\n  // that is a palindrome that starts with the\
    \ string we will add one to\n  // the length so that the first palindrome that\
    \ starts with the string\n  // is found.\n  $stringlength = strlen($string);\n\
    \  $longestprefix = 0;\n  $longestprefixlength = strlen($string);\n  $currentprefixlength\
    \ = 0;\n  $i = 0;\n  while (++$i <= $stringlength && $currentprefixlength < $longestprefixlength)\
    \ {\n    $char = $string[$i];\n    if ($char == $string[$i][$i]) {\n      $currentprefixlength++;\n\
    \    } else {\n      $longestprefix = $currentprefixlength;\n      $longestprefixlength\
    \ = $currentprefixlength;\n    }\n  }\n  $longestprefix += 1;\n\n  // Now that\
    \ we've found the longest prefix of the string that is a\n  // palindrome, we'll\
    \ need to add one to the end of the string to get\n  // the full palindrome starting\
    \ with the longest prefix.\n  $reversedstring = strrev($string);\n  return substr($string\
    \ . $reversedstring, 0, $longestprefix);\n}", "  $reversed_string = '';\n  for\
    \ ($i = 0, $string_length = strlen($string); $i < $string_length; ++$i) {\n  \
    \  $reversed_string .= str_repeat($string[$i], 2);\n  }\n  return $string . $reversed_string;\n\
    }\n", "  $length = strlen($string);\n  for ($i = 0; $i < $length - 1; $i++) {\n\
    \    if ($string[$i] !== $string[$length - 1 - $i]) {\n      break;\n    }\n \
    \ }\n  $return = $string;\n  $return[$i] = $string[$length - 1 - $i];\n  for ($j\
    \ = $length - 2; $j > 0; $j--) {\n    $return[$j] = $string[$j];\n  }\n  return\
    \ $return;\n}", "  $post_fix = $string;\n  $post_fix_reversed = '';\n\n  // Loop\
    \ through the string and find the longest postfix that is a palindrome.\n  foreach\
    \ (str_split($string) as $position) {\n    $new_post_fix = $post_fix;\n    $new_post_fix_reversed\
    \ = $post_fix_reversed;\n    $new_post_fix_reversed .= substr($new_post_fix, 0,\
    \ $position);\n\n    // Check if post prefix is a palindrome and if the new postfix\
    \ is longer.\n    if (is_palindrome($new_post_fix) && strlen($new_post_fix_reversed)\
    \ > strlen($new_post_fix)) {\n      $post_fix = $new_post_fix;\n      $post_fix_reversed\
    \ = $new_post_fix_reversed;\n    }\n  }\n\n  return $post_fix.$post_fix_reversed;\n\
    }\n", "    if ( ! is_string($string) || ! preg_match('/^[a-z]+$/', $string)) {\n\
    \        return false;\n    }\n    $postfix = str_split($string, -1);\n    array_pop($postfix);\n\
    \    $palindrome_postfix = implode('', $postfix);\n    $string_prefix = $string;\n\
    \    for ( $i = 0; $i < count($postfix); $i++) {\n        if (strrev($string_prefix)==$palindrome_postfix)\
    \ {\n            $palindrome = substr($string, 0, strlen($string)-$i);\n     \
    \       break;\n        }\n    }\n    return $palindrome;\n}\n</code>\n<|/ a tags=palindrome,algorithm,php\
    \ |>\n<| a |>\n<code>\npublic function reverseString($str) {\n    $chars = str_split($str);\n\
    \    return implode(array_reverse($chars));\n}\n\npublic function isPalindrome($str)\
    \ {\n    $reversed = $this->reverseString($str);\n    $reversed = rtrim($reversed);\n\
    \    return $str == $reversed;\n}\n</code>\n<|/ a dscore=1 tags=palindrome,algorithm,php\
    \ |>\n<| a tags=palindrome,algorithm,php dscore=1 |>\n<code>\n/**\n * bool $string\n\
    \ * bool\n */", "\t$prefix = substr($string, 0, -1);\n\t$suffix = substr($string,\
    \ -1);\n\n\t// Find longest palindrome that starts with the same prefix\n\t$max_len\
    \ = strlen($prefix);\n\tfor ($i = 0; $i < $max_len; $i++) {\n\t\t$reversed_string\
    \ = '';\n\t\tfor ($j = strlen($string) - $i; $j >= 0; $j--) {\n\t\t\t$reversed_string\
    \ .= $string[$j];\n\t\t}\n\t\tif ($reversed_string == $suffix) {\n\t\t\t$result\
    \ = substr($string, 0, $i);\n\t\t\t$result .= $suffix;\n\t\t\treturn $result;\n\
    \t\t}\n\t}\n\treturn $string;\n}\n", "    $palindrome = '';\n    $palindrome_length\
    \ = strlen($string);\n    $length = 0;\n    for($i = 0; $i < $palindrome_length;\
    \ $i++) {\n        $reverse = substr($string, $length, 1);\n        $palindrome\
    \ = $palindrome . $reverse;\n        $length++;\n    }\n    return $palindrome;\n\
    }\n", "  global $DEBUG;\n  if ($DEBUG) {\n    print (\"Running make_palindrome()\
    \ for $string\\n\");\n  }\n  $suffix = \"$string\";\n  $max_suffix = 0;\n  $min_suffix\
    \ = strlen($string) - 1;\n  while (substr($suffix, 0, 1) === substr($string, -1,\
    \ 1)) {\n    $max_suffix++;\n    $min_suffix--;\n  }\n  if ($DEBUG) {\n    print\
    \ (\"max_suffix=$max_suffix min_suffix=$min_suffix\\n\");\n  }\n  for ($i = 0;\
    \ $i < $min_suffix; $i++) {\n    $suffix = substr($string, 0, $i) + strrev(substr($string,\
    \ $i));\n    if ($DEBUG) {\n      print (\"suffix=$suffix\\n\");\n    }\n    if\
    \ (!palindrome($suffix)) {\n      return $suffix;\n    }\n  }\n}", "  global $max_index;\n\
    \  return $string . $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string) - 1 - $max_index[strlen($string)\
    \ - 1 - $max_index", "    if (!is_string($string)) {\n        return false;\n\
    \    }\n\n    $postfix_length = strlen($string) - 1;\n    $is_palindrome = false;\n\
    \    $longest_postfix = $postfix_length;\n\n    for ($i = 0; $i <= $postfix_length;\
    \ $i++) {\n        $current_postfix = substr($string, 0, $i);\n        if (is_palindrome($current_postfix))\
    \ {\n            $is_palindrome = true;\n            $longest_postfix = $i;\n\
    \        }\n    }\n\n    $end_of_string = strlen($string);\n    $reverse_of_postfix\
    \ = substr($string, $longest_postfix, $end_of_string);\n\n    return $is_palindrome\
    \ ? $string . reverse($reverse_of_postfix) : $string;\n}", "\t$postfix = substr($string,\
    \ -1);\n\tif ($string === $postfix = strrev($string)) {\n\t\treturn $string;\n\
    \t}\n\tif (is_palindrome($string)) {\n\t\t$append = strrev($string) . $postfix;\n\
    \t} else {\n\t\t$append = $string . $postfix;\n\t}\n\treturn $append . $string;\n\
    }\n", "    $longest = '';\n    $longest_suffix = NULL;\n\n    for ($i = 0; $i\
    \ < strlen($string); $i++) {\n        $postfix = substr($string, $i, 1);\n   \
    \     $postfix = make_palindrome_rec($postfix);\n\n        // Find longest palindrome\
    \ from all possible suffixes starting with the first character.\n        if ($postfix\
    \ != $longest_suffix) {\n            $longest = $postfix;\n            $longest_suffix\
    \ = $longest;\n        } else {\n            $longest = substr($postfix, 0, -1).$longest;\n\
    \        }\n    }\n\n    return $longest . $longest_suffix;\n}\n", "  // Find\
    \ the longest palindrome that is also a suffix of the given string.\n  // This\
    \ is done by looking for the longest postfix that is also a prefix of the given\
    \ string.\n  // Algorithm is straightforward:\n  // - Find the postfix that is\
    \ a prefix of the given string.\n  // - If this postfix is longer, append it to\
    \ the end of the given string.\n  // - If not, repeat the algorithm on the given\
    \ string with the current postfix as the prefix of this string.\n  // >>> make_palindrome('')\n\
    \  // ''\n  // >>> make_palindrome('cat')\n  // 'cat'\n  // >>> make_palindrome('cata')\n\
    \  // 'cata'\n  // >>> make_palindrome('catac')\n  // 'catac'\n  // >>> make_palindrome('catact')\n\
    \  // 'catact'\n  return $string . strrev(preg_replace('~[^a-z]~i', '', $string));\n\
    }", "  $max_length = strlen($string);\n  $palindrome = $max_length;\n  $i = 1;\n\
    \  while (strlen($string) > 0) {\n    $suffix = ($max_length - $i);\n    $reversed_string\
    \ = strrev($string);\n    $reversed_string_prefix = substr($string, 0, $suffix);\n\
    \    if ($reversed_string_prefix === $reversed_string) {\n      $palindrome =\
    \ $suffix;\n    } else {\n      $palindrome = $max_length;\n    }\n    $string\
    \ = substr($string, $i + 1);\n    $max_length = $max_length - $i;\n    $i++;\n\
    \  }\n  return $string;\n}\n", "    $postfix = substr($string, strlen($string)\
    \ - 1);\n    $postfix = strrev($postfix);\n    $postfix = str_pad($postfix, strlen($string),\
    \ '0', STR_PAD_LEFT);\n    $postfix = $postfix . $string;\n    return $postfix;\n\
    }\n", "    // Find the longest postfix that is palindrome.\n    $postfix = $string;\n\
    \    while (strlen($postfix) > 0 && strrev($postfix) == $string) {\n        $postfix\
    \ = substr($postfix, 0, -1);\n    }\n\n    // Add this suffix to the end of a\
    \ string.\n    return $string . $postfix;\n}\n</code>\n<|/ a dscore=4 |>\n<| c\
    \ |>\nYou are not checking if a string is a palindrome in the case where `$string\
    \ = 'aba'`. I think you have an error here\n<|/ c |>\n<| c |>\nNot true. `make_palindrome`\
    \ only returns the reverse of the postfix if it is palindrome, and the postfix\
    \ of the original string if not. You are free to change the definition of `make_palindrome`\
    \ to return a different string if one needs to be returned, but this does not\
    \ change the algorithm as long as you are aware that `make_palindrome` will return\
    \ exactly one string if the given string is a palindrome.\n<|/ c |>\n<| c |>\n\
    Yes you are right I missed the `$string == make_palindrome($string);` part. My\
    \ bad :)\n<|/ c |>\n<| c |>\nI added a more complete example, including checking\
    \ for palindromes.\n<|/ c |>\n<| c |>\n`make_palindrome` will work fine without\
    \ checking for palindromes. `make_palindrome` will return either `a` or `b` as\
    \ a palindrome. Both of them are palindromes since they are reversed of each other.\
    \ `make_palindrome` does not need to check whether a string is a palindrome. This\
    \ is done inside `make_palindrome`. See my example in the answer.\n<|/ c |>\n\
    <| a tags=php |>\n<code>\n$palindrome = substr($string,-1) == strrev($string);\n\
    </code>\nor\n<code>\n$palindrome = strrev($string) == substr($string,-1);\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis was my first thought too, but doesn't work. `make_palindrome(\"\
    cat\") == \"cact\"`, `make_palindrome(\"a\") == \"a\"`, `make_palindrome(\"aba\"\
    ) == \"aba\"`.\n<|/ c |>\n<| c |>\nIt would be better to check the reversed string\
    \ first. For example: `$palindrome = strrev($string) == $string;`\n<|/ c |>\n",
  "    // The longest palindrome is the part before the palindrome itself.\n    $prefix\
    \ = substr($string, strlen($string)/2, strlen($string)/2);\n\n    // Find a palindrome\
    \ suffix that is as long as possible,\n    // by trimming off characters from\
    \ the end.\n    $suffix = substr($string, -strlen($prefix));\n\n    // Add the\
    \ reverse of the prefix to the suffix.\n    $suffix = $prefix . strrev($suffix);\n\
    \n    // Return everything.\n    return $string . $suffix;\n}", "  // Find the\
    \ longest postfix that is a palindrome.\n  $len = strlen($string);\n  $reversed_postfix\
    \ = substr(strrev($string), 0, $len);\n  return $string . $reversed_postfix;\n\
    }\n", "    // Find longest prefix that is palindrome\n    $reverse_string = '';\n\
    \    $reverse_string_reversed = '';\n    foreach (str_split($string) as $char)\
    \ {\n        $reverse_string .= $char;\n        $reverse_string_reversed = strrev($reverse_string);\n\
    \        if ($reverse_string == $reverse_string_reversed) {\n            break;\n\
    \        }\n    }\n\n    // Append to end of string\n    $string = $string.$reverse_string_reversed;\n\
    \    return $string;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a dscore=1 tags=php,algorithm\
    \ |>\n<code>", "    $string = $string.\"a\";\n    $string = $string.\"a\";\n \
    \   $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\"\
    ;\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string = $string.\"\
    a\";\n    $string = $string.\"a\";\n    $string = $string.\"a\";\n    $string\
    \ = $string.\"a\";\n", "    $postfix_length = strlen($string) - 1;\n    $postfix_is_palindrome\
    \ = true;\n    $reverse_string = '';\n    $reverse_prefix_length = 0;\n    $i\
    \ = 0;\n\n    while ($i < $postfix_length && $postfix_is_palindrome) {\n     \
    \   $reverse_prefix_length++;\n        $reverse_string .= $string[$i];\n     \
    \   $i++;\n        if ($reverse_string == $string) {\n            $postfix_is_palindrome\
    \ = true;\n        } else {\n            $postfix_is_palindrome = false;\n   \
    \     }\n    }\n\n    return $string.substr(0, $i + $reverse_prefix_length).$reverse_string.substr(0,\
    \ $i);\n}\n", "  $palindrome = '';\n  $start = $length;\n  $length = strlen($string);\n\
    \  for ($i = 0; $i < $length; $i++) {\n    if ($string[$i] == $string[$length\
    \ - $i]) {\n      $palindrome = $string.$palindrome;\n    }\n  }\n  return $palindrome;\n\
    }\n", "    $max_prefix_length = 0;\n    $max_suffix_length = 0;\n    $max_prefix_length\
    \ = $max_suffix_length = $max_prefix_length + strlen($string);\n    $prefix_length\
    \ = $suffix_length = 0;\n    $prefix_length = $suffix_length = strlen($string);\n\
    \    $last_char = $string[0];\n\n    while ($prefix_length < $max_prefix_length\
    \ || $suffix_length < $max_suffix_length) {\n        $prefix = $string;\n    \
    \    $suffix = substr($string, $prefix_length);\n\n        $prefix_length = $suffix_length\
    \ = 0;\n        $prefix_length = $suffix_length = strlen($prefix);\n\n       \
    \ for ($i = 0; $i < $prefix_length; $i++) {\n            $char = substr($prefix,\
    \ $i, 1);\n            $suffix_length += (strlen($suffix) + $i == strlen($suffix))\
    \ ? 1 : 0;\n            if ($suffix[$i] == $char) {\n                $prefix_length\
    \ += 1;\n            } else {\n                $suffix_length += 0;\n        \
    \        $prefix = substr($prefix, 0, $i) . strrev($suffix);\n               \
    \ $prefix_length = $suffix_length = 0;\n                $prefix_length = $suffix_length\
    \ = strlen($prefix);\n                $last_char = $suffix[$i];\n            }\n\
    \        }\n\n        if ($prefix_length > $max_prefix_length) {\n           \
    \ $max_prefix_length = $prefix_length;\n        }\n\n        if ($suffix_length\
    \ > $max_suffix_length) {\n            $max_suffix_length = $suffix_length;\n\
    \        }\n    }\n\n    return $string;\n}\n", "    if (!is_string($string))\
    \ {\n        return '';\n    }\n\n    $prefix = substr($string, 0, -1);\n    $suffix\
    \ = '';\n    $length = 0;\n\n    // Find the length of the longest palindromic\
    \ substring.\n    while (strlen($prefix . $suffix . $string) > $length) {\n  \
    \      $length++;\n        $suffix = substr($string, -$length);\n    }\n\n   \
    \ // Append reverse of the string prefix that comes before palindromic suffix.\n\
    \    // Note that we must reverse the order of the characters before and after\
    \ the string\n    // because reversing also reverses the order of characters after\
    \ string.\n    return str_repeat($suffix, $length - 1) . $prefix . str_repeat($prefix,\
    \ -strlen($suffix));\n}\n</code>\n<|/ a tags=palindrome,php,algorithm,string |>\n\
    <| a tags=palindrome,php,algorithm,string |>\n<code>\n<?php\n$string = \"hello\
    \ world\";\n$palindrome = $string;\n\nif (strlen($string) > 1) {\n    $first \
    \ = substr($string, 0, strlen($string)/2);\n    $last   = substr($string, strlen($string)/2,\
    \ strlen($string));\n    $middle = substr($string, 0, strlen($string)/2 + 1);\n\
    \    $palindrome = $first . strrev($middle) . $last;\n}\n\nreturn $palindrome;",
  "\t$postfix = find_postfix($string, $string = reverse($string));\n\treturn $string\
    \ . $postfix;\n}", "    $length = strlen($string);\n    if ($length == 0) {\n\
    \        return $string;\n    }\n    $reversed_string = substr(strrev($string),\
    \ 0, $length);\n    $postfix_length = strlen($reversed_string);\n    return $string\
    \ . $reversed_string;\n}\n", "    if (strlen($string) < 1) {\n        return $string;\n\
    \    }\n\n    // find longest postfix of string\n    $suffix = substr($string,\
    \ -1);\n    $prefix_length = strlen($string) - strlen($suffix);\n    $palindrome\
    \ = substr($string, 0, strlen($string) - 1);\n\n    $palindrome .= str_repeat($suffix,\
    \ $prefix_length);\n\n    return $palindrome;\n}\n", "  return $string . rtrim(preg_replace('/^(.).*?\\\
    1/', reverse(substr($string, 0, -1)), $string), 'a');\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| a tags=php dscore=0 |>\n<code>", "    if ($string == '') return '';\n\
    \    $palindrome_prefix = '';\n    $palindrome_suffix = '';\n    for ($i = 0;\
    \ $i < strlen($string); $i++) {\n        if ($string[$i] == $string[strlen($string)\
    \ - 1 - $i]) {\n            $palindrome_suffix .= $string[strlen($string) - 1\
    \ - $i];\n        } else {\n            $palindrome_prefix .= $string[$i];\n \
    \       }\n    }\n    return $palindrome_prefix . strrev($palindrome_suffix);\n\
    }\n", "  // Find longest postfix that is palindrome.\n  $postfix = find_postfix_of($string);\n\
    \  $reverse_postfix = substr($postfix, 0, strlen($postfix) - 1) . strrev($postfix);\n\
    \n  // Append palindrome prefix to postfix.\n  return $string . $reverse_postfix;\n\
    }\n", "    $length = strlen($string);\n    if ($length < 2) return $string;\n\
    \    $postfix = substr($string, $length - 1);\n    $reversed = strrev($postfix);\n\
    \    return substr($string, 0, $length - 1) . $reversed . $string;\n}\n\n/**\n\
    \ * Find a substring that is a palindrome of a given string.\n * Algorithm idea\
    \ is similar to the first algorithm implemented, but with two additions:\n * -\
    \ First step reduces the number of loops by 2\n * - Second step makes sure to\
    \ only return palindromes that are longer than the given string\n */", "    $postfix_length\
    \ = strlen($string);\n    $reverse = strrev($string);\n    $length = strlen($reverse);\n\
    \    for ($i = 0; $i < $postfix_length; $i++) {\n        if ($string[$i] === $reverse[$i])\
    \ {\n            $postfix_length -= $i;\n            break;\n        }\n    }\n\
    \    for ($i = 0; $i < $length; $i++) {\n        $string .= $reverse[$i];\n  \
    \  }\n    return $string;\n}\n", "  $postfix_length = strlen($string);\n  $postfix\
    \ = substr($string, 0, $postfix_length-1);\n  $palindrome_prefix = substr($string,\
    \ 0, $postfix_length);\n\n  return $palindrome_prefix . strrev($postfix);\n}\n",
  "    $end = $strlen = strlen($string);\n    for ($i = $strlen; $i >= 1; $i--) {\n\
    \        if ($string[$i] != $string[$strlen - $i]) {\n            $string = $string\
    \ . substr($string, $strlen - $i, 1);\n            break;\n        }\n    }\n\
    \    return $string;\n}\n", "  // find longest postfix that is palindrome\n  $postfix\
    \ = substr($string, -1 * strrev($string));\n  // build up the palindrome and return\n\
    \  return $string . strrev(substr($string, 0, -1 * strrev($postfix)));\n}\n</code>\n\
    <|/ a tags=php,algorithm,palindrome |>\n<| c |>\nThanks for your reply, but it's\
    \ not working. It's not printing any palindrome.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is O(M + N) where M is the longest string and N is the number of characters\
    \ in the string.  Your algorithm is O(N).  To make this work with large strings,\
    \ you'll need to use something like Boyer-Moore or Knuth-Morris-Pratt to reduce\
    \ the complexity of doing the reverse search to O(1).\n<|/ c |>\n<| c |>\nYes,\
    \ you're right, but it's also O(N) algorithm. Just the algorithm is optimized\
    \ to find palindromes.\n<|/ c |>\n<| c |>\nIt's O(N) in the worst case, because\
    \ of the need to call strrev (once for the longest string and once for the substring\
    \ that is equal to the reverse of the longest).  It's O(N) in the best case, because\
    \ there's no strrev call at all.  So it's O(1), but O(N) is still O(N).\n<|/ c\
    \ |>\n<| a |>\n<code>", "    $reversedString = strrev($string);\n    $longestPalindrome\
    \ = substr($string, 0, -1);\n    for ($i = strlen($string) - 1; $i >= 0; $i--)\
    \ {\n        if (substr($reversedString, $i, 1) == substr($string, $i, 1)) {\n\
    \            $reversedString = substr($reversedString, 0, $i) + substr($reversedString,\
    \ $i + 1);\n            $longestPalindrome = substr($string, 0, -1) + $reversedString;\n\
    \            break;\n        }\n    }\n    return $longestPalindrome;\n}\n", " \
    \   $len = strlen($string);\n    $palindrome = '';\n    $reversed_string = $string;\n\
    \    for ($i = 0; $i < $len; ++$i) {\n        $char = substr($string, $i, 1);\n\
    \        if (!isPalindrome($char)) {\n            $reversed_string .= substr($reversed_string,\
    \ 0, -1);\n            $reversed_string .= $char;\n        } else {\n        \
    \    $palindrome .= $char;\n        }\n    }\n    return $palindrome;\n}\n", " \
    \   $start = $end = 0;\n    $length = strlen($string);\n\n    while (($start <\
    \ $length) && ($string[$start] == $string[$end])) {\n        $start++;\n     \
    \   $end++;\n    }\n    if ($start == $end) {\n        return $string;\n    }\n\
    \n    $palindrome = substr($string, $start, $end - $start + 1);\n    return $palindrome\
    \ . substr($string, $end - $start, $end - $start + 1);\n}\n", "    // Find first\
    \ longest postfix of supplied string.\n    $postfix = substr($string, -1);\n \
    \   $prefix_length = 0;\n    for ($i = strlen($string) - 1; $i >= 0; $i--) {\n\
    \        $prefix_length += strlen($string[$i]);\n        if ($string[$i] == $postfix)\
    \ {\n            $postfix = substr($string, -$i);\n            $prefix_length\
    \ = $i + 1;\n            break;\n        }\n    }\n    // Add reversed prefix\
    \ to the end of the string.\n    return $string . $reverse_of_substr($string,\
    \ $prefix_length);\n}\n", "    $reversed = substr($string, strlen($string) / 2\
    \ - 1, strlen($string) / 2);\n    return $string . strrev($reversed);\n}", " \
    \   $suffix = '';\n    $length = strlen($string);\n    while ($length > 0) {\n\
    \        $suffix_length = ($length % 2 == 1) ? $length + 1 : $length - 1;\n  \
    \      $postfix = substr($string, -$suffix_length);\n        $postfix = reverse($postfix);\n\
    \        $postfix = str_replace(' ', '', $postfix);\n        $palindrome = substr($string,\
    \ 0, -$suffix_length).$postfix.substr($string, -$length);\n        if ($palindrome\
    \ == $string) {\n            return $palindrome;\n        }\n        $length =\
    \ floor($length / 2);\n        $suffix = $postfix.$suffix;\n    }\n    return\
    \ '';\n}\n", "  // $string = strtolower($string);\n  // If the string length is\
    \ zero or one character then it must be a palindrome and can be returned immediately.\n\
    \  if (strlen($string) < 2 || strlen($string) > 10) return $string;\n  $length\
    \ = strlen($string);\n  $postfix = substr($string, $length - 1);\n  $postfix_reversed\
    \ = strrev($postfix);\n  // Reverse the string prefix that comes before the palindrome\
    \ suffix.\n  $prefix_reversed = strrev($string);\n  // Append the reversed string\
    \ prefix to the end of the palindromic string.\n  $palindromic_string = $postfix_reversed\
    \ . $prefix_reversed;\n  // Return the palindromic string.\n  return $palindromic_string;\n\
    }\n", "    $postfix = substr($string, -1);\n    $prefix_length = strlen(substr($string,\
    \ 0, -1));\n    $reversed_postfix = strrev($postfix);\n    $palindromic = $string\
    \ . $reversed_postfix;\n    return $palindromic . $string;\n}\n", "    $suffix\
    \ = '';\n    $prefix = substr($string, 0, -1);\n    $reverse = strrev(substr($prefix,\
    \ 0, -1));\n    $suffixLen = strlen($reverse) - 1;\n    if ($suffixLen > 0) {\n\
    \        $suffix = substr($reverse, 0, $suffixLen);\n    }\n    $palindrome =\
    \ $prefix . $suffix . $string;\n    return $palindrome;\n}\n</code>\n<|/ a |>\n\
    <| a |>\nHere is a recursive version\n<code>", "    $stack = [];\n    $palindrome\
    \ = '';\n    $length = 0;\n\n    $length = strlen($string);\n\n    // Check for\
    \ odd length\n    if ($length & 1) return ''; // If not even, return empty string\n\
    \n    for ($i = 0; $i < $length; $i++) {\n        // Check current character\n\
    \        if ($string[$i] != $string[$length - $i - 1]) {\n            // Reverse\
    \ string\n            $palindrome = str_split(strrev($string), 2);\n\n       \
    \     // Append reverse of string preceding current character\n            for\
    \ ($j = $length - 1; $j > $i; $j--) {\n                $stack[] = $palindrome[$j];\n\
    \            }\n\n            // Append current character\n            $stack[]\
    \ = $string[$i];\n\n            // Check for palindrome\n            $palindrome_length\
    \ = strlen($palindrome);\n            if ($palindrome_length < $length) {\n  \
    \              return '';\n            }\n        }\n    }\n    // Return result\n\
    \    return implode('', $stack);\n}", "    // Store the longest postfix of $string\
    \ that is a palindrome\n    $longest_post_match = '';\n    $longest_palindrome\
    \ = '';\n    // Loop $string from start (0) to end ($length-1) so that we can\n\
    \    // determine longest postfix match\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        // If $longest_post_match is not set, set it to $string\n \
    \       if (!isset($longest_post_match)) {\n            $longest_post_match =\
    \ $string[$i];\n        // If the last character in $longest_post_match match\
    \ the last character in $string\n        } elseif ($string[$i] == $longest_post_match)\
    \ {\n            // Then append the postfix $longest_post_match to $longest_palindrome\n\
    \            $longest_palindrome .= $longest_post_match;\n            // And reset\
    \ $longest_post_match to $string[$i]\n            $longest_post_match = $string[$i];\n\
    \        // Else, set $longest_post_match to $string[$i]\n        } else {\n \
    \           $longest_post_match = $string[$i];\n        }\n    }\n    // Append\
    \ to the end of $longest_palindrome the reverse of the $longest_post_match\n \
    \   $longest_palindrome .= strrev($longest_post_match);\n    return $longest_palindrome;\n\
    }", "    $len = strlen($string);\n    $reversed = '';\n    $suffix = '';\n   \
    \ $palindrome = '';\n\n    for ($i = 1; $i <= $len; $i++) {\n        $reversed_part\
    \ = substr($string, 0, $len - $i);\n        $prefix_part = substr($string, 0,\
    \ $i - 1);\n        if ($reversed_part == $prefix_part) {\n            $suffix\
    \ = ($reversed_part . $suffix);\n        } else {\n            $palindrome = ($palindrome\
    \ . $reversed_part . $suffix);\n        }\n    }\n    return $palindrome;\n}",
  "    if (empty($string)) {\n        return '';\n    }\n\n    $postfix_length  =\
    \ strlen($string);\n    $postfix_start_index = max((int)(($postfix_length / 2)\
    \ - 1), 0);\n    $reversed_string   = substr($string, $postfix_length);\n\n  \
    \  for ($i = 0; $i < $postfix_start_index; $i++) {\n        $reversed_string =\
    \ str_repeat($reversed_string, 2);\n    }\n\n    return $string . $reversed_string;\n\
    }\n\n/**\n * Test if an address is an IP or a domain name.\n *\n * @param string\
    \ $address The address to test\n * @return bool\n */", "    $start = strlen($string);\n\
    \    $end = strlen($string);\n    $middle = intval($start / 2);\n\n    $reversed\
    \ = str_repeat(\"0\", $end);\n    $reversed = str_replace(array(\"0\", \"1\"),\
    \ array(\"1\", \"0\"), $reversed);\n\n    $prefix_reversed = substr($string, 0,\
    \ $middle);\n    $prefix_reversed = str_replace(array(\"0\", \"1\"), array(\"\
    1\", \"0\"), $prefix_reversed);\n\n    $suffix = substr($string, $middle);\n\n\
    \    $postfix = substr($string, 0, $start) . $reversed;\n\n    return $prefix_reversed\
    \ . $suffix . $postfix;\n}\n", "    $reversed = '';\n    $longest = 0;\n\n   \
    \ $reversed_strings = array();\n    foreach(array_reverse(str_split($string))\
    \ as $value) {\n        $reversed_strings[] = strrev($value);\n    }\n    \n \
    \   foreach ($reversed_strings as $reversed_string) {\n        if (strlen($reversed_string)\
    \ > $longest) {\n            $longest = strlen($reversed_string);\n        }\n\
    \    }\n\n    for ($i = 0; $i < $longest; $i++) {\n        $reversed .= $reversed_strings[$i];\n\
    \    }\n\n    $string .= $reversed;\n\n    return $string;\n}\n</code>\n<|/ a\
    \ tags=palindrome,algorithm,php dscore=1 |>\n<| c |>\nThank you for your answer,\
    \ it works but for strings containing only 1 or 2 characters it doesn't return\
    \ a palindrome.\n<|/ c |>\n<| c |>\nThank you for your feedback. I fixed the error\
    \ - it now should work for all possible cases. But it still doesn't return true\
    \ when given a string is either empty or only one character long :)\n<|/ c |>\n\
    <| a dscore=0 |>\nThis is my solution, I have only tested it on cases of length\
    \ 2 and 3, but it worked for me\n<code>", "    $reverse = '';\n    for ($i = 0;\
    \ $i <= strlen($string) - 1; $i++) {\n        $reverse .= $string[$i];\n    }\n\
    \n    $middle = substr($string, strlen($string) / 2, strlen($string));\n    $reverse_middle\
    \ = substr($reverse, strlen($reverse) / 2, strlen($reverse));\n\n    if ($middle\
    \ == $reverse_middle) {\n        return $string;\n    }\n    return $string .\
    \ $reverse;\n}\n</code>\n<|/ a dscore=0 tags=php |>\n<| c |>\nThanks for the answer.\
    \ What i meant is the way you calculate the middle. Is it possible, without doing\
    \ that way, to get the middle part of a string? And if you can explain your code,\
    \ i can understand it better. Thanks\n<|/ c |>\n<| c |>\n- What do you mean by\
    \ middle part? The first half of the string or the second half?\n<|/ c |>\n<|\
    \ c |>\nI want the first half. So i need to calculate how many character i should\
    \ add for that?\n<|/ c |>\n<| c |>\nI need the second half. Thanks anyway for\
    \ the answer.\n<|/ c |>\n<| c |>\n- Ah I see, that makes the code more complicated.\
    \ I'll try to edit it out.\n<|/ c |>\n<| a tags=php dscore=0 |>\nIf your string\
    \ length is even then you find the middle by using \n<code>\n$middle = intval($strlen\
    \ / 2);\n$first_half = substr($str,0,$middle);\n$last_half = substr($str,$middle);\n\
    </code>\nthen compare these two halves and return one if it is a palindrome otherwise\
    \ return 0\n<|/ a |>\n<| c |>\nYou don't need to do that `intval()` call. `$middle\
    \ = ($strlen / 2)` will do fine.\n<|/ c |>\n<| c |>\nI need the second half. Thanks\
    \ anyway for the answer.\n<|/ c |>\n<| a tags=php |>\nHere's another solution\
    \ that uses the substr() function to get subsections of the string, which makes\
    \ it easier to compare the substrings themselves rather than to calculate the\
    \ middle of the string.\n<code>", "  // Find the longest postfix of supplied string\
    \ that is a palindrome.\n  $postfix = substr($string, -1);\n  $postfix = strrev($postfix);\n\
    \  $postfix = $string . $postfix;\n\n  return $postfix;\n}\n", "  $reverse = substr($string,\
    \ strlen($string)/2, strlen($string));\n  return $string . $reverse;\n}", "  \
    \  if ($string == '') return $string;\n    if (strlen($string) == 1) {\n     \
    \   return $string;\n    }\n    $result = $string;\n    $result[0] = strtolower($result[0]);\n\
    \    $result_length = strlen($result);\n    $suffix_length = strlen($string) -\
    \ 1;\n    for ($i = 0; $i < $suffix_length; $i++) {\n        if ($suffix !== substr($string,\
    \ $i + 1, strlen($string))) {\n            // The suffix does not match the current\
    \ string.\n            // Get the length of the current suffix.\n            $suffix\
    \ = substr($string, $i + 1, strlen($string));\n            $reverse_suffix = '';\n\
    \            for ($j = 0; $j < strlen($suffix); $j++) {\n                $reverse_suffix\
    \ .= $suffix[$j];\n            }\n            // Append the reversed suffix.\n\
    \            $result .= $reverse_suffix;\n        } else {\n            // The\
    \ suffix matches current string.\n            // No need to reverse anything.\n\
    \            return $result;\n        }\n    }\n}\n\n$test_string = 'cata';\n\
    $test_input = 'cat';\necho make_palindrome($test_string);", "\t$max_postfix_length\
    \ = 0;\n\t$postfix_length = 0;\n\tfor ($i = 0; $i < strlen($string); $i++) {\n\
    \t\tif ($string[$i] === 'a') {\n\t\t\t$postfix_length++;\n\t\t} else {\n\t\t\t\
    $postfix_length--;\n\t\t}\n\t\tif ($postfix_length < 0) {\n\t\t\tbreak;\n\t\t\
    }\n\t\t$max_postfix_length = max($max_postfix_length, $postfix_length);\n\t}\n\
    \n\t$postfix_length = $max_postfix_length + 1;\n\n\t$palindrome = \"\";\n\t$reverse_string\
    \ = \"\";\n\n\tfor ($i = $max_postfix_length; $i >= 0; $i--) {\n\t\t$reverse_string\
    \ .= $string[$i];\n\t}\n\n\tif ($max_postfix_length === 0) {\n\t\treturn $string;\n\
    \t}\n\n\tfor ($i = 0; $i < $max_postfix_length; $i++) {\n\t\tif ($string[$i] ===\
    \ $reverse_string[$i]) {\n\t\t\t$palindrome .= $string[$i];\n\t\t} else {\n\t\t\
    \t$palindrome .= $reverse_string[$i];\n\t\t}\n\t}\n\n\treturn $palindrome;\n}\n\
    \n$palindrome = make_palindrome('cat');\nprint \"'$palindrome'\\n\";\nprint \"\
    '$palindrome' is palindrome\\n\";\nprint \"'$palindrome' is reverse of 'cat'\\\
    n\";\n", "    if ($string === '') {\n        return '';\n    }\n\n    // Find\
    \ the longest postfix that is palindrome.\n    $longestPalindrome = find_longest_palindrome($string);\n\
    \    $longestPalindromeLen = strlen($longestPalindrome);\n\n    // Append the\
    \ reverse of the string prefix that comes before this suffix\n    // to the end\
    \ of the string, so that the palindrome is always found at the end.\n    $newString\
    \ = $string . $reverse($string, 0, $longestPalindromeLen);\n    return $newString;\n\
    }", "  $prefix_length = $string; // This becomes our \"prefix length\"\n  $palindrome\
    \ = $prefix_length . reverse($prefix_length, $prefix_length);\n  return $palindrome;\n\
    }\n", "    // If the string is already a palindrome just return the string.\n\
    \    if (strlen($string) > 2 && ($string[0] == $string[strlen($string) - 1]))\
    \ {\n        return $string;\n    }\n\n    $length = strlen($string);\n    $palindrome\
    \ = '';\n    $i = 0;\n    $j = strlen($string) - 1;\n    while ($i <= $j) {\n\
    \        // Check if the characters are equal, if so add them to the palindrome.\n\
    \        if ($string[$i] != $string[$j]) {\n            $palindrome .= $string[$i];\n\
    \        }\n\n        $i++;\n        $j--;\n    }\n\n    // Append the reverse\
    \ of the suffix that comes before the palindrome\n    // at the end of the string\
    \ and return it.\n    $palindrome .= substr($string, 0, $i);\n    return $palindrome;\n\
    }\n", "  $palindrome = $string;\n  $prefix = '';\n  $max_length = 0;\n\n  // Find\
    \ the longest postfix that is a palindrome.\n  while ($palindrome != substr($palindrome,\
    \ 0, -1)) {\n    $max_length++;\n    array_unshift($prefix, $palindrome);\n  \
    \  $palindrome = substr($palindrome, 1, -1);\n  }\n\n  // Add postfix of suffix\
    \ that comes before the palindromic suffix.\n  if ($prefix != '') {\n    $palindrome\
    \ .= substr($prefix, -1);\n  }\n\n  // Reverse the string to make it a palindrome.\n\
    \  $reversed = strrev($palindrome);\n\n  // Append the palindromic prefix to the\
    \ reverse of postfix of suffix.\n  $reversed .= substr($prefix, 0, $max_length);\n\
    \n  return $reversed;\n}\n", "    return $string . (strrpos($string, $string)\
    \ - 1);\n}\n", "    $len = strlen($string);\n    if ($len === 0) {\n        return\
    \ '';\n    }\n    $postfix = strrev($string);\n    $longest = 0;\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        $suffix = substr($string, $i, 1);\n       \
    \ if ($suffix === $postfix) {\n            $longest = max($longest, $i);\n   \
    \     } else {\n            break;\n        }\n    }\n    $suffix = substr($string,\
    \ $i, 1);\n    $prefix = substr($string, 0, $i);\n    $palindrome = $prefix .\
    \ strrev($suffix);\n    $longest = max($longest, strlen($prefix));\n    return\
    \ substr($palindrome, 0, $longest);\n}\n", "    $reverse = substr($string, 0,\
    \ -1);\n    if ($string === $reverse) {\n        return $string;\n    }\n    $result\
    \ = \"\";\n    $length = strlen($string);\n    $index = 0;\n    while ($index\
    \ < $length) {\n        $result .= $string[$index];\n        $index += strlen($string)\
    \ - $index;\n        $first = $string[$index];\n        $index += strlen($first);\n\
    \        $last = $string[$index];\n        if ($last !== $first) {\n         \
    \   $result .= $first;\n            $index += strlen($first);\n        }\n   \
    \ }\n    return $result . $reverse;\n}\n", "  $len = strlen($string);\n  $reverse\
    \ = '';\n  for ($i = 0; $i < $len; $i++) {\n    $reverse .= $string[$len-1 - $i];\n\
    \  }\n  return $string.$reverse;\n}\n", "  // Find the longest postfix that is\
    \ a palindrome.\n  $postfix = substr($string, -1);\n  $reverse = strrev($postfix);\n\
    \n  // Check if reverse is equal to the original string.\n  // If so, return the\
    \ original string.\n  return $postfix === $reverse ? $string : $string . $reverse;\n\
    }\n", "    // Find the length of the palindrome\n    $length = strlen($string);\n\
    \    // Find the longest postfix of $string that is a palindrome\n    $reverse\
    \ = strrev(substr($string, 0, $length));\n    // Find the longest postfix of $string\
    \ that is a palindrome\n    $prefix = substr($string, $length - strlen($reverse));\n\
    \    // Append the reverse of the postfix to the end string\n    return $prefix.$reverse;\n\
    }", "    return $string . str_repeat(\n        strrev($string), strlen($string)\
    \ - strlen($string) % strlen($string) - 1);\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis is one of the only solutions that makes use of PHP's [string operators](http://php.net/manual/en/language.operators.string.php).\n\
    <|/ c |>\n<| a |>\nFor those who have difficulties to understand the code of others:\n\
    <code>\n<?php", "    $maxLength = 0;\n    $suffix = false;\n    foreach(explode($string,\
    \ ' ') as $word)\n        if(!is_numeric($word)) {\n            if(strlen($word)\
    \ > $maxLength) {\n                $maxLength = strlen($word);\n             \
    \   $suffix = $word;\n            }\n        }\n    \n    if($maxLength == 0)\
    \ {\n        return '';\n    }\n    \n    $suffixLen = strlen($suffix);\n    $prefix\
    \ = substr($string, 0, strlen($suffix));\n    \n    $reversePrefix = strrev($prefix);\n\
    \    if(substr($reversePrefix, 0, $suffixLen) != $suffix) {\n        $reversePrefix\
    \ .= substr($suffix, 0, $suffixLen);\n    }\n    \n    $result = $prefix . $reversePrefix;\n\
    \    \n    return $result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI love this\
    \ answer, because it also deals with letters with accents, like \xE9 and \xE8\
    . Nice.\n<|/ c |>\n<| a dscore=2 |>\nFor those who are looking for a Javascript\
    \ function that returns palindrome words starting with the letters in the input,\
    \ this will work:\n<code>", "    // Store the longest postfix string and associated\
    \ index\n    $longest_postfix = '';\n    $longest_postfix_index = 0;\n\n    //\
    \ Create a string prefix that comes before the longest postfix\n    $string_prefix\
    \ = '';\n    for ($i = 0; $i < strlen($string); $i++) {\n        $string_prefix\
    \ .= substr($string, 0, $i);\n    }\n\n    // Find the longest postfix that is\
    \ a palindrome\n    for ($i = 0; $i < strlen($string); $i++) {\n        // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix\n        $longest_postfix_index = strrpos($string, $string_prefix, $i);\n\
    \        $longest_postfix .= substr($string, 0, $longest_postfix_index);\n   \
    \ }\n\n    // Return the string prefix and associated palindrome index\n    return\
    \ $string_prefix . $longest_postfix;\n}\n", "    $postfix = find_postfix_length($string);\n\
    \    $prefix_length = strlen($string) - $postfix;\n    if ($prefix_length < 0)\
    \ {\n        throw new Exception('Negative prefix length detected');\n    }\n\
    \    $palindrome = '';\n    for ($i = 0; $i < $prefix_length; $i++) {\n      \
    \  $palindrome .= $string[$i];\n    }\n    $palindrome .= str_rev($string[$postfix\
    \ - 1]);\n    return $palindrome;\n}", "  $postfix = $string;\n  $reverse_prefix\
    \ = substr($postfix, 0, strrev($postfix));\n  return $reverse_prefix . $reverse_prefix[strlen($reverse_prefix)\
    \ - 1];\n}", "  $prefix_length = 0;\n  $prefix_string = '';\n  $suffix = '';\n\
    \  $postfix_length = 0;\n  $postfix_string = '';\n  while ($string) {\n    $postfix_string\
    \ = $string . str_reverse($string);\n    $postfix_length = strlen($postfix_string);\n\
    \    $suffix = $postfix_string . $string;\n    if ($postfix_length >= $prefix_length\
    \ && $postfix_length < strlen($suffix)) {\n      return $suffix;\n    }\n    $prefix_length\
    \ = strlen($string);\n    $prefix_string = $string;\n    $string = substr($string,\
    \ 1);\n  }\n}", "    $chars = str_split($string);\n    $longest = 0;\n    $longestLetter\
    \ = '';\n    $longestLen = 0;\n\n    foreach ($chars as $i => $char) {\n     \
    \   if (strlen($char) > $longestLen) {\n            $longestLen = strlen($char);\n\
    \            $longestLetter = $char;\n        }\n    }\n\n    $prefix = $string;\n\
    \    $suffix = '';\n    $reversed = strrev($prefix);\n\n    foreach ($chars as\
    \ $i => $char) {\n        if ($i > 0 && !in_array($char, $reversed)) {\n     \
    \       $suffix = $char;\n            break;\n        }\n    }\n\n    $palindrome\
    \ = $prefix . $suffix . $reversed;\n    return $palindrome;\n}\n", "    $length\
    \ = strlen($string);\n    $longest = maxLength($string);\n    $palindrome = '';\n\
    \    $i = 0;\n    $suffix = '';\n    while ($i < $length) {\n        // Find longest\
    \ possible postfix of $string.\n        // This will be the suffix for reversing\
    \ the prefix.\n        $postfix = substr($string, $i, $longest);\n        $postfix\
    \ = make_reverse_of_prefix($postfix, $string, $i);\n        if ($suffix == $postfix)\
    \ {\n            // The postfix is a palindrome.\n            // Append to the\
    \ palindrome and we're done.\n            $palindrome .= $postfix;\n         \
    \   break;\n        } else {\n            // The postfix is not a palindrome.\n\
    \            // The string does not begin with the palindromic suffix.\n     \
    \       $suffix = $postfix;\n            // Find the next postfix that is not\
    \ a palindrome.\n            $i += $longest - 1;\n        }\n    }\n    return\
    \ $palindrome;\n}\n", "  $palindrome = '';\n  $length_of_longest_postfix = 0;\n\
    \  for ($i = 0; $i < strlen($string); $i++) {\n    $postfix = substr($string,\
    \ $i, 1);\n    if ($i == 0 || $postfix != substr($string, $i - 1, 1)) {\n    \
    \  $palindrome .= $postfix;\n    }\n    $length_of_longest_postfix += strlen($postfix);\n\
    \  }\n  $palindrome .= str_repeat(substr($string, -1), $length_of_longest_postfix);\n\
    \  return $palindrome;\n}\n\n$postfix = make_palindrome('abcbc');\n", "  // Simpler\
    \ to reverse the supplied string before starting.\n  $reversed_string = $string;\
    \ // \"cat\" => \"tac\"\n  while ($reversed_string) {\n    $reversed_string =\
    \ strrev($reversed_string); // \"tac\" => \"tac\"\n  }\n\n  // Append the palindrome\
    \ reverse of the string prefix.\n  // \"cat\" => \"catac\"\n  return $string .\
    \ $reversed_string;\n}", "    $palindrome = '';\n    $length = strlen($string);\n\
    \    $palindrome = substr($string, 0, $length);\n    $palindrome = str_reverse($palindrome);\n\
    \    $palindrome .= substr($string, 0, $length - strlen($palindrome));\n\n   \
    \ return $palindrome;\n}\n</code>\n<|/ a tags=php,algorithm,palindrome |>\n<|\
    \ c |>\nI think this algorithm has a bug. it seems that the condition `if($palindrome[$i]\
    \ != $string[$i+$length-1])` can never be true after the first iteration. the\
    \ condition should be `if($i+$length <= $length-1&&$palindrome[$i] != $string[$i+$length-1])`\n\
    <|/ c |>\n<| c |>\nyou're right, I was missing a part of the loop. I edited my\
    \ answer. Thanks!\n<|/ c |>\n<| c |>\nThanks man! but I found something different.\
    \ the algorithm that you gave me didn't work for long inputs. so I tried to do\
    \ what u suggested and I fixed my algorithm and I used this condition. `if($i+$length\
    \ <= $length-1&&$palindrome[$i] == $string[$i+$length-1])`\n<|/ c |>\n<| c |>\n\
    I updated my answer with new algorithm, which I believe will work for long inputs.\n\
    <|/ c |>\n<| c |>\nthe algorithm doesn't work for strings like 'aaaaaaaaa'.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe fastest way is by creating a palindrome function\
    \ which uses recursion. It takes a string, and checks whether it is the palindrome.\
    \ It also passes the $string and $offset on recursion.\n<code>", "  $postfix =\
    \ $string;\n  $palindrome = '';\n\n  $reverse_postfix = '';\n  for ($i = 1; $i\
    \ <= strlen($postfix); $i++) {\n    $reverse_postfix .= $postfix[$i];\n  }\n \
    \ strrev($reverse_postfix);\n\n  $reverse_prefix_length = 0;\n  for ($i = 1; $i\
    \ <= strlen($postfix); $i++) {\n    if ($postfix[$i] == $reverse_postfix[$i])\
    \ {\n      $reverse_prefix_length = $i;\n      break;\n    }\n  }\n\n  // We append\
    \ the reverse of the prefix to the postfix to create our palindromic string.\n\
    \  $palindrome .= substr($postfix, 0, $reverse_prefix_length) . substr($reverse_postfix,\
    \ 0, $reverse_prefix_length);\n\n  // If there is only 1 character in the postfix\
    \ and no character in the prefix, we have a palindrome.\n  if (strlen($postfix)\
    \ == 1 && $reverse_prefix_length == 0) {\n    return $palindrome;\n  }\n\n  //\
    \ Now we know that we have a palindrome if there is no character in the prefix.\n\
    \  // We can start building the palindrome by adding the reverse of the prefix\
    \ to the postfix until we have\n  // added just one character to the postfix.\n\
    \  for ($i = 1; $i <= strlen($postfix); $i++) {\n    if ($postfix[$i] == $reverse_postfix[$i])\
    \ {\n      $palindrome .= substr($reverse_postfix, 0, $i) . substr($postfix, 0,\
    \ $i);\n      break;\n    }\n  }\n\n  return $palindrome;\n}\n\n$string = 'abc';\n\
    echo make_palindrome($string);\n</code>\nThe output of this is:\n<code>\nabcabc\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThanks I liked your answer but I am new to\
    \ php and can't understand it. I tried to understand it but i failed. If you have\
    \ time please explain it to me. thanks\n<|/ c |>\n<| c |>\nSure, I'll post some\
    \ explanation later today when I'm back in my office computer\n<|/ c |>\n<| c\
    \ |>\nI've added a code block which should help you understand what it's doing.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's my implementation of Kevin's solution in Python:\n\
    <code>\ndef make_palindrome(string):\n  postfix = string\n  palindrome = ''\n\n\
    \  reverse_postfix = ''\n  for x in range(1, len(postfix)):\n    reverse_postfix\
    \ += postfix[x]\n\n", "    if ($string == '') return $string;\n    $start = preg_match('/[a-z]/i',\
    \ $string);\n    if ($start == 0) return $string;\n    $result = $string;\n  \
    \  for ($i = $start - 1; $i >= 0; $i--) {\n        $result = str_replace($string[$i],\
    \ substr($string, 0, $i), $result);\n    }\n    return $result;\n}", "    $suffix\
    \ = substr($string, -1);\n    $postfix = substr($string, 0, -1);\n    $postfix\
    \ = str_replace(array('a', 'b'), array('d', 'c'), $postfix);\n    return $string\
    \ . $postfix . $suffix;\n}\n", "  $longestLength = 0;\n  $palindrome = \"\";\n\
    \  $palindromePrefix = \"\";\n  for ($i = 0; $i < strlen($string); $i++) {\n \
    \   $palindromePostfix = '';\n    $palindromeSuffix = \"\";\n    for ($j = $i;\
    \ $j < strlen($string); $j++) {\n      if ($j == 0 || $string[$j] != $string[$j-1])\
    \ {\n        $palindromePostfix .= $string[$j];\n      } else {\n        $palindromeSuffix\
    \ .= $string[$j];\n      }\n    }\n    $palindrome = $palindromePostfix . $palindromeSuffix;\n\
    \    if (strlen($palindrome) > $longestLength) {\n      $longestLength = strlen($palindrome);\n\
    \      $palindromePrefix = substr($palindrome, 0, $longestLength - 1);\n     \
    \ $palindromeSuffix = substr($palindrome, $longestLength - 1);\n    }\n  }\n \
    \ $palindrome = $palindromePrefix . $palindrome . $palindromeSuffix;\n  return\
    \ $palindrome;\n}", "\tif (strlen($string) == 0) {\n\t\treturn '';\n\t}\n\n\t\
    // Find the longest postfix of supplied string that is a palindrome.\n\t$postfix\
    \ = substr($string, -1);\n\t$reverse = strrev($string);\n\twhile (substr($reverse,\
    \ 0, strlen($postfix)) == $postfix) {\n\t\t$postfix = substr($postfix, 1);\n\t\
    }\n\n\t// Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n\t$reverse = $reverse . $postfix . strrev($postfix);\n\
    \n\t// Return the reversed palindrome.\n\treturn $reverse;\n}", "    $length =\
    \ strlen($string);\n    $longestPalindrome = '';\n    $shortestPalindrome = '';\n\
    \    $suffix = '';\n\n    while ($length > 0) {\n        $postfix = substr($string,\
    \ 0, $length);\n        $suffix = substr($string, 0, $length-1);\n        $reverse\
    \ = strrev($suffix);\n        if ($postfix === $reverse) {\n            $longestPalindrome\
    \ = $postfix . $suffix;\n        }\n        if (strlen($postfix) > strlen($shortestPalindrome))\
    \ {\n            $shortestPalindrome = $postfix;\n        }\n        $length =\
    \ strlen($string) - 1;\n    }\n    if ($length == 0) {\n        return $string;\n\
    \    }\n    return $longestPalindrome . $shortestPalindrome;\n}\n", "  global\
    \ $reverse, $palindrome;\n\n  $reverse = strrev($string);\n  $post_palindrome_start\
    \ = strpos($reverse, $palindrome);\n  $post_palindrome_end = strlen($string) -\
    \ strpos($string, $reverse, $post_palindrome_start);\n\n  return $post_palindrome_start\
    \ === $post_palindrome_end ? $string . substr($reverse, $post_palindrome_start)\
    \ : substr($string, $post_palindrome_start, $post_palindrome_end) . $palindrome;\n\
    }\n", "    $length = strlen($string);\n    $palindrome = '';\n    for ($i = 0;\
    \ $i < $length; $i++) {\n        $reverse = strrev($string);\n        $palindrome\
    \ = substr($string, 0, $i).$reverse.$palindrome;\n    }\n    return $palindrome;\n\
    }\n", "  $max_post_len = strlen($string);\n  $prefix = '';\n  for ($i = 1; $i\
    \ <= $max_post_len; $i++) {\n    $prefix .= substr($string, 0, $i);\n    $suffix\
    \ = substr($string, -$i);\n    if ($suffix === $reverse($prefix)) {\n      return\
    \ $prefix . $suffix;\n    }\n  }\n  return $string;\n}\n", "    $strlen = strlen($string);\n\
    \    $i = 0;\n    $j = 0;\n    $output = '';\n    while ($i < $strlen) {\n   \
    \     $output = $output . $string[$i];\n        $i++;\n    }\n    $reversed_string\
    \ = strrev($output);\n    $is_palindrome = true;\n    for ($i = $strlen - 1; $i\
    \ >= 0; $i--) {\n        if ($string[$i] != $reversed_string[$i]) {\n        \
    \    $is_palindrome = false;\n            break;\n        }\n    }\n    $new_string\
    \ = '';\n    for ($i = $strlen; $i >= 0; $i--) {\n        $new_string = $new_string\
    \ . $string[$i];\n    }\n    return $is_palindrome ? $new_string : $string;\n}",
  "\t$longest = '';\n\t$postfix_array = $longest_postfix_array($string);\n\tforeach\
    \ ($postfix_array as $postfix_str) {\n\t\tif ($longest != '') {\n\t\t\t$string\
    \ .= substr($postfix_str, strlen($longest));\n\t\t}\n\t\t$string .= strrev($postfix_str);\n\
    \t\t$longest = $postfix_str;\n\t}\n\treturn $string;\n}", "  // Find the longest\
    \ postfix of $string that is a palindrome.\n  $postfix = substr($string, -1);\n\
    \  $postfix = strrev($postfix);\n  if (preg_match('/^' . $postfix . '\\z/s', $string))\
    \ {\n    return $string;\n  }\n  // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n  // If there is\
    \ no 'suffix' postfix then just append the '$string'.\n  $prefix = substr($string,\
    \ 0, -1);\n  if (!preg_match('/^' . $prefix . '\\z/s', $string)) {\n    return\
    \ $string . $postfix;\n  }\n  $result = $string;\n  do {\n    $result = $prefix\
    \ . strrev($result);\n    $postfix = substr($result, -1);\n    $postfix = strrev($postfix);\n\
    \    if (preg_match('/^' . $postfix . '\\z/s', $result)) {\n      return $result;\n\
    \    }\n  } while ($result !== $string);\n  return $string;\n}", "  // Start with\
    \ empty string as palindrome's prefix.\n  $prefix = $string;\n  // Start with\
    \ empty string as palindrome's suffix.\n  $suffix = $string;\n  $longestPalindrome\
    \ = $string;\n  // Find postfix of longest palindrome that begins with a supplied\
    \ string.\n  while ($prefix != $suffix) {\n    // Find postfix of longest palindrome\
    \ that begins with a supplied string.\n    $postfix = substr($string, -1);\n \
    \   // Find the postfix of longest palindrome that ends with a supplied string.\n\
    \    $postfix = substr($postfix, 0, -1);\n    // If postfix of longest palindrome\
    \ is palindromic suffix,\n    // append its postfix to palindrome's suffix.\n\
    \    if ($suffix === $postfix) {\n      // Append its postfix to palindrome's\
    \ suffix.\n      $suffix = $postfix . $suffix;\n    }\n    // If postfix of longest\
    \ palindrome is palindromic prefix,\n    // append its postfix to palindrome's\
    \ prefix.\n    else if ($prefix === $postfix) {\n      // Append its postfix to\
    \ palindrome's prefix.\n      $prefix = $postfix . $prefix;\n    }\n    // If\
    \ postfix of longest palindrome is shorter than supplied string,\n    // increase\
    \ its length in both prefix and suffix by one character.\n    else if (strlen($postfix)\
    \ < strlen($prefix)) {\n      // Increase length of palindrome's suffix.\n   \
    \   $suffix = substr($suffix, 0, strlen($suffix) + 1);\n      // Increase length\
    \ of palindrome's prefix.\n      $prefix = substr($prefix, 0, strlen($prefix)\
    \ + 1);\n    }\n    // If postfix of longest palindrome is longer than supplied\
    \ string,\n    // increase its length in both prefix and suffix by one character.\n\
    \    else if (strlen($postfix) > strlen($prefix)) {\n      // Increase length\
    \ of palindrome's suffix.\n      $suffix = substr($suffix, 0, strlen($suffix)\
    \ + 1);\n      // Increase length of palindrome's prefix.\n      $prefix = substr($prefix,\
    \ 0, strlen($prefix) + 1);\n    }\n    else {\n      // Increase length of palindrome's\
    \ suffix.\n      $suffix = substr($suffix, 0, strlen($suffix) + 1);\n      //\
    \ Increase length of palindrome's prefix.\n      $prefix = substr($prefix, 0,\
    \ strlen($prefix) + 1);\n    }\n    // Find postfix of longest palindrome that ",
  "  $suffix = '';\n  $i = 0;\n  for ($c = strlen($string); $i < $c; $i++) {\n   \
    \ $suffix .= $string[$i];\n  }\n  return $prefix . $suffix . make_palindrome_suffix($string);\n\
    }\n", "    if (empty($string)) {\n        return $string;\n    }\n\n    $max_palindrome_length\
    \ = strlen($string) - 1;\n    $min_palindrome_length = $max_palindrome_length\
    \ - 1;\n\n    $max_palindrome = substr($string, 0, $max_palindrome_length);\n\
    \    $min_palindrome = substr($string, 0, $min_palindrome_length);\n\n    $palindrome\
    \ = $max_palindrome;\n\n    for ($i = 1; $i <= $max_palindrome_length; ++$i) {\n\
    \        $palindrome = substr($palindrome, 0, -1) . strrev($min_palindrome);\n\
    \    }\n\n    return $palindrome;\n}\n</code>\n<|/ a tags=string,reverse,php |>\n\
    <| c |>\nThis doesn't handle the empty string case.\n<|/ c |>\n<| a tags=string,reverse,php\
    \ dscore=2 |>\n<code>\n<?php", "    $palindrome = '';\n    $length = strlen($string);\n\
    \    $index = 0;\n    while ($index < $length) {\n        $palindrome .= substr($string,\
    \ $index, 1);\n        if ($index == 0) {\n            continue;\n        }\n\
    \        $index++;\n        while ($index < $length) {\n            $palindrome\
    \ .= substr($string, $index, 1);\n            $index++;\n        }\n    }\n  \
    \  $reverse = strrev($string);\n    return $palindrome . $reverse;\n}", "    $string\
    \ = $string.\"x\";\n    $result = '';\n    for ($i = strlen($string); $i > 0;\
    \ $i--) {\n        for ($j = 0; $j < $i; $j++) {\n            $char = $string{$j};\n\
    \            $result.=$char;\n        }\n    }\n    $result = strrev($result);\n\
    \    return $result;\n}", "    $palindrome = '';\n    $longest = 0;\n    $longestLen\
    \ = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n        $c = $string[$i];\n\
    \        if ($c !== substr($palindrome, -$i)) {\n            $palindrome .= $c;\n\
    \        }\n        if (strlen($palindrome) > strlen($string) - $longestLen) {\n\
    \            $longest = $i;\n            $longestLen = strlen($palindrome);\n\
    \        }\n    }\n    return $palindrome;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,php,string\
    \ |>\n<| a |>\nI wrote a simple script in python that does just that. It uses\
    \ recursion just like the other answers, but it uses a little more resources.\
    \ It is tested on Python 2.7.5 and it passes all my tests. It is quite straight\
    \ forward and can be easily adapted to PHP using Pearl's implementation. The advantage\
    \ of this implementation is that it does not actually create the palindrome, but\
    \ generates one in the process.\n<code>\ndef palindrome(s):\n  if len(s) == 1:\n\
    \    return True\n  if s[0] == s[-1]:\n    return palindrome(s[1:-1])\n  else:\n\
    \    return palindrome(s[1:-1]) or palindrome(s[0]+s[1:-1])\n\ndef make_palindrome(s):\n\
    \  ps = s\n  for i in range(0, len(s) - 1):\n    if ps[i] != ps[len(s) - 1 - i]:\n\
    \      ps = ps[:i] + '-' + ps[-i:]\n  return ps\n</code>\n<|/ a dscore=0 tags=algorithm,php,string\
    \ |>\n<| a dscore=0 tags=algorithm,php,string |>\nYou can use the function below:\n\
    <code>\n$string = 'test';\n", "    return make_palindrome_aux($string, 0);\n}",
  "  if (!is_string($string))\n    die('Not a string.');\n  // Find longest postfix\
    \ of string that is a palindrome.\n  $iMax = 0;\n  $jMax = 0;\n  $kMax = $iMax;\n\
    \  $jMin = 0;\n  for ($i = 1; $i <= strlen($string); $i++) {\n    // Find prefix\
    \ of string that is a palindrome and length less than or equal to given string.\n\
    \    if (is_palindrome($string, $i, $jMin, $iMax)) {\n      $jMin = $i;\n    \
    \  $kMax = $iMax;\n      $iMax = $i;\n    }\n    if (is_palindrome($string, $i,\
    \ $kMax, $jMax)) {\n      $kMax = $iMax;\n    }\n  }\n  // Determine if suffix\
    \ should be appended to the start of the string or not.\n  $kMin = $kMax - 1;\n\
    \  if ($kMin >= 0) {\n    $jMax = $kMin + 1;\n    return $jMax > strlen($string)\
    \ ? $string.substr($string, $jMax) : $string.'$';\n  }\n  return $string;\n}\n",
  "  $reversed = '';\n\n  // Find the length of the supplied string.\n  // We will\
    \ use it in the next two loops.\n  $len = strlen($string);\n  \n  // Find the\
    \ longest postfix of the supplied string that is a palindrome.\n  $max_length\
    \ = 0;\n  $pos = 0;\n  \n  for ($i = 0; $i < $len; $i++) {\n    $reversed = $reversed\
    \ . $string[$i];\n\n    // Find the postfix that is a palindrome.\n    if ($pos\
    \ == 0) {\n      $postfix = substr($string, 0, $i);\n      \n      // Check if\
    \ the postfix is a palindrome.\n      if ($postfix === $reversed) {\n        \n\
    \        // Save the index of the last character of the postfix.\n        $max_length\
    \ = $i + 1;\n        \n        break;\n      }\n    }\n    $pos++;\n  }\n  \n\
    \  // Append the reverse of the supplied string to the end of the palindromic\
    \ suffix.\n  $string = $string . $reversed;\n  \n  // Return the modified string.\n\
    \  return $string;\n}\n", "  // Start with an empty string.\n  $palindrome = '';\n\
    \  // Iterate over all characters in string.\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    // Find the longest postfix that is a palindrome.\n    $p = $string[$i];\n\
    \    for ($j = strlen($string); $j > $i; $j--) {\n      $p = $string[$j - 1] .\
    \ $p;\n    }\n    // Append reverse of the postfix to the palindrome.\n    $palindrome\
    \ .= $p;\n  }\n  return $palindrome;\n}\n$result = make_palindrome('cata')\n \
    \ . make_palindrome('catac');\necho $result; // catac", "  $len = strlen($string);\n\
    \  if ($len <= 1) {\n    return $string;\n  }\n\n  $reversed_string = substr($string,\
    \ $len-1, $len);\n  return $string . $reversed_string;\n}", "  $string = (string)$string;\n\
    \  $min_prefix_length = min(strlen($string), strrev($string));\n  $suffix = '';\n\
    \  for ($i = 1; $i <= strlen($string); $i++) {\n    if (substr($string, $i - 1,\
    \ 1) !== substr($string, $i, 1)) {\n      $suffix .= substr($string, $min_prefix_length,\
    \ $i);\n      break;\n    }\n  }\n  $string .= $suffix;\n  return $string;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nIt does not work for strings containing a\
    \ single character. Ex: 'a'\n<|/ c |>\n<| a tags=string,php,reverse |>\n<code>\n\
    <?php\n", "  global $palindromes;\n  // Store the original string length to check\
    \ for palindrome postfix length.\n  $len = strlen($string);\n  // Store the longest\
    \ postfix length to be used as a starting point for reverse iteration\n  $postfix_len\
    \ = strlen($palindromes[$len]) - 1;\n  for ($i = $len - 1; $i >= $postfix_len;\
    \ $i--) { \n    $palindromes[$len] = $palindromes[$i] . $palindromes[$len];\n\
    \  }\n  return $string;\n}", "\t// First reverse the supplied string that comes\
    \ before the first postfix palindrome that is found.\n\t// This way we can always\
    \ reverse the postfix string later when we compare it with the prefix.\n\t$reversed_string\
    \ = strrev($string);\n\t\n\t$palindrome_postfix_length = 0;\n\t$longest_postfix_length\
    \ = 0;\n\t$longest_postfix_length_key = 0;\n\t$longest_postfix_length_prefix =\
    \ $string;\n\t\n\tforeach($strings as $string) {\n\t\t$string_postfix_length =\
    \ strlen($string);\n\t\t\n\t\tif($string_postfix_length > $longest_postfix_length\
    \ && $string_postfix_length > $palindrome_postfix_length) {\n\t\t\t$longest_postfix_length\
    \ = $string_postfix_length;\n\t\t\t$longest_postfix_length_key = $strings[$longest_postfix_length_key];\n\
    \t\t\t$longest_postfix_length_prefix = $string;\n\t\t}\n\t\t\n\t\tif($string ===\
    \ $reversed_string) {\n\t\t\t$palindrome_postfix_length = $string_postfix_length;\n\
    \t\t\t$palindrome_postfix_length_key = $strings[$longest_postfix_length_key];\n\
    \t\t\t$longest_postfix_length_key = $longest_postfix_length_key;\n\t\t}\n\t}\n\
    \t\n\t// Now append to the end of the supplied string a reverse of the $longest_postfix_length_prefix\
    \ that comes before the first postfix palindrome that is found.\n\t$append_string\
    \ = $longest_postfix_length_prefix.$reversed_string;\n\t\n\treturn $append_string;\n\
    }\n", "    $reversed_string = strrev($string);\n    $reverse_postfix = strrev($reversed_string);\n\
    \    $prefix_length = 1;\n    $postfix_length = 0;\n    while ($postfix_length\
    \ < strlen($reversed_string)) {\n        $prefix_length++;\n        $postfix_length\
    \ = strrpos($reverse_postfix, $string, $postfix_length);\n        if ($postfix_length\
    \ < 0) {\n            return '';\n        }\n    }\n    return substr($string,\
    \ 0, $prefix_length) . strrev($reverse_postfix);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    While this does give the correct answer, I'm pretty sure the OP wants to find\
    \ this in a different way (without using loops)\n<|/ c |>\n<| c |>\nThe OP says:\
    \ \" without using loops\"\n<|/ c |>\n<| c |>\nThat is not the definition of loops,\
    \ they mean recursion.\n<|/ c |>\n<| c |>\nWell, I suppose I should edit the wording,\
    \ but I meant loops without using recursion. I'll edit the answer to be more precise.\n\
    <|/ c |>\n<| c |>\n, your second solution is not the correct one for me (I cannot\
    \ use recursion).\n<|/ c |>\n<| a tags=php,string dscore=2 |>\nThis doesn't use\
    \ a loop, but I think it is fairly efficient:\n<code>", "    // Find the length\
    \ of string prefix.\n    $prefix_length = 0;\n    $prefix_index = $start_index\
    \ = -1;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i]\
    \ == $string[strlen($string) - 1 - $i]) {\n            $prefix_length++;\n   \
    \         if ($prefix_length >= $i) {\n                $prefix_index = $i;\n \
    \               $prefix_length = 0;\n            }\n        }\n    }\n    if ($prefix_length\
    \ == 0) {\n        return $string;\n    }\n    // Find the longest postfix that\
    \ is a palindrome.\n    $postfix_length = 0;\n    $postfix_index = $end_index\
    \ = -1;\n    for ($i = 0; $i < strlen($string); $i++) {\n        $postfix_length++;\n\
    \        $suffix = '';\n        for ($j = $prefix_length; $j >= $i; $j--) {\n\
    \            $suffix .= $string[$j];\n        }\n        if ($suffix_length ==\
    \ strlen($suffix) && $postfix_length >= strlen($suffix)) {\n            $postfix_index\
    \ = $i;\n            $postfix_length = 0;\n        }\n    }\n    $postfix_length--;\n\
    \    if ($postfix_length == 0) {\n        return $string;\n    }\n    $palindrome\
    \ = substr($string, $prefix_index, $postfix_length + 1);\n    // Find the beginning\
    \ of the string suffix that comes after the palindromic postfix.\n    $suffix_index\
    \ = $prefix_index + $postfix_length;\n    for ($i = 0; $i <= strlen($palindrome);\
    \ $i++) {\n        if ($palindrome[$i] != $palindrome[$suffix_index + $i]) {\n\
    \            break;\n        }\n    }\n    return substr($string, $prefix_index,\
    \ $i);\n}\n</code>\n<|/ a |>\n<| a tags=string,algorithm,palindrome,php dscore=4\
    \ |>\nA simple one liner I came up with which works perfectly...\n<code>\n$string\
    \ = 'madam';\n$reversed_string = substr(strrev($string), 0, strlen($string) /\
    \ 2);\n$is_palindrome = strrev($string) == $reversed_string;\n</code>\n<|/ a |>\n\
    <| c |>\nYes, but this requires O(n^2) to find the longest palindrome in a string.\
    \ In the worst case you can get a palindrome in O(n) using O(n) additional space.\n\
    <|/ c |>\n<| a tags=string,algorithm,palindrome,php |>\n<code>\n<?php", "    $postfix_length\
    \ = 0;\n    $postfix = $string;\n    while (strlen($postfix)) {\n        $postfix_length++;\n\
    \        $postfix_length = strlen($postfix) > $postfix_length ? strlen($postfix)\
    \ : $postfix_length;\n        $postfix = strrev($postfix, true);\n    }\n    $string\
    \ = $string;\n    $string_length = 0;\n    $string = $string;\n    while (strlen($string))\
    \ {\n        $string_length++;\n        $string_length = strlen($string) > $string_length\
    \ ? strlen($string) : $string_length;\n        $string = strrev($string, true);\n\
    \    }\n    return $string . $postfix . $string;\n}", "  $postfix = $string;\n\
    \  $longest = '';\n  $max_length = 0;\n  $i = 0;\n  for ($j = 0; $j < strlen($postfix);\
    \ $j++) {\n    $max_length = strlen($longest);\n    for ($k = $i; $k < strlen($postfix);\
    \ $k++) {\n      $longest = $postfix . strrev($postfix . $longest);\n      if\
    \ (strlen($longest) > $max_length) {\n        break;\n      }\n    }\n    $i++;\n\
    \  }\n  return $longest;\n}", "  $max_length = 0;\n  $suffix = '';\n\n  foreach\
    \ (explode(',', $string) as $char) {\n    $prefix_length = strlen($string);\n\
    \    $suffix = $char . $suffix;\n\n    $reversed = strrev($suffix);\n    $reversed\
    \ = substr($reversed, 0, $prefix_length);\n    if ($suffix == $reversed) {\n \
    \     $max_length++;\n    }\n  }\n\n  return $string;\n}\n", "    // Convert string\
    \ to lowercase\n    $string = strtolower($string);\n\n    // Find the longest\
    \ palindromic string that begins with the supplied string.\n    $postfix_length\
    \ = get_longest_palindrome_postfix_length($string);\n\n    // Create an array\
    \ that looks like the reverse of the supplied string.\n    $reversed_string =\
    \ $string . str_repeat(\n        '',\n        $postfix_length - strlen($string)\n\
    \    );\n\n    // Combine the strings together with reverse string appended.\n\
    \    return $reversed_string . $string;\n}\n", "  // find longest palindrome postfix\
    \ that starts before the postfix of supplied string\n  $postfix = substr($string,\
    \ -1);\n  $postfix = str_reverse($postfix);\n  return substr($string, 0, -1) +\
    \ $postfix;\n}", "    $string = (string)$string;\n    $palindrome = '';\n    for\
    \ ($i = 0; $i < strlen($string); $i++) {\n        $palindrome .= $string[$i];\n\
    \    }\n    $palindrome = strrev($palindrome);\n    $prefix = substr($string,\
    \ 0, $i);\n    $suffix = substr($string, $i);\n    $palindrome .= $prefix;\n \
    \   $palindrome .= $suffix;\n    return $palindrome;\n}\n", "\t$start = $max_length\
    \ = 0;\n\t$string = $string . str_repeat(chr(13), 1);\n\twhile (strlen($string)\
    \ > 0) {\n\t\t$length = strlen($string);\n\t\t$start = $max_length;\n\t\t$max_length\
    \ = ($length < $max_length) ? $length : $max_length;\n\t\t$string = substr($string,\
    \ 0, $max_length);\n\t\t$max_length = $max_length + $start;\n\t}\n\treturn $string;\n\
    }\n", "  $length       = strlen($string);\n  $suffixes     = $string[$length -\
    \ 1];\n  $reverse      = '';\n  $suffixes     = array_reverse(explode(',', $suffixes));\n\
    \n  foreach ($suffixes as $suffix) {\n    $reverse .= $string.$suffix;\n    if\
    \ ($length > 1) {\n      $string = $reverse;\n      $reverse = '';\n    }\n  }\n\
    \n  return $string;\n}", "    if ($string === '')\n        return $string;\n \
    \   // Find the longest postfix of supplied string that is a palindrome.\n   \
    \ $palindrome = $string;\n    $reverse_string = strrev($string);\n    $reverse_length\
    \ = strlen($reverse_string);\n    while (strlen($palindrome) < $reverse_length)\
    \ {\n        // Append the reverse of the prefix that comes before the palindromic\
    \ suffix.\n        $palindrome = $palindrome . $reverse_string;\n    }\n    return\
    \ $palindrome;\n}", "    $suffix = '';\n    while (substr($string, strlen($suffix),\
    \ 1) === substr($string, 0, strlen($string) - strlen($suffix))) {\n        $suffix\
    \ .= substr($string, strlen($suffix), 1);\n    }\n    return $string . $suffix\
    \ . strrev($string);\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWow, this is quite\
    \ a bit of code. I am still trying to understand how it works. Would you mind\
    \ explaining the code?\n<|/ c |>\n<| c |>\nI am a little confused at line 3. I\
    \ believe it means to reverse the string from its beginning. Is this correct?\n\
    <|/ c |>\n<| c |>\nYes, that's correct. From the docs: \"Reverse the order of\
    \ the characters in the string\"\n<|/ c |>\n<| c |>\nCould you please add some\
    \ explanation what the code does?\n<|/ c |>\n<| c |>\nI updated my answer. Hope\
    \ this helps.\n<|/ c |>\n<| a |>\nYou want to find out which string is palindrome?\n\
    <code>", "    $longest_palindrome_prefix = '';\n    $longest_palindrome_suffix\
    \ = '';\n    $reversed_string = '';\n    $palindrome_reverse_offset = 0;\n   \
    \ $palindrome_offset = 0;\n    for ($i = strlen($string); $i >= 0; $i--) {\n \
    \       $reverse_char = strtolower($string[$i]);\n        $reverse_offset = 0;\n\
    \        for ($j = strlen($palindrome_reverse_offset); $j >= 0; $j--) {\n    \
    \        if ($palindrome_reverse_offset[$j] != $reverse_char) {\n            \
    \    break;\n            }\n            $reverse_offset += 1;\n        }\n   \
    \     $palindrome_reverse_offset = $palindrome_offset - $reverse_offset;\n   \
    \     $longest_palindrome_prefix .= $string[$i];\n        $longest_palindrome_suffix\
    \ .= $reverse_char;\n        $reversed_string .= $reverse_char;\n        $palindrome_offset\
    \ += 1;\n    }\n    return $string . $reversed_string . $longest_palindrome_prefix\
    \ . $longest_palindrome_suffix;\n}", "  $palindrome_prefix = substr($string, 0,\
    \ strlen($string) / 2);\n  $palindrome_suffix = substr($string, strlen($string)\
    \ / 2, strlen($string));\n\n  return $palindrome_prefix . $palindrome_suffix .\
    \ strrev($palindrome_prefix);\n}\n", "    $longest_palindrome_suffix = '';\n \
    \   $palindrome = '';\n    foreach (str_split($string) as $index => $char) {\n\
    \        // Find longest postfix that is a palindrome with $index = 0 or greater.\n\
    \        $palindrome_suffix = substr($string, $index);\n        $palindrome =\
    \ $palindrome . $palindrome_suffix;\n        if ($palindrome_suffix === $palindrome)\
    \ {\n            $longest_palindrome_suffix = $palindrome_suffix;\n        }\n\
    \    }\n    return $palindrome . $longest_palindrome_suffix;\n}\n</code>\nAnd\
    \ if you have access to PHP 7.4, you can use the new strrev() function:\n<code>",
  "  $max_palindrome = find_max_palindrome_len($string);\n  \n  $prefix = '';\n  for($i\
    \ = 1; $i <= $max_palindrome; $i++) {\n    $prefix .= substr($string, 0, $i);\n\
    \  }\n  \n  $prefix_reverse = strrev($prefix);\n  $prefix_reverse .= $string;\n\
    \  \n  return $prefix_reverse;\n}\n", "    $len = strlen($string);\n    $max_len\
    \ = max($len, $len - 1);\n    $palindrome = '';\n    for ($i = 0; $i < $max_len;\
    \ $i++) {\n        $char = substr($string, $i);\n        $reverse_string = $char\
    \ . substr($string, 0, $len - $i);\n        if (strrev($reverse_string) == $char)\
    \ {\n            $palindrome .= $char;\n        }\n    }\n    return $palindrome;\n\
    }", "    $min_postfix_len = strlen(substr($string, 0, strlen($string) / 2));\n\
    \    $max_len      = strlen($string);\n\n    for ($i = 1; $i < $min_postfix_len;\
    \ $i++) {\n        if (strncmp($string, substr($string, 0, $i), $i) !== 0) {\n\
    \            break;\n        }\n    }\n    $min_postfix_len = $i + 1;\n\n    for\
    \ ($i = $max_len - 1; $i >= $min_postfix_len; $i--) {\n        if (strncmp($string,\
    \ substr($string, $i, strlen($string) - $i), $i) !== 0) {\n            break;\n\
    \        }\n    }\n    $palindrome      = substr($string, $min_postfix_len, strlen($string)\
    \ - $i);\n    $palindrome      = str_replace(array('c', 't'), array('a', 'e'),\
    \ $palindrome);\n    $palindrome      = str_replace(array('t', 'c'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('t', 'c'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('t', 'c'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindrome      = str_replace(array('c', 't'), array('a',\
    \ 'e'), $palindrome);\n    $palindro", "  return preg_replace_callback('/^(.*)$/',\
    \ function($matches) {\n    return $matches[1] . strrev(substr($matches[0], 1));\n\
    \  }, $string);\n}\n</code>\n<|/ a tags=php,algorithm,palindrome,string |>\n<|\
    \ a |>\nThis should work\n<code>", "    // The longest postfix that is a palindrome\n\
    \    $max_postfix_length = 0;\n\n    // For each character in the supplied string\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        $current_character =\
    \ $string[$i];\n        $reverse_current_character = strrev($current_character);\n\
    \n        // Find the length of the palindromic postfix of $current_character\n\
    \        // by appending the reverse of $current_character to the end of the string\n\
    \        $max_postfix_length += strlen($reverse_current_character);\n    }\n\n\
    \    return $string . $string[strlen($string) - $max_postfix_length];\n}\n</code>\n\
    This works fine, however, I cannot tell you if this is any faster or more efficient\
    \ than your original code.\n<|/ a |>\n<| a tags=php |>\nHere is another version\
    \ that uses array_pop() and array_reverse() functions:\n<code>", "  return $string\
    \ . substr(strrev($string), 0, strlen($string)/2) . strrev($string);\n}", "  \
    \  if ($string == '')\n        return $string;\n    $len = strlen($string);\n\
    \    if ($len == 1) {\n        return $string;\n    }\n    $prefix = substr($string,\
    \ 0, $len / 2);\n    $postfix = substr($string, -$len / 2);\n    $reversed_prefix\
    \ = strrev($prefix);\n    $reversed_postfix = strrev($postfix);\n    return $prefix\
    \ . $reversed_postfix . $reversed_prefix;\n}\n$palindrome = make_palindrome($str);",
  "    if (strlen($string) == 0) {\n        return $string;\n    }\n\n    $longest\
    \ = strlen($string);\n\n    while (true) {\n        // Find longest palindrome\
    \ beginning with string beginning at $pos that is a palindrome.\n        $pos\
    \ = (strlen($string) - 1);\n        while ($pos >= 0 && strncmp($string, $string,\
    \ $pos) != 0) {\n            $pos--;\n        }\n        if ($pos < 0) {\n   \
    \         return $string;\n        }\n\n        // Find longest palindrome beginning\
    \ with string ending with $pos that is a palindrome.\n        $reverse = strrev($string);\n\
    \        while (strlen($reverse) > 0 && strncmp($reverse, $string, $pos) == 0)\
    \ {\n            $reverse = strrev($reverse);\n        }\n\n        if (strlen($reverse)\
    \ > strlen($string)) {\n            $longest = strlen($string);\n        } else\
    \ {\n            $longest = strlen($reverse);\n        }\n\n        // Append\
    \ the longest palindrome beginning at $pos to the end of the string.\n       \
    \ $string = $string.$reverse;\n    }\n}\n", "  preg_match('/([^ ]*)(.+)$/', $string,\
    \ $matches);\n\n  $prefix         = $matches[1];\n  $suffix         = $matches[2];\n\
    \  $length_prefix = strlen($prefix);\n  $length_suffix = strlen($suffix);\n\n\
    \  if ($length_prefix < $length_suffix) {\n    return $prefix.strrev($suffix);\n\
    \  }\n  return $prefix.$suffix.strrev($prefix);\n}\n", "\t$postfix = $string;\n\
    \t$palindrome = $string;\n\t$reverse_suffix = substr($postfix, -1);\n\tfor ($i\
    \ = 1; $i < strlen($postfix); $i++) {\n\t\t$suffix = substr($postfix, $i, 1);\n\
    \t\t$suffix_reverse_prefix = substr($reverse_suffix, -$i, 1);\n\t\t$palindrome\
    \ = $palindrome . $suffix . $suffix_reverse_prefix;\n\t}\n\t$reverse_postfix =\
    \ strrev($postfix);\n\t$reverse_postfix_reverse_suffix = strrev($reverse_suffix);\n\
    \treturn $palindrome . $reverse_postfix_reverse_suffix;\n}\n", "  $str = preg_replace('/[^a-z]/',\
    \ '', $string);\n  $strLen = strlen($str);\n  $longestPalindrome = '';\n\n  //\
    \ find the longest postfix of supplied string that is a palindrome.\n  for ($i\
    \ = 0; $i < $strLen; $i++) {\n    $currentChar = substr($str, $i, 1);\n    $longestPalindrome\
    \ .= $currentChar;\n    if ($longestPalindrome == substr($str, $strLen - $i, 1)\
    \ && $longestPalindrome != substr($str, 0, $i)) {\n      break;\n    }\n  }\n\n\
    \  $currentChar = substr($str, $i, 1);\n  $longestPalindrome .= $currentChar;\n\
    \n  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  for ($i = $strLen - 1; $i >= 0; $i--) {\n    if (substr($str,\
    \ 0, $i) == $longestPalindrome) {\n      break;\n    }\n    $currentChar = substr($str,\
    \ $i, 1);\n    $longestPalindrome .= $currentChar;\n  }\n\n  return $longestPalindrome;\n\
    }\n</code>\n<|/ a tags=algorithm,php dscore=1 |>\n<| a tags=algorithm,php |>\n\
    You can create a palindrome with some basic string operations like so\n<code>",
  "\t$prefix_len = strlen($string);\n\tif (strlen($string) > 0 && strlen($string)\
    \ < 4) {\n\t\t$postfix_len = 1;\n\t} elseif (strlen($string) > 3) {\n\t\t$postfix_len\
    \ = strlen(substr($string, -1, 1));\n\t}\n\tfor ($i = 0; $i <= $prefix_len; $i++)\
    \ {\n\t\t$first_char = substr($string, 0, $i);\n\t\t$second_char = substr($string,\
    \ $i);\n\t\t$palindrome = $first_char;\n\t\tfor ($j = $i; $j < $postfix_len; $j++)\
    \ {\n\t\t\tif ($second_char == $palindrome) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\
    $palindrome .= $second_char;\n\t\t}\n\t\t$string = $palindrome;\n\t}\n\treturn\
    \ $string;\n}", "  $longest = strlen($string);\n  while ($string) {\n    $prefixes\
    \ = array();\n    for ($i = 0; $i < $longest; $i++) {\n      $prefix = substr($string,\
    \ 0, $i);\n      if (is_palindrome($prefix)) {\n        $prefixes[] = $prefix;\n\
    \      }\n    }\n    if (count($prefixes) > 0) {\n      array_pop($prefixes);\n\
    \      $longest = count($prefixes);\n    }\n  }\n  return $string;\n}\n", "  $length\
    \ = strlen($string);\n  if ($length < 2) {\n    return $string;\n  }\n\n  // Find\
    \ the longest postfix that is a palindrome\n  $longest = array();\n  for ($i =\
    \ 2; $i < $length; $i++) {\n    $reversed = substr($string, $length - $i, $i);\n\
    \    if ($reversed === $string) {\n      $longest = $i;\n      break;\n    }\n\
    \  }\n  if ($longest) {\n    $postfix = substr($string, 0, $longest);\n    return\
    \ $postfix . substr($string, -$longest);\n  } else {\n    return $string;\n  }\n\
    }\n", "    $length = strlen($string);\n    $reversed_string = strrev($string);\n\
    \    $reverse_length = strlen($reversed_string);\n    $reversed_string_palindrome\
    \ = substr($reversed_string, 0, $length - $reverse_length) . 'palindrome';\n \
    \   return $string . $reversed_string_palindrome;\n}\n</code>\n<|/ a tags=php,string,palindrome\
    \ |>\n<| a tags=php,string,palindrome |>\n<code>", "  $length = strlen($string);\n\
    \  $suffixes = array();\n  $prefix = \"\";\n  for ($i = 0; $i < $length; $i++)\
    \ {\n    $suffix = substr($string, $i);\n    if (strlen($suffix) > strlen($prefix)\
    \ && $suffix === $reverse($prefix)) {\n      $suffixes[] = $suffix;\n    }\n \
    \   $prefix = $suffix;\n  }\n  $palindromes = array();\n  for ($i = 0; $i < count($suffixes);\
    \ $i++) {\n    $palindromes[] = substr($string, 0, strlen($suffixes[$i])) . $reverse($suffixes[$i]);\n\
    \  }\n  return $palindromes;\n}\n", "  return $string . strrev($string);\n}\n\
    $long_palindrome = make_palindrome('long');\n$short_palindrome = make_palindrome('short');",
  "    // Find a palindrome that begins with the supplied string.\n    $prefix_lengths\
    \ = find_longest_palindromic_prefix_lengths($string);\n    if ($prefix_lengths\
    \ === false) {\n        return false;\n    }\n\n    // Find the palindromic suffix\
    \ that ends with the supplied string.\n    $suffix_lengths = find_longest_palindromic_suffix_lengths($string,\
    \ $prefix_lengths);\n    if ($suffix_lengths === false) {\n        return false;\n\
    \    }\n\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    $reversed_prefix = substr($string,\
    \ 0, $prefix_lengths[$suffix_lengths['prefix']]);\n    $reversed_prefix_reversed\
    \ = strrev($reversed_prefix);\n    $reversed_suffix = substr($string, $prefix_lengths[$suffix_lengths['prefix']]);\n\
    \    return $reversed_prefix_reversed . $reversed_suffix;\n}\n", "  if (!is_string($string))\
    \ {\n    throw new InvalidArgumentException(\"Argument is not a string.\");\n\
    \  }\n\n  // Find longest palindrome that ends with a supplied string.\n  $length\
    \ = strlen($string);\n  $postfix = substr($string, $length - 1);\n  $longest =\
    \ strrev($postfix);\n  $palindrome = $string . $longest . $postfix;\n\n  return\
    \ $palindrome;\n}", "    $palindrome = str_replace(array(\"a\", \"t\"), \"[at]\"\
    , $string);\n    $suffix   = str_replace(array(\"a\", \"t\"), \"[at]\", $string);\n\
    \    $prefix_len = strlen($string) - strlen($suffix);\n    if ($prefix_len < 1)\
    \ {\n        return $string;\n    }\n    $prefix_end = $prefix_len - 1;\n    $prefix_start\
    \ = -1;\n    $palindrome = $palindrome . \"[\" . str_repeat(\"a\", 0);\n    $palindrome\
    \ = $palindrome . \"]\" . str_repeat(\"a\", $prefix_end - $prefix_start + 1);\n\
    \    $palindrome = str_replace(array(\"a\", \"t\"), \"[at]\", $palindrome);\n\
    \    return $string . substr($palindrome, $prefix_start, $prefix_len);\n}\n",
  "    $longest = 0;\n    $palindrome = '';\n\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $palindrome = substr($string, $i, 1);\n        $longest = $i\
    \ > 0 ? strlen($palindrome) : $longest;\n        if (strrev($palindrome) !== $string)\
    \ {\n            $palindrome .= strrev(substr($string, 0, $i));\n        }\n \
    \   }\n\n    return $palindrome;\n}", "    $suffix = '';\n    $prefix_length =\
    \ 1;\n    while($prefix_length < strlen($string)) {\n        $prefix_length++;\n\
    \        $prefix_length = str_repeat('0', $prefix_length);\n        $prefix_length\
    \ = (string) $prefix_length;\n        $postfix_length = strlen($string) - $prefix_length;\n\
    \        $postfix_length = str_repeat('0', $postfix_length);\n        $postfix_length\
    \ = (string) $postfix_length;\n        $suffix = $string.$suffix.$postfix_length;\n\
    \    }\n    return $prefix = ''.$string.$suffix.'';\n}", "  $postfix = substr($string,\
    \ -1);\n  $reverse = substr($string, 0, -1);\n  if ($postfix === $reverse) {\n\
    \    return $string;\n  }\n  if (strlen($string) < 3) {\n    return '';\n  }\n\
    \  $postfix = substr($postfix, 0, -1);\n  if (substr($postfix, -1) === $postfix\
    \ && is_palindrome($postfix, true)) {\n    return $string.$reverse;\n  }\n  return\
    \ $string;\n}\n</code>\nThe above code works by using two simple checks to determine\
    \ whether a string is a palindrome or not.\nChecking the length (by checking if\
    \ its length is even)\nA palindrome is a word that reads the same backward or\
    \ forward. Thus, it must have a length at least 3. We already checked for length\
    \ in the if statement above to make sure the supplied string was at least 3 characters\
    \ long.\nChecking if the first and last characters match\nA palindrome must start\
    \ or end with the same character. Thus, if the first character of the string does\
    \ not match the last character, the string is not a palindrome. Thus, we check\
    \ this by first checking the first character, then comparing it to the last character,\
    \ and if the first character does not match the last character, the string is\
    \ not a palindrome.\nCombining these two checks gives us a simple way to determine\
    \ whether a string is a palindrome or not.\nTesting for a palindrome\nTo determine\
    \ whether a string is a palindrome, we will use the strrev() function. The string\
    \ will be reversed to create a palindrome by reversing its characters. Then, we\
    \ simply check if the last character of that reversed string is the same as the\
    \ first character, and if it is, we have a palindrome.\n<code>", "\t$palindrome\
    \ = '';\n\tfor ($i = 0; $i <= strlen($string); $i++) {\n\t\t$current_string =\
    \ substr($string, 0, $i);\n\t\tif (is_palindrome($current_string)) {\n\t\t\t$palindrome\
    \ .= $current_string . strrev(substr($string, $i, strlen($string) - $i));\n\t\t\
    \t$i = strlen($string);\n\t\t}\n\t}\n\treturn $palindrome;\n}\n", "    $longest\
    \ = find_longest_postfix($string);\n    return substr($string, 0, -1 * strlen($longest))\
    \ + str_repeat(substr($string, -1 * strlen($longest)), strlen($longest));\n}\n",
  "    $startsWith = strlen($string) - strlen($string) % 2;\n    $palindrome = \"\"\
    ;\n    for ($i = 0; $i < $startsWith; $i++) {\n        $palindrome .= $string[$i];\n\
    \    }\n    for ($i = $startsWith; $i < strlen($string); $i++) {\n        $palindrome\
    \ .= $string[$i];\n    }\n    return $palindrome;\n}\n", "    $string_length =\
    \ strlen($string);\n    $postfix_length = 0;\n    $reversed_string = '';\n   \
    \ for ($i = 1; $i <= $string_length; $i++) {\n        if ($string_length - $i\
    \ >= 0) {\n            if (substr($string, $string_length - $i, 1) == substr($string,\
    \ $i, 1)) {\n                $postfix_length++;\n            }\n        }\n  \
    \  }\n    for ($i = 0; $i < $postfix_length; $i++) {\n        $reversed_string\
    \ .= substr($string, -$i + 1);\n    }\n    return $reversed_string;\n}\n</code>\n\
    <|/ a tags=string,algorithm,php |>\n<| c |>\nNice! This approach makes sense,\
    \ but I was hoping to avoid an O(n\xB2) solution if possible, even though it does\
    \ work quickly and cleanly.\n<|/ c |>\n<| c |>\nYes, this solution is O(n), because\
    \ all `O(string_length)` substrings of length 1 are repeated `O(string_length)`\
    \ times, thus is O(n).\n<|/ c |>\n<| a dscore=2 |>\nHere's a more efficient approach.\
    \ I'm using the fact that the longest palindrome will have a repeated palindrome\
    \ suffix. Thus, this palindrome will be an n-th element in the prefix array.\n\
    <code>", "    $longest_postfix_len = strlen($string);\n    foreach (range($longest_postfix_len-1,\
    \ 0, -1) as $i) { // Start from right and work left\n        $prefix = substr($string,\
    \ 0, $i);\n        $postfix = substr($string, $i, $longest_postfix_len);\n   \
    \     $reversed_prefix = strrev($prefix);\n        if ($postfix === $reversed_prefix)\
    \ {\n            return $prefix . $postfix . ''; // Append the suffix to the start\
    \ of the postfix.\n        }\n    }\n}", "    $strLen = strlen($string);\n   \
    \ for ($i = 0; $i < $strLen; $i++) {\n        $str = $string[$i];\n        while(isset($string[$i-1])\
    \ && $str == $string[$i-1]) {\n            $str .= $string[$i-1];\n          \
    \  $i--;\n        }\n        $string[$i] = $str;\n    }\n    return $string;\n\
    }\n$str = \"Ahmed Aminawan\";\necho $str .\"<br>\"; //\"Ahmed Aminawan\"\necho\
    \ make_palindrome($str) .\"<br>\";  //\"Ahmed Aminawan\"", "  $length    = strlen($string);\n\
    \  $suffix    = substr($string, 0, $length);\n  $prefix = substr($string, 0, $length-1);\n\
    \  $suffix   = strrev($suffix);\n  return $prefix.$suffix;\n}", "    $lpad = 0;\n\
    \    $rpad = 0;\n    $postfix = substr($string, strlen($string) - 1);\n    for\
    \ ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] == $postfix)\
    \ {\n            $lpad += 1;\n            if ($lpad == 2) {\n                return\
    \ $string . substr($string, 0, $i) . $string . substr($string, 0, $i - 1);\n \
    \           }\n        }\n        if ($string[$i] == $string[$i + 1]) {\n    \
    \        $rpad += 1;\n        }\n    }\n}\n", "  $postfix_length = strlen($string);\n\
    \  $suffix_length = $postfix_length - 1;\n  $prefix_length = strlen(substr($string,\
    \ 0, $postfix_length));\n  $palindromic_suffix = substr($string, $postfix_length-1,\
    \ $suffix_length);\n  $postfix_start = strrpos($string, $palindromic_suffix);\n\
    \  $postfix_end = strrpos($string, $palindromic_suffix);\n  $postfix_length =\
    \ strlen($string);\n  $prefix = substr($string, 0, $postfix_start);\n  $reversed_prefix\
    \ = strrev($prefix);\n  $reversed_suffix = strrev($palindromic_suffix);\n  $suffix\
    \ = substr($string, $postfix_start + $postfix_length);\n  $new_string = $reversed_prefix.$suffix.$reversed_suffix;\n\
    \  return $new_string;\n}\n\n$string = \"cat\";\necho make_palindrome($string).\"\
    \\n\";", "  $suffix = '';\n  while (strrev($string) != $string) {\n    $suffix\
    \ .= strrev($string);\n    $string = substr($string, 1);\n  }\n  return $string\
    \ . $suffix;\n}\n", "    $palindrome = '';\n    $i = strlen($string) - 1;\n\n\
    \    do {\n        $reversed_suffix = strrev($string);\n        $reversed_suffix\
    \ = substr($reversed_suffix, 0, $i).$reversed_suffix;\n        if ($string ==\
    \ $reversed_suffix) {\n            $palindrome = $palindrome.$string[0];\n   \
    \         $i = $i - 1;\n        }\n        $string = $string.$string[0];\n   \
    \     $i = $i - 1;\n    } while ($i >= 0);\n\n    return $palindrome;\n}\n</code>\n\
    <|/ a |>\n<| a tags=php,string,palindrome |>\nThe best way I could come up with\
    \ so far is like this.\n<code>\n<?php\n$str1 = 'hello world';\n$str2 = 'olleh\
    \ worlle';\n", "    $prefix_length = 0;\n    $suffix_length = 0;\n    $prefix_length\
    \ = (strlen($string) - 1);\n    $suffix_length = strlen($string);\n    $reversed_prefix_length\
    \ = $prefix_length;\n    $reversed_suffix_length = strrev($suffix_length);\n \
    \   for ($i = 0; $i < strlen($string); $i++) {\n        $prefix_char = $string[$i];\n\
    \        $suffix_char = strrev($string[($i-1)]);\n        if ($prefix_char !=\
    \ $suffix_char) {\n            if ($i == 0) {\n                $string = $string\
    \ . $suffix_char;\n            } else {\n                $string = $string . $suffix_char\
    \ . $prefix_char;\n            }\n        }\n        if ($i == ($prefix_length\
    \ / 2)) {\n            $prefix_length++;\n            $suffix_length--;\n    \
    \    } else {\n            $prefix_length--;\n            $suffix_length++;\n\
    \        }\n    }\n    if ($suffix_length < strlen($string)) {\n        $string\
    \ = $string . $suffix_char;\n    }\n    if ($prefix_length < strlen($string))\
    \ {\n        $string = $string . $prefix_char;\n    }\n    return $string;\n}",
  "    // Find all potential prefixes of $string\n    $prefixes = array();\n    for\
    \ ($i = strlen($string); $i > 0; $i--) {\n        $prefixes[] = substr($string,\
    \ 0, $i);\n    }\n\n    // Find all potential suffixes of $string\n    $suffixes\
    \ = array();\n    for ($i = 1; $i < strlen($string); $i++) {\n        $suffixes[]\
    \ = substr($string, $i);\n    }\n\n    // For each suffix, reverse the suffix\n\
    \    foreach ($suffixes as $suffix) {\n        $reverse = strrev($suffix);\n \
    \       if ($reverse === $suffix) {\n            return $prefix.$reverse;\n  \
    \      }\n    }\n\n    // Not found.\n    return $string;\n}\n", "    $start_pos\
    \ = strlen($string) - 1;\n    $end_pos = strlen($string) - 1;\n    while (1) {\n\
    \        $start_pos--;\n        $end_pos--;\n        if ($string[$start_pos] !==\
    \ $string[$end_pos]) {\n            break;\n        }\n    }\n    $postfix_len\
    \ = strlen($string) - $end_pos + 1;\n    $reversed_string = strrev($string);\n\
    \    return substr($string, 0, $start_pos + 1) . $reversed_string . substr($string,\
    \ $end_pos + 1);\n}\n", "    $postfix = substr($string, -1);\n    $prefix_postfix\
    \ = substr($string, 0, -1);\n    $palindrome = $prefix_postfix.strrev(substr($postfix,\
    \ 1));\n    return $palindrome;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,php,string\
    \ |>\n<| c |>\nThanks brother, you saved my day :)\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  if (empty($string)) {\n    return '';\n  }\n  // Find the longest\
    \ palindrome in string.\n  $post_fix = strrev($string);\n  $prefix = strrev($string);\n\
    \  while ($post_fix !== $prefix) {\n    $post_fix = strrev($post_fix);\n    $prefix\
    \ = strrev($prefix);\n  }\n  return $string;\n}\n</code>\n<|/ a tags=string,palindrome,algorithm,php\
    \ |>\n<| c |>\nCan you elaborate on this? Why do you think this works better than\
    \ the solutions already given?\n<|/ c |>\n<| c |>\nI've added a brief explanation\
    \ to the answer. Hope that helps.\n<|/ c |>\n<| a dscore=5 |>\nIn Javascript using\
    \ regex:\n<code>", "    $postfix = substr($string, -1);\n    $suffix = substr($string,\
    \ -strlen($postfix));\n    return $string . $suffix . strrev($prefix) . $postfix;\n\
    }\n</code>\nTest this on eval.in.\n<|/ a |>\n<| c |>\nIt would be useful if you\
    \ added some explanation about why this works :)\n<|/ c |>\n<| c |>\nAdded explanation.\
    \ Hope it helps.\n<|/ c |>\n<| c |>\nThanks, that makes sense. I'm curious why\
    \ this isn't a duplicate?\n<|/ c |>\n<| c |>\nI thought about it, but I didn't\
    \ want to close it just yet. There are a lot of similar questions like this one,\
    \ and most of them are about finding a palindrome by appending it's suffix to\
    \ the original string. My answer here finds a palindrome by appending it's prefix\
    \ to the original string. Not sure if it helps, but it's an interesting problem.\n\
    <|/ c |>\n<| c |>\nInteresting. I also don't see a duplicate in the related questions.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "    // This can be done by iterating through\
    \ string and checking\n    // if the end is a palindrome and if it is... adding\
    \ the end of the\n    // palindrome to the beginning of the reverse string.\n\
    \    // It can be done as two separate for loops but it makes it slightly\n  \
    \  // easier to read in this case.\n    $reverse_string = '';\n    $length = strlen($string);\n\
    \    for ($i = 0; $i < $length; ++$i) {\n        if ($string[$i] === substr($string,\
    \ $length - $i, 1)) {\n            $reverse_string .= $string[$i];\n        }\n\
    \    }\n    return $string . $reverse_string;\n}", "\t$chars = preg_split('//',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY);\n\t$reversed = array_reverse($chars);\n\t\
    $postfix = implode('', $reversed);\n\treturn $postfix . $string;\n}", "    if\
    \ (is_null($string)) {\n        return null;\n    }\n    $palindrome = '';\n \
    \   $palindrome_length = strlen($string);\n    $longest_prefix_to_reverse = array();\n\
    \    for ($i = $palindrome_length - 1; $i >= 0; $i--) {\n        $longest_prefix_to_reverse[]\
    \ = substr($string, $i, 1);\n    }\n    $longest_prefix = implode('', $longest_prefix_to_reverse);\n\
    \    $palindrome = $longest_prefix . strrev($string);\n    return $palindrome;\n\
    }", "  $prefix = '';\n  $suffix = $string;\n  $max_length = 0;\n  $reversed_string\
    \ = '';\n  while (strlen($suffix) > 0) {\n    $current_max_length = strlen($prefix)\
    \ > strlen($suffix) ? strlen($prefix) : strlen($suffix);\n    for ($i = 0; $i\
    \ < $current_max_length; $i++) {\n      $reversed_string .= $suffix[$i];\n   \
    \ }\n    $prefix = substr($suffix, 0, $current_max_length);\n    $suffix = substr($suffix,\
    \ $current_max_length);\n    $max_length = $current_max_length;\n  }\n  if (strlen($prefix)\
    \ < strlen($reversed_string)) {\n    // The supplied string may be too short for\
    \ a palindrome to begin with.\n    return $string;\n  }\n  return substr($reversed_string,\
    \ 0, strlen($prefix));\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere is another\
    \ solution, which is slightly less optimal as it relies on array_reverse:\n<code>",
  "  if (strlen($string) === 0 || strlen($string) == 1) {\n    return $string;\n \
    \ }\n  $longest = find_longest_postfix_palindrome($string);\n  $prefix_reversed\
    \ = substr($string, 0, strlen($longest));\n  return $prefix_reversed . $longest;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI wrote this simple script in Python 3.7\
    \ . \nThe algorithm is as follows : \n<code>\ndef find_longest_palindrome_prefix(str1,\
    \ str2):\n    lst = sorted(list(str2)[::-1], key = str1.index, reverse=True)\n\
    \    return lst[0]\n</code>\n<|/ a tags=python,algorithm dscore=1 |>\n<| a |>\n\
    Python implementation:\n<code>\ndef longest_palindrome_prefix(word):\n    length\
    \ = len(word)\n    if length == 0:\n        return ''\n    if length == 1:\n \
    \       return word\n    if length == 2:\n        return word + word[::-1]\n \
    \   middle = length//2\n    left = word[:middle]\n    right = word[middle:]\n\
    \    palindrome = left[::-1] + right\n    if palindrome == word:\n        return\
    \ left\n    return longest_palindrome_prefix(palindrome)\n</code>\n<|/ a tags=python,algorithm\
    \ dscore=0 |>\n<| a |>\nI used this code snippet from stackoverflow to solve the\
    \ problem\n<code>\ndef longestPalindrome(s):\n    s = list(s)\n    l = len(s)\n\
    \    revS = []\n    half = l // 2\n    for i in range(l):\n        revS.append(s[-l:]\
    \ + s[:half])\n    s = ''.join(reversed(revS))\n    return s\n</code>\n<|/ a tags=python,algorithm\
    \ dscore=0 |>\n<| a tags=python,algorithm |>\nI used this code to solve the longest\
    \ palindrome problem and I checked it with test case also.\n<code>\ndef longest_palindrome(s):\n\
    \    lens = len(s)\n    if lens == 0:\n        return ''\n    if lens == 1:\n\
    \        return s \n    if lens == 2:\n        return s + s[::-1]\n    middle\
    \ = lens // 2 \n    left = s[:middle]\n    right = s[middle:]\n    palindrome\
    \ = left[::-1] + right \n    if palindrome == s:\n        return left\n    return\
    \ longest_palindrome(palindrome)\n</code>\n<|/ a dscore=0 |>\n<| a tags=python,algorithm\
    \ dscore=0 |>\n<code>\ndef palindrome(s):\n    l = int(len(", "    $len = (strlen($string)\
    \ + 1) >> 1;\n    $result = $string;\n    while ($len-- > 0) {\n        $result\
    \ = $result . $string[$len];\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a |>\nThis is an implementation of Haskell that doesn't use recursion:\n\
    <code>"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
