name: HumanEval_49_modp
language: php
prompt: "<?php\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n\
  // 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n\
  // 8\n// >>> modp(100, 101)\n// 1\nfunction modp($n, $p) {\n"
tests: "function candidate(...$args) {\n    return modp(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(3, 5) !== 3) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(1101, 101) !== 2) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(0, 101) !== 1) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(3, 11) !== 8) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(100, 101) !== 1) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(30, 5) !== 4) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(31, 5) !== 3) { throw new Exception(\"Test failed!\"); }\n}\n\n\
  test();"
completions: ["\treturn bcmod($n, $p);\n}\n", "  $m = pow($p, $n, MATH_BIGINTEGER_MODE);\n\
    \  return ($m !== false) ? (($m & ($p - 1)) == 0 ? $m : 0)\n                 \
    \       : false;\n}\n\n/**\n * Validates and parses an unsigned big integer.\n\
    \ *\n * On success, returns an unsigned big integer.\n * Otherwise throws a relevant\
    \ exception.\n *\n * @param string $number\n * @param int $base\n * @return array|false\n\
    \ * @access public\n */", "  if (!$p) $p = 1;\n  $n = abs($n);\n  return ($n %\
    \ $p == 0) ? ($n / $p) : ((-$n % $p) + $p);\n}", "  return $n % $p ? $n % $p :\
    \ $n;\n}\n", "    if ($n !== (int) $n || ($n !== 0 && $n != $p)) {\n        throw\
    \ new \\InvalidArgumentException(sprintf('Input values must be integers. (got\
    \ %d, %d)', $n, $p));\n    }\n\n    return $n % $p;\n}\n", "  return $n%$p ==\
    \ 0 ? $n : ($n%$p == 0 ? $p - 1 : modp($n, $p-1));\n}\n", "    return pow($n,\
    \ $p - 2, $p);\n}\n", "  $n = (int) $n;\n  if ($n < 1) {\n    return 1;\n  }\n\
    \  $p = (int) $p;\n  if ($p < 1) {\n    return $n;\n  }\n  if ($n == $p) {\n \
    \   return $n;\n  }\n  if ($n <= $p - 1) {\n    return ($n % $p) + modp($n - $p,\
    \ $p);\n  }\n  return modp($n, $p) % $p;\n}\n", "  $n = (integer) $n;\n  $p =\
    \ (integer) $p;\n  if ($n < 0) {\n    return $p + ($n * modp($p - (abs($n), $p)));\n\
    \  }\n  if ($p == $n) {\n    return $p;\n  }\n  if ($p < 0) {\n    return $modp($n,\
    \ $p);\n  }\n\n  $m = ($p + ($p / 4) + ($n / 4)) * $n / 4;\n  if ($n % 2) {\n\
    \    return $modp($m, $p);\n  }\n  return $modp($m, $n);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThank you for sharing this, it works. However, i was hoping for\
    \ a mathematical way as i don't want to add more complexity to my code.\n<|/ c\
    \ |>\n<| a tags=php |>\nI think this can solve your problem\n<code>\n$base= pow\
    \ (2, $k);\n$final = pow (2, $k);\nwhile ($final < $p){\n    $base= pow (2, $k);\n\
    \    $final = $final + $base;\n    $k++;\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nYou don't need a loop to do this.\n<|/ c |>\n<| c |>\nThe original poster\
    \ wanted to avoid looping. Therefore I added the looping logic\n<|/ c |>\n<| a\
    \ |>\nI have implemented this algorithm in Ruby. Let me know if you want an implementation\
    \ in PHP:\n<code>\ndef mod_power(base, exponent, modulus)\n    return 0 if exponent\
    \ < 0\n    return 0 if modulus < base\n    exponent = exponent.to_i\n    base\
    \     = base.to_i\n    modulus  = modulus.to_i\n\n    if exponent == 0\n     \
    \   return modulus\n    end\n\n    # Find the least common multiple of the two\n\
    \    lcm = base.lcm(modulus)\n\n    # Get the value of k. \n    # k is such that\
    \ k * base % modulus = 1.\n    k = exponent / lcm\n\n    # Since we know the least\
    \ common multiple is greater than modulus (i.e.\n    # k < modulus), we need to\
    \ divide modulus by lcm to move the \n    # remainder to the correct place.\n\
    \    mod = modulus / lcm\n\n    # Calculate remainder of the product of base and\
    \ modulus\n    product = (product / (base.to_f * mod.to_f)).floor\n\n    # If\
    \ the product of base and modulus is greater than modulus, then\n    # subtract\
    \ the modulus from the product of ", "    return ($n % $p + $p) % $p;\n}\n", " \
    \ return ((($n%$p) + $p)%$p);\n}", "    if ($n % $p)\n        return $n % $p;\n\
    \    else\n        return ($n % $p + $p) % $p;\n}\n", "  // n is a number\n  //\
    \ p is an integer > 0\n  if ($n == 0) {\n    return 0;\n  }\n\n  if ($p < 2) {\n\
    \    return $n;\n  }\n\n  if ($p > 9) {\n    return $n % $p;\n  }\n\n  if ($p\
    \ % 2 == 0) {\n    return ($n % $p) % $p;\n  }\n\n  return $n % $p + (int)($n\
    \ / $p);\n}", "  return $n % $p == 0 ? $n - ($n % $p) : $n % $p;\n}", "    return\
    \ ((($n = $n % $p) + $p) % $p) + 1;\n}\n\n/**\n * A few auxiliary functions.\n\
    \ *\n * These functions don't make sense as standalone functions -- if you\n *\
    \ read this code, don't blame me for writing it in PHP - it's just so much\n *\
    \ better to have a separate file for it.\n *\n * @author Michael Dowling and Todd\
    \ B. Arnold\n * @copyright 2007-2008, Michael Dowling and Todd B. Arnold\n * @license\
    \ http://www.opensource.org/licenses/bsd-license.php BSD License\n * @version\
    \ 2.6.5\n * @package Text_Diff\n */", "    return $n % $p;\n}\n", "  return ($n\
    \ % $p) + (($n%$p) == 0 ? 0 : ($n%$p));\n}\n", "  $n = (int)$n;\n  $p = (int)$p;\n\
    \  $m = $p;\n  if ($n < 0 || $p < 0)\n    return 0;\n  while ($n > 1) {\n    $m\
    \ %= $p;\n    if ($m == 0)\n      return $m;\n    $n -= $m;\n    $m /= $p;\n \
    \ }\n  return $n;\n}\n", "  if ($n == 0) return $p;\n  $n = (int) $n;\n  $p =\
    \ (int) $p;\n  if ($n < 0) {\n    $n *= -1;\n    $p = -$p;\n  }\n  if ($p < 0)\
    \ {\n    $p *= -1;\n    $n = -$n;\n  }\n  $r = $n % $p;\n  if ($r == 0) {\n  \
    \  return $n;\n  }\n  return $p - $r;\n}\n", "    // TODO: is this really faster?\n\
    \    if ($p < $n) return $n % $p;\n    return $n % $p;\n}\n", "  $pmod = $p-1;\n\
    \  if ($pmod == 0)\n    return 1;\n  return ($n % $pmod) == 0 ? $n % $pmod : $n\
    \ % $pmod+1;\n}", "  if ($p === 0) return 0;\n  if ($n == 0 || $p == 0) return\
    \ $n % $p == 0;\n  return ($n % $p + modp($n / $p, $p)) % $p;\n}", "  return $n\
    \ - ($n % $p);\n}", "  $result = $n % $p;\n  if ($result < 0) {\n    $result +=\
    \ $p;\n  }\n  return $result;\n}", "  return $n%$p;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI think you have to be careful that the modulus is always an integer.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work for negative numbers.  e.g. modp(9,\
    \ -3) returns -2 instead of 1.\n<|/ c |>\n<| c |>\n, you are right, didn't think\
    \ about that case, but I guess you can always make modulo in negative numbers\
    \ by making `%` modulo `-p` then making `mod` modulo `p`.\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer.  It works perfectly and is both simple and\
    \ concise.\n<|/ c |>\n<| c |>\nThe answer doesn't work on `modulus` function defined\
    \ as `modp($n = 3, $p = 5)`. `modp(3, 5)` will result in `0`, but `modp(3, 5)%5`\
    \ is `1` which is correct.\n<|/ c |>\n<| a |>\nI believe the easiest way to do\
    \ this is:\n<code>", "  $r = $n % $p;\n  return $r ? $p * pow($n, $r - 1) : $n;\n\
    }\n", "    return $p > $n || $p < 0 ? null : $n % $p;\n}\n", "    return (int)\
    \ ($n % $p);\n}", "  return $n % $p == 0 ? $n : $n % $p;\n}\n", "  $n = (int)$n;\n\
    \  if ($p > 0)\n    return pow($n, $p - 1);\n  else\n    return ($n > 0) ? mod((int)$n,\
    \ $p) : $n;\n}\n", "    return $n%$p;\n}\n", "  if ($n%$p==0) {\n    return $p;\n\
    \  }\n  return modp($n/$p, $p);\n}\n", "  $n2 = $n * 2;\n  $n4 = $n2 * 4;\n  $n2Squared\
    \ = $n2 * $n;\n  $pSquared = $p * $p;\n  if ($n4 === 0 || $n4 == $n) {\n    return\
    \ $n;\n  }\n  else if ($n2Squared <= $pSquared) {\n    return $n4;\n  }\n  else\
    \ {\n    return ($n % $p) + modp($n - $n, $p);\n  }\n}\n", "    return $n - ($n\
    \ % ($p === $p ? $p : $p) - $p);\n}\n</code>\n<|/ a tags=php,math dscore=2 |>\n\
    <| c |>\nThat is the exact same answer I gave two days ago...\n<|/ c |>\n<| c\
    \ |>\ni know i gave an answer two days ago, but it's different enough to count\
    \ as a different answer.\n<|/ c |>\n<| c |>\nHaha, no worries. I guess I was too\
    \ late with the answer, lol. Sorry! :)\n<|/ c |>\n<| c |>\nI don't even understand\
    \ how you got the \"exact same answer\" if you got it from me ;)\n<|/ c |>\n<|\
    \ c |>\nsorry I was not thinking before posting. Thanks :)\n<|/ c |>\n<| a tags=php,math\
    \ |>\nYou need modulo\n<code>", "  $n = $n - floor($n); // Normalize $n and $p\n\
    \  $n = $n * floor($p / $n);\n  $p = ($p - $n * floor($p / $n)) * floor($p / $n);\n\
    \  return $p;\n}", "  $nMod = $n % $p;\n  if ($nMod != 0) {\n    return $nMod\
    \ - ($p + ($p / $nMod));\n  } else {\n    return 0;\n  }\n}\n", "  return $p ===\
    \ 0\n      ? 1\n      : $n == 0\n      ? 0\n      : ($n % $p) / $p;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI really need to look into this. This is quite interesting!\
    \ Thank you!\n<|/ c |>\n<| c |>\nAwesome solution. I'm just wondering if it's\
    \ possible to make it work for the [decimal type](https://msdn.microsoft.com/en-us/library/cc953fek(v=office.12).aspx)\
    \ too\n<|/ c |>\n<| c |>\n: I've added the code to the answer, just in case it\
    \ might help someone else.\n<|/ c |>\n<| c |>\nI like that `mod` function that\
    \ you use! But I wouldn't recommend this one for big numbers (it's O(n)). You'd\
    \ better try to use binary methods like `modpow` or `mod2`, or implement a [modular\
    \ arithmetic algorithm](https://en.wikipedia.org/wiki/Modular_exponentiation#Algorithm_using_Gauss_algorithm_to_exponentiate_a_modulus)\
    \ by yourself (it's easier to implement but also has worse time complexity).\n\
    <|/ c |>\n<| c |>\n: Good point. Implementing a binary method would be O(log n)\
    \ but would need O(log log n) time complexity. Of course, the advantage is that\
    \ it can handle numbers with arbitrary precision (for example BigDecimal), which\
    \ may or may not be a deal breaker for OP.\n<|/ c |>\n<| a tags=php,modulo |>\n\
    I've written a small module that works with float (double) numbers and BigIntegers\
    \ (PHP 7)\n<code>\n/**\n * Floor division modulo\n *\n * float $dividend (dividend)\n\
    \ * float $divisor (divisor)\n * float $modulus\n * float\n */", "  if (!is_numeric($p))\
    \ {\n    trigger_error(\"modp() expects parameter 2 to be long, integer given\"\
    , E_USER_WARNING);\n    return 1;\n  }\n  // Get modulus\n  $modulus = pow(2,\
    \ ($n * 8) - 2);\n  return ($modulus % $p);\n}\n", "  $n = intval($n);\n  $p =\
    \ intval($p);\n  if ($n == 0 || $p == 0) {\n    return 0;\n  }\n  if ($p <= 0)\
    \ {\n    return ($n % $p);\n  }\n  if ($p > $n) {\n    return ($n % $p);\n  }\n\
    \  do {\n    $r = $n % $p;\n    $n = (int) ($p / $p);\n    $p = $r;\n  } while\
    \ ($p > 0);\n  return $r;\n}\n\n/*\n * Montgomery reduction\n */", "  return pow($n,\
    \ $p % $p, $p);\n}\n", "  if ($n%$p != 0) {\n    if ($n%$p == 1) return $p;\n\
    \    if ($n%$p == 0) return $n%$p;\n  }\n  else {\n    $r = modp($n/$p, $p);\n\
    \    return $r*$p + ($n%$p);\n  }\n}\n", "\treturn $n % $p;\n}\n", "    return\
    \ $n & ($p - 1); // same as $n % $p\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    I got my own solution based on this answer but with much better code quality:\n\
    <code>", "  return ($n - ($n % ($p - 1))) / $p;\n}\n", "  // >>> modp(2, 3)\n\
    \  // 3\n  // >>> modp(10, 3)\n  // 3\n  if ($n < 0 || $n % $p === 0) {\n    return\
    \ $n;\n  }\n  // >>> modp(4, 3)\n  // 2\n  // >>> modp(1, 4)\n  // 0\n  if ($n\
    \ % $p !== 0) {\n    return ($n % $p) % $p;\n  }\n  // >>> modp(1, 9)\n  // 1\n\
    \  return $n % $p;\n}\n", "  $ns = array($n, $p); // $ns[0] + $ns[1]\n  do {\n\
    \    $ns[0] = bcadd($ns[0], 1);\n    $ns[1] = bcsub($ns[1], 1);\n  } while (bccomp($ns[1],\
    \ 0, BC_EPSILON) != 1);\n  return $ns[0];\n}\n\n$x = $a + $b;\n$y = $a + $c;\n\
    $z = $b + $c;\n\n$a2 = $a * $a;\n$a3 = $a2 * $a;\n$a4 = $a2 * $b;\n$a5 = $a3 *\
    \ $b;\n$a6 = $a4 * $b;\n$a7 = $a5 * $b;\n\n$a4 = $a4 * $c;\n$a5 = $a5 * $c;\n\n\
    $a2 = bcsub($a5, $a4);\n$a4 = bcsub($a7, $a6);\n$a6 = bcadd($a2, $a6);\n\n$b =\
    \ bcadd($a2, $a4);\n$c = bcsub($a6, $a5);\n\n$a2 = $a2 * $c;\n$a3 = $a3 * $c;\n\
    \n$a4 = bcmul($a2, $y);\n$a5 = bcmul($a4, $y);\n$a6 = bcmul($a3, $y);\n\n$a2 =\
    \ bcmul($a4, $z);\n$a3 = bcmul($a6, $z);\n\n$a2 = bcadd($a2, $a5);\n$a4 = bcadd($a3,\
    \ $a6);\n\n$b = bcsub($a4, $a2);\n$c = bcsub($b, $a3);\n\n$a = bcmul($b, $c);\n\
    $a = bcadd($a, $b);\n", "  return ($n % $p) + $p;\n}\n", "    return ($n % $p)\
    \ + (($n % $p) < ($p / 2)) ? $n % $p : $n % $p + $p;\n}", "  return $n % $p ==\
    \ 0 ? ($n % $p) + $p : $n % $p;\n}\n", "  return pow($n, $p - 2, $p);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\n\"Beware of numerics\" - this is where I would have\
    \ gone wrong too.\n<|/ c |>\n<| c |>\n- What exactly do you mean?\n<|/ c |>\n\
    <| c |>\nMy bad, I thought you meant modulo. You're right of course.\n<|/ c |>\n\
    <| c |>\n- Oh, so that's what you meant. I'll edit my answer to reflect that.\n\
    <|/ c |>\n<| a tags=math,algorithm,php |>\n<code>", "  $res = 1;\n  for ($i =\
    \ 1; $i <= $n; $i++) {\n    $res *= ($p - $i);\n  }\n  return $res;\n}\n", " \
    \   $r = $n % $p;\n    if ($r == 0) {\n        return $p;\n    } elseif ($r >\
    \ 0) {\n        return $p;\n    } else {\n        return $n % $p;\n    }\n}\n",
  "  return $n - ($n / $p) * $p;\n}\n", "  $n = $p - $n % $p;\n  return $n % $p;\n\
    }\n", "  return $n % $p; // & ($n >= $p);\n}", "  return $n % $p;\n}\n", "  return\
    \ $n % $p == 0 ? $n : ($n % $p + ($p ^ ($n % $p) - $n) % $p) % $p;\n}", "    if\
    \ ($n == 0) {\n        $n = '0';\n    }\n    return ($n%$p)%$p;\n}\n", "  if ($n\
    \ < 0) {\n    $n = (-$n) % $p;\n  }\n  return $n % $p;\n}\n", "  if (!$n) return\
    \ $n;\n  if ($n>$p) return $n;\n  if ($p>$n) return $p;\n\n  if ($n<0) return\
    \ $p+modp(abs($n), $p);\n  $x = 0;\n  while ($n>0) {\n    $x = $x*$n%$p;\n   \
    \ $n = (int)floor($n/$p);\n  }\n  return $x;\n}\n", "  return $n - ($n % ($p));\n\
    }\n", "  $n = $n * 2;\n  for ($i = 0; $i < $p; $i++) {\n    $n = (int) ($n / 2);\n\
    \  }\n  return $n % $p;\n}\n", "    return ($n % $p + $p) % $p;\n}\n", "    //\
    \ $n and $p are integers or strings\n    $n = intval($n);\n    $p = intval($p);\n\
    \    if ($n == $p) {\n        return 1;\n    }\n    $n_copy = $n;\n    $p_copy\
    \ = $p;\n    if ($n_copy > $p_copy) {\n        // We use $n here because of the\
    \ possibility of negative $n\n        // and $p values, where $n_copy would always\
    \ equal $p_copy.\n        // Using $p instead so that we only need to consider\
    \ $p if $n\n        // is negative, and not $n if $n is positive.\n        $n_copy\
    \ = $p_copy;\n        $p_copy = $n;\n    }\n    if ($n_copy == 0) {\n        return\
    \ 0;\n    }\n    if ($p_copy == 0) {\n        return -1;\n    }\n    if ($p_copy\
    \ > $n_copy) {\n        // $n and $p are both negative.\n        return 1;\n \
    \   }\n    // $n and $p are both positive.\n    $n_copy = $p_copy;\n    $p_copy\
    \ = $n;\n    if ($n_copy == 0) {\n        // Either $n or $p is 0, which means\
    \ either $n is 1, or $p is 1,\n        // so either $n or $p is odd. So we need\
    \ to return the greatest\n        // possible value for $n_copy so that we never\
    \ return 0 and 1,\n        // because that would mean that both $n and $p were\
    \ even.\n        return $n_copy % $p_copy;\n    }\n    if ($p_copy == 1) {\n \
    \       return 0;\n    }\n    $n_copy = $p_copy;\n    $p_copy = $n;\n    if ($n_copy\
    \ == 1) {\n        return 0;\n    }\n    if ($p_copy < $n_copy) {\n        //\
    \ $n and $p are both negative.\n        // So we use the fact that $n_copy is\
    \ odd, and $p_copy even.\n        // See modular arithmetic.\n        return modp($n_copy,\
    \ 2 * $p_copy);\n    }\n    // $n and $p are both positive.\n    // $n_copy is\
    \ odd, so $p_copy is even.\n    // See modular arithmetic.\n    return modp($p_copy,\
    \ $n_copy - $p_copy);\n}\n", "  if (!$n) {\n    return 1;\n  }\n  if ($p < 1)\
    \ {\n    return $n;\n  }\n  if ($p > $n) {\n    return $p;\n  }\n  return bcmod($n,\
    \ bcpow($p, $n));\n}", "  if ($p == 0) return $n;\n  if ($p > $n) return 0;\n\
    \  if ($p < -$n) return 0;\n  return $n % $p;\n}\n", "  return ($n % $p) + $p;\n\
    }\n", "  return ($n % $p) + $p;\n}\n", "  if ($n < 0) return $n % $p;\n  else\
    \ return $n - ($n % $p); // negative means $n may overflow $p\n}\n", "  if ($p\
    \ % $n == 0) return $p;\n  return $n % $p + (($p % $n) != 0 ? 1 : 0);\n}\n", " \
    \ $r = $n % $p;\n  if ($r == 0) {\n    return $p;\n  }\n  return $r;\n}\n", " \
    \   if ($n%$p != 0) {\n        return $n % $p;\n    } else {\n        if ($n %\
    \ $p != 0) {\n            return $n%$p;\n        } else {\n            return\
    \ $p;\n        }\n    }\n}\n", "  if ($n < 0 || $p < 0)\n    return null;\n  return\
    \ ($n ** $p) % $p;\n}\n", "  if ($n < 0 || $n >= $p) {\n    return 0;\n  }\n \
    \ if ($n == 0) {\n    return 1;\n  }\n  if ($p < 0) {\n    return ($n % $p) +\
    \ modp($n / $p, $p);\n  }\n  return modp($n / $p, $p);\n}\n", "  return pow($n,\
    \ $p - 2, $p);\n}\n\n/**\n * Calculate an nth root of a number, modulo p (be aware\
    \ of numerics).\n * Useful for large numbers such as Pi.\n * >>> nthroot(9, 2)",
  "  return $n % $p;\n}\n", "\tif ($n == 0) {\n\t\treturn 0;\n\t}\n\n\tfor ($i = 0;\
    \ $n < $i; ++$n) {\n\t\tif ($n & 1) {\n\t\t\tif ($n % $p == 0) {\n\t\t\t\treturn\
    \ $p;\n\t\t\t}\n\n\t\t\t$n /= $p;\n\t\t}\n\t\telse {\n\t\t\tif ($n % $p == 0)\
    \ {\n\t\t\t\treturn $p;\n\t\t\t}\n\n\t\t\t$n = (int) ($n / $p);\n\t\t}\n\t}\n\n\
    \treturn 1;\n}", "  if ($n < 0) {\n    $n += $p;\n    if ($n < 0)\n      $n =\
    \ (-$p) + $n;\n  }\n\n  return ($n % $p);\n}\n", "  $n2 = $n * $n;\n  $p2 = $p\
    \ * $p;\n  if ($p2 == 0) {\n    return $n2;\n  }\n  if ($n2 < $p2) {\n    return\
    \ $n;\n  }\n  if ($n2 > $p2) {\n    return $p;\n  }\n  return $n2 % $p;\n}", "\t\
    if ($n < 0) {\n\t\treturn $n % $p;\n\t} else if ($n < $p) {\n\t\treturn $n - $p;\n\
    \t} else {\n\t\treturn $n % $p;\n\t}\n}\n", "    return $n % $p;\n}\n</code>\n\
    <|/ a dscore=4 tags=math,php,algorithm |>\n<| c |>\nI ran your code with a random\
    \ large number generator that produced a large prime number. This produced a result\
    \ that seemed correct but gave strange results for certain inputs. For example,\
    \ `modp(97752, 104)` returned 1, which is correct. However, `modp(97752, 105)`\
    \ returned `97752` which is not correct, and is also strange as I ran it multiple\
    \ times over different ranges and it never returned `97752`. The input 97752 was\
    \ a prime number generated by a python script that uses the Miller-Rabin primality\
    \ test (https://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test). As far\
    \ as I can tell, there are no bugs in your code.\n<|/ c |>\n<| c |>\nThe prime\
    \ number was found by searching all primes up to the square root of the number\
    \ you are checking. The Miller-Rabin test is used to determine if your number\
    \ is composite or not, but you also need to know if the number is prime or composite.\
    \ There are two methods of determining primality. My method uses the fact that\
    \ a prime number is odd (odd number mod 2 == 0), and the fact that any non-prime\
    \ number is odd (even number mod 2 == 1).\n<|/ c |>\n<| c |>\nThis code does not\
    \ work at all. I just tried it with a number that is too small to be prime and\
    \ it is still giving me a wrong result\n<|/ c |>\n<| c |>\nit does indeed, what\
    \ numbers are you using?\n<|/ c |>\n<| c |>\nThis code is incorrect, it's too\
    \ long and too slow.  I suggest you take it out of the answer and post it somewhere\
    \ else like http://codereview.stackexchange.com/questions/17444/php-mod-operator-implementation-with-testing-for-primality\n\
    <|/ c |>\n<| a |>\nThis code uses OEIS as a reference to determine if the input\
    \ is a prime number.\n<code>", "  if ($p % 2 == 0) {\n    return pow($n, $p /\
    \ 2);\n  } else {\n    return pow($n, floor($p / 2));\n  }\n}\n", "    return\
    \ ($n % $p) < ($p / 2 ? $p - 1 : $p);\n}\n", "    if ($n % $p != 0) {\n      \
    \  $n = ($n % $p) * $p + ($n%$p)*$p + $n;\n    }\n    return $n;\n}\n", "  return\
    \ $n % $p == 0 ? $n : $p * modp($n / $p, $p) + $n % $p;\n}\n", "  // We use a\
    \ lookup table to speed up the multiplication.\n  $xp = array(\n    1       =>\
    \ 1,\n    3       => 7,\n    5       => 10,\n    7       => 11,\n    10      =>\
    \ 16,\n    11      => 16,\n    16      => 23,\n    23      => 30,\n    30    \
    \  => 31,\n    31      => 39,\n    39      => 40,\n    100     => 101,\n    101\
    \     => 120,\n    120     => 151,\n    151     => 180,\n    180     => 230,\n\
    \    230     => 270,\n    270     => 330,\n    330     => 370,\n    370     =>\
    \ 420,\n    420     => 480,\n    480     => 540,\n    540     => 600,\n    600\
    \     => 625,\n    625     => 660,\n    660     => 725,\n    725     => 770,\n\
    \    770     => 840,\n    840     => 920,\n    920     => 1000,\n    1000 => 1050,\n\
    \    1050 => 1075,\n    1075   => 1100,\n    1100   => 1151,\n    1151   => 1200,\n\
    \    1200   => 1225,\n    1225   => 1250,\n    1250   => 1275,\n    1275   =>\
    \ 1300,\n    1300   => 1351,\n    1351   => 1400,\n    1400   => 1451,\n    1451\
    \   => 1500,\n    1500 => 1551,\n    1551   => 1600,\n    1600   => 1651,\n  \
    \  1651   => 1700,\n    1700 => 1751,\n    1751 => 1800,\n    1800   => 1851,\n\
    \    1851   => 1900,\n    1900 => 1951,\n    1951  => 2000,\n    2000 => 2051,\n\
    \    2051  => 2100,\n    2100   => 2151,\n    2151   => 2200,\n    2200   => 2251,\n\
    \    2251   => 2300,\n    2300   => 2351,\n    2351   => 2400,\n    2400 => 2451\n\
    \  );\n\n  return $xp[$p < $n ? $p : $n] % $n;\n}\n", "    return (($n % $p) +\
    \ $p) % $p;\n}\n", "    $n %= $p;\n    if ($n < 0)\n        $n = ($p - 1) + ($n\
    \ >> $p);\n    return $n;\n}\n", "  return $n % $p;\n}\n\n/**\n * Test the equality\
    \ of two values.\n *\n * In PHP 5 this function is deprecated in favor of is_numeric,\
    \ which will be\n * removed in future versions.\n *\n * @deprecated\n * @return\
    \ bool whether the values are equal\n */", "    return ($n % $p);\n}\n", "  return\
    \ $n - ($n%$p);\n}", "  return $n % $p;\n}\n\n/**\n * Returns the logarithm of\
    \ the absolute value of the argument.\n */", "  if ($n % $p === 0) return $n;\n\
    \  return $n % $p + $p;\n}", "    if ($n == 0) return 1;\n    $m = (int) ($p /\
    \ $n);\n    $r = ($p % $n) * modp($n, $p);\n    if ($m == 0 && $r > 0) return\
    \ 0;\n    if ($m == 0 && $r == 0) return 1;\n    return $r;\n}", "  $n = (int)\
    \ $n;\n  $p = (int) $p;\n  if ($n == 0) {\n    return $p;\n  }\n  $res = 1;\n\
    \  for ($i = 0; $i < $n; $i++) {\n    $res *= $p;\n    $res += ($n % $p);\n  \
    \  $n = floor($n / $p);\n  }\n  return $res;\n}\n", "  $n = intval($n);\n  $p\
    \ = intval($p);\n  if ($n === 0) {\n    return 0;\n  }\n  return ($n % $p) < ($p\
    \ / 2) ? $p : $n;\n}\n", "  return $n % $p;\n}\n", "  return ($n%$p) + $p;\n}\n",
  "    if ($p <= 0) return $n;\n    if ($n <= 0) return $p;\n    if ($n == $p) return\
    \ 1;\n    return $n % $p + ($p != ($n % $p) ? 1 : 0);\n}\n", "  $npos = array_search($n,\
    \ $p);\n  return $npos === false ? $n : $p[$npos];\n}", "  return (int) ($n %\
    \ $p);\n}\n", "  if ($n == 0) {\n    return 0;\n  }\n  if ($n < 0) {\n    return\
    \ -modp(abs($n), $p);\n  }\n  if ($p < 0) {\n    return -modp($n, abs($p));\n\
    \  }\n  if ($p === 0) {\n    return $n;\n  }\n  return ($n % $p) == 0 ? $p : -modp($n,\
    \ $p);\n}\n", "  return pow($n, $p % $p, (1 / $p));\n}\n", "  // From the Wikipedia\
    \ article:\n  // http://en.wikipedia.org/wiki/Modulo_operation\n  return $n %\
    \ $p == 0 ? $n : $n % $p + $p;\n}", "  $n = intval($n);\n  $p = intval($p);\n\
    \  if ($p === 0) {\n    return 1;\n  }\n  if ($n < 0) {\n    return $p < 0 ? -pow(-$n,\
    \ $p) : 0;\n  }\n  if ($p < 0) {\n    return $p < 0 ? -pow($n, $p) : 0;\n  }\n\
    \  $y = $n = $n * $p;\n  $x = 1;\n  while ($n > 0) {\n    if (($y -= $n & 1) <\
    \ 0) {\n      $x += $p;\n      $n = $y >> 1;\n      $y = $x % $p;\n    }\n   \
    \ $x *= $p;\n    $n--;\n  }\n  return $x % $p;\n}\n", "  return pow(2, $n) % $p;\n\
    }", "    $n = $p - floor($n / $p);\n    if ($n * $n == 0) {\n        return 0;\n\
    \    }\n    return $n / $p;\n}", "    if (!is_numeric($n) || !is_numeric($p))\
    \ return null;\n    $sign = intval($n) < 0;\n    $n = abs($n);\n    $p = abs($p);\n\
    \n    if ($p < 0) {\n        $p *= -1;\n        $sign *= -1;\n    }\n\n    $r\
    \ = 1;\n    while ($p > 0) {\n        $r = $r * $n % $p;\n        $n = ($n / $p)\
    \ * $p;\n        $p--;\n    }\n\n    if ($sign) $r = -$r;\n    return $r;\n}\n",
  "  $n1 = $n * 2;\n  return ($n1 % $p) == 0 ?\n      (int)$n : $n1 - (int)($n1 %\
    \ $p);\n}\n\n", "    if ($n < 0) {\n        $n = $n + $p;\n    }\n\n    $r = $n\
    \ % $p;\n    if ($r == 0 && $n != $p) {\n        $r =1;\n    }\n    return $r;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nHi, Thanks for your answer, but i can't seem to\
    \ get it to work with larger numbers. I've tried using your modp function but\
    \ when i try to test it with an example: modp(101, 101) it returns 1 instead of\
    \ 2. I tried this with other examples as well, such as modp(201, 101) but that\
    \ also returns 1 instead of 2. Can you see what I'm doing wrong here?\n<|/ c |>\n\
    <| c |>\n: I just changed my answer, it works for me for larger numbers.\n<|/\
    \ c |>\n<| c |>\nHi, thank you for updating your code. I've tried using it with\
    \ the example I mentioned in my previous comment but that still doesn't seem to\
    \ work for me. I've checked the PHP site and they say that the modp function works\
    \ on larger numbers. Can you have a look at my test code I put in my original\
    \ post? I tried to do modp(201, 101) but it still returns 1.\n<|/ c |>\n<| c |>\n\
    : I suspect you are running this code on the 32-bit version of PHP. On my computer,\
    \ this works perfectly: http://ideone.com/GgKJCq\n<|/ c |>\n<| c |>\nHi, I'm running\
    \ it on a windows 7 machine with xampp installed with version 5.6.8. Is that a\
    \ problem? I've checked the version you've used and it also returns 1 instead\
    \ of 2.\n<|/ c |>\n<| a dscore=0 |>\nI recommend a simpler algorithm:\n<code>",
  "  $r = 1;\n  for ($i = 0; $i < $p; $i++) {\n    $r = $r * $n >> $i;\n  }\n  return\
    \ $r;\n}\n</code>\n<|/ a tags=modular-arithmetic,php,integer-arithmetic |>\n<|\
    \ c |>\nYour `modp` function returns different results than your `mod` function.\
    \  Are you sure the function returns the same results?  It should be returning\
    \ 1 in your first test case, and 8 in your second.\n<|/ c |>\n<| c |>\nYes, I\
    \ noticed that, thank you. I fixed the answer. Thanks for the heads up.\n<|/ c\
    \ |>\n<| c |>\nI didn't even know that `%` could overflow in PHP.  Nice!\n<|/\
    \ c |>\n<| c |>\nThe reason you still get the same result as OP is because you\
    \ used `ceil` instead of `floor` when determining the modulus. In fact, `ceil`\
    \ returns `1` for `$n = 12` and `$p = 12`.\n<|/ c |>\n<| c |>\nWhoops, yeah, that's\
    \ right. Thanks for pointing that out.\n<|/ c |>\n<| a tags=modular-arithmetic,php,integer-arithmetic\
    \ dscore=3 |>\nI find it most readable in these cases to use a for loop. For example:\n\
    <code>", "  return $n * $p % $p;\n}\n", "  return ($n % $p) + $p * (($n + 1) /\
    \ $p);\n}\n\n/**\n * Multiply two numbers and return the product\n * >>> mul(2,\
    \ 3)", "\treturn (pow($n, $p) % ($p)) < 0 ? $n : $n % $p;\n}", "    return ($n\
    \ % $p) + $p;\n}\n", "  if ($n < 0) {\n    return -1;\n  }\n  if ($p < 0) {\n\
    \    return $n % $p;\n  }\n  if ($p === 0) {\n    return 1;\n  }\n  if ($p ===\
    \ 1) {\n    return $n;\n  }\n  if ($n % $p === 0) {\n    return $n / $p;\n  }\n\
    \  return modp($n / $p, $p);\n}\n</code>\n<|/ a dscore=1 tags=php,algorithm,javascript,performance,number-theory\
    \ |>\n<| c |>\nI've taken the liberty of editing your answer a bit, for readability,\
    \ and added a few comments.\n<|/ c |>\n<| c |>\nWow, that's an awesome solution\
    \ and works perfectly, thank you very much!\n<|/ c |>\n<| c |>\nI wouldn't have\
    \ thought of it until I saw your solution to [this question](http://stackoverflow.com/q/15151018/1269037).\
    \  You are the man!\n<|/ c |>\n<| a dscore=0 |>\nThe algorithm you're looking\
    \ for is called the Modulo Theorem. The best way to solve it is to write an efficient\
    \ implementation of the theorem, and benchmark it against other possible solutions.\
    \ There are several ways of doing this (including a table lookup algorithm), but\
    \ I would suggest you try the following implementation:\n<code>", "    return\
    \ ($n % $p) + floor($n % $p) / $p;\n}\n", "  return $n & ($p - 1); \n}\n\n$min\
    \ = $_GET['min'];\n$max = $_GET['max'];\n$n = $_GET['n'];\n\n$num = 0;\n\n$arr\
    \ = [];\nfor ($i = $min; $i <= $max; $i++) { \n  $arr[] = $i;\n}\n\n$count = count($arr);\n\
    \nfor ($i = 0; $i < $count; $i++) {\n  $num += modp($arr[$i] + $n, 9);\n}\n\n\
    echo $num;", "    if ($n < 0) {\n        $n = (int) ($n / $p);\n        $p *=\
    \ -1;\n    }\n\n    if ($n%$p) {\n        return 0;\n    }\n\n    $n = (int) ($n/$p);\n\
    \n    return $n;\n}\n", "  return $n % $p;\n}", "\treturn (int)($n % $p);\n}\n",
  "  if ($p === 0) return 1;\n  if ($p === 1) return $n;\n  if ($p === -1) return\
    \ (~$n) + 1;\n  if ($p === -2) return (~$n) + 2;\n  if ($p === -3) return (~$n)\
    \ + 3;\n  if ($p === -4) return (~$n) + 4;\n  if ($p === -5) return (~$n) + 5;\n\
    \  if ($p === -6) return (~$n) + 6;\n  if ($p === -7) return (~$n) + 7;\n  if\
    \ ($p === -8) return (~$n) + 8;\n  if ($p === -9) return (~$n) + 9;\n  if ($p\
    \ === -10) return (~$n) + 10;\n  if ($p === -11) return (~$n) + 11;\n  if ($p\
    \ === -12) return (~$n) + 12;\n  if ($p === -13) return (~$n) + 13;\n  if ($p\
    \ === -14) return (~$n) + 14;\n  if ($p === -15) return (~$n) + 15; // From http://primes.utm.edu/lists/small/1000.txt\n\
    \  if ($p === -16) return (~$n) + 16;\n  if ($p === -17) return (~$n) + 17;\n\
    \  if ($p === -18) return (~$n) + 18;\n  if ($p === -19) return (~$n) + 19;\n\
    \  if ($p === -20) return (~$n) + 20;\n  if ($p === -21) return (~$n) + 21;\n\
    \  if ($p === -22) return (~$n) + 22;\n  if ($p === -23) return (~$n) + 23;\n\
    \  if ($p === -24) return (~$n) + 24;\n  if ($p === -25) return (~$n) + 25;\n\
    \  if ($p === -26) return (~$n) + 26;\n  if ($p === -27) return (~$n) + 27;\n\
    \  if ($p === -28) return (~$n) + 28;\n  if ($p === -29) return (~$n) + 29;\n\
    \  if ($p === -30) return (~$n) + 30;\n  if ($p === -31) return (~$n) + 31;\n\
    \  if ($p === -32) return (~$n) + 32;\n  if ($p === -33) return (~$n) + 33;\n\
    \  if ($p === -34) return (~$n) + 34;\n  if ($p === -35) return (~$n", "    if\
    \ ($n >= $p)\n        return 0;\n    if ($n == 0)\n        return 1;\n    $n =\
    \ $p - $n;\n    return ($n & ($n << 1)) == 0 ? ($n >> 1) : ($n - 1);\n}\n", " \
    \   $r = 1;\n    while ($p != 0) {\n        if ($n & 1) {\n            $r *= $p;\n\
    \        }\n        $n >>= 1;\n        $p--;\n    }\n    return $r;\n}\n", " \
    \   $p = $p < 1 ? 1 : $p;\n    $r = $n % $p;\n    return $r == 0 ? 1 : $p - $r;\n\
    }\n", "    return $n % $p === 0 && $n % $p !== 0 && $n % $p == 0;\n}\n</code>\n\
    And with PHP >= 5.5 you can make your function more efficient by using a combination\
    \ of bitwise operators and comparison against 0\n<code>", "  if ($n == 0 || $p\
    \ == 0) return $n;\n  if ($p > $n) return $n % $p;\n  if ($n < $p) return ($n\
    \ % $p) + $p;\n  else return $n;\n}\n", "  return $n % $p;\n}\n\n$i = (int) $_GET['i'];\n\
    $j = (int) $_GET['j'];\n$k = (int) $_GET['k'];\n\n$i2 = modp($i+1, 101);\n$j2\
    \ = modp($j+1, 101);\n$k2 = modp($k+1, 101);\n\n$j3 = modp($j+2, 101);\n$i3 =\
    \ modp($i+2, 101);\n$k3 = modp($k+2, 101);\n$p = (int) $_GET['p'];\n\n$q = $i\
    \ + $p * ($j - $i) *($k - $j) * ($k - $k);\n$r = $i + $p * ($j - $i) * modp($j+2,\
    \ 101) * ($k - $j) * modp($k+2, 101);\n$s = $i * $j * ($k - $k) * modp($k+2, 101);\n\
    \n$a = (int) $_GET['a'];\n$b = (int) $_GET['b'];\n\necho \"$q mod $p = ($q * $j\
    \ + $q * $k + $q + $r + $s + $a) mod $p\\n\";\necho \"$r mod $p = ($q * $j + $q\
    \ * $k + $q + $r + $s + $b) mod $p\\n\";\necho \"$s mod $p = ($i * $k + $i * $k)\
    \ mod $p\\n\";\necho \"$a mod $p = ($i * $j + $i * $k + $i + $j + $j + $k + $k)\
    \ mod $p\\n\";\necho \"$b mod $p = ($i * $j + $i * $k + $i + $j + $j + $k + $k)\
    \ mod $p\\n\";", "    if (!is_numeric($n) || !is_numeric($p)) {\n        die('modp()\
    \ expects two non-numeric arguments.');\n    }\n    // Based on http://code.google.com/p/modpstats/source/browse/trunk/modpstats.php\n\
    \    return bcmod($n, $p);\n}\n", "  return pow($n, $p % 2147483647, 2147483647);\n\
    }", "    return $p > 0 ? ($n % $p + $p) % $p : $n % $p;\n}\n", "    return (int)\
    \ ($n % $p);\n}\n\n/**\n * @return string\n */", "  return bcmod($n, bcpow('2',\
    \ $p));\n}\n", "    return $n%$p;\n}\n", "    return ($n % $p) + $p;\n}\n", " \
    \ $q = $n / $p;\n  $r = $n % $p;\n  if ($r == 0) {\n    return $q;\n  } else if\
    \ ($r < 0) {\n    return $q + modp($q, $p);\n  } else {\n    return $q;\n  }\n\
    }\n", "    return ($n % $p + $p) % $p;\n}\n", "  if ($n % $p != 0) {\n    return\
    \ $n % $p;\n  }\n  return ($n % $p) + $p;\n}", "    if (!isset($p) || $p === null)\
    \ {\n        $p = 2;\n    }\n\n    return (int) ($n % $p);\n}\n", "  return ($n\
    \ % $p) + $p;\n}\n", "    if ($n < 0) {\n        $n = $n % ($p / abs($p));\n \
    \       if ($n < 0) {\n            $n = $p + ($n + 1);\n        }\n    } else\
    \ {\n        $n = (int) $n;\n    }\n    return $n;\n}\n", "    return ($n % $p\
    \ + $p) % $p;\n}\n", "  if ($n == 0) {\n    return 0;\n  }\n  $modulus = pow(2,\
    \ $p);\n  return ($modulus % $n) + ((~$modulus) % $n);\n}\n\n/**\n * A variant\
    \ of modp that returns 0 if the number is negative.\n *\n * See `modp` for details.\n\
    \ *\n * @param $n The number to test.\n * @param $p The modulus.\n */", "  //\
    \ TODO: modpow($n, $p, $m)\n  return pow($n, $p - ($p & ($n >> 1)) & ~(pow($n,\
    \ $p & 1) & ($n >> 1)), p)\n}", "  $n = (int) $n;\n  $p = (int) $p;\n  if ($p\
    \ == 0) return $n;\n  if ($n == 0) return $p;\n  if ($p == 1) return 1;\n  if\
    \ ($n == 1) return $p;\n  if ($p == -1 && $n != 1) return $n;\n\n  // p % n ==\
    \ 0 <=> n != 1 && p % n == 0 <=> n != 1 && p % n == 1\n  // p % n == 1 <=> n ==\
    \ 1 && p % n == 1 <=> n != 1 && p % n != 1\n  // p % n != 1 <=> n != 1 && p %\
    \ n != 1 <=> n != 1 && p % n == 1\n  $n1 = $n & -$p;\n  $n2 = $n >> $p;\n\n  //\
    \ n <-> n1 + n2\n  if ($n1 == $n2) {\n    return modp($n1 + $p, $p);\n  }\n\n\
    \  $n1 += $p & -$n1;\n  $n2 += $p >> $p;\n\n  // n1 <-> n1 + n2\n  if ($n1 ==\
    \ $n2) {\n    return modp($n1 + $p, $p);\n  }\n\n  $n1 += $p & -$n1;\n  $n2 +=\
    \ $p >> $p;\n\n  // n1 <-> n1 + n2\n  if ($n1 == $n2) {\n    return modp($n1 +\
    \ $p, $p);\n  }\n\n  // n1 <-> n1 + n2\n  return modp($n1 + $n, $n);\n}", "  return\
    \ (int)((int)pow($n, $p % $n, $p) - pow(1 - $n, $p % $n, $p));\n}\n", "  // assert($n\
    \ >= 0 && $n <= 0xffffffff && $p >= 0 && $p <= 0xffffffff && $n % $p == 0, 'modp()\
    \ only accepts an integer between 0 and 0xffffffff and 0 <= $p <= 0xffff');\n\
    \  if ($n < 0) {\n    return $p + modp(-$n, $p);\n  }\n\n  if ($n >= 0xffffffff)\
    \ {\n    return $p + (0 - modp(0xffffffffffffffff, $p));\n  }\n\n  return $p +\
    \ ($n % $p);\n}\n", "  if ($n == $p)\n    return $n;\n  if ($n == 0)\n    return\
    \ 0;\n  if ($n == 1)\n    return $p;\n  if ($p == 1)\n    return $n;\n  if ($p\
    \ % 2 == 0 && $n % $p == 0)\n    return $p / $n;\n  if ($p % 2 == 1 && $n % $p\
    \ == 0)\n    return $n;\n  if ($p == $n)\n    return 1;\n  $q = modp($p, $n);\n\
    \  if ($n % $q == 0)\n    return $q;\n  return $n / $q;\n}\n", "    return $p\
    \ > 0 ? ((pow(2, $n) % $p) + $p) % $p : $n; // pow returns float.\n}\n", "  return\
    \ $n - ($n % $p);\n}\n", "    if ($n < 0) {\n        $n = ($p - ($n >>> 1)) |\
    \ 0;\n    }\n    return ((($n * $p) % $p) + $n) % $p;\n}\n", "  return $n % $p\
    \ == 0 ? (int) pow(2, $p * abs($n - $p) / $p) : (int) $n % $p;\n}\n", "    $n2\
    \ = $n * 2;\n    $n3 = $n2 * 3;\n    $n4 = $n3 * 4;\n    $n6 = $n4 * 6;\n    $n8\
    \ = $n6 * 8;\n    $n10 = $n8 * 10;\n    $n12 = $n10 * 12;\n    $n14 = $n12 * 14;\n\
    \    return ($p - ($n14 * floor($n / $p)) % $p);\n}\n", "  $n0 = $n|0;\n  $p0\
    \ = $p|0;\n\n  return $n0 - ($n0|$p0)%$p0;\n}", "  $n = (int)$n;\n  $p = (int)$p;\n\
    \  return ($n % $p + $p) % $p;\n}", "  $s = bcmod($n, $p);\n  return ($s < 0)\
    \ ? $s + $p : $s;\n}", "    if ($n == 0) return 1;\n    if ($n == 1) return 0;\n\
    \    if ($p < $n) return $n - ($n % $p);\n    return modp($p - ($n / $p), $p);\n\
    }\n", "  $res = 1;\n  $p = $p - 1;\n  for (; $p; $p--) {\n    $res = ($res * $n)\
    \ % $p;\n  }\n  return $res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI don't\
    \ really see any difference between this and the one I posted before with regards\
    \ to the actual algorithm. The only difference is the order of the arguments (the\
    \ least significant argument being first).\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    <?php\n$x = pow(2, 32) - 1;\n$y = pow(2, 32);\n$z = $y + 1;\n", "  if ($p < 1)\
    \ return 0;\n  if ($n == 0) return 0;\n  if ($n >= pow(2, $p - 1)) return 1;\n\
    \  return modp($n >> 1, $p - 1) | modp($n, $p) << 1;\n}", "    if ($n < 0) {\n\
    \        return $p ? modp($n*-1, $p) : 1;\n    }\n    if (!$p) {\n        return\
    \ $n % 2 ? $n : $n*-1;\n    }\n    return ($n % $p)%$p;\n}\n\n/**\n * Checks whether\
    \ a number is a power of two (2, 8, 16...)\n *\n * @param $x Number to check\n\
    \ * @return Boolean Whether the number is a power of two\n */", "  if ($n % $p\
    \ > 0) {\n    return $n % $p;\n  }\n  return $n % $p + ($p - ($n % $p));\n}",
  "  $n = (int) $n;\n  $p = (int) $p;\n  if ($n == 0 || !$p) { return 1; }\n  if ($p\
    \ < 0) { return $n % $p; }\n  return ($n % $p) / $p;\n}\n", "    $nn = $n * $n;\n\
    \    return $nn - (int) ($nn / $p);\n}\n", "    $res = 1;\n    while (true) {\n\
    \        if ($n % $p == 0) {\n            return $res;\n        }\n        $res\
    \ *= $p;\n        $n = (int) ($n / $p);\n    }\n}\n", "    if ($n%$p)\n      \
    \  return $p+modp($n%$p, $p);\n    return $n;\n}", "  return $n % $p;\n}\n", " \
    \   if ($n == 0 || $p == 0)\n        return 0;\n    return $p > $n ? $n % $p :\
    \ $n % $p;\n}\n", "    $s = 1;\n    $p *= 2;\n    do {\n        if ($p % $n ===\
    \ 0)\n            break;\n        $s *= 2;\n    } while ($n++ < $p);\n    return\
    \ $s;\n}\n", "  if ($n<$p)\n    return $p;\n  return $n;\n}\n", "  return ($n\
    \ % $p) + (($n % $p) < $p ? 1 : 0);\n}\n", "  return $n % $p == 0 ? ($n % $p +\
    \ $p) % $p : $n % $p;\n}\n\n/**\n * Return true if $number is even or odd.\n *\n\
    \ * Even numbers are considered odd.\n *\n * @param $number int|float|string\n\
    \ *\n * @return bool\n */", "  $mod = ($n % $p);\n  if ($mod == 0) {\n    return\
    \ $p;\n  }\n  return $mod;\n}\n", "    return $n % $p;\n}\n", "  $n = intval($n);\n\
    \  $p = intval($p);\n  $e = $n % $p;\n  if ($e == 0) {\n    return $p;\n  }\n\
    \  $k = $p - $e;\n  return $n % $k ? $k + ($n / $k) : $k;\n}\n", "  $n = (int)\
    \ $n;\n  $p = (int) $p;\n  if ($n == 0) {\n    return 0;\n  }\n  if ($n < 0) {\n\
    \    $n += $p;\n    if ($n < 1) {\n      return $p;\n    }\n  }\n  if ($p < 0)\
    \ {\n    $p += $n;\n    if ($p < 1) {\n      return $n;\n    }\n  }\n  $res =\
    \ $n;\n  while ($p > 0) {\n    $res *= $p;\n    $p--;\n  }\n  return $res;\n}\n",
  "\treturn (int) ($n % $p);\n}\n", "\t$n = (int) $n;\n\t$p = (int) $p;\n\tif ($p\
    \ > 0 && (($n % $p) == 0)) {\n\t\treturn $n;\n\t}\n\treturn $n % $p;\n}\n\n/**\n\
    \ * Returns true if all characters in $str1 are in $str2.\n * This is case sensitive,\
    \ so \"A\" != \"a\". If you'd like to test case insensitive, use strcasecmp.\n\
    \ * Note: This is case sensitive, so \"A\" != \"a\".\n *\n * @param string $str1\
    \ String being compared against.\n * @param string $str2 String being compared\
    \ against the first string.\n * @return bool\n */", "  return ($n & ($p - 1) ==\
    \ 0) ? $n : $n % $p;\n}\n", "\t$n = intval($n);\n\t$p = intval($p);\n\tif ($n\
    \ == $p) {\n\t\treturn $n;\n\t}\n\tif ($n < 0) {\n\t\tif ($p < 0) {\n\t\t\treturn\
    \ - modp(abs($n), abs($p));\n\t\t}\n\t\treturn modp(0 - $n, $p);\n\t}\n\tif ($p\
    \ < 0) {\n\t\treturn modp($n, abs($p));\n\t}\n\treturn (1 << ($n % $p)) - modp($n\
    \ / $p, $p);\n}", "    if ($n >= $p) {\n        return $n % $p;\n    }\n    return\
    \ ($n % $p) + $p;\n}\n", "    if ($n < 0 || $p < 0)\n        return PHPExcel_Calculation_Functions::NaN();\n\
    \n    $sign = ($n < 0);\n    $n = abs($n);\n    $p = abs($p);\n\n    if ($p ===\
    \ 0)\n        return 1;\n\n    if ($n !== floor($n) || $p !== floor($p))\n   \
    \     return PHPExcel_Calculation_Functions::NaN();\n\n    if ($p <= $n / 2)\n\
    \        return $sign;\n\n    return !$sign;\n}\n\n/**\n * INT.\n *\n * Returns\
    \ the integer part of number.\n *\n * Excel Function:\n *        FLOOR\n *   \
    \     INTEGER\n *\n * @param float $number Number to round\n *\n * @return int\
    \ Integer part of number\n */", "  return $n & ($p - 1); // bitwise and with 1\n\
    }\n", "  return bcmod($n, $p);\n}\n", "\treturn ($n % $p + $p) % $p;\n}\n\n/*\n\
    \tThe algorithm used is based on the example by Daniel J. Bernstein in\n\t\"A\
    \ Constant Time Byte-Array Implementation Using Pairing\", see \"The\n\tAlgorithm\
    \ Design Manual\", version 2.2, page 21.\n\n\tModifications have been made to\
    \ make it work with the Blowfish block and\n\tto fix a bug in some PHP versions\
    \ that would cause it to return a value\n\tof 1 instead of -1 for $c->u.\n\n\t\
    See the full source code for bcrypt() for a better understanding of\n\tthe algorithm.\n\
    */\n\nclass BCrypt {\n\n\t/**\n\t * Blowfish block size, in bytes.\n\t */\n\t\
    public $block_size = 16;\n\n\t/**\n\t * Blowfish block initialization vector.\n\
    \t */\n\tpublic $iv;\n\n\t/**\n\t * Length of the final Blowfish block, after\
    \ padding and before encoding.\n\t */\n\tpublic $padded_block_size;\n\n\t/**\n\
    \t * Padded $data after it has been encrypted and before it has been padded.\n\
    \t */\n\tpublic $pad;\n\n\t/**\n\t * Holds the output of the encryption algorithm\
    \ in order to make it\n\t * accessible to other Blowfish functions without passing\
    \ a parameter.\n\t * One must call setResult() to store the value after calling\n\
    \t * setRounds() and before calling final() again.\n\t */\n\tpublic $result;\n\
    \n\t/**\n\t * Holds the value of the block size which will be used to create\n\
    \t * the Blowfish key.\n\t */\n\tprivate $key_size;\n\n\t/**\n\t * Holds the number\
    \ of rounds used to encrypt the data.\n\t */\n\tprivate $rounds;\n\n\t/**\n\t\
    \ * The current value of the $rounds property.\n\t */\n\tprivate $rounds_count;\n\
    \n\t/**\n\t * Holds the value of the keysize property (which is not neccessarily\
    \ the\n\t * block size).\n\t */\n\tprivate $keysize;\n\n\t/**\n\t * Holds a cached\
    \ version of the $keysize variable.\n\t */\n\tprivate $cached_keysize;\n\n\t/**\n\
    \t * Holds the generated $key.\n\t */\n\tprivate $key;\n\n\t/**\n\t * Holds a\
    \ cached version of the $rounds_count variable.\n\t */\n\tprivate $cached_rounds_count;\n\
    \n\t/**\n\t * Holds the generated $iv which is used for initializing the $key\n\
    \t * variable.\n\t */\n\tprivate $iv;\n\n\t/**\n\t * Constructor with $block_size\
    \ = 16.\n\t *\n\t * @param string $input\n\t * @param int $key_size\n\t */\n\t\
    public function __construct($input, $key_", "    $r = 1;\n    while ($n-- > 0)\
    \ {\n        $r = $r * ($p--);\n    }\n    return $r;\n}\n", "  return ($n % $p)\
    \ + $p;\n}\n", "    $p = base_convert($p, 10, 2);\n    $n = base_convert($n, 10,\
    \ 2);\n    if ($p < 0 || $p > $n) {\n        return 0;\n    }\n    if ($p ===\
    \ 0) {\n        return 1;\n    }\n    $r = $n % $p;\n    if ($r < 0) {\n     \
    \   return $p - $r + $n;\n    }\n    return $r;\n}\n", "    if ($n == 0) return\
    \ 1;\n    if ($p == 0) return 0;\n    if ($p == 1) return $n;\n    if ($p < 1)\
    \ return $n % $p;\n    return ($n % $p) / $p;\n}\n", "  if ($n < 0) {\n    $n\
    \ = ($p + $n);\n  }\n\n  if ($n < 1 || $n >= $p) {\n    return 0;\n  }\n\n  return\
    \ bcmod($p, $n);\n}\n", "  if ($p == 0 || $p == 1)\n    return $p;\n  else\n \
    \   return modp($n / $p, $p) * $p;\n}\n", "    return (int) ($n % $p) + (int)\
    \ ($n % $p) >= $p ? $p - (int) ($n % $p) : $n;\n}", "\treturn $n - $n * log($p);\n\
    }", "    $r = $n % $p;\n    if ($r < 0) {\n        $r = -$p;\n        $n = $n\
    \ + ($p / abs($p));\n    }\n    return $r;\n}\n", "    if ($n < 0) {\n       \
    \ $n = -$n;\n        $p = -$p;\n    }\n    return ($n % $p + $p - 1) % $p;\n}\n",
  "  if ($n%$p == 0) return $p;\n  else if ($n%$p == $p) return modp($n, $p*$p);\n\
    \  else return modp($n%$p, $p);\n}\n", "  if ($n == 0 || $n == 1)\n    return\
    \ $n;\n  if ($p == 0)\n    return $n;\n  if ($p > $n)\n    return modp($n, $p);\n\
    \  if ($p < 0)\n    return modp($n, $p);\n\n  $n = $n % $p;\n\n  if ($p % 2 ==\
    \ 0 && $n % 2 == 0) {\n    return $n;\n  } else if ($p % 2 == 1) {\n    return\
    \ $n - $p;\n  }\n\n  // $p % 2 = 0 or 1\n  return $p * modp($n / $p, $p);\n}\n\
    \n/**\n * Return the binary GCD of two numbers\n *\n * @param int $a the first\
    \ number\n * @param int $b the second number\n * @return int\n */", "  return\
    \ $n % $p;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=php |>\n<code>\n<?php\n",
  "  return ($n % $p) + $p;\n}\n", "  if ($n >= $p)\n    return $n % $p;\n  return\
    \ modp($p - ($n % $p), $p);\n}\n", "    // Find GCD of n and p. Return -1 iff\
    \ n = p.\n    if ($n == $p) {\n        return -1;\n    }\n    // If n < p, return\
    \ -1 (numerically unsatisfiable).\n    if ($n < $p) {\n        return -1;\n  \
    \  }\n    // If n = p, return n (this is easy).\n    return $n;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
