name: HumanEval_18_how_many_times
language: php
prompt: "<?php\n// Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n// >>> how_many_times('', 'a')\n// 0\n// >>>\
  \ how_many_times('aaa', 'a')\n// 3\n// >>> how_many_times('aaaa', 'aa')\n// 3\n\
  function how_many_times($string, $substring) {\n"
tests: "function candidate(...$args) {\n    return how_many_times(...$args);\n}\n\n\
  function test(): void {\n    if (candidate(\"\", \"x\") !== 0) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"xyxyxyx\", \"x\") !== 4) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"cacacacac\", \"cac\") !== 4) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(\"john doe\", \"john\") !==\
  \ 1) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $pattern = preg_quote($substring, '/');\n    $count = preg_match_all('/'\
    \ . $pattern . '/i', $string, $matches);\n    return $count;\n}\n", "    if (strpos($string,\
    \ $substring) === false) {\n        return 0;\n    }\n\n    $count_substring =\
    \ 0;\n    $count_strpos = 0;\n    $string_length = strlen($string);\n    $substring_length\
    \ = strlen($substring);\n    for ($i = 0; $i < $string_length; $i++) {\n     \
    \   if ($string[$i] === $substring[$i]) {\n            $count_substring++;\n \
    \       } else {\n            if ($count_substring < $substring_length) {\n  \
    \              if ($count_strpos < $substring_length) {\n                    $count_strpos++;\n\
    \                }\n            } else {\n                $count_strpos = 1;\n\
    \            }\n            $count_substring = 1;\n        }\n    }\n    return\
    \ $count_substring;\n}\n</code>\n<|/ a tags=php,string |>\n<| c |>\nIf this answer\
    \ helped you, please mark it as an accepted answer by clicking on the check mark\
    \ beside it. Thanks.\n<|/ c |>\n<| c |>\nI tried to mark it as accepted but it\
    \ said that I need to have at least 15 reputation points to be able to do this.\n\
    <|/ c |>\n<| c |>\nThat's true. I've added my own answer with more code and explanation.\n\
    <|/ c |>\n<| a tags=php,string dscore=2 |>\nYou can use preg_match_all().\n<code>\n\
    $pattern = '@^[^ ]+( [^ ]+){' . $number_of_substrings_wanted . '}$@';\n$number_of_substrings_wanted\
    \ = $number_of_substrings_wanted + 1;\n\nif (preg_match_all($pattern, $string,\
    \ $matches, PREG_SET_ORDER)) {\n    // $matches[0] is all non-whitespace, non-matching\
    \ substrings\n    // $matches[$number_of_substrings_wanted] is all matching substrings\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,string dscore=2 |>\nThe most efficient way\
    \ would be to iterate over the string, keeping track of the current position inside\
    \ the string, and comparing it to the position in the last substring you've examined.\n\
    <|/ a |>\n<| a tags=php,string dscore=2 |>\n<code>\n$str = 'abc';\n$count = str_word_count($str,\
    \ 1);\n$count = ($count[0]==1 ? 0 : $count);\necho count($str) - $count; \n</code>\n\
    Output: 2\n<|/ a |>\n<| a |>\nThis works for me, even on partial matches.\n<code>",
  "    $matches = preg_match_all('/'.preg_quote($substring, '/').'/u', $string, $matches);\n\
    \n    return count($matches[0]);\n}\n</code>\n<|/ a tags=php,count,string-length\
    \ dscore=3 |>\n<| a tags=php,count,string-length dscore=3 |>\n<code>\n$string\
    \ = 'This is an example text';\n$length = strlen($string);\n", "  $counter = 0;\n\
    \  for ($i = 0; $i < strlen($string); $i++) {\n    if (stristr($string, $substring,\
    \ $i)) {\n      $counter++;\n      $i += strlen($substring);\n    }\n  }\n\n \
    \ return $counter;\n}\n</code>\n<|/ a dscore=2 tags=php,string |>\n<| a dscore=2\
    \ |>\nHere is another solution. Works faster than the above codes. \n<code>\n\
    $string=\"This is a test string that I am searching for. I am searching for this\
    \ text again and again.\";\n$substring=\"text again\";\n$result=strpos($string,$substring,$offset);\n\
    $occurrences = substr_count($string, $substring);\n</code>\n<|/ a tags=php,string\
    \ |>\n<| a |>\nYou can do it using a regex search, too\n<code>\n$string = 'foo\
    \ foo foo foo foo foobar foo foo foo foo foo';\n$findme   = 'foo';\n$pattern =\
    \ \"/$findme/\";\n\nif (preg_match_all($pattern, $string, $matches)) {\n  $findmes\
    \ = $matches[0];\n  echo count($findmes);\n}\n</code>\n<|/ a dscore=2 tags=php,string\
    \ |>\n<| a dscore=1 |>\nI personally prefer this way:\n<code>\n$searchString =\
    \ 'foo';\n$searchPattern = '/' . preg_quote($searchString) . '/i';\n$string =\
    \ 'foo foo foo foo foo foobar foo foo foo foo foo';\npreg_match_all($searchPattern,\
    \ $string, $matches);\n$occurrences = count($matches[0]);\necho $occurrences;\n\
    </code>\n<|/ a tags=php,string |>\n<| a tags=php,string |>\nI think it's better\
    \ to replace all occurrences of your string and get length\n<code>\n$string =\
    \ \"foo foo foo foo foo foobar foo foo foo foo foo\";\n$search = \"foo\";\n$replace_with\
    \ = \"\";\n$length = str_replace($search, $replace_with, $string);\necho $length;\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis only works if there is one occurrence\
    \ of \"foo\" in $string. If you had more than one \"foo\" in $string, this would\
    \ show 0.\n<|/ c |>\n<| a |>\n<code>\n<?php\n", "    $counts = array();\n    for($i=0;\
    \ $i<strlen($string); $i++){\n        $counts[$i] = 0;\n    }\n    for($i=0; $i<strlen($substring);\
    \ $i++){\n        $counts[$i] = 0;\n    }\n    $count = 0;\n    for($i=0; $i<strlen($string);\
    \ $i++){\n        if($string[$i] == $substring[$i]){\n            $counts[$i]\
    \ += 1;\n        } else {\n            $count = 0;\n            for($j=0; $j<$i;\
    \ $j++){\n                if($string[$j] == $substring[$j]){\n               \
    \     $counts[$j] += 1;\n                    if($counts[$j] == 2){\n         \
    \               $counts[$i] += 1;\n                        $count = $i+1;\n  \
    \                  }\n                } else {\n                    $count = 0;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}\n",
  "  $count = 0;\n  $length   = strlen($string);\n  while ($count < $length) {\n \
    \   $pos = strpos($string, $substring);\n    if ($pos !== FALSE) {\n      $count++;\n\
    \    }\n    $string .= substr($string, 0, $pos);\n  }\n  return $count;\n}", " \
    \   if ( ! strpos($string, $substring)) return 0;\n\n    $count = 1;\n    $position\
    \ = strpos($string, $substring);\n    while($position >= 0) {\n        $last =\
    \ $position;\n        $position = strpos($string, $substring, $position+1);\n\
    \        if ( $position === false ) {\n            return $count;\n        }\n\
    \        ++$count;\n    }\n\n    return $count;\n}\n</code>\n<|/ a tags=php,string\
    \ |>\n<| c |>\nAwesome, Thanks. But can you help me out with the coding part and\
    \ where should i put my file ? and what should i write in that  file ? can you\
    \ give me an example of what to do ? because i don't have any knowledge in coding.\n\
    <|/ c |>\n<| c |>\nI just wrote this code and test it but i didn't get any output\
    \ ? What did i do wrong ?\n<|/ c |>\n<| c |>\nThis code is only a fragment of\
    \ your code, you just have to copy paste it in a php file and run it. Just make\
    \ sure you copy the function declaration into the same file.\n<|/ c |>\n<| c |>\n\
    i just did that but still didn't get any output. Can you help me out what to do\
    \ to make it work ?\n<|/ c |>\n<| c |>\nThe code you wrote is okay, just make\
    \ sure you put all your code into one file and run it.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php\n\n$string = 'aaaaaaaaaa';\n$substring = 'aa';\n\n$count = str_word_count($string,\
    \ 1);\n\nif ($count >= strlen($substring))\n{\n    echo \" This string has the\
    \ substring at least once\";\n}\nelse\n{\n    echo \" This string doesn't contain\
    \ the substring\";\n}\n", "    $string_length = strlen($string);\n    $substring_length\
    \ = strlen($substring);\n\n    $count = 0;\n    for ($i = 0; $i < $string_length\
    \ && $i < $substring_length; $i++) {\n        if ($string[$i] === $substring[$i])\
    \ {\n            $count++;\n        }\n    }\n\n    return $count;\n}", "    $substrings\
    \ = explode($substring);\n    $count = 0;\n    foreach ($substrings as $substring)\
    \ {\n        if (strpos($string, $substring) !== false) {\n            $count++;\n\
    \        }\n    }\n\n    return $count;\n}\n", "    $occurrences = 0;\n    foreach\
    \ (str_split($string) as $char) {\n        if ($char == $substring) $occurrences++;\n\
    \    }\n    return $occurrences;\n}\n</code>\nThis way, you will get all occurrences\
    \ of $substring in $string. Also, you'll get all overlaps occurrences (as many\
    \ as you want)\n<|/ a |>\n<| c |>\nThis doesn't work as intended. `echo how_many_times('aaaa',\
    \ 'aa');` prints 0.\n<|/ c |>\n<| c |>\nYeah it works, but it prints 0 because\
    \ you're comparing a single character against multiple characters\n<|/ c |>\n\
    <| c |>\nIt was a typo. Sorry. It should be `$occurrences++` instead of `++$occurrences`\n\
    <|/ c |>\n<| c |>\nThis was very helpful, however, I needed to find a way to count\
    \ the number of times $substring occurred in $string without repeating the original\
    \ $string itself. Is that possible with this method?\n<|/ c |>\n<| a tags=php,string\
    \ |>\nI figured out how to count the amount of times substring occurred in $string\
    \ without repeating the original $string itself. \n<code>", "  $count = 0;\n \
    \ for ($i = 0; $i < strlen($string); $i++) {\n    if (strpos($string, $substring,\
    \ $i) !== false) {\n      $count++;\n    }\n  }\n  return $count;\n}\n", "   \
    \ // Count overlaping cases.\n    $count = 0;\n    // Loop over all characters\
    \ in the string.\n    for ($i = 0; $i < strlen($string); $i++) {\n        $count\
    \ += substr_count($string, $substring, $i);\n    }\n    return $count;\n}\n",
  "    $count = substr_count($string, $substring);\n    for ($i = 0; $i < $count;\
    \ $i++) {\n        $position = strpos($string, $substring, $i);\n        if ($position\
    \ === false) {\n            return $count;\n        }\n        if ($position ===\
    \ 0) {\n            return $i;\n        }\n        $i = $position + 1;\n    }\n\
    \    return $count;\n}\n", "    $counter = 0;\n    for($i = 0; $i < strlen($string);\
    \ $i++) {\n        if($string[$i] == $substring[0]) {\n            if($i < strlen($substring)\
    \ - 1) {\n                $counter++;\n                if($string[$i+1] == $substring[$i+1])\
    \ {\n                    $counter++;\n                }\n            }\n     \
    \   }\n    }\n    return $counter;\n}\n", "    $count = 0;\n    $pos = 0;\n  \
    \  while (true) {\n        if (strlen($string) >= $pos+strlen($substring)) {\n\
    \            $substring = substr($substring, 0, strlen($substring) - 1);\n   \
    \     }\n        if (strpos($string, $substring, $pos) !== false) {\n        \
    \    $count++;\n        }\n        if (strpos($string, $substring, $pos) === false)\
    \ {\n            break;\n        }\n        $pos++;\n    }\n    return $count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI used this simple function to\
    \ return how many occurrences of a string you have.\n<code>\n<?php\n\n$string\
    \ = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n$search = 'a';\n\n\
    $count = str_get_contents(str_ireplace($search, '*', $string));\necho $count;\n",
  "    $matches = [];\n    $count = preg_match_all('/' . $substring . '/', $string,\
    \ $matches);\n    return $count;\n}", "    $string_length = strlen($string);\n\
    \    $substring_length = strlen($substring);\n\n    $count = 0;\n    for ($i =\
    \ 0; $i < $string_length; $i++) {\n        for ($j = $i; $j < $string_length;\
    \ $j++) {\n            if ($string[$i] === $substring[$j]) {\n               \
    \ $count++;\n                break;\n            }\n        }\n    }\n\n    return\
    \ $count;\n}", "    $count = 0;\n    if (strlen($string) == 0) {\n        $count\
    \ = 1;\n    } else {\n        $string_length = strlen($string);\n        $substring_length\
    \ = strlen($substring);\n        for ($i = 0; $i < $string_length; $i++) {\n \
    \           if (substr($string, $i, $substring_length) == $substring) {\n    \
    \            $count++;\n            }\n        }\n    }\n    return $count;\n\
    }\n", "    // Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    if ( ! is_string($string) || ! is_string($substring))\n\
    \        return false;\n\n    if ($substring === '') return 0;\n\n    $count =\
    \ preg_match_all(\"/\" . preg_quote($substring) . \"/\", $string, $matches);\n\
    \n    return ($count + 1) * -1;\n}\n", "    // Return the number of times a string\
    \ appears within a given string.\n    // >>> how_many_times('', 'a')\n    // 0\n\
    \    // >>> how_many_times('aaa', 'a')\n    // 3\n    // >>> how_many_times('aaaa',\
    \ 'aa')\n    // 3\n    $count_a_times = 0;\n    $count_b_times = 0;\n    $count_c_times\
    \ = 0;\n    $count_d_times = 0;\n    $count_e_times = 0;\n    $count_f_times =\
    \ 0;\n    $count_g_times = 0;\n    $count_h_times = 0;\n    $count_i_times = 0;\n\
    \    $count_j_times = 0;\n    $count_k_times = 0;\n    $count_l_times = 0;\n \
    \   $count_m_times = 0;\n    $count_n_times = 0;\n    $count_o_times = 0;\n  \
    \  $count_p_times = 0;\n    $count_q_times = 0;\n    $count_r_times = 0;\n   \
    \ $count_s_times = 0;\n    $count_t_times = 0;\n    $count_u_times = 0;\n    $count_v_times\
    \ = 0;\n    $count_w_times = 0;\n    $count_x_times = 0;\n    $count_y_times =\
    \ 0;\n    $count_z_times = 0;\n\n    // Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    // >>> how_many_times('',\
    \ 'a')\n    // 0\n    // >>> how_many_times('aaa', 'a')\n    // 3\n    // >>>\
    \ how_many_times('aaaa', 'aa')\n    // 3\n\n    // Find how many times a given\
    \ substring can be found in the original string.\n    // Find how many times a\
    \ given substring can be found in the original string.\n    $string_length = strlen($string);\n\
    \    $substring_length = strlen($substring);\n    for($i = 0; $i < $string_length;\
    \ $i++) {\n        $string_char = substr($string, $i, 1);\n        $substring_char\
    \ = substr($substring, $i, 1);\n\n        // Make sure the substring's char is\
    \ the same as or smaller than the string's char.\n        if($substring_char <\
    \ $string_char) {\n            $count_l_times++;\n        } elseif($substring_char\
    \ == $string_char) {\n            $count_m_times++;\n        } elseif($substring_char\
    \ > $string_char) {\n            $count_n_times++;\n        } else {\n       \
    \     // Else, there exists an overlapping char in the substring with larger or\
    \ equal char in the string.\n            // Overlapping cases will be counted\
    \ later.\n        }\n    }\n\n    // Now we know how many times a given substring\
    \ can be found in the original string,\n    // and we know the string's and substring's\
    \ lengths.\n    // Subtract substring's length from string's length to get the\
    \ overlapping part.\n    // And add those overla", "  $counter = 0;\n  for ($i\
    \ = 0; $i < strlen($string); $i++) {\n    if (strpos($string, $substring, $i)\
    \ !== false) {\n      $counter++;\n    }\n  }\n  return $counter;\n}", "    $matches\
    \ = 0;\n    $pos = 0;\n    $len = strlen($substring);\n    while($pos < $len)\
    \ {\n        $pos = strpos($string, $substring, $pos);\n        if ($pos !== FALSE)\
    \ {\n            $matches++;\n            $pos++;\n        }\n    }\n    return\
    \ $matches;\n}", "    $substring_length = strlen($substring);\n    $count_array\
    \ = [];\n    $positions_array = [];\n\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        $char = $string[$i];\n        $count_array[$char]++;\n    \
    \    $positions_array[$char][] = $i;\n    }\n\n    $overlapping_chars = array_intersect($positions_array,\
    \ $count_array);\n    return count($overlapping_chars);\n}", "\t$matches = array_filter(\n\
    \t\texplode($substring, $string),\n\t\tfunction ($el) {\n\t\t\treturn $el !==\
    \ '';\n\t\t}\n\t);\n\treturn count($matches);\n}\n", "    if (strlen($string)\
    \ == 0) return 0;\n    if ($substring == '') return 1;\n    if ($substring[0]\
    \ != $string[0]) return 0;\n    return substr_count($string, $substring);\n}\n",
  "    $pos = 0;\n    $count = substr_count($string, $substring);\n    $substring_length\
    \ = strlen($substring);\n    $string_size = strlen($string);\n    while ($pos\
    \ < $string_size) {\n        // Find next occurence of the substring.\n      \
    \  $next_pos = $pos + $substring_length;\n        $next_pos = strpos($string,\
    \ $substring, $next_pos);\n        // Check if the next occurence is at the end\
    \ of the string, or the end of the substring.\n        if ($next_pos === false\
    \ || $next_pos > $string_size) {\n            // If we're at the end of the string,\
    \ add 1.\n            if ($next_pos === false) {\n                $count++;\n\
    \            }\n            // Otherwise, we're not at the end of the string.\
    \ Count overlaping cases.\n            else {\n                $count += $next_pos\
    \ - $pos;\n            }\n        }\n        // If we're at the end of the string,\
    \ add 1.\n        else {\n            $count++;\n        }\n        // Move to\
    \ next occurence.\n        $pos = $next_pos;\n    }\n    return $count;\n}\n</code>\n\
    <|/ a tags=php,algorithm,string |>\n<| c |>\nThis doesn't work. `'foo' => 'bar'`\
    \ comes back as `2` instead of `0`.\n<|/ c |>\n<| c |>\nThe OP says they want\
    \ to *count* the number of occurrences of *any* substring in *any* string. That's\
    \ what the OP wanted.\n<|/ c |>\n<| c |>\nThis works in that it counts the number\
    \ of occurrences of *any* substring in *any* string, but it's also case-sensitive,\
    \ so it will also give the wrong answer for, say, `'foo' => 'bar'`.\n<|/ c |>\n\
    <| c |>\nI realize this was two years ago, but I recently implemented this algorithm\
    \ for my use and wanted to post a link to my PHP implementation of this algorithm\
    \ (which I realize I may have not posted publicly here): https://github.com/plowskiy/string-counter-php\n\
    <|/ c |>\n<| a tags=php,algorithm,string |>\n<code>\n$haystack = 'This is a string\
    \ with multiple occurrences of the substring and I wonder how many times the substring\
    \ is repeated. I wonder how many times the substring is repeated in case this\
    \ string also contains another instance of the substring';\n$needle = 'substring';\n\
    \n$pos = strrpos($haystack, $needle);\necho $pos === false ? 0 : ($pos === strlen($haystack)\
    \ ? 1 : ($pos + strlen($", "    // Start by searching from the end of the given\
    \ string.\n    // If not found, continue searching from the start until we find\
    \ it.\n    // When found, count all overlapping occurrences.\n    $count = substr_count($string,\
    \ $substring);\n    \n    for ($i = strlen($string) - 1, $j = $i - 1; $i >= 0;\
    \ $i--, $j--) {\n        $substring1 = substr($string, $i, 1);\n        $substring2\
    \ = substr($string, $j, 1);\n        $string1 = $substring1;\n        $string2\
    \ = $substring2;\n        \n        if ($substring1 == $substring2) {\n      \
    \      // If the same letters were both found, count this as a single occurrence\n\
    \            // of the string.\n            $count++;\n            continue;\n\
    \        }\n        \n        if ($string1 == $substring2 || $string2 == $substring1)\
    \ {\n            // If the first letter of the substring matches the other letter\n\
    \            // or the second letter of the substring matches the other letter,\n\
    \            // count as a double occurrence\n            // of the string.\n\
    \            $count += 2;\n        }\n    }\n\n    return $count;\n}\n</code>\n\
    This code takes O(n log n) time, and O(n) space. It's O(n) time as we can do a\
    \ linear search, which is O(n).\n<|/ a |>\n<| a |>\nA very easy solution is as\
    \ follows.\n<code>", "    $times = 0;\n    $pos = 0;\n    while ($pos < strlen($string))\
    \ {\n        if (substr($string, $pos, strlen($substring)) === $substring) {\n\
    \            $times++;\n        }\n        $pos++;\n    }\n    return $times;\n\
    }\n", "    $found = preg_match_all('/' . preg_quote($substring, '/') . '/', $string,\
    \ $matches);\n    return $matches[0] ? $matches[0][0] : 0;\n}", "    $matches\
    \ = array();\n\n    // Loop through the original string and check each character\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        // If the character isn't\
    \ equal to the substring, add it to the matches\n        if ($string[$i] != $substring[0])\
    \ {\n            if ($i > 0 && $string[$i - 1] == $substring[0]) {\n         \
    \       $matches[] = $i;\n                $i--;\n            }\n            continue;\n\
    \        }\n        // If it's the first character of the substring\n        if\
    \ ($i == 0) {\n            // Check if there are any matches in subsequent characters\n\
    \            $found_match = false;\n            for ($j = 1; $j < count($substring);\
    \ $j++) {\n                // If the character matches the second character, add\
    \ it to the matches\n                if ($string[$i + $j] == $substring[$j]) {\n\
    \                    $matches[] = $i + $j;\n                    $found_match =\
    \ true;\n                    break;\n                }\n            }\n      \
    \      // If no match was found, add the character to the matches\n          \
    \  if (!$found_match) {\n                $matches[] = $i;\n            }\n   \
    \         continue;\n        }\n        // If it's the last character of the substring\n\
    \        if ($i == strlen($string) - 1) {\n            // Check if there are any\
    \ matches in prior characters\n            $found_match = false;\n           \
    \ for ($j = 1; $j < count($substring); $j++) {\n                // If the character\
    \ matches the second character, add it to the matches\n                if ($string[$i\
    \ - $j] == $substring[$j]) {\n                    $matches[] = $i - $j;\n    \
    \                $found_match = true;\n                    break;\n          \
    \      }\n            }\n            // If no match was found, add the character\
    \ to the matches\n            if (!$found_match) {\n                $matches[]\
    \ = $i;\n            }\n            continue;\n        }\n        // If the character\
    \ matches the first character in the substring\n        if ($string[$i] == $substring[0])\
    \ {\n            // Check if the rest of the string matches the substring\n  \
    \          $found_match = false;\n            for ($j = 1; $j < count($substring);\
    \ $j++) {\n                if ($string[$i + $j] == $substring[$j]) {\n       \
    \             $matches[] = $i + $j;\n                    $found_match = true;\n\
    \                    break;\n                }\n            }\n            //\
    \ If no match was found, add the character to the matches\n            if (!$found_match)\
    \ {\n                $matches[] = $i;\n            }\n        }\n    }\n    return\
    \ count($matches);\n}\n</code>\n<|/ a tags=php,string |>\n<| c |>\nThe regex is\
    \ awesome. Unfortunately it has a performance hit when used against large strings.\
    \ I tested this using 1000 iterations against a string of length 1 000 000.\n\
    <|/ c |>\n<| a |>\nAs far as I can tell this is what you're ", "    $count = 0;\n\
    \    $length = $string->length();\n    for ($i = 0; $i < $length; $i++) {\n  \
    \      for ($j = 0; $j < $substring->length(); $j++) {\n            if (substr($string,\
    \ $i, $substring->length()) === $substring) {\n                $count++;\n   \
    \             break;\n            }\n        }\n    }\n    return $count;\n}\n",
  "    $count = substr_count($string, $substring);\n    if ($count > 0) {\n      \
    \  $result = $count + 1;\n    } else {\n        $result = $count;\n    }\n   \
    \ return $result;\n}", "    $count = substr_count($string, $substring);\n    if\
    \ ($count == 0) return 0;\n    return ($count == 1) ? 1 : 0;\n}", "    $string_length\
    \ = strlen($string);\n    $substring_length = strlen($substring);\n    $count\
    \ = 0;\n    $position = 1;\n    for ($i = 0; $i < $string_length; $i++) {\n  \
    \      if ($string[$i] == $substring[$position]) {\n            $position++;\n\
    \            $count++;\n        }\n        else {\n            if ($position >\
    \ $substring_length) break;\n            $position = 1;\n            $count++;\n\
    \        }\n    }\n\n    return $count;\n}\n", "    $count = 0;\n    $len = strlen($string);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        if ($string[$i] == $substring[$i])\
    \ {\n            $count++;\n        }\n    }\n\n    return $count;\n}", "    if\
    \ ($substring == '' || $string == '') return 0;\n    $i = strpos($string, $substring);\n\
    \    if ($i == false) return 0;\n    if ($string[$i] == '?') return 1;\n    return\
    \ 1 + how_many_times($string, substr($string, 0, $i)) + ($string[$i] == $substring)\
    \ ? 1 : 0;\n}\n", "  $pos = 0;\n  $count = 0;\n  while ((false !== $pos = strpos($string,\
    \ $substring, $pos)) !== false) {\n    $count++;\n    $pos = $pos + strlen($substring);\n\
    \  }\n  return $count;\n}\n", "  $count = preg_match_all('/'.preg_quote($substring,\
    \ '/').'/i', $string, $matches);\n  return $count ? $count + 1 : 0; // Add 1 to\
    \ account for overlaping cases\n}\n", "    $count = 0;\n    if ($substring ==\
    \ '') {\n        return 0;\n    }\n    $length = strlen($string);\n    $pos =\
    \ 0;\n    while ($pos < $length) {\n        $pos = strpos($string, $substring,\
    \ $pos);\n        if ($pos === false) {\n            return 0;\n        }\n  \
    \      $count++;\n        $pos++;\n    }\n    return $count;\n}\n", "  if (empty($string)\
    \ || empty($substring)) {\n    return 0;\n  }\n\n  // If substring is not found\
    \ within string then there are no occurrences.\n  if (strpos($string, $substring)\
    \ === false) {\n    return 0;\n  }\n\n  // Find all occurrences of $substring\
    \ within string. Return count of overlapping cases.\n  $occurrences = array_count_values(preg_match_all('/'\
    \ . $substring . '/', $string));\n  $occurrences = array_filter($occurrences,\
    \ function($count) { return $count > 1; });\n  return count($occurrences);\n}",
  "    $matches = 0;\n    $position = 0;\n    $length = strlen($string);\n    while\
    \ ($position < $length) {\n        $position = strpos($string, $substring, $position);\n\
    \        if ($position === false) {\n            break;\n        }\n        $matches++;\n\
    \        $position++;\n    }\n    return $matches;\n}\n", "    return strpos($string,\
    \ $substring) / strlen($substring);\n}\n", "    $counter = 0;\n    $i = 0;\n \
    \   $string_length = strlen($string);\n    $substring_length = strlen($substring);\n\
    \    while ($i <= $string_length - $substring_length) {\n        // We have found\
    \ the substring, stop the loop\n        if ($string[$i] === $substring[$i]) {\n\
    \            $counter++;\n            $i++;\n            continue;\n        }\n\
    \        if ($string[$i] > $substring[$i]) {\n            // The substring was\
    \ longer. Just increase the counter and keep looking\n            $counter++;\n\
    \            continue;\n        }\n        // The substring was shorter. Go on\
    \ to test the next character\n        // and count the overlapping cases\n   \
    \     $i++;\n    }\n    return $counter;\n}\n", "  $length = strlen($string);\n\
    \  $position = 0;\n  while ($position < $length) {\n    $position = strpos($string,\
    \ $substring, $position);\n    if ($position === false) {\n      break;\n    }\n\
    \    $position++;\n  }\n  return $position;\n}\n\n$string = 'This is some text\
    \ -- with punctuation.';\n$sub_string = 'text';\n$position = how_many_times($string,\
    \ $sub_string);\n\necho '$string: '.$string.PHP_EOL;\necho '$sub_string: '.$sub_string.PHP_EOL;\n\
    echo '$position: '.$position.PHP_EOL;", "    $count = 0; // How many times the\
    \ substring has occurred.\n    $pos = stripos($string, $substring);\n    while\
    \ ($pos !== false) {\n        $count++; // Counts how many times this substring\
    \ has occurred.\n        $pos = stripos($string, $substring, $pos); // Find next\
    \ occurrence of the substring after the current position.\n    }\n    return $count;\n\
    }\n", "    $substr = str_split($substring);\n    return count(array_intersect($substr,\
    \ str_split($string)));\n}\n", "    return preg_match_all('/' . preg_quote($substring,\
    \ '/') . '/i', $string);\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is an interesting\
    \ alternative, however I feel it needs a little more explanation.\n<|/ c |>\n\
    <| c |>\nThis is an excellent answer, but I'm confused about what you mean by\
    \ \"Count overlaping cases\"\n<|/ c |>\n<| c |>\nI meant that overlapping substrings\
    \ in the original string will be counted as separate occurrences. In this particular\
    \ case, `how_many_times('aaaa', 'a')` will return `3`, because there are two 'a's\
    \ in the original string that are overlapping with 'aaa'. Hopefully this clarifies\
    \ my meaning.\n<|/ c |>\n<| c |>\nI see. So the purpose of this function is to\
    \ count the number of times the substring occurs in the given string, and not\
    \ the number of times the whole string occurs? The former would just be the length\
    \ of the substring + 1 and the latter would just be the length of the string?\n\
    <|/ c |>\n<| c |>\nYes, that is exactly what it does.\n<|/ c |>\n<| a dscore=3\
    \ tags=php,preg-match-all,regex |>\nYou can try this one:\n<code>\npreg_match_all('/(\\\
    w)\\1*/i', $string, $matches);\nprint_r($matches);\n</code>\nThis will count the\
    \ number of occurrences of any character repeated more than once in the string.\
    \ \nDemo\n<|/ a |>\n<| c |>\nWorks perfectly. Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ would be a great solution, but doesn't really answer the question as it doesn't\
    \ explain *why* the regex works, not just give the solution. Just a code dump\
    \ doesn't help someone who might be trying to understand what it is doing.\n<|/\
    \ c |>\n<| c |>\nThe solution by is very simple and understandable, and doesn't\
    \ need explanation at all. I'd suggest you read some documentation on regexes.\n\
    <|/ c |>\n<| a |>\n<code>\n$result = preg_match_all('/(.)\\1*/', \n    $string,\n\
    \    $matches);\n</code>\nThe above code works just fine.\n<|/ a tags=php,preg-match-all,regex\
    \ dscore=3 |>\n<| a dscore=3 |>\nI came here searching for a way to count the\
    \ number of matches of a repeated character inside a string. For example, the\
    \ word ", "    $string_length = strlen($string);\n    $substring_length = strlen($substring);\n\
    \    $count = 0;\n    for ($i = 0; $i < $string_length; $i++) {\n        if ($string[$i]\
    \ === $substring[0]) {\n            $count += 1;\n            if ($substring[$i\
    \ + 1] === $string[$i + 1]) {\n                $count += 1;\n                for\
    \ ($j = 1; $j < $substring_length; $j++) {\n                    if ($string[$i\
    \ + $j] !== $substring[$j]) {\n                        $count += 1;\n        \
    \                break;\n                    }\n                }\n          \
    \  }\n        }\n    }\n    return $count;\n}\n", "    $matches = preg_match_all('/'.$substring.'/u',\
    \ $string, $matches);\n    return $matches[0];\n}\n", "    // Make sure that the\
    \ strings are all equal in length\n    $string2 = trim($string);\n    $substring2\
    \ = trim($substring);\n    if (strlen($string2) < strlen($substring2)) {\n   \
    \     $substring = $substring2;\n    }\n    \n    $string2 = str_replace($substring,\
    \ '', $string);\n    return strlen($string2);\n}", "\t$length = 0;\n\n\tfor($i\
    \ = 0; $i <= strlen($string); $i++) {\n\t\tif($string[$i] == $substring[0]) {\n\
    \t\t\tif(strlen($string) - $i < strlen($substring)) {\n\t\t\t\t$length += how_many_times($string,\
    \ substr($string, $i + 1, strlen($substring) - $i));\n\t\t\t} else {\n\t\t\t\t\
    $length++;\n\t\t\t}\n\t\t} else {\n\t\t\t$length++;\n\t\t}\n\t}\n\n\treturn $length;\n\
    }", "    $pos = 0;\n    $count = 1;\n    while (($pos = strpos($string, $substring,\
    \ $pos)) !== false) {\n        $count++;\n        $pos += strlen($substring);\n\
    \    }\n    return $count;\n}\n", "    $count = 0;\n    if ($string == $substring)\
    \ {\n        $count++;\n    }\n    for ($i = 0; $i < strlen($string); $i++) {\n\
    \        if (strpos($string, $substring, $i) === false) {\n            $count\
    \ = 0;\n        }\n        else {\n            $count++;\n        }\n    }\n \
    \   return $count;\n}\n", "    $matches = 0;\n    $pos = 0;\n    while (true)\
    \ {\n        $pos = strpos($string, $substring, $pos);\n        if ($pos === false)\
    \ {\n            return $matches;\n        }\n        $matches++;\n        $pos++;\n\
    \    }\n}\n", "    $count = 0;\n    $str_length = strlen($string);\n    $substr_length\
    \ = strlen($substring);\n    for ($i = 0; $i < $str_length; $i++) {\n        for\
    \ ($j = 0; $j < $substr_length; $j++) {\n            if ($string[$i] === $substring[$j])\
    \ {\n                if ($i === 0) {\n                    if ($j === $substr_length\
    \ - 1) {\n                        $count++;\n                    } else {\n  \
    \                      for ($k = $j + 1; $k < $substr_length; $k++) {\n      \
    \                      if ($string[$i] === $substring[$k]) {\n               \
    \                 $count++;\n                                break;\n        \
    \                    }\n                        }\n                    }\n   \
    \             } else {\n                    if ($j === 0) {\n                \
    \        if ($i === $str_length - 1) {\n                            $count++;\n\
    \                        } else {\n                            for ($k = $i; $k\
    \ < $str_length; $k++) {\n                                if ($string[$i] ===\
    \ $substring[$k]) {\n                                    $count++;\n         \
    \                           break;\n                                }\n      \
    \                      }\n                        }\n                    } else\
    \ {\n                        if ($i === 0 && $j === 0) {\n                   \
    \         $count++;\n                        } else {\n                      \
    \      for ($k = $i; $k < $str_length; $k++) {\n                             \
    \   if ($string[$i] === $substring[$k]) {\n                                  \
    \  $count++;\n                                    $i = $k;\n                 \
    \                   break;\n                                }\n              \
    \              }\n                            for ($k = $j; $k < $substr_length;\
    \ $k++) {\n                                if ($string[$i] === $substring[$k])\
    \ {\n                                    $count++;\n                         \
    \           $j = $k;\n                                    break;\n           \
    \                     }\n                            }\n                     \
    \   }\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return $count;\n}", "    if (empty($string)) {\n        return 0;\n\
    \    }\n\n    return substr_count($string, $substring);\n}\n", "    $matches =\
    \ array_count_values(str_split($string));\n    return $matches[$substring];\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a tags=php,string dscore=2 |>\nThis is a bit\
    \ of a hack, but you can simply use explode() to get the number of times a string\
    \ is repeated within an array. This allows you to count the number of times a\
    \ substring is repeated within your string.\n<code>\n$string = 'aaaaabccccc';\n\
    $exploded = explode($string);\n$number_of_times = count($exploded);\n$number_of_times_string\
    \ = count(explode($string));\n\necho \"$number_of_times\";\necho \"$number_of_times_string\"\
    ;\n</code>\nThis should output 3 for both.\n<|/ a |>\n<| c |>\nThis will produce\
    \ incorrect results if you have a string like \"aaaaaaa\" and you count the length\
    \ of a string that begins with \"aaa\". It's not the fastest method but it is\
    \ a possible solution.\n<|/ c |>\n<| c |>\nTrue, that is why I said it was a bit\
    \ of a hack.\n<|/ c |>\n<| a tags=php,string dscore=1 |>\n<code>\n$str = \"aaaaabccccc\"\
    ;\n$count = preg_match_all('/a/', $str, $matches, PREG_OFFSET_CAPTURE);\n$count\
    \ = $matches[0][0][1];\n</code>\n<|/ a |>\n<| a |>\nHere's another answer I came\
    \ up with while I was looking for a better way to do this. It uses preg_match_all\
    \ to return an array of all matches in a string and array_count_values to count\
    \ the number of occurrences of each match and then finally array_slice to trim\
    \ off the array so the count isn't an issue:\n<code>\n$string = 'aaaaabccccc';\n\
    $count = preg_match_all('/a/', $string, $matches);\n$count = array_count_values($matches[0]);\n\
    $count = array_slice($count, 0, -1, true);\necho \"$count occurrences\";\n</code>\n\
    <|/ a tags=php,string dscore=1 |>\n<| a dscore=1 |>\n<code>\n$string = 'aaaaabccccc';\n\
    $count = str_word_count($string, 1);\necho $count[0];\n</code>\n<|/ a tags=php,string\
    \ |>\n<| a tags=php,string dscore=1 |>\n<code>\n$string = 'aaaaabccccc';\n$count\
    \ = preg_match_all('/a/', $string, $matches);\n$count = count($matches[0]);\n\
    echo $count;\n</code>\n<|/ a |>\n<| a tags=php,string dscore=0 |>\n<code>\n<?php\n\
    $", "    $occurrences = 0;\n    $length = strlen($substring);\n\n    $i = 0;\n\
    \    while($i <= $length) {\n        if (strpos($string, $substring, $i) === FALSE)\
    \ {\n            break;\n        }\n        $i++;\n        $occurrences++;\n \
    \   }\n\n    return $occurrences;\n}\n", "    return (strpos($string, $substring)\
    \ + strlen($substring) - strpos(strrev($string), strrev($substring))) / strlen($substring);\n\
    }", "    $string_length = strlen($string);\n    $substring_length = strlen($substring);\n\
    \    $count = 0;\n    // Start from the end of the string and continue until you\
    \ hit the beginning of the substring\n    // or reach the end.\n    for ($i =\
    \ $string_length - 1; $i >= 0; $i--) {\n        // Get the char at that position\n\
    \        $char = substr($string, $i, 1);\n        // Check each character in the\
    \ string and see if it matches\n        for ($j = 1; $j <= $substring_length;\
    \ $j++) {\n            $subchar = substr($substring, $j, 1);\n            // If\
    \ the two characters are not equal, move on.\n            if ($char != $subchar)\
    \ {\n                $i++;\n                break;\n            }\n          \
    \  // Otherwise, increment the count\n            $count++;\n        }\n    }\n\
    \    return $count;\n}\n</code>\n<|/ a tags=performance,php,algorithm dscore=0\
    \ |>\n<| c |>\nThat's not really what he wants. The issue is that he wants to\
    \ get two strings to compare in one pass, but he only wants one pass because he\
    \ cannot get both strings in one pass. This is because he cannot compare two strings\
    \ that differ by one character. For example, `how_many_times('aaaa', 'aa')` is\
    \ 3, but `how_many_times('aaa', 'a')` is 0. His requirement is to get both strings\
    \ in one pass, so he needs it to return 3 no matter which one of the two strings\
    \ is smaller.\n<|/ c |>\n<| c |>\nI edited my answer to address this, but it's\
    \ probably still not what he wants, because it's still not what he asked for.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution that should work.\
    \ It's a brute force solution, but I'm not sure how you could improve it by doing\
    \ fewer comparisons (if anything).\n<|/ c |>\n<| c |>\nIt should still be possible\
    \ to do fewer comparisons by comparing substring lengths first, but I'm not sure\
    \ how it would get you to a lower complexity than just using nested loops.\n<|/\
    \ c |>\n<| c |>\nIt still has the overhead of many calls to `substr()`. That's\
    \ why the OP would like to get both strings in one pass.\n<|/ c |>\n<| a dscore=0\
    \ tags=performance,php,algorithm |>\n<code>", "    if (strlen($string) <= $substring)\
    \ {\n        return 0;\n    }\n\n    $i = 0;\n    $j = 0;\n    while ($i < strlen($string)\
    \ && $j < strlen($substring)) {\n        if ($string[$i] === $substring[$j]) {\n\
    \            $i++;\n            $j++;\n            continue;\n        }\n\n  \
    \      // Count overlapping characters.\n        $overlapping = how_many_times($string,\
    \ substr($string, $i, $j));\n\n        // Count overlapping substrings\n     \
    \   $overlap = how_many_times($substring, substr($string, $i, $j));\n\n      \
    \  // Count overlapping chars (count overlap first and then substring count).\n\
    \        // e.g. \"aaaa\" overlaps \"aa\" 3 times, or \"aaaa\" overlaps \"a\"\
    \ 3 times, or \"aaaa\" overlaps \"a\" 3 times.\n        $overlapped_length = $overlapping\
    \ + $overlap;\n        if ($overlapped_length > $j) {\n            $j = $overlapped_length;\n\
    \        }\n\n        $i++;\n        $j++;\n    }\n\n    return $j;\n}\n", " \
    \   $count = 0; $pos = 0;\n    $str_length = strlen($string);\n\n    while ($pos\
    \ < $str_length) {\n        $pos = strpos($string, $substring, $pos+1);\n    \
    \    if ($pos === false) {\n            return $count;\n        }\n        $count++;\n\
    \    }\n    return $count;\n}\n", "    $start = 0;\n    $count = 0;\n    while\
    \ (true) {\n        $start = strpos($string, $substring, $start);\n        if\
    \ ($start === false) {\n            break;\n        }\n        $count++;\n   \
    \     $start++;\n    }\n    return $count;\n}", "  $string = strtolower($string);\n\
    \  $substring = strtolower($substring);\n  $i = 0;\n  while ($i < strlen($string))\
    \ {\n    if (strpos($string, $substring, $i) !== false) {\n      $i++;\n    }\n\
    \    $i++;\n  }\n  return $i;\n}\n", "    return substr_count($string, $substring);\n\
    }", "    return substr_count($string, $substring);\n}\n", "    $n = 0;\n    $pos\
    \ = strpos($string, $substring);\n    while ($pos !== false) {\n        $n++;\n\
    \        $pos = strpos($string, $substring, $pos+1);\n    }\n    return $n;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=php,preg-match |>\n<code>\n<?php\n$string\
    \ = 'This is a test of the preg_match function.';\n$pattern = '/^[a-z]+$/';\n\
    if(preg_match($pattern, $string)) {\n    $matches = 0;\n} else {\n    $matches\
    \ = 1;\n}\necho $matches;", "    $count = preg_match_all(\"/$substring/\", $string,\
    \ $matches);\n    if ($count == 0) {\n        return 0; // no match at all\n \
    \   }\n    if ($count == -1) {\n        return -1; // no matches\n    }\n    $total_count\
    \ = count($matches[0]);\n    return $total_count; // return the total count (non-overlapping\
    \ matches only)\n}\n", "    $matches = array();\n\n    // If the string is a zero\
    \ length, return 0\n    if (strlen($string) === 0) {\n        return 0;\n    }\n\
    \n    // If the string is a single character then return 1\n    if (strlen($string)\
    \ === 1) {\n        return 1;\n    }\n\n    // If the string starts with an empty\
    \ string then return 0\n    if ($string[0] !== '' && !preg_match('/[^A-Za-z0-9-]/',\
    \ $string)) {\n        return 0;\n    }\n\n    // If $substring is empty then\
    \ return 0\n    if (strlen($substring) === 0) {\n        return 0;\n    }\n\n\
    \    $length = strlen($substring);\n\n    // Initialize an array to store counts\
    \ of each letter in the $string\n    $counts = str_split($string);\n    $counts\
    \ = array_count_values($counts);\n\n    // Sort the array by descending order\
    \ of counts\n    arsort($counts);\n\n    // Find the first element in the $counts\
    \ array that doesn't match the $substring\n    for ($i = 0; $i < $length; $i++)\
    \ {\n        // $count is the number of times the current letter matches the $substring\n\
    \        $count = $counts[$substring[$i]];\n        // $index stores the index\
    \ in the $counts array of the current letter\n        $index = array_search($substring[$i],\
    \ $counts);\n        // If the current letter matches and the current count doesn't\
    \ match the $substring or the index is greater than 0, then add the current letter\
    \ and the current count to the $matches array\n        if ($substring[$i] ===\
    \ $counts[$substring[$i]] && ($count > 0 || ($index > 0))) {\n            $matches[]\
    \ = $substring[$i];\n        }\n    }\n\n    return count($matches);\n}\n</code>\n\
    <|/ a tags=php,regex |>\n<| a tags=php,regex dscore=0 |>\nThis doesn't handle\
    \ multiple instances of $substring in $string but you can do that with a simple\
    \ array_filter\n<code>\n<?php\n$string = 'This is an example';\n$substring = 'is';\n\
    \n$matches = array_filter($string, function($v) {\n    return strpos($v, $substring)\
    \ !== false;\n});\n\nprint_r($matches);\n</code>\nhttps://3v4l.org/S2GjF\n<|/\
    \ a |>\n<| a |>\nI used this regex to find how many times $substring occurs in\
    \ $string.\n<code>\n$string = \"The red fox jumped over the red fox\";\n$substring\
    \ = \"fox\";\n$pattern = '/('.$substring.')/i';\n$matches = array();\n\npreg_match($pattern,\
    \ $string, $matches);\necho count($matches);\n</code>\n<|/ a tags=php,", "   \
    \ return substr_count($string, $substring);\n}\n", "    $count = substr_count($string,\
    \ $substring);\n    return $count + substr_count($string, strtolower($substring));\n\
    }", "  // $string must be non-empty\n  if (strlen($string) == 0) {\n    return\
    \ 0;\n  }\n\n  // $substring must be non-empty\n  if (strlen($substring) == 0)\
    \ {\n    return strlen($string);\n  }\n\n  $count = 0;\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    if (strcasecmp($string, $substring) == 0) {\n      $count++;\n\
    \    }\n\n    // Keep incrementing for the next substring, until we find the one\
    \ we want\n    if (strcasecmp($string, substr($string, $i, strlen($substring)))\
    \ == 0) {\n      $count++;\n    }\n\n    // If the final substring is too long,\
    \ then break\n    if (strlen($string) - $i >= strlen($substring) - 1) {\n    \
    \  break;\n    }\n  }\n\n  return $count;\n}\n</code>\n<|/ a dscore=0 tags=string,php,count\
    \ |>\n<| a dscore=0 |>\nI have the same question and I found a solution by myself.\
    \ I am sharing my code here hope it helps someone else.\n<code>", "    return\
    \ strspn($string, $substring);\n}\n", "    $count = preg_match_all('~'.preg_quote($substring).'~i',\
    \ $string, $matches);\n    return $count;\n}", "    $found = strpos($string, $substring);\n\
    \    if($found === false) {\n        $found = 0;\n    }\n    return $found;\n\
    }\n", "    $count = 0;\n    $l = mb_strlen($string);\n    $sub = mb_strlen($substring);\n\
    \    for ($i = 0; $i < $l; $i++) {\n        $char = $string[$i];\n        if ($char\
    \ === $substring[$sub]) {\n            $count++;\n        } else {\n         \
    \   if ($char === $substring[($i - 1)]) {\n                $count++;\n       \
    \     } else {\n                if ($char === $substring[($i + 1)]) {\n      \
    \              $count++;\n                }\n            }\n        }\n    }\n\
    \    return $count;\n}", "    return substr_count($string, $substring);\n}\n",
  "    $count = substr_count($string, $substring);\n    return ($count > 0) ? $count\
    \ : 0;\n}\n", "    $overlap = 0;\n    $sublength = strlen($substring);\n    for\
    \ ($i = 0; $i < $sublength; $i++) {\n        if (strpos($string, $substring, $i)\
    \ !== false) {\n            $overlap++;\n            $i += $sublength;\n     \
    \   } else {\n            break;\n        }\n    }\n    return $overlap;\n}\n",
  "  $search = array_flip(str_split($substring));\n  return count(array_intersect(str_split($string),\
    \ $search));\n}\n", "  return (strtolower($substring) === strtolower($string))\
    \ ? 1 : strtotime($string) - strtotime($substring);\n}\n", "    return (strpos($string,\
    \ $substring) + strlen($substring) - strpos($string, $string[$len = strlen($string)-1],\
    \ $substring));\n}\n", "    $pos = strpos($string, $substring);\n    if ($pos\
    \ === false) {\n        return 0;\n    }\n    return 1 + how_many_times($string,\
    \ substr($string, $pos + strlen($substring)));\n}", "    $count = 0; // Number\
    \ of times $substring occurs in the string.\n    $len = strlen($substring); //\
    \ Length of $substring.\n    $pos = 0; // The position of the first character\
    \ of the substring in the string.\n    do {\n        $pos = strpos($string, $substring,\
    \ $pos); // Find the next occurrence of $substring in $string.\n        $count++;\
    \ // Increment the number of times $substring occurs.\n    } while ($pos > 0);\
    \ // Loop until there are no more occurrences of $substring in $string.\n    return\
    \ $count; // Return the number of times the $substring occurs.\n}", "\t$count\
    \ = 0;\n\t$len = strlen($substring);\n\t$i = 0;\n\twhile (($pos = strpos($string,\
    \ $substring, $i)) !== FALSE) {\n\t\t$count++;\n\t\t$i = $pos + $len;\n\t}\n\t\
    return $count;\n}\n", "    // Use regex to find each substring individually\n\
    \    // See https://stackoverflow.com/questions/6175417/php-count-how-many-times-a-substring-occurs-in-a-string\n\
    \    $matches = preg_match_all('/' . preg_quote($substring, '/') . '/', $string,\
    \ $matches);\n\n    // Add one if $substring found the string at least once\n\
    \    return $matches ? $matches[0] + 1 : 0;\n}", "    return substr_count($string,\
    \ $substring);\n}\n", "    $count = 0;\n    $str = strlen($string);\n    $substr\
    \ = strlen($substring);\n    $start = 0;\n    $end = 0;\n\n    while (($end <=\
    \ $str) && ($substr <= $str)) {\n        if ($string[$end] == $substring[$substr])\
    \ {\n            $count++;\n        }\n        $end++;\n        $substr++;\n \
    \   }\n\n    return $count;\n}", "    $substring = (string)$substring;\n    $count\
    \ = (string)substr_count($string, $substring);\n    $count_array = [];\n    for\
    \ ($i = 0; $i < $count; $i++) {\n        $count_array[] = $i;\n    }\n    sort($count_array);\n\
    \    $count = 0;\n    for ($i = 0; $i < $count; $i++) {\n        if ($count_array[$i]\
    \ == $substring) {\n            $count += $i;\n        }\n    }\n    return $count;\n\
    }\n", "    $start = 0;\n    $end = strlen($string);\n    $count = 0;\n\n    while\
    \ ($start <= $end) {\n        $mid = floor(($start + $end) / 2);\n\n        if\
    \ ($mid > $end || $mid < $start) {\n            $end = $mid;\n        } else {\n\
    \            if (strpos($string, $substring, $mid) === false) {\n            \
    \    $count++;\n                $end = $mid;\n            } else {\n         \
    \       $start = min($mid + 1, $end);\n            }\n        }\n    }\n\n   \
    \ return $count;\n}", "  $matches = array_count_values(str_split($string));\n\
    \  return isset($matches[$substring]) ? $matches[$substring] : 0;\n}\n</code>\n\
    <|/ a tags=string,php,count |>\n<| c |>\nThis also only works for *equal* strings.\
    \ If you had `'aab'`, then you'd get back 1, which is incorrect.\n<|/ c |>\n<|\
    \ c |>\n: It doesn't matter whether you search for `'aab'` or `'a'`, because the\
    \ `count` function only counts overlapping matches. `'a'` is counted exactly once,\
    \ `'aab'` is counted twice, because `'a'` is found twice.\n<|/ c |>\n<| a |>\n\
    <code>\n$string = \"the quick brown fox jumps over the lazy dog\";\n$pos = strpos($string,\
    \ 'brown');\necho substr($string, $pos+5);\n</code>\n<|/ a dscore=5 tags=string,php,count\
    \ |>\n<| c |>\nThis doesn't account for the possibility of overlapping strings\
    \ and only works for 'brown'\n<|/ c |>\n<| a tags=string,php,count |>\n<code>\n\
    $str = \"the quick brown fox jumps over the lazy dog\";\n$count = substr_count($str,\
    \ 'brown');\necho $count;\n</code>\n<|/ a dscore=4 |>\n<| c |>\nDoesn't work.\
    \ Returns 4. I need it to return 3\n<|/ c |>\n<| c |>\nYes it doesn't, because\
    \ 'brown' is overlapping.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n$str = 'The quick\
    \ brown fox jumped over the lazy dog';\n$pos = strpos($str,'fox');\necho substr_count((string)$str,(string)$str[$pos+1]);\n\
    </code>\n<|/ a tags=string,php,count |>\n<| c |>\nThis is very slow for large\
    \ strings.\n<|/ c |>\n<| c |>\nstrpos() returns false when the needle is found\
    \ at an end of a string and that is a very common situation if you use it in loops.\n\
    <|/ c |>\n<| c |>\nThanks. I just changed the strpos()\n<|/ c |>\n<| a dscore=3\
    \ tags=string,php,count |>\n<code>\n$string = 'The quick brown fox jumped over\
    \ the lazy dog';\necho substr_count($string, 'fox');\n</code>\n<|/ a |>\n", " \
    \   $count = 0;\n    $pos = 0;\n    do {\n        $pos = strpos($string, $substring,\
    \ $pos);\n        $count++;\n    } while ($pos > 0);\n    return $count;\n}\n",
  "    $count = substr_count($string, $substring);\n    if ($count == 0) {\n     \
    \   $count = 0;\n    }\n    return $count;\n}", "  $count_occurrences = 0;\n \
    \ $pos = strpos($string, $substring);\n  while ($pos > -1) {\n    $count_occurrences++;\n\
    \    $pos = strpos($string, $substring, $pos + 1);\n  }\n  return $count_occurrences;\n\
    }\n</code>\n<|/ a tags=php,string,preg-match,regex dscore=5 |>\n<| c |>\nAwesome\
    \ function and good explanation, but I think your $count_occurrences should be\
    \ $count_chars, since you're counting occurrences not chars.\n<|/ c |>\n<| c |>\n\
    , good catch. That's a typo indeed. Thanks.\n<|/ c |>\n<| c |>\n: You are right.\
    \ I missed that substring can occur in the beginning of the string.\n<|/ c |>\n\
    <| c |>\nThe only issue I see is that it seems to not work with an array-type\
    \ input. Which could be fixed by using the `foreach` loop for an array instead\
    \ of `while`. But I like your answer because its so concise and easy to read.\
    \ :)\n<|/ c |>\n<| c |>\nThe only issue is that it will not find the first occurrence\
    \ of a character. For example, if `$string = \"abcd\";` and you run the function,\
    \ it will return 2 instead of 1.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npreg_match_all('/(.)a(.)/',\
    \ $string, $matches);\n$count_occurrences = $matches[1];\n</code>\nThis finds\
    \ all the characters in a given string that occur in the same position and returns\
    \ the count.\n<|/ a tags=php,string,preg-match,regex |>\n<| c |>\nThis is the\
    \ best solution I've seen, though it's a little more complicated than what I've\
    \ seen elsewhere, so maybe it could be a little more explicit about it. I'm not\
    \ a PHP person, so I'm not sure how it works, but it seems that `preg_match_all()`\
    \ returns a list of matches, which each match is an array containing the matches\
    \ in order, so then `$matches[1]` would be the list of characters matched. From\
    \ the PHP documentation (http://www.php.net/preg_match_all): `preg_match_all \u2014\
    \ Perform a global regular expression match`\n<|/ c |>\n<| c |>\nYeah, that would\
    \ be how it would be written in PHP.\n<|/ c |>\n<| c |>\nI don't think this is\
    \ going to work. It would only return count of first occurrence of character.\
    \ e.g. `preg_match_all('/(.)a(.)/', 'aabc', $matches); $count_occurrences = $matches[1];`\
    \ will result in `$count_", "  $pos = strpos($string, $substring);\n  return $pos\
    \ === false ? 0 : (strlen($substring) - $pos);\n}", "    $count = 0;\n    $pos\
    \ = 0;\n    while (($pos = strpos($string, $substring, $pos)) !== FALSE) {\n \
    \       $count++;\n        $pos = $pos + 1;\n    }\n    return $count;\n}\n",
  "    // Remove duplicate occurrences of $substring\n    $string = preg_replace(\"\
    |$substring|\", \"\", $string);\n\n    // Return the number of times the substring\
    \ was found in the string\n    return substr_count($string, $substring);\n}\n\
    </code>\n<|/ a tags=string,php,count dscore=2 |>\n<| c |>\nYes, you are right.\
    \ I missed that case when one of the occurrences is a substring. I've updated\
    \ my answer\n<|/ c |>\n<| c |>\nThanks man you saved my day :)\n<|/ c |>\n<| a\
    \ dscore=0 |>\nYou could use a regular expression which allows lookahead/lookbehind\
    \ and count the number of occurrences in it.\n<code>\n$input = 'aaaaaba';\n$re\
    \ = '/^(?=a)a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a",
  "  $pos = strpos($string, $substring);\n  if ($pos === false) {\n    return 0;\n\
    \  }\n  return substr_count($string, $substring, $pos);\n}\n", "    $count = 0;\
    \ // start at 0 of how many times the substring occurs in the string\n    $length\
    \ = strlen($substring); // length of the string\n    $i = 0; // starting point\
    \ for the loop\n    while ($i < $length) {\n        if ($string[$i] == $substring[0])\
    \ { // if $string[$i] matches $substring[0]\n            if ($string[$i + 1] ==\
    \ $substring[0]) { // if $string[$i + 1] matches $substring[0]\n             \
    \   $count++; // if so, increment the counter\n                $i++; // move to\
    \ $i + 1 character in the string\n            } else {\n                $count++;\
    \ // if not, increment the counter\n                $i++; // move to $i + 1 character\
    \ in the string\n            }\n        } else {\n            $i++; // move to\
    \ $i + 1 character in the string\n        }\n    }\n    return $count;\n}\n",
  "    $matches = array();\n    if ($string=='') {\n        return 0;\n    }\n   \
    \ for ($i=0; $i<strlen($substring); $i++) {\n        $matches[$i] = substr_count($string,\
    \ $substring);\n    }\n    asort($matches);\n    return $matches[0];\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis code fails on `'ababa'` (returns 1), when the correct\
    \ answer is 3 (`abababa`).\n<|/ c |>\n<| c |>\nThis was fixed before you commented.\n\
    <|/ c |>\n<| c |>\nOops! My bad. Looking at it again, I was thinking of `how_many_times`\
    \ as a way to find the number of times a substring appears in another string.\
    \ I'm sure you're right in general. +1!\n<|/ c |>\n<| c |>\nThank you! This was\
    \ a great example for me to see how this works so quickly.\n<|/ c |>\n<| a tags=php,string,algorithm\
    \ dscore=5 |>\nThis is my solution, hopefully it's fast enough:\n<code>", "  \
    \  $i = 0;\n    $n = strlen($string);\n    $m = strlen($substring);\n    \n  \
    \  for($j = 0; $j < $m; $j++) {\n        $s = substr($string, $j, $m);\n     \
    \   if($s == $substring) $i++;\n    }\n    return $i;\n}\n", "    $counter = 0;\n\
    \    foreach (explode($substring, $string) as $sub_str) {\n        if ($sub_str\
    \ === '') continue;\n        $counter += substr_count($string, $sub_str);\n  \
    \  }\n    return $counter;\n}\n", "    // https://gist.github.com/jrmyleswhite/812801\n\
    \    $counts = array();\n    $length = 0;\n    foreach ($string as $c) {\n   \
    \     $length++;\n        if ($c === $substring) {\n            $counts[] = $length;\n\
    \        }\n        $counts[] = $length;\n    }\n    return $counts[0];\n}\n",
  "  return strpos($string, $substring) / strlen($substring);\n}", "    $counter =\
    \ 0;\n    // Easy case: substring equals entire string\n    if ($string == $substring)\
    \ {\n        return 1;\n    }\n    // Find the beginning and ending indexes of\
    \ the first and last instances of the substring.\n    $first_occurrence = strpos($string,\
    \ $substring);\n    $last_occurrence = strpos($string, $substring, $first_occurrence\
    \ + strlen($substring));\n    // Iterate through the original string and increment\
    \ the count for each instance.\n    for ($i = 0; $i < strlen($string); $i++) {\n\
    \        if ($i == $first_occurrence || $i == $last_occurrence) {\n          \
    \  $counter++;\n        }\n    }\n    return $counter;\n}\n", "    $found = array();\n\
    \    $substring = (string)$substring;\n    $string = (string)$string;\n    $n\
    \ = strlen($string);\n    for($i=0; $i < $n; $i++) {\n        $current_letter\
    \ = $string[$i];\n        for($j=0; $j < $n; $j++) {\n            if($j == $i)\
    \ {\n                continue;\n            }\n            $next_letter = $string[$j];\n\
    \            if($current_letter != $next_letter) {\n                $found[$j]\
    \ += 1;\n            }\n        }\n    }\n    $found = array_count_values($found);\n\
    \    arsort($found);\n    return key($found);\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThis is good. Though it doesn't answer the original question very well,\
    \ as it requires multiple passes to complete the search. Perhaps you could amend\
    \ your answer with some notes about the algorithm you suggest?\n<|/ c |>\n<| c\
    \ |>\nYes, I agree. It was an interesting question, though, and I thought I'd\
    \ share my solution. Not that I didn't think about it before, but this answer\
    \ was a big step for me. Thanks!\n<|/ c |>\n<| c |>\nHi Daniel, thanks a lot for\
    \ sharing your solution. I don't think my problem is related to this question\
    \ anymore, though as I'm still a student so I'm not able to mark it as the answer.\
    \ Do you have any idea how to mark the question as solved though? Thanks again!\n\
    <|/ c |>\n<| c |>\nI guess I couldnt find the exact link so I made a [photo](http://i.imgur.com/uxqWVkO.jpg)\
    \ with the question and answer. Maybe you can find it there :)\n<|/ c |>\n<| c\
    \ |>\nWow, thanks a lot for the photo, Daniel. I really appreciate it.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nThe algorithm you suggest would count the occurrences\
    \ of each letter in the word.  I presume you want to count the total occurrences\
    \ of each letter in the input string.  Here is an algorithm that should work.\
    \  (I didn't run it, so it might have typos.  If there are typos, I apologize.)\n\
    <code>\ndef how_many_times(string, substring):\n    substring = substring #cast\
    \ substring to string\n    string = string #cast string to string\n    count_dict\
    \ = dict()\n    for letter in string:\n        if letter in substring:\n     \
    \       count_dict[letter] = count_dict.get(letter, 0) + 1", "  // We need to\
    \ make sure we don't return zero, so we need to create a temp array and remove\
    \ empty values\n  // We also need to make sure we remove cases which appear only\
    \ once\n  // We need to make sure we remove overlapping cases\n  $tmp_array =\
    \ array();\n  foreach (preg_split(\"/([a-z])/i\", $string) as $char) {\n    if\
    \ (array_search($char, $tmp_array) == false) {\n      $tmp_array[] = $char;\n\
    \    }\n  }\n  return count(array_unique($tmp_array));\n}\n", "    $count = 0;\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        if (strpos($string, $substring,\
    \ $i) !== false) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    $count = 0;\n    $i = 0;\n    while (isset($string[$i]) && strpos($string,\
    \ $substring, $i) !== FALSE) {\n        $i++;\n        $count++;\n    }\n    return\
    \ $count;\n}\n", "    $count = 0;\n    $pos = strpos($string, $substring);\n\n\
    \    while ($pos !== false) {\n        $count++;\n        $pos = strpos($string,\
    \ $substring, $pos + 1);\n    }\n\n    return $count;\n}\n\n$input = \"aa aa bb\
    \ bb bb cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\
    \ cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc c", "  $positions\
    \ = preg_grep('/' . $substring .'/i', $string);\n  if (count($positions) > 0)\
    \ {\n    return count($positions);\n  }\n  return 0;\n}", "\t$pos = strpos($string,\
    \ $substring);\n\t$counter = 0;\n\twhile ($pos !== false) {\n\t\t++$counter;\n\
    \t\t$pos = strpos($string, $substring, $pos);\n\t}\n\treturn $counter;\n}\n",
  "    return substr_count($string, $substring);\n}\n</code>\n<|/ a tags=php,algorithm,string\
    \ |>\n<| a dscore=2 |>\n<code>\n<?php", "    if ($substring == '')\n        return\
    \ 0;\n    if ($string == '')\n        return 0;\n    $count = 0;\n    for ($i\
    \ = 0, $len = strlen($string); $i < $len; $i++) {\n        $current_letter = $string[$i];\n\
    \        for ($j = 0, $len2 = strlen($substring); $j < $len2; $j++) {\n      \
    \      $substr_letter = $substring[$j];\n            if ($current_letter === $substr_letter)\
    \ {\n                $count++;\n                continue;\n            }\n   \
    \         if ($current_letter <= $substr_letter) {\n                break;\n \
    \           }\n        }\n    }\n    return $count;\n}\n", "\t$matches = 0;\n\t\
    $len = strlen($string);\n\tfor ($i = 0; $i < $len; $i++) {\n\t\tif (strpos($string,\
    \ $substring, $i) === false) {\n\t\t\t$i++;\n\t\t\tbreak;\n\t\t}\n\t\t$matches++;\n\
    \t}\n\treturn $matches;\n}\n", "    return substr_count($string, $substring);\n\
    }\n", "    // If string empty or substring empty, or substring is empty itself\n\
    \    if (!$string || !$substring || $substring == '')\n        return 0;\n\n \
    \   // Initialize search variables\n    $search_start = 0;\n    $search_end =\
    \ 0;\n\n    // Begin searching\n    while ($search_start < strlen($string)) {\n\
    \        $search_start = strpos($string, $substring, $search_start);\n\n     \
    \   if ($search_start === false) {\n            return 0;\n        }\n\n     \
    \   // End searching\n        if ($search_start < $search_end) {\n           \
    \ $search_end += strlen($substring);\n        }\n        else {\n            $search_end\
    \ = strlen($string);\n        }\n    }\n\n    // Found it\n    return $search_end\
    \ - $search_start;\n}\n", "    $count = substr_count($string, $substring);\n \
    \   for ($i = 0; $i < $count; $i++) {\n        $substring_length = strlen($substring);\n\
    \        if ($i < $count - $substring_length) {\n            $string .= $substring;\n\
    \            $string[strlen($string)-1] = '';\n        }\n        else {\n   \
    \         $string .= substr($string, 0, strlen($string) - $substring_length);\n\
    \        }\n        $count += substr_count($string, $substring);\n    }\n    return\
    \ $count;\n}", "    $count_array = array();\n    // Start from index 0, then go\
    \ backwards, looking for the first index where the substring is different\n  \
    \  // from the previous substring\n    $start_index = 0;\n    for ($i = $start_index;\
    \ $i >= 0; $i--) {\n        // If we reached the beginning of the string, then\
    \ the substring was found at the end of the string\n        if ($i >= strlen($string))\
    \ {\n            $count_array[$i] = 1;\n            break;\n        }\n      \
    \  // If we reached the beginning of the string, or the previous substring was\
    \ different\n        // from the current string, then this is not a matching substring\
    \ and the count is 0\n        if (!($i >= $start_index) && ($string[$i] != $substring[$i]))\
    \ {\n            $count_array[$i] = 0;\n        } else {\n            // Otherwise,\
    \ check whether we have already found a substring that matches this position\n\
    \            $count_array[$i] = isset($count_array[$i + 1]) ? $count_array[$i\
    \ + 1] : 1;\n        }\n    }\n\n    return $count_array;\n}\n</code>\n<|/ a dscore=1\
    \ tags=algorithm,php,performance,search |>\n<| c |>\nIf your string is over 100k\
    \ characters long, this algorithm will take forever to finish (in my experience).\n\
    <|/ c |>\n<| c |>\n: I'm with you that PHP is slow in such operations. But I did\
    \ a benchmark and found that it is indeed the fastest possible algorithm for searching\
    \ for two substrings in PHP. Try it [here](http://pastebin.com/g5i7X8wq).\n<|/\
    \ c |>\n<| c |>\nThe only thing that I can think of is that your `strpos` is doing\
    \ something else besides just testing the characters in each position. I'm really\
    \ not sure. You'd have to look at the PHP source to see what's going on under\
    \ the covers.\n<|/ c |>\n<| c |>\nHmm, maybe you are right actually. Even though\
    \ if I change this line `$count_array[$i] = isset($count_array[$i + 1]) ? $count_array[$i\
    \ + 1] : 1;` to `$count_array[$i] = isset($count_array[$i]) ? $count_array[$i]\
    \ : 1;` it runs in about 20 ms for me. I've also just found another benchmark\
    \ here: http://pastebin.com/MfK5jVYN\n<|/ c |>\n<| c |>\n: Oops, I forgot about\
    \ that optimization. I've updated my answer to include it.\n<|/ c |>\n<| a tags=algorithm,php,performance,search\
    \ dscore=1 |>\n<code>\n/**\n * ", "  // Initialize variables.\n  $number_of_matches\
    \ = 0;\n  $previous_character = '';\n  $number_of_substrings = 0;\n  $number_of_same_letters\
    \ = 0;\n  // For each character in the string, compare it with the substring.\n\
    \  for ($i = 0; $i < strlen($string); $i++) {\n    // If the current character\
    \ matches the substring, increase the number of matches by 1.\n    if ($string[$i]\
    \ == $substring[$number_of_substrings]) {\n      $number_of_matches++;\n     \
    \ // If the current character is equal to the previous character, increase the\
    \ number of matching letters by 1.\n      if ($string[$i] == $previous_character)\
    \ {\n        $number_of_same_letters++;\n      }\n      // If the current character\
    \ is not equal to the previous character, increase the number of matching letters\
    \ by 1.\n    } else {\n      // If the current character is not equal to the previous\
    \ character, increase the number of matching letters by 1.\n      if ($string[$i]\
    \ != $previous_character) {\n        $number_of_same_letters++;\n      }\n   \
    \ }\n    // Keep track of the current character.\n    $previous_character = $string[$i];\n\
    \  }\n  // Increase the number of matching letters by 1, if the substring is longer.\n\
    \  if (strlen($substring) > strlen($string)) {\n    $number_of_matches++;\n  }\n\
    \  // If the current string is longer than the substring, increase the number\
    \ of matching letters by 1.\n  $number_of_substrings += strlen($substring);\n\
    \  // If the current number of matching letters is the same as the number of matching\
    \ characters in the substring, increase the number of matching letters by 1.\n\
    \  if ($number_of_same_letters == strlen($substring)) {\n    $number_of_matches++;\n\
    \  }\n  // Return the number of matches.\n  return $number_of_matches;\n}", " \
    \   $count = substr_count($string, $substring);\n    if ($count > 1) {\n     \
    \   for ($i = 1; $i < $count; $i++) {\n            $string .= $substring;\n  \
    \          $count = substr_count($string, $substring);\n        }\n    }\n   \
    \ return $count;\n}\n", "    $count = substr_count($string, $substring);\n   \
    \ if ($count) {\n        return $count;\n    }\n    $cases = array(\n        'aa'\
    \ => 'a',\n        'aaa' => 'a',\n        'aaab' => 'a',\n        'aaaab' => 'a',\n\
    \        'aaaba' => 'a',\n        'aab' => 'a',\n        'aaba' => 'a',\n    \
    \    'aabaa' => 'a',\n        'aabaab' => 'a',\n        'aabaaa' => 'a',\n   \
    \     'aabaabb' => 'a',\n        'aabaabba' => 'a',\n        'aabaabbb' => 'a',\n\
    \        'aabaabbbb' => 'a',\n        'aabaabbbbb' => 'a',\n        'aabaabbbbbb'\
    \ => 'a',\n        'aabaabbbbbbb' => 'a',\n        'aabaabbbbbbbb' => 'a',\n \
    \       'aabaabbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbb' =>\
    \ 'a',\n        'aabaabbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n       \
    \ 'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n    \
    \    'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\
    \ => 'a',\n        'aabaabbbbbbbbbbbbbbbbbbbbbbbbb", "    $pattern = preg_quote($substring,\
    \ '/');\n    $matches = 0;\n    preg_match_all('/' . $pattern . '/u', $string,\
    \ $matches);\n    return count($matches[0]);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The only trouble with this solution is that `how_many_times` returns different\
    \ results for the same input. `how_many_times('aaaa', 'aa')` returns 3 but `how_many_times('',\
    \ 'a')` returns 0.\n<|/ c |>\n<| c |>\nGood point, but `how_many_times('aaaa',\
    \ 'a')` returns 1, and `how_many_times('', 'aa')` returns 1...\n<|/ c |>\n<| c\
    \ |>\nYeah, that's what I meant. Your answer only returns correct results for\
    \ the first case `'aaa'`. Maybe the OP should clarify.\n<|/ c |>\n<| a tags=php,regex\
    \ dscore=1 |>\nThis is what I ended up using. Works pretty well:\n<code>\n$string\
    \ = 'aaaa';\n$substring = 'a';\necho preg_replace('/[aa]+/', '', $string); //\
    \ 3\n</code>\n<|/ a |>\n<| c |>\nBut `preg_replace('/[aa]+/', 'aa', $string);`\
    \ returns `'aaa'`, which is not what the OP asked for. Maybe you should clarify.\n\
    <|/ c |>\n<| c |>\nI thought he just wanted to count the occurrences of 'a'.\n\
    <|/ c |>\n<| c |>\nOP wants to count *overlapping* occurrences of `a`.\n<|/ c\
    \ |>\n<| c |>\nYes, OP wants overlapping occurrences.\n<|/ c |>\n<| c |>\nYeah,\
    \ maybe I was too fast with my comment. This should have been a comment in my\
    \ answer.\n<|/ c |>\n<| a tags=php,regex |>\nThis should work, maybe not optimized\
    \ but works ;)\n<code>\n<?php\n$string = 'aaaa';\n$substring = 'a';\n\n$pos =\
    \ strrpos($string, $substring) + strlen($substring);\n\nwhile($pos >= 0){\n  \
    \  echo substr_count($string, $substring);\n    $pos = strrpos($string, $substring,\
    \ $pos);\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=php,regex |>\nYou can use the\
    \ following function:\n<code>", "    if (strpos($string, $substring) === false)\
    \ {\n        return 0;\n    }\n    $str_length = strlen($string);\n    $substr_length\
    \ = strlen($substring);\n    $result = 0;\n    for ($i = 0; $i <= $str_length\
    \ - $substr_length; $i++) {\n        if (substr($string, $i, $substr_length) ===\
    \ $substring) {\n            $result++;\n        }\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis function is simple and easy\
    \ to understand.\nJust copy paste this function to your controller and it will\
    \ return the count of the occurrences of the given string in the given array.\n\
    <code>\n$arr = array('aaaa', 'asasa', 'asas', 'aa');\n$search = 'aaaa';\n$count\
    \ = findSubStr($search, $arr);\nvar_dump($count);\n", "    return substr_count($string,\
    \ $substring);\n}\n", "    return substr_count($string, $substring);\n}\n", " \
    \   $count = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if (strpos($string,\
    \ $substring, $i) !== false) $count++;\n    }\n    return $count;\n}", "    $matches\
    \ = array();\n    $i = 0;\n    $len = strlen($string);\n    $substr_len = strlen($substring);\n\
    \    while ($i < $len) {\n        if (substr($string, $i, $substr_len) == $substring)\
    \ {\n            $matches[] = $i + 1;\n            $i += $substr_len + 1;\n  \
    \      }\n        $i += 1;\n    }\n    return count($matches);\n}\n", "    $counter\
    \ = 0;\n    $len = strlen($string);\n    $sublen = strlen($substring);\n    for\
    \ ($i = 0; $i < $len; $i++) {\n        $counter += substr_count($string, $substring[$i]\
    \ == $string[$i] ? $substring[$i] : $substring[$i].$substring[$i], 0);\n    }\n\
    \    return $counter;\n}\n", "\tif (strlen($string) == 0 || strlen($substring)\
    \ == 0) return 0;\n\n\t// Make a list of all possible substrings\n\t$possible_substrings\
    \ = str_split($substring);\n\n\t// Count the number of times each possible substring\
    \ appears\n\t$count_substr_array = array_count_values($possible_substrings);\n\
    \n\t// Return the number of times all possible substring were found in the original\
    \ string\n\treturn array_sum($count_substr_array);\n}", "    if (strlen($string)\
    \ === 0) {\n        return 0;\n    }\n\n    $num_times = 0;\n    $str_length =\
    \ strlen($substring);\n\n    // If there are enough characters, just count the\
    \ occurrences of the substring\n    if ($str_length > 0) {\n        for ($i =\
    \ 0; $i < $str_length; $i++) {\n            if (strpos($string, $substring) !==\
    \ false) {\n                $num_times++;\n            }\n        }\n    }\n\n\
    \    // Now let's see how many times the substring can be found in the original\
    \ string\n    for ($i = 0; $i < $str_length; $i++) {\n        if (stristr($string,\
    \ $substring) !== false) {\n            $num_times++;\n        }\n    }\n\n  \
    \  return $num_times;\n}\n\n/**\n * Sort array of objects by object attribute\n\
    \ * Especially useful for when object keys are used as indexes in a multidimensional\
    \ array\n * @param array $array the array of objects to sort.\n * @param string\
    \ $string the key of the attribute to sort by.\n * @param boolean $reverse whether\
    \ the sort should be descending or not.\n * @return array\n */", "    $count_a\
    \ = 0;\n    $count_b = 0;\n    $current_str = '';\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        if ($string[$i] == $substring[0]) {\n            $current_str\
    \ .= $substring[0];\n            $count_a++;\n            $count_b++;\n      \
    \      if ($count_a == strlen($substring)) {\n                $count_b++;\n  \
    \          }\n        } else {\n            $current_str .= $string[$i];\n   \
    \     }\n    }\n\n    return $count_b;\n}\n", "    $matches = [];\n    preg_match_all(\"\
    /\".preg_quote($substring).\"/i\", $string, $matches);\n    return count($matches[0]);\n\
    }", "    return substr_count($string, $substring);\n}\n", "\t$total_times = 0;\n\
    \n\t// First loop through the string and check if it contains the substring. If\
    \ it does, we keep a count.\n\tfor ($i = 0; $i < strlen($string); $i++) {\n\t\t\
    if (strpos($string, $substring, $i) !== FALSE) {\n\t\t\t$total_times++;\n\t\t\
    }\n\t}\n\n\t// If we didn't find any matches return the original string length\
    \ as the count.\n\tif ($total_times == 0) {\n\t\treturn strlen($string);\n\t}\n\
    \n\t// Calculate the number of matches of every possible length and add them all\
    \ together.\n\t$match_combinations = array();\n\tfor ($i = 0; $i < strlen($string);\
    \ $i++) {\n\t\t$match_combinations[] = how_many_times(substr($string, 0, $i),\
    \ $substring);\n\t}\n\tsort($match_combinations);\n\n\t// If the match combinations\
    \ contain a single item it means there was just one match so the only thing left\
    \ to do is return the count of the single item in the combination (1).\n\tif (count($match_combinations)\
    \ == 1) {\n\t\treturn count($match_combinations[0]);\n\t}\n\n\t// Sort the match\
    \ combinations and then grab the highest match count and return the new total\
    \ of times the substring was found the most times (3).\n\treturn max(array_sum($match_combinations));\n\
    }\n", "  $count = 0;\n  $current_len = strlen($string);\n  $pos = 0;\n  $string_capped\
    \ = strtolower($string);\n  while (strpos($string_capped, $substring, $pos) !==\
    \ false) {\n    if ($pos > $current_len) {\n      return 0;\n    }\n    $pos =\
    \ $pos + 1;\n    $count++;\n  }\n  return $count;\n}\n", "    return preg_match_all('/'\
    \ . preg_quote($substring, '/') . '/i', $string, $matches) ? count($matches[0])\
    \ : 0;\n}\n", "    $result = 0;\n    if ($string) {\n        $string_exploded\
    \ = str_split($string);\n        foreach ($string_exploded as $char) {\n     \
    \       $result += substr_count($char, $substring);\n        }\n    }\n    return\
    \ $result;\n}\n</code>\n<|/ a tags=php dscore=5 |>\n<| c |>\nThis is also the\
    \ best solution. Thanks.\n<|/ c |>\n<| c |>\nI made this a php function to make\
    \ it easier to use: `function num_overlapped_times($string, $substring) { return\
    \ how_many_times($string, $substring);}`\n<|/ c |>\n<| c |>\n, This would be better\
    \ as a function, so you'd use it as: `echo num_overlapped_times($string, 'a');`.\
    \ Or you could just put `return how_many_times($string, $substring);` at the end\
    \ of `how_many_times()`, since it returns the count.\n<|/ c |>\n<| c |>\nFor this\
    \ particular problem, a regex solution is more appropriate. Even the PHP answer\
    \ above takes O(n) time instead of O(n*m), so this regex solution will be more\
    \ performant if this is done a lot.\n<|/ c |>\n<| c |>\nWhat about this one? https://stackoverflow.com/a/55504391/3832970\n\
    <|/ c |>\n<| a |>\nThe solution using preg_match_all is very simple and doesn't\
    \ require regular expressions. It's also a lot faster than other solutions. I\
    \ wrote a benchmarking code below (run on PHP 5.3.18):\n<code>\n<?php\n", "  //\
    \ return 0 if the substring does not exist in the string\n  if( ! strpos($string,\
    \ $substring)) return 0;\n\n  // find the position of this substring in the string\n\
    \  $pos = strpos( $string, $substring );\n\n  // find how many times the substring\
    \ can be found in this position\n  return $pos !== false ? ($pos - $string) /\
    \ strlen($substring) + 1 : false;\n}", "\t$counter = 0;\n\tfor ($i = 0, $count\
    \ = mb_strlen($string, 'UTF-8'); !$count && $i < $imax; $i++, $count = mb_strlen($string,\
    \ 'UTF-8')) {\n\t\tif (mb_stripos($string, $substring, $i, 'UTF-8') !== false)\
    \ {\n\t\t\t$counter++;\n\t\t}\n\t}\n\treturn $counter;\n}\n", "    if ($substring\
    \ == '' || $string == '' || strlen($string) == 0 || strlen($substring) == 0) {\n\
    \        return 0;\n    }\n    $occurrences = 0;\n    $substring_length = strlen($substring);\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        if (substr($string, $i,\
    \ $substring_length) == $substring) {\n            $occurrences++;\n        }\n\
    \    }\n    return $occurrences;\n}", "  $pos = 0;\n  $count = 0;\n  while ($pos\
    \ = strpos($string, $substring, $pos)) {\n    $count++;\n    $pos += strlen($substring);\n\
    \  }\n  return $count;\n}", "    $count = substr_count($string, $substring);\n\
    \    if ($count === 0)\n        $count = substr_count($string, 'a');\n    return\
    \ $count;\n}\n", "    // Keep track of how many times this substring has occured\n\
    \    // If no such substring has occured before, start at 0\n    if (isset($string[$substring]))\
    \ {\n        return $string[$substring];\n    }\n    return $string[$substring]\
    \ = 0;\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution fails on `how_many_times('aaaa',\
    \ 'aa')` returns 1 instead of 3. But thanks for providing the first one, I need\
    \ to research the other ones!\n<|/ c |>\n<| c |>\nOh, yeah, I forgot about that\
    \ edge case. My solution is not complete. I'll fix it.\n<|/ c |>\n<| c |>\nThat\
    \ is exactly what I need! However, it works fine in PHP, but fails in JS. Could\
    \ you please provide a JS-version too? Thanks a lot for the help!\n<|/ c |>\n\
    <| c |>\nI'll try to get it working in JS. I'll get back to you when I've finished.\n\
    <|/ c |>\n<| a dscore=1 |>\nThe function you provided will return the number of\
    \ occurrences but not the length of the string. For example for the string 'abcabcbb'\
    \ your function will return 3 whereas the correct answer should be 6 since the\
    \ last 3 characters do not match. \nI would say that the best solution for your\
    \ problem is to use preg_replace with a callback function:\n<code>\n<?php", "\t\
    $length = strlen($string);\n\t$substring = strtolower($substring);\n\t$substring\
    \ = preg_replace('/[^a-z]/', '', $substring);\n\t$count = 0; $found = false;\n\
    \tfor ($i = 0; $i < $length; $i++) {\n\t\t$char = $string[$i];\n\t\t$pos = strpos($substring,\
    \ $char);\n\t\tif ($pos === false) {\n\t\t\t$count++;\n\t\t} else {\n\t\t\tif\
    \ ($substring == $char || $pos == strrpos($substring, $char)) {\n\t\t\t\t$count++;\n\
    \t\t\t} else {\n\t\t\t\t$found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\
    if (!$found) {\n\t\t$count++;\n\t}\n\treturn $count;\n}\n", "    // Count overlaping\
    \ occurrences.\n    $count = 0;\n    for ($i = 0; $i < strlen($string); $i++)\
    \ {\n        $last = $substring[$i];\n        for ($j = $i + 1; $j < strlen($string);\
    \ $j++) {\n            if ($string[$i] === $substring && $string[$j] === $last)\
    \ {\n                ++$count;\n            }\n        }\n    }\n    return $count;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=3 tags=algorithm,php |>\nI wrote a PHP function\
    \ to do it for me:\n<code>", "  return strlen($string) - substr_count($string,\
    \ $substring);\n}\n</code>\n<|/ a tags=php,string,regex |>\n<| c |>\nI added another\
    \ variant which takes advantage of PHP's regex engine. Unfortunately, it doesn't\
    \ yet support Unicode (I think it does), but you can easily adapt it.\n<|/ c |>\n\
    <| c |>\n`preg_replace_callback` isn't necessarily faster than a straight regex\
    \ replacement. In the OP example, the difference is negligible, though. But in\
    \ a case that involves some actual code execution, such as a search for a regex\
    \ in a text file with 1000s of lines, that function could be very handy.\n<|/\
    \ c |>\n<| a dscore=3 |>\nHere is how I did it. \n<code>\n$string = \"This is\
    \ a string that contains a word\";\n$find = \"a\";\n$replace = \"\";\n\n$result\
    \ = preg_replace(\"/($find)/\", $replace, $string);\n\necho $result;\n</code>\n\
    <|/ a tags=php,string,regex |>\n<| c |>\nThis will replace all occurrences of\
    \ `$find` - not just the first.\n<|/ c |>\n<| a |>\nHere is another way of doing\
    \ it (that doesn't involve regex):\n<code>\n$string = \"This is a string that\
    \ contains a word\";\n$string2 = $string; //to avoid modifying the original string\n\
    $pos = strpos($string, \"a\");\n$string2[$pos] = \"\";\necho str_replace(\"a\"\
    , \"\",$string2);\n</code>\n<|/ a tags=php,string,regex dscore=3 |>\n<| c |>\n\
    I like the way you did it, but just one suggestion is that `str_replace()` doesn't\
    \ replace the first occurrence of the searched string, whereas `preg_replace()`\
    \ does. And this can be solved with some simple `if` checks inside the loop. Plus,\
    \ you don't have to declare `$pos`, you can use the `strpos()` function directly\
    \ on `$string` without creating another variable for it.\n<|/ c |>\n<| c |>\n\
    Yeah, this solution would have to be modified to replace only the first/next occurrence\
    \ of the string. You could also use an `if` statement inside the loop to skip\
    \ the rest of the string. Depending on what you want, though, the solution could\
    \ be modified to skip the rest of the string and just replace the first occurrence\
    \ of the string. I'll post the code in a second, but for now I'll leave it at\
    \ `strpos()` :) Thanks for the tip though.\n<|/ c |>\n<| c |>\nI added some code\
    \ to the first version of ", "  $counts = array();\n  for($i = 0; $i < strlen($string);\
    \ $i++) {\n    $counts[$string[$i]] += substr_count($substring, $string[$i], 0,\
    \ $i);\n  }\n  return max(count($counts), 0);\n}\n", "    return substr_count($string,\
    \ $substring);\n}\n", "    $substring = strtolower($substring);\n    $string =\
    \ strtolower($string);\n    $count = substr_count($string, $substring);\n    return\
    \ $count;\n}\n", "    return preg_match_all('/' . $substring . '/i', $string,\
    \ $matches) ? count($matches[0]) : 0;\n}", "    $matches = 0;\n    $substr_length\
    \ = strlen($substring);\n    for ($i = 0; $i < strlen($string); $i++) {\n    \
    \    $char = substr($string, $i, 1);\n        if ($char == $substring) {\n   \
    \         $matches++;\n        }\n    }\n    return $matches;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nPlease explain why this answer is useful (it may also solve OP's\
    \ problem).\n<|/ c |>\n<| c |>\nThis does not provide an answer to the question.\
    \ To critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/15250526)\n<|/ c |>\n<| c |>\n\
    This answer provides a solution to the question asked.  I do agree that it is\
    \ unlikely to help the OP, but it is an answer to the question asked.\n<|/ c |>\n\
    <| c |>\nIt is not an answer to OP's question, but an answer. Since SO is about\
    \ helping people understand problems, it would be better if it were pointed out\
    \ what they did wrong/miss and how the fix could improve the post. Just because\
    \ a user doesn't understand something, does not mean they shouldn't be pointed\
    \ out.\n<|/ c |>\n<| a dscore=5 |>\nI had a similar problem and I used this:\n\
    <code>\n$myString = 'Hello World'\n$myString =~ /./;\n</code>\nHope it helps!\n\
    <|/ a tags=php,regex,string |>\n<| c |>\nThis is the best solution of the lot.\
    \ It's simple and effective. It doesn't require extra code or function calls.\
    \ Thanks.\n<|/ c |>\n<| c |>\nThank you!  This is a much more concise and direct\
    \ answer than other solutions given above.  Simple and effective.  Thank you!\n\
    <|/ c |>\n<| c |>\nAwesome solution. Thanks.\n<|/ c |>\n<| c |>\nThank you very\
    \ much. I was wondering about this and I did not know about this solution. So\
    \ simple and effective.\n<|/ c |>\n<| c |>\nThe above code will give you an array\
    \ with only one character in the string. Use `preg_match_all` as `preg_match`\
    \ will just return the first match.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npreg_match_all('/(.)/',\
    \ $string, $matches);\n</code>\nThis will create a match array with each ", " \
    \   $count = substr_count($string, $substring);\n    $string = strtolower($string);\n\
    \    $substring = strtolower($substring);\n    $overlap_count = 0;\n    for ($i\
    \ = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        $sub_char\
    \ = $substring[0];\n        $start = 0;\n        if ($char != $sub_char) {\n \
    \           if ($i < strlen($string) - 1) {\n                if ($string[$i +\
    \ 1] == $sub_char) {\n                    $start++;\n                }\n     \
    \       }\n            if ($start == 0) {\n                $overlap_count++;\n\
    \            }\n        } else {\n            $overlap_count++;\n        }\n \
    \   }\n    return $overlap_count + $count;\n}\n", "  // Initialize variables\n\
    \  $strings = explode('', $string);\n  $substrings = explode('', $substring);\n\
    \  $count = 0;\n  foreach ($strings as $string) {\n    foreach ($substrings as\
    \ $substring) {\n      // If the current string is longer, add the new count and\
    \ start again\n      if (strlen($string) < strlen($substring)) {\n        $count\
    \ += 1;\n        $substrings = explode($substring);\n        // Reinitialize the\
    \ variables when reaching the end of the string\n        $strings = explode('',\
    \ $string);\n        break;\n      }\n      // If the current string is equal,\
    \ add the new count and start again\n      if ($string == $substring) {\n    \
    \    $count += 1;\n        $substrings = explode($substring);\n        // Reinitialize\
    \ the variables when reaching the end of the string\n        $strings = explode('',\
    \ $string);\n        break;\n      }\n      // If the current string overlaps\
    \ with the current substring, add it to the count\n      if (stripos($string,\
    \ $substring) !== false) {\n        $count += 1;\n      }\n    }\n  }\n  return\
    \ $count;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nI did this, but for some reason\
    \ it only returned a value of 2 for most of the words. I used this code: https://pastebin.com/vKgZ2wHZ\
    \ to test it, and for some reason it returned a value of 1 for most words. I'm\
    \ not sure why this is. Anyways, thank you for your answer :)\n<|/ c |>\n<| c\
    \ |>\nYou are welcome. I tested it, and it works fine. The code is tested as well.\
    \ Maybe you could provide some example input data to your question.\n<|/ c |>\n\
    <| c |>\nOkay, I just added an example of how it works on my site. I'm sorry for\
    \ the late reply, but I just started using Stack Overflow, so I don't have much\
    \ time to work on it right now.\n<|/ c |>\n<| c |>\nYour question is okay, but\
    \ it is hard to help you if you don\u2019t show us your code. I can\u2019t tell\
    \ what might be the issue from just an input data you provided. You have to provide\
    \ some working code to help you\n<|/ c |>\n<| c |>\nOkay, I'll provide an example\
    \ input data\n<|/ c |>\n<| a dscore=0 |>\nUse array_count_values function like\
    \ below,\n<code>\n$array = array('a','a','a','a','a');\nprint_r(array_count_values($array));\n\
    </code>\nOutput\n<code>\nArray\n(\n    [a] => 4\n)\n</code>\n<|/ a tags=php |>\n",
  "  // Keep count of times substring occurs in original string. Count overlaping\
    \ cases.\n  $count = 0;\n  for ($i = 0; $i < strlen($string); $i++) {\n    if\
    \ ($string[$i] == $substring) {\n      $count++;\n    }\n  }\n  // Return number\
    \ of occurrences.\n  return $count;\n}\n", "    $chars = str_split($string);\n\
    \    $substrings = str_split($substring);\n    $found_count = 0;\n    foreach($chars\
    \ as $key => $value) {\n        if($substring == $value) {\n            $found_count\
    \ += 1;\n        }\n        if($substring != $value && strpos($substring, $value)\
    \ !== false) {\n            $found_count += 1;\n        }\n    }\n\n    return\
    \ $found_count;\n}\n</code>\n<|/ a tags=performance,php,strpos |>\n<| a |>\n<code>\n\
    /**\n * count how many times a string occurs in a string without duplicates\n\
    \ *\n * string  $haystack\n * string  $needle\n * int     $offset\n * integer\
    \ number of times the string occurs\n */", "    $substringLen = strlen($substring);\n\
    \    $stringLen = strlen($string);\n    $result = 0;\n    $character;\n    for\
    \ ($i = 0; $i < $stringLen; $i++) {\n        $character = $string[$i];\n     \
    \   if ($character == $substring[0]) {\n            $result += $substringLen;\n\
    \        } else {\n            $result += 1;\n        }\n        if ($i == $stringLen\
    \ - 1) {\n            break;\n        }\n    }\n    return $result;\n}\n", " \
    \   $count_a = 0;\n    $count_b = strlen($string) - strlen($substring);\n    $i\
    \ = 0;\n    while ($i < $count_b) {\n        if ($string[$i] == $substring[0])\
    \ {\n            if (strlen($string) - $i >= $substring) {\n                $count_a++;\n\
    \                $i = strlen($string) - $substring;\n            } else {\n  \
    \              $i++;\n            }\n        } else {\n            if ($string[$i]\
    \ == $substring[1]) {\n                if (strlen($string) - $i >= $substring)\
    \ {\n                    $count_a++;\n                    $i = strlen($string)\
    \ - $substring;\n                } else {\n                    $i++;\n       \
    \         }\n            } else {\n                if (strlen($string) - $i >=\
    \ $substring) {\n                    $count_b++;\n                    $i = strlen($string)\
    \ - $substring;\n                } else {\n                    $i++;\n       \
    \         }\n            }\n        }\n    }\n    return $count_a + $count_b;\n\
    }\n", "  // Find where in the string the substring can be found.\n  $search_pos\
    \ = strpos($string, $substring);\n  // Find how many times the substring can be\
    \ found in the string.\n  $times = substr_count($string, $substring);\n  // Count\
    \ the number of times the substring appears adjacent to the first instance of\
    \ the substring.\n  $overlaps = $times - ($search_pos + strlen($substring));\n\
    \  return min($overlaps, $times);\n}", "    if ($string == $substring) {\n   \
    \     return 0;\n    }\n    if ($string{0} == $substring) {\n        return 1;\n\
    \    }\n    return count(preg_grep('/' . $substring . '/i', $string));\n}", " \
    \   if (empty($string)) {\n        return 0;\n    }\n    return substr_count($string,\
    \ $substring);\n}\n", "    $matches = 0;\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        if (strpos($string, $substring, $i) !== FALSE) {\n        \
    \    $matches++;\n        }\n    }\n    return $matches;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI like this answer too.  I wish I could upvote more than once.\n\
    <|/ c |>\n<| c |>\nYou might want to use strrpos as you wouldn't want to find\
    \ 'a' in 'aaa'.\n<|/ c |>\n<| c |>\nThis answer is more efficient for me. I'm\
    \ using the same string and the substring as yours.\n<|/ c |>\n<| a dscore=4 |>\n\
    The answer is in the question; use the count function.\n<code>\n<?php\n$string\
    \ = 'aaabb';\n$substring = 'aa';\necho strpos($string, $substring);", "    $count\
    \ = preg_match_all('/'.preg_quote($substring, '/').'/i', $string);\n    return\
    \ $count;\n}\n", "  // Make search variable global.\n  $pos = strpos($string,\
    \ $substring);\n  // If not found, return 0 results.\n  if (!$pos) {\n    return\
    \ 0;\n  }\n  // If the substring is already found, add 1.\n  if ($pos == strlen($substring))\
    \ {\n    return 1;\n  }\n  // Otherwise, increment the result by one.\n  return\
    \ $pos + how_many_times($string, '', $substring);\n}", "    $result = substr_count($string,\
    \ $substring);\n    return $result;\n}\n", "    $matches = 0;\n    $total_length\
    \ = 0;\n    $i = 0;\n    while (isset($string[$i])) {\n        if (strpos($string,\
    \ $substring, $i) === false) {\n            $i = strlen($string);\n        } else\
    \ {\n            $matches++;\n            $total_length += strlen($substring);\n\
    \            $i += strlen($substring);\n        }\n        $i++;\n    }\n    return\
    \ $matches;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for providing a php based\
    \ solution. However a regex based solution would be preferred. Anyway thanks for\
    \ your effort :) ..\n<|/ c |>\n<| c |>\nNo worries. I appreciate it. :) I updated\
    \ my answer to include a regex based solution. Give it a try.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nOne of the solutions would be to do a regular expression match\
    \ of the substring, and only count it once:\n<code>\n/(^| )$substring/\n</code>\n\
    <|/ a tags=php,substring,string |>\n<| a dscore=0 |>\nTo answer your question\
    \ more specifically, you can use the following code:\n<code>\n$string = \"this\
    \ should be ignored\";\n$string2 = \"this\";\n$substring = \"shoul\";\n\n$strlen\
    \ = strlen($string);\n$substr = strlen($substring);\n\n$result = $strlen - ($substring\
    \ . strlen($string));\n\n$substr = strlen($substring);\n\n$result2 = $strlen -\
    \ ($substring . strlen($string2));\n\nif ($result === $result2) {\n    echo \"\
    Both strings end with same substring\";\n} else {\n    echo \"The strings do not\
    \ end with same substring\";\n}\n</code>\n<|/ a tags=php,substring,string |>\n\
    <| c |>\nThe problem is that the above code returns different results if the substrings\
    \ differ in length.\n<|/ c |>\n<| a dscore=0 |>\nJust to conclude this question,\
    \ here is my final working solution:\n<code>", "    $count = substr_count($string,\
    \ $substring);\n    if ($count > 0) {\n        return $count;\n    }\n    $count_all\
    \ = substr_count($string, 'a');\n    $count_all = max(0, $count_all - 1);\n  \
    \  return ($count_all * 2);\n}\n", "  $matches = 0;\n  for ($i = 0; $i < strlen($string);\
    \ $i++) {\n    if (strpos($string, $substring, $i) !== FALSE) {\n      $matches++;\n\
    \    }\n  }\n  return $matches;\n}\n</code>\n<|/ a tags=php,php-7,strpos |>\n\
    <| a dscore=1 |>\nFor this purpose, explode() is the best solution:\n<code>",
  "    return preg_match_all('/' . preg_quote($substring, '/') . '/i', $string, $matches)\
    \ ? count($matches[0]) : 0; \n}", "    $pos = strpos($string, $substring);\n \
    \   $count_substr_occurrences = $pos !== false ? $pos - 1 : 0;\n\n    $pos2 =\
    \ strpos($string, $substring, $pos + 1);\n    if ($pos2 === false) {\n       \
    \ return $count_substr_occurrences;\n    }\n\n    $count_overlapping_occurrences\
    \ = $pos2 - $pos + 1;\n    return max(0, $count_substr_occurrences + $count_overlapping_occurrences);\n\
    }", "    $search = preg_quote($substring, '/');\n    $find = strpos($string, $search);\n\
    \    $find = ($find !== false) ? $find : substr($string, strlen($substring));\n\
    \    return ($find === $substring) ? 0 : substr_count($string, $substring);\n\
    }\n", "    $substring = strtolower($substring);\n    $string = strtolower($string);\n\
    \    $result = substr_count($string, $substring);\n    return $result;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nThe solution is simple:\n<code>\n$str = 'This is a test string';\n\
    $search = 'is';\n$count = substr_count($str, $search);\n</code>\nThe code above\
    \ will count the occurrences of \"is\" in \"This is a test string\".\n<|/ a tags=php,string\
    \ dscore=5 |>\n<| a dscore=5 |>\nHow about using the strpos function?\n<code>\n\
    $string = \"This is a string with lots of funny characters\";\n$position=strpos($string,$needle);\n\
    $count = $position - 1;\n</code>\n<|/ a tags=php,string |>\n<| a dscore=4 tags=php,string\
    \ |>\nIn PHP 7 there is also the strpos_count, which I find more useful than substr_count,\
    \ because you can supply a strict comparison as second argument to only find exact\
    \ matches, instead of counting overlapping matches.\n<code>\n$countOfSomeString\
    \ = \"This is a string with lots of funny characters\";\n$find = \"is\";\n$countOfSomeStringCount\
    \ = strpos_count($countOfSomeString, $find);\n</code>\n<|/ a |>\n<| a tags=php,string\
    \ |>\nThe most flexible and efficient method would be:\n<code>\n$string = 'this\
    \ is a test string';\n$search = 'is';\n$count = str_word_count($string, 1);\n\
    $count = ($count[$search] ?? 0) + 1;\n</code>\nThe str_word_count() function takes\
    \ your string and converts it into an array containing the words in it. Then you\
    \ can access the array with a string as the key to get its value.\nThis gives\
    \ you the ability to count words which have non-alphanumeric characters in them.\n\
    <|/ a dscore=4 |>\n<| c |>\nThis isn't correct answer as it counts `$search` substring\
    \ as a whole word. e.g. `var_dump(str_word_count($search, 1));` returns `array(1)\
    \ { [0]=> string(3) \"is\" }`. So it will return 2 and not 3\n<|/ c |>\n<| c |>\n\
    This answer is correct in regard to finding the number of words. If you have a\
    \ specific requirement to find the number of occurrences of something, please\
    \ update your question with that information.\n<|/ c |>\n<| c |>\nI needed to\
    \ find all the occurrences of the string in the string. Your answer helped me\
    \ find all the ", "    $count = 0;\n    if (empty($string) || empty($substring))\
    \ return $count;\n    $length = strlen($string);\n    $substring_length = strlen($substring);\n\
    \    for ($i = 0; $i < $length; $i++) {\n        if (substr($string, $i, $substring_length)\
    \ == $substring) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    if (strlen($string) < strlen($substring)) {\n        return 0;\n    }\n\
    \n    $total_matches = 0;\n\n    $pos_substr_start = strpos($string, $substring);\n\
    \    $pos_substr_end = strpos($string, $substring, $pos_substr_start + 1);\n\n\
    \    while (true) {\n        if ($pos_substr_end === 0) {\n            $total_matches++;\n\
    \            break;\n        }\n\n        $pos_substr_start = strpos($string,\
    \ $substring, $pos_substr_end + 1);\n        $pos_substr_end = strpos($string,\
    \ $substring, $pos_substr_start + 1);\n\n        $total_matches++;\n    }\n\n\
    \    return $total_matches;\n}\n", "    if ($string===$substring) return 0;\n\
    \    $count = substr_count($string, $substring);\n    if ($count===0) return 0;\n\
    \    $count = $count*2 - 1;\n    $pos = strrpos($string, $substring);\n    while\
    \ ($pos!==false) {\n        $count = $count + ($pos - strrpos($string, $substring));\n\
    \        $pos = strrpos($string, $substring, $pos+1);\n    }\n    return $count;\n\
    }", "    $start = 0;\n    $length = strlen($substring);\n    $count = 0;\n   \
    \ while (($pos = strpos($string, $substring, $start)) !== false) {\n        $count\
    \ += $pos - $start;\n        $start = $pos + 1;\n    }\n    return $count;\n}\n",
  "  // Split string into an array of chars so we can use array_search\n  $str_array\
    \ = str_split($string);\n  $substr_array = str_split($substring);\n\n  // Find\
    \ how many times a given substring can be found in the original string\n  $count\
    \ = count($substr_array);\n  for ($i = 0; $i < $count; $i++) {\n    // Skip to\
    \ the first char not found in the array\n    while ($str_array[array_search($substr_array[$i],\
    \ $str_array, true)] == $substring) {\n      array_push($str_array, $substr_array[$i],\
    \ $substr_array[$i]);\n    }\n  }\n\n  return $count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "    $search = preg_quote($substring, '/');\n    $match_length\
    \ = preg_match_all('/'.$search.'/ui', $string, $matches);\n    return $match_length;\n\
    }\n", "    if (!is_string($string) || !is_string($substring)) {\n        throw\
    \ new \\InvalidArgumentException('Arguments must be strings.');\n    }\n\n   \
    \ $length_string = strlen($string);\n    $length_substring = strlen($substring);\n\
    \    $count = 0;\n    $current_offset = 0;\n    for ($i = 0; $i < $length_string;\
    \ $i++) {\n        if (strpos($substring, $string[$i]) === false) {\n        \
    \    continue;\n        }\n\n        $count++;\n        $current_offset++;\n\n\
    \        // If we found an exact match, exit the loop\n        if ($i == $current_offset)\
    \ {\n            break;\n        }\n    }\n\n    return $count;\n}\n", "    $matches\
    \ = 0;\n    $sublen = strlen($substring);\n    for($i = 0; $i < strlen($string);\
    \ $i++) {\n        if ($string[$i] == $substring[$i]) {\n            $matches++;\n\
    \        } else {\n            $matches += min($sublen, $matches);\n         \
    \   $matches = max($sublen, $matches);\n        }\n    }\n    return $matches;\n\
    }", "    $total_times = 0;\n    $i = 0;\n    while($i < (count($string) - strlen($substring)))\
    \ {\n        $substring_length = strlen($substring);\n        $string_length =\
    \ strlen($string);\n        $start_index = strpos($string, $substring, $i);\n\
    \        // If the substring was not found, return zero.\n        if ($start_index\
    \ === FALSE) {\n            return $total_times;\n        }\n        // If the\
    \ substring was found and its length equals the whole string, return it.\n   \
    \     if ($start_index == $substring_length) {\n            $total_times++;\n\
    \        }\n        $i = $start_index + $substring_length;\n    }\n    return\
    \ $total_times;\n}\n", "\t$count = 0;\n\t$original_length = strlen($string);\n\
    \t$substring_length = strlen($substring);\n\n\t// Iterate through the entire string\
    \ and compare each character with the substring.\n\t// If the current substring\
    \ exists within the current string, increment the count.\n\t// If not, reset count\
    \ to 0 and start a new count at 1.\n\tfor ($i = 0; $i < $original_length; $i++)\
    \ {\n\t\tif (substr($string, $i, $substring_length) === $substring) {\n\t\t\t\
    $count++;\n\t\t} else {\n\t\t\t$count = 0;\n\t\t}\n\t}\n\n\treturn $count;\n}\n",
  "    return substr_count($string, $substring);\n}\n", "    $n = 0;\n    $i = 0;\n\
    \    while ($i < strlen($string)) {\n        $n = $n + substr_count($string, $substring,\
    \ $i);\n        $i++;\n    }\n    return $n;\n}\n", "    $num_times = 0;\n   \
    \ $num_substring = 0;\n    for($pos = 0; $pos < strlen($string); $pos++) {\n \
    \       if ($string[$pos] == $substring[$num_substring]) {\n            $num_times++;\n\
    \            $num_substring++;\n        }\n        else if ($num_substring > 0)\
    \ {\n            $num_substring += 1;\n        }\n    }\n    return $num_times;\n\
    }", "    if (strlen($string) == 0)\n        return 0;\n    if (strlen($substring)\
    \ == 0)\n        return strlen($string);\n    return substr_count($string, $substring);\n\
    }\n", "    $matches = [];\n    preg_match_all('/'.preg_quote($substring, '/').'/i',\
    \ $string, $matches);\n    return count($matches[0]);\n}\n</code>\n<|/ a tags=php,string\
    \ |>\n<| a tags=php,string |>\n<code>", "    $count = 0;\n    $search = strpos($string,\
    \ $substring);\n    while ($search !== false) {\n        $count++;\n        $search\
    \ = strpos($string, $substring, $search+1);\n    }\n    return $count;\n}\n",
  "    $count = 0;\n    $length = mb_strlen($string);\n    for($i = 0; $i < $length;\
    \ $i++) {\n        $char = mb_substr($string, $i, 1);\n        if($char === $substring)\
    \ {\n            $count++;\n            $i += 1;\n        } else if($char !==\
    \ $substring) {\n            break;\n        }\n    }\n    return $count;\n}\n",
  "  $result = 1;\n  if (strlen($string) == 0) return $result;\n  if ($string[0] ==\
    \ $substring[0]) {\n    // No overlap in first letter\n    return $result;\n \
    \ }\n\n  if (substr_count($string, $substring) > 0) {\n    // There is overlap\n\
    \    return $result;\n  }\n\n  $string_pos = 0;\n  $substring_pos = 0;\n  $current_pos\
    \ = 0;\n  while ($current_pos < strlen($string)) {\n    if ($string[$current_pos]\
    \ == $substring[$substring_pos]) {\n      $current_pos++;\n      $substring_pos++;\n\
    \      if ($substring_pos >= strlen($substring)) {\n        $result += $current_pos\
    \ - $string_pos + 1;\n        $string_pos = $current_pos;\n        $substring_pos\
    \ = 0;\n      }\n    } else {\n      if ($substring_pos < strlen($substring))\
    \ {\n        $string_pos = $current_pos;\n        $substring_pos = 0;\n      }\n\
    \      $current_pos++;\n    }\n  }\n\n  return $result;\n}\n", "    if ($string)\
    \ {\n        return substr_count($string, $substring);\n    }\n    return 0;\n\
    }", "    $search = preg_quote($substring, '/');\n    $position = 0;\n\n    $matches\
    \ = array();\n    do {\n        $matches = preg_grep('~' . $search . '~', preg_split('~'\
    \ . $search . '~', $string, -1, PREG_SPLIT_NO_EMPTY));\n        $position += strlen($matches[0]);\n\
    \    } while ($position < strlen($string));\n\n    return $position;\n}\n", " \
    \   $pos = strpos($string, $substring);\n    $counter = 0;\n    if ($pos === false)\
    \ {\n        $counter++;\n    }\n    if ($pos != 0) {\n        $counter++;\n \
    \       $string = substr($string, 0, $pos);\n    }\n    return $counter;\n}\n",
  "    $len = mb_strlen($string, 'UTF-8');\n    $pos = mb_strpos($string, $substring,\
    \ 'UTF-8');\n    $count = count($string) - $len - $pos;\n    return $count;\n}",
  "  if ($string == $substring) {\n    return 0;\n  }\n\n  $substring_length = strlen($substring);\n\
    \  if ($substring_length == 0) {\n    return 1;\n  }\n\n  $string_length = strlen($string);\n\
    \  $count = 0;\n\n  for ($i = 0; $i < $string_length; $i++) {\n    if ($string[$i]\
    \ == $substring[0]) {\n      if ($string[$i] == $substring[$substring_length -\
    \ 1]) {\n        $count++;\n        $substring = substr($substring, 1, -1);\n\
    \      }\n      else {\n        $substring = substr($substring, 1, -1);\n    \
    \  }\n    }\n  }\n\n  return $count;\n}", "    $count = 0; // number of times\
    \ a substring can be found in the original string\n    $len   = strlen($string);\n\
    \    $index = 0;\n\n    while (1) {\n        $index = strpos($string, $substring,\
    \ $index); // find the first occurence of the substring in the original string\n\
    \n        if ($index === false) { // substring not found, move the index to the\
    \ last character of the original string\n            $index = $len-1;\n      \
    \  }\n\n        $count++;\n        if ($index == 0) break; // all substrings found,\
    \ break out of loop\n\n        // move the index to the character before the first\
    \ occurence of the substring\n        $index--;\n    }\n    return $count;\n}",
  "    $n = substr_count($string, $substring);\n    return ($n === 0) ? 0 : ($n ==\
    \ 1) ? $n : $n + 1;\n}\n", "    $count = 0;\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        if (strpos($substring, $string[$i]) !== false) {\n        \
    \    $count += 1;\n        }\n    }\n    return $count;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is really nice and clever. +1\n<|/ c |>\n<| c |>\nThis one worked\
    \ perfectly for me. Thank you! I added the code for counting overlaps case in\
    \ the function above.\n<|/ c |>\n<| c |>\nThanks very much! I used this code and\
    \ added the overlaps case count to the function above.\n<|/ c |>\n<| c |>\nGreat.\
    \ Feel free to upvote my answer if it helped you. Thanks :)\n<|/ c |>\n<| a |>\n\
    I made this simple code to solve this problem:\n<code>", "    $found = 0;\n  \
    \  $substring = strtolower($substring);\n    do {\n        $found = strpos($string,\
    \ $substring, $found + 1);\n    } while ($found !== false);\n    return $found;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n$str1 = $_POST['searchfor'];\n\
    $str2 = strtolower($_POST['searchwords']);\n$str3 = strtolower($_POST['searchwords2']);\n\
    \n$str1a = str_split($str1, 1);\n$str2a = str_split($str2, 1);\n$str3a = str_split($str3,\
    \ 1);\n\n$common = [];\n$final = [];\n\nforeach ($str1a as $key => $value) {\n\
    \    if (in_array($value, $str2a) && in_array($value, $str3a)) {\n        $common[]\
    \ = $value;\n    }\n}\n\nforeach ($str2a as $key => $value) {\n    if (in_array($value,\
    \ $str1a) && in_array($value, $str3a)) {\n        $final[] = $value;\n    }\n\
    }\n\nvar_dump($common);\nvar_dump($final);\n</code>\n<|/ a tags=php dscore=0 |>\n\
    <| a tags=php |>\n<code>", "    $length = $string->length();\n    $pos = 0;\n\
    \    $matches = 0;\n\n    while ($pos < $length) {\n        if ($string->substr($pos,\
    \ $length) == $substring) {\n            $matches++;\n        }\n\n        $pos\
    \ = $pos + 1;\n    }\n\n    return $matches;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
