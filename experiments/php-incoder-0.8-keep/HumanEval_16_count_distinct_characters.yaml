name: HumanEval_16_count_distinct_characters
language: php
prompt: "<?php\n// Given a string, find out how many distinct characters (regardless\
  \ of case) does it consist of\n// >>> count_distinct_characters('xyzXYZ')\n// 3\n\
  // >>> count_distinct_characters('Jerry')\n// 4\nfunction count_distinct_characters($string)\
  \ {\n"
tests: "function candidate(...$args) {\n    return count_distinct_characters(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(\"\") !== 0) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"abcde\") !== 5) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"abcdecadeCADE\") !== 5) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"aaaaAAAAaaaa\") !== 1) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"Jerry jERRY JeRRRY\") !== 5) { throw new\
  \ Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["    $characters = str_split($string);\n    $counts = array_count_values($characters);\n\
    \    return count(array_keys($counts, 1));\n}\n\n$input = 'AABBCCDD';\n$output\
    \ = count_distinct_characters($input);\necho $output . \"\\n\";\n</code>\n<|/\
    \ a tags=php,arrays,performance,mysql |>\n<| a dscore=2 |>\nIf you don't care\
    \ about maintaining the order of letters, you can use this:\n<code>\nSELECT DISTINCT(SUBSTRING_INDEX(string,\
    \ letter, 1) ORDER BY letter ASC);\n</code>\n<|/ a tags=php,arrays,performance,mysql\
    \ |>\n<| a dscore=2 |>\n<code>\n<?php\n$string = \"AABBCCDD\";\n$length = strlen($string);\n\
    $unique = array();\n$count = 0;\nfor ($i = 0; $i < $length; $i++) {\n    $char\
    \ = substr($string, $i, 1);\n    if (! in_array($char, $unique)) {\n        $unique[]\
    \ = $char;\n        $count++;\n    }\n}\necho $count;\n</code>\n<|/ a tags=php,arrays,performance,mysql\
    \ |>\n<| c |>\nThis solution is great as it's very fast compared to other answers.\n\
    <|/ c |>\n<| a |>\n<code>", "    return array_reduce(str_split($string), function($count,\
    \ $character) {\n        return $count + count(array_filter(str_split($character)));\n\
    \    }, 0);\n}\n", "    $returnValue = 0;\n    $lowerCaseCharacters = str_split(strtolower($string));\n\
    \    foreach ($lowerCaseCharacters as $character) {\n        if ($character !==\
    \ '') {\n            $returnValue++;\n        }\n    }\n    return $returnValue;\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\nFor those that downvoted this answer,\
    \ could you please leave a comment explaining why? I believe it answers the question\
    \ that was asked.\n<|/ c |>\n<| c |>\n+1 because I agree with you that this is\
    \ an excellent answer. Although I prefer the answer that has less lines.\n<|/\
    \ c |>\n<| c |>\nThanks. I agree that it's much more readable and concise.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>\n$count = array_count_values(str_split($string));\n\
    $count = count($count);\n</code>\n<|/ a tags=php |>\n<| c |>\nThis is the only\
    \ answer that actually gives the correct answer. Everyone else just gets the word\
    \ count instead of character count.\n<|/ c |>\n<| c |>\nFor those that downvoted\
    \ this answer, could you please leave a comment explaining why? I believe it answers\
    \ the question that was asked.\n<|/ c |>\n<| a |>\nUse this\n<code>", "  // Split\
    \ the string into characters so we know how to count them.\n  $characters = str_split($string);\n\
    \n  // Go through each character and keep a count of how many times it appears.\n\
    \  $count = array();\n  foreach($characters as $character) {\n    // Convert the\
    \ character to lowercase for easier comparisons.\n    $character = strtolower($character);\n\
    \n    // If this character isn't in the count array, add it to the count array.\n\
    \    if(!array_key_exists($character, $count)) {\n      $count[$character] = 1;\n\
    \    } else {\n      // If the character appears more than once, increment its\
    \ count.\n      $count[$character] += 1;\n    }\n  }\n\n  // Now return our counting\
    \ result.\n  return count($count);\n}\n", "    if (!is_string($string)) return\
    \ 0;\n    return strlen($string);\n}\n", "    return count(preg_split('//u', $string,\
    \ -1, PREG_SPLIT_NO_EMPTY));\n}\n", "    return count(array_filter(str_split($string),\
    \ function($character) {\n        return $character === $character || ctype_upper($character);\n\
    \    }));\n}\n</code>\nThis would return 4 for \"Jerry\"\nIf you need this functionality\
    \ to actually be done in the database, try this:\n<code>\n<?php", "    $char_list\
    \ = array();\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char =\
    \ strtolower($string[$i]);\n        if (isset($char_list[$char])) {\n        \
    \    $char_list[$char]++;\n        } else {\n            $char_list[$char] = 1;\n\
    \        }\n    }\n    \n    return count($char_list);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThank you for that very helpful answer! I modified it to fit my code\
    \ and it works great!\n<|/ c |>\n<| a dscore=2 tags=php,wordpress,mysql,sql |>\n\
    This is a bit more complicated, but you can use a combination of LEFT JOIN, GROUP\
    \ BY, and a conditional expression to get the result you're looking for.  Here\
    \ is what your query would look like:\n<code>\nSELECT DISTINCT\n  CHAR_LENGTH(b.title)\
    \ as title_length,\n  b.post_id,\n  c.meta_value as name_length\nFROM wp_posts\
    \ b\nLEFT JOIN wp_postmeta c\n  ON c.post_id = b.ID\nLEFT JOIN wp_postmeta d\n\
    \  ON d.post_id = b.ID\n  AND d.meta_key = 'name_length'\nWHERE b.post_type =\
    \ 'post'\n  AND b.post_status = 'publish'\n  AND b.post_excerpt = ''\nGROUP BY\
    \ b.ID\n</code>\nThis will give you a row for each distinct title in the wp_posts\
    \ table, and a meta_value of \"name_length\" for each one.  I suspect that the\
    \ meta_value will only be populated if it exists in the wp_postmeta table.\n<|/\
    \ a |>\n<| c |>\nThanks for that, I implemented it and it works great!\n<|/ c\
    \ |>\n<| a |>\nI wrote a plugin that does this, but I never got around to finishing\
    \ it.  You can find it here:  https://github.com/jmccallum/wpseo-custom-fields\n\
    <|/ a tags=php,wordpress,mysql,sql dscore=2 |>\n<| a tags=php,wordpress,mysql,sql\
    \ |>\nHere's a very simple script that can do this.\nIt loops through all your\
    \ wordpress posts and counts the number of times each letter is used (excluding\
    \ the numbers).\n<code>\n<?php\n$count = 0;\n$all_post_titles = array();", " \
    \   return preg_match_all('/./u', $string) + 1;\n}\n</code>\n<|/ a tags=php,arrays\
    \ dscore=2 |>\n<| c |>\nThanks Benjamin. The result I get is `3`. What is the\
    \ `+` sign for?\n<|/ c |>\n<| c |>\nThanks for your explanation. As I am not a\
    \ professional PHP developer, what other PHP functions are available that can\
    \ be used for a better/simpler programming style?\n<|/ c |>\n<| c |>\nIt means\
    \ \"one or more repetitions of whatever the expression inside the parens matches\"\
    .\n<|/ c |>\n<| a tags=php,arrays |>\nOne way of doing it:\n<code>\n$array = array('one',\
    \ 'two', 'three', 'four', 'five');\n$a = count(array_unique($array));\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nThere are many ways to accomplish this same task.\
    \ I like to use preg_grep to create arrays of unique values, then use count()\
    \ to get the number of unique values. This method also allows you to use an array\
    \ with additional conditions.\n<code>\n$string = \"hello world hello\";\n", " \
    \   return preg_match_all('/[A-Za-z]+/', $string, $matches) ? count($matches[0])\
    \ : 0;\n}\n", "    // Convert lowercase string into upper and remove all non-alphanumeric\
    \ characters\n    $string = preg_replace('/[^A-Za-z0-9]/', '', strtoupper($string));\n\
    \    return count(array_unique(str_split($string)));\n}\n", "  return count(array_count_values(str_split($string)));\n\
    }\n", "    $chars = array();\n    foreach (str_split($string) as $char) {\n  \
    \      $char = strtolower($char);\n        if (!isset($chars[$char])) {\n    \
    \        $chars[$char] = 0;\n        }\n        $chars[$char]++;\n    }\n    return\
    \ count($chars);\n}\n", "  $string = preg_replace('/[^A-Za-z]/', null, $string);\n\
    \  return strlen($string);\n}\n", "  return preg_match_all('/./us', $string) +\
    \ 1;\n}\n</code>\n(The regular expression just matches a single character, but\
    \ could easily be expanded to match more than one character)\n<|/ a |>\n<| c |>\n\
    Nice answer, however, how would you do it, if you didn't know the length of the\
    \ string?\n<|/ c |>\n<| c |>\nI wouldn't bother. The length isn't really that\
    \ important. Unless you think that you're dealing with a very long string and\
    \ want to save on memory, it's probably not worth the extra overhead.\n<|/ c |>\n\
    <| a tags=php,unique,string dscore=0 |>\nUse str_split and array_diff to find\
    \ all the unique characters in the string. array_diff will remove all the duplicates.\n\
    <code>\n$str = 'xyzxyz';\n$array = str_split($str);\n$unique = array_diff($array,\
    \ array_unique(array_reverse($array)));\n</code>\n<|/ a |>\n<| c |>\nYes, I know\
    \ how to find the unique characters, but how do I find out how many unique characters\
    \ are in the string?\n<|/ c |>\n<| a tags=php,unique,string dscore=0 |>\n<code>\n\
    $string = 'xyzxyz';\n$unique = preg_replace('/(.)(?=\\1)/', '', $string);\n\n\
    echo $unique;\n</code>\n<|/ a |>\n<| a tags=php,unique,string |>\n<code>\n<?php\n\
    \n$str = 'xyzxyz';\n$len = strlen($str);\nfor ($i = 0; $i < $len; $i++)\n{\n \
    \ for($j = $i; $j < $len; $j++)\n  {\n    if($str[$i] == $str[$j])\n    {\n  \
    \    break;\n    }\n  }\n}\n\necho $len; // (4 - 1)\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=php,unique,string |>\nUse a preg_replace to remove duplicate\
    \ characters, then count the characters:\n<code>\n$string = \"xyzxyz\";\n$chars\
    \ = preg_replace(\"/./\", \"\", $string);\n$unique = count($chars);\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\n<?php\n\n    $string = \"xyzxyz\";\n\n   \
    \ $unique = preg_replace('/(.)(?=\\1)/', '', $string);\n\n    $length = strlen($unique);\n\
    \n    echo $length;\n", "    if (empty($string)) {\n        return 0;\n    }\n\
    \    $character_count = count(array_unique(preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY)));\n\
    \    return $character_count;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    <?php", "    $character_count = array();\n    $character_array  = str_split($string);\n\
    \    foreach ($character_array as $value) {\n        $character_count[$value]\
    \ = isset($character_count[$value]) ? $character_count[$value] + 1 : 1;\n    }\n\
    \    return count($character_count);\n}\n</code>\n<|/ a dscore=1 tags=unique,arrays,php\
    \ |>\n<| a |>\nThe function below is very efficient compared to other answers\
    \ for large string comparisons. The only requirement is that your strings are\
    \ all lower case.\n<code>\n<?php", "    $alphabet = preg_split('//', $string,\
    \ -1, PREG_SPLIT_NO_EMPTY);\n    return count(array_unique($alphabet));\n}\n",
  "    $char = array();\n    $string = strtolower($string);\n    foreach (str_split($string)\
    \ as $char) {\n        $char = strtolower($char);\n        if (isset($char[$char]))\
    \ {\n            $char[$char] = $char[$char] + 1;\n        }\n        else {\n\
    \            $char[$char] = 1;\n        }\n    }\n    return array_sum($char);\n\
    }\n", "    if ($string === '') {\n        return 1;\n    }\n\n    $count = 0;\n\
    \    for ($i = 0; $i < strlen($string); $i++) {\n        $char = strtolower($string[$i]);\n\
    \        if (!isset($counts[$char])) {\n            $counts[$char] = 1;\n    \
    \    } else {\n            $counts[$char]++;\n        }\n    }\n    return count($counts);\n\
    }\n</code>\n<|/ a tags=string,php,performance dscore=4 |>\n<| c |>\n+1 Nice solution,\
    \ just one thing: you can replace `substr($string, $i)` by `$string[$i]` as the\
    \ second parameter of `strpos` can be omitted.\n<|/ c |>\n<| c |>\n- Good point.\
    \ I've updated my answer to include your suggestion.\n<|/ c |>\n<| a |>\nHere's\
    \ a solution using PHP preg_replace:\n<code>", "    $letters_count = array();\n\
    \n    foreach (str_split($string) as $letter) {\n        if (!isset($letters_count[$letter]))\
    \ {\n            $letters_count[$letter] = 0;\n        }\n\n        $letters_count[$letter]++;\n\
    \    }\n\n    return count(array_keys($letters_count));\n}\n</code>\n<|/ a dscore=5\
    \ tags=python,php |>\n<| c |>\nIt would be good to add a PHP version to the PHP\
    \ solution if it is possible to add one. This would help newbies learn Python\
    \ quicker and understand it better.\n<|/ c |>\n<| c |>\nThe original post specifically\
    \ stated PHP, so I wouldn't bother adding one since it only adds overhead and\
    \ not actual new information. I've also updated it with a Python solution, thanks\
    \ for pointing it out!\n<|/ c |>\n<| c |>\nWhat about using [collections.Counter](http://docs.python.org/library/collections.html#collections.Counter)\
    \ from the collections module in Python?\n<|/ c |>\n<| c |>\nJust wanted to throw\
    \ this out there in case someone stumbles across this post and wants a PHP version\
    \ of this. I couldn't find a PHP solution that worked for me and this one did.\n\
    <|/ c |>\n<| c |>\nI love the use of `isset` instead of `!array_key_exists()`\n\
    <|/ c |>\n<| a tags=python,php |>\nHow about this:\n<code>\n$numOfCharacters =\
    \ count(preg_split('//', $string));\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe\
    \ downside of this is that it won't split at non-alphanumeric characters, but\
    \ then I don't think there is another easy way to do it.\n<|/ c |>\n<| c |>\n\
    Nice solution, but doesn't quite work if you have a string with '\\t'.\n<|/ c\
    \ |>\n<| c |>\nGood point.  A more robust solution would be to replace `\\t` with\
    \ `\\x20`.  But this might require some careful attention to the surrounding characters,\
    \ depending on your use case.\n<|/ c |>\n<| c |>\nThis doesn't work when you have\
    \ '\\t' in your string.\n<|/ c |>\n<| c |>\nWhat about '`\\t`' ?\n<|/ c |>\n<|\
    \ a |>\nAs it turns out, you don't have to use regular expression to split a string\
    \ by any delimiter:\n<code>\n$string = \"abc,def,ghi\";\n$delimiter = \",\";\n\
    $words = explode($delimiter, $string);\n</code>\n<|/ a ", "    return array_count_values(str_split($string));\n\
    }\n</code>\n<|/ a tags=php,arrays dscore=4 |>\n<| c |>\nThat is exactly what I\
    \ was looking for. Thanks!\n<|/ c |>\n<| c |>\nI prefer `return array_count_values(str_split($string))[$string];`\n\
    <|/ c |>\n<| c |>\nI ran into trouble using `str_split` on multibyte strings (`mb_str_split`).\
    \ A simple preg_split worked fine: `preg_split('//u', $string)`. Note that `mb_str_split`\
    \ is deprecated; use instead `preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY)`.\n\
    <|/ c |>\n<| a |>\nI didn't see any code using str_split. Here is a simpler solution\
    \ that uses substr_count. \n<code>\n$str = 'Hello World';\n$str = explode(\" \"\
    ,$str);\n$distinctChars = count(array_unique(substr($str[0],0,1)));\n</code>\n\
    This solution also will work with multi-byte characters.\n<|/ a tags=php,arrays\
    \ dscore=4 |>\n<| a dscore=4 tags=php,arrays |>\nHere's a solution that is based\
    \ on the original question, which assumes every word is two characters long:\n\
    <code>\n$chars = array_count_values(str_split($str, 2));\n$distinctChars = $chars['a']\
    \ + $chars['b'] + $chars['c'] + $chars['d'];\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ mate, this was exactly what I was looking for.\n<|/ c |>\n<| c |>\nHow do you\
    \ get the number of distinct characters? I thought that should be `count(array_unique($chars));`.\
    \ I'm guessing you meant something else. Thanks!\n<|/ c |>\n<| c |>\nYou're right\
    \ - that was a typo in the original post.  I've updated the answer.\n<|/ c |>\n\
    <| c |>\nI think he meant `count($chars)`, no?\n<|/ c |>\n<| c |>\nNo, `count($chars)`\
    \ will give the number of \"words\" (characters) in the string.  If you want distinct/unique\
    \ characters, you'd want to use `$distinctChars = array_count_values($chars)['a']\
    \ + ...`\n<|/ c |>\n<| a tags=php,arrays dscore=4 |>\nI suggest using array_count_values\
    \ and then array_sum to get the number of distinct characters. \n<code>\n$string\
    \ = '", "    return preg_match(\"/[[:alpha:]]/\", $string) ?\n        preg_match_all(\"\
    /[[:alpha:]]/\", $string, $matches) :\n        preg_match_all(\"/[^[:alpha:]]/\"\
    , $string, $matches);\n}\n", "    $chars = array();\n    $length = 0;\n    foreach\
    \ (preg_split('//', $string) as $char) {\n        $length++;\n        if (!array_key_exists($char,\
    \ $chars)) {\n            $chars[$char] = 0;\n        }\n        $chars[$char]++;\n\
    \    }\n    return $length;\n}\n</code>\n<|/ a tags=sorting,php,string |>\n<|\
    \ c |>\nHow about counting how many different letters are in a string? `'aabbcc'`\n\
    <|/ c |>\n<| a |>\nYou can use this code. It will help you to get the distinct\
    \ characters in string and count the number of character in the string.\n<code>\n\
    <?php\n$string = 'Hello World';\n$strCount = strlen($string);\n$count = 0;\n$distinct_char\
    \ = [];\nfor($i = 0; $i < $strCount; $i++){\n  $char = $string[$i];\n  if(in_array($char,\
    \ $distinct_char)){\n    $count++;\n  }else{\n    $distinct_char[] = $char;\n\
    \  }\n}\necho 'No of Distinct Characters: ' . $count . \"<br>\";\necho 'Distinct\
    \ Characters in String: ' . implode(',', $distinct_char) . \"<br>\";", "    $return\
    \ = array();\n    foreach (preg_split('//', $string) as $char) {\n        $return[$char]\
    \ = isset($return[$char]) ? $return[$char] + 1 : 1;\n    }\n    return array_count_values($return);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. Perhaps I'm\
    \ doing something wrong, but I get the same number of chars regardless of capitalization.\n\
    <|/ c |>\n<| c |>\n, The code above works fine for me in PHP 5.3.10. The string\
    \ passed should be `'xyzXYZ'`.\n<|/ c |>\n<| a dscore=1 |>\nI've created a function\
    \ to do this\n<code>", "    $chars = array();\n    $char_count = 0;\n\n    for\
    \ ($i = 0; $i < strlen($string); $i++) {\n        $chars[$string[$i]] = $string[$i];\n\
    \        if ($string[$i] === $string[$i - 1]) {\n            $char_count++;\n\
    \        } else {\n            $char_count = 0;\n        }\n    }\n\n    return\
    \ $char_count;\n}\n", "  return implode(array_count_values(str_split($string)));\n\
    }\n", "    $chars = array();\n    for ($i = 0; $i < strlen($string); ++$i) {\n\
    \        $char = strtolower($string[$i]);\n        if (isset($chars[$char])) {\n\
    \            $chars[$char]++;\n        } else {\n            $chars[$char] = 1;\n\
    \        }\n    }\n\n    return count($chars);\n}\n", "\t$string = strtolower($string);\n\
    \t$string = preg_replace('/[^a-z]/i', '', $string);\n\treturn strlen($string);\n\
    }\n", "    $distinct_characters = 1;\n    foreach (str_split($string) as $char)\
    \ {\n        $distinct_characters += count(array_filter(array_keys(str_split($string),\
    \ $char)));\n    }\n    return $distinct_characters;\n}\n</code>\n<|/ a tags=php,optimization,algorithm\
    \ |>\n<| c |>\nI think you might need to use str_split and array_filter instead\
    \ of str_pad and array_intersect to get the desired output\n<|/ c |>\n<| c |>\n\
    : Thank you for the suggestion, I have updated my answer and added a simpler approach.\n\
    <|/ c |>\n<| c |>\nThanks, I actually just finished implementing this but am accepting\
    \ this as the answer.\n<|/ c |>\n<| c |>\nI implemented this as my first answer...\
    \ but I also have a second version I posted as another answer, thanks for your\
    \ help!\n<|/ c |>\n<| a dscore=2 tags=php,optimization,algorithm |>\n<code>\n\
    $input = 'Jerry';\n\n$chars = str_split($input);\n$count = count($chars);\n\n\
    $distinct = 0;\nforeach ($chars as $char) {\n    $counts = array_count_values($chars);\n\
    \    if ($counts[$char] > 1) {\n        $distinct++;\n    }\n}\n\necho $distinct;\n\
    </code>\n<|/ a |>\n<| a tags=php,optimization,algorithm |>\n<code>", "    $distinct\
    \ = 0;\n    foreach (str_split($string) as $character) {\n        $distinct +=\
    \ (strtolower($character) === strtolower($character));\n    }\n    return $distinct;\n\
    }\n</code>\n<|/ a tags=php |>\n<| c |>\n`str_replace(\"a\", \"A\", $string)` will\
    \ not work in many locales (where `a` is an accented letter for example).\n<|/\
    \ c |>\n<| a tags=php |>\nAnother more flexible way is to create a multi dimensional\
    \ array with the counts of each letter and then use array_count_values() to return\
    \ the number of times each letter is used.\n<code>\n<?php\n    $string = \"abcdefghijklmnop\"\
    ;\n    $letters = str_split($string);\n    $counts = array_count_values($letters);\n\
    \    print_r($counts);", "    $characters = explode(' ', $string);\n    $distinct_characters\
    \ = array();\n    foreach ($characters as $character) {\n        $distinct_characters[$character]\
    \ = isset($distinct_characters[$character]) ? ++$distinct_characters[$character]\
    \ : 1;\n    }\n    return count($distinct_characters);\n}\n", "    if (strlen($string)\
    \ == 0) {\n        return 0;\n    }\n    // convert to lowercase\n    $string\
    \ = strtolower($string);\n    $num_distinct_characters = 0;\n    for ($i = 0;\
    \ $i < strlen($string); $i++) {\n        $num_distinct_characters += (ord($string[$i])\
    \ - ord('A') + 1);\n    }\n    return $num_distinct_characters;\n}\n", "    $distinct_characters\
    \ = '';\n    $string_c = strtolower($string);\n    $string_a = str_split($string_c);\n\
    \    $length = count($string_a);\n    for ($i = 0; $i < $length; $i++) {\n   \
    \     $distinct_characters = $distinct_characters . $string_a[$i] . ' ';\n   \
    \ }\n    $distinct_characters = preg_replace('/[^a-z A-Z 0-9 \\.]/', '', $distinct_characters);\n\
    \    return str_word_count($distinct_characters);\n}\n", "  $counts = array_count_values(str_split($string));\n\
    \  $distinctCount = 0;\n  foreach ($counts as $count => $countValue) {\n    if\
    \ ($count > $distinctCount) {\n      $distinctCount = $count;\n    }\n  }\n  return\
    \ $distinctCount;\n}\n</code>\n<|/ a tags=string,php,unique |>\n<| c |>\nThis\
    \ one should be the best answer.\n<|/ c |>\n<| c |>\nThis is an awesome answer!\
    \ I'd also love to see a regex solution so I can also include special characters\
    \ in the string.\n<|/ c |>\n<| c |>\nI added a regex solution and a sample of\
    \ how you could use it.\n<|/ c |>\n<| c |>\nYou don't need to use regex to solve\
    \ this problem. See my answer below for how you can achieve this using just basic\
    \ string manipulation functions.\n<|/ c |>\n<| a tags=string,php,unique dscore=5\
    \ |>\nYou can get all the unique characters in the string using preg_match_all:\n\
    <code>\n$str = 'Jerry';\n\npreg_match_all('/./u', $str, $matches);\nprint_r($matches[0]);\n\
    </code>\nThis would print:\n<code>\nArray\n(\n    [0] => J\n    [1] => j\n   \
    \ [2] => e\n    [3] => r\n    [4] => y\n)\n</code>\n<|/ a |>\n<| c |>\nThis answer\
    \ is definitely the easiest and most straightforward way to do it.\n<|/ c |>\n\
    <| c |>\nI wonder why this was downvoted so much. Anyone care to explain?\n<|/\
    \ c |>\n<| c |>\nThis answer works perfectly in all situations. No need for regex\
    \ or iterating over the string characters and counting the duplicates. And it's\
    \ extremely fast.\n<|/ c |>\n<| c |>\nI like this answer as well. Very simple,\
    \ very fast.\n<|/ c |>\n<| c |>\nWhy don't you just use `/./`?\n<|/ c |>\n<| a\
    \ |>\n<code>\n$s = 'Jerry';\n$result = array_unique( str_split( $s ) );\n</code>\n\
    <|/ a dscore=5 tags=string,php,unique |>\n<| c |>\nThis fails to remove duplicate\
    \ characters. `array_unique()` will remove duplicate entries from the array, but\
    \ it will not remove duplicate characters as stated in the OP.\n<|/ c |>\n<| a\
    \ dscore=5 tags=string,", "  return preg_match_all('/(\\w)\\1*/', $string, $matches,\
    \ PREG_OFFSET_CAPTURE);\n}\n", "    return count(preg_split('//u', $string, -1,\
    \ PREG_SPLIT_NO_EMPTY));\n}\n", "  return count(array_filter(str_split($string),\
    \ 'strlen'));\n}\n</code>\n<|/ a tags=php,string,string-length dscore=0 |>\n<|\
    \ c |>\nWhy not use the built-in `count()` function?\n<|/ c |>\n<| c |>\nHe said\
    \ he would like to count letters regardless of case. I assume he wants to count\
    \ all letters. If you use count_chars it will return all letters regardless of\
    \ case.\n<|/ c |>\n<| c |>\n\"all letters\"? That's just `count($string)`. No\
    \ need for `array_filter()`.\n<|/ c |>\n<| c |>\nI thought he wanted the counts\
    \ regardless of case.\n<|/ c |>\n<| c |>\nThis answer is so wrong.\n<|/ c |>\n\
    <| a tags=php,string,string-length dscore=0 |>\nYou can create a custom function\
    \ for that purpose:\n<code>\n<?php\n", "    $chars = preg_split('//u', $string);\n\
    \n    $distinct_chars = 1;\n    for ($i = 0, $count = count($chars); $i < $count;\
    \ $i++) {\n        $distinct_chars *= 26; // Count the ASCII characters only\n\
    \        $distinct_chars += $chars[$i];\n    }\n\n    return $distinct_chars;\n\
    }\n", "    if (is_null($string)) {\n        return 0;\n    }\n\n    $counter =\
    \ array_count_values(str_split(strtolower($string)));\n    return count($counter);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=php,string |>\n<code>\n$str = 'Jerry\
    \ Brown';\n$str = ucfirst(strtolower($str));\n$len = strlen($str);\nfor($i=0;\
    \ $i < $len; $i++) {\n    if($str[$i] == $str[($i+1)] && $str[$i] == $str[($i+2)])\
    \ {\n        echo 'distinct';\n        break;\n    }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=php,string |>\nHere is a recursive solution:\n<code>\n$string\
    \ = 'Jerry Brown';\n", "    $string = mb_strtolower($string);\n    return mb_strlen($string,\
    \ 'UTF-8') / mb_strlen($string, 'UTF-16BE');\n}\n</code>\n<|/ a tags=php,hash,md5,security\
    \ |>\n<| a tags=php,hash,md5,security dscore=2 |>\nThe hashing algorithm should\
    \ be independent from the language used to implement it. So you might want to\
    \ write your own hashing function with specific hashing algorithm. \nYou can find\
    \ some links here: http://php.net/manual/en/function.hash-equals.php\nThe same\
    \ goes for encryption algorithm (using hash functions)\n<|/ a |>\n<| a tags=php,hash,md5,security\
    \ |>\nMD5 and SHA are both ways of implementing hashing. MD5 was written by RSA\
    \ and was designed to produce unique hashes across different computers. SHA was\
    \ written by RSA and was designed to produce unique hashes across different computers.\
    \ SHA was designed to be fast, so it has proven its speed to be acceptable for\
    \ use in security applications.\nTo answer your question: it depends on whether\
    \ you want to be safe and secure in some area, or want to be secure in others.\n\
    MD5 has a bit of vulnerability to people who create their own passwords, while\
    \ SHA only has vulnerability to people who create their own hashes. Therefore,\
    \ you should avoid MD5 and SHA if you plan on creating your own passwords.\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 tags=php,hash,md5,security |>\nMD5 was designed\
    \ to be fast, and is also used to hash passwords for storage. Its security is\
    \ as good as SHA1. \nIf you are implementing your own hashing function for storing\
    \ passwords, make sure that you use the same hashing function you are using for\
    \ your login system, to not leak passwords by mistake. \nThe only thing you should\
    \ store in the database is passwords, and not the hashes. MD5 should only be used\
    \ as a last resort if all else fails.\n<|/ a |>\n<| a dscore=1 |>\nThis question\
    \ is very old and has lots of good answers. So I won't rephrase it again.\nThere\
    \ are two kinds of hashing algorithms:\n\nThe old ones (md5, sha1, sha256, sha512)\n\
    The newer ones (SHA256, SHA512)\n\nThese algorithms were designed to produce a\
    \ strong collision resistance (two strings that produce the same result are considered\
    \ equal). The newer ones (SHA-256, SHA512) were designed to be fast and resistant\
    \ to collisions.\n", "    $count = array_count_values(str_split($string));\n \
    \   return count($count);\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,string,php\
    \ |>\nSince str_split's output is not a plain array but an object, the solution\
    \ to your problem is to use an ArrayIterator and use array_count_values() to get\
    \ your result like so:\n<code>\n$str = 'aabaa';\n$arr = [];\n$iterator = new ArrayIterator(str_split($str));\n\
    array_walk($iterator, function(&$val) { $arr[$val]++; });\necho array_count_values($arr)['aa'];\
    \ // 3\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,string,php dscore=0 |>\n\
    You can use array_count_values() function as described in docs\n<code>\n<?php\n\
    $string = \"aabaa\";\n$chars = array_count_values(str_split($string));\necho $chars['a'];",
  "    return count(preg_split('//u', $string));\n}\n</code>\n<|/ a tags=string,php,arrays\
    \ |>\n<| a |>\nYou can easily do this with a simple for loop:\n<code>\n$string\
    \ = 'abc';\n\n$count = count($string);\n$chars = strlen($string);\n\nfor($i =\
    \ 0; $i < $count; $i++) {\n  for($j = 0; $j < $chars; $j++) {\n    if ($string[$i]\
    \ == $string[$j]) {\n      $count--;\n    }\n  }\n}\n\necho $count;\n</code>\n\
    <|/ a dscore=0 tags=string,php,arrays |>\n<| a tags=string,php,arrays |>\nYou\
    \ can use a foreach loop to compare each letter in the string with all the other\
    \ letters and then subtract that number of letters from the total to get a number.\n\
    <code>", "    if (empty($string)) {\n        return 0;\n    }\n\n    $chars =\
    \ preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY);\n    $result = array();\n\
    \    foreach ($chars as $c) {\n        $char = strtolower($c);\n        if (isset($result[$char]))\
    \ {\n            $result[$char]++;\n        } else {\n            $result[$char]\
    \ = 1;\n        }\n    }\n\n    return count($result);\n}\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| a tags=php,algorithm dscore=0 |>\nYou can simply use array_count_values(),\
    \ like this:\n<code>\n$string=\"ABCABCABCABC\";\nprint_r(array_count_values($string));\n\
    </code>\nAnd the output will be:\n<code>\nArray\n(\n    [A] => 4\n    [B] => 3\n\
    \    [C] => 3\n)\n</code>\n<|/ a |>\n<| a tags=php,algorithm |>\nA quick and dirty\
    \ solution would be to replace all the letters with a space and run the function\
    \ again replacing all spaces with the original letter.  \nIf you have a lot more\
    \ letters, you might find it more efficient to create an array of the letters\
    \ and then just call array_count_values().  I didn't benchmark this against your\
    \ solution, but it's probably quicker.\n<code>", "    return strlen($string);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nJust an FYI, you didn't say that in the question,\
    \ only in a comment. Your answer is correct for the question, though.\n<|/ c |>\n\
    <| c |>\nThis should be the answer, not the comment, because the comment is the\
    \ correct answer to the question.\n<|/ c |>\n<| a tags=php,math dscore=3 |>\n\
    The easiest way to do this is to create a hashmap from the string and then do\
    \ a strlen() on that hashmap to get the number of distinct characters:\n<code>\n\
    $distinctCharacters = array_count_values(str_split($string));\n$distinctCharacters\
    \ = array_sum($distinctCharacters);\n</code>\nThis approach is O(n)\n<|/ a |>\n\
    <| a |>\n<code>\n$countDistinctChars = count(array_unique(str_split($string)));\n\
    </code>\n<|/ a dscore=2 tags=php,math |>\n<| c |>\nThis doesn't work if the string\
    \ contains multiple repeating characters.  It also doesn't work at all on UTF8\
    \ strings (which OP has stated they might have).\n<|/ c |>\n<| a tags=php,math\
    \ |>\n<code>", "    return preg_match_all('/[A-z\\s]/u', $string) + 1;\n}", " \
    \   if (empty($string)) return 0;\n    if (strlen($string) === 1) return 1;\n\
    \    $chars = preg_split('//', $string, null, PREG_SPLIT_NO_EMPTY);\n    $characters\
    \ = array_unique(array_map('strtolower', $chars));\n    return count($characters);\n\
    }\n", "    $chars = str_split($string);\n    $count = count($chars);\n    array_walk($chars,\
    \ function(&$item){\n        $item = strtolower($item);\n    });\n    return $count;\n\
    }", "    $hash = [];\n    $distinctCharacterCount = 0;\n    foreach (str_split($string)\
    \ as $char) {\n        if (! isset($hash[$char])) {\n            $hash[$char]\
    \ = 1;\n            $distinctCharacterCount++;\n        } else {\n           \
    \ $hash[$char]++;\n        }\n    }\n\n    return $distinctCharacterCount;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    $string = strtolower($string);\n\
    \n    return count(array_unique(str_split($string)));\n}", "    $alphabet = [];\n\
    \    foreach (str_split(strtolower($string)) as $character) {\n        if (isset($alphabet[$character]))\
    \ {\n            $alphabet[$character]++;\n        } else {\n            $alphabet[$character]\
    \ = 1;\n        }\n    }\n    return count($alphabet);\n}\n", "    if (empty($string))\
    \ {\n        return 0;\n    }\n\n    $char = array();\n    $distinct = 0;\n  \
    \  for ($i = 0; $i < strlen($string); ++$i) {\n        $char = strtolower($string[$i]);\n\
    \        if (!isset($char[$char])) {\n            $distinct++;\n            $char[$char]\
    \ = 1;\n        } else {\n            $char[$char] += 1;\n        }\n    }\n\n\
    \    return $distinct;\n}\n\n/**\n * Convert a number of bytes to a human readable\
    \ format.\n * @param integer $bytes\n * @return string Human readable byte count\n\
    \ * @link http://php.net/manual/en/function.number-format-size.php\n */", "  \
    \  $characters = count(preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY));\n\
    \    return $characters > 0 ? $characters : 1;\n}\n", "    return strlen($string);\n\
    }", "    return preg_match_all('/\\pL/u', $string, $matches) ? count(array_unique($matches[0]))\
    \ : 0;\n}\n", "    $characters = array_map('strtolower', str_split($string));\n\
    \    return count(array_unique($characters));\n}\n", "\treturn trim(preg_replace('/[^a-zA-Z0-9]/',\
    \ '', $string)).length;\n}\n", "    $characters = $chars = [];\n\n    foreach\
    \ (str_split($string) as $char) {\n        $char = strtolower($char);\n      \
    \  if (array_key_exists($char, $characters)) {\n            $characters[$char]\
    \ += 1;\n        } else {\n            $characters[$char] = 1;\n        }\n  \
    \  }\n\n    foreach ($characters as $char => $count) {\n        $chars[$char]\
    \ = $char;\n    }\n\n    return count($chars);\n}\n</code>\nAs a bonus, this can\
    \ be used in a more readable way:\n<code>\n$count = count_distinct_characters($string);\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=php,string |>\n<code>", "    $characters\
    \ = [];\n    $str_length = mb_strlen($string);\n    for ($i = 0; $i < $str_length;\
    \ $i++) {\n        $char = mb_substr($string, $i, 1);\n        if (!array_key_exists($char,\
    \ $characters)) {\n            $characters[$char] = 1;\n        } else {\n   \
    \         $characters[$char]++;\n        }\n    }\n    return array_sum($characters);\n\
    }\n", "    return mb_strtolower(strtr($string, array('Z' => 'z', 'z' => 'Z')),\
    \ \"UTF-8\");\n}\n</code>\n<|/ a tags=php,unique,algorithm,string |>\n<| a |>\n\
    <code>", "    $chars = preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY);\n \
    \   $cnt = count($chars);\n    // count only unique characters, ignore case\n\
    \    $distinct = 0;\n    $lower = 0;\n    $upper = 0;\n    for ($i = 0; $i < $cnt;\
    \ $i++) {\n        if (ctype_alpha($chars[$i])) {\n            if (ctype_upper($chars[$i]))\
    \ {\n                $upper++;\n            } else {\n                $lower++;\n\
    \            }\n        } else {\n            $distinct++;\n        }\n    }\n\
    \    return $lower + $distinct - $upper;\n}\n</code>\n<|/ a tags=php,string,regex,mysql\
    \ |>\n<| c |>\nThis worked perfectly. I did have to add an extra function to strip\
    \ out any non-alphabetical characters, but that was pretty simple.\n<|/ c |>\n\
    <| c |>\nThat works great for non-alpha characters, but it also includes the spaces.\
    \ How would I modify this for spaces only?\n<|/ c |>\n<| a tags=php,string,regex,mysql\
    \ |>\nFor this particular string you could also use the following, which will\
    \ return the same answer:\n<code>\nSELECT LENGTH(TRIM(BOTH ' ' FROM \n  REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(\n\
    \    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(\n\
    \    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(\n\
    \    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLAC", "  $uniqueCharacters = preg_split('//u',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY);\n  return count(array_unique($uniqueCharacters));\n\
    }\n", "    return strlen($string) ?\n        $string :\n        preg_replace('/(^|.)\\\
    \\?/', '\\\\1', $string);\n}", "    return strlen($string);\n}\n", "    return\
    \ preg_match_all('/\\w/', $string) ? count(preg_split('//', $string)) : 0;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nI hope this will help to someone\n<code>\n\
    <?php \n$string=\"My name is Kumar Singh\";\necho count_distinct_characters($string);\n\
    \ function count_distinct_characters($string) {\n$string = preg_replace('/[^a-z\
    \ ]/', '', $string);\nreturn preg_match_all('/[a-z]/i', $string) ? count(preg_split('//',\
    \ $string)) : 0;\n}", "    return strlen(preg_replace('~(.)\\1+~', '$1', $string));\n\
    }", "    $unique_characters = array();\n    foreach (str_split($string) as $char)\
    \ {\n        if (! isset($unique_characters[strtolower($char)])) {\n         \
    \   $unique_characters[strtolower($char)] = 0;\n        }\n        $unique_characters[strtolower($char)]++;\n\
    \    }\n    return count($unique_characters);\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis answer is more complete than mine is :) The `str_split()` function\
    \ should be faster than `str_word_count()`. On my PHP 5.6 machine I tested the\
    \ timing of `str_split()` and `str_word_count()` and got about the same execution\
    \ time as the accepted answer (with `str_split()` being faster on average). However,\
    \ `str_word_count()` does not return a numeric value, so I replaced `count($unique_characters)`\
    \ with `count($unique_characters)-1`. Also, the accepted answer does not seem\
    \ to account for non-word characters as distinct characters, as those are counted\
    \ separately with `str_word_count()`.\n<|/ c |>\n<| c |>\nThanks for the comments.\
    \ I ran this on PHP 5.6 and I got `str_split()` being about 5 times faster than\
    \ `str_word_count()`. On my machine it is about the same (for both the accepted\
    \ answer and this answer). However, `str_word_count()` does not return a numeric\
    \ value, so I replaced `count($unique_characters)` with `count($unique_characters)-1`.\
    \ Also, the accepted answer does not seem to account for non-word characters as\
    \ distinct characters, as those are counted separately with `str_word_count()`.\n\
    <|/ c |>\n<| c |>\nI tested this on PHP 7.0 with identical results. I did notice\
    \ that `str_word_count()` seems to include spaces as distinct characters, but\
    \ my function doesn't do that as `str_word_count()` does. It does not account\
    \ for non-word characters as distinct characters, as those are counted separately\
    \ with `str_word_count()`.\n<|/ c |>\n<| c |>\nI tested this on PHP 7.1 with identical\
    \ results. I did notice that `str_word_count()` seems to include spaces as distinct\
    \ characters, but my function doesn't do that as `str_word_count()` does. It does\
    \ not account for non-word characters as distinct characters, as those are counted\
    \ separately with `str_word_count()`.\n<|/ c |>\n<| c |>\nI tested this on PHP\
    \ 7.2 with identical results. I did notice that `str_word_count()` seems to include\
    \ spaces as distinct characters, but my function doesn't do that as `str_word_count()`\
    \ do", "    // Get an array of all characters found in the string\n    // This\
    \ is an array where each element contains another array with the character and\
    \ the position in the string\n    $chars = array_map('str_split', $string);\n\
    \    $chars = array_map('array_unique', $chars);\n    return count(array_map('strlen',\
    \ $chars));\n}\n", "    return strlen($string) - count_chars($string, false);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,php |>\nHere's a very simple way\
    \ to do it:\n<code>", "    if (!$string) {\n        return 0;\n    }\n\n    $chars\
    \ = preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY);\n\n    return count(array_unique($chars));\n\
    }\n", "  return count_chars($string, COUNT_DISTINCT, '');\n}\n", "    $counter\
    \ = 0;\n    $array = str_split($string);\n    foreach ($array as $char) {\n  \
    \      if (ctype_lower($char)) {\n            $counter++;\n        }\n    }\n\
    \    return $counter;\n}", "    $char_list = array_map('strtolower', str_split($string));\n\
    \    $unique_characters = array_unique(array_map(\n        function ($char) use\
    \ ($char_list) {\n            $char_index = array_search($char, $char_list);\n\
    \            return $char_index;\n        },\n        $char_list\n    ));\n\n\
    \    return count($unique_characters);\n}\n</code>\n<|/ a dscore=4 tags=php,algorithm\
    \ |>\n<| c |>\nThe algorithm above (which is not O(n)) will get *very* slow for\
    \ long strings. It's very inefficient for short strings and inefficient for long\
    \ strings with repeating characters.\n<|/ c |>\n<| a dscore=4 |>\nTo get an O(n)\
    \ solution, we can build our own array (I call it chars) from our original string\
    \ (I call it str) then do this:\n<code>\n$count = 0;\nforeach ($chars as $c) {\n\
    \    $count += $str{0} === $c ? 1 : 0;\n}\n</code>\nThis basically does the counting\
    \ in a single pass, but requires two O(n) operations (the foreach and the accessing\
    \ $str{0}). Since each char is compared against the entire string we get an O(n)\
    \ algorithm.\nHere's a benchmark showing the O(n) algorithm is faster than the\
    \ others: http://3v4l.org/hNJ7h\n<|/ a tags=php,algorithm |>\n<| c |>\nThis algorithm\
    \ doesn't seem to be O(n), can you please explain why?\n<|/ c |>\n<| c |>\nIt's\
    \ O(n). We build an array with O(n) size, then iterate through the array and compare\
    \ each char to the whole string.\n<|/ c |>\n<| c |>\nI thought you were saying\
    \ it's O(n^2)... Sorry, I'm still a bit confused as to how it works.\n<|/ c |>\n\
    <| c |>\nO(n) means it will always take the same amount of time to execute, regardless\
    \ of the size of the input. O(n^2) means a larger input is more expensive than\
    \ a smaller input. http://stackoverflow.com/questions/17640754/what-is-time-complexity-of-a-program\n\
    <|/ c |>\n<| c |>\nI see. Thank you for explanation. BTW I edited my answer with\
    \ a benchmark that shows that my algorithm is faster than the others.\n<|/ c |>\n\
    <| a |>\nTry this one,\n<code>", "    $length = strlen($string);\n\n    if ($length\
    \ <= 1) {\n        return 1;\n    }\n\n    $characters = array();\n\n    for ($i\
    \ = 0; $i < $length; $i++) {\n        $character = strtolower($string[$i]);\n\
    \        if (!array_key_exists($character, $characters)) {\n            $characters[$character]\
    \ = 0;\n        }\n        $characters[$character]++;\n    }\n\n    return count($characters);\n\
    }\n", "\t$string = strtolower($string);\n\t$string = $string ? preg_replace('/[^a-z0-9]+/i',\
    \ '', $string) : '';\n\treturn $string ? strlen($string) : 1;\n}\n", "    return\
    \ strlen(preg_replace('~^.+~', '', $string));\n}\n", "    $count = count(array_unique(str_split($string,\
    \ 1)));\n    if ($count == 0) {\n        $count = 0;\n    }\n    return $count;\n\
    }\n", "    return str_split($string, 1, null, false)\n        ->reduce(function\
    \ ($count, string $char) {\n            $count++;\n            return $count;\n\
    \        }, 0);\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not the most efficient\
    \ way to count distinct characters, as it will split the string into an array,\
    \ then recombine it, as opposed to counting the characters from the original string,\
    \ which is way faster.\n<|/ c |>\n<| c |>\n, thanks for the heads-up. I will make\
    \ an edit and fix that immediately.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution\
    \ which only splits a string once (which is much more efficient than counting\
    \ characters from the original string for each character):\n<code>", "    $length\
    \ = 0;\n    foreach(str_split($string) as $char) {\n        $length += mb_strlen($char,\
    \ 'UTF-8');\n    }\n\n    return $length;\n}\n\n$string = 'abracadabra';\nvar_dump(strlen($string));\n\
    \n$string = 'abracadabra';\nvar_dump(count_distinct_characters($string));\n</code>\n\
    <|/ a tags=php dscore=5 |>\n<| c |>\nThis is only returning the first character\
    \ in the string and not the full string\n<|/ c |>\n<| c |>\nI actually don't know\
    \ why... I used it for years and never had a problem\n<|/ c |>\n<| c |>\nit gives\
    \ me this error : Warning: count(): Parameter must be an array or an object that\
    \ implements Countable in\n<|/ c |>\n<| c |>\nThis only returns \"A\" because\
    \ `strlen()` returns the number of bytes the string occupies. If you want to count\
    \ the number of characters then `mb_strlen()` or `mb_strlen()`\n<|/ c |>\n<| a\
    \ dscore=5 tags=php |>\nFor PHP >= 7.2 you can use mb_strlen()\n<code>\n$string\
    \ = 'abracadabra';\nvar_dump(mb_strlen($string));\n</code>\n<|/ a |>\n<| c |>\n\
    I think it should be `var_dump(mb_strlen($string, 'UTF-8'));`\n<|/ c |>\n<| a\
    \ dscore=4 |>\nYou can use this function \n<code>", "    // count the number of\
    \ characters\n    $count = count($string);\n    // initialize array for storing\
    \ the result\n    $distinct_characters = array();\n\n    // loop through all characters\
    \ in the string\n    for ($i = 0; $i < $count; $i++) {\n        // get the character\
    \ at position $i\n        $character = $string[$i];\n        // check if the character\
    \ is in the array\n        if (in_array($character, $distinct_characters)) {\n\
    \            // if it is, increment the counter\n            $distinct_characters[$character]++;\n\
    \        } else {\n            // if it isn't, add it to the array\n         \
    \   $distinct_characters[$character] = 1;\n        }\n    }\n\n    // return the\
    \ count of distinct characters\n    return count($distinct_characters);\n}", " \
    \   return count(array_count_values(str_split($string)));\n}\n", "    $distinct_characters\
    \ = array_count_values(str_split($string));\n    return array_sum(array_keys($distinct_characters));\n\
    }\n</code>\nThis gives you a much cleaner syntax that doesn't require any manual\
    \ parsing of the string. Of course you will have to modify the function to suit\
    \ your specific needs.\n<|/ a dscore=1 tags=php,algorithm,string |>\n<| a tags=php,algorithm,string\
    \ |>\nUsing a simple foreach() loop:\n<code>", "    if (is_null($string)) {\n\
    \        return 0;\n    }\n\n    $chars = preg_split('//u', $string);\n\n    return\
    \ count($chars);\n}\n</code>\n<|/ a dscore=1 tags=php,string,regex |>\n<| c |>\n\
    What do you do if the string contains multiple `\xA3`? You get wrong result.\n\
    <|/ c |>\n<| c |>\nI already added a solution for that. Didn't know about the\
    \ `preg_split` function before, so thank you! :)\n<|/ c |>\n<| a tags=php,string,regex\
    \ dscore=1 |>\nYou could use preg_split with unicode flag as in documentation:\n\
    <code>\n$string = 'abc\xA3def\xA3ghi\xA3jkl\xA3mno\xA3pqr\xA3tuv\xA3wxy\xA3zyz';\n\
    $charsCount = preg_split(\"//u\", $string, -1, PREG_SPLIT_NO_EMPTY);\nprint_r($charsCount);\n\
    </code>\nOutput:\n<code>\nArray\n(\n    [0] => abc\n    [1] => def\n    [2] =>\
    \ ghi\n    [3] => jkl\n    [4] => mno\n    [5] => pqr\n    [6] => tuv\n    [7]\
    \ => wxy\n    [8] => zyz\n)\n</code>\nDemo\n<|/ a |>\n<| c |>\nI already added\
    \ a solution for that. Didn't know about the `preg_split` function before, so\
    \ thank you! :)\n<|/ c |>\n<| a |>\nTo get the number of distinct characters,\
    \ you could use preg_replace() with \\X to match all non-word characters and use\
    \ \\w to match any word characters (and \\s to match whitespaces) and add them\
    \ up:\n<code>\npreg_replace('/\\X\\w+/', null, 'abc\xA3def\xA3ghi\xA3jkl\xA3mno\xA3\
    pqr\xA3tuv\xA3wxy\xA3zyz');\n</code>\nOutput:\n<code>\n8\n</code>\nDemo\n<|/ a\
    \ dscore=0 tags=php,string,regex |>\n<| c |>\nI already added a solution for that.\
    \ Didn't know about the `preg_replace` function before, so thank you! :)\n<|/\
    \ c |>\n<| a tags=php,string,regex |>\nYou could use preg_match_all with your\
    \ pattern to fetch all non-word characters using \\W+\nCode:\n<code>\n$string\
    \ = 'abc\xA3def", "    return count(array_count_values(str_split(strtolower($string))));\n\
    }\n", "    $chars = $matches = [];\n    // Count how many times each character\
    \ appears in the string.\n    foreach (preg_split('//u', $string) as $c) {\n \
    \       if (isset($chars[$c])) {\n            $chars[$c]++;\n        } else {\n\
    \            $chars[$c] = 1;\n        }\n    }\n    // Count the unique characters.\n\
    \    $distinct_chars = 0;\n    foreach ($chars as $k => $v) {\n        if ($v\
    \ > 1) {\n            $distinct_chars += $v;\n            $matches[$k] = $v;\n\
    \        }\n    }\n    return $distinct_chars;\n}", "    // This could be done\
    \ much quicker with regex, but this should do fine\n    $count = count($string);\n\
    \    $hash = [];\n    foreach ($string as $value) {\n        $hash[$value] = isset($hash[$value])\
    \ ? $hash[$value] + 1 : 1;\n    }\n    return $count;\n}\n</code>\nThis could\
    \ be further improved with a better data structure, like a hash table, but it\
    \ doesn't seem that this is necessary.\n<|/ a dscore=0 |>\n<| c |>\nThis answer\
    \ is correct. Not sure why it was downvoted. +1 from me :)\n<|/ c |>\n<| c |>\n\
    I think he wants the number of different characters, not the number of unique\
    \ characters. So that would be 5 (two x's and one l).\n<|/ c |>\n<| c |>\nThis\
    \ solution also works as I expected! Thanks for the answer!\n<|/ c |>\n<| c |>\n\
    : Oh, I see what you're saying. I misunderstood the OP's question. I'll update\
    \ the answer accordingly.\n<|/ c |>\n<| c |>\nI think you got the point correctly.\
    \ Thanks for the answer!\n<|/ c |>\n<| a |>\n<code>\n$string = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n", "    if (strlen($string) === 0) return 0;\n    $chars = preg_split('//u',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY);\n    return count(array_filter($chars, create_function('$char',\
    \ 'return ctype_upper($char);')));\n}\n</code>\n<|/ a tags=string,count,php |>\n\
    <| c |>\nI really like this solution, but i find it slightly slower than the function\
    \ i already have. I'll use it. Thank you.\n<|/ c |>\n<| c |>\nI did some benchmarking\
    \ and the function i already have is really fast. Not bad.\n<|/ c |>\n<| a tags=string,count,php\
    \ |>\nI think your best bet would be to run a test and check how long it takes\
    \ each function to execute.\n<|/ a dscore=1 |>\n<| a |>\nI would create a table\
    \ with the letters of the alphabet and check it against the string being passed\
    \ in. Then count the amount of records in the table. If it's below a certain amount\
    \ (or above a certain amount), it's unique. \nA query like this would take milliseconds\
    \ to execute in MySQL.\n<code>\nSELECT COUNT(DISTINCT colname) FROM tableName\n\
    </code>\n<|/ a tags=string,count,php dscore=0 |>\n<| c |>\nI need a function or\
    \ algorithm that works for any given string and any given character and any given\
    \ alphabet. I don't necessarily want to create a table just to test if a character\
    \ is unique.\n<|/ c |>\n<| a |>\nI've tried different approaches, but ended up\
    \ with the simplest one (without using regexps etc.).\n<code>", "    return strlen($string)\
    \ - str_split($string, 1).strlen($string);\n}\n</code>\n<|/ a |>\n<| c |>\nI think\
    \ there's a bug with str_repeat(), if the string is `abb`, it will return `abbb`\
    \ instead of `aabb`\n<|/ c |>\n<| a |>\nHere's a solution I came up with that\
    \ doesn't require a loop.\n<code>\n<?php\n\n$string = \"Hello World!\";\n", " \
    \   return preg_match_all('/./us', $string, $matches) ? count($matches[0]) : 0;\n\
    }\n", "    $chars = preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY);\n\n  \
    \  $distinct_chars = array();\n    foreach ($chars as $char) {\n        if (!isset($distinct_chars[strtolower($char)]))\
    \ {\n            $distinct_chars[strtolower($char)] = 0;\n        }\n        $distinct_chars[strtolower($char)]++;\n\
    \    }\n\n    return count($distinct_chars);\n}", "    $chars = '';\n    foreach\
    \ (str_split($string) as $char) {\n        $chars .= strtolower($char);\n    }\n\
    \    return substr_count($chars, 'a');\n}\n", "    return count(preg_split('//u',\
    \ $string));\n}\n", "    if (empty($string)) {\n        return 0;\n    }\n\n \
    \   // Count occurrences of all characters\n    $counts = array_count_values(str_split($string));\n\
    \n    // Return count of characters\n    return array_sum($counts);\n}\n", " \
    \   if (is_null($string)) return 0;\n    $chars = preg_split('//u', $string, -1,\
    \ PREG_SPLIT_NO_EMPTY);\n    return count(array_unique($chars));\n}\n", "\treturn\
    \ preg_match_all('/./u', $string, $matches) ? count($matches[0]) : 0;\n}\n", " \
    \   $length = strlen($string);\n    $count_array = array();\n    for ($i = 0;\
    \ $i < $length; $i++) {\n        $char = strtolower($string[$i]);\n        if\
    \ (!isset($count_array[$char])) {\n            $count_array[$char] = 0;\n    \
    \    }\n        $count_array[$char] += 1;\n    }\n    return count($count_array);\n\
    }\n", "  return array_count_values(str_split($string));\n}\n", "    $count = 1;\n\
    \    foreach (preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY) as $char) {\n\
    \        $char = (int)$char;\n        if ($char === 65 || $char === 97 || $char\
    \ === 97 || $char === 122) $count++;\n    }\n    return $count;\n}", "    $characters\
    \ = '';\n    $strings = str_split($string);\n    foreach ($strings as $s) {\n\
    \        $characters .= preg_replace('/[^a-z]/', '', $s);\n    }\n    return count($characters);\n\
    }\n</code>\n<|/ a tags=php,sql,mysql |>\n<| c |>\nThanks Mike, but I guess I wasn't\
    \ clear in my question. I need to be able to return the number of distinct characters\
    \ in every string in a table, not just for the first one.\n<|/ c |>\n<| c |>\n\
    Yes, I understand the question. That's why I posted my answer based on your comment.\
    \ Do you understand it? Do you see that I'm calling the function `count_distinct_characters()`?\n\
    <|/ c |>\n<| c |>\nYes I understand it, but I wasn't able to integrate it into\
    \ my existing code.\n<|/ c |>\n<| c |>\nI did it, but I guess I didn't fully understand\
    \ your code and wasn't able to figure out why it wasn't working for my actual\
    \ data. Once I fixed my actual data, it worked fine. Thanks for your help.\n<|/\
    \ c |>\n<| c |>\n: I added my answer (I hope).\n<|/ c |>\n<| a dscore=0 |>\nThis\
    \ should get you going in the right direction:\n<code>\nCREATE PROCEDURE `count_distinct_characters`(IN\
    \ _string TEXT CHARSET utf8)\nBEGIN\nDECLARE _total_characters BIGINT;\n\nSELECT\n\
    \  COUNT(*)\nINTO\n  _total_characters\nFROM\n  (SELECT\n    CHAR_LENGTH(REPLACE(REPLACE(REPLACE(REPLACE(_string,\
    \ '?', ''),'!', ''),'#', ''),'%', ''),'&', '') AS character_count\n  FROM\n  \
    \  (SELECT\n      string\n    FROM\n      my_table\n    ORDER BY\n      string\
    \ DESC) AS _my_table\n  )\nWHERE\n  character_count <> 0;\n\nSELECT\n  _total_characters;\n\
    \nEND\n</code>\n<|/ a tags=php,sql,mysql |>\n<| a tags=php,sql,mysql dscore=0\
    \ |>\n<code>\nSELECT DISTINCT LENGTH(REPLACE(REPLACE(REPLACE(REPLACE(str,'#',''),'%',''),'!',''),'&',''),'?',''))\
    \ AS char_count, count(*) FROM my_table;\n</code>\n<|/ a |>\n<| c |>\nWhile this\
    \ code may answer the question, providing additional context regarding why ",
  "    if ($string == '') {\n        return 0;\n    }\n    $counts = array_count_values(str_split($string));\n\
    \    $length = count($counts);\n    return $length < 2 ? 0 : $length; // if count\
    \ is zero or one, no need to check for the distinct characters\n}\n</code>\n<|/\
    \ a tags=php |>\n<| c |>\nWhat about this case: `'x'`?\n<|/ c |>\n<| c |>\n, thank\
    \ you, I didn't pay enough attention to the case\n<|/ c |>\n<| c |>\nAh I see\
    \ that now, thanks. It's not really clear to me what it's supposed to return,\
    \ since it appears to have nothing to do with what the OP is asking for, just\
    \ some code that does something else.\n<|/ c |>\n<| c |>\nThe OP wants to know\
    \ how many distinct characters there are in a given string. My solution does the\
    \ same, that's why I posted it\n<|/ c |>\n<| c |>\n, I've updated my answer to\
    \ include the counting code\n<|/ c |>\n<| a dscore=1 |>\nUse str_split() to count\
    \ the number of unique characters.\n<code>\n$str = \"hello\";\n$str_arr = str_split($str);\n\
    $unique = count($str_arr);\n</code>\n<|/ a tags=php |>\n<| c |>\nThe OP specifically\
    \ mentioned that they don't want to use array_count_values()\n<|/ c |>\n<| c |>\n\
    Oh I see, I missed that.\n<|/ c |>\n<| c |>\nI believe I read that the OP doesn't\
    \ want to *split* the string but count the number of distinct characters. But\
    \ now that I see the other answers, I guess it's just me.\n<|/ c |>\n<| c |>\n\
    Yeah, it's a bit unclear what they want. I just saw the comment about wanting\
    \ to count characters so I wanted to make sure I understood the question correctly.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\n$str = \"hello\";\n$str_arr = str_split($str);\n\
    $unique = count($str_arr);\n</code>\n<|/ a tags=php |>\n<| c |>\nThe OP specifically\
    \ mentioned that they don't want to use array_count_values()\n<|/ c |>\n<| a |>\n\
    <code>\n<?php\n$str = \"hello\";\n$str_arr = str_split($str);\n$unique = count($str_arr);\n\
    echo $unique;", "    $result = 0;\n    $characters = str_split($string);\n   \
    \ foreach ($characters as $char) {\n        if (ctype_upper($char)) {\n      \
    \      $result += 1;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nthank you for your help\n<|/ c |>\n<| a dscore=0 |>\n\
    This is what works for me:\n<code>\n<?php\n$string = str_replace(array(\"e\",\
    \ \"E\", \"i\", \"I\"), \"\", \"helloEyIy\");\n$string = ucfirst(strtolower($string));\n\
    $string = preg_replace(\"/([^a-zA-Z])/\", \"\", $string);\n$string = preg_replace(\"\
    /([a-zA-Z])/\", \"_$0\", $string);\n$string = $string . \"s\";\necho strlen($string);\n\
    </code>\n<|/ a tags=php,string |>\n<| a dscore=0 tags=php,string |>\nI have been\
    \ using this for years now - \n<code>\nclass String\n{\n    public function count_distinct_characters($string)\n\
    \    {\n        $characters = str_split($string);\n        $count_chars = array_count_values($characters);\n\
    \        $chars_array = array();\n        foreach ($count_chars as $char_value=>$num_value)\n\
    \        {\n            $chars_array[] = $char_value;\n        }\n        $new_chars_array\
    \ = array_count_values($chars_array);\n        return $new_chars_array[$char_value];\n\
    \    }\n}\n</code>\n<|/ a |>\n<| c |>\nPlease add some explanation as to why the\
    \ OP's code didn't work.\n<|/ c |>\n<| a dscore=0 tags=php,string |>\nThis code\
    \ will replace duplicate letters with \"_\" then add a \"s\" to the end of the\
    \ string.\n<code>\n$string = 'helloEyIy';\n$string2 = ucfirst(strtolower($string));\n\
    $string2 = preg_replace('/(.)/', '_$0', $string2);\n$string2 = preg_replace('/([a-z])/',\
    \ '_$0', $string2);\n$string2 = $string2 . \"s\";\necho strlen($string2);\n</code>\n\
    <|/ a |>\n<| a tags=php,string |>\nTry this one...\n<code>\n<?php\n$string = \"\
    helloEyIy\";\n$string=ucfirst(strtolower($string));\n$string = preg_replace('/([^a-zA-Z])/','',$string);\n\
    $string = preg_replace('/([a-zA-Z])/','_$0',$", "    $chars = array();\n    $letters\
    \ = str_split($string);\n    foreach ($letters as $letter) {\n        $chars[$letter]\
    \ = isset($chars[$letter]) ? $chars[$letter] + 1 : 1;\n    }\n    return count(array_keys($chars));\n\
    }\n", "    $characters = $count = array();\n    $length = strlen($string);\n \
    \   for ($i = 0; $i < $length; $i++) {\n        $char = strtolower($string[$i]);\n\
    \        $count[$char] = isset($count[$char]) ? $count[$char] + 1 : 1;\n     \
    \   $characters[$char] = $char;\n    }\n    return array_sum(array_keys($count));\n\
    }\n", "    $characters = [];\n    foreach (str_split($string) as $character) {\n\
    \        $characters[$character] = isset($characters[$character]) ? $characters[$character]\
    \ + 1 : 1;\n    }\n\n    return array_sum(array_keys($characters));\n}\n\n/**\n\
    \ * Returns true if the given string is a valid URL.\n *\n * @param string $str\n\
    \ * @return boolean\n */", "  // If there are no characters, return 0\n  if (empty($string))\
    \ return 0;\n  // Return 1 + the length of the string\n  return 1 + count_unique_characters($string);\n\
    }\n", "    if (!is_string($string)) return 0;\n    $distinctCharacters = preg_match_all('/.\\\
    B/', $string);\n    return ($distinctCharacters);\n}\n", "    return count(array_count_values(str_split($string)));\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI think your code is wrong. For example: count_distinct_characters('Jerry')\
    \ returns 4 but should be 2.\n<|/ c |>\n<| c |>\nI ran the code and got 2. How\
    \ would you get 4? I assumed that's what the OP wanted.\n<|/ c |>\n<| c |>\nI\
    \ think it was unclear what the desired output is - I thought that 'Jerry' should\
    \ be counted as 2.\n<|/ c |>\n<| c |>\nYeah, I've noticed the confusion. But I've\
    \ updated my answer so hopefully it's clear now. Thanks for your input.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nYou might consider a regular expression for this task.\
    \ It should work for both upper- and lowercase letters, numbers and special characters.\
    \ However, it also counts words as single characters, meaning that \"John\" gets\
    \ counted as two. \"Jerry\" gets counted as four, etc.\n<code>\npreg_match_all('~([a-z]+|[A-Z]+|[0-9]+|[!@#\\\
    $%\\^&\\*\\-_=\\+;:,\\.\\?\\'\\~\\(\\)\\[\\]\\{\\}\\\\\\|])~i', $subject, $matches);\n\
    </code>\n<|/ a tags=php,string,function |>\n<| c |>\nI think that this is an over-complicated\
    \ solution for what OP is trying to do. For example, `preg_match` matches a regex\
    \ against a string, not a single character. Also, it's overly complex because\
    \ of the need to escape characters with special meaning in regexes.\n<|/ c |>\n\
    <| c |>\nThat's not what OP wants - he wants to count characters, not words.\n\
    <|/ c |>\n<| c |>\nIt's not even a complicated solution, just too complicated\
    \ - see my answer. It could be simplified a lot, but as it is it will still work\
    \ for the OP's specific example (albeit, probably with some edge cases).\n<|/\
    \ c |>\n<| c |>\nOkay, the answer was accepted and I learned something too. But\
    \ I still think that it might be overkill for what OP wants. I think that's what\
    \ he meant with his comment about it being for beginners. Anyway, my comment was\
    \ meant as a little note for future visitors, not as an absolute rule.\n<|/ c\
    \ |>\n<| c |>\nThe original answer was accepted so I guess that your answer is\
    \ even better", "    $counts = array_count_values(str_split($string));\n    return\
    \ $counts;\n}\n", "    $counter = 0;\n    for($i = 0; $i < strlen($string); $i++)\
    \ {\n        $counter++;\n        for($j = $i+1; $j < strlen($string); $j++) {\n\
    \            if($string[$i] == $string[$j]) {\n                ++$counter;\n \
    \           }\n        }\n    }\n    return $counter;\n}\n", "  return count(preg_split('//u',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY));\n}\n", "    $distinct = array();\n    $stringLength\
    \ = strlen($string);\n    for ($i = 0; $i < $stringLength; $i++) {\n        $char\
    \ = strtoupper(substr($string, $i, 1));\n        if (!isset($distinct[$char]))\
    \ {\n            $distinct[$char] = 0;\n        }\n        $distinct[$char]++;\n\
    \    }\n\n    return count(array_keys($distinct));\n}", "  // return '' if no\
    \ characters, otherwise returns number of distinct characters out of all characters\
    \ in $string\n  if(empty($string)) return '';\n\n  $len = strlen($string);\n \
    \ if($len == 0) return 0;\n\n  $unique_chars = array();\n  foreach(str_split($string)\
    \ as $char) {\n    if(!in_array($char, $unique_chars)) $unique_chars[] = $char;\n\
    \  }\n\n  return count($unique_chars);\n}\n", "    $string = strtolower($string);\n\
    \    $string  = preg_replace('/[^a-z]+/i', '', $string); // remove all non-alphabetical\
    \ characters\n    $string  = preg_replace('/[^A-Z]+/i', '', $string); // remove\
    \ all non-alphabetical characters\n    $string  = preg_replace('/[^0-9]+/i', '',\
    \ $string); // remove all non-numeric characters\n    return strlen($string);\n\
    }\n", "    return preg_match('/(.)\\1+/', $string) ? count(explode('\"', $string,\
    \ -1)) : 0;\n}\n</code>\nTo make it a bit more efficient (in terms of space),\
    \ we could use strlen instead of count\n<code>", "    $strlen = strlen($string);\n\
    \    if ($strlen == 0) return 0;\n    $array = array();\n    for ($i = 0; $i <\
    \ $strlen; $i++) $array[] = strtolower($string[$i]);\n    return count(array_unique($array));\n\
    }\n", "    $count = preg_match_all('/.(?=.*(.))/', $string, $matches);\n    return\
    \ $count-1;\n}\n", "    // Split string into an array with each character in its\
    \ own element\n    // >>> str_split('xyzXYZ')\n    // [ 'x', 'y', 'z', 'x', 'y',\
    \ 'z' ]\n    return array_count_values(str_split($string));\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis works quite well. Although it does not allow for\
    \ characters like '\xF8' or '\xC6'.\n<|/ c |>\n<| c |>\nThis is definitely the\
    \ right answer to the question asked.\n<|/ c |>\n<| a tags=php dscore=4 |>\nThis\
    \ counts the number of unique characters in a given string. \n<code>\n$charArray\
    \ = str_split($string);\n$unique = array();\nforeach ($charArray as $char)\n{\n\
    \    if (!in_array($char, $unique))\n    {\n        $unique[] = $char;\n    }\n\
    }\nreturn count($unique);\n</code>\n<|/ a |>\n<| c |>\nThis will add '\xE0' to\
    \ your count. You may want to use mb_strtolower() to make '\xE0' lower case before\
    \ using str_split.\n<|/ c |>\n<| c |>\nJust a note: if you use utf8_encode(string)\
    \ instead of str_split it will take in all unicode characters and convert them\
    \ to ascii characters. So if you pass \"a\xF9\", it will return 1 instead of 2.\
    \ If you only want to take in ascii characters, use str_split(mb_strtolower(utf8_encode($string))).\n\
    <|/ c |>\n<| c |>\nThis will fail if any of the characters are multi-byte characters.\
    \ E.g., `'\u20AC'` will not be counted correctly.\n<|/ c |>\n<| c |>\n: You mean\
    \ `str_split()` instead of `mb_str_split()`? I thought `str_split()` would handle\
    \ multibyte characters just fine.\n<|/ c |>\n<| c |>\nIt's actually the other\
    \ way around. `mb_str_split()` doesn't convert multibyte characters to ASCII,\
    \ and `str_split()` does.\n<|/ c |>\n<| a tags=php |>\nHere is an alternative\
    \ solution that is more memory efficient and performs quicker than the other methods\
    \ listed.\n<code>", "    return preg_match_all('/\\B/', $string);\n}\n", "   \
    \ $num_chars = array_count_values(str_split($string));\n    $num_chars = $num_chars[''];\n\
    \    return count($num_chars);\n}\n", "    return count(array_unique(str_split(strtolower($string))));\n\
    }\n", "  $distinctCharacters = array();\n  foreach(str_split($string) as $char)\
    \ {\n    if (!in_array($char, $distinctCharacters)) {\n      $distinctCharacters[]\
    \ = $char;\n    }\n  }\n  return count($distinctCharacters);\n}\n", "\treturn\
    \ strlen(preg_replace('~(.)\\1+~', '$1', $string));\n}\n", "  // Make sure we\
    \ have a non-empty string\n  if (!is_string($string)) {\n    return -1;\n  }\n\
    \n  // Count how many distinct characters are in this string regardless of case\n\
    \  $chars = array_count_values(str_split(strtolower($string)));\n  return count(array_filter($chars,\
    \ function($value) {\n    return $value > 1;\n  }));\n}\n</code>\n<|/ a dscore=0\
    \ tags=php,string |>\n<| a dscore=0 |>\n<code>\n<?php\n", "    return array_count_values(str_split($string));\n\
    }\n</code>\n<|/ a tags=php,arrays,foreach |>\n<| c |>\nThis doesn't work.  You\
    \ need `array_count_values` after your initial `array_filter`.  The second `array_filter`\
    \ is still doing the filtering, not counting the number of unique characters.\n\
    <|/ c |>\n<| a tags=php,arrays,foreach dscore=3 |>\nIf you wan't to count all\
    \ unique characters, use's answer. \nIf you wan't to count unique characters in\
    \ specific part of string, I guess this will do the trick:\n<code>\n$string =\
    \ 'Hello World';\n$string2 = 'Hello World';\n\n$string3 = 'Hello World';\n$string4\
    \ = 'Hello World';\n$string5 = 'Hello World';\n\n$string6 = 'He llllo World';\n\
    \n$string7 = 'He llllo WoRlD';\n\n$string8 = 'He llllo WOrld';\n\n$string9 = 'He\
    \ llllo WorLd';\n\n$string10 = 'He llllo WOrld';\n\n$string11 = 'He llllo World';\n\
    \n$string12 = 'He llllo World';\n\n$string13 = 'Hello World';\n\n$string14 = 'Hello\
    \ World';\n\n$string15 = 'Hello World';\n\n$string16 = 'He llllo World';\n\n$string17\
    \ = 'He llllo WoRlD';\n\n$string18 = 'He llllo WOrld';\n\n$string19 = 'He llllo\
    \ WorLd';\n\n$string20 = 'He llllo WOrld';\n\n$string21 = 'He llllo World';\n\n\
    $string22 = 'He llllo World';\n\n$string23 = 'Hello World';\n\n$string24 = 'Hello\
    \ World';\n\n$string25 = 'Hello World';\n\n$string26 = 'He llllo World';\n\n$string27\
    \ = 'He llllo WoRlD';\n\n$string28 = 'He llllo WOrld';\n\n$string29 = 'He llllo\
    \ WorLd';\n\n$string30 = 'He llllo WOrld';\n\n$string31 = 'He llllo World';\n\n\
    $string32 = 'He llllo World';\n\n$string33 = 'Hello World';\n\n$string34 = 'Hello\
    \ World';\n\n$string35 = 'Hello World';\n\n", "    return preg_match_all('/([A-Z]+)/',\
    \ $string, $matches) ? count($matches[1]) : 1;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nTo find the number of distinct characters (regardless of case)\
    \ in a string, I used the method given here: http://phpjs.org/functions/count_chars:523\n\
    <code>", "    return (int)preg_match_all('/^(.)\\1{2,}$/i', $string);\n}\n</code>\n\
    The regex will match the first character and then match it twice, followed by\
    \ another character, and so forth.\n<|/ a dscore=1 |>\n<| c |>\nThis is amazing.\
    \ Thank you. Do you know how I could incorporate this into my code? I'm not really\
    \ sure where to start with this\n<|/ c |>\n<| c |>\nDo you know how I could incorporate\
    \ this into my code? I'm not really sure where to start with this.\n<|/ c |>\n\
    <| c |>\nI've added an explanation of the regex\n<|/ c |>\n<| c |>\nI actually\
    \ see what you mean now that you've explained it so thank you. However, when I\
    \ try to use this in my code it gives me the following error: preg_match_all():\
    \ Delimiter must not be alphanumeric or backslash.\n<|/ c |>\n<| c |>\nCan you\
    \ post your updated code? The error is probably because your PHP code is using\
    \ single quotes rather than double quotes to surround the regex string\n<|/ c\
    \ |>\n<| a dscore=0 |>\nYou can use regex pattern to find repeated characters.\n\
    <code>\n<?php\n$str = \" hello how are you world \";\n\n$pattern = \"/(.)\\1\\\
    1\\1/\";\n\npreg_match($pattern, $str, $matches);\n\nprint_r($matches);", "  \
    \  $result = 1;\n    $len = mb_strlen($string, 'UTF-8');\n    for ($i = 0; $i\
    \ < $len; $i++) {\n        $char = mb_substr($string, $i, 1, 'UTF-8');\n     \
    \   $result *= (strtolower($char) == $char ? 26 : $char > 126 ? 2 : 1);\n    }\n\
    \    return $result;\n}\n", "    $unique_characters = array();\n    $i = 0;\n\n\
    \    while ($i < strlen($string)) {\n        $char = substr($string, $i, 1);\n\
    \        if (!in_array($char, $unique_characters)) {\n            $unique_characters[]\
    \ = $char;\n        } else {\n            $i++;\n        }\n    }\n\n    return\
    \ count($unique_characters);\n}\n</code>\n<|/ a |>\n<| a |>\nYou can't use the\
    \ same $string variable for different purposes.\nYou should change your function\
    \ to accept a parameter:\n<code>", "    return count(preg_split(\"//u\", $string));\n\
    }\n", "    return str_split($string);\n}\n", "    if (empty($string)) {\n    \
    \    return 0;\n    }\n    $chars = str_split(strtolower($string));\n    $count\
    \ = array();\n    foreach ($chars as $char) {\n        if (!isset($count[$char]))\
    \ {\n            $count[$char] = 1;\n        } else {\n            $count[$char]\
    \ += 1;\n        }\n    }\n    return count($count);\n}\n</code>\nThe second part\
    \ is to get the number of distinct characters for each of your target strings:\n\
    <code>", "    $counts = [];\n    $string = strtolower($string);\n    foreach (str_split($string)\
    \ as $char) {\n        if (!isset($counts[$char])) {\n            $counts[$char]\
    \ = 1;\n        } else {\n            $counts[$char] += 1;\n        }\n    }\n\
    \    return array_count_values($counts);\n}\n", "    return preg_match_all('/[[:lower:]]+/',\
    \ $string, $matches) ? count($matches[0]) : null;\n}\n", "    if (strlen($string)\
    \ == 0) {\n        return 0;\n    }\n    return array_count_values(str_split(strtolower($string)));\n\
    }\n", "    $counter = 0;\n    foreach ($string as $char) {\n        $counter++;\n\
    \    }\n    return $counter;\n}\n</code>\n<|/ a dscore=0 tags=php,mysql,sql,character,sql\
    \ |>\n<| a |>\n<code>\nSELECT \n    COUNT(*) count, \n    SUBSTRING_INDEX(SUBSTRING_INDEX(column,'\
    \ ',-1) ,' ',1) \nFROM \n    table;\n</code>\n<|/ a tags=php,mysql,sql,character,sql\
    \ dscore=0 |>\n<| a dscore=0 |>\nIt might be easier to split the string into a\
    \ list, then count the frequency of each value:\n<code>\nSELECT \n  SUBSTRING_INDEX(column,\
    \ ' ', -1) AS word,\n  COUNT(DISTINCT SUBSTRING_INDEX(column, ' ', -1)) AS frequency\n\
    FROM \n  table;\n</code>\n<|/ a tags=php,mysql,sql,character,sql |>\n<| a dscore=0\
    \ tags=php,mysql,sql,character,sql |>\nUsing a variable to store previous value\
    \ and incrementing it by one each time will give you the number of unique characters\
    \ in a string.\n<code>\n    DELIMITER $$\n\nDROP FUNCTION IF EXISTS `count_distinct_characters`$$\n\
    CREATE FUNCTION `count_distinct_characters`(str VARCHAR(255)) RETURNS INT\nBEGIN\n\
    \  DECLARE str VARCHAR(255);\n  DECLARE prev_char VARCHAR(255);\n  DECLARE cnt\
    \ INT;\n  DECLARE i INT;\n  SET cnt = 0;\n  SET i = 0;\n  WHILE i < LENGTH(str)\
    \ DO\n    SET str = SUBSTRING(str, i, 1);\n    IF str = prev_char THEN\n     \
    \ SET cnt = cnt + 1;\n    END IF;\n    SET i = i + 1;\n    SET prev_char = str;\n\
    \  END WHILE;\n  RETURN cnt;\nEND$$\n\nDELIMITER ;\n</code>\n<|/ a |>\n<| a |>\n\
    <code>\nSELECT SUM(LENGTH(word) - LENGTH(REPLACE(word,' ',''))) AS unique_chars\n\
    FROM table\n</code>\n<|/ a tags=php,mysql,sql,character,sql dscore=0 |>\n<| c\
    \ |>\nThis answer would be more useful if you elaborated on how it works.\n<|/\
    \ c |>\n<| a tags=php,mysql,sql,character,sql dscore=0 |>\n<code>\nCREATE FUNCTION\
    \ `countuniquechar`(word VARCHAR(255))\nRETURNS INT\nRETURN COUNT(DISTINCT word);\n",
  "    return preg_match_all('/[[:^alpha:]]/', $string) + preg_match_all('/[[:^alphanum:]]/',\
    \ $string) + preg_match_all('/[[:^digit:]]/', $string);\n}\n", "  $num_distinct\
    \ = 0;\n  $character_sets = array_map('strtolower', str_split($string));\n  foreach\
    \ ($character_sets as $character_set) {\n    $num_distinct += count(array_filter($character_set));\n\
    \  }\n  return $num_distinct;\n}\n</code>\n<|/ a |>\n<| a |>\nI was using php\
    \ and have come across this problem and found that there were two possible solutions\
    \ to this. In some cases the second solution would be the better solution. This\
    \ solution would give the correct result for both upper and lower case as well\
    \ as no whitespace or punctuation at all.\nThe first solution is to find the string\
    \ length and divide it by 2 to get the number of times the string is repeated\
    \ and subtract that from the string length. For example \"ABBCA\" has length 5\
    \ but we only want two B's so the total number of B's is 5-1=4. The code below\
    \ is then used to find the number of B's and subtract 1 from the length.\nThe\
    \ second solution is to first convert the string to lowercase and then find out\
    \ how many times each character appears. The code below is then used to find how\
    \ many times each character appears and then sum them up and divide by 2 to find\
    \ the number of times each character appears then subtract 1 from the length.\
    \ \n<code>\n$string_length = strlen($string);\n$string = \"ABBCA\";\n$character_sets\
    \ = array_map('strtolower', str_split($string));\n$unique_character_counts = array_count_values($character_sets);\n\
    \n$total_unique_character_counts = array_sum($unique_character_counts);\n$number_of_unique_characters\
    \ = $total_unique_character_counts - 1;\n$number_of_unique_characters = $number_of_unique_characters\
    \ / 2;\n</code>\n<|/ a dscore=2 tags=php,python,algorithm,string |>\n<| a |>\n\
    Using Regex to get number of occurrence\n<code>\n$str = \"ABBCA\";\n$pattern =\
    \ '/./';\npreg_match_all($pattern, $str, $matches);\n$count_occurrence = count($matches[0]);\n\
    </code>\n<|/ a dscore=2 tags=php,python,algorithm,string |>\n<| a dscore=1 |>\n\
    <code>\nlen(set(string))\n</code>\nis probably the simplest solution\n<|/ a tags=php,python,algorithm,string\
    \ |>\n<| c |>\nThis only works for unique characters.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. The same string can appear multiple times. But it does work as long\
    \ as there are no duplicate characters (which it seems is implied by the OP)\n\
    <|/ c |>\n<| a |>\nPython ", "  return preg_match_all('/[A-Z]+/', $string);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for the explanation. Was confused\
    \ about how to do this.\n<|/ c |>\n<| a dscore=2 tags=php,string,algorithm,arrays\
    \ |>\nYou can use a regex to match all possible cases of capitalized letters.\
    \ Then just count the number of matches:\n<code>\n$string = 'This is a test string';\n\
    $matches = preg_match_all('/[[:upper:]]+/', $string);\n\necho $matches;\n</code>\n\
    <|/ a |>\n<| c |>\nI like this one. I was trying to come up with a way without\
    \ using regex, but couldn't quite figure out a way. Thanks!\n<|/ c |>\n<| a |>\n\
    Here is a solution using a hash to count the letters.\n<code>\n$string = \"Hello,\
    \ this is a test string\";\n\n$counts = array_count_values(str_split($string));\n\
    \nvar_dump($counts);\n</code>\nOutput\n<code>\narray(3) {\n  [\"H\"]=>\n  int(1)\n\
    \  [\"i\"]=>\n  int(1)\n  [\"t\"]=>\n  int(2)\n}\n</code>\n<|/ a tags=php,string,algorithm,arrays\
    \ dscore=2 |>\n<| c |>\nWhile I didn't end up using this method, it's extremely\
    \ helpful for anyone else who comes across this question and needs a similar solution.\
    \ Thank you!\n<|/ c |>\n<| a dscore=0 |>\nHere is a working code\n<code>\n$string\
    \ = 'This is a test string';\n$chars = str_split($string);\n$charsCount = array();\n\
    \nforeach($chars as $char){\n    if(!array_key_exists($char, $charsCount)){\n\
    \        $charsCount[$char] = 1;\n    }else{\n        $charsCount[$char] += 1;\n\
    \    }\n}\n</code>\n<|/ a tags=php,string,algorithm,arrays |>\n<| a |>\n<code>\n\
    <?php\n$string = 'This is a test string';\n$chars = str_split($string);\n$charsCount\
    \ = array();\n\nforeach($chars as $char){\n    if(!array_key_exists($char, $charsCount)){\n\
    \        $charsCount[$char] = 1;\n    }else{\n        $charsCount[$char] += 1;\n\
    \    }\n}\n\necho '<pre>';\nprint_r($charsCount);\necho '</pre>';\n", "    return\
    \ count(preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY));\n}\n", "    if (!is_string($string))\
    \ {\n        return 0;\n    }\n\n    $unique_chars = array_count_values(str_split($string));\n\
    \    return count(array_filter($unique_chars, function($val) { return $val > 1;\
    \ }));\n}\n</code>\nIf you wanted a more generic implementation you could do something\
    \ like:\n<code>", "    return count(array_filter(array_unique(str_split($string)),\
    \ function($char) { return !is_numeric($char); }));\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 tags=php,count,character,unique,string |>\nThis works:\n<code>\n\
    echo strlen(preg_replace('~[^A-Za-z]~', '', $string));\n</code>\n<|/ a |>\n<|\
    \ a tags=php,count,character,unique,string |>\n<code>", "  $unique_characters\
    \ = array();\n  foreach (str_split($string) as $char) {\n    if (!in_array($char,\
    \ $unique_characters)) {\n      $unique_characters[] = $char;\n    }\n  }\n  return\
    \ count($unique_characters);\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis isn't\
    \ the right answer, because it isn't the question that was asked. Rather, this\
    \ is the right answer to the wrong question.\n<|/ c |>\n<| c |>\n: Yeah, but this\
    \ answer is what was asked and what was the right answer ;)\n<|/ c |>\n<| c |>\n\
    : I hope you realize that you're actually giving credit to Kenny G. for providing\
    \ this answer to the question that was asked.\n<|/ c |>\n<| c |>\n- I see what\
    \ you mean. Nothing personal, but I assumed it would be nice to have some sort\
    \ of explanation that would lead users to either change the question or to provide\
    \ an answer (to either of these two).\n<|/ c |>\n<| c |>\n: I didn't think of\
    \ the possibility of someone being asked to revise the answer by adding some explanation,\
    \ so I did just that. My bad. :)\n<|/ c |>\n<| a |>\nHere's a solution that just\
    \ uses PHP:\n<code>\n<?php", "    return preg_match_all('/./u', $string, $matches)\
    \ ? count($matches[0]) : null;\n}\n", "    $result = 0;\n    if (is_string($string)\
    \ && strlen($string) > 0) {\n        for ($i = 0; $i < strlen($string); $i++)\
    \ {\n            $char = strtolower($string[$i]);\n            $result += (is_numeric($char))\
    \ ? strlen($char) : 1;\n        }\n    }\n    return $result;\n}", "    return\
    \ preg_match_all('/[A-Z]+/', $string) - preg_match_all('/[a-z]+/', $string);\n\
    }\n", "    return mb_strlen(preg_replace('/[\\x80-\\xFF]/', \"\", $string), \"\
    UTF-8\");\n}\n", "    $result = 0;\n    $count = strlen($string);\n    for ($i\
    \ = 0; $i < $count; $i++) {\n        $result += (bool)($string[$i] >= 'A' && $string[$i]\
    \ <= 'Z') + (bool)($string[$i] >= 'a' && $string[$i] <= 'z');\n    }\n    return\
    \ $result;\n}\n", "\t$chars = '';\n\tfor ($i = 0; $i < strlen($string); $i++)\
    \ {\n\t\t$chars .= strtolower($string[$i]);\n\t}\n\treturn strlen($chars);\n}",
  "    $count = 0;\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char\
    \ = strtolower($string[$i]);\n        $char = strtoupper($char);\n        if ($char\
    \ !== $string[$i]) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }\n", "    $characters = str_split($string);\n    $characterCount = array();\n\
    \    foreach($characters as $character) {\n        if (!array_key_exists($character,\
    \ $characterCount)) {\n            $characterCount[$character] = 0;\n        }\n\
    \        $characterCount[$character]++;\n    }\n    return count($characterCount);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThat does not take into account the length of each\
    \ word, which is crucial for the application.\n<|/ c |>\n<| c |>\nThat's why I\
    \ used str_split(), which takes into account the length of each word.  str_split()\
    \ returns an array of strings, and each string has a length.  I updated my answer.\n\
    <|/ c |>\n<| c |>\nOkay, I see where you were going with the new example, but\
    \ I still have no idea how to implement it.  I am only just starting out with\
    \ PHP.  It is a little beyond my skill level.  Can you give an example using my\
    \ example above?\n<|/ c |>\n<| c |>\nThis code should work fine as long as your\
    \ strings are only single words.  If you have multiple words, you need to change\
    \ `$characterCount[$character]++; $characterCount[$character] +=count($characters);`\
    \ to `$characterCount[$character]++; $characterCount[$character] += $stringlength;`\n\
    <|/ c |>\n<| c |>\nHmmm.  It is not counting anything.  I added a couple of lines\
    \ of code right before your echo line: `$string = $_POST['string'];  $stringlength\
    \ = strlen($string);\n$words = preg_replace(\"/[^A-Za-z]+/\", \"\", $string);\n\
    $characterCount = count_distinct_characters($words);\necho $characterCount;` \
    \ Nothing happens when I submit the form.\n<|/ c |>\n<| a |>\nA more efficient\
    \ approach is to count the occurrence of each character (using str_split):\n<code>\n\
    <?php\n", "    return strlen($string);\n}", "    $character_count = array();\n\
    \    foreach(str_split($string) as $character) {\n        if (!array_key_exists($character,\
    \ $character_count)) {\n            $character_count[$character] = 1;\n      \
    \  } else {\n            $character_count[$character]++;\n        }\n    }\n \
    \   return count($character_count);\n}\n", "  $counter = 0;\n  for ($i = 0; $i\
    \ < strlen($string); $i++) {\n    if (mb_strtolower($string[$i]) === mb_strtolower($string[$i\
    \ + 1])) {\n      $counter++;\n    }\n  }\n\n  return $counter;\n}\n</code>\n\
    <|/ a tags=php,string dscore=0 |>\n<| a tags=php,string |>\nThis is a bit late\
    \ to the party, but I have created a function that works in all cases, including\
    \ uppercase and lowercase strings, all special characters and non-printable characters.\
    \ You can change the delimiters used in the substr or str_replace functions to\
    \ whatever you like.\n<code>", "  return (strtolower($string) - strtolower($string[0]))\
    \ * 2654435769;\n}\n", "    return strlen($string) - count_chars($string, false);\n\
    }\n\n/**\n * Get the maximum width of a column in a database table\n *\n * @param\
    \ string $table the table name\n * @param string $column the column name\n * @param\
    \ boolean $utf8 if true, the string will be treated as utf8\n * @return int\n\
    \ */", "    return preg_match_all('/\\p{L}+/', $string, $matches) ? count($matches[0])\
    \ : 0;\n}\n", "    // Loop through the string and store how many times each character\
    \ occurs\n    $frequency = [];\n    foreach (str_split($string) as $character)\
    \ {\n        $frequency[$character] = isset($frequency[$character]) ? $frequency[$character]\
    \ + 1 : 1;\n    }\n\n    // Return the count of distinct characters\n    return\
    \ count($frequency);\n}\n", "    $counter = 0;\n    foreach($string as $character)\
    \ {\n        $counter++; if($counter > 1) return $counter;\n    }\n    return\
    \ 1;\n}", "    $characters = array_map('strtolower', $string);\n    $count_distinct_characters\
    \ = 0;\n    $count_distinct_characters++;\n    foreach ($characters as $character)\
    \ {\n        $count_distinct_characters += count($characters);\n    }\n\n    return\
    \ $count_distinct_characters;\n}\n</code>\n<|/ a tags=string,count,unique,php\
    \ |>\n<| c |>\nThanks for your help but I'm looking for a pure PHP solution, not\
    \ javascript ;)\n<|/ c |>\n<| c |>\nSure, sorry then. I'll keep searching!\n<|/\
    \ c |>\n<| a dscore=1 |>\nI think I got it right now. Thanks everybody ;)\n<code>\n\
    $a = 'Bella';\n$b = strtolower($a);\n$c = array_count_values($b);\n$d = array_keys($c);\n\
    \n$count = count($d);\n\necho \"Number of letters: \" . $count . \"\\n\";\n</code>\n\
    <|/ a tags=string,count,unique,php |>\n<| a |>\n<code>\n$string = 'Bella';\n$new_string\
    \ = strtolower($string);\n$array = str_split($new_string);\n$array = array_count_values($array);\n\
    $array = array_keys($array);\n$count = count($array);\necho $count;\n</code>\n\
    <|/ a dscore=1 tags=string,count,unique,php |>\n<| a dscore=1 |>\n<code>\n$string\
    \ = 'Bella';\n$new_string = strtolower($string);\n$array = str_split($new_string);\n\
    $array = array_count_values($array);\n$array = array_keys($array);\n$count = count($array);\n\
    echo $count;\n</code>\n<|/ a tags=string,count,unique,php |>\n<| a dscore=1 |>\n\
    <code>\n$string = 'Bella';\n$new_string = strtolower($string);\n$array = str_split($new_string);\n\
    $array = array_count_values($array);\n$array = array_keys($array);\n$count = count($array);\n\
    echo $count;\n</code>\n<|/ a tags=string,count,unique,php |>\n<| a |>\n<code>\n\
    <?php\n\n$string = 'Bella';\n$new_string = strtolower($string);\n$array = str_split($new_string);\n\
    $array = array_count_values($array);\n$array = array_keys($array);\n$count = count($array);\n\
    echo $count;\n</code>\n<|/ a dscore=1 tags=string,count,unique,php |>\n<| a |>",
  "    return count(array_filter(preg_split('/(?=[A-Z])/', $string)));\n}\n", "\t\
    return strlen($string) - count_chars($string, 'abcdefghijklmnopqrstuvwxyz');\n\
    }\n", "  return strlen($string) - count_chars(strtolower($string));\n}\n", " \
    \   return count(preg_split('//u', $string, -1, PREG_SPLIT_NO_EMPTY));\n}", " \
    \ return count(preg_split('/(?<!^)(?!$)/', $string));\n}\n", "    return preg_match_all('~.~u',\
    \ $string) - 1;\n}\n", "    // Return an empty string if $string is empty\n  \
    \  if (empty($string)) {\n        return 0;\n    }\n\n    $lowercase_string =\
    \ strtolower($string);\n\n    // For each character in the string, increment the\
    \ count if it's a lowercase letter or if the character is repeated at least twice\n\
    \    // Return the accumulated count\n    $total_characters = 0;\n    $count =\
    \ 1;\n    for ($i = 0; $i < strlen($lowercase_string); $i++) {\n        $char\
    \ = strtolower($lowercase_string[$i]);\n        if ($char === $lowercase_string[$i]\
    \ || $count > 2) {\n            $total_characters++;\n        }\n        $count\
    \ += ($char === $lowercase_string[$i]);\n    }\n\n    return $total_characters;\n\
    }\n", "    $count = 0; // keep track of how many distinct characters there are\n\
    \n    $chars = str_split($string);\n    $lowercase = array();\n    $uppercase\
    \ = array();\n    foreach ($chars as $char) {\n        if (ctype_lower($char))\
    \ {\n            $lowercase[$char] = 1;\n        } else {\n            $uppercase[$char]\
    \ = 1;\n        }\n    }\n\n    foreach ($lowercase + $uppercase as $char) {\n\
    \        $count += count($chars);\n    }\n\n    return $count;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nThe original question mentioned that \"the strings consist\
    \ of a maximum of 100 characters\".  If you are not concerned about memory or\
    \ CPU consumption, I thought I'd add something more elegant than a brute force\
    \ solution.\nThis solution uses the hash-map data structure from PHP.  You can\
    \ read up on it here: http://php.net/manual/en/book.hash.php\nThe hash-map can\
    \ store the key/value pairs in a much more efficient manner than using arrays.\
    \  It also has the advantage of being much more readable than a switch statement.\n\
    <code>\n$chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()';\n\
    $hashTable = hash_init($chars);\n\nforeach ($str as $ch) {\n    hash_update($hashTable,\
    \ $ch);\n}\n\n$key = hash_final($hashTable);\n</code>\n<|/ a tags=algorithm,php,string,optimization\
    \ dscore=2 |>\n<| a |>\nUse a regular expression:\n<code>\n$str = \"Jerry Hendrix\"\
    ;\nif (preg_match_all('/[a-z]+/i', $str, $matches)) {\n    echo $matches[0][0];\n\
    } else {\n    echo 'No match';\n}\n</code>\nThis won't work correctly for non-ASCII\
    \ characters, though. I'm not sure how you'd get around that.\n<|/ a tags=algorithm,php,string,optimization\
    \ dscore=0 |>\n<| a tags=algorithm,php,string,optimization dscore=0 |>\nYou could\
    \ use str_split and count the characters that are different. Then you can use\
    \ a for loop to find out if the number of characters is above 100 and do something\
    \ with it.\n<|/ a |>\n<| a tags=algorithm,php,string,optimization |>\nThis is\
    \ an algorithm that uses no loops, just a regular expression.\n<code>\n<?php\n\
    $string = \"Jerry Hendrix\";\n\nif(preg_match_all('/([A-Z]+)/i', $string, $matches))\
    \ {\n  ", "    $result = array();\n    $length = strlen($string);\n    for ($i\
    \ = 0; $i < $length; $i++) {\n        $result[] = strtolower($string[$i]);\n \
    \   }\n    return count($result);\n}\n</code>\n<|/ a dscore=1 tags=php,performance\
    \ |>\n<| a tags=php,performance dscore=0 |>\nThis isn't quite an answer to your\
    \ question, but an answer that may help some: this sort of thing is hard to get\
    \ right and hard to get it right. \nI say this because I recently started looking\
    \ at PHP code written in other languages, mostly C (but some C++) and I realised\
    \ that it's hard to get a lot of performance out of this kind of stuff.\nIf you're\
    \ interested in performance, it's pretty much the bane of every PHP developer.\
    \ Don't code it like you did in C, C++, C#, Java, or any other language. Try to\
    \ do everything you can and don't try to micro-optimize your code. Code it to\
    \ be readable, maintainable, and easy to debug. That said, do some profiling to\
    \ identify where the bottlenecks are. For example, what are you doing with the\
    \ data? Can you load it into RAM and process it in chunks? Are you doing any database\
    \ queries while processing? If so, try to make those as fast as you can. \nThe\
    \ best way to find out what your bottlenecks are is to profile your code. Profile\
    \ your code. Find out what's slow. Make those things fast enough to do the processing\
    \ you're doing. Don't just try to optimize everything by hand, since you won't\
    \ know what exactly is slow.\n<|/ a |>\n<| a tags=php,performance |>\nIt's not\
    \ about the programming language but about the program logic. \nYou cannot make\
    \ an algorithm to work fast on every input, but a perfect algorithm should be\
    \ very fast. The best is to use algorithms that take advantage of the fact that\
    \ they work on the given input.\nThe main problem is when you try to put all the\
    \ numbers in the array into one array. That's because in PHP array is basically\
    \ a hash table (hashtable in short). When you try to put an array into a hash\
    \ table, it has to check every single value whether it exists in the hash table\
    \ or not. Hashtable has O(n) lookup performance.\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nAs other have stated, your algorithm is not optimal and you really should\
    \ change it. Here is a good example of what you can do to optimize it (using PHP):\n\
    <code>\n<?php\n\n$words = array('Hello', 'World', 'Foo', 'Bar');\n$count = array();\n\
    \nforeach ($words as $", "    return count(preg_split('//u', $string));\n}\n",
  "\t$result = 1;\n\tforeach(str_split($string) as $char) {\n\t\tif($string !== strtolower($char))\
    \ {\n\t\t\t$result *= (strtolower($char) - 'a');\n\t\t}\n\t}\n\treturn $result;\n\
    }\n", "\treturn count(preg_split(\"//u\", $string, -1, PREG_SPLIT_NO_EMPTY));\n\
    }\n", "    $chars = array();\n    foreach (str_split($string) as $character) {\n\
    \        $chars[$character]++;\n    }\n    return count($chars);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=php |>\nHere's a function that counts how many times\
    \ each character appears in a string.\n<code>", "\t$result = strlen($string);\n\
    \n\tfor ($i = 1; $i <= $result; $i++) {\n\t\tif (preg_match('/' . preg_quote($string[$i\
    \ - 1], '/') . '/i', $string[$i])) {\n\t\t\t$result--;\n\t\t}\n\t}\n\n\treturn\
    \ $result;\n}\n", "    $characters = array_unique(str_split(strtolower($string)));\n\
    \    return count($characters);\n}\n", "    return count(preg_split('//u', $string));\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`preg_split` uses a greedy match by default. So,\
    \ your function will match `\"Jerry123`\" as \"Jerry\". Change it to `preg_split('//u',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY)` so that the match stops before the end of\
    \ the line and doesn't include the newline at the end.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe PHP function strlen() is also helpful for this. \nThis function returns\
    \ the number of characters in a string, and not the count. In the example below,\
    \ the number of characters is 4 rather than 5.\n<code>\n<?php\n$string = \"hello\
    \ world\";\necho strlen($string); // 5", "    return preg_replace('/./u', '',\n\
    \        strtr($string, array(\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
    \ \"e\" => 1, \"f\" => 1, \"g\" => 1, \"h\" => 1, \"i\" => 1, \"j\" => 1, \"k\"\
    \ => 1, \"l\" => 1, \"m\" => 1, \"n\" => 1, \"o\" => 1, \"p\" => 1, \"q\" => 1,\
    \ \"r\" => 1, \"s\" => 1, \"t\" => 1, \"u\" => 1, \"v\" => 1, \"w\" => 1, \"x\"\
    \ => 1, \"y\" => 1, \"z\" => 1, \"A\" => 1, \"B\" => 1, \"C\" => 1, \"D\" => 1,\
    \ \"E\" => 1, \"F\" => 1, \"G\" => 1, \"H\" => 1, \"I\" => 1, \"J\" => 1, \"K\"\
    \ => 1, \"L\" => 1, \"M\" => 1, \"N\" => 1, \"O\" => 1, \"P\" => 1, \"Q\" => 1,\
    \ \"R\" => 1, \"S\" => 1, \"T\" => 1, \"U\" => 1, \"V\" => 1, \"W\" => 1, \"X\"\
    \ => 1, \"Y\" => 1, \"Z\" => 1))\n    );\n}\n", "    // Count how many characters\
    \ in $string are in alphabetical order\n    $unique_characters = array_count_values(str_split($string));\n\
    \    $unique_characters = array_keys($unique_characters);\n    return count($unique_characters);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is the right solution and should be accepted\
    \ as the correct answer.\n<|/ c |>\n<| a tags=php |>\nI haven't run this through\
    \ my editor, but this should work:\n<code>", "    $count = 0; // Initialize count\n\
    \    foreach (str_split($string) as $char) {\n        if (ctype_upper($char))\
    \ {\n            $count++; // If it is a capital letter, increment count\n   \
    \     }\n    }\n    return $count; // Return the count\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=php |>\nYou can do something like the following:\n<code>", " \
    \   // Initialize count\n    $count = count($string);\n    // Initialize character\
    \ frequency\n    $frequencies = array();\n    foreach ($string as $character)\
    \ {\n        if (!array_key_exists($character, $frequencies)) {\n            $frequencies[$character]\
    \ = 1;\n        } else {\n            $frequencies[$character] += 1;\n       \
    \ }\n    }\n    // Go through all characters and find out how many distinct characters\
    \ they consist of\n    foreach ($frequencies as $character => $frequency) {\n\
    \        if ($frequency === 1) {\n            $count--;\n        }\n    }\n  \
    \  return $count;\n}\n", "    if ($string == null) {\n        return 0;\n    }\n\
    \n    $chars = [];\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char\
    \ = mb_substr($string, $i, 1, \"UTF-8\");\n        if (in_array($char, $chars))\
    \ {\n            $chars[$char]++;\n        } else {\n            $chars[$char]\
    \ = 1;\n        }\n    }\n\n    return count($chars);\n}\n", "    $distinct_characters\
    \ = 0;\n\n    $length = strlen($string);\n\n    for ($i = 0; $i < $length; $i++)\
    \ {\n        $distinct_characters += 1;\n    }\n\n    return $distinct_characters;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=algorithm,php |>\nThere are\
    \ various methods. I'd suggest two algorithms: Hash tables and suffix trees. Hash\
    \ tables rely on the fact that you can look up a specific character by calculating\
    \ its hash value. Suffix trees are based on pre- and post-order traversals. \n\
    Here's an example of a hash table implementation in PHP: http://www.php.net/manual/en/hashtable.construct.php\
    \ \nHere's an example of a suffix tree implementation: http://www.php.net/manual/en/suffixtree.construct.php\n\
    <|/ a |>\n<| a |>\nI implemented a solution using Java which should work well\
    \ in PHP as well:\n<code>\npackage com.so;\n\npublic class CountDistinctCharacters\n\
    {\n\n    public static int countDistinctCharacters(String s)\n    {\n        int\
    \ distinctChars = 0;\n\n        for (Character c : s.toCharArray())\n        {\n\
    \            distinctChars += 1;\n        }\n\n        return distinctChars;\n\
    \    }\n\n    public static void main(String[] args)\n    {\n        String input\
    \ = \"abcabc\";\n        System.out.println(countDistinctCharacters(input));\n\
    \    }\n}\n</code>\n<|/ a tags=algorithm,php dscore=1 |>\n<| a |>\nA very good\
    \ way to achieve this is by using an associative array. The keys can be the characters\
    \ in the string, and the values will increase when you add a new character. This\
    \ will give an O(n) solution.\n<|/ a tags=algorithm,php dscore=1 |>\n<| c |>\n\
    And it can be done in O(1), see [here](http://php.net/manual/en/function.count-chars.php#76020).\n\
    <|/ c |>\n<| c |>\nThat's true, and O(n) is the same as O(1)\n<|/ c |>\n<| a dscore=0\
    \ |>\nI wrote this solution in Java. It is not the most optimized way but it is\
    \ easy and short.\n<code>\nimport java.util.HashMap;\nimport java.util.Map;\n\n\
    public class Strings{\n    public static int countDistinctChars(String str){\n\
    \        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n\
    \        for(int i = 0; i < str.length(); i++){\n            char c = str.charAt(i);\n\
    \            Integer val = map.get(c);\n            if(val == null)\n        \
    \        val = map.", "    if (empty($string)) {\n        return 0;\n    }\n \
    \   $result = array();\n    $length  = strlen($string);\n    foreach (str_split($string)\
    \ as $char) {\n        $lower = strtolower($char);\n        if (!isset($result[$lower]))\
    \ {\n            $result[$lower] = 1;\n        } else {\n            $result[$lower]++;\n\
    \        }\n    }\n    return $length;\n}\n</code>\n<|/ a tags=sorting,php |>\n\
    <| c |>\nThis is incredibly slow on large strings\n<|/ c |>\n<| c |>\nThanks for\
    \ your reply. I know i shouldn't be using PHP for this but this is for a project\
    \ that I am working on and it's one of the first things I have ever worked on\
    \ in PHP so I need to stick with it.\n<|/ c |>\n<| c |>\nI'm getting this error:\
    \ Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate\
    \ 130 bytes) in /Users/Matthew/Desktop/PhpProjects/CodeWarrior/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/WarriorProject/Warri",
  "    $count = preg_match_all('/[a-z]+/i', $string, $matches);\n    return $count;\n\
    }\n</code>\n<|/ a tags=php |>\n<| a |>\nHere's a solution using array_count_values()\n\
    <code>\n<?php\n$string = 'asdasdasd asdasd asdasd';\n$array = str_split($string);\n\
    $counts = array_count_values($array);\necho count($counts);\n</code>\n<|/ a tags=php\
    \ dscore=3 |>\n<| c |>\nA lot slower than other solutions.\n<|/ c |>\n<| a tags=php\
    \ dscore=2 |>\nI created a benchmark comparing various functions on PHP 7.4.3.\
    \ The function count is the fastest, but most popular answer is the slowest. array_count_values()\
    \ is also slowest, but most popular answer is the fastest. The fastest function\
    \ was preg_match_all. The longest string was 'jerry'.\n<|/ a |>\n<| a tags=php\
    \ |>\n<code>", "    $characters = preg_split('//', $string, null, PREG_SPLIT_NO_EMPTY);\n\
    \    return count(array_unique(array_map('strtolower', $characters)));\n}\n</code>\n\
    <|/ a tags=php |>\n<| c |>\nThat's a nice solution; but be careful with `count_distinct_characters('Mr.\
    \ Rutherford Thompson')`\n<|/ c |>\n<| c |>\nThis doesn't work if there is a space\
    \ in the string `count_distinct_characters('Mr. Rutherford Thompson')` returns\
    \ 2.\n<|/ c |>\n<| c |>\n: thanks for pointing that out. I updated my answer by\
    \ adding a `trim()` call on `$string`. Not sure if there's a way to handle that\
    \ case. I'm just trying to provide a general solution here, which will work in\
    \ 99.9% of all cases. I see you accepted my answer but I'm posting a separate\
    \ answer anyway just in case someone comes across the same issue.\n<|/ c |>\n\
    <| c |>\nThis should handle single letters, numbers and dashes: `function count_distinct_characters($string)\
    \ {\n    return count(preg_split('//', $string, null, PREG_SPLIT_NO_EMPTY) - preg_split('//',\
    \ preg_replace('/[\\s-]+/', '', $string), null, PREG_SPLIT_NO_EMPTY));\n}`\n<|/\
    \ c |>\n<| c |>\n: Thanks for adding that comment. It made me realize that I've\
    \ been using that function on more than just counting distinct characters (as\
    \ evidenced by the other answers). I'm going to update my answer to include a\
    \ more general solution which will work for any given string.\n<|/ c |>\n<| a\
    \ |>\n<code>", "    // Create a set that contains all distinct characters, ignoring\
    \ case\n    $unique_characters = array_unique(str_split($string));\n\n    // Count\
    \ the number of different characters in that set\n    return count($unique_characters);\n\
    }\n</code>\nThis works because it turns the string into a set of characters, and\
    \ then finds how many different characters there are (array_unique removes duplicates).\n\
    <|/ a dscore=2 |>\n<| a tags=php |>\n<code>\n$string = 'A quick brown fox jumps\
    \ over the lazy dog';\n$unique_characters = array_unique(str_split($string));\n\
    $unique_characters_count = count($unique_characters);\n\necho $unique_characters_count;\
    \ // Output: 4\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=php |>\nIf you\
    \ only need the count of distinct characters without storing the result, you can\
    \ use str_split and array_unique:\n<code>\n$string = 'A quick brown fox jumps\
    \ over the lazy dog';\n$array = str_split($string);\n$count  = count(array_unique($array));\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\necho count(array_unique(strtolower(str_split($string))));\n\
    </code>\n<|/ a dscore=0 tags=php |>\n<| a tags=php |>\n<code>", "    if (!is_string($string))\
    \ {\n        return 0;\n    }\n\n    // Split the string into array of characters\n\
    \    $char_array = str_split($string);\n    $distinct_count = 0;\n\n    // Iterate\
    \ through each character and check if it is unique or not.\n    foreach ($char_array\
    \ as $char) {\n        if (!isset($char)) {\n            continue;\n        }\n\
    \n        $distinct_count = max($distinct_count, substr_count($string, $char));\n\
    \    }\n\n    return $distinct_count;\n}\n</code>\nEDIT: Since this question is\
    \ tagged php as well, I've written a php version of this algorithm here.\n<|/\
    \ a |>\n<| c |>\nThis won't work for unicode characters that are not the same\
    \ length in every character set.\n<|/ c |>\n<| c |>\nOoops sorry, missed that\
    \ one. Thanks for the heads up\n<|/ c |>\n<| c |>\nNice function but i think you\
    \ should add another else block `else if ($character == 0){\n                \
    \    $distinct_count++;\n                }`\n<|/ c |>\n<| c |>\nYou are right.\
    \ I've just added that and updated my answer with proper links to other similar\
    \ answers on this site (since I've also mentioned that they have some issues with\
    \ unicode characters). Thanks for pointing that out!\n<|/ c |>\n<| c |>\nThank\
    \ you for posting this. The problem with my implementation is if $string contains\
    \ the character \xE6 (LATIN SMALL LETTER AE), the function will count it as a\
    \ distinct character.\n<|/ c |>\n<| a tags=algorithm,php,string,character |>\n\
    This is a great question!\nA good thing to remember here is that a character is\
    \ not only 1 byte, but is potentially more than one!\nFor example, a character\
    \ can be 2 bytes (for utf-8) or more!\nSo a byte can represent a unicode character\
    \ (which can be more than 1 byte), or a single ASCII character.\nYou might want\
    \ to look at these two other questions to learn more about characters and unicode\
    \ in general, as well as this answer, which outlines the difficulties of dealing\
    \ with unicode characters in PHP.\n<|/ a dscore=5 |>\n<| c |>\n\"A character can\
    \ be 2 bytes\" - no, it's a code unit in PHP (a byte in other languages)\n<|/\
    \ c |>\n<| c |>\n\"A byte can represent a unicode character (which can be more\
    \ than 1 byte)\" - no, it's just an 8-bit unsigned integer. It's a code point\
    \ or code unit. http://unicode.org/ is an excellent resource if you want to know\
    \ more.\n<|/ c |>\n<| ", "    return count(array_count_values(str_split(strtolower($string))));\n\
    }\n", "    if (!$string) {\n        return 0;\n    }\n    $count = array();\n\
    \    $length = strlen($string);\n    for ($i = 0; $i < $length; $i++) {\n    \
    \    if (!isset($count[$string[$i]])) {\n            $count[$string[$i]] = 1;\n\
    \        } else {\n            $count[$string[$i]]++;\n        }\n    }\n    return\
    \ count($count);\n}\n\n$characters = count_distinct_characters('Jerry Smith');\n\
    echo $characters;\n</code>\n<|/ a |>\n<| c |>\nThanks for the reply! This was\
    \ actually my first idea, but I think it would be too slow to check (potentially)\
    \ all possible combinations.\n<|/ c |>\n<| a tags=string,php,count |>\nI think\
    \ the solution is easier than you think:\n<code>\n$string = 'Jerry Smith';\n$count\
    \ = str_split($string);\n$count[0] = 0;\n$count[1] = 0;\n$count[2] = 0;\n$count[3]\
    \ = 0;\n$count[4] = 0;\n$count[5] = 0;\n$count[6] = 0;\n$count[7] = 0;\n$count[8]\
    \ = 0;\n$count[9] = 0;\n$count[10] = 0;\n$count[11] = 0;\n$count[12] = 0;\n$count[13]\
    \ = 0;\n$count[14] = 0;\n$count[15] = 0;\n$count[16] = 0;\n$count[17] = 0;\n$count[18]\
    \ = 0;\n$count[19] = 0;\n$count[20] = 0;\n$count[21] = 0;\n$count[22] = 0;\n$count[23]\
    \ = 0;\n$count[24] = 0;\n$count[25] = 0;\n$count[26] = 0;\n$count[27] = 0;\n$count[28]\
    \ = 0;\n$count[29] = 0;\n$count[30] = 0;\n$count[31] = 0;\n$count[32] = 0;\n$count[33]\
    \ = 0;\n$count[34] = 0;\n$count[35] = 0;\n$count[36] = 0;\n$count[37] = 0;\n$count[38]\
    \ = 0;\n$count[39] = 0;\n$count[40] = 0;\n$count[41] = 0;\n$count[42] = 0;\n$count[43]\
    \ = 0;\n$count[44] = 0;\n$count[45] = 0;\n$count[46] = 0;\n$count[47] = 0;\n$count[48]\
    \ = 0;\n$count[49] = 0;\n$count[50] = 0;\n$count[51] = 0;\n$count[52] = 0;\n$count[53]\
    \ = 0;\n$count[54] = 0;\n$count[55] = 0;\n$count[56] = 0;\n$count[57", "    if\
    \ (empty($string)) {\n        return 0;\n    }\n    return preg_match_all('/[\\\
    s\\p{L}]+/', $string, $matches) ? count($matches[0]) : 0;\n}\n", "    return count(array_count_values(str_split(strtolower($string))));\n\
    }\n", "    $str = strtolower($string);\n    $distinct = array();\n    for ($i=0;\
    \ $i<strlen($str); $i++) {\n        $distinct[$str[$i]] = isset($distinct[$str[$i]])\
    \ ? $distinct[$str[$i]] + 1 : 1;\n    }\n    return count($distinct);\n}\n</code>\n\
    <|/ a tags=php,string |>\n<| c |>\nThis code looks much neater than mine. Thanks\
    \ for posting\n<|/ c |>\n<| a |>\nThe most efficient algorithm for this is to\
    \ sort the characters in the string, then count the distinct characters up to\
    \ (but not including) the length of the string.  For example if your string was\
    \ \"abBcD\" then sort it, then the distinct characters you would need to count\
    \ up would be \"BcD\" and the total distinct characters would be 3.\n<|/ a dscore=1\
    \ tags=php,string |>\n<| c |>\nThat's an interesting algorithm. Do you know of\
    \ any implementations that would do that kind of thing?\n<|/ c |>\n<| a dscore=0\
    \ tags=php,string |>\nI'm sure there are better ways to do it, but this should\
    \ work. \n<code>", "    return count(array_unique(strtolower($string)));\n}\n",
  "    if (!$string) {\n        return 0;\n    }\n    // This regex will match all\
    \ unicode \"letters\" (from A to Z)\n    // This should work on all browsers (tested\
    \ on FF, IE, and Chrome)\n    return preg_match_all('/[a-z]+/u', $string);\n}\n",
  "    $chars = '';\n    foreach (str_split($string) as $char) {\n        $chars .=\
    \ strtolower($char);\n    }\n    return strlen($chars);\n}\n", "  return count(preg_split('//u',\
    \ $string, null, PREG_SPLIT_NO_EMPTY));\n}", "    if ($string === '') {\n    \
    \    return 0;\n    }\n\n    $counter = 0;\n    for ($i = 0; $i < strlen($string);\
    \ $i++) {\n        if (ctype_upper($string[$i])) {\n            $counter++;\n\
    \        }\n        if (ctype_lower($string[$i])) {\n            $counter++;\n\
    \        }\n    }\n\n    return $counter;\n}\n", "\t$chars = preg_split('//',\
    \ $string, -1, PREG_SPLIT_NO_EMPTY);\n\t$chars = array_unique($chars);\n\treturn\
    \ count($chars);\n}\n", "    // Count how often each character appears in the\
    \ input\n    $char_counts = array_count_values(str_split($string));\n    // Return\
    \ the number of unique characters\n    return count(array_filter($char_counts));\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYour answer has been flagged as low quality\
    \ because of its length and content. Could you provide some explanation on what\
    \ you have done in this code? Thanks.\n<|/ c |>\n<| c |>\nI appreciate your feedback.\
    \ I added an explanation.\n<|/ c |>\n<| c |>\nThanks for your effort but I need\
    \ your explanation, not just the code :)\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    <?php\n/**\n * string $str\n * string $char\n * int $count\n */", "    if (! is_string($string))\
    \ {\n        throw new InvalidArgumentException('Expected a string');\n    }\n\
    \    $string = (string) $string;\n    $distinctCharacters = [];\n    $distinctCharacters\
    \ = array_unique(str_split(strtolower($string)));\n    $distinctCharacters = array_values($distinctCharacters);\n\
    \    return count($distinctCharacters);\n}\n", "    return strlen(preg_replace('/[^A-Za-z]/',\
    \ \"\", strtolower($string)));\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
