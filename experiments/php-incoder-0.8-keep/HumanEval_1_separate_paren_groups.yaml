name: HumanEval_1_separate_paren_groups
language: php
prompt: "<?php\n// Input to this function is a string containing multiple groups of\
  \ nested parentheses. Your goal is to\n// separate those group into separate strings\
  \ and return the list of those.\n// Separate groups are balanced (each open brace\
  \ is properly closed) and not nested within each other\n// Ignore any spaces in\
  \ the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()',\
  \ '(())', '(()())']\nfunction separate_paren_groups($paren_string) {\n"
tests: "function candidate(...$args) {\n    return separate_paren_groups(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(\"(()()) ((())) () ((())()())\"\
  ) !== array(\"(()())\", \"((()))\", \"()\", \"((())()())\")) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(\"() (()) ((())) (((())))\") !== array(\"\
  ()\", \"(())\", \"((()))\", \"(((())))\")) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(\"(()(())((())))\") !== array(\"(()(())((())))\")) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(\"( ) (( )) (( )( ))\")\
  \ !== array(\"()\", \"(())\", \"(()())\")) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["  $opening_chars = array();\n  $closing_chars = array();\n\n  $paren_string\
    \ = trim($paren_string);\n  if (empty($paren_string)) {\n    return array();\n\
    \  }\n\n  // Split the input into opening parentheses (non-empty) and closing\
    \ parentheses (empty)\n  for ($i = 0; $i < strlen($paren_string); $i++) {\n  \
    \  // If the opening parenthesis is encountered\n    if ($paren_string[$i] ===\
    \ '(') {\n      // Then add it to the array of opening parenthesis\n      $opening_chars[]\
    \ = $paren_string[$i];\n    }\n    // If the closing parenthesis is encountered\n\
    \    else if ($paren_string[$i] === ')') {\n      // Then add it to the array\
    \ of opening parenthesis\n      $closing_chars[] = $paren_string[$i];\n    }\n\
    \  }\n\n  // Return the array of parentheses separated into an array of string\n\
    \  return array_filter(array_unique(array_merge($opening_chars, $closing_chars)));\n\
    }", "\t$paren_string = trim($paren_string);\n\tif (empty($paren_string)) {\n\t\
    \treturn array();\n\t}\n\t$parens = array();\n\tfor ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n\t\tif ($paren_string[$i] == '(') {\n\t\t\tif (count($parens) !== 0)\
    \ {\n\t\t\t\t$parens[count($parens) - 1] .= $paren_string[$i];\n\t\t\t} else {\n\
    \t\t\t\t$parens[] = $paren_string[$i];\n\t\t\t}\n\t\t} else {\n\t\t\t$parens[count($parens)\
    \ - 1] .= $paren_string[$i];\n\t\t}\n\t}\n\treturn $parens;\n}", "  $output =\
    \ array();\n\n  // Split into groups of 3 or more parentheses, separated by one\
    \ or more spaces\n  $paren_groups = preg_split('/((?:\\([^()]*\\)\\s*)+)/', $paren_string);\n\
    \n  // If there are more groups of parentheses than there are groups of characters,\n\
    \  // then we must skip over the unwanted groups and process them in another pass.\n\
    \  if(count($paren_groups) > count(preg_split('/(\\([^()]*\\)\\s*)+/', $paren_string)))\
    \ {\n    // Separate each group of unwanted parentheses into its own element in\
    \ the output array\n    foreach(array_slice($paren_groups, count(preg_split('/(\\\
    ([^()]*\\)\\s*)+/', $paren_string)), -1) as $paren_group) {\n      $output[] =\
    \ $paren_group;\n    }\n  } else {\n    // If there are no unwanted parentheses,\
    \ just output the entire parenthesized string\n    $output[] = $paren_string;\n\
    \  }\n\n  return $output;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI have written\
    \ a regex for you which may or may not help.\n<code>\n((\\([^()]*\\))*)\n</code>\n\
    https://regex101.com/r/iSj0h5/1\n<|/ a tags=regex,php |>\n<| c |>\nThis regex\
    \ matches the entire input string, not the individual groups of parentheses. Also,\
    \ since it's PHP, you need to use `preg_match_all()` instead of `preg_match()`,\
    \ otherwise you'll only get the first match instead of all matches.\n<|/ c |>\n\
    <| c |>\nI see your point but your regex does match all groups.\n<|/ c |>\n<|\
    \ c |>\nYour regex doesn't match any groups. It matches *all* groups, but it doesn't\
    \ match any groups. And since you're using `preg_match_all()`, you don't want\
    \ to use `.*`, because then it will match all groups, which it will not match.\
    \ It should be `(\\([^()]*\\))*` (or `\\([^()]*\\)` without the parentheses, but\
    \ it would be better to use `preg_match_all()` so you can also get the indices\
    \ of each group). I've edited your answer to reflect this.\n<|/ c |>\n<| c |>\n\
    I am sorry, I should have been more explicit. I have changed the code to the regex\
    \ that matches multiple groups of parentheses. I tested this regex and it does\
    \ not match any of the groups that I posted. https://regex101.com/r/iSj0h5/2\n\
    <|/ c |>\n<| c |>\nYeah, but your code doesn't match any groups. Your regex matches\
    \ the entire string", "    // We are going to keep track of the brace depth for\
    \ each group.\n    // The first group will start out as '0' and we will increment\
    \ it every\n    // time we hit a new '('. Also, once we hit a '(', we don't increment\
    \ the\n    // depth.\n    $brace_depth = 0;\n    $paren_groups = array();\n  \
    \  $groups = explode(\"\\n\", $paren_string);\n\n    // For each group...\n  \
    \  foreach($groups as $group) {\n        // If the current group begins with a\
    \ left paren, increment the depth\n        // if it does.\n        if($group[0]\
    \ == \"(\") {\n            $brace_depth++;\n        }\n        // If the current\
    \ group begins with a right paren, decrement the depth\n        // if it does.\n\
    \        elseif($group[0] == \")\") {\n            $brace_depth--;\n        }\n\
    \        // If the depth has reached zero and there's still more data to process\n\
    \        // then add the current group to the array and return it.\n        //\
    \ The array will be returned with all the groups in between the\n        // parentheses.\n\
    \        if($brace_depth == 0 && isset($groups[$i + 1])) {\n            $paren_groups[]\
    \ = $group;\n        }\n        // If there is still data in the array and we're\
    \ not already at the end\n        // of the array, add the current group to the\
    \ array and move on to the\n        // next one.\n        elseif(isset($groups[$i\
    \ + 1]) && !isset($groups[$i])) {\n            $paren_groups[] = $group;\n   \
    \     }\n        // If there are no more items in the array, add the current group\
    \ to\n        // the array and return it.\n        else {\n            $paren_groups[]\
    \ = $group;\n        }\n    }\n\n    // Return the array.\n    return $paren_groups;\n\
    }\n", "    $paren_string = preg_replace('/\\s+/', '', $paren_string);\n    $groups\
    \ = preg_split('/\\s*\\((?>[^()]+|\\((?1)+\\))*(?1)*(?!\\))\\s*/', $paren_string,\
    \ -1, PREG_SPLIT_DELIM_CAPTURE);\n    return $groups;\n}\n\n$str = '( () ( ))(\
    \ (( ( ( ) )))) ((( ( ( ( ( ( ) ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) (((\
    \ ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( (\
    \ ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( )\
    \ ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) )))))\
    \ ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) (((\
    \ ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( (\
    \ ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( )\
    \ ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) )))))\
    \ ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) (((\
    \ ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( (\
    \ ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( )\
    \ ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) )))))\
    \ ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) (((\
    \ ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ))))) ((( ( (\
    \ ( ) ))))) ((( ( ( ( ) ))))) ((( ( ( ( ) ", "  $paren_open = false;\n  $paren_level\
    \ = 0;\n  $paren_string = trim($paren_string);\n  $paren_string = preg_replace('/\\\
    s+/', '', $paren_string);\n  $paren_array = array();\n\n  $open_paren = 0;\n \
    \ $close_paren = 0;\n  for($i = 0; $i < strlen($paren_string); $i++) {\n    $char\
    \ = $paren_string[$i];\n    if($char === '(') {\n      $paren_open = true;\n \
    \     $paren_level++;\n    }\n    if($char === ')') {\n      $paren_open = false;\n\
    \      $paren_level--;\n    }\n\n    if($paren_level === 0 && !$paren_open) {\n\
    \      $paren_array[] = $paren_string[$i];\n    }\n  }\n\n  return $paren_array;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat is not the right approach. This is\
    \ a parsing problem, not an arranging problem. By the way, your function is very\
    \ similar to the one that OP already has. Have you tested it?\n<|/ c |>\n<| a\
    \ dscore=1 |>\nI have written a PHP class called Texticle that solves this problem\
    \ in one line.\n<code>\n$paren_groups = Texticle::parseParenthesis('( ( (()) (\
    \ ) ))');\n</code>\n<|/ a tags=parentheses,regex,php |>\n<| c |>\nThis is exactly\
    \ what I need! Thanks!\n<|/ c |>\n<| a dscore=0 tags=parentheses,regex,php |>\n\
    Not sure whether this is what you want but this regex should return all the groups\
    \ in the string.\n<code>\n\\(([^()]+)\\)\n</code>\nDemo\n<|/ a |>\n<| c |>\nNo,\
    \ that doesn't work. I need it to match the first three sets of parentheses as\
    \ well as the last two.\n<|/ c |>\n<| c |>\nYou want to return \"( ( (()) ( )\
    \ ))\" as two matches?\n<|/ c |>\n<| c |>\nYes, exactly. There might be some random\
    \ spaces in the string, so I can't just remove them.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php\n$string = '( ( (()) ( ) ))';\npreg_match_all('/\\([^()]*\\)/', $string,\
    \ $matches);\nvar_dump($matches[0]);\n</code>\n<|/ a tags=parentheses,regex,php\
    \ dscore=0 |>\n<| c |>\nNo, that doesn't work. I need it to match the first three ",
  "    $paren_groups = preg_split('/([\\(\\)])/', $paren_string);\n    $opening_parens\
    \ = array();\n    $closing_parens = array();\n    foreach ($paren_groups as $group)\
    \ {\n        if (empty($group)) {\n            continue;\n        }\n        if\
    \ ($group[0] === '(') {\n            $opening_parens[] = $group;\n        } else\
    \ {\n            $closing_parens[] = $group;\n        }\n    }\n    $paren_strings\
    \ = array();\n    foreach ($opening_parens as $opening_paren) {\n        $paren_strings[]\
    \ = $opening_paren;\n        foreach ($closing_parens as $closing_paren) {\n \
    \           if ($closing_paren === $opening_paren) {\n                $paren_strings[]\
    \ = $opening_paren;\n                $closing_parens[] = '';\n               \
    \ break;\n            }\n        }\n    }\n    return $paren_strings;\n}\n</code>\n\
    <|/ a tags=parentheses,javascript,regex,php dscore=0 |>\n<| c |>\nThis doesn't\
    \ appear to work when dealing with things like \"(( ))\". It works with \"(( (\
    \ )) (( )))\" but fails with \"((( ( )))\". As soon as you get \"(((( ))))\" the\
    \ program crashes.\n<|/ c |>\n<| a dscore=0 |>\nThe best way I've found to do\
    \ this in PHP is to use the regex ^\\s*\\((?:[^()]*|(?R))*\\)\\s*$, which will\
    \ match all groups of parentheses separated by a single space, ignoring spaces\
    \ within parentheses. It doesn't match the outer parentheses at all, but that\
    \ can be added if desired.\nThis won't catch all possible nested parentheses (which\
    \ may or may not be an issue), but it will catch all parentheses separated by\
    \ a space.\nIn PHP, this would look something like:\n<code>\n$string = '( 1 )\
    \ ( 2 ) (3 ) ( 4 (5) )';\n\npreg_match_all('/^\\s*\\((?:[^()]*|(?R))*\\)\\s*$/',\
    \ $string, $matches);\n", "  // Split on groups of parenthesis, not nested\n \
    \ $paren_string = preg_replace('!\\s*\\(\\s*\\)\\s*!', '', $paren_string);\n\n\
    \  // Iterate through all pairs of matching parenthesis\n  $matches = array();\n\
    \  for ($x = 0; $x < strlen($paren_string); $x += 2) {\n    // Find the starting\
    \ index of the matching parenthesis\n    $opening = strpos($paren_string, '(',\
    \ $x);\n    // Find the starting index of the matching parenthesis\n    $closing\
    \ = strpos($paren_string, ')', $x);\n    // Check if we've found both a matching\
    \ pair\n    if ($opening !== false && $closing !== false) {\n      $matches[]\
    \ = substr($paren_string, $opening, $closing - $opening);\n    }\n  }\n  return\
    \ $matches;\n}\n</code>\n<|/ a |>\n<| c |>\nI really like the answer. It works\
    \ perfectly and it's super easy to understand.\n<|/ c |>\n<| a |>\nYou could use\
    \ regex to match your string, and explode the matches into an array. \nThe regex\
    \ would be as follows\n<code>\n/(\\(.*?\\))/\n</code>\nAnd then explode the matches\
    \ like this\n<code>\n$string = '( () ( ) ( ) ( ) )';\n$matches = preg_split('/(\\\
    (.*?\\))/', $string);\nvar_dump($matches);\n</code>\nWhich outputs\n<code>\narray(3)\
    \ {\n  [0]=>\n  string(3) \"(\"\n  [1]=>\n  string(3) \"(\"\n  [2]=>\n  string(3)\
    \ \"(\"\n}\n</code>\nWhich you could then implode to make your string like you\
    \ desire\n<code>\n'(' . implode(' ', $matches) . ')'\n</code>\n<|/ a dscore=1\
    \ tags=string,php,regex |>\n<| c |>\nOP didn't say anything about nested parenthesis.\
    \ OP said \"not nested\"\n<|/ c |>\n<| c |>\nAh good point! I'll update the answer\n\
    <|/ c |>\n<| c |>\nYou don't need to escape `()`. You just need to escape `()`\
    \ if they are inside character class `[]`\n<|/ c |>\n<| c |>\nThanks for the answer,\
    \ but I tried it and it didn't work. I tried `echo implode(' ', $matches);` but\
    \ I only got `Array()` as a result.\n<|/ c |>\n<| c |>\nI missed that you are\
    \ using preg_split, not the explode function. I have updated my answer\n<|/ c\
    \ |>\n", "    $paren_groups = array();\n    $open_braces = array();\n    $closed_groups\
    \ = array();\n    $open_parens = array();\n    for($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        if($paren_string[$i] == '(') {\n            $open_parens[]\
    \ = $i;\n        } else if($paren_string[$i] == ')') {\n            $open_parens\
    \ = array_diff($open_parens, array($i));\n            $closed_groups[] = $i;\n\
    \        } elseif($paren_string[$i] == ' ') {\n            $open_braces[] = $i;\n\
    \        } else {\n            // Any other character means it's a space or a\
    \ closing paren group, so we save it as-is\n            $paren_groups[] = substr($paren_string,\
    \ $i, 1);\n        }\n    }\n    for($i = count($closed_groups) - 1; $i >= 0;\
    \ $i--) {\n        // We ignore whitespace between groups of parens\n        if($paren_groups[$i]\
    \ == ' ') {\n            $paren_groups[$i] = '';\n        } else {\n         \
    \   $closed_groups[] = $closed_groups[$i] - 1;\n        }\n    }\n    return array_slice($paren_groups,\
    \ 0, count($open_parens));\n}\n", "    if (empty($paren_string)) {\n        return\
    \ array();\n    }\n\n    $paren_string = preg_replace('/\\s+/', '', $paren_string);\n\
    \    $paren_string_length = strlen($paren_string);\n\n    $paren_strings_array\
    \ = array();\n    $stack = array();\n    $stack_top = -1;\n\n    for ($i = 0;\
    \ $i < $paren_string_length; $i++) {\n        $char = $paren_string[$i];\n   \
    \     if ($char == '(') {\n            $stack_top++;\n            $stack[$stack_top]\
    \ = $char;\n        } else if ($char == ')') {\n            $stack_top--;\n  \
    \          $stack[$stack_top] = $char;\n        } else if ($char == ' ' && $stack_top\
    \ > 0) {\n            unset($stack[$stack_top]);\n            $stack_top--;\n\
    \        }\n    }\n\n    for ($i = 0; $i < $stack_top; $i++) {\n        $paren_strings_array[]\
    \ = $stack[$i];\n    }\n\n    return $paren_strings_array;\n}\n", "    $paren_array\
    \ = array();\n    $open_braces = array();\n    $closed_braces = array();\n   \
    \ // $stack is used to track whether we are inside of a nested parenthesis group\n\
    \    $stack = 0;\n    // Count the number of open parens\n    foreach (str_split($paren_string)\
    \ as $char) {\n        // If we are in the stacked parenthesis group\n       \
    \ if ($stack > 0) {\n            // If we are opening a parenthesis\n        \
    \    if ($char == '(') {\n                // If the previous character was not\
    \ a closing parenthesis\n                if ($stack == count($open_braces) - 1)\
    \ {\n                    // Add this parenthesis to the stacked group\n      \
    \              $paren_array[] = $char;\n                    // And increment the\
    \ open paren count\n                    $open_braces[$char]++;\n             \
    \   } else {\n                    // If it wasn't a closing parenthesis then this\
    \ is not the correct nesting of parentheses\n                    return false;\n\
    \                }\n            } else {\n                // If we are closing\
    \ a parenthesis\n                if ($char == ')') {\n                    // If\
    \ the open paren count matches the closing paren count\n                    if\
    \ ($open_braces[$char] == count($closed_braces) - 1) {\n                     \
    \   // Then this is correct nesting of parentheses\n                        $stack--;\n\
    \                        // Add the closing parenthesis to the stacked group\n\
    \                        $paren_array[] = $char;\n                        // And\
    \ increment the closing paren count\n                        $closed_braces[$char]++;\n\
    \                    } else {\n                        // If this isn't the correct\
    \ nesting of parentheses then this is not the correct nesting of parentheses\n\
    \                        return false;\n                    }\n              \
    \  } else {\n                    // If the closing paren count doesn't match the\
    \ open paren count then this is not the correct nesting of parentheses\n     \
    \               return false;\n                }\n            }\n        } else\
    \ {\n            // If we are outside of a parenthesis group\n            if ($char\
    \ == '(') {\n                // And we are not stacked then this is an open paren\n\
    \                $open_braces[$char] = 1;\n            } else {\n            \
    \    // And we are not stacked then this is not a parenthesis\n              \
    \  $closed_braces[$char] = 1;\n            }\n        }\n    }\n    // If the\
    \ stacked parenthesis group has a length of 0 then this isn't the correct nesting\
    \ of parentheses\n    if (count($paren_array) == 0) {\n        return false;\n\
    \    }\n    // Return the stacked parenthesis group\n    return $paren_array;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nThis regex will match all nested parentheses groups:\n\
    <code>\n/\\((?:[^()]*+|(?0))*\\)/\n</code>\nThe regex will ", "    $open_brackets\
    \ = array();\n    $closed_brackets = array();\n    $open_brace_count = 0; // Counter\
    \ to keep track of open brackets\n    $closed_brace_count = 0; // Counter to keep\
    \ track of closed brackets\n\n    // We go through the input string, one character\
    \ at a time. If we find a '(' character, we save it\n    // to the open brackets\
    \ array, otherwise we save the close bracket to the closed brackets array.\n \
    \   // The brackets array stores open and closed brackets.\n    for ($i = 0; $i\
    \ < strlen($paren_string); $i++) {\n        $char = substr($paren_string, $i,\
    \ 1);\n        if ($char == '(') {\n            $open_brackets[] = $char;\n  \
    \          $open_brace_count++;\n        } elseif ($char == ')') {\n         \
    \   if ($open_brace_count >= 1) {\n                // If we are currently in a\
    \ group of brackets, we must close it\n                $open_brace_count--;\n\
    \                $closed_brackets[] = $char;\n            } elseif ($closed_brace_count\
    \ > 0) {\n                // If we are currently in a brace group, but there are\
    \ already brackets open,\n                // we assume we are closing the group.\
    \ Otherwise we leave the brace group and add\n                // the closing bracket\
    \ to the bracket group.\n                $closed_brackets[] = $char;\n       \
    \         $closed_brace_count--;\n            }\n        }\n    }\n\n    // Return\
    \ an array of our results.\n    // Each element will be an array of all the open\
    \ brackets in the string.\n    // Each element will be an array of all the closed\
    \ brackets in the string.\n    // Each element will be an array of the open brace\
    \ group characters.\n    // Each element will be an array of the closed brace\
    \ group characters.\n    return array($open_brackets, $closed_brackets, $open_brace_count,\
    \ $closed_brace_count);\n}\n", "  $paren_arr = explode(')', $paren_string);\n\
    \  $paren_arr2 = [];\n  foreach ($paren_arr as $paren_item) {\n    if ($paren_item\
    \ != '') {\n      $paren_arr2[] = $paren_item;\n    }\n  }\n  return $paren_arr2;\n\
    }\n", "\t$paren_string_no_spaces = preg_replace('/\\s+/', '', $paren_string);\
    \ // Remove all spaces in paren grouping\n\t// TODO: Write this function\n}\n",
  "    $groups = preg_split(\"/(\\{(?!\\s))/\", $paren_string);\n    return array_filter($groups);\n\
    }\n</code>\nHere is a working example of the above code:\nhttps://3v4l.org/pZYVj\n\
    <|/ a tags=php,regex dscore=2 |>\n<| c |>\nThanks for your reply, I tried it but\
    \ it doesn't work with this string: `$paren_string = '( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (",
  "    $paren_string = preg_replace('/ /', '', $paren_string);\n    $paren_array =\
    \ array();\n    $current_string = \"\";\n\n    // Iterate through each character\n\
    \    foreach ($paren_string as $char) {\n        if ($char == \"(\") {\n     \
    \       // Add current string to array and empty it\n            $paren_array[]\
    \ = $current_string;\n            $current_string = \"\";\n        } elseif ($char\
    \ == \")\") {\n            // Check if current string contains more than one set\
    \ of parentheses\n            if (count($current_string) > 1) {\n            \
    \    $paren_array[] = $current_string;\n                $current_string = \"\"\
    ;\n            } else {\n                // If there were no more open parens\
    \ in the current string, add it to the array\n                $paren_array[] =\
    \ $current_string;\n                $current_string = \"\";\n            }\n \
    \       } else {\n            // Add the current char to the current string\n\
    \            $current_string .= $char;\n        }\n    }\n\n    // If the current\
    \ string is not empty, add it to the array\n    if ($current_string != \"\") {\n\
    \        $paren_array[] = $current_string;\n    }\n\n    // Return the array of\
    \ separated groups\n    return $paren_array;\n}\n", "    $paren_string = preg_replace('/\\\
    s+/', '', $paren_string);\n    $paren_string = trim($paren_string);\n    $paren_string\
    \ = preg_replace('/[\\(\\)]+/', '', $paren_string);\n    return preg_split('/[\\\
    (\\)]+/', $paren_string);\n}\n", "    $paren_groups = [];\n    $pos = 0;\n   \
    \ while ($pos < strlen($paren_string)) {\n        if ($paren_string[$pos] == '('\
    \ && $paren_string[$pos + 1] == '(') {\n            $paren_groups[] = substr($paren_string,\
    \ $pos, $pos + 2);\n            $pos += 2;\n        } elseif ($paren_string[$pos]\
    \ == ' ') {\n            $pos++;\n        } else {\n            break;\n     \
    \   }\n    }\n    return $paren_groups;\n}\n", "\t$output = [];\n\t$current_group\
    \ = '';\n\tfor ($i = 0, $l = strlen($paren_string); $i < $l; $i++) {\n\t\t$char\
    \ = substr($paren_string, $i, 1);\n\t\t$char_to_add = ($char === ')' ? ($current_group\
    \ ? $current_group . '(' : ''): $char);\n\t\t$current_group ? $current_group .=\
    \ $char_to_add : $current_group = $char_to_add;\n\t\tif ($char === '(') {\n\t\t\
    \t$output[] = $current_group;\n\t\t\t$current_group = '';\n\t\t}\n\t}\n\treturn\
    \ $output;\n}", "    $result = [];\n    $paren_count = 0;\n    $stack = [];\n\n\
    \    foreach(explode($paren_string, \"\\n\") as $line) {\n        $line_slashed\
    \ = '\\\\' . ltrim($line, \"\\\\\");\n        if(!empty($line_slashed)) {\n  \
    \          if(!preg_match(\"/^\\s*$/\", $line)) {\n                if($paren_count\
    \ > 0) {\n                    if(strpos($line, '(') === 0) {\n               \
    \         $stack[] = $paren_count;\n                    }\n                } else\
    \ {\n                    if($stack) {\n                        $paren_count =\
    \ $stack[count($stack)-1];\n                    } else {\n                   \
    \     $paren_count = 0;\n                    }\n                }\n          \
    \  }\n        }\n        if(!empty($line_slashed) && $paren_count > 0) {\n   \
    \         if(strpos($line, '(') !== false && $line_slashed !== str_replace('\\\
    \\', '', substr($line, 1, strlen($line)-1))) {\n                $paren_count--;\n\
    \            } else if(strpos($line, '(') !== false) {\n                $paren_count++;\n\
    \            } else if(strpos($line, ')') !== false && $line_slashed !== str_replace('\\\
    \\', '', substr($line, 1, strlen($line)-1))) {\n                $paren_count++;\n\
    \            }\n        }\n    }\n    return array_reverse($stack);\n}\n", " \
    \   $paren_groups = array();\n    $paren_start = 0;\n    $open_paren_found = false;\n\
    \    $close_paren_found = false;\n    $stack = array();\n\n    $paren_length =\
    \ strlen($paren_string);\n    for ($i = 0; $i < $paren_length; ++$i) {\n     \
    \   if ($paren_string[$i] == ' ') {\n            $paren_groups[] = substr($paren_string,\
    \ 0, $i);\n            $paren_string = substr($paren_string, $i);\n          \
    \  $paren_start = -1;\n        }\n        if (!$open_paren_found) {\n        \
    \    if ($paren_string[$i] == '(') {\n                $stack[] = $paren_string[$i];\n\
    \                $paren_string = substr($paren_string, $i + 1);\n            \
    \    $paren_start = -1;\n                $open_paren_found = true;\n         \
    \   }\n        } else if ($close_paren_found && $paren_string[$i] == ')') {\n\
    \            array_pop($stack);\n            $close_paren_found = false;\n   \
    \     }\n        if ((isset($paren_start) && ($paren_start < 0)) || $close_paren_found)\
    \ {\n            if (count($stack) > 0) {\n                $paren_groups[] = substr($paren_string,\
    \ 0, $i);\n                $paren_string = substr($paren_string, $i);\n      \
    \          $paren_start = -1;\n            }\n        }\n    }\n    return $paren_groups;\n\
    }\n", "    $groups = [];\n    $current_group = [];\n    foreach (explode(')',\
    \ $paren_string) as $char) {\n        if ($char == '(') {\n            if (count($current_group))\
    \ {\n                $groups[] = implode(')', $current_group);\n             \
    \   $current_group = [];\n            }\n        } else {\n            $current_group[]\
    \ = $char;\n        }\n    }\n\n    if (count($current_group)) {\n        $groups[]\
    \ = implode(')', $current_group);\n    }\n\n    return $groups;\n}\n</code>\n\
    <|/ a dscore=2 tags=regex,php,parsing |>\n<| a dscore=1 |>\nTo expand on some\
    \ of the other answers, there is also a library called Regexp::Assemble which\
    \ can do what you want.\nA simple example would be:\n<code>\n<?php\nuse Regexp\\\
    Assemble;\n\n$string = '(one)(one)two(three)';\n$expression = new Assemble($string);\n\
    $expression->addPattern('(', ',', true, true, true);\n$expression->addPattern('one',\
    \ ',', true, true, true);\n$expression->addPattern('two', ',', true, true, true);\n\
    $expression->addPattern('three', ',', true, true, true);\n$expression->addPattern(')',\
    \ ',', true, true, true);\n\nvar_dump($expression->compile());\n</code>\nWhich\
    \ outputs:\n<code>\nstring(43) \"(,one,one,two,three)\"\n</code>\n<|/ a tags=regex,php,parsing\
    \ |>\n<| a |>\n<code>\n<?php\n$str = \"((one)(one)two(three)\";\npreg_match_all('/(?<=\\\
    ))(?=\\()/',$str,$matches);\n$matches[] = $matches[0];\nprint_r($matches);\n</code>\n\
    Output:\n<code>\nArray\n(\n    [0] => Array\n        (\n            [0] => (\n\
    \            [1] => (one\n            [2] => (one\n            [3] => two\n  \
    \          [4] => (three\n        )\n\n)\n</code>\n<|/ a dscore=0 tags=regex,php,parsing\
    \ |>\n<| a tags=regex,php,parsing dscore=0 |>\nI use this function to parse some\
    \ expressions and output an array.\n<code>", "    $paren_string = trim($paren_string);\n\
    \n    // This variable will hold the text outside of any parentheses\n    $outside_string\
    \ = '';\n\n    // This will hold one open brace at a time for checking\n    $open_curly\
    \ = null;\n\n    // This will hold one closing brace at a time for checking\n\
    \    $close_curly = null;\n\n    // This will hold one opening brace at a time\
    \ for checking\n    $open_paren = null;\n\n    // This will hold one closing brace\
    \ at a time for checking\n    $close_paren = null;\n\n    $open_bracket = false;\n\
    \    $close_bracket = false;\n    $open_curly = false;\n    $close_curly = false;\n\
    \    $open_paren = false;\n    $close_paren = false;\n\n    $open_paren_pos =\
    \ 0;\n    $open_curly_pos = 0;\n    $close_paren_pos = 0;\n    $close_curly_pos\
    \ = 0;\n\n    // Iterate over all characters\n    foreach (str_split($paren_string)\
    \ as $char) {\n        // When a paren is encountered, the start of a group\n\
    \        if ($char === '(') {\n            $open_paren_pos++;\n\n            //\
    \ If this is the first open paren, save it for later use\n            if ($open_paren_pos\
    \ === 1) {\n                $open_paren = $char;\n            }\n        } elseif\
    \ ($char === '{') {\n            $open_curly_pos++;\n\n            // If this\
    \ is the first open curly, save it for later use\n            if ($open_curly_pos\
    \ === 1) {\n                $open_curly = $char;\n            }\n        } elseif\
    \ ($char === '(') {\n            $open_paren_pos++;\n\n            // If this\
    \ is the first close paren, save it for later use\n            if ($open_paren_pos\
    \ === 1) {\n                $close_paren = $char;\n            }\n        } elseif\
    \ ($char === '{') {\n            $close_curly_pos++;\n\n            // If this\
    \ is the first close curly, save it for later use\n            if ($close_curly_pos\
    \ === 1) {\n                $close_curly = $char;\n            }\n        } elseif\
    \ ($char === ')') {\n            $close_paren_pos++;\n\n            // If this\
    \ is the last close paren, save it for later use\n            if ($close_paren_pos\
    \ === 1) {\n                $close_paren = $char;\n            }\n        } elseif\
    \ ($char === '}') {\n            $close_curly_pos++;\n\n            // If this\
    \ is the last close curly, save it for later use\n            if ($close_curly_pos\
    \ === 1) {\n                $close_curly = $char;\n            }\n        } elseif\
    \ ($char === ')') {\n            $close_paren_pos++;\n\n            // If this\
    \ is the last close paren, save it for later use\n            if ($", "    $paren_string\
    \ = preg_replace('/\\s+/', ' ', $paren_string);\n    $paren_array = explode(')',\
    \ $paren_string);\n    $paren_array_size = count($paren_array);\n    $paren_array_pointer\
    \ = 0;\n    $return_string = '';\n    for ($i = 0; $i < $paren_array_size; $i++)\
    \ {\n        if ($paren_array_pointer == $i) {\n            $return_string .=\
    \ $paren_array[$i];\n        } else {\n            if ($paren_array[$i] == (')'))\
    \ {\n                $return_string .= $paren_array[$i];\n                for\
    \ ($j = $paren_array_pointer + 1; $j < $i; $j++) {\n                    $return_string\
    \ .= $paren_array[$j];\n                }\n                $paren_array_pointer\
    \ = $i - 1;\n            }\n        }\n    }\n    return $return_string;\n}\n",
  "    // Initialize result array\n    $result_array = array();\n    // Iterate through\
    \ the string character by character until we reach the end of the string\n   \
    \ for ($i = 0; $i < strlen($paren_string); ++$i) {\n        // Get the character\
    \ from the string\n        $char_at_pos = $paren_string[$i];\n        // If the\
    \ character is a left parenthesis, push it to the result array and increment the\
    \ count\n        if ($char_at_pos == '(') {\n            $result_array[] = $paren_string;\n\
    \            // If the character is a right parenthesis, pop one value off the\
    \ result array and decrement the count\n        } elseif ($char_at_pos == ')')\
    \ {\n            array_pop($result_array);\n            --$i;\n            //\
    \ If the character is not a right parenthesis, or if the character is a space\n\
    \        } elseif ($char_at_pos != ' ') {\n            // If not a left parenthesis,\
    \ add it to the result array as a string\n            $result_array[] = $char_at_pos;\n\
    \            // If it is a space, we have reached the end of the string\n    \
    \    } elseif ($paren_string[$i + 1] == ' ') {\n            // If the character\
    \ is a right parenthesis, pop one value off the result array and decrement the\
    \ count\n            array_pop($result_array);\n            --$i;\n          \
    \  // If there are no more right parenthesis\n        } elseif ($paren_string[$i\
    \ + 1] != ')') {\n            // If there are no more left parenthesis\n     \
    \       break;\n        }\n    }\n    // Return the result array\n    return $result_array;\n\
    }\n\n$test_paren_string = '( ) (( )) (( )( ))';\n$result_array = separate_paren_groups($test_paren_string);\n\
    echo \"\\n The paren groups are: \\n\";\nprint_r($result_array);\necho \"\\n Number\
    \ of groups in the string is: \" . count($result_array);", "    // Your code here...\n\
    }\n</cell>\n<cell>", "    $paren_string = preg_replace('/\\s+/', ' ', $paren_string);\
    \ // Replace any spaces with a single space\n    $paren_string = preg_replace('/([^(]*)(\\\
    ([^\\)]*\\))*/', '$1', $paren_string); // Strip out everything in front of the\
    \ first open paren\n    $paren_string = preg_replace('/\\(([^\\)]*)\\)$/', '$1',\
    \ $paren_string); // Strip out everything after the last close paren\n    $paren_string\
    \ = preg_replace('/([^(]*)\\(([^\\)]*)\\)/', '$2', $paren_string); // Strip out\
    \ everything in front of the first open paren\n    $paren_string = preg_replace('/\\\
    (([^\\)]*)\\)$/', '$2', $paren_string); // Strip out everything after the last\
    \ close paren\n    $paren_string = preg_replace('/\\([^\\)]*\\)$/', '', $paren_string);\
    \ // Strip out everything in front and after the last close paren\n    return\
    \ explode(' ', $paren_string);\n}\n</code>\n<|/ a tags=php,string |>\n<| c |>\n\
    The first example doesn't work properly (it doesn't return `()`, it returns `()()`).\n\
    <|/ c |>\n<| c |>\nWhat does \"doesn't work properly\" mean?\n<|/ c |>\n<| c |>\n\
    It returns `()`\n<|/ c |>\n<| c |>\nOK - that's what I thought.  I changed it\
    \ slightly, now it should return `()()`\n<|/ c |>\n<| c |>\nSorry that wasn't\
    \ clear - I edited my comment.  I meant the first example doesn't work properly\
    \ (it doesn't return `()`, it returns `()()`).\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ can use a regex to match the opening parentheses with something like this:\n\
    <code>\n<?php\n$test = '(()()()';\npreg_match('/\\(/s', $test, $matches);\nprint_r($matches);\n\
    </code>\nThis will output\n<code>\nArray\n(\n    [0] => ()\n    [1] => ()\n  \
    \  [2] => ()\n    [3] => ()\n)\n</code>\nIf you want them to be removed, you can\
    \ add another preg_match to remove the parentheses:\n<code>\npreg_match('/\\(/s',\
    \ $test, $matches);\npreg_match('/\\)/s', $test, $matches);\nprint_r($matches);\n\
    </code>\nWhich will output\n<code>\nArray\n(\n    [0] => (()\n    [1] => (()\n\
    \    [2] => (()\n    [3] => (()", "    $paren_stack = array();\n    $paren_array\
    \ = array();\n    $current_string = '';\n\n    // Iterate through each character\
    \ in the string.\n    for ($i = 0; $i < strlen($paren_string); $i++) {\n     \
    \   $char = $paren_string[$i];\n\n        // If we see a new parenthesis, push\
    \ it to the paren stack\n        if ($char === '(') {\n            $paren_stack[]\
    \ = $current_string;\n            $current_string = '';\n        }\n\n       \
    \ // If we see a close parenthesis, extract the string and remove it from the\
    \ paren stack\n        elseif ($char === ')') {\n            // If the string\
    \ isn't empty, push it to the paren array\n            if (!empty($current_string))\
    \ {\n                $paren_array[] = $current_string;\n                $current_string\
    \ = '';\n            }\n\n            // If the last open paren was the most recently\
    \ closed, remove the string\n            elseif (isset($paren_stack[$paren_stack_key\
    \ = $paren_stack_key--])) {\n                unset($paren_stack[$paren_stack_key]);\n\
    \            }\n        }\n\n        // If it's not a closing parenthesis, add\
    \ the character to the current string\n        else {\n            $current_string\
    \ .= $char;\n        }\n    }\n\n    // If there are any remaining strings in\
    \ the paren array, push them to the paren array\n    if (!empty($current_string))\
    \ {\n        $paren_array[] = $current_string;\n    }\n\n    // Return the paren\
    \ array\n    return $paren_array;\n}\n</code>\n<|/ a tags=parsing,php |>\n<| c\
    \ |>\nThis looks very promising. I'll give this a try. Thanks so much.\n<|/ c\
    \ |>\n<| a |>\nThis regex is simple and should work in most cases, provided they\
    \ are balanced. The basic idea is this:\n\nGroup all the characters that aren't\
    \ parenthesis () into a character group\nGroup all the parenthesis into a parenthesis\
    \ group\nRemove the parenthesis from the string and return the string without\
    \ parenthesis\n\n<code>\npreg_replace_callback('/([^()]*)(\\()([^()]*)(\\))/',\
    \ function($matches) {\n    return $matches[1].$matches[3];\n}, '(()())')\n</code>\n\
    <|/ a tags=parsing,php dscore=0 |>\n<| a dscore=0 |>\nHere is an example using\
    \ PHP's regex engine with preg_match_all:\n<code>\n<?php\n\n$string = '(()())';\n\
    \npreg_match_all('/\\((.*?)\\)/', $string, $matches, PREG_SET_ORDER);\n\nforeach\
    \ ($matches as $match) {\n    echo $match[1].'<br/>';\n}\n", "    if (!$paren_string)\
    \ {\n        throw new \\Exception('Empty string');\n    }\n\n    $paren_groups\
    \ = array();\n    $open_braces = array();\n    $level = 0;\n\n    // Walk through\
    \ the string, one character at a time. If we find a close paren, increment the\
    \ level\n    // If not, add it to the current open brace list\n    for ($i = 0,\
    \ $len = strlen($paren_string); $i < $len; ++$i) {\n        $c = $paren_string[$i];\n\
    \n        if ($c == '(') {\n            $open_braces[] = $level;\n        } else\
    \ if ($c == ')') {\n            $level = $open_braces[count($open_braces) - 1];\n\
    \        } else {\n            $paren_groups[] = $paren_string[$i];\n        }\n\
    \    }\n\n    return $paren_groups;\n}\n</code>\n<|/ a tags=php,regex dscore=1\
    \ |>\n<| c |>\nIt doesn't work if the string looks like this: `(()()())` It returns\
    \ `Array()` instead of `Array('()', '(())', '(()())')`\n<|/ c |>\n<| c |>\nThat's\
    \ what I said. It will work for all cases. I checked it on a string with your\
    \ example and it works. It's not clear how you expect it to work for all cases.\
    \ It just gives you `['()', '(())', '(()())']` as output. The function returns\
    \ a list of all groups in the given string, which is then what you want for your\
    \ original question.\n<|/ c |>\n<| a |>\nTo get all possible groups of parenthesis\
    \ you may use this code:\n<code>\npreg_match_all('/\\(([^()]+)\\)/', $str, $matches);\n\
    </code>\n<|/ a tags=php,regex dscore=1 |>\n<| a dscore=1 |>\nA bit late, but here's\
    \ my solution:\n<code>\n<?php", "    $paren_string = rtrim($paren_string, ')');\n\
    \    $paren_string = ltrim($paren_string, '(');\n    // Separate each group into\
    \ an array of strings (the nested ones)\n    $nested_paren_groups = preg_split('/\\\
    s*(?<!\\()/', $paren_string);\n    // If the string is not actually a paren group\
    \ (i.e it is not a nested paren group) then just return it.\n    if (sizeof($nested_paren_groups)\
    \ !== 1) {\n        return $nested_paren_groups;\n    }\n    // Otherwise return\
    \ the nested paren group and keep track of how many open and close paren groups\
    \ it has.\n    // First find out how many nested paren groups there are, then\
    \ iterate through them and count how many\n    // open and close paren groups\
    \ it has.\n    $open_paren_groups = 0;\n    $nested_paren_group_index = 0;\n \
    \   foreach ($nested_paren_groups as $group) {\n        if (preg_match('/\\(/',\
    \ $group)) {\n            $open_paren_groups++;\n        }\n        else {\n \
    \           $open_paren_groups--;\n        }\n        // If this is the last nested\
    \ paren group then add it to the list with the correct amount of open paren groups.\n\
    \        if ($nested_paren_group_index === count($nested_paren_groups) - 1) {\n\
    \            $nested_paren_groups[$nested_paren_group_index] = str_repeat('(',\
    \ $open_paren_groups);\n        }\n        $nested_paren_group_index++;\n    }\n\
    \    // Return the groups with an added amount of open paren groups to match the\
    \ number of close paren groups.\n    return array_merge(array($nested_paren_groups[0]),\
    \ $nested_paren_groups);\n}\n</code>\n<|/ a tags=php,regex |>\n<| c |>\nThanks\
    \ for your answer. I did it like this in my situation:\n`function separate_paren_groups($paren_string)\
    \ {\n    return preg_split('/\\s*(?<!\\()/', $paren_string);\n}`\n<|/ c |>\n<|\
    \ a |>\nThis regex will match balanced parenthesis\n<code>\n$re = \"/\\\\(([^()]*)\\\
    \\)|\\\\([^()]*\\\\)/\";\n$str = \"( 1) ( ( 2) ) ( 3 ) ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 4 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )\
    \ ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ", "    $groups = [];\n\
    \    $current_group = [];\n    $len = strlen($paren_string);\n    for ($i = 0;\
    \ $i < $len; $i++) {\n        $char = $paren_string[$i];\n        if ($char ===\
    \ '(') {\n            $groups[] = '';\n            $current_group[] = $char;\n\
    \        } elseif ($char === ')') {\n            if (empty($current_group)) {\n\
    \                throw new Exception(\n                    'A group is unexpectedly\
    \ closed at position ' . $i . '. '\n                );\n            }\n      \
    \      $current_group[] = $char;\n            array_pop($groups);\n        } else\
    \ {\n            $groups[] = implode('', $current_group);\n            $current_group\
    \ = [];\n        }\n    }\n    return $groups;\n}\n", "    $paren_string = $paren_string;\n\
    \    $paren_array = array();\n    $paren_array_length = strlen($paren_string);\n\
    \    $open_brace_positions = array();\n    $open_brace_positions_length = count($open_brace_positions);\n\
    \    $open_parentheses = 1;\n    $open_parentheses_length = count($open_brace_positions);\n\
    \    for ($c = 0; $c < $paren_array_length; $c++) {\n        $char = substr($paren_string,\
    \ $c, 1);\n        // Check if this is the end of a group\n        if ($char ==\
    \ '}' || $char == ')') {\n            // Append the opening brace to the array\
    \ if it's an open brace\n            if ($char == '{') {\n                // Add\
    \ to the array\n                $paren_array[] = $char;\n            } else {\n\
    \                // If it's not an open brace, decrement the counter\n       \
    \         if ($open_parentheses == $open_parentheses_length) {\n             \
    \       --$open_parentheses_length;\n                } else if ($open_parentheses\
    \ == 0) {\n                    // Decrement the counter\n                    --$open_parentheses;\n\
    \                }\n            }\n            // If the counter is at 0, reset\
    \ it\n            if ($open_parentheses_length == 0) {\n                $open_parentheses\
    \ = 1;\n                $open_parentheses_length = count($open_brace_positions);\n\
    \            }\n            // If this was a closing brace, increment the counter\n\
    \            if ($char == ')') {\n                ++$open_parentheses;\n     \
    \       }\n            // If the counter is at 0, reset it\n            if ($open_parentheses_length\
    \ == 0) {\n                $open_parentheses = 1;\n                $open_parentheses_length\
    \ = count($open_brace_positions);\n            }\n        }\n    }\n    // If\
    \ there are any open braces left in the string, add them\n    if ($open_parentheses_length\
    \ > 0) {\n        for ($x = 0; $x < $open_parentheses_length; $x++) {\n      \
    \      $paren_array[] = $open_brace_positions[$x];\n        }\n    }\n    return\
    \ $paren_array;\n}\n", "    $groups = [];\n    // Loop through each paren, separating\
    \ it from the rest.\n    for ($i = 0; $i < strlen($paren_string); $i++) {\n  \
    \      // If this paren is open (not closed), add it to the group list.\n    \
    \    if ($paren_string[$i] === '(') {\n            $groups[] = '';\n        }\n\
    \        // If this paren is closed (not open), add it to the group list.\n  \
    \      else if ($paren_string[$i] === ')') {\n            $groups[count($groups)\
    \ - 1] .= ')';\n        }\n        // If this paren is open, and we aren't at\
    \ the start of a new group, close the last one.\n        else if ($paren_string[$i]\
    \ === ')' && !$i) {\n            $groups[count($groups) - 1] .= ')';\n       \
    \ }\n        // If this paren is open, and we are at the start of a new group,\
    \ remember to close it.\n        else if ($paren_string[$i] === ')' && $i) {\n\
    \            $groups[count($groups) - 1] .= ')';\n        }\n    }\n    return\
    \ $groups;\n}\n", "    $bracket_stack = array();\n    $paren_stack = array();\n\
    \    $paren_string = trim($paren_string);\n    $paren_string = trim($paren_string,\
    \ \"()\\t\\n\");\n    $paren_string = trim($paren_string, \"\\r\\n\");\n    $paren_string\
    \ = trim($paren_string, \" \\t\");\n    if ($paren_string == \"\") {\n       \
    \ return array();\n    }\n    $paren_string = preg_replace('/\\s+/', '', $paren_string);\
    \ // remove whitespace\n    $open_brackets = explode('(', $paren_string);\n  \
    \  for ($i = 0; $i < count($open_brackets); $i++) {\n        $open_bracket = $open_brackets[$i];\n\
    \        // If the open bracket is the final character in the string, then add\
    \ it to the return string\n        if ($open_bracket == substr($paren_string,\
    \ -1, 1)) {\n            $return_string = implode('', $paren_stack);\n       \
    \     $return_strings[] = $return_string;\n            return $return_strings;\n\
    \        }\n        // If there is a closing bracket to the left of the current\
    \ open bracket, then add it to the stack\n        if ($open_bracket == substr($paren_string,\
    \ $i, 1)) {\n            $paren_stack[] = $open_bracket;\n        }\n        //\
    \ If there is a closing bracket to the right of the current open bracket, then\
    \ add it to the stack\n        if ($open_bracket == substr($paren_string, $i+1,\
    \ 1)) {\n            $paren_stack[] = $open_bracket;\n        }\n        // Otherwise,\
    \ if the current open bracket is followed by a closing bracket (regardless of\
    \ its position), then\n        // add the current open bracket to the stack and\
    \ clear the paren stack\n        if ($open_bracket == substr($paren_string, $i+2,\
    \ 1)) {\n            $paren_stack[] = $open_bracket;\n            unset($paren_stack[0]);\n\
    \        }\n        // Otherwise, if there is an open bracket following the current\
    \ open bracket, then add it to the stack\n        if ($open_bracket == substr($paren_string,\
    \ $i+1, 1)) {\n            $paren_stack[] = $open_bracket;\n        }\n    }\n\
    \    return $paren_strings;\n}\n</code>\n<|/ a tags=php,regex,string |>\n<| a\
    \ |>\nI have created this regular expression which returns your desired results.\n\
    <code>\n((\\))|((^)|(\\{))|(($)))\n</code>\nHere is the link for regex101:\nhttps://regex101.com/r/lM6jN8/1\n\
    <|/ a tags=php,regex,string dscore=0 |>\n<|", "    $groups = array();\n    $bracket_stack\
    \ = array();\n    $open_brackets = 0;\n    $depth = 0;\n    $tokens = token_get_all($paren_string);\n\
    \n    foreach ($tokens as $token) {\n        switch ($token[0]) {\n          \
    \  case T_OPEN_PAREN:\n                $open_brackets++;\n                break;\n\
    \n            case T_CLOSE_PAREN:\n                $open_brackets--;\n       \
    \         break;\n\n            case T_STRING:\n                $bracket_stack\
    \ = array_merge($bracket_stack, array_slice($token[1], 1));\n                break;\n\
    \n            case T_ARRAY:\n                $depth--;\n\n                // If\
    \ the depth gets too deep, let's go one level deeper\n                if ($depth\
    \ < 0) {\n                    $depth++;\n                }\n                break;\n\
    \n            case T_INLINE_HTML:\n                $depth--;\n               \
    \ break;\n        }\n\n        // If there are open brackets, and the last token\
    \ is not an open bracket, let's save that group\n        if ($open_brackets >\
    \ 0 && isset($tokens[$open_brackets - 1]) && $tokens[$open_brackets - 1][0] ===\
    \ T_OPEN_PAREN) {\n            $groups[] = join('', array_slice($token[1], 1));\n\
    \        }\n    }\n\n    return $groups;\n}\n", "  if (empty($paren_string)) {\n\
    \    return [];\n  }\n\n  $brackets = [\n    'left_open' => [],\n    'left_closed'\
    \ => [],\n    'right_open' => [],\n    'right_closed' => [],\n  ];\n\n  $paren_stack\
    \ = [];\n  $pos = 0;\n  for ($i = 0; $i < strlen($paren_string); $i++) {\n   \
    \ $char = $paren_string[$i];\n    if (isset($brackets[$char])) {\n      $brackets[$char][]\
    \ = $paren_string[$pos];\n      array_push($paren_stack, $char);\n    } else {\n\
    \      if ($char == '(') {\n        array_push($paren_stack, $char);\n       \
    \ $brackets['left_open'][] = $char;\n      } else if ($char == ')') {\n      \
    \  if (!empty($paren_stack)) {\n          $bracket = array_pop($paren_stack);\n\
    \          if ($bracket == '(') {\n            $brackets['left_closed'][] = $bracket;\n\
    \          } else {\n            $brackets['right_closed'][] = $bracket;\n   \
    \       }\n        }\n      }\n    }\n    $pos++;\n  }\n  $result = [];\n  if\
    \ (!empty($paren_stack)) {\n    throw new Exception('Parenthesis unbalanced');\n\
    \  }\n\n  for ($i = 0; $i < count($brackets['left_open']); $i++) {\n    $brackets['left_open'][$i]\
    \ = substr($paren_string, $pos, $brackets['left_open'][$i]);\n  }\n  $pos++;\n\
    \  for ($i = 0; $i < count($brackets['right_open']); $i++) {\n    $brackets['right_open'][$i]\
    \ = substr($paren_string, $pos, $brackets['right_open'][$i]);\n  }\n  $pos++;\n\
    \  for ($i = 0; $i < count($brackets['left_closed']); $i++) {\n    $brackets['left_closed'][$i]\
    \ = substr($paren_string, $pos, $brackets['left_closed'][$i]);\n  }\n  $pos++;\n\
    \  for ($i = 0; $i < count($brackets['right_closed']); $i++) {\n    $brackets['right_closed'][$i]\
    \ = substr($paren_string, $pos, $brackets['right_closed'][$i]);\n  }\n\n  return\
    \ $result;\n}\n", "    $paren_groups = array();\n    $in_parens = false;\n   \
    \ for($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == '(') {\n            $in_parens = true;\n        } else if ($paren_string[$i]\
    \ == ')') {\n            $in_parens = false;\n        } else if ($in_parens &&\
    \ $paren_string[$i] == ' ') {\n            // Ignore spaces, unless we're already\
    \ inside a group\n            if (!$in_parens) {\n                continue;\n\
    \            }\n        }\n\n        if ($in_parens) {\n            $paren_groups[]\
    \ = substr($paren_string, $i, 1);\n        }\n    }\n\n    return $paren_groups;\n\
    }\n", "    $paren_groups = array();\n\n    $open_parens = array();\n    $nested_parens\
    \ = array();\n    $current_group = \"\";\n\n    // Push first open paren onto\
    \ $paren_groups array\n    array_push($paren_groups, $open_parens);\n\n    $paren_stack\
    \ = array();\n\n    // Iterate through every character in $paren_string\n    for\
    \ ($i = 0, $paren_length = strlen($paren_string); $i < $paren_length; $i++) {\n\
    \        // Get the current character\n        $current_char = $paren_string[$i];\n\
    \n        // Pop the last open paren from the $paren_stack\n        if (!empty($paren_stack))\
    \ {\n            array_pop($paren_stack);\n        }\n\n        if ($current_char\
    \ === \"(\") {\n            // Handle the opening paren\n            $nested_parens[]\
    \ = $current_group;\n            $current_group = trim($current_group . $current_char);\n\
    \        } else {\n            // Handle the closing paren\n            $current_group\
    \ = $current_group . \")\" . $current_char;\n        }\n\n        if ($current_char\
    \ === \"(\") {\n            // Push onto the $paren_stack\n            array_push($paren_stack,\
    \ $current_group);\n        } else if ($current_char === \")\") {\n          \
    \  // If there is an open paren at the top of the stack...\n            if (!empty($paren_stack))\
    \ {\n                // ... if the most recent character was also an open paren...\n\
    \                if ($current_group[0] === \"(\") {\n                    // ...\
    \ then this group is nested within the most recent open paren.\n             \
    \       $nested_parens[] = $current_group;\n                } else {\n       \
    \             // ... otherwise the most recent open paren is not nested within\
    \ the most recent group.\n                    // The most recent open paren belongs\
    \ to a different group, so push this new paren to the $paren_stack\n         \
    \           array_push($paren_stack, $current_group);\n                }\n   \
    \         } else {\n                // ... otherwise the most recent open paren\
    \ is nested within the most recent group.\n                // The most recent\
    \ open paren is also nested within another group, so push this new paren to the\
    \ $paren_stack\n                array_push($paren_stack, $current_group);\n  \
    \          }\n        }\n    }\n\n    // Remove the last paren from the $paren_stack,\
    \ if there is any\n    if (!empty($paren_stack)) {\n        array_pop($paren_stack);\n\
    \    }\n\n    // Reassemble the nested paren groups\n    foreach ($nested_parens\
    \ as $nested_paren) {\n        foreach (str_split($nested_paren) as $nested_group)\
    \ {\n            array_push($paren_groups, $nested_group);\n        }\n    }\n\
    \n    return $paren_groups;\n}\n</code>\n<|/ a |>\n<| c |>\nThank", "    $paren_groups\
    \ = array();\n    $open_brace_count = 0;\n\n    $input_len = strlen($paren_string);\n\
    \    for ($i = 0; $i < $input_len; $i++) {\n        $char = $paren_string[$i];\n\
    \n        if ($char == ' ') {\n            $open_brace_count = 0;\n        }\n\
    \n        if (($char == '(') || ($char == '{') || ($char == '[') || ($char ==\
    \ '<')) {\n            $open_brace_count++;\n        } else {\n            $open_brace_count--;\n\
    \n            if ($open_brace_count <= 0) {\n                $paren_groups[] =\
    \ substr($paren_string, 0, $i);\n                $paren_string = substr($paren_string,\
    \ $i + 1);\n                $input_len = strlen($paren_string);\n            \
    \    $i = $input_len - 1;\n            }\n        }\n    }\n\n    $paren_groups[]\
    \ = $paren_string;\n\n    return $paren_groups;\n}", "  $paren_string = preg_replace('/\
    \ {2,}/', ' ', $paren_string);\n  $paren_string = preg_replace('/\\((.*?)\\)\\\
    s+/', '$1', $paren_string);\n  $paren_string = preg_replace('/\\((.*?)\\)/', '$1',\
    \ $paren_string);\n  // $paren_string = preg_replace('/(.*?) +/', '$1', $paren_string);\n\
    \  // $paren_string = preg_replace('/\\s+\\)/', '', $paren_string);\n  // $paren_string\
    \ = preg_replace('/\\s+\\)/', '', $paren_string);\n  // $paren_string = preg_replace('/\\\
    ((.*?)\\)/', '$1', $paren_string);\n  return explode(', ', $paren_string);\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=php,regex |>\nHere's a solution that uses\
    \ recursion. I've tested it on some sample strings (on regex101) and it works.\n\
    <code>\n$regex = '~^(?:\\((?>[^()]|(?R))*\\))+$~';\n$input = '( ( )() )( ) ( (\
    \ ( ( ( ( ( ( ( ( ( ) )() )() )() )() )() )() )() )() )()';\n\n$output = preg_replace_callback($regex,function($matches)\
    \ {\n    return preg_split('~(?R)(?<=\\()~', $matches[0]);\n}, $input);\n</code>\n\
    The regex pattern matches \"(\" followed by one or more \"(\" followed by \"(\"\
    \ or \")\" recursively until the last \")\". Then it uses a callback function\
    \ to split each \"(\" into individual strings (by splitting on \"(?R)(?<=\\()\"\
    ).\n<|/ a dscore=3 |>\n<| a tags=php,regex |>\nThis is working for me:\n<code>\n\
    <?php\n$input = '( ( )() )( ) ( ( ( ( ( ( ( ( ( ( ( ) )() )() )() )() )() )()\
    \ )() )() )()';\n\n$output = preg_replace('/\\((.*?)\\)/', '$1', $input);\n\n\
    echo \"$output\";\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthis doesn't work. it\
    \ returns `( ( )() )( ) ( ( ( ( ( ( ( ( ( ( ( ) )() )() )() )() )() )() )() )()\
    \ )()` when it should return `( )( ) ( ( ( ( ( ( ( ( ( ( ( ) )() )() )() )", " \
    \   $stack = [];\n    $result = [];\n\n    $paren_string = str_replace([\")\"\
    , \"(\"], [\"\\n\", \"\\t\"], $paren_string);\n    $paren_string = str_replace(\"\
    \ \", \"\", $paren_string);\n\n    for($i = 0; $i < strlen($paren_string); $i++)\
    \ {\n        if($paren_string[$i] == \" \") {\n            $stack[] = $paren_string[$i];\n\
    \        }\n        elseif($paren_string[$i] == \")\") {\n            while(isset($stack[count($stack)\
    \ - 1])) {\n                if($paren_string[++$i] == \")\") {\n             \
    \       $stack[count($stack) - 1] .= \"\\n\";\n                }\n           \
    \     else {\n                    break;\n                }\n            }\n \
    \           if(isset($stack[count($stack) - 1])) {\n                $stack[count($stack)\
    \ - 1] .= \"\\n\";\n            }\n        }\n        else {\n            $new_string\
    \ = $paren_string[$i];\n            $new_stack = $stack;\n\n            while(isset($new_stack[count($new_stack)\
    \ - 1])) {\n                if(isset($new_stack[count($new_stack) - 1][$new_string])\
    \ && $new_stack[count($new_stack) - 1][$new_string] === $new_string) {\n     \
    \               $new_stack[count($new_stack) - 1] = array_pop($new_stack);\n \
    \               }\n                else {\n                    $new_stack[count($new_stack)\
    \ - 1] .= \"\\n\";\n                }\n            }\n\n            while(count($new_stack)\
    \ > 0) {\n                $result[] = array_pop($new_stack);\n            }\n\
    \            $stack = $new_stack;\n        }\n    }\n\n    return $result;\n}\n\
    \n$paren_string = '( ) (( )) (( )( ))';\n$result = separate_paren_groups($paren_string);\n\
    \nprint_r($result);\n</code>\n<|/ a dscore=2 tags=php,parentheses |>\n<| c |>\n\
    Thanks for your help, your solution is also correct, but I prefer Andreas Bunk's\
    \ solution.\n<|/ c |>\n<| c |>\nI agree, that Andreas solution is much more efficient.\
    \ I just wanted to provide a quick solution to your problem.\n<|/ c |>\n<| a dscore=1\
    \ tags=php,parentheses |>\nThis should do the trick:\n<code>", "  $paren_groups\
    \ = array();\n  preg_match_all('/\\([^)]*\\)/', $paren_string, $paren_groups);\n\
    \  return $paren_groups[0];\n}\n", "  if (empty($paren_string)) return array();\n\
    \  $paren_array = array();\n  $stack = array();\n  $len = strlen($paren_string);\n\
    \  $i = 0;\n  $in_paren_group = false;\n  while ($i < $len) {\n    if ($paren_string[$i]\
    \ == '(') {\n      // Found opening parenthesis, push it to the stack and set\
    \ flag\n      $paren_array[] = substr($paren_string, 0, $i);\n      $in_paren_group\
    \ = true;\n      $stack[] = $i;\n      $i++;\n      continue;\n    }\n    else\
    \ if ($paren_string[$i] == ')') {\n      // Found closing parenthesis\n      //\
    \ Check if the current element is the only one remaining in the stack\n      if\
    \ (empty($stack)) {\n        // If so, just pop it out and leave it blank\n  \
    \      $paren_array[] = substr($paren_string, $i);\n        continue;\n      }\n\
    \      $open_brace_count = count($paren_array);\n      // If there's more than\
    \ 1 opening brace, it's a nested group\n      if ($open_brace_count > 1) {\n \
    \       // Pop out the entire nested paren group and push the current element\
    \ onto the stack\n        $paren_array[] = substr($paren_string, $stack[count($stack)\
    \ - 1]);\n        $stack = array_slice($stack, 0, count($stack) - 1);\n      }\n\
    \      // Check if the current element is the only one remaining in the stack\n\
    \      if (empty($stack)) {\n        // If so, just pop it out and leave it blank\n\
    \        $paren_array[] = substr($paren_string, $i);\n        continue;\n    \
    \  }\n      // Pop out the top element from the stack\n      $paren_array[] =\
    \ substr($paren_string, $stack[count($stack) - 1]);\n      // Pop out all subsequent\
    \ stacked paren groups\n      $stack = array_slice($stack, 0, count($stack) -\
    \ 1);\n      // Set flag to false, since we haven't found closing parenthesis\n\
    \      $in_paren_group = false;\n    }\n    else if ($paren_string[$i] == ' ')\
    \ {\n      // Ignore spaces in the input string\n      continue;\n    }\n    else\
    \ if ($paren_string[$i] == ',') {\n      // Ignore commas in the input string\n\
    \      continue;\n    }\n    else if ($paren_string[$i] == ';') {\n      // Ignore\
    \ semicolons in the input string\n      continue;\n    }\n    else if ($paren_string[$i]\
    \ == ' ') {\n      // Ignore spaces in the input string\n      continue;\n   \
    \ }\n    else if ($paren_string[$i] == '.') {\n      // Ignore periods in the\
    \ input string\n      continue;\n    }\n    else {\n      // Found something else,\
    \ append to current element and continue\n      $paren_", "  $open_brace_stack\
    \ = array();\n  $paren_string = str_replace(array('(', '{', '[', '>', '>'), '',\
    \ trim($paren_string));\n  while ($paren_string !== '') {\n    $open_brace_stack\
    \ = array_merge($open_brace_stack, $paren_string{0} == '(' ? array() : array(substr($paren_string,\
    \ 0, 1)));\n    $paren_string = str_replace($open_brace_stack, array(''), $paren_string);\n\
    \  }\n  return array_filter(explode(')', $open_brace_stack));\n}\n", "    $group_stack\
    \ = array();\n\n    foreach (explode(' ', $paren_string) as $group_line) {\n \
    \       foreach (preg_split('/(\\s+)/', $group_line) as $group) {\n          \
    \  if ($group == '(' || $group == ')') {\n                if ($group == '(') {\n\
    \                    array_push($group_stack, $group);\n                } else\
    \ {\n                    if (count($group_stack) == 0 || $group_stack[count($group_stack)\
    \ - 1] != '(') {\n                        $group_stack[count($group_stack)] =\
    \ $group;\n                    } else {\n                        array_pop($group_stack);\n\
    \                    }\n                }\n            }\n        }\n    }\n\n\
    \    return $group_stack;\n}\n", "    // Your code here...\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nHi Amit - sorry to keep bothering you but I'm trying to work through\
    \ this and can't seem to make it work. I'd really appreciate it if you could help\
    \ me out by posting a code snippet. Thanks.\n<|/ c |>\n<| c |>\nOk, I'm working\
    \ on it\n<|/ c |>\n<| c |>\nI updated the answer (I wasn't getting all the parens,\
    \ sorry about that)\n<|/ c |>\n<| c |>\nAwesome! Thank you! One more thing - do\
    \ you happen to know how I would go about removing white spaces from a string\
    \ (such as \"(  ) ( )  )\") so that all whitespace is gone from the string? Thanks.\n\
    <|/ c |>\n<| c |>\nThis can be done by looping through each character and checking\
    \ if it is whitespace or not (ex: `if (!is_wsp($character))`)\n<|/ c |>\n<| a\
    \ |>\nI wrote a regex for you that might work for you here https://regex101.com/r/0vj0QC/1\n\
    It works well for me, but if you need more help let me know. \n<code>\n<?php\n\
    $string = '(( )) (  ( ( (( ()())((  )))   ((  ))  )(  ))   (( ())  ) ) ';\n\n\
    preg_match_all('/((\\()|(\\))|(\\()|(\\))|(\\()|(\\))|(\\()|(\\))|(\\()|(\\))|(\\\
    ()|(\\)))+\\)/', $string, $output);\nprint_r($output);", "    $paren_group_start\
    \ = 0;\n    $paren_group_end = 0;\n    $paren_groups = array();\n    for ($i =\
    \ 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i] == '(')\
    \ {\n            $paren_group_start = $i;\n        }\n        if ($paren_string[$i]\
    \ == ')') {\n            $paren_group_end = $i;\n        }\n        if ($paren_group_end\
    \ && $paren_group_start && ($paren_group_end != $paren_group_start)) {\n     \
    \       $paren_groups[] = substr($paren_string, $paren_group_start, $paren_group_end\
    \ - $paren_group_start);\n        }\n    }\n    return $paren_groups;\n}", " \
    \   // Use regex to find all groups of nested parentheses. Each group is separated\
    \ by a '('.\n    // Groups must be properly closed with a ')' that is not the\
    \ final character in the string.\n    $paren_groups = preg_match_all('/\\((?>[^()]*+|(?R))*\\\
    )/', $paren_string, $matches);\n\n    // If the string has any groups of nested\
    \ parentheses, return the list of those groups separated by '()'\n    if ($paren_groups\
    \ > 0) {\n        $paren_group_strings = $matches[0];\n    }\n\n    // If the\
    \ string has no groups of nested parentheses, return null (no string returned\
    \ indicates successful execution).\n    else {\n        return null;\n    }\n\n\
    \    // Iterate over the list of groups of parentheses\n    // For each group,\
    \ separate the contents by any non-opening parenthesis\n    // Return an array\
    \ of strings of those contents that are non-opening\n    $strings = array();\n\
    \    foreach ($paren_group_strings as $string) {\n        // Iterate over each\
    \ character in the string\n        foreach (str_split($string) as $char) {\n \
    \           // Skip opening parenthesis (unless it is an opening parenthesis in\
    \ which case it has no effect)\n            if ($char === '(' && !in_array($char,\
    \ $strings)) {\n                continue;\n            }\n            // Skip\
    \ closing parenthesis\n            if ($char === ')') {\n                break;\n\
    \            }\n            // Add char to list of contents since we are about\
    \ to return a list of non-opening\n            $strings[] = $char;\n        }\n\
    \    }\n\n    // Return the list of non-opening\n    return $strings;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWow, thank you so much! I really appreciate it. I was looking\
    \ at your regex and was thinking that it might not be an option but I didn't know\
    \ about this \"(?R)\" part of regex. Now I know.\n<|/ c |>\n<| c |>\nThat is very\
    \ helpful! Thanks so much. I was trying to figure out how I can use that regex\
    \ for matching in PHP.\n<|/ c |>\n<| a tags=regex,php |>\nI love the answer. Here\
    \ is another way to skin this cat.\n<code>\n<?php\n", "    if (strpos($paren_string,\
    \ '(') === FALSE) {\n        return [];\n    }\n\n    $paren_stack = [];\n   \
    \ $opening_braces = 0;\n\n    $paren_str = str_replace('(', '(#', $paren_string);\n\
    \    $len = strlen($paren_str);\n\n    // iterate through all characters\n   \
    \ for ($i = 0; $i < $len; $i++) {\n        // read next character\n        $char\
    \ = $paren_str[$i];\n\n        // if opening brace is closed\n        if ($char\
    \ === '(') {\n            // count this opening brace\n            $opening_braces++;\n\
    \n            // add character to stack if it is not a nested group\n        \
    \    if ($opening_braces > 0) {\n                $paren_stack[$opening_braces]\
    \ = $char;\n            }\n            // else it is a nested group but we don't\
    \ need to care about it\n            else {\n                $opening_braces--;\n\
    \            }\n        }\n\n        // if we are currently in a nested group\n\
    \        if ($opening_braces > 0) {\n            // close it\n            if ($char\
    \ === ')') {\n                $opening_braces--;\n            }\n        }\n\n\
    \        // if current character is a closing brace\n        if ($char === ')')\
    \ {\n            // add that closing brace to the stack\n            $paren_stack[$opening_braces]\
    \ = $char;\n        }\n    }\n\n    // iterate through stack and remove all unnecessary\
    \ spaces\n    for ($i = 0; $i < count($paren_stack); $i++) {\n        $paren_str[$i]\
    \ = strtr($paren_stack[$i], \"()#\", '');\n    }\n\n    // remove all spaces from\
    \ the string\n    $paren_str = str_replace(\" \", '', $paren_str);\n\n    // split\
    \ string by spaces\n    return preg_split('/\\s+/', $paren_str);\n}\n</code>\n\
    <|/ a tags=php,parentheses |>\n<| c |>\nI like this answer, but I'd like to see\
    \ your PHP version as it would be the best solution to this question ;)\n<|/ c\
    \ |>\n<| c |>\nThe regex is not only more elegant than the one liner. But, the\
    \ one liner also has a flaw. The string `foo(bar(baz(qux))` will split into `['foo',\
    \ '(bar(baz(qux)))']`, when it should split into `['foo', 'bar', 'baz(qux)']`.\n\
    <|/ c |>\n<| a dscore=4 |>\nI personally use a recursive function like so:\n<code>",
  "    // Start with a fresh empty array for our output\n    $paren_groups = array();\n\
    \    // Loop through each character in the string\n    foreach ($paren_string\
    \ as $char) {\n        // If it is a left paren, add it to the array\n       \
    \ if ($char == '(') {\n            $paren_groups[] = '';\n            // Loop\
    \ through each character in the string\n            foreach ($paren_string as\
    \ $char) {\n                // If the next character is a right paren, stop our\
    \ loop\n                if ($char == ')') {\n                    break;\n    \
    \            }\n                // If our current character is blank, add it to\
    \ the array\n                if ($char == ' ') {\n                    $paren_groups[]\
    \ = '';\n                } else {\n                    // Else, add it to the\
    \ array\n                    $paren_groups[] = $char;\n                }\n   \
    \         }\n        }\n        // If our current character is a left paren, add\
    \ it to the array\n        if ($char == '(') {\n            $paren_groups[] =\
    \ '';\n            // Loop through each character in the string\n            foreach\
    \ ($paren_string as $char) {\n                // If the current character is a\
    \ right paren, stop our loop\n                if ($char == ')') {\n          \
    \          break;\n                }\n                // If our current character\
    \ is blank, add it to the array\n                if ($char == ' ') {\n       \
    \             $paren_groups[] = '';\n                } else {\n              \
    \      // Else, add it to the array\n                    $paren_groups[] = $char;\n\
    \                }\n            }\n        }\n    }\n    // Return the array\n\
    \    return $paren_groups;\n}\n", "  $open_brackets = array();\n  $output_array\
    \ = array();\n\n  $curly = false;\n  $open_count = 1;\n  for($i = 0; $i < strlen($paren_string);\
    \ ++$i) {\n    $char = substr($paren_string, $i, 1);\n    if($char == '(' || $char\
    \ == '{' || $char == '[') {\n      // If it's a new group, create a new array\
    \ and add it to the output array.\n      if($char == '(') {\n        $output_array[$open_count++]\
    \ = array();\n        $open_brackets[$open_count-1][] = $i;\n      }\n      else\
    \ {\n        $curly = $char == '{' ? true : false;\n      }\n    }\n    else if($char\
    \ == ')' && $open_count > 0) {\n      // If it's part of a group, just close the\
    \ group\n      $open_brackets[$open_count-1][] = $i;\n      if($char == ')' &&\
    \ $open_brackets[$open_count-1][0] < strlen($paren_string)-1) {\n        $open_brackets[$open_count-1][]\
    \ = strlen($paren_string);\n      }\n      $open_count--;\n    }\n    else if($char\
    \ == '}' && $open_count > 0) {\n      // If it's part of a group, just close the\
    \ group\n      if($open_brackets[$open_count-1][0] < strlen($paren_string)-1)\
    \ {\n        $open_brackets[$open_count-1][] = strlen($paren_string);\n      }\n\
    \      if($char == '}') {\n        // If the next char is also a }, close the\
    \ group\n        if($open_brackets[$open_count-1][0] < strlen($paren_string)-1)\
    \ {\n          $open_brackets[$open_count-1][] = strlen($paren_string);\n    \
    \    }\n        $open_count--;\n      }\n    }\n    else if($char == ']' && $open_count\
    \ > 0) {\n      // If it's part of a group, just close the group\n      if($open_brackets[$open_count-1][0]\
    \ < strlen($paren_string)-1) {\n        $open_brackets[$open_count-1][] = strlen($paren_string);\n\
    \      }\n      if($char == ']') {\n        // If the next char is also a }, close\
    \ the group\n        if($open_brackets[$open_count-1][0] < strlen($paren_string)-1)\
    \ {\n          $open_brackets[$open_count-1][] = strlen($paren_string);\n    \
    \    }\n        $open_count--;\n      }\n    }\n    else if($char == ' ') {\n\
    \      // If it's a space, ignore it\n    }", "  $groups = [];\n  // Store opening\
    \ brace groups as we find them\n  $opening_groups = [];\n  // Keep track of whether\
    \ we've encountered a matching closing brace group\n  $encountered_matching_brace_group\
    \ = false;\n  // Iterate over the string\n  for($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n    // If the current char is equal to opening bracket, push it into\
    \ the list of opening brace groups\n    if($paren_string[$i] == ' ') {\n     \
    \ // Skip any spaces in the string\n      if($i == strlen($paren_string) - 1)\
    \ continue;\n      // If we've encountered a matching opening brace group\n  \
    \    if($encountered_matching_brace_group) {\n        // We should have encountered\
    \ a closing brace group at some point. Throw an error since we can't split these\
    \ groups\n        trigger_error(\"Error: Found nested paren groups in string\"\
    , E_USER_ERROR);\n      }\n      $encountered_matching_brace_group = true;\n \
    \     array_push($opening_groups, $i);\n    }\n    // If the current char is equal\
    \ to closing bracket, remove it from the list of opening brace groups\n    else\
    \ if($paren_string[$i] == '(') {\n      // Skip any spaces in the string\n   \
    \   if($i == strlen($paren_string) - 1) continue;\n      // If we haven't encountered\
    \ a matching closing brace group\n      if(!$encountered_matching_brace_group)\
    \ {\n        // Throw an error since we can't split these groups\n        trigger_error(\"\
    Error: Found unpaired paren group in string\", E_USER_ERROR);\n      }\n     \
    \ // Remove this opening brace group\n      array_pop($opening_groups);\n    }\n\
    \  }\n\n  // We haven't encountered a matching closing brace group yet, so throw\
    \ an error since we can't split these groups\n  if(!$encountered_matching_brace_group)\
    \ trigger_error(\"Error: Did not find matching paren groups in string\", E_USER_ERROR);\n\
    \n  // Iterate over the list of opening brace groups\n  for($i = 0; $i < count($opening_groups);\
    \ $i++) {\n    // Get the start and ending positions for each brace group\n  \
    \  $start = max(0, $opening_groups[$i]);\n    $end = min($i, strlen($paren_string));\n\
    \    // If the string ends with the closing brace group\n    if($end == strlen($paren_string)\
    \ - 1) {\n      // If this is a single brace group\n      if($paren_string[$end]\
    \ == ' ') {\n        // Add it to the list of brace groups\n        $groups[]\
    \ = substr($paren_string, $start, $end - $start + 1);\n      }\n      // Else",
  "    $paren_string = str_replace(\" \", \"\", $paren_string);\n    $paren_string\
    \ = str_replace(\"\\n\", \"\", $paren_string);\n    $paren_string = str_replace(\"\
    \\t\", \"\", $paren_string);\n    $paren_string = trim($paren_string);\n\n   \
    \ $groups = preg_match_all(\"/\\\\([^)]+\\\\)/\", $paren_string, $matches);\n\n\
    \    $groups = $matches[0];\n\n    return $groups;\n}\n</code>\n<|/ a tags=php,regex\
    \ |>\n<| c |>\nThank you for showing me how to do this. I tested your example\
    \ and it worked well.  I have not yet tested it with the actual data that I am\
    \ working with, but I will keep you posted.\n<|/ c |>\n<| c |>\nThe code works\
    \ for one exception.  It will separate parens with text or other parens.  Example\
    \ input: `(') ( ) (')`  Output is: `(()())`  When it should really be `(())`\n\
    <|/ c |>\n<| c |>\nJust a heads-up, this code isn't properly handling nested quotes\
    \ inside parens. I've tried using it in a regex tester and it won't work. I tried\
    \ to implement it for my own use, but I've encountered the same issue with nested\
    \ quotes. I was able to get around the issue by creating a separate regex to find\
    \ all text inside of parens. However, this still leaves me with the issue that\
    \ some quotes are being missed out when there are nested quotes inside the parens.\
    \ I tried to solve that by replacing double quotes with single quotes in the code,\
    \ but no luck.\n<|/ c |>\n<| c |>\nThe code does work for nested quotes inside\
    \ the parens. Try running it here: https://regex101.com/r/bM0nN0/3\n<|/ c |>\n\
    <| c |>\nOk, let me be more clear. Your example works fine for the parens situation,\
    \ but it will not work for the scenario where there are nested quotes inside of\
    \ parens.  Here is an example I ran against your code: `(') test ( ') (') ` I\
    \ expected it to return `(()())` but instead it returns `(())`. See here: https://regex101.com/r/bM0nN0/5\
    \  Please let me know if I am misunderstanding your code\n<|/ c |>\n<| a |>\n\
    You could do it with simple regex:\n<code>\n/((?!\\s)(?:[^()]|(?R))*)|(?<=\\s)\\\
    ((?!\\s)(?:[^()]|(?R))*\\)/g\n</code>\nLive demo\n<|/ a tag", "  // Loop through\
    \ each character in the string\n  for ($i = 0; $i < strlen($paren_string); $i++)\
    \ {\n    // If this character is a space\n    if ($paren_string[$i] == ' ') {\n\
    \      // If this is not the first character in the string\n      if ($i != 0)\
    \ {\n        // Add this character to the string before this space in the string\n\
    \        $paren_string = substr_replace($paren_string, '', $i, 1);\n      }\n\
    \      // Add this character to the string after this space in the string\n  \
    \    $paren_string = substr_replace($paren_string, '', $i + 1, 1);\n      // Continue\
    \ iterating through the string from there to find the next space to remove parens\
    \ from\n      $i = strpos($paren_string, ' ', $i + 1);\n    }\n\n    // If the\
    \ character is not the beginning of a grouping parenthesis\n    elseif ($paren_string[$i]\
    \ != '(') {\n      // If this character is not the beginning of a grouping parenthesis\n\
    \      if ($paren_string[$i] != ' ') {\n        // Add this character to the string\
    \ after this character in the string\n        $paren_string = substr_replace($paren_string,\
    \ '', $i, 1);\n      }\n      // Add a closing parenthesis to the string after\
    \ this character in the string\n      $paren_string = substr_replace($paren_string,\
    \ ')', $i, 1);\n      // Set the variable which stores the index of the last character\
    \ before the closing parenthesis\n      $last_open_brace_position = $i;\n    }\n\
    \n    // If the character is the beginning of a grouping parenthesis\n    elseif\
    \ ($paren_string[$i] == ' ') {\n      // If this is not the first character in\
    \ the string\n      if ($i != 0) {\n        // Add this character to the string\
    \ before this space in the string\n        $paren_string = substr_replace($paren_string,\
    \ '', $i, 1);\n      }\n      // Add this character to the string after this space\
    \ in the string\n      $paren_string = substr_replace($paren_string, '', $i +\
    \ 1, 1);\n      // Add an opening parenthesis to the string after this character\
    \ in the string\n      $paren_string = substr_replace($paren_string, '(', $i,\
    \ 1);\n      // Set the variable which stores the index of the last character\
    \ before the opening parenthesis\n      $last_open_brace_position = $i;\n    }\n\
    \n    // If this character is the end of a grouping parenthesis\n    elseif ($paren_string[$i]\
    \ == ')') {\n      // If this is the last character in the string\n      if ($i\
    \ == strlen($paren_string) - 1) {\n        // Add the closing parenthesis to the\
    \ string before this character in the string\n        $paren_string = substr_replace($paren_string,\
    \ ')', $i, 1);\n      }\n      // Add a closing parenthesis to the string before\
    \ this character in the string\n      $paren_string = substr", "    // Create\
    \ a string with each group of parentheses separated by a space\n    $nested_paren_string\
    \ = str_replace(' ', '     ', $paren_string);\n    // Create the regex pattern\
    \ to match the groups of parentheses\n    $nested_paren_regex = sprintf('/((?:%s)*)/s',\
    \ preg_quote($nested_paren_string, '/'));\n    // Run the regex pattern through\
    \ preg_match_all to find all groups of parentheses\n    preg_match_all($nested_paren_regex,\
    \ $paren_string, $nested_paren_matches);\n    // Return the array of matched groups\
    \ of parentheses\n    return $nested_paren_matches[0];\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThat is brilliant. Thanks for sharing the code.\n<|/ c |>\n<| c\
    \ |>\nThanks Mr.A. Thomas, your solution really saved my day. My requirement was\
    \ to split a string into individual words and all parentheses including nested\
    \ parentheses being considered as one group.\n<|/ c |>\n<| c |>\nAwesome! Thank\
    \ you very much. I needed to parse a lot of different strings and this was the\
    \ best solution that worked for me.\n<|/ c |>\n<| c |>\nThis is awesome. Thanks!\n\
    <|/ c |>\n<| c |>\n: Thank you!\n<|/ c |>\n<| a |>\nThe answers by David and Rick\
    \ Astley are great. Here's my own take on it using recursion. The main difference\
    \ is that my recursive approach doesn't require any additional regex patterns.\n\
    <code>\n<?php\n", "  $paren_groups = array();\n  $level = 0;\n  $opening_symbols\
    \ = array();\n  $last_char_index = 0;\n  while ($last_char_index < strlen($paren_string))\
    \ {\n    $char = substr($paren_string, $last_char_index);\n    switch ($char)\
    \ {\n      case ')':\n        if ($level == 0) {\n          $paren_groups[] =\
    \ substr($paren_string, 0, $last_char_index);\n          continue;\n        }\n\
    \        break;\n      case '(':\n        if (!$level) {\n          $opening_symbols[]\
    \ = $char;\n          continue;\n        }\n        break;\n      case ' ':\n\
    \        if ($level == 0) {\n          $opening_symbols = array();\n        }\n\
    \        break;\n      case '}':\n        if ($level == 0) {\n          $paren_groups[]\
    \ = substr($paren_string, 0, $last_char_index);\n          continue;\n       \
    \ }\n        $level--;\n        break;\n      case '{':\n        $level++;\n \
    \       break;\n      default:\n        throw new Exception(\n          pht(\n\
    \            \"Encountered unknown character when attempting to separate parent\
    \ groups from \".\n            \"each other in string: \\\"%s\\\".\",\n      \
    \      $char));\n    }\n\n    $last_char_index++;\n  }\n\n  if ($level != 0) {\n\
    \    throw new Exception(\n      pht(\n        \"Encountered unmatched parentheses\
    \ while trying to separate parent groups from \".\n        \"each other in string:\
    \ \\\"%s\\\".\",\n        $paren_string));\n  }\n\n  return $paren_groups;\n}\n\
    \n", "    $paren_string = preg_replace('/\\s+/', '', $paren_string);\n    $open_brace_array\
    \ = preg_split('/\\([^)]*\\)/', $paren_string, -1, PREG_SPLIT_DELIM_CAPTURE |\
    \ PREG_SPLIT_NO_EMPTY);\n    $closed_brace_array = preg_split('/\\[([^\\]]*\\\
    ])/', $paren_string, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n  \
    \  $paren_array = array_merge($open_brace_array, $closed_brace_array);\n    return\
    \ $paren_array;\n}", "    $open_brace_stack = array();\n    $close_brace_stack\
    \ = array();\n    $return_strings = array();\n\n    foreach (explode(\"\\n\",\
    \ $paren_string) as $line) {\n        // Ignore any spaces\n        $line = preg_replace(\"\
    /\\s/\", \"\", $line);\n\n        // Skip the line if it's empty\n        if (empty($line))\
    \ {\n            continue;\n        }\n\n        // If the line starts with a\
    \ left paren, push the brace onto the stack\n        if (substr($line, 0, 1) ==\
    \ \"(\") {\n            $open_brace_stack[] = $line;\n        }\n\n        //\
    \ If the line starts with a right paren, pop one off the stack\n        if (substr($line,\
    \ -1, 1) == \")\") {\n            $close_brace_stack[] = array_pop($open_brace_stack);\n\
    \        }\n\n        // If the line starts with one or more left parens, recursively\
    \ process it\n        if (preg_match(\"/^\\\\(.*\\\\)$/\", $line, $matches)) {\n\
    \            $open_brace_stack = array_merge($open_brace_stack, $matches[1]);\n\
    \        }\n\n        // If the line starts with one or more right parens, recursively\
    \ process it\n        if (preg_match(\"/^\\\\(.*\\\\)$/\", $line, $matches)) {\n\
    \            $close_brace_stack = array_merge($close_brace_stack, $matches[1]);\n\
    \        }\n\n        // If the line starts with one or more left parens and one\
    \ or more right parens, recursively process it\n        if (preg_match(\"/^\\\\\
    (.*\\\\).*\\\\(.*\\\\)$/\", $line, $matches)) {\n            $open_brace_stack\
    \ = array_merge($open_brace_stack, $matches[1]);\n            $close_brace_stack\
    \ = array_merge($close_brace_stack, $matches[2]);\n        }\n\n        // If\
    \ the line starts with one or more left parens, recursively process it\n     \
    \   if (preg_match(\"/^\\\\(.*\\\\)$/\", $line, $matches)) {\n            $open_brace_stack\
    \ = array_merge($open_brace_stack, $matches[1]);\n        }\n\n        // If the\
    \ line starts with one or more right parens, recursively process it\n        if\
    \ (preg_match(\"/^\\\\(.*\\\\).*\\\\(.*\\\\)$/\", $line, $matches)) {\n      \
    \      $close_brace_stack = array_merge($close_brace_stack, $matches[1]);\n  \
    \      }\n\n        // If the line starts with one or more left parens, recursively\
    \ process it\n        if (preg_match(\"/^\\\\(.*\\\\).*\\\\(.*\\\\)$/\", $line,\
    \ $matches)) {\n            $open_brace_stack = array_merge($open_bra", "  $result\
    \ = array();\n  $depth = 0;\n  for ($pos = 0; $pos < strlen($paren_string); $pos++)\
    \ {\n    // Find an opening parenthesis\n    $opening = strpos($paren_string,\
    \ $paren_string[$pos], $pos);\n    if ($opening === false) {\n      // This parenthesis\
    \ wasn't found\n      if ($paren_string[$pos] == ' ') continue;\n      else $opening\
    \ = strlen($paren_string);\n    }\n\n    // Find the next closing parenthesis\n\
    \    $closing = strpos($paren_string, $paren_string[$pos], $opening + 1);\n  \
    \  if ($closing === false) {\n      // This parenthesis wasn't found\n      if\
    \ ($paren_string[$pos] == ' ') continue;\n      else $closing = strlen($paren_string);\n\
    \    }\n\n    // Found the closing parenthesis, move backwards to the closing\
    \ position\n    $paren_string = substr($paren_string, 0, $closing);\n\n    //\
    \ Add an opening parenthesis to result if it's not the final element\n    if ($pos\
    \ < strlen($paren_string) - 1) {\n      if ($paren_string[$pos] == ' ') continue;\n\
    \      else $paren_string = $paren_string.' (';\n    }\n\n    // Add the closing\
    \ parenthesis to the list\n    $result[] = $paren_string;\n\n    // If we have\
    \ unbalanced parens, move forward in the string\n    $depth++;\n    if ($depth\
    \ > count($paren_string) - 1) $depth = 0;\n\n    $pos += strlen($paren_string);\n\
    \  }\n\n  return $result;\n}\n", "    // Ignore spaces in the string first\n \
    \   $paren_string = preg_replace('/ /', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/( )/', '((', $paren_string);\n    $paren_string = preg_replace('/(\
    \ )/', '(()', $paren_string);\n    $paren_string = preg_replace('/( )/', '(()()',\
    \ $paren_string);\n    $paren_string = preg_replace('/( )/', '(()()())', $paren_string);\n\
    \n    $group_arr = array();\n    $current_open = -1;\n    $current_close = -1;\n\
    \n    // Iterate through paren groups and add them to the array\n    foreach (explode('(',\
    \ $paren_string) as $open) {\n        $group_arr[] = $open;\n        ++$current_open;\n\
    \    }\n\n    // Iterate through paren groups and add them to the array\n    foreach\
    \ (explode(')', $paren_string) as $close) {\n        // Check if the group we're\
    \ closing is already open. If it is, leave it alone.\n        if ($current_close\
    \ >= 0 && $current_close == $open) {\n            continue;\n        }\n\n   \
    \     $group_arr[] = $close;\n        ++$current_close;\n    }\n\n    return $group_arr;\n\
    }\n</code>\n<|/ a tags=regex,php,php-5.6,preg-replace,nested-parentheses |>\n\
    <| c |>\nThanks, I was hoping to be able to do this without counting but this\
    \ helps.\n<|/ c |>\n<| c |>\nI added a comment to the question with the actual\
    \ algorithm used.\n<|/ c |>\n<| a |>\nIf you don't want to use recursion (as I\
    \ did), you can do this:\n<code>\n<?php\n", "  $paren_arr = preg_split('/\\((?=\\\
    ))\\)/', $paren_string);\n  $paren_arr2 = preg_split('/(?=\\))\\((?=\\))/', $paren_string);\n\
    \n  $count = 0;\n  foreach ($paren_arr as $key => $value) {\n    if ($value ===\
    \ '(') {\n      $count++;\n    }\n  }\n  $count = 0;\n  foreach ($paren_arr2 as\
    \ $key => $value) {\n    if ($value === '(') {\n      $count++;\n    }\n  }\n\n\
    \  $paren_arr = [];\n  $paren_arr2 = [];\n\n  if ($count !== 1) {\n    $paren_arr\
    \ = preg_split('/\\((?=\\))\\)/', $paren_string);\n    $paren_arr2 = preg_split('/(?=\\\
    ))\\((?=\\))/', $paren_string);\n  }\n  return [$paren_arr, $paren_arr2];\n}\n\
    </code>\n<|/ a tags=php,arrays dscore=1 |>\n<| c |>\ni don't see how this works?\
    \ can you explain? i can get it to do something, just not explain it\n<|/ c |>\n\
    <| c |>\nSure thing. Let me know if you still need an explanation.\n<|/ c |>\n\
    <| c |>\nThe first function separates each parenthesized group (the parenthesis\
    \ opening and closing brackets) from the string and stores them in an array. The\
    \ second function takes the array that first function returns (\"$paren_arr\"\
    ) and splits it into two separate arrays that are not nested within each other.\
    \ This means that in the example above, the first array contains 3 strings and\
    \ the second array contains 3 strings. The code example above is written for strings\
    \ containing multiple groups of parenthesized strings and therefore splits them\
    \ into two separate arrays.\n<|/ c |>\n<| c |>\nI wrote a quick and dirty explanation\
    \ to the code above and added some comments to the code so you can understand\
    \ how it works and why it works. Let me know if you still need an explanation.\n\
    <|/ c |>\n<| c |>\nI think I understand. but can you please explain each line\
    \ in the code? I'm not following what they do\n<|/ c |>\n<| a tags=php,arrays\
    \ |>\n<code>\n<?php\n\n$input='((()())())()((()()))((()))()(((()))())((())()())(((())))()()((())))()()';\n\
    \n$arr1 = explode('()', $input);\n$arr2 = array_filter($arr1, ", "    $paren_group\
    \ = array();\n    $inside_group = false;\n    $open_braces = 0;\n    $open_brace_paren\
    \ = 0;\n\n    $paren_string = preg_replace('/\\s+/', '', $paren_string);\n\n \
    \   for ($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == ' ') {\n            $inside_group = true;\n        }\n        if ($paren_string[$i]\
    \ == '(') {\n            if ($inside_group) {\n                $open_braces++;\n\
    \                $open_brace_paren++;\n            } else {\n                $open_braces++;\n\
    \                $open_brace_paren = 0;\n            }\n        } else if ($paren_string[$i]\
    \ == '(') {\n            if ($open_braces > 0) {\n                $open_braces--;\n\
    \            } else if ($open_brace_paren > 0) {\n                $open_brace_paren--;\n\
    \            }\n        } else if ($paren_string[$i] == ')') {\n            if\
    \ ($inside_group) {\n                $open_braces--;\n                $open_brace_paren--;\n\
    \            } else {\n                $open_braces--;\n                $open_brace_paren\
    \ = 0;\n            }\n        } else if ($paren_string[$i] == ')') {\n      \
    \      if ($open_braces == 0) {\n                $paren_group[] = substr($paren_string,\
    \ 0, $i);\n                $paren_string = substr($paren_string, $i);\n      \
    \      }\n        } else if ($paren_string[$i] == ' ') {\n            if ($open_braces\
    \ == 0 && $open_brace_paren == 0) {\n                $paren_string = substr($paren_string,\
    \ $i);\n            }\n        } else if ($paren_string[$i] == ',') {\n      \
    \      $inside_group = false;\n        }\n    }\n    if ($open_braces) {\n   \
    \     throw new Exception('Too many open parenthesis');\n    }\n    if ($open_brace_paren)\
    \ {\n        throw new Exception('Too many open parenthesis after closing the\
    \ first');\n    }\n    return $paren_group;\n}\n", "    preg_match_all('/\\(+/',\
    \ $paren_string, $matches);\n    $stack = [];\n    $cur_group = [];\n    $parens\
    \ = 0;\n    $groups = [];\n    foreach ($matches[0] as $match) {\n        if ($parens\
    \ == 0) {\n            if ($match == '(') {\n                $stack[] = $match;\n\
    \            } else {\n                $stack[] = '';\n            }\n       \
    \ } else {\n            if ($match == ')') {\n                while ($stack) {\n\
    \                    $s = array_pop($stack);\n                    if ($s == '(')\
    \ {\n                        $cur_group[] = $s;\n                        $parens\
    \ += 1;\n                    } else {\n                        $cur_group[] =\
    \ $s;\n                        $parens -= 1;\n                    }\n        \
    \        }\n                $cur_group[] = '';\n                $groups[] = $cur_group;\n\
    \                $cur_group = [];\n            } else {\n                $stack[]\
    \ = $match;\n            }\n        }\n    }\n    while ($stack) {\n        $s\
    \ = array_pop($stack);\n        if ($s == '(') {\n            $cur_group[] = $s;\n\
    \            $parens += 1;\n        } else {\n            $cur_group[] = $s;\n\
    \            $parens -= 1;\n        }\n    }\n    $groups[] = $cur_group;\n  \
    \  return $groups;\n}\n$test_string = \"( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ", "  // First, remove\
    \ multiple spaces\n  $paren_string = preg_replace('/\\s+/', ' ', $paren_string);\n\
    \  // Separate into groups\n  $groups = explode(' ', $paren_string);\n  // Make\
    \ sure that there is at least 1 group\n  if (count($groups) < 1) {\n    return\
    \ [];\n  }\n  // Make sure that all groups are properly balanced\n  $open_brace_count\
    \ = count(array_filter(\n    $groups,\n    function ($group) {\n      return strpos($group,\
    \ '(') !== false && strrpos($group, ')') !== strlen($group) - 1;\n    }\n  ));\n\
    \  if ($open_brace_count !== count($groups)) {\n    return [];\n  }\n  return\
    \ $groups;\n}\n</code>\n<|/ a tags=php,function,parentheses |>\n<| c |>\nIt fails\
    \ when the parens are within parentheses.\n<|/ c |>\n<| c |>\n: Sorry, I missed\
    \ that. Fixed now.\n<|/ c |>\n<| a dscore=3 |>\nFor those looking to use regex\
    \ with multiline support:\n<code>", "    $paren_string = preg_replace(\"/\\s+/\"\
    , \"\", $paren_string);\n    $paren_array = array();\n    $current_opening_brace_count\
    \ = -1;\n    $current_closing_brace_count = -1;\n    $opening_brace_stack = array();\n\
    \n    // Iterate through the string one character at a time\n    // If the current\
    \ character is a paren character, add the brace group to the list\n    // If the\
    \ current character is a closing brace, add the last brace group to the list,\
    \ then add it to\n    //  the stack\n    for($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        if($paren_string[$i] == '(') {\n            $paren_array[]\
    \ = substr($paren_string, 0, $i);\n            $opening_brace_stack[] = substr($paren_string,\
    \ 0, $i);\n        } else if($paren_string[$i] == ')') {\n            $paren_array[]\
    \ = substr($paren_string, 0, $i-1);\n            $paren_array[] = substr($paren_string,\
    \ $i-1, 1);\n            $opening_brace_stack[] = substr($paren_string, 0, $i-1);\n\
    \            $opening_brace_stack[] = substr($paren_string, $i-1, 1);\n      \
    \      $current_closing_brace_count++;\n        } else {\n            $opening_brace_stack[]\
    \ = $paren_string[$i];\n        }\n    }\n\n    // If the string did not contain\
    \ any closing braces, return the last group\n    if(count($opening_brace_stack)\
    \ == 0) {\n        return $paren_array;\n    }\n\n    // Remove the last brace\
    \ group from the stack, then remove it from the string\n    array_pop($opening_brace_stack);\n\
    \    $paren_string = substr($paren_string, strlen($opening_brace_stack[0]));\n\
    \n    // Iterate through the remaining string, adding each group to the list\n\
    \    for($i = 0; $i < strlen($paren_string); $i++) {\n        if($paren_string[$i]\
    \ == '(') {\n            $paren_array[] = substr($paren_string, 0, $i);\n    \
    \    } else if($paren_string[$i] == ')') {\n            $paren_array[] = substr($paren_string,\
    \ 0, $i-1);\n            $current_closing_brace_count--;\n        } else {\n \
    \           $paren_array[] = $paren_string[$i];\n        }\n    }\n\n    // If\
    \ the string did not contain any closing braces, return the last group\n    if($current_closing_brace_count\
    \ < 0) {\n        return $paren_array;\n    }\n\n    // If the string did not\
    \ contain any opening braces, return empty array\n    if(count($opening_brace_stack)\
    \ == 0) {\n        return array", "    preg_match_all('/\\(([^()]+|(?R))*\\)/',\
    \ $paren_string, $matches);\n    return $matches[1];\n}\n</code>\n<|/ a tags=php,regex,expression,string\
    \ dscore=0 |>\n<| a |>\nI found an solution that worked for me that looks like\
    \ this:\n<code>", "    if (!is_string($paren_string)) {\n        throw new InvalidArgumentException(\"\
    Invalid parameter. Parameter must be a string\");\n    }\n    $paren_string =\
    \ $paren_string;\n    $paren_string_len = strlen($paren_string);\n    $groups\
    \ = array();\n    $curly_pairs = array();\n    for ($i = 0; $i < $paren_string_len;\
    \ $i++) {\n        $char = $paren_string[$i];\n        if ($char == '(') {\n \
    \           $groups[] = '';\n            $curly_pairs[] = '';\n        } else\
    \ if ($char == ')') {\n            $groups[] = trim($curly_pairs[count($curly_pairs)\
    \ - 1]);\n            $curly_pairs[] = '';\n        } else {\n            $groups[]\
    \ = trim($curly_pairs[count($curly_pairs) - 1]);\n            $groups[] = $char;\n\
    \        }\n        $curly_pairs[] = '';\n    }\n    return $groups;\n}\n</code>\n\
    <|/ a dscore=0 tags=javascript,regex |>\n<| a |>\nJust use (...)+. That's what\
    \ it does: it captures as many groups as possible, while also not capturing the\
    \ (...) part itself.\nIn other words, it captures the contents of your parentheses,\
    \ regardless of what's inside of them.\n<|/ a tags=javascript,regex dscore=0 |>\n\
    <| c |>\nThe regex is not greedy, it is lazy.\n<|/ c |>\n<| c |>\n: Why is that?\
    \ I've used `/(...)+/g` many times and never had trouble with it.\n<|/ c |>\n\
    <| c |>\nYou are right and I have never had problems with it. But the OP asked\
    \ for regex which matches all groups, including inner ones. That is why I suggested\
    \ this kind of pattern. Since OP is aware of the fact that matching multiple groups\
    \ is easy and I suspect he is aware that regex is greedy but lazy by default.\
    \ `/(...)+/g` will match all the groups in the string without inner ones (if that\
    \ is what is desired of course). But it will also match a group that is not inside\
    \ of it.\n<|/ c |>\n<| c |>\n: You're both right. I'll edit my answer to reflect\
    \ that.\n<|/ c |>\n<| c |>\nI misunderstood the question. +1 for the right answer\n\
    <|/ c |>\n<| a tags=javascript,regex |>\nIf you don't want to capture the inner\
    \ parentheses, you could use a character class [()] instead of (...).\nIn that\
    \ case the regex will match the same number of characters as in the first ", " \
    \ // Separate every set of nested parentheses.\n  $paren_group_array = explode('(',\
    \ $paren_string);\n  $paren_group_array_count = count($paren_group_array);\n\n\
    \  // Keep track of how many parentheses we've opened already.\n  $paren_opened_count\
    \ = 0;\n  $paren_opened_array = [];\n\n  // Keep track of how many parentheses\
    \ we've closed already.\n  $paren_closed_count = 0;\n  $paren_closed_array = [];\n\
    \n  // Reset the count of parentheses we've opened on each new group.\n  $paren_opened_group\
    \ = 0;\n\n  // Iterate over every paren_group_array.\n  foreach ($paren_group_array\
    \ as $paren_group_element) {\n    // If the current element in the array is a\
    \ set of nested parentheses, make sure we close them all\n    // before opening\
    \ a new set of parentheses.\n    if (strpos($paren_group_element, ')') !== false)\
    \ {\n      $paren_closed_group++;\n    }\n\n    // If the current element is a\
    \ set of nested parentheses, make sure we close it all.\n    if (strpos($paren_group_element,\
    \ '(') !== false) {\n      $paren_closed_group++;\n    }\n\n    // If the current\
    \ element in the array is a set of nested parentheses, make sure we close it all.\n\
    \    if (strpos($paren_group_element, ')') !== false) {\n      $paren_closed_group++;\n\
    \    }\n\n    // If the current element is a set of nested parentheses, make sure\
    \ we close it all.\n    if (strpos($paren_group_element, '(') !== false) {\n \
    \     $paren_closed_group++;\n    }\n\n    // If the current element is a set\
    \ of nested parentheses, make sure we close it all.\n    if (strpos($paren_group_element,\
    \ '(') !== false) {\n      $paren_closed_group++;\n    }\n\n    // If the current\
    \ element is a set of nested parentheses, make sure we close it all.\n    if (strpos($paren_group_element,\
    \ '(') !== false) {\n      $paren_closed_group++;\n    }\n\n    // If the current\
    \ element is a set of nested parentheses, make sure we close it all.\n    if (strpos($paren_group_element,\
    \ '(') !== false) {\n      $paren_closed_group++;\n    }\n\n    // If the current\
    \ element is a set of nested parentheses, make sure we close it all.\n    if (strpos($paren_group_element,\
    \ '(') !== false) {\n      $paren_closed_group++;\n    }\n\n    // If we have\
    \ closed all of the parentheses we opened for this group, append it to $paren_opened_array.\n\
    \    if ($paren_closed_group === $paren_opened_group) {\n      $paren_opened_array[]\
    \ = $paren_group_element;\n    }\n\n    // If we have closed all of the parentheses\
    \ we opened for this ", "    $paren_string = preg_replace('/\\s+/', '', $paren_string);\
    \ // remove any whitespace\n    $paren_string = preg_replace('/^\\(|\\)$/', '',\
    \ $paren_string); // remove any parentheses at the beginning or end\n    $groups\
    \ = preg_split('/(?<=\\\\))(?=\\\\()/', $paren_string);\n    return $groups;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nPlease explain the code. While it may\
    \ answer the question, just code-only answers don't really help OP or future readers\
    \ understand the answers.\n<|/ c |>\n<| c |>\nI agree with the above comment from\
    \ Alister. I will add explanation and code as I understand it. I just started\
    \ learning php and am learning as I go.\n<|/ c |>\n<| c |>\nI like this one\n\
    <|/ c |>\n<| a tags=regex,php |>\nI suggest you to use recursive function for\
    \ this problem\n<code>", "    $paren_string = preg_replace('/\\s+/', '', $paren_string);\n\
    \    $paren_string = trim($paren_string);\n    $paren_string = preg_replace_callback('/\\\
    (\\s*((?>[^()]+|(?R))*)\\)/', 'extract_paren_groups', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\)/', '', $paren_string);\n    return explode(',', $paren_string);\n\
    }\n", "  preg_match_all('/\\((.+?)(?:\\))+\\)/', $paren_string, $m);\n  return\
    \ $m[1];\n}\n", "    $paren_groups = preg_split('~(?<!\\\\)(\\\\()|(\\\\()~',\
    \ $paren_string);\n    foreach ($paren_groups as $i => &$paren_group) {\n    \
    \    if ($paren_group == '(') {\n            $paren_group = $paren_groups[++$i];\n\
    \            continue;\n        }\n        if ($paren_group == ')') {\n      \
    \      $paren_group = $paren_groups[$i];\n            continue;\n        }\n \
    \   }\n    return $paren_groups;\n}\n", "    $paren_string = preg_replace(\"/(^\\\
    ()|(\\)$)/\", '', $paren_string);\n    $matches = array();\n    $nested_parens\
    \ = array();\n    $paren_count = 0;\n    $nested_paren_level = 0;\n    foreach\
    \ (explode(')', $paren_string) as $char) {\n        if ($char == '(') {\n    \
    \        $paren_count += 1;\n            $nested_paren_level += 1;\n         \
    \   $nested_parens[] = $paren_count;\n        } elseif ($char == ')') {\n    \
    \        $nested_paren_level -= 1;\n            if ($nested_paren_level == 0)\
    \ {\n                $nested_parens[] = $paren_count;\n            }\n       \
    \     $paren_count -= 1;\n        } else {\n            $nested_paren_level =\
    \ 0;\n            $paren_count = 0;\n        }\n    }\n    if ($paren_count >\
    \ 0) {\n        throw new Exception('Parens not closed properly');\n    }\n  \
    \  $paren_string = implode(')', $nested_parens);\n    $matches = array();\n  \
    \  $nested_paren_level = 0;\n    $nested_parens = array();\n    $paren_count =\
    \ 0;\n    foreach (explode(')', $paren_string) as $char) {\n        if ($char\
    \ == '(') {\n            $nested_paren_level += 1;\n            $nested_parens[]\
    \ = $paren_count;\n        } elseif ($char == ')') {\n            $nested_paren_level\
    \ -= 1;\n            if ($nested_paren_level == 0) {\n                $nested_parens[]\
    \ = $paren_count;\n            }\n            $paren_count -= 1;\n        } else\
    \ {\n            $nested_paren_level = 0;\n            $paren_count = 0;\n   \
    \     }\n    }\n    if ($nested_paren_level != 0) {\n        throw new Exception('Nested\
    \ parens not closed properly');\n    }\n    $matches[] = '(';\n    foreach ($nested_parens\
    \ as $nested_paren) {\n        $matches[] = str_repeat('(', $nested_paren);\n\
    \    }\n    $matches[] = ')';\n    return $matches;\n}\n", "  $paren_groups =\
    \ array();\n  $paren_open = false;\n  $paren_group = \"\";\n  foreach (str_split($paren_string)\
    \ as $char) {\n    if ($paren_open && $char == \"(\") {\n      $paren_open = false;\n\
    \      array_push($paren_groups, $paren_group);\n      $paren_group = \"\";\n\
    \    } else if ($paren_open) {\n      $paren_group .= $char;\n    } else {\n \
    \     $paren_open = ($char == \"(\" ? true : false);\n    }\n  }\n  return $paren_groups;\n\
    }\n", "    $paren_string_exploded = explode(')', $paren_string);\n    foreach\
    \ ($paren_string_exploded as $index => $group) {\n        // If the string starts\
    \ with an open paren, check if it is properly closed by another paren\n      \
    \  if ($group[0] == '(') {\n            $open_brace_count = get_count_of_braces_before($group,\
    \ $index);\n            // If the first open brace is properly closed by the next\
    \ one, we're good\n            if ($open_brace_count === $index + 1) {\n     \
    \           $paren_string_exploded[$index + 1] = substr($group, $open_brace_count\
    \ + 1);\n            }\n        }\n    }\n    // Remove the last group of parens\
    \ from the list\n    // Since this one was not properly closed, remove it from\
    \ the list so we don't end up with an empty group\n    $paren_string_exploded[count($paren_string_exploded)\
    \ - 1] = '';\n    return $paren_string_exploded;\n}\n", "  $groups = array();\n\
    \n  // Start with the full string and work backwards\n  $paren_string = preg_replace('/\\\
    s+/', '', $paren_string);\n  $paren_string = str_replace('()', '($1)', $paren_string);\n\
    \  $paren_string = str_replace('((', '($1)($1)', $paren_string);\n  $paren_string\
    \ = str_replace('))', ')($1)', $paren_string);\n  $paren_string = str_replace('()()',\
    \ '($1)($1)', $paren_string);\n\n  // Parse the string backwards looking for matching\
    \ parens\n  for ($i = count($paren_string) - 2; $i >= 0; $i -= 2) {\n    // Find\
    \ an opening paren\n    if (strpos($paren_string[$i], $paren_string[$i + 1]) !==\
    \ false) {\n      // Insert it into the group\n      $groups[] = substr($paren_string,\
    \ 0, $i);\n      // Replace the opening paren with the last character in the group\n\
    \      $paren_string = substr($paren_string, 0, $i).substr($paren_string, $i +\
    \ 1);\n    }\n  }\n\n  // Append the remainder of the string\n  $groups[] = $paren_string;\n\
    \n  return $groups;\n}\n", "    $open_paren_count = 0;\n    $paren_stack = [];\n\
    \    $bracket_stack = [];\n    $paren_matches = [];\n    $bracket_matches = [];\n\
    \    $paren_matches_tmp = [];\n    $bracket_matches_tmp = [];\n    $str_stack\
    \ = [];\n    $str_matches = [];\n    // Find all open parens\n    while ($open_paren_count\
    \ < strlen($paren_string)) {\n        if ($paren_string[$open_paren_count] ===\
    \ '(') {\n            array_push($str_stack, $paren_string[$open_paren_count]);\n\
    \            array_push($paren_stack, $open_paren_count);\n            array_push($str_matches,\
    \ $open_paren_count);\n            $str_stack[] = '(';\n            $str_matches[]\
    \ = $open_paren_count;\n            ++$open_paren_count;\n        }\n        elseif\
    \ ($paren_string[$open_paren_count] === '{') {\n            array_push($str_stack,\
    \ $paren_string[$open_paren_count]);\n            array_push($paren_stack, $open_paren_count);\n\
    \            array_push($str_matches, $open_paren_count);\n            $str_stack[]\
    \ = '{';\n            $str_matches[] = $open_paren_count;\n            ++$open_paren_count;\n\
    \        }\n        elseif ($paren_string[$open_paren_count] === '[') {\n    \
    \        array_push($str_stack, $paren_string[$open_paren_count]);\n         \
    \   array_push($paren_stack, $open_paren_count);\n            array_push($str_matches,\
    \ $open_paren_count);\n            $str_stack[] = '[';\n            $str_matches[]\
    \ = $open_paren_count;\n            ++$open_paren_count;\n        }\n        elseif\
    \ ($paren_string[$open_paren_count] === '{') {\n            array_push($str_stack,\
    \ $paren_string[$open_paren_count]);\n            array_push($paren_stack, $open_paren_count);\n\
    \            array_push($str_matches, $open_paren_count);\n            $str_stack[]\
    \ = '{';\n            $str_matches[] = $open_paren_count;\n            ++$open_paren_count;\n\
    \        }\n        elseif ($paren_string[$open_paren_count] === '[') {\n    \
    \        array_push($str_stack, $paren_string[$open_paren_count]);\n         \
    \   array_push($paren_stack, $open_paren_count);\n            array_push($str_matches,\
    \ $open_paren_count);\n            $str_stack[] = '[';\n            $str_matches[]\
    \ = $open_paren_count;\n            ++$open_paren_count;\n        }\n        elseif\
    \ ($paren_string[$open_paren_count] === '(') {", "    // Remove any leading and\
    \ trailing whitespace\n    $paren_string = trim($paren_string);\n    $paren_string\
    \ = preg_replace('/\\s+/', '', $paren_string);\n\n    // Keep track of how many\
    \ levels we have in the paren string. Start with 1 and then increment each time\
    \ we see a left paren\n    $level = 1;\n    $paren_string = str_repeat('()', $level);\n\
    \n    // Keep a stack of characters we are currently looking at. This keeps track\
    \ of how we go through the string and find each group\n    $open_parens = array();\n\
    \    $closed_parens = array();\n    $stack = array();\n\n    // Keep a stack of\
    \ characters that aren't currently inside a group. These characters are characters\
    \ like a space or opening bracket\n    $non_group_chars = array();\n\n    // Loop\
    \ through each character in the paren string\n    foreach (str_split($paren_string)\
    \ as $char) {\n        // If we are at a left paren, then add it to the stack\n\
    \        if ($char === '(') {\n            $open_parens[] = $char;\n        }\
    \ else {\n            // If we aren't at a left paren, add it to the list of non-group\
    \ characters\n            $non_group_chars[] = $char;\n        }\n\n        //\
    \ If we see a right paren, decrement our level\n        if ($char === ')') {\n\
    \            $level--;\n\n            // If the level is zero or negative, then\
    \ this isn't a group of parens, so pop it off the stack\n            if ($level\
    \ < 0) {\n                array_pop($stack);\n            }\n        }\n\n   \
    \     // If we are at a left paren, add it to the stack unless we are currently\
    \ in a group\n        if ($char === '(') {\n            if (!in_array($char, $stack))\
    \ {\n                $stack[] = $char;\n            }\n        }\n    }\n\n  \
    \  // Return an array of the strings we have created\n    return $stack;\n}\n",
  "    $paren_groups_array = array();\n    $paren_groups_string = preg_replace(\"\
    /(^|\\s)(\\()?(\\()?(\\()?(\\()?(\\()?(\\()?(\\()?/\", '\\\\1', $paren_string);\n\
    \    $paren_groups_string = preg_replace(\"/\\))?\\)$/\", '\\\\1', $paren_groups_string);\n\
    \    $paren_groups_array = explode('\\\\1', $paren_groups_string);\n    return\
    \ $paren_groups_array;\n}\n", "    $opened_paren_count = count($paren_string)\
    \ - 1;\n    $closed_paren_count = count($paren_string) - 2;\n    $result = [];\n\
    \    for ($i = 0; $i < $closed_paren_count; $i++) {\n        if ($paren_string[$i]\
    \ === '(') {\n            $i++;\n            if ($paren_string[$i] === ')') {\n\
    \                $i++;\n            }\n        }\n        $result[] = $paren_string[$i];\n\
    \    }\n    if ($closed_paren_count !== $opened_paren_count) {\n        throw\
    \ new Exception('Unbalanced parens');\n    }\n    return $result;\n}", "    return\
    \ preg_split('~(?<=\\\\)\\\\(\\\\))*\\\\(\\\\)(?=\\\\)\\\\(\\\\))*\\\\)~', $paren_string,\
    \ -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);\n}\n", "    $paren_string\
    \ = trim($paren_string);\n    $paren_string = preg_replace('/\\s/', '', $paren_string);\n\
    \    $paren_string_arr = explode(')', $paren_string);\n    return $paren_string_arr;\n\
    }\n", "    // Use a stack to keep track of nested groups\n    $paren_stack = [];\n\
    \n    // The output array that will contain the groups\n    $output = [];\n\n\
    \    // Iterate through each character in the input string\n    foreach ($paren_string\
    \ as $char) {\n        // If the character is one of the opening parens, push\
    \ it to the stack\n        if ($char == \"(\") {\n            array_push($paren_stack,\
    \ $char);\n        }\n        // If the character is one of the closing parens,\
    \ pop off the stack\n        elseif ($char == \")\") {\n            // Make sure\
    \ that there is an open paren left in the stack\n            if (count($paren_stack)\
    \ >= 1) {\n                array_pop($paren_stack);\n            }\n        }\n\
    \        // If the character is one of the special characters, push the character\
    \ on the stack\n        elseif ($char == \"|\") {\n            // Make sure that\
    \ there is an open paren left in the stack\n            if (count($paren_stack)\
    \ >= 1) {\n                array_push($paren_stack, $char);\n            }\n \
    \           // If the stack is empty, push the character to the output array\n\
    \            else {\n                array_push($output, $char);\n           \
    \ }\n        }\n        // If the stack is not empty and we have an open paren,\
    \ push the character on the stack\n        elseif (count($paren_stack) >= 1) {\n\
    \            array_push($paren_stack, $char);\n        }\n        // Otherwise,\
    \ just push the character to the output array\n        else {\n            array_push($output,\
    \ $char);\n        }\n    }\n\n    // Return the output array\n    return $output;\n\
    }\n</code>\nThe code above is an implementation of the same algorithm in PHP.\
    \ It returns an array of strings (not nested arrays). The function above will\
    \ also separate nested parentheses that you do not want to separate into separate\
    \ strings. I added the code to remove spaces using the preg_replace function.\n\
    The function will work with the example you provided but it will not work if you\
    \ have a string like this '( ( ))( )'. Your algorithm would result in ['(', '(()',\
    \ '(()())']. However, since you provided a test case that demonstrates this, I\
    \ wrote a quick test and added it to the above code. Here is the code I used for\
    \ the test:\n<code>\n<?php\n\n$string = '( ( ))( )';\n\n$output = separate_paren_groups($string);\n\
    \nvar_dump($output);\n", "    $paren_array = [];\n    $open_paren = 0;\n    $close_paren\
    \ = 0;\n    $ingroup = false;\n    for($i = 0; $i < strlen($paren_string); $i++)\
    \ {\n        if($paren_string[$i] == ' ') {\n            $ingroup = true;\n  \
    \      } elseif($paren_string[$i] == '(') {\n            $open_paren = $i;\n \
    \           $ingroup = true;\n        } elseif($paren_string[$i] == '(' && $close_paren\
    \ == 0) {\n            $paren_array[] = substr($paren_string, 0, $open_paren).'()';\n\
    \            $open_paren = 0;\n            $ingroup = true;\n        } elseif($paren_string[$i]\
    \ == ')' && $close_paren == 0) {\n            $paren_array[] = substr($paren_string,\
    \ 0, $open_paren).'()';\n            $open_paren = 0;\n            $ingroup =\
    \ false;\n        } elseif($paren_string[$i] == ')' && $close_paren != 0) {\n\
    \            $close_paren = $i;\n        } elseif($paren_string[$i] == ')' &&\
    \ $close_paren != 0 && $ingroup) {\n            $close_paren = $i;\n         \
    \   $paren_array[] = substr($paren_string, 0, $open_paren).'()';\n           \
    \ $open_paren = 0;\n            $ingroup = false;\n        }\n    }\n    return\
    \ $paren_array;\n}\n</code>\n<|/ a tags=javascript,php,regex dscore=0 |>\n<| c\
    \ |>\nThank you for the suggestions. I added some new code that works with your\
    \ suggestions and some explanations.\n<|/ c |>\n<| c |>\nThanks for the effort!\
    \ You did it again! But i cannot give an upvote because I don't have enough reputation\
    \ to do so...\n<|/ c |>\n<| c |>\nNo worries, thanks for the upvote! I see your\
    \ explanation was a lot more concise than the code I originally posted, but it\
    \ was also a lot more complicated than it needed to be. I'm glad you got it working.\n\
    <|/ c |>\n<| a tags=javascript,php,regex |>\nThe code below is based on a suggestion\
    \ by. \nThe code below works with PHP 5.3+ and JavaScript v1.7+.\nThe code below\
    \ also works with JavaScript v1.6+, but with extra regexp code. \nThe code below\
    \ also works with JavaScript v1.0+.\n<code>", "    $paren_count = substr_count($paren_string,\
    \ '(');\n    $nested_count = 1;\n    $groups = array();\n    $last_open_brace\
    \ = -1;\n    $open_brace_count = 0;\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        // If the character at the current index is not an open paren,\
    \ add it to the current group\n        // and continue to the next character in\
    \ the string\n        if ($paren_string[$i] != '(') {\n            $groups[] =\
    \ substr($paren_string, 0, $i);\n            $paren_count--;\n            if ($paren_count\
    \ == 0) {\n                $nested_count++;\n            }\n            continue;\n\
    \        }\n        // If the character at the current index is not a closing\
    \ paren, add the current group\n        // to the array and continue to the next\
    \ character in the string\n        if ($paren_string[$i] != ')') {\n         \
    \   $groups[] = substr($paren_string, 0, $i);\n            $paren_count--;\n \
    \           if ($paren_count == 0) {\n                $nested_count++;\n     \
    \       }\n            continue;\n        }\n        // If the character at the\
    \ current index is an opening paren, increment the open brace count\n        //\
    \ and add it to our current group\n        if ($paren_string[$i] == ' ') {\n \
    \           $open_brace_count++;\n            $groups[] = substr($paren_string,\
    \ 0, $i);\n            $paren_count--;\n            if ($paren_count == 0) {\n\
    \                $nested_count++;\n            }\n            continue;\n    \
    \    }\n        // If the character at the current index is a closing paren, decrement\
    \ the open brace count\n        // if the open brace count is zero, and add the\
    \ open brace count to the current group\n        if ($paren_string[$i] == ' '\
    \ && $open_brace_count > 0) {\n            $open_brace_count--;\n            if\
    \ ($open_brace_count == 0) {\n                $groups[] = substr($paren_string,\
    \ 0, $i);\n            }\n        }\n    }\n    return $groups;\n}\n", "    if\
    \ (!$paren_string) {\n        return [];\n    }\n\n    $result = explode('(',\
    \ $paren_string);\n    $result_count = (count($result) - 1);\n\n    for ($i =\
    \ 0; $i <= $result_count; $i++) {\n        $result[$i] = $result[$i][1];\n   \
    \ }\n    return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nVery cool! I just started\
    \ writing a similar function using regex to do the same thing. I'll post the function\
    \ when I get it working. Thanks for the suggestion\n<|/ c |>\n<| c |>\nOh man,\
    \ now that I've finished it, I realize I used the wrong word. I'll try to fix\
    \ the wording. Thanks for catching that issue. =)\n<|/ c |>\n<| c |>\nThanks for\
    \ sharing this - it's been quite useful to me in some scenarios.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nAs suggested in the comments, another approach that works with\
    \ multiple groups of nested parentheses (unlike my previous answer) is to use\
    \ regex. \n<code>", "    return array_filter(preg_split('/\\s*\\(\\(?|\\)\\)?\\\
    s*/', $paren_string));\n}\n</code>\nHere's a fiddle\n<|/ a tags=php,regex |>\n\
    <| c |>\nThis answer is better because it does not require the use of explode().\n\
    <|/ c |>\n<| c |>\nI love this solution, it uses pure regexp with no function\
    \ calls.\n<|/ c |>\n<| a tags=php,regex |>\nIn JavaScript you can use the following\
    \ regex:\n<code>\n/^\\((.+)\\)$/\n</code>\nIn PHP:\n<code>\n/^\\((.+)\\)$/\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=php,regex |>\nI made a function using preg_split.\
    \ \n<code>", "  if (strlen($paren_string) == 0) {\n    return array();\n  }\n\
    \  $paren_string = trim($paren_string);\n  $open_brace_count = array_count_values(str_split($paren_string,\
    \ 1))['('];\n  return array_filter(str_split($paren_string, $open_brace_count));\n\
    }\n", "  $paren_groups = array();\n  $open_braces = 0;\n  $close_braces = 0;\n\
    \  $paren_level = 0;\n  $open_brace_levels = array();\n  $closed_brace_levels\
    \ = array();\n  $paren_levels = array();\n  $open_parens = array();\n\n  foreach\
    \ ($paren_string as $char) {\n    if ($char === ' ') {\n      continue;\n    }\n\
    \n    if ($char === '(') {\n      $open_braces++;\n      $open_parens[] = $paren_level;\n\
    \      $paren_level++;\n      $open_brace_levels[] = $open_braces;\n      $paren_levels[]\
    \ = $paren_level;\n      $open_braces++;\n      $close_braces++;\n      $closed_brace_levels[]\
    \ = $close_braces;\n      $paren_levels[] = $paren_level;\n    }\n    else if\
    \ ($char === ')') {\n      $close_braces++;\n      $open_braces--;\n    }\n  \
    \  else if ($char === '(') {\n      $open_braces++;\n    }\n    else if ($char\
    \ === ')') {\n      $close_braces++;\n    }\n  }\n\n  for ($i = 0; $i < count($open_parens);\
    \ $i++) {\n    $paren_groups[$open_parens[$i]] = '';\n    $paren_levels[$open_parens[$i]]\
    \ = $open_brace_levels[$i];\n    for ($j = $paren_levels[$open_parens[$i]] - 1;\
    \ $j >= 0; $j--) {\n      if ($paren_levels[$j] >= $open_brace_levels[$i]) {\n\
    \        $paren_groups[$open_parens[$i]] .= '(';\n        $paren_levels[$open_parens[$i]]\
    \ = $paren_levels[$j] + 1;\n      }\n      else {\n        $paren_groups[$open_parens[$i]]\
    \ .= ')';\n        $paren_levels[$open_parens[$i]] = $paren_levels[$j];\n    \
    \  }\n    }\n  }\n\n  return $paren_groups;\n}\n", "  $paren_stack = array();\n\
    \  $open_braces = array();\n  $paren_level = 0;\n  $open_paren_level = 0;\n  foreach\
    \ (str_split($paren_string) as $c) {\n    switch ($c) {\n      case '(':\n   \
    \     if ($paren_level == 0) {\n          $open_paren_level++;\n        } else\
    \ {\n          if ($open_paren_level == $paren_level) {\n            $open_braces[]\
    \ = $c;\n          }\n        }\n        $paren_level++;\n        break;\n   \
    \   case ')':\n        if ($paren_level == 0) {\n          $open_paren_level--;\n\
    \        } else {\n          if ($open_paren_level == $paren_level) {\n      \
    \      $open_braces[] = $c;\n          }\n        }\n        $paren_level--;\n\
    \        break;\n      case ' ':\n        // Nothing to do\n        break;\n \
    \   }\n  }\n  unset($c, $open_braces, $paren_level);\n  return $paren_stack;\n\
    }\n", "    $output = array();\n    do {\n        $current_group = array();\n \
    \       $open_brackets = preg_match_all('/\\(([^()]*)\\)/', $paren_string, $paren_matches);\n\
    \        if ($open_brackets) {\n            $paren_groups = preg_split('/[()]/',\
    \ $paren_string);\n            foreach ($paren_groups as $index => $paren_group)\
    \ {\n                $current_group[] = $paren_group;\n                if ($open_brackets\
    \ > 1) {\n                    $output[] = implode('', $current_group);\n     \
    \               $current_group = array();\n                }\n            }\n\
    \        }\n    } while ($open_brackets > 0);\n\n    return $output;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWhile I appreciate this answer, this doesn't seem to address\
    \ any concerns I mentioned in my question (eg, no recursion and no need for nested\
    \ regex patterns and loops).\n<|/ c |>\n<| c |>\nI appreciate your answer!\n<|/\
    \ c |>\n<| a tags=recursion,php,nested,regex |>\nI made this php script that recursively\
    \ splits nested parenthesis into separate strings. It's not 100% tested so use\
    \ at your own risk.\n<code>\n<?php\n\nclass RecursiveParenthesisSplitter\n{\n\
    \    /**\n     * string $string\n     * array\n     */\n    public function split(string\
    \ $string)\n    {\n        $string = $this->removeNewlines($string);\n       \
    \ $string = $this->removeTabs($string);\n\n        $splits = $this->split($string,\
    \ 1, $lastIndex = -1, $stack = []);\n        $splits[] = '';\n        return $splits;\n\
    \    }\n\n    /**\n     * string $string\n     * int $index\n     * int $lastIndex\n\
    \     * array $stack\n     * array\n     */\n    private function split(string\
    \ $string, int $index, int $lastIndex, array $stack): array\n    {\n        $splits\
    \ = array();\n        $index = $this->removeWhitespace($string, $index, $lastIndex,\
    \ $stack);\n\n        if ($index == $lastIndex) {\n            $stack[] = $string;\n\
    \            return $splits;\n        }\n\n        $parens = substr($string, $index,\
    \ 1);\n\n        $leftParen = $parens[0] === '(';\n        $rightParen = $parens[0]\
    \ === ')';\n\n        if ($leftParen || $rightParen) {\n            $string =\
    \ $this->removeWhitespace($string, $index, $lastIndex, $stack);\n            $string\
    \ = $this->removeNewlines($string);\n            $string = $this->removeTabs($string);\n\
    \n            $splits = array_merge($split", "    $pattern = '/(?<! \\() \\))*\\\
    s*\\((?!\\((?!\\s*\\)))+\\s*/';\n    preg_match_all($pattern, $paren_string, $matches);\n\
    \    return $matches[0]; \n}\n", "  // Split all nested brackets into separate\
    \ groups\n  $paren_array = preg_split('/([\\(\\)])/', $paren_string);\n  // Ignore\
    \ spaces in input string\n  $paren_array = preg_replace('/\\s/', '', $paren_array);\n\
    \  // Return all nested groups\n  return $paren_array;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis works like a charm for my specific use case and should be the accepted\
    \ answer. Thanks!\n<|/ c |>\n<| a tags=php,regex,parentheses |>\nThis might be\
    \ a little too simplistic but you could probably do this with regular expressions:\n\
    <code>\n$str = '((abc)) ((xyz))';\npreg_match_all('/\\((.*?)\\)/', $str, $matches);\n\
    print_r($matches);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => Array\n   \
    \     (\n            [0] => (abc)\n            [1] => (xyz)\n        )\n\n)\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\n<?php\n$string = \"(((abc)def)ghi\"\
    ;\n\npreg_match_all(\"/\\(([^()]+)\\)/\", $string, $matches);\n\nprint_r($matches[1]);\n",
  "    return preg_split(\"/\\s*\\((?=.*\\))\\s*|(?<=\\))\\s*(?=\\()/\", $paren_string);\n\
    }", "    // Return an empty array if there is no valid input data\n    if (empty($paren_string))\
    \ {\n        return array();\n    }\n\n    // Make sure the string is valid\n\
    \    if (!is_string($paren_string) || empty($paren_string)) {\n        echo \"\
    Input string is not a valid string\\n\";\n        return array();\n    }\n\n \
    \   // Count the number of times a substring appears in our string.\n    // We\
    \ will use this later to find out when our paren is balanced.\n    $paren_count\
    \ = substr_count($paren_string, \"(\");\n\n    // Split the string and place all\
    \ nested paren groups into an array\n    $nested_paren_groups = explode(\"(\"\
    , $paren_string);\n\n    // Create a temporary array to store the results as we\
    \ loop through\n    $results = array();\n\n    // Loop through the string\n  \
    \  foreach ($nested_paren_groups as $index => $nested_paren_group) {\n       \
    \ // If our current paren group is empty or has no nested paren groups place it\
    \ in our results array\n        if (empty($nested_paren_group) || !is_string($nested_paren_group))\
    \ {\n            $results[] = $nested_paren_group;\n            continue;\n  \
    \      }\n\n        // Make sure the nested paren group is a string\n        if\
    \ (!is_string($nested_paren_group)) {\n            echo \"Your nested paren group\
    \ is not a string\\n\";\n            return array();\n        }\n\n        //\
    \ Find the number of open parentheses in this group\n        $open_paren_count\
    \ = substr_count($nested_paren_group, \"(\");\n\n        // If we do not have\
    \ enough open parentheses then this group must be nested within another paren\n\
    \        // So we need to recursively call the function again to find all the\
    \ groups in this group\n        // and place them in the results array\n     \
    \   if ($open_paren_count < $paren_count) {\n            $nested_paren_groups\
    \ = array_merge(separate_paren_groups($nested_paren_group), $nested_paren_groups);\n\
    \        }\n\n        // Add the nested group to the results array\n        $results[]\
    \ = $nested_paren_group;\n    }\n\n    // Return the results array\n    return\
    \ $results;\n}\n", "    $open_braces = array();\n    $closing_braces = array();\n\
    \n    for ($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == ' ') {\n            continue;\n        }\n\n        // If the next character\
    \ is another brace (not an opening brace or closing brace - which would cause\
    \ an\n        // additional open/close group to be started...\n        if ($paren_string[$i+1]\
    \ == '(') {\n            $closing_braces[] = $paren_string[$i];\n            continue;\n\
    \        }\n\n        // Otherwise if the next character is a closing brace, add\
    \ it to the list of opening braces\n        // and set the current opening brace\
    \ to that next character\n        if ($paren_string[$i+1] == ')') {\n        \
    \    $open_braces[] = $paren_string[$i];\n            $i = $i + 1;\n        }\n\
    \    }\n\n    return $open_braces;\n}", "  $paren_string_array = preg_split('/\\\
    s+/', $paren_string, -1, PREG_SPLIT_NO_EMPTY);\n  $paren_string_array = array_filter($paren_string_array,\
    \ 'strlen');\n  return $paren_string_array;\n}\n\n/**\n * Take the string input\
    \ from the form field and turn it into a list of tuples, where the first\n * element\
    \ is the string and the second element is the index number. For example\n * >>>\
    \ [('a', '1'), ('b','2')]\n * >>> [('A','1'), ('B','2')]\n * >>> [('a', '1'),\
    \ ('b','2'), ('C','3'), ('D','4'), ('E','5'), ('F','6')]\n *\n * TODO: What if\
    \ someone enters a comma separated list of multiple words? Like \"a, b, c, d,\
    \ e\"\n *\n * @param string $form_field The input field in the form as entered\
    \ by the user\n *\n * @return array The input string as an array of tuples representing\
    \ the words and indexes\n */", "    $paren_matches = [];\n    preg_match_all('/\\\
    ((.*?)\\)/', $paren_string, $paren_matches);\n    return $paren_matches[1];\n}",
  "    $open_braces = 0;\n    $closed_braces = 0;\n    $result = [];\n    $brace_counter\
    \ = [];\n    $is_open = false;\n    foreach (explode(')', $paren_string) as $sub_string)\
    \ {\n        // Ignore spaces inside the parens\n        if (!preg_match('/^\\\
    s*$/', $sub_string)) {\n            // New group found\n            if ($is_open)\
    \ {\n                if ($sub_string{0} === '(') {\n                    $closed_braces++;\n\
    \                } else if ($sub_string{0} === '{') {\n                    $brace_counter[$sub_string]++;\n\
    \                }\n                // Open Brace is closed (but make sure not\
    \ to open any new ones)\n                if ($closed_braces > $open_braces ||\
    \ ($closed_braces === $open_braces && $brace_counter[$sub_string] > 1)) {\n  \
    \                  $is_open = false;\n                }\n            } else {\n\
    \                // Close the previous open group (if any)\n                if\
    \ ($open_braces && ($is_open)) {\n                    if ($sub_string{0} === '(')\
    \ {\n                        $open_braces--;\n                    } else if ($sub_string{0}\
    \ === '{') {\n                        $brace_counter[$sub_string]--;\n       \
    \             }\n                }\n                // Open a new group\n    \
    \            $open_braces++;\n                $is_open = true;\n            }\n\
    \        }\n        // Add this char to the result string\n        $result[] =\
    \ $sub_string;\n    }\n    return $result;\n}\n", "\t$groups = array();\n\t//\
    \ Each time we find a set of parenthesis, we add a new group to the list\n\t//\
    \ and begin to populate it with the group's contents\n\tfor ($charpos=0; $charpos\
    \ < strlen($paren_string); $charpos++) {\n\t\tif ($paren_string[$charpos] ===\
    \ '(') {\n\t\t\t$groups[] = '';\n\t\t}\n\n\t\t$groups[] = $paren_string[$charpos];\n\
    \t\tif ($paren_string[$charpos] === ')') {\n\t\t\t$group_contents = $groups[count($groups)\
    \ - 1];\n\t\t\tunset($groups[count($groups) - 1]);\n\t\t\t$groups[count($groups)\
    \ - 1] = $group_contents;\n\t\t}\n\t}\n\treturn $groups;\n}\n", "    $paren_string_length\
    \ = strlen($paren_string);\n    $out = [];\n    for ($i = 0; $i < $paren_string_length;\
    \ $i++) {\n        $out[] = $paren_string[$i];\n        if ($paren_string[$i]\
    \ == \"(\") {\n            $out[] = \"\";\n        }\n        if ($paren_string[$i]\
    \ == \")\") {\n            $out[] = \"\";\n        }\n    }\n    return $out;\n\
    }\n", "    // Make sure there are some openings. \n    if (strpos($paren_string,\
    \ '(') !== false) {\n        // Get rid of the opening parens.\n        $paren_string\
    \ = trim($paren_string, '()');\n        // If the opening parens are actually\
    \ balanced (do not have unclosed parens in them)\n        if (strpos($paren_string,\
    \ '(') !== false) {\n            // Find all opening parens.\n            $paren_positions\
    \ = str_pos($paren_string, '(');\n            // Make sure the closing parens\
    \ are there.\n            $found_parens = strpos($paren_string, ')');\n      \
    \      // Make sure there is an actual closing paren somewhere.\n            if\
    \ ($found_parens === false) throw new Exception('No closing parens found.');\n\
    \            // Make sure the closing parens follow the opening parens.\n    \
    \        if ($paren_positions + 1 !== $found_parens) throw new Exception('Closing\
    \ parens do not follow opening parens.');\n            // Make sure the closing\
    \ parens match this opening paren group.\n            if ($found_parens != $paren_positions)\
    \ throw new Exception('Closing parens don\\'t match opening paren groups.');\n\
    \            // Make sure the number of opening and closing parens match.\n  \
    \          if ($paren_positions != strlen($paren_string)) throw new Exception('Mismatched\
    \ number of opening paren and closing paren.');\n            // Make sure there\
    \ aren't nested opening parens somewhere else.\n            $paren_string = str_replace($paren_string,\
    \ '(', $paren_string);\n            $paren_string = str_replace(')', ')', $paren_string);\n\
    \            // Make sure there aren't nested closing parens somewhere else.\n\
    \            $paren_string = str_replace(')', '(', $paren_string);\n         \
    \   // Make sure there are some closing parens.\n            if (strpos($paren_string,\
    \ '(') !== false) {\n                // Get rid of all the closing parens.\n \
    \               $paren_string = trim($paren_string, '()');\n                //\
    \ Make sure there are no unclosed parens in the string.\n                if (strpos($paren_string,\
    \ '(') === false) throw new Exception('No unclosed parens found.');\n        \
    \    }\n        }\n    }\n    // Make sure there are no spaces in the string.\n\
    \    if (strpos($paren_string, ' ') !== false) throw new Exception('Spaces found.\
    \ Try trimming the string.');\n    // Make sure there are parens in the string.\n\
    \    if (strpos($paren_string, '(') === false) throw new Exception('No parentheses\
    \ found.');\n    // Remove all spaces from the string.\n    $paren_string = trim($paren_string,\
    \ '()');\n    // Make sure there are parens in the string.\n    if (strpos($paren_string,\
    \ '(') === false) throw new Exception('No parentheses found.');\n    // Return\
    \ the list of parens.\n    return $paren_string;\n}\n</code>", "    $group_stack\
    \ = [];\n    $group_string = '';\n\n    $paren_array = explode('(', $paren_string);\n\
    \    foreach ($paren_array as $key => $paren) {\n        if ($paren == '(') {\n\
    \            $group_stack[] = $paren;\n        } else {\n            $group_string\
    \ .= $paren;\n            if (count($group_stack) == 0) {\n                $results[]\
    \ = $group_string;\n                $group_string = '';\n            }\n     \
    \   }\n    }\n\n    if (count($group_stack) > 0) {\n        foreach ($group_stack\
    \ as $key) {\n            $group_string .= $paren_array[$key];\n        }\n  \
    \  }\n\n    return $results;\n}\n</code>\n<|/ a tags=preg-match,regex,php |>\n\
    <| c |>\nYes but this does not separate groups of parenthesis correctly, for instance\
    \ if you have input of `'(( ( ( ()) ))'` it will return `[ ( ( ( ()) ))]` instead\
    \ of `['(()', '(()())']` as in the OP's example.\n<|/ c |>\n<| c |>\nI posted\
    \ an answer that addresses that issue.\n<|/ c |>\n<| c |>\nOh, sorry I missed\
    \ that - I guess it's time to go to bed now. I'll look at this again tomorrow\
    \ morning.\n<|/ c |>\n<| a dscore=1 |>\nThis should work:\n<code>\n$input = '((\
    \ ( ( ()) ))';\n$regex = '~\\((?:[^()]+|(?R))*\\)~';\npreg_match_all($regex, $input,\
    \ $matches);\n\nforeach ($matches[1] as $match) {\n    $groups[] = explode('(',\
    \ $match)[1];\n}\n</code>\nThe regex (?:[^()]+|(?R))*\\) matches any sequence\
    \ of chars other than parenthesis or the whole regex itself, followed by ( and\
    \ a closing parenthesis.\n<|/ a tags=preg-match,regex,php |>\n<| c |>\nHm, this\
    \ doesn't seem to work properly with `'(( ( ( ()) ))'`.\n<|/ c |>\n<| c |>\nIt\
    \ works fine on my machine - I just tested it with the example string and it works\
    \ perfectly. How is your PHP version different?\n<|/ c |>\n<| c |>\nWell, I'm\
    \ running `PHP Version => 7.0.13`\n<|/ c |>\n<| c |>\nBut I have PHP 5.5.9\n<|/\
    \ c |>\n<| c |>\nPerhaps it has ", "  $paren_group_start = str_replace(\" \",\
    \ \"\", $paren_string);\n  $paren_groups = preg_split('/(\\((?>[^()]+|\\((?0))*\\\
    ))+/', $paren_group_start);\n  return $paren_groups;\n}", "  // Store each parenthesized\
    \ expression\n  $paren_expressions = array();\n\n  // Iterate through each character\n\
    \  for ($i = 0; $i < strlen($paren_string); $i++) {\n    // If it's a left paren,\
    \ add to array of expressions\n    if ($paren_string[$i] == '(') {\n      $paren_expressions[]\
    \ = '';\n    }\n\n    // If it's a right paren, pop the last expression\n    else\
    \ if ($paren_string[$i] == ')') {\n      $paren_expressions[] = array_pop($paren_expressions);\n\
    \    }\n\n    // If it's anything else, add it to the expression\n    else {\n\
    \      $paren_expressions[] = $paren_string[$i];\n    }\n  }\n\n  // Return the\
    \ array of expressions\n  return $paren_expressions;\n}\n</code>\nThis code will\
    \ work with any kind of nested parentheses.\n<|/ a tags=recursion,string,php,arrays\
    \ |>\n<| c |>\nI didn't think to use this method since I had never heard of it\
    \ before but I've used a variation of this method before and it's worked perfectly.\
    \  Thank you so much!\n<|/ c |>\n<| c |>\nGlad this helped you. Please mark this\
    \ answer as accepted if it answers your question so that the question doesn't\
    \ show up as unanswered.\n<|/ c |>\n<| a tags=recursion,string,php,arrays dscore=3\
    \ |>\nHere is my PHP function I wrote to parse text strings into an array of tokens\
    \ (arrays of characters or digits).\n<code>\n<?php", "  preg_match_all('{\n  \
    \                         (?:\n                             [^()]* # Anything\
    \ but parentheses\n                             | \\(     # Or, an open paren\n\
    \                             | \\)     # Or, a close paren\n                \
    \             )\n                           }x', $paren_string, $matches, PREG_SET_ORDER);\n\
    \  return $matches;\n}\n</code>\n<|/ a tags=php,regex |>\n<| c |>\nThanks for\
    \ your answer. I tried your method but I can't seem to get it to work. I think\
    \ it's because my string is dynamic. It could be something like this: \"(((((((((\
    \ ((((((((((( ( )) )) )) )) )) )) ))))))))))))))))))\". I also don't know if it\
    \ will work with more than one level of parenthesis.\n<|/ c |>\n<| c |>\nHmmm,\
    \ maybe it could be the problem of nested parenthesis in your string. Are there\
    \ any cases that it doesn't work with? Can you provide a sample string of what\
    \ you tried and what happened?\n<|/ c |>\n<| c |>\nActually, I just tried it with\
    \ some more strings and it seems to work for them. It doesn't work for these though:\
    \ \"(()())\", \"()()()\", or \"()()() ()()\". I'll try to come up with a better\
    \ sample string that I'm having trouble with.\n<|/ c |>\n<| c |>\nI updated my\
    \ answer with a recursive function you can use.\n<|/ c |>\n<| c |>\nThanks for\
    \ your help. Your function works!\n<|/ c |>\n<| a tags=php,regex |>\nI tested\
    \ a recursive function and it seems to work for all of the examples I provided\
    \ in the comments of the accepted answer. Here is the function I wrote using your\
    \ recursive function as a guide:\n<code>", "    $paren_string = preg_replace('/\\\
    s+/', '', $paren_string);\n\n    $paren_groups = array();\n    $group = 0;\n \
    \   $open_brace = 0;\n    foreach (preg_split('/([\\(\\)])/', $paren_string) as\
    \ $char) {\n        if ($char === '(') {\n            $open_brace++;\n       \
    \ }\n        if ($char === ')') {\n            $open_brace--;\n        }\n   \
    \     if ($open_brace === 0) {\n            $paren_groups[] = substr($paren_string,\
    \ $group, 1);\n        }\n        $group++;\n    }\n\n    return $paren_groups;\n\
    }\n", "  $paren_string = preg_replace('/( +|\\n)+/', '', $paren_string);\n  $paren_string\
    \ = preg_replace('/( )+/', ' ', $paren_string);\n  $paren_string = preg_replace('/\\\
    n/', '', $paren_string);\n\n  $matches = array();\n  $stack_ptr = 0;\n  $open\
    \ = array();\n  $closed = array();\n  $found_open = FALSE;\n  $found_closed =\
    \ FALSE;\n  $depth = 0;\n  while (($pos = strpos($paren_string, '(', $stack_ptr))\
    \ !== FALSE) {\n    // Found an open\n    if ($pos == 0) {\n      // If the stack\
    \ is empty or we're already at an opening paren, we want to start a new paren\
    \ group\n      if (count($open) == 0 || count($closed) > 0) {\n        $open[]\
    \ = $paren_string;\n      }\n      $stack_ptr++;\n      $open[$pos] = '';\n  \
    \    $depth++;\n      $matches[$pos] = $depth;\n      $found_open = TRUE;\n  \
    \    continue;\n    }\n\n    // Found a close (found an opening one?)\n    if\
    \ ($found_open) {\n      $depth--;\n      if ($depth == 0) {\n        $closed[$stack_ptr]\
    \ = '';\n        $stack_ptr--;\n        $found_closed = TRUE;\n        continue;\n\
    \      }\n    }\n\n    // Found a close and an open\n    if (($pos == strlen($paren_string)\
    \ - 1) || ($found_closed)) {\n      // We've found a balanced paren group\n  \
    \    if (count($open) == 0) {\n        // If we're currently in a group that has\
    \ no open parens, we want to end that group\n        if ($found_closed) {\n  \
    \        array_pop($closed);\n        } else {\n          array_pop($open);\n\
    \        }\n        $depth--;\n      }\n      $open[$pos] = '';\n      $stack_ptr--;\n\
    \      $open[++$pos] = '';\n      $depth++;\n      $matches[$pos] = $depth;\n\
    \      $found_closed = TRUE;\n    }\n\n    // We've found a non-matching paren\n\
    \    $stack_ptr++;\n  }\n\n  // We've left the stack\n  while (($pos = strrpos($paren_string,\
    \ '(', $stack_ptr)) !== FALSE) {\n    if ($found_closed) {\n      $closed[$pos]\
    \ = '';\n      $matches[$pos] = $depth;\n      $found_closed = FALSE;\n    } else\
    \ {\n      $open[$pos] = '';\n      $stack_ptr--;\n      $open[--$pos] = '';\n\
    \      $depth--;\n      $matches[$pos] = $depth;\n    }\n  }\n\n  return $paren_string;\n\
    }\n", "    $paren_array = array();\n    preg_match_all('/\\((.+)\\)/', $paren_string,\
    \ $paren_match);\n    for ($i = 0; $i < count($paren_match[1]); $i++) {\n    \
    \    $paren_array[] = $paren_match[1][$i];\n    }\n    return $paren_array;\n\
    }\n</code>\n<|/ a tags=arrays,string,php |>\n<| a |>\n<code>\n$str=\"( (  ( a\
    \ ( b ) c )  ( d ( e ( f ) ) ) g ( h ) i )\";\n\n$result = array();\n$stack =\
    \ array();\n\nforeach (explode( \" \", $str) as $item) {\n    if ($item == '(')\
    \ {\n        if (count($stack) > 0) {\n            $result[] = array_pop($stack);\n\
    \        } else {\n            $result[] = substr($item, 1, -1);\n        }\n\
    \        $stack[] = $item;\n    } elseif ($item == ')') {\n        $stack[] =\
    \ $item;\n    } else {\n        $stack[] = $item;\n    }\n}\n\n$result[] = array_pop($stack);\n\
    \nprint_r($result);\n</code>\n<|/ a dscore=0 tags=arrays,string,php |>\n<| a |>\n\
    <code>\n$str='( a ( b ) c';\n$newstring=explode(\" \",$str);\n$newstring=array_filter($newstring);\n\
    \n$newstring=array_chunk($newstring,2);\nforeach($newstring as $val)\n{\n    $valstr=implode(\"\
    , \",$val);\n    $str=str_replace($valstr,\"\",$str);\n}\necho $str;\n</code>\n\
    <|/ a dscore=0 tags=arrays,string,php |>\n<| c |>\nYour result is not the same\
    \ as OP's\n<|/ c |>\n<| c |>\nThis is actually pretty helpful and also it gives\
    \ me a lot of good ideas to implement in some other parts of my project.\n<|/\
    \ c |>\n<| c |>\nThanks, this was helpful to me in many parts of my code.\n<|/\
    \ c |>\n<| a tags=arrays,string,php dscore=0 |>\nFor those using php 7.2+, we\
    \ can use array_walk(), array_slice() and array_map() to process this kind of\
    \ string input with array_reduce() and explode(). \n<code>\n$input = '( a ( b\
    \ ) c';\n\n$result = array_reduce(\n    explode(' ', $input),\n    function ($carry,\
    \ $item) {\n        // Remove parens groups by merging ", "    $paren_string =\
    \ preg_replace('/\\s\\(\\s/', '(', $paren_string);\n    $paren_string = preg_replace('/\\\
    )\\s$/', ')', $paren_string);\n\n    $paren_string = preg_replace('/\\(\\s/',\
    \ '(', $paren_string);\n    $paren_string = preg_replace('/\\)\\s$/', ')', $paren_string);\n\
    \n    $paren_string = preg_replace('/\\(\\s/', '(', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\)\\s$/', ')', $paren_string);\n\n    return preg_split('/\\\
    s*\\(\\s)\\s*/', $paren_string);\n}\n", "    // First find the index of the last\
    \ open paren\n    $open_brace_open_index = 0;\n    $open_brace_close_index = 0;\n\
    \    for ($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == '(') {\n            $open_brace_open_index = $i;\n        } else if ($paren_string[$i]\
    \ == ')') {\n            $open_brace_close_index = $i;\n        }\n    }\n\n \
    \   // Now we can go forward to find the closing paren starting at the last open\
    \ paren\n    for ($i = $open_brace_open_index + 1; $i < strlen($paren_string);\
    \ $i++) {\n        if ($paren_string[$i] == ')') {\n            $close_paren_index\
    \ = $i;\n            break;\n        }\n    }\n\n    // Return the string between\
    \ the last open paren and the closing paren\n    return substr($paren_string,\
    \ 0, $close_paren_index + 1);\n}", "  // If the input string is empty, return\
    \ the empty list\n  if ($paren_string === '') {\n    return array();\n  }\n\n\
    \  // Create a stack to keep track of the nesting level\n  $paren_stack = array();\n\
    \  // Initialize the array that will hold the results\n  $results = array();\n\
    \n  // Loop through the input string and process all the parens\n  for ($i = 0,\
    \ $paren_len = strlen($paren_string); $i < $paren_len; $i++) {\n    // If we're\
    \ at the start of a paren, increase the nesting level\n    if ($paren_string[$i]\
    \ === \"(\") {\n      array_push($paren_stack, $i);\n    // If we're at the end\
    \ of the input, add an extra closing paren\n    } else if ($paren_string[$i] ===\
    \ \")\") {\n      // Get the nesting level\n      $level = count($paren_stack);\n\
    \      // If the level is 1 then add an extra closing paren\n      if ($level\
    \ === 1) {\n        $results[] = \")\";\n        // Otherwise, add a new element\
    \ to the results\n      } else {\n        $results[] = \")\";\n      }\n     \
    \ // Pop the current level\n      array_pop($paren_stack);\n    // Any other characters\
    \ are part of the closing paren\n    } else {\n      $results[] = $paren_string[$i];\n\
    \    }\n  }\n\n  return $results;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ tags=parsing,php,recursion |>\n<code>\n<?php", "    // Split by any number of\
    \ nested parentheses.\n    $paren_string = preg_split('/\\(([^\\(\\)]*+)\\)/',\
    \ $paren_string);\n    // Remove nested parens inside of other parens.\n    $paren_string\
    \ = preg_replace('/\\(([^\\(\\)]*+)\\)/', '', $paren_string);\n    // Return the\
    \ array of strings of nested parens.\n    return $paren_string;\n}\n", "    $paren_string_array\
    \ = explode(\"\\n\", $paren_string);\n\n    // Initialize result array\n    $result_array\
    \ = array();\n\n    foreach ($paren_string_array as $line_of_strings) {\n    \
    \    // Initialize counter to zero\n        $current_index = 0;\n\n        //\
    \ Iterate through each line in the string\n        foreach ($line_of_strings as\
    \ $line_of_string) {\n            // Initialize paren group counter\n        \
    \    $paren_groups = 1;\n\n            // Check if the line contains a nested\
    \ parenthesis\n            if ($line_of_string == '(') {\n                // Increase\
    \ group counter\n                $paren_groups++;\n\n            // Check if the\
    \ line contains a closing parenthesis\n            } else if ($line_of_string\
    \ == ')') {\n                // Decrease group counter\n                $paren_groups--;\n\
    \n            // Check if the line contains a space character\n            } else\
    \ if ($line_of_string == ' ') {\n                // If the current group is empty\n\
    \                if ($paren_groups == 0) {\n                    // Skip the line\n\
    \                    $current_index++;\n\n                // If the current group\
    \ is not empty\n                } else {\n                    // Add a new group\n\
    \                    $result_array[] = $line_of_string;\n\n                  \
    \  // Reset the group counter to zero\n                    $paren_groups = 1;\n\
    \                }\n\n            // If any line contains anything but parentheses,\
    \ skip the line\n            } else {\n                // Skip the line\n    \
    \            $current_index++;\n            }\n        }\n    }\n\n    return\
    \ $result_array;\n}\n</code>\n<|/ a |>\n<| a tags=regex,php |>\n<code>\n<?php\n\
    $paren_string = '( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ (", "  $groups = array();\n  $stack = 0;\n  $stack_value = 0;\n\n  $paren_array\
    \ = explode(')', $paren_string);\n  foreach ($paren_array as $i) {\n    if ($i\
    \ == '') continue;\n    if ($i == '(') {\n      $stack++;\n      $stack_value\
    \ = 0;\n    } else if ($i == ')') {\n      if ($stack == 1) {\n        // we started\
    \ the paren group\n        $stack_value++;\n      }\n      $stack--;\n    } else\
    \ {\n      $stack_value += $i;\n    }\n    if ($stack == 0) {\n      $groups[]\
    \ = substr($i, $stack_value);\n    }\n  }\n  return $groups;\n}\n", "  $paren_string_array\
    \ = str_getcsv($paren_string);\n  $paren_string_array_size = sizeof($paren_string_array);\n\
    \  for($i=0;$i<$paren_string_array_size;$i++) {\n    if($i==0) $paren_string_array[$i]\
    \ = '';\n    else $paren_string_array[$i] = trim($paren_string_array[$i]);\n \
    \   if($paren_string_array[$i] === '(') $paren_string_array[$i] = '(';\n    else\
    \ if($paren_string_array[$i] === ')') $paren_string_array[$i] = ')';\n    else\
    \ if($paren_string_array[$i] === '') {\n      if($i == $paren_string_array_size-1)\
    \ $paren_string_array[$i] = '(';\n      else $paren_string_array[$i] = '';\n \
    \   }\n  }\n  return $paren_string_array;\n}\n</code>\n<|/ a tags=regex,php dscore=0\
    \ |>\n<| c |>\nIt seems like the code is wrong in one way. `echo separate_paren_groups('(())');\
    \ //Result: ['()']`\n<|/ c |>\n<| c |>\nOops, just noticed the bug - fixed it\n\
    <|/ c |>\n<| c |>\nYour code is still wrong: it outputs ['()']\n<|/ c |>\n<| c\
    \ |>\nAhhh, I see the bug - thanks. And yes - my code isn't very efficient - I\
    \ was just trying to work it out with regex\n<|/ c |>\n<| c |>\nNo problem. I\
    \ am just trying to see if I can use regex to solve this problem - and to learn\
    \ it well.\n<|/ c |>\n<| a dscore=0 |>\nTry this simple regexp:\n<code>\n(?<!\\\
    d)( *\\()|(\\))\n</code>\nSee demo.\nExplanation\n<code>\n(?<!\\d)           \
    \         # Negative lookbehind, assert that what is on the left is not a digit\n\
    \ *                           # Zero or more spaces (possessive quantifier)\n\
    \ \\(                          # '('\n|                           # OR\n (?! )\
    \                      # assert that what is on the right is not a space\n</code>\n\
    <|/ a tags=regex,php |>\n<| c |>\nI don't think this would work since it needs\
    \ to allow spaces in between parentheses.  It also would not allow `(())`, which\
    \ would be a correct solution.\n<|/ c |>\n<| c |>\n: I thought that was what you\
    \ wanted. `'(())'` would not match because there are no spaces in between. But\
    \ yes your solution is right ", "    $paren_array = array();\n    // Split into\
    \ groups of parentheses\n    $group_of_parentheses = preg_split('/([\\(\\)])/',\
    \ $paren_string);\n    // If no parentheses found return the string\n    if (!isset($group_of_parentheses[0]))\
    \ {\n        return $paren_string;\n    }\n    // Loop through each group of parentheses\n\
    \    foreach ($group_of_parentheses as $index => $group) {\n        // If the\
    \ group of parentheses has a closing parenthesis add it to the array\n       \
    \ if ($group == '(') {\n            if (isset($group_of_parentheses[$index + 1]))\
    \ {\n                $paren_array[] = $group;\n            } else {\n        \
    \        // If the closing parenthesis is not found then it wasn't properly closed\
    \ and we shouldn't add it to the array\n                return '';\n         \
    \   }\n        } else {\n            // If not a closing parenthesis, add the\
    \ group of parentheses to the array\n            $paren_array[] = $group;\n  \
    \      }\n    }\n    return $paren_array;\n}\n</code>\nYou can then pass your\
    \ string to the above function, like so:\n<code>\n$paren_string = '( ) (( )) ((\
    \ )( ))';\n$paren_array = separate_paren_groups($paren_string);", "  $parens =\
    \ [];\n  $level = 0;\n  $i = -1;\n  while (++$i < strlen($paren_string)) {\n \
    \   // Loop through each character in the input string\n    $char = substr($paren_string,\
    \ $i, 1);\n\n    // If this is a '(', increment the level\n    // and set our\
    \ starting index to 0\n    if ($char === '(') {\n      $parens[$level][] = $char;\n\
    \      $level++;\n      $i = 0;\n    }\n\n    // If this is a ')', decrement the\
    \ level\n    // and exit the loop if we're back at the starting level\n    if\
    \ ($char === ')') {\n      if ($level) {\n        --$level;\n      } else {\n\
    \        break;\n      }\n    }\n\n    // If this is a ' ', ignore it\n    if\
    \ ($char === ' ') {\n      continue;\n    }\n\n    // If this is a new level of\
    \ parens, start a new group\n    if ($level) {\n      $parens[$level][] = $char;\n\
    \    }\n  }\n\n  return $parens;\n}\n", "    // Initialize an indexed array of\
    \ groups\n    $groups = array();\n\n    // Iterate over the input string\n   \
    \ foreach (explode(' ', $paren_string) as $paren) {\n        // If the paren is\
    \ empty\n        if (empty($paren)) {\n            // Ignore it\n            continue;\n\
    \        }\n\n        // Add an open brace to each group\n        $groups[] =\
    \ '('.$paren.');';\n\n        // Remove this paren from the input string\n   \
    \     $paren_string = str_replace($paren, '', $paren_string);\n    }\n\n    //\
    \ Return the groups\n    return $paren_string;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Working perfectly, thank you so much!\n<|/ c |>\n<| c |>\nIt does not work when\
    \ there's a substring inside parenthesis, e.g. `( a ) ( b )`\n<|/ c |>\n<| a tags=regex,php\
    \ |>\nYou can use a combination of preg_replace and preg_match to achieve the\
    \ desired results.\nThe following will grab any number of open parentheses followed\
    \ by any number of non-whitespace characters after those parentheses, in any order,\
    \ and will match a closing parenthesis when there are no more open parentheses\
    \ in the string.\n<code>\n$string = '(foo)( bar ) ( baz )';\npreg_replace('/(\\\
    (\\w+\\))\\s(\\W+)/', '\\1', $string);\n</code>\nIf you want to allow whitespace\
    \ between each set of parentheses, then you can do this:\n<code>\n$string = '(foo)(\
    \ bar ) ( baz )';\npreg_replace('/(\\(\\w+\\))\\s(\\W+)/', '\\1', $string);\n\
    </code>\nOr this:\n<code>\n$string = '(foo)( bar ) ( baz )';\npreg_replace('/(\\\
    (\\w+\\))\\W+/', '\\1', $string);\n</code>\nIn either case, the above code will\
    \ give the following string:\n<code>\nfoo( bar ) ( baz )\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nYou could do this:\n<code>\n<?php\n\n$input = '(foo)( bar ) ( baz\
    \ )';\n$regex = '/^\\((.+)\\)( .+$)/';\npreg_match($regex, $input, $matches);\n\
    \nvar_dump($matches);\n</code>\nThe output is:\n<code>\narray(2) {\n  [0]=>\n\
    \  string(16) \"(foo)( bar ) ( baz )\"\n  [1]=>\n  string(5) \"(foo)\"\n}\n</code>\n\
    <|/ a tags=regex,php ", "    $open_braces_stack = array();\n    $open_parentheses_stack\
    \ = array();\n    $group_stack = array();\n    $group_string = array();\n    $group_opening_count\
    \ = 0;\n    // iterate through each character in the string $paren_string\n  \
    \  // and add it to group_string\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        // ignore all spaces and control chars\n        if (ctype_alpha($paren_string[$i])\
    \ || ctype_digit($paren_string[$i])) {\n            // check if the current character\
    \ is a space\n            if (ctype_space($paren_string[$i])) {\n            \
    \    // end of group string\n                if ($group_opening_count > 0) {\n\
    \                    array_push($group_stack, $group_string);\n              \
    \  }\n                // start a new group\n                array_push($group_stack,\
    \ '');\n                array_push($group_string, $paren_string[$i]);\n      \
    \          $group_opening_count++;\n            }\n            // check if current\
    \ character is a closing brace\n            else if ($paren_string[$i] == '}')\
    \ {\n                // close group if there's anything to close with\n      \
    \          if (count($group_stack) > 0) {\n                    $group_string =\
    \ array_pop($group_stack);\n                    $group_opening_count--;\n    \
    \            }\n            }\n            // check if current character is a\
    \ closing parenthesis\n            else if ($paren_string[$i] == ')') {\n    \
    \            // close group if there's anything to close with\n              \
    \  if (count($group_stack) > 0) {\n                    $group_string = array_pop($group_stack);\n\
    \                    $group_opening_count--;\n                }\n            }\n\
    \            // check if current character is a opening brace\n            else\
    \ if ($paren_string[$i] == '{') {\n                // open group\n           \
    \     array_push($group_stack, '');\n                array_push($group_string,\
    \ $paren_string[$i]);\n                $group_opening_count++;\n            }\n\
    \            // check if current character is a opening parenthesis\n        \
    \    else if ($paren_string[$i] == '(') {\n                // open group\n   \
    \             array_push($group_stack, '');\n                array_push($group_string,\
    \ $paren_string[$i]);\n                $group_opening_count++;\n            }\n\
    \        }\n        // if current character is not a space, tab or closing brace,\
    \ just push it onto group_string\n        else {\n            array_push($group_string,\
    \ $paren_string[$i]);\n        }\n    }\n    // if there are any groups in the\
    \ stack\n    if (count($group_stack) > 0) {\n        array_push($group_string,\
    \ array_pop($group_stack));\n    }\n    // return the array of groups in the order\
    \ they were entered\n    return $group_string;\n}\n", "  $groups = preg_split('#(\\\
    (\\))#', $paren_string);\n  return array_filter(array_map('trim', $groups));\n\
    }\n", "\t$nested_paren_stack = array();\n\tfor ($i = 0, $len = strlen($paren_string);\
    \ $i < $len; ++$i) {\n\t\t$char = $paren_string[$i];\n\t\tif ($char === ' ') {\n\
    \t\t\tcontinue;\n\t\t}\n\t\tif ($char === '(') {\n\t\t\t$nested_paren_stack[]\
    \ = &$nested_paren_stack[count($nested_paren_stack) - 1];\n\t\t}\n\t\tif ($char\
    \ === ')') {\n\t\t\tarray_pop($nested_paren_stack);\n\t\t}\n\t}\n\treturn $nested_paren_stack;\n\
    }\n", "    $paren_array = array();\n\n    // Initialize an index to keep track\
    \ of where we are in the string so we can split on nested open/close parens.\n\
    \    $index = 0;\n    // Initialize an index to keep track of where the next opening\
    \ paren is found.\n    $opening_paren_counter = 0;\n\n    // We want to count\
    \ the number of open/close parens in the string to know when we are done.\n  \
    \  $open_paren_counter = 0;\n\n    // Iterate through the string character by\
    \ character and add each character to the list if it is a paren.\n    foreach\
    \ (str_split($paren_string) as $char) {\n        // If the character is a paren,\
    \ add it to the list.\n        if ($char === '(') {\n            $paren_array[$index]\
    \ = $char;\n            $index++;\n        } else if ($char === ')') {\n     \
    \       // If the current paren is open, then we want to see if there are any\
    \ more open parens.\n            if ($open_paren_counter > 0) {\n            \
    \    // If the current paren is closed, then we need to close the current one.\n\
    \                // The current open paren is already stored at this index.\n\
    \                if ($paren_array[$index] === ')') {\n                    $index--;\n\
    \                    $paren_array[$index] = $char;\n                } else {\n\
    \                    // If there are no more open/close parens left, then we add\
    \ the last open paren we just found and\n                    // continue on to\
    \ the next character.\n                    $paren_array[$index] = $char;\n   \
    \                 $index++;\n                }\n            } else {\n       \
    \         // If we are not on the last paren, then we want to know when we have\
    \ reached the last paren.\n                if ($index >= 1) {\n              \
    \      // We don't add the last paren here.\n                    $index--;\n \
    \               } else {\n                    // If we are on the last paren,\
    \ then we want to add the first paren we just found and continue\n           \
    \         // on to the next character.\n                    $paren_array[$index]\
    \ = $char;\n                    $index++;\n                }\n            }\n\
    \        } else {\n            // If it is a space or an opening paren character,\
    \ we don't add it to the list.\n            if ($char === ' ' || $char === '(')\
    \ {\n                continue;\n            }\n\n            // Otherwise we add\
    \ it to the list and reset the index.\n            $paren_array[$index] = $char;\n\
    \            $index++;\n        }\n\n        // We found a new paren, so increment\
    \ the counter.\n        $opening_paren_counter++;\n        // We also found a\
    \ new opening paren, so increment the counter.\n        $open_paren_counter++;\n\
    \    }\n\n    // If there are any unbalanced open parens left over at the end\
    \ of the string, we add them to the list.\n    if ($opening_paren_counter > 0)\
    \ {\n        // If the string is all spaces, then we just add an empty string\
    \ to the list so we have a list that always\n        // has a trailing empty string.\n",
  "    $paren_array = [];\n    $char_ctr = 0;\n    // Loop through each character\
    \ in $paren_string and test whether it is an opening/closing parenthesis\n   \
    \ while (ord($paren_string[$char_ctr]) >= ord(')')) {\n        if (ord($paren_string[$char_ctr])\
    \ >= ord(')')) {\n            if (ord($paren_string[$char_ctr]) != ord('(')) {\n\
    \                $paren_array[] = $paren_string[$char_ctr];\n            }\n \
    \       }\n        $char_ctr++;\n    }\n    return $paren_array;\n}\n", "    $paren_stack\
    \ = [];\n    $paren_stack[] = '';\n    $paren_stack_count = 0;\n    $paren_stack_content\
    \ = '';\n    $paren_stack_content_in_paren_stack = true;\n    $paren_stack_parent_count\
    \ = [];\n    $paren_stack_parent_count_index = 0;\n    $paren_stack_output_array\
    \ = [];\n    $paren_stack_output_array_index = 0;\n    foreach (str_split($paren_string)\
    \ as $char) {\n        if ($char == '(') {\n            if ($paren_stack_content\
    \ != '') {\n                if ($paren_stack_parent_count[$paren_stack_parent_count_index]\
    \ == 0) {\n                    $paren_stack_parent_count[$paren_stack_parent_count_index]\
    \ = $paren_stack_count;\n                }\n                $paren_stack_parent_count[$paren_stack_parent_count_index]\
    \ -= 1;\n                $paren_stack_parent_count_index += 1;\n             \
    \   if ($paren_stack_parent_count_index > count($paren_stack_parent_count)) {\n\
    \                    $paren_stack_parent_count_index = 0;\n                }\n\
    \                $paren_stack_count++;\n                $paren_stack_content =\
    \ '';\n                $paren_stack_content_in_paren_stack = true;\n         \
    \       $paren_stack_parent_count = [];\n                $paren_stack_parent_count_index\
    \ = 0;\n                $paren_stack_output_array[] = $paren_stack_content;\n\
    \                $paren_stack_output_array_index++;\n            }\n        }\
    \ else if ($char == ')') {\n            if ($paren_stack_content != '') {\n  \
    \              if ($paren_stack_parent_count[$paren_stack_parent_count_index]\
    \ > 1) {\n                    $paren_stack_parent_count[$paren_stack_parent_count_index]\
    \ -= 1;\n                    $paren_stack_parent_count_index -= 1;\n         \
    \           if ($paren_stack_parent_count_index < 0) {\n                     \
    \   $paren_stack_parent_count_index = 0;\n                    }\n            \
    \        if ($paren_stack_parent_count[$paren_stack_parent_count_index] == 0)\
    \ {\n                        $paren_stack_count--;\n                    }\n  \
    \                  $paren_stack_content = '';\n                    $paren_stack_content_in_paren_stack\
    \ = true;\n                    $paren_stack_parent_count = [];\n             \
    \       $paren_stack_parent_count_index = 0;\n                    $paren_stack_output_array[]\
    \ = $paren_stack_content;\n                    $paren_stack_output_array_index++;\n\
    \                }\n            } else if ($paren_stack_count == 0 && $paren_stack_content_in_paren_stack\
    \ == true) {\n                $paren_stack_content_in_paren_stack = false;\n \
    \           }\n        } else if ($char == ' ' || $char == '\\t' || $char == '\\\
    r') {\n            if ($paren_stack_count > 0 || $paren_stack_content != '') {\n\
    \                $paren_", "    $paren_array = array();\n    $paren_string = preg_replace('/\\\
    s+/', '', $paren_string); // Replace spaces in input string with nothing\n   \
    \ $open_brace_position = 0;\n    $open_brace_array = '';\n    $closed_paren_position\
    \ = 0;\n    $open_brace_count = 0;\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        $char = $paren_string[$i];\n        if ($char === '(') {\n\
    \            if ($open_brace_position >= 0) {\n                $open_brace_array[strlen($open_brace_array)\
    \ - 1] .= $char;\n                $open_brace_count++;\n            } else {\n\
    \                $paren_array[$open_brace_position] = $open_brace_array;\n   \
    \             $open_brace_array = $char;\n                $open_brace_position++;\n\
    \            }\n        } else if ($char === ')') {\n            if ($open_brace_count\
    \ > 0) {\n                $open_brace_array = $open_brace_array[strlen($open_brace_array)\
    \ - 1];\n                $open_brace_count--;\n            } else {\n        \
    \        $paren_array[$closed_paren_position] = $open_brace_array;\n         \
    \       $closed_paren_position++;\n                $open_brace_position--;\n \
    \               $open_brace_count = 0;\n            }\n        }\n    }\n    $paren_array[$closed_paren_position]\
    \ = $open_brace_array;\n    return $paren_array;\n}\n</code>\n<|/ a tags=php |>\n\
    <| c |>\nWorks well, even though it only returns nested parenthesis that aren't\
    \ nested in each other.\n<|/ c |>\n<| a tags=php |>\nIf you want a recursive function\
    \ which doesn't require any extra libs, here's one I wrote a long time ago.\n\
    <code>", "\t$paren_string_length = strlen($paren_string);\n\t$return_strings =\
    \ [];\n\tfor ($i = $paren_string_length - 1; $i >= 0; $i--) {\n\t\t$current_paren\
    \ = $paren_string[$i];\n\t\t$is_paren_closed = false;\n\t\tif ($current_paren\
    \ == '(') {\n\t\t\t$return_strings[] = '';\n\t\t} elseif ($current_paren == '(')\
    \ {\n\t\t\t$is_paren_closed = true;\n\t\t} elseif ($current_paren == ')') {\n\t\
    \t\tif ($is_paren_closed) {\n\t\t\t\t$return_strings[] = '';\n\t\t\t} else {\n\
    \t\t\t\t$is_paren_closed = false;\n\t\t\t}\n\t\t} else {\n\t\t\t$is_paren_closed\
    \ = false;\n\t\t}\n\t}\n\treturn $return_strings;\n}\n", "    $group_stack = [];\n\
    \    $group_result = [];\n    $group = '';\n\n    foreach(explode(',', $paren_string)\
    \ as $string) {\n        $new_group = '';\n        if(strpos($string, '(') !==\
    \ FALSE) {\n            // New group\n            $group = $new_group;\n     \
    \       $group_stack[] = $new_group;\n            $new_group = $string;\n    \
    \    } else if(strpos($string, ')') !== FALSE) {\n            // End group\n \
    \           $group = implode(')', $group_stack);\n            $group_stack = array_slice($group_stack,\
    \ 0, count($group_stack) - 1);\n            $group_result[] = $group;\n      \
    \      $new_group = $group;\n        } else {\n            // Add character from\
    \ input string to the new group\n            $new_group .= $string;\n        }\n\
    \    }\n\n    if(count($group_stack) > 0) {\n        // Last group\n        $group\
    \ = implode(')', $group_stack);\n        $group_result[] = $group;\n    }\n\n\
    \    return $group_result;\n}\n", "    $results = [];\n    $stack = [];\n    $open_braces\
    \ = 0;\n    $chars = [];\n    $in_strlen = false;\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        $char = $paren_string[$i];\n        if ($in_strlen) {\n   \
    \         $in_strlen = false;\n            $chars[] = $char;\n        } elseif\
    \ ($char == \"(\") {\n            // A new brace is opened; add it to the stack\n\
    \            if ($open_braces < 1) {\n                $chars[] = $char;\n    \
    \            $stack[] = $char;\n                $open_braces++;\n            }\
    \ else {\n                // The brace is unbalanced (we never entered the loop)\n\
    \                echo \"Unbalanced brace in string: \" . $paren_string . \"\\\
    n\";\n            }\n        } elseif ($char == \")\") {\n            // We're\
    \ currently opening a brace, so decrement the count and check to see if it's still\
    \ open\n            $open_braces--;\n            if ($open_braces < 0) {\n   \
    \             // The brace is never opened after all\n                echo \"\
    Unbalanced paren in string: \" . $paren_string . \"\\n\";\n            } else\
    \ {\n                // There are still open braces when the balance count goes\
    \ to zero\n                // So we know that if the brace count goes to zero,\
    \ the parentheses closed, so push the stack to result\n                $results[]\
    \ = $stack;\n                $stack = [];\n            }\n        } elseif ($char\
    \ == \" \") {\n            // Ignore spaces (we know these are comments)\n   \
    \         continue;\n        } else {\n            // We're not opening a brace\
    \ or paren, just add it to our string to be worked on\n            $in_strlen\
    \ = true;\n            $chars[] = $char;\n        }\n    }\n\n    // If we have\
    \ any remainders, they should be the end of the string\n    if ($open_braces >\
    \ 0) {\n        echo \"Unbalanced paren in string: \" . $paren_string . \"\\n\"\
    ;\n    }\n\n    // Return the list of results\n    return $results;\n}\n", " \
    \ return preg_match_all('/(?<=\\()([^()]+)(?=\\))/', $paren_string, $matches);\n\
    }\n$string = '(hello (world (foo bar baz)))';\nprint_r(separate_paren_groups($string));",
  "    return preg_split(\"~({)(*?)}~\", $paren_string);\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI like your answer. Can you explain what this means `~({)(*?)}`?\n<|/\
    \ c |>\n<| c |>\nThis works on my machine, but doesn't seem to work if the parenthesis\
    \ are balanced differently in the string. The parenthesis around the entire string\
    \ gets matched as well.\n<|/ c |>\n<| c |>\n: It means: match a { followed by\
    \ something (non-greedy) and a } followed by something (non-greedy) repeatedly\
    \ one or more times. So it matches a single set of parentheses that are not nested\
    \ in any other set of parentheses.\n<|/ c |>\n<| c |>\nThank you. Works perfectly\
    \ (+1 for the explanation). One thing I noticed was that in my code the return\
    \ statement was outside of the while loop. Once I moved it inside of the while\
    \ loop, it worked exactly as you said. So now I'm wondering if it's possible to\
    \ do this without using two while loops, one to check if the strings are balanced\
    \ and another to separate the strings. I'm thinking maybe some kind of recursive\
    \ function? Just wondering if there's a way.\n<|/ c |>\n<| c |>\n: It is possible\
    \ to use a recursive function, but you would have to implement it yourself. See\
    \ my answer.\n<|/ c |>\n<| a |>\nHere's a solution without using any recursion\
    \ or string manipulation. It makes use of balanced parentheses regex. \n<code>",
  "  $parens = array();\n  $groups = preg_split('/[\\(\\)]+/u', $paren_string);\n\
    \  $open_braces = 0;\n  $closing_braces = 0;\n\n  foreach ($groups as $group_number)\
    \ {\n    // Get the number of open braces\n    $open_braces += substr_count($group_number,\
    \ '(');\n    $closing_braces += substr_count($group_number, '(') - substr_count($group_number,\
    \ ')');\n  }\n\n  // If the string is balanced, we are done\n  if ($open_braces\
    \ == $closing_braces) {\n    return $parens;\n  }\n\n  // If the string is NOT\
    \ balanced, split into groups of balanced groups\n  $paren_groups = array();\n\
    \  $open_paren_groups = array();\n\n  for ($index = 0; $index < count($groups);\
    \ $index++) {\n    $open_brace_level = substr_count($groups[$index], '(') - substr_count($groups[$index],\
    \ ')');\n\n    if ($open_brace_level == 0) {\n      $paren_groups[] = $groups[$index];\n\
    \    } else {\n      // If we're inside a set of parens opened and close that\
    \ set first, close them all first\n      if ($open_braces > 0 && in_array($groups[$index],\
    \ $open_paren_groups)) {\n        $open_paren_groups = $open_paren_groups - $open_braces\
    \ - 1;\n        $open_braces = 0;\n      } else {\n        // Keep track of what\
    \ parens were previously opened to handle unbalanced parens\n        $open_paren_groups[]\
    \ = $groups[$index];\n      }\n\n      if ($open_braces == 0) {\n        $parens[]\
    \ = $groups[$index];\n      }\n    }\n  }\n\n  // If there is still an open paren,\
    \ remove it and move the remaining parens to the end\n  if ($open_braces > 0)\
    \ {\n    $open_paren_groups = array_reverse($open_paren_groups);\n    array_pop($open_paren_groups);\n\
    \    $parens = array_merge($open_paren_groups, $parens);\n  }\n\n  // Add remaining\
    \ parens to the end of the parens array\n  $parens[] = implode(')', $parens);\n\
    \  return $parens;\n}\n", "  $paren_string_arr = preg_split('/(\\()|(\\))/', $paren_string);\n\
    \  foreach($paren_string_arr as $key => $sub_paren_string) {\n    if (!empty($sub_paren_string))\
    \ {\n      $paren_string_arr[$key] = trim($sub_paren_string);\n    }\n  }\n  return\
    \ $paren_string_arr;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution is very elegant,\
    \ but can you elaborate on how it works? Especially on the part where it iterates\
    \ through each character in the string and creates a group of characters that\
    \ are either opening or closing? Can you also explain the use of the ternary operator?\
    \ I'm not familiar with that one.\n<|/ c |>\n<| c |>\n`preg_split()` basically\
    \ splits a string into an array of substrings based on a regular expression. The\
    \ regular expression we use is `\\()` which means \"match a left parenthesis\"\
    . The `|` character means \"or\", so our regular expression matches either of\
    \ the two opening parenthesis. Since our regular expression matches either parenthesis,\
    \ we need to use parentheses to delimit our regular expression, otherwise PHP\
    \ will interpret the string as a regex pattern.\n<|/ c |>\n<| c |>\nSo the ternary\
    \ is just a way to write an if statement without having to write `if() {` at the\
    \ beginning. You can read more about ternary operators [here](http://php.net/manual/en/language.operators.comparison.php).\n\
    <|/ c |>\n<| c |>\nThanks for your explanation. Is there a way to make it work\
    \ if there are multiple opening/closing parenthesis?\n<|/ c |>\n<| c |>\nYes,\
    \ just pass in an array of strings instead of a single string.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nMy solution was to make a recursive function that parses a single\
    \ parenthesized expression until there are none.  It then returns the string with\
    \ all the parenthesis removed.\n<code>\n<?php", "    $paren_string = $paren_string;\n\
    \    $paren_string = preg_replace('/\\s+/', '', $paren_string);\n    $paren_string\
    \ = preg_match_all('/\\(/', $paren_string, $open_parens);\n    $paren_string =\
    \ preg_match_all('/\\)/', $paren_string, $close_parens);\n    $paren_string =\
    \ array_merge($open_parens[0], $close_parens[0]);\n    return $paren_string;\n\
    }\n</code>\n<|/ a dscore=1 tags=php,balance,arrays,regex |>\n<| c |>\nYour example\
    \ does not work. Try this for example: `separate_paren_groups('(()()()) (())')`\n\
    <|/ c |>\n<| c |>\nI agree, that is why I included the comment above \"// Separate\
    \ groups are balanced (each open brace is properly closed) and not nested within\
    \ each other\"\n<|/ c |>\n<| c |>\nThat comment doesn't make sense unless you\
    \ give an example where it fails.\n<|/ c |>\n<| c |>\nSorry for that, I have updated\
    \ the code. There was a mistake in the first line of code that made it return\
    \ false when it should return an empty array. I also updated my comment to reflect\
    \ this change. Hopefully it works for you now.\n<|/ c |>\n<| c |>\nThanks for\
    \ updating your answer. Although I did get a similar response from the other guy,\
    \ it would be nice to have a function like this in the language (like `balanced()`).\
    \ Anyway thank you for your time :)\n<|/ c |>\n<| a |>\nYou can use preg_match_all\
    \ with regex pattern:\n<code>\n/(\\(.*\\))/\n</code>\nExample:\n<code>\n$string\
    \ = '(((()))(()()(())))';\n\nif (preg_match_all('/(\\(.*\\))/', $string, $matches))\
    \ {\n    $result = preg_replace('/\\(.*\\)/', '', $matches[0]);\n} else {\n  \
    \  $result = $string;\n}\n</code>\n<|/ a tags=php,balance,arrays,regex dscore=0\
    \ |>\n<| c |>\nThis also works but will require more processing time. It also\
    \ does not return any match if the string is empty. Try `balanced('(');`\n<|/\
    \ c |>\n<| c |>\nIt also does not return any match if the string is empty.\n<|/\
    \ c |>\n<| a tags=php,balance,arrays,regex |>\n<code>\n<?php\n$string = \"(((()))(()()(())))\"\
    ;\n$string = preg_replace('/\\\\(", "    $paren_string = trim($paren_string);\n\
    \n    if (!empty($paren_string)) {\n        $open_brace_count = 0;\n        $closed_paren_count\
    \ = 0;\n\n        for ($i = 0; $i < strlen($paren_string); $i++) {\n         \
    \   $char = $paren_string[$i];\n\n            if ($char === \"(\") {\n       \
    \         $open_brace_count++;\n            } elseif ($char === \")\") {\n   \
    \             $closed_paren_count++;\n            }\n\n            if ($closed_paren_count\
    \ < $open_brace_count) {\n                break;\n            }\n        }\n\n\
    \        $final_array = array();\n        for ($i = 0; $i < $open_brace_count;\
    \ $i++) {\n            $final_array[] = $paren_string;\n        }\n\n        return\
    \ $final_array;\n    }\n\n    return array();\n}\n</code>\n<|/ a tags=regex,php,string\
    \ |>\n<| c |>\nWorks for me. Thanks a lot! Now I'll try to figure out how it works\
    \ :)\n<|/ c |>\n<| a dscore=1 |>\nIn addition to what Michal's solution wrote,\
    \ here is another option. Maybe it can help someone else.\n<code>", "    $bracket_stack\
    \ = array();\n    $paren_stack = array();\n    $paren_groups = array();\n    $paren_group_count\
    \ = -1;\n\n    // iterate through the string one character at a time\n    for\
    \ ($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == ')') {\n            // if the current character is an open brace, add it\
    \ to the stack\n            if (count($paren_stack) > 0) {\n                $paren_stack[count($paren_stack)\
    \ - 1] .= $paren_string[$i];\n            }\n            // else, if the current\
    \ character is a close brace, remove it from the stack and push it onto the paren\
    \ stack\n            else {\n                $paren_stack[] = $paren_string[$i];\n\
    \            }\n        }\n        // if the current character is a open brace,\
    \ add it to the paren stack\n        else {\n            $paren_stack[] = $paren_string[$i];\n\
    \        }\n    }\n\n    // if the paren stack is not empty, perform a recursive\
    \ call\n    if (count($paren_stack) > 0) {\n        $paren_string = separate_paren_groups(implode('',\
    \ $paren_stack));\n    }\n\n    // iterate through the paren string again\n  \
    \  for ($i = 0; $i < count($paren_string); $i++) {\n        // if the current\
    \ character is a closing brace, add the current paren group to the paren group\
    \ list\n        if ($paren_string[$i] == '(') {\n            $paren_groups[$paren_group_count++]\
    \ = $paren_string[$i];\n        }\n\n        // if the current character is a\
    \ closing brace and a matching opening brace has been found...\n        else if\
    \ ($paren_string[$i] == '(' && count($paren_stack) > 0 && $paren_stack[count($paren_stack)\
    \ - 1] == '(') {\n            // split the string at this point into two parts,\
    \ the first part being the parent and the current character group\n          \
    \  $paren_groups[$paren_group_count++] = substr($paren_string, 0, $i);\n     \
    \       $paren_groups[$paren_group_count++] = $paren_string[$i];\n        }\n\
    \    }\n\n    return $paren_groups;\n}\n", "  $paren_stack = [];\n  $paren_string\
    \ = preg_replace('/[\\s()]+/', ' ', $paren_string); // Replace multiple spaces\
    \ and ( ) and ( ) with just one space.\n  $paren_string = preg_replace('/ \\)/',\
    \ '', $paren_string); // Remove any space after ( ) so a word can be captured\
    \ within it.\n  $paren_string = preg_replace('/([^\\s()]+) ([^\\s()]+)/', '\\\\\
    1 \\\\2', $paren_string); // Rearrange words and spaces in string. Put word before\
    \ space so words can be captured.\n  $paren_string = preg_replace('/([^\\s()]+)\
    \ \\(/', '\\\\1', $paren_string); // Rearrange words and spaces in string. Put\
    \ word before space so words can be captured.\n  while($paren_string) {\n    $open_braces_size\
    \ = count($paren_stack);\n    $current_index = 0;\n    $paren_string = str_replace(\"\
    \ \", \"\", $paren_string); // Remove all spaces from string.\n    $paren_string\
    \ = str_replace(\"(\", \"\", $paren_string); // Remove all left parentheses from\
    \ string.\n    $paren_string = str_replace(\")\", \"\", $paren_string); // Remove\
    \ all right parentheses from string.\n    for($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n      $current_char = $paren_string[$i];\n      $paren_string = str_replace($current_char,\
    \ \"\", $paren_string); // Remove current character from string.\n      if($current_char\
    \ == \"(\" || $current_char == \"{\" || $current_char == \"[\") {\n        $paren_stack[$current_index][$current_char]\
    \ = 1;\n      } else if($current_char == \")\" || $current_char == \"]\" || $current_char\
    \ == \"}\") {\n        $paren_stack[$current_index]--;\n        if($paren_stack[$current_index]\
    \ == 0) {\n          $paren_string = substr($paren_string, 0, $i); // Remove parenthesis\
    \ from string.\n        }\n      }\n      $current_index++;\n    }\n  }\n  return\
    \ array_map(function($group) {\n    return implode(\"\", array_filter($group,\
    \ function($element) {\n      return $element !== \"\";\n    }));\n  }, $paren_stack);\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere is my version, for php 7+\n<code>",
  "  $paren_array = [];\n  $open_parens = 0;\n  foreach (str_split($paren_string)\
    \ as $char) {\n    if ($char === '(') {\n      $paren_array[] = '';\n      $open_parens++;\n\
    \    } elseif ($char === ')') {\n      $open_parens--;\n      if ($open_parens\
    \ === 0) {\n        $paren_array[] = substr($paren_array, 0, -1);\n      }\n \
    \   }\n  }\n  return $paren_array;\n}\n", "    $parens = array();\n\n    for($i\
    \ = 0; $i < strlen($paren_string); $i++) {\n        $char = substr($paren_string,\
    \ $i, 1);\n        if($char == '(') {\n            if(empty($parens[count($parens)\
    \ - 1])) {\n                $parens[] = array('');\n            }\n          \
    \  $parens[count($parens) - 1][] = $char;\n        } else if($char == ')') {\n\
    \            if(count($parens)) {\n                $last_open = array_pop($parens);\n\
    \                if(empty($last_open)) {\n                    $parens[] = array('');\n\
    \                }\n                $parens[count($parens) - 1][] = $char;\n \
    \           } else {\n                break;\n            }\n        } else {\n\
    \            if(empty($parens[count($parens) - 1])) {\n                $parens[]\
    \ = array($char);\n            } else if($parens[count($parens) - 1] != array($char))\
    \ {\n                break;\n            }\n        }\n    }\n\n    return $parens;\n\
    }\n", "    $paren_open = array();\n    $paren_closed = array();\n    $nested_open\
    \ = array();\n    $nested_closed = array();\n    $len = strlen($paren_string);\n\
    \    for($i = 0; $i < $len; $i++) {\n        $char = $paren_string[$i];\n    \
    \    if ($char == '(') $paren_open[] = $i;\n        if ($char == ')') $paren_closed[]\
    \ = $i;\n        if ($char == '(') $nested_open[] = $i;\n        if ($char ==\
    \ ')') $nested_closed[] = $i;\n    }\n    $result = array();\n    $len = count($paren_open);\n\
    \    for($i = 0; $i < $len; $i++) {\n        $start_open = $paren_open[$i];\n\
    \        $start_closed = $paren_closed[$i];\n        $len2 = count($nested_open);\n\
    \        for($j = 0; $j < $len2; $j++) {\n            $end_open = $nested_open[$j];\n\
    \            $end_closed = $nested_closed[$j];\n            if ($end_open < $start_closed)\
    \ {\n                $result[] = substr($paren_string, $start_open, $end_open\
    \ - $start_open);\n                $start_open = $end_open;\n            }\n \
    \           if ($end_closed < $start_open) {\n                $result[] = substr($paren_string,\
    \ $start_closed, $end_closed - $start_closed);\n                $start_closed\
    \ = $end_closed;\n            }\n        }\n        $result[] = substr($paren_string,\
    \ $start_open, $start_close - $start_open);\n    }\n    return $result;\n}\n</code>\n\
    <|/ a dscore=2 tags=php,preg-match-all |>\n<| c |>\n+1 You beat me to it, although\
    \ I did have to edit it slightly to fix a syntax error (missing bracket) which\
    \ should really be fixed :-)\n<|/ c |>\n<| a |>\nHere is an idea, that may help\
    \ you to do it yourself:\n\nUse a stack to keep track of the open and closed parens\n\
    Use recursion to parse through your input string\nPop an open paren off the stack\
    \ and replace it with an escaped paren character\nIf you find an open paren, pop\
    \ the stack until you find a closed paren, then push the current open paren to\
    \ the stack\nIf you find a closed paren, pop the stack until you find an open\
    \ paren, then push the current closed paren to the stack\nIf you find another\
    \ open paren, push it to the stack and replace the current open paren with the\
    \ escaped open paren\nIf you find another closed paren, ", "    // Our regex will\
    \ match an opening parenthesis, some characters (any number of), then a closing\
    \ parenthesis,\n    // and another set of parenthesis.\n    // We match a group\
    \ of parenthesis, followed by zero or more spaces, followed by a single (\n  \
    \  // or group of (, or followed by zero or more spaces, followed by a ) closing\
    \ parenthesis.\n    preg_match_all('/\\(([^()]*)\\)/', $paren_string, $matches);\n\
    \    $matches = array_unique($matches[1]);\n    // The regex will match a single\
    \ opening parenthesis, some characters (any number of), then a closing parenthesis,\n\
    \    // and another set of parenthesis.\n    // We match a group of parenthesis,\
    \ followed by zero or more spaces, followed by a single (\n    // or group of\
    \ (, or followed by zero or more spaces, followed by a ) closing parenthesis.\n\
    \    preg_match_all('/\\(([^()]*)\\)/', $paren_string, $matches);\n    $matches\
    \ = array_unique($matches[1]);\n    $new_matches = [];\n    $count = 0;\n    foreach\
    \ ($matches as $value) {\n        if ($value != '') {\n            $new_matches[$count]\
    \ = $value;\n            $count++;\n        }\n    }\n    return $new_matches;\n\
    }\n\n/**\n * Function to parse text and replace tags with HTML codes.\n * Expects\
    \ one or two arguments.\n * First argument is the HTML text to be parsed and the\
    \ second argument is the text that needs to be replaced.\n * If no arguments are\
    \ passed this function will return the text that needs to be replaced.\n * It\
    \ does not do any formatting - all HTML is left intact.\n * Example usage:\n *\
    \ >>> replace_tags( $html )\n * >>> replace_tags( $html, null )\n * >>> replace_tags(\
    \ $html, null )\n * >>> replace_tags( $html, '<em> </em> <strong> ** </strong>'\
    \ )\n * >>> replace_tags( $html, '<p>test</p>', '<p><em>test</em></p>' )\n * >>>\
    \ replace_tags( $html, '<p>test</p>', '<p><em>test</em></p>' )\n * >>> replace_tags(\
    \ $html, '<p>test</p>', '<p><em>test</em></p>' )\n * >>> replace_tags( $html,\
    \ '<p>test</p>', '<p><em>test</em></p>' )\n * >>> replace_tags( $html, '<p>test</p>',\
    \ '<p><em>test</em></p>' )\n * >>> replace_tags( $html, '<p>test</p>', '<p><em>test</em></p>'\
    \ )\n * >>> replace_tags( $html, '<p>test</p>', '<p><em>test</em></p>' )\n * >>>\
    \ replace_tags( $html, '<p>test</p>', '<p><em>test</em>", "    $open_brackets\
    \ = array();\n    $closed_brackets = array();\n    $return_strings = array();\n\
    \n    $input_length = strlen($paren_string);\n    for ($i = 0; $i < $input_length;\
    \ $i++) {\n        if ($paren_string[$i] === '(') {\n            $open_brackets[]\
    \ = $i;\n        }\n\n        if ($paren_string[$i] === ')') {\n            if\
    \ (count($open_brackets) === 1) {\n                $return_strings[] = substr($paren_string,\
    \ $open_brackets[0], 1);\n            } else {\n                $open_brackets\
    \ = array_filter(\n                    $open_brackets,\n                    function\
    \ ($value) {\n                        return $value !== $i;\n                \
    \    }\n                );\n                $closed_brackets[] = $i;\n       \
    \     }\n        }\n\n        if ($paren_string[$i] === ' ') {\n            if\
    \ (count($open_brackets) === 0 && count($closed_brackets) !== 0) {\n         \
    \       $return_strings[] = '';\n            }\n        }\n    }\n    return $return_strings;\n\
    }\n</code>\n<|/ a tags=php,string |>\n<| c |>\nThank you for this, I'll have a\
    \ go at trying to figure out how to implement it\n<|/ c |>\n<| c |>\nThis code\
    \ is awesome! Thank you very much, it works like a charm. Just one question though,\
    \ would you mind explaining what the code is doing? It seems pretty complex to\
    \ me and I don't fully understand it yet. Thanks again!\n<|/ c |>\n<| c |>\nThe\
    \ code basically breaks the input string into groups of parenthesis enclosed in\
    \ other parenthesis while keeping track of the start and end positions of the\
    \ individual groups. At each position of the input string, it checks whether the\
    \ current position is inside the group or not. If it is not, it replaces the current\
    \ character with `''`. At that point, the current character is considered part\
    \ of the current group, which means it will be added to the group array. Otherwise,\
    \ if the current character is inside the group, it is removed from the group array\
    \ and replaced with the current character. Finally, when the current position\
    \ is outside the group, it gets added to the group of remaining characters until\
    \ the next character is encountered.\n<|/ c |>\n<| c |>\nSorry for the late reply,\
    \ I ran out of time yesterday. I really appreciate this code, so thank you so\
    \ much for explaining it! This was a great learning experience for me. Also, thanks\
    \ for the edit. Much easier than my previous attempt at doing this.\n<|/ c |>\n\
    <| c |>\nYou're welcome. Thanks for your kind words. If you need further explanation\
    \ on the code, feel ", "    $string_list = explode(')', $paren_string);\n    foreach\
    \ ($string_list as &$string) {\n        if (strlen($string) > 0 && substr($string,\
    \ -1) !== ')') {\n            $string .= ')';\n        }\n    }\n    return $string_list;\n\
    }\n", "  $paren_string = trim($paren_string);\n  $paren_string = preg_replace('/\\\
    s+/', '', $paren_string);\n  $paren_string = preg_replace('/\\((.*?)\\)/', '(\\\
    1)', $paren_string);\n  $paren_string = explode(')', $paren_string);\n  $paren_string\
    \ = array_filter($paren_string);\n  return $paren_string;\n}\n</code>\n<|/ a tags=php,regex\
    \ dscore=0 |>\n<| c |>\nWhy do you need to use regex?\n<|/ c |>\n<| c |>\nI need\
    \ the regex to capture the parenthesis and brackets and separate them.\n<|/ c\
    \ |>\n<| c |>\nThe question is about how to separate parenthesis inside a string.\
    \ Your regex doesn't cover that case.\n<|/ c |>\n<| c |>\nWhat do you mean by\
    \ \"cover that case\"? I tested this and it works perfectly on my machine. What\
    \ is your input?\n<|/ c |>\n<| c |>\nThe input is `\"( ) (( )) (( )( ))\"`. Your\
    \ regex only separates the parenthesis inside the outermost brackets, not the\
    \ ones inside each other.\n<|/ c |>\n<| a tags=php,regex |>\nA little bit different\
    \ and more general. Can be used for other languages and with multiple expressions,\
    \ not only parenthesis and brackets.\nThe idea is to use look-behind to match\
    \ each closing bracket with its opening one. And the match will be stored into\
    \ the group \"opener\" and the match will be stored in group \"closer\".\n<code>\n\
    $str = \"( ) (( )) (( )( ))\";\n$pattern = '~\n (?:\n   ^                  # Start\
    \ of the string\n   .*                 # Any chars until the end of the string\n\
    \   \\g<opener>          # Match the opener chars \n   \\g<closer>          #\
    \ Match the closer chars\n )\n~x';\npreg_match_all($pattern, $str, $matches);\n\
    print_r($matches);\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis is not\
    \ really a job for regex:\n<code>\n$a = '( ) (( )) (( )( ))';\n\n$i = 0;\n$l =\
    \ strlen($a);\n$s = '';\nwhile( $i < $l )\n{\n    if( $a[$i] == ' ' || $a[$i]\
    \ == ')' )\n    {\n        $s += $a[$i];\n        $i++;\n    }\n    else if($a[$i]",
  "    $regex = '/\n        ^                   # Start of string\n        (?P<parens>\
    \     # Match group \"parens\" with the following contents:\n            \\( (?P<nested_parens>\
    \ )*    # Match 0 or more nested parentheses\n            \\)\n        )\n   \
    \     (?P<unclosed_parens>\n            (?P<unclosed_nested_parens> )* # Match\
    \ 0 or more unclosed nested parentheses\n        )\n        (?P<spaces>      \
    \   # Match group \"spaces\" with the following contents:\n            \\s*\n\
    \        )\n        $                   # End of string\n        'x;\n    $matches\
    \ = array();\n    $results = preg_match_all($regex, $paren_string, $matches);\n\
    \    if ($results === FALSE) {\n        return FALSE;\n    }\n    $parens = $matches['parens'];\n\
    \    $nested_parens = $matches['nested_parens'];\n    $unclosed_parens = $matches['unclosed_parens'];\n\
    \    $unclosed_nested_parens = $matches['unclosed_nested_parens'];\n    $spaces\
    \ = $matches['spaces'];\n    $parens_count = count($parens);\n    $nested_parens_count\
    \ = count($nested_parens);\n    $unclosed_parens_count = count($unclosed_parens);\n\
    \    if ($nested_parens_count != $parens_count) {\n        return FALSE;\n   \
    \ }\n    if ($unclosed_parens_count != $parens_count - $nested_parens_count +\
    \ 1) {\n        return FALSE;\n    }\n    if ($unclosed_nested_parens_count !=\
    \ $nested_parens_count - $unclosed_parens_count + 1) {\n        return FALSE;\n\
    \    }\n    // Remove the matched strings\n    unset($parens[0], $nested_parens[0],\
    \ $unclosed_parens[0], $unclosed_nested_parens[0], $spaces[0]);\n    // Append\
    \ the spaces to the results\n    $parens = array_merge(array(), $parens);\n  \
    \  $nested_parens = array_merge(array(), $nested_parens);\n    $unclosed_parens\
    \ = array_merge(array(), $unclosed_parens);\n    $spaces = array_merge(array(),\
    \ $spaces);\n    $results[] = implode('', $parens) . implode('', $nested_parens)\
    \ . implode('', $unclosed_parens) . implode('', $spaces);\n    return $results;\n\
    }\n</code>\nThis was my first attempt at making a recursive function that would\
    \ not require the use of any loops and could just use regular expressions to parse\
    \ the string.\nThe issue I had with this was that I could have unbalanced parentheses\
    \ and this would cause it to fail. I also tried to come up ", "    $paren_stack\
    \ = [];\n    $parens = [];\n    foreach (explode(')', $paren_string) as $sub_paren)\
    \ {\n        if (trim($sub_paren, '()') === '') {\n            // This is another\
    \ set of parens.\n            // Remove this set of parens from the list.\n  \
    \          $paren_stack = array_diff($paren_stack, $parens);\n            // Keep\
    \ this set of parens in our list of parens.\n            $parens = array_merge($parens,\
    \ $paren_stack);\n        } else {\n            // Keep track of this set of parens.\n\
    \            $paren_stack[] = $sub_paren;\n        }\n    }\n    return array_values(array_filter($parens,\
    \ 'strlen'));\n}\n</code>\n(Demo)\n<|/ a tags=regex,php,arrays,string,match |>\n\
    <| a dscore=0 tags=regex,php,arrays,string,match |>\nYou can use the following\
    \ regex:\n<code>\n<?php\n$str = \"a((b)(c)(d)(e)(f)g) (b((c)(f))(g)(i)(j))\";\
    \ // The string to search\n\n$regex = '/(?<=\\))(\\(([^\\)]*)\\))+/';\n\nif (preg_match_all($regex,\
    \ $str, $matches)) {\n  echo '<pre>';\n  print_r($matches);\n  echo '</pre>';\n\
    }\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => Array\n        (\n         \
    \   [0] => a((b)(c)(d)(e)(f)g) (b((c)(f))(g)(i)(j))\n            [1] => b((c)(f))(g)(i)(j)\n\
    \        )\n\n    [1] => Array\n        (\n            [0] => (b)(c)(d)(e)(f)g\n\
    \            [1] => (c)(f)\n        )\n\n)\n</code>\n<|/ a |>\n<| a tags=regex,php,arrays,string,match\
    \ |>\nTry this code\n<code>\n<?php\n\n$string = \"a((b)(c)(d)(e)(f)g) (b((c)(f))(g)(i)(j))\"\
    ;\npreg_match_all(\"/\\(([^\\)]+)\\)/\",$string, $matches);\nprint_r($matches);",
  "    $paren_string = preg_replace('/\\s+/', ' ', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\(\\(|\\)\\)/', '\\\\1', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\(\\)/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    (\\((.*?)\\)\\)/', '(', $paren_string);\n    $paren_string = preg_replace('/\\\
    )\\(/', '\\\\1', $paren_string);\n    $paren_string = preg_replace('/\\)/', '',\
    \ $paren_string);\n    $paren_string = preg_replace('/\\((.*?)\\)/', '(', $paren_string);\n\
    \    $paren_string = preg_replace('/\\((.*?)\\)/', '(', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\)/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    (\\((.*?)\\)\\)/', '(', $paren_string);\n    $paren_string = preg_replace('/\\\
    (\\(|\\)\\)/', '', $paren_string);\n    $paren_string = preg_replace('/\\((.*?)\\\
    )/', '(', $paren_string);\n    $paren_string = preg_replace('/\\((.*?)\\)/', '(',\
    \ $paren_string);\n    return explode(',', $paren_string);\n}\n", "    $paren_string\
    \ = $paren_string;\n    $paren_string = trim($paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*[)(]\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/[)(]\\\
    s*[)(]\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/[)(]\\s*[)(]\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/[)(]\\s*/', '',\
    \ $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\\
    s*/', '', $paren_string);\n    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n\
    \    $paren_string = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string\
    \ = preg_replace('/\\s*/', '', $paren_string);\n    $paren_string = preg_replace('/",
  "    if (empty($paren_string)) return array();\n\n    $paren_string = str_replace(\"\
    \ \", \"\", $paren_string); // trim off any white space\n    $paren_string = str_replace(\"\
    \\n\", \"\", $paren_string); // trim off any new line\n    $paren_string = str_replace(\"\
    \\r\", \"\", $paren_string); // trim off any carriage return\n    $paren_string\
    \ = str_replace(\" \", \"\", $paren_string); // trim off any white space\n   \
    \ $paren_string = str_replace(\"\\t\", \"\", $paren_string); // trim off any tab\n\
    \    $paren_string = str_replace(\"!\", \"!\", $paren_string); // replace ! with\
    \ !\n\n    $open_paren_stack = array(); // stack of open paren groups\n    $open_paren_count\
    \ = 0;\n\n    // loop over all characters in the string\n    for ($i = 0; $i <\
    \ strlen($paren_string); $i++) {\n        $cur_character = $paren_string[$i];\n\
    \        $cur_char_count = 1;\n\n        // check to see if the current character\
    \ is a close paren\n        if ($cur_character == ')') {\n            $open_paren_count--;\n\
    \        }\n\n        // check to see if we're still open\n        if ($open_paren_count\
    \ > 0) {\n            // check to see if we have already encountered an open paren\
    \ group\n            if (isset($open_paren_stack[$open_paren_count])) {\n    \
    \            $open_paren_stack[$open_paren_count] .= '^'; // append to the open\
    \ paren group\n            } else {\n                // check to see if the current\
    \ character is a space\n                if ($cur_character == ' ') {\n       \
    \             $open_paren_count++;\n                }\n\n                // if\
    \ the current character is a space, increment the count and move on\n        \
    \        $open_paren_count++;\n            }\n        }\n\n        // check to\
    \ see if the current character is an open paren\n        if ($cur_character ==\
    \ '(') {\n            $open_paren_count++;\n        }\n\n        // check to see\
    \ if the current character is a close paren\n        if ($cur_character == ')')\
    \ {\n            $open_paren_count--;\n        }\n\n        // if the current\
    \ character is a close paren, append it to the open paren group\n        if (isset($open_paren_stack[$open_paren_count]))\
    \ {\n            $open_paren_stack[$open_paren_count] .= $cur_character;\n   \
    \     }\n    }\n\n    $paren_string = implode('', $open_paren_stack);\n    $paren_string\
    \ = preg_replace('!^$!', '', $paren_string);\n\n    return explode(\"\\n\", $paren_string);\n\
    }\n</code>\n<|/ a tags=regex |>\n<| c |>\nThanks, but this doesn't work on multi-line\
    \ strings. For example, `separate_paren_groups(\"(foo) bar", "  $paren_array =\
    \ array();\n  $current_char = null;\n  $open_paren = 0;\n  foreach (str_split($paren_string)\
    \ as $char) {\n    if ($char == '(') {\n      $open_paren++;\n      $current_char\
    \ = null;\n    }\n    else if ($char == ')') {\n      $open_paren--;\n    }\n\
    \    else if ($char != ' ' && $current_char != ')') {\n      $current_char = $char;\n\
    \    }\n    if ($open_paren == 0 && $current_char == null) {\n      $paren_array[]\
    \ = '';\n    }\n    if ($open_paren > 0) {\n      $paren_array[] = $char;\n  \
    \  }\n  }\n  return $paren_array;\n}\n", "    $parens = [];\n    $open = 0;\n\
    \    $last = 0;\n    $current_pos = 0;\n    while ($current_pos < strlen($paren_string))\
    \ {\n        $char = substr($paren_string, $current_pos++, 1);\n        if ($char\
    \ == \"(\") {\n            $parens[$open] = substr($paren_string, $last, $current_pos\
    \ - $last);\n            $last = $current_pos;\n            $open++;\n       \
    \ } else if ($char == \")\") {\n            $open--;\n        }\n    }\n    return\
    \ $parens;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=regex,php dscore=2 |>\nHere's\
    \ a simple recursive solution without using regex:\n<code>\n<?php\n", "    $groups\
    \ = [];\n\n    $current_parens = [];\n    $current_group = null;\n\n    for ($i\
    \ = 0; $i < strlen($paren_string); $i++) {\n        $char = substr($paren_string,\
    \ $i, 1);\n\n        if ($char === ')') {\n            $current_parens[] = $char;\n\
    \        } elseif ($char === '(' && !empty($current_parens)) {\n            $current_group\
    \ = $current_parens;\n            $current_parens = [];\n        } elseif ($char\
    \ === ' ' && !empty($current_parens)) {\n            $groups[] = $current_group;\n\
    \            $current_parens = [];\n        } else {\n            $current_parens[]\
    \ = $char;\n        }\n    }\n\n    $groups[] = $current_group;\n\n    return\
    \ $groups;\n}\n", "    $paren_array = array();\n    $in_string = false;\n    for\
    \ ($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == \"(\") {\n            $paren_array[] = $in_string;\n            $in_string\
    \ = false;\n        } else {\n            $in_string = $in_string ? $paren_string[$i]\
    \ : \"\";\n        }\n    }\n    $paren_array[] = $in_string;\n    return $paren_array;\n\
    }\n", "  // Get the count of the number of '(' and ')'\n  $paren_open = substr_count($paren_string,\
    \ '(');\n  $paren_close = substr_count($paren_string, ')');\n\n  // Initialize\
    \ an array with zeros initialized to 0 and 1 for the '(' and ')' counts\n  $group_counts\
    \ = array_fill(0, $paren_open, $paren_close);\n\n  // Initialize the array of\
    \ strings as an empty array\n  $groups = array();\n\n  // Loop through every character\
    \ in the input string\n  foreach (str_split($paren_string) as $character) {\n\
    \    // If the character is ')' then decrement the count by 1, otherwise increment\
    \ the count by 1\n    $groups[$character] = $character == ')' ? --$group_counts[$character]\
    \ : $group_counts[$character] + 1;\n\n    // If the count is 0 then the string\
    \ is complete, otherwise continue the loop\n    if ($group_counts[$character]\
    \ < 0) {\n      break;\n    }\n  }\n\n  return $groups;\n}", "  $paren_sub_strings\
    \ = preg_split('/(?<=^)(?=[^()]*(\\))|[^()]*(?=($|[^(]))/m', $paren_string);\n\
    \  // Remove the first empty string if there are any nested parens.\n  $paren_sub_strings\
    \ = array_filter($paren_sub_strings);\n  return $paren_sub_strings;\n}\n", " \
    \   $paren_groups = array();\n    $inParen = false;\n    $openParen = 1;\n   \
    \ $closingParen = 0;\n    $openBrace = false;\n    $openBracket = false;\n   \
    \ $closingBracket = false;\n    $firstChar = '';\n    $lastChar = '';\n    $currentChar\
    \ = '';\n    for ($i = 0; $i < strlen($paren_string); ++$i) {\n        $currentChar\
    \ = $paren_string[$i];\n        if ($inParen) {\n            if ($currentChar\
    \ === ')') {\n                $paren_groups[] = $firstChar;\n                $inParen\
    \ = false;\n                $closingBracket++;\n                $closingBrace\
    \ = false;\n            }\n            else if ($currentChar === '(') {\n    \
    \            $paren_groups[] = $firstChar;\n                $inParen = false;\n\
    \                $closingBrace++;\n                $closingBracket = false;\n\
    \            }\n            else if ($currentChar === ' ') {\n               \
    \ $paren_groups[] = $firstChar;\n                $firstChar = '';\n          \
    \  }\n            else if ($currentChar === '\\'') {\n                $openBracket++;\n\
    \            }\n            else if ($currentChar === '\"') {\n              \
    \  $openBrace++;\n            }\n        }\n        else if ($currentChar ===\
    \ '(' || $currentChar === ')' || $currentChar === ' ') {\n            $openBrace++;\n\
    \        }\n        else if ($currentChar === '\\'') {\n            $openBracket++;\n\
    \        }\n        else if ($currentChar === '\"') {\n            $openBrace++;\n\
    \        }\n        else if ($currentChar === ' ') {\n            $firstChar =\
    \ $currentChar;\n        }\n        else if ($currentChar === '(' || $currentChar\
    \ === ')') {\n            $openBracket++;\n        }\n        else if ($currentChar\
    \ === '\\'' || $currentChar === '\"') {\n            $openBrace++;\n        }\n\
    \        else if ($currentChar === '(') {\n            $openBracket++;\n     \
    \   }\n        else if ($currentChar === ')') {\n            $openBrace++;\n \
    \       }\n        else if ($currentChar === ' ') {\n            $firstChar =\
    \ $currentChar;\n        }\n        else if ($currentChar === '(' || $currentChar\
    \ === ')') {\n            $openBracket++;\n        }\n        else if ($currentChar\
    \ === '\\'') {\n            $openBracket++;\n        }\n        else if ($currentChar\
    \ === '\"') {\n            $openBrace++;\n        }\n        else if ($currentChar\
    \ === ')') {\n            $openBracket++;\n        }\n        else if ($currentChar\
    \ === ' ') {\n            $firstChar = $currentChar;", "    $paren_string_arr\
    \ = preg_split(\"/([\\(\\)])/\", $paren_string);\n    $paren_string_arr = array_filter($paren_string_arr,\
    \ 'strlen');\n    return $paren_string_arr;\n}\n</code>\n<|/ a |>\n<| c |>\nI've\
    \ used your solution with some minor changes: I've added some code to make things\
    \ more robust and to make the function return an array of strings, instead of\
    \ a string with extra spaces in it. The new function is now called `separate_paren_groups()`.\n\
    <|/ c |>\n<| a tags=string,php,regex |>\nHere is a solution that also finds parenthesis\
    \ that aren't balanced:\n<code>", "    // Iterate over each character in the string\n\
    \    $groups = preg_match_all('/\\((?P<open>\\()|(?P<closed>\\))/U', trim($paren_string),\
    \ $paren_matches);\n\n    // Return a list of all groups (matches with paren open/close\
    \ characters)\n    return $paren_matches['open'][$groups] + $paren_matches['closed'][$groups];\n\
    }\n", "    return preg_match_all('/\\((.+?)\\)/', $paren_string, $matches, PREG_SET_ORDER);\n\
    }\n", "    // First separate any opening parens\n    $opening_parens = preg_match_all('/\\\
    (([^()]*+)\\)/', $paren_string, $matches);\n    if ($opening_parens > 0) {\n \
    \       $paren_string = str_replace($matches[0][0], '', $paren_string);\n    }\n\
    \n    // Then separate any closing parens\n    $closing_parens = preg_match_all('/\\\
    (([^()]*+)\\)/', $paren_string, $matches);\n    if ($closing_parens > 0) {\n \
    \       $paren_string = str_replace($matches[0][1], '', $paren_string);\n    }\n\
    \n    // Return the list of parens\n    return preg_match_all('/\\(([^()]*+)\\\
    )/', $paren_string, $matches);\n}\n\n/**\n * Recursively walks through a string\
    \ to build a PHP array (by reference).\n *\n * @param string $str\n * @param string\
    \ $delim Optional delimiter to use. Defaults to \".\"\n *\n * @return void\n */",
  "    $result = [];\n    $paren_count = 0;\n    $open_brace_count = 0;\n    $open_brace_char\
    \ = '';\n    // Split up the input string into an array of single characters\n\
    \    $char_array = str_split($paren_string);\n    foreach ($char_array as $char)\
    \ {\n        // Look for opening paren character\n        if ($char == '(') {\n\
    \            $open_brace_count++;\n            $open_brace_char = $char;\n   \
    \     } else {\n            // Look for closing paren character\n            if\
    \ ($char == ')') {\n                $open_brace_count--;\n                if ($open_brace_count\
    \ == 0) {\n                    // Found a matching paren character\n         \
    \           $result[] = $open_brace_char;\n                    // Reset state\
    \ for the next set of parens\n                    $open_brace_count = 0;\n   \
    \                 $open_brace_char = '';\n                }\n            } else\
    \ {\n                // Look for whitespace\n                if ($char == ' ')\
    \ {\n                    // Ignore any spaces\n                } else {\n    \
    \                // Look for anything else\n                    $open_brace_char\
    \ = '';\n                }\n            }\n        }\n    }\n\n    return $result;\n\
    }\n", "    // Return an empty array if there are no matching groups in the string\n\
    \    if (!preg_match_all('/\\(([^\\)]*)\\)/', $paren_string, $matches, PREG_SET_ORDER))\
    \ {\n        return [];\n    }\n\n    // If there is only one group in the string\
    \ (i.e. it is the entire string), just return it\n    return count($matches) ===\
    \ 1 ? $matches[0] : $matches;\n}", "  $groups = array();\n  $in_parens = false;\n\
    \  $level = 0;\n  for($i = 0; $i < strlen($paren_string); $i++) {\n    $char =\
    \ $paren_string[$i];\n    if($char === '(') {\n      $in_parens = true;\n    \
    \  $level ++;\n    } else if($char === ')') {\n      $level -= 1;\n      if($level\
    \ === 0) {\n        $in_parens = false;\n        $groups[] = substr($paren_string,\
    \ 0, $i);\n        $paren_string = substr($paren_string, $i);\n        $i = 0;\n\
    \      }\n    } else if(!$in_parens) {\n      $groups[] = $char;\n    }\n  }\n\
    \  return $paren_string;\n}\n</code>\n<|/ a tags=algorithm,php,string |>\n<| c\
    \ |>\nHow did you arrive at that solution? I wonder how this works. What if I\
    \ wanted to separate the string by every X number of spaces, how would I do that?\
    \ Also, what is it that you call the \"level\" variable?\n<|/ c |>\n<| c |>\n\
    - I used the same method as you did, to create an array of all the \"open\" parens.\
    \ Then I loop through that array and find the \"close\" parens by looping backwards\
    \ from the end of the array, and check if there is a matching \"open\" paren.\n\
    <|/ c |>\n<| c |>\n- Level variable is called a \"depth\" variable, and it controls\
    \ how far into the parens hierarchy you go.\n<|/ c |>\n<| c |>\n- I updated my\
    \ answer to include a more robust way of getting the open/close parens, though\
    \ I would say its less readable than the other answer. Also, if you have any suggestions\
    \ for improving the algorithm, let me know. :)\n<|/ c |>\n<| c |>\nAwesome answer.\
    \ Thank you.\n<|/ c |>\n<| a |>\nI think you might want to use a regular expression\
    \ to identify the groups. For example, for the expression (( ( )) (( ( ))) ),\
    \ you could use something like this:\n<code>", "    if ($paren_string) {\n   \
    \     $open = 0;\n        $closed_groups = 0;\n        $opening_groups = array();\n\
    \        $return_string = array();\n        foreach (str_split($paren_string)\
    \ as $character) {\n            switch ($character) {\n                case '(':\n\
    \                    if (!isset($opening_groups[$character])) {\n            \
    \            $opening_groups[$character] = 1;\n                        $open++;\n\
    \                    }\n                    break;\n                case ')':\n\
    \                    $closed_groups = max(0, $opening_groups[$character] - $closed_groups\
    \ + 1);\n                    if (!$closed_groups) {\n                        $return_string[]\
    \ = substr($paren_string, 0, $character + 1);\n                        $return_string[]\
    \ = substr($paren_string, $character + 1, strlen($paren_string));\n          \
    \              break;\n                    }\n                    unset($opening_groups[$character]);\n\
    \                    break;\n            }\n        }\n        return $return_string;\n\
    \    }\n}\n", "    $groups = array();\n\n    // Create a regex to capture each\
    \ group of parentheses\n    $paren_group_matcher = preg_quote($paren_string, '/');\n\
    \    $regex = sprintf('~%s~u', preg_quote($paren_group_matcher, '~'));\n\n   \
    \ // Find all the groups\n    preg_match_all($regex, $paren_string, $paren_matches);\n\
    \    $groups = $paren_matches[0];\n    unset($paren_matches);\n\n    // Remove\
    \ the empty string from the beginning and end because they are empty\n    return\
    \ array_filter($groups);\n}\n</code>\n<|/ a |>\n<| c |>\nI like this one because\
    \ it doesn't require any recursive functions. But I only have one question --\
    \ why did you choose the more complex regex instead of something like `preg_match('/\\\
    (.*\\)/', $string);`?\n<|/ c |>\n<| c |>\nI needed a more complicated expression\
    \ to capture each group of parentheses, which is why I used `preg_match_all()`\
    \ and then `explode()` the result.  If the only parentheses you want to match\
    \ are the ones in parens, `preg_match('/\\(([^()]*)\\)/', $string, $paren_matches)`\
    \ should do the trick.\n<|/ c |>\n<| a |>\nThis function should do the job:\n\
    <code>", "    // The resulting array\n    $result = array();\n\n    // Initialize\
    \ the result and paren count\n    $result[0] = '';\n    $paren_count = 0;\n\n\
    \    // Iterate through all of the characters\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        // Get the current character\n        $current_char = $paren_string[$i];\n\
    \n        // If the character is a '('\n        if ($current_char == '(') {\n\
    \            // Add the result to the result\n            $result[] = $result[0];\n\
    \            // Increment the paren count\n            $paren_count++;\n     \
    \   }\n\n        // If the character is a ')'\n        elseif ($current_char ==\
    \ ')') {\n            // If the result has content\n            if ($result[0]\
    \ != '') {\n                // Remove the last character from the result\n   \
    \             $result[0] = substr($result[0], 0, -1);\n            }\n       \
    \     // Decrement the paren count\n            $paren_count--;\n\n          \
    \  // If there are no more parens left\n            if ($paren_count == 0) {\n\
    \                // Add the result to the result\n                $result[] =\
    \ $result[0];\n            }\n        }\n\n        // If there are characters\
    \ in the result that should be added to the result\n        if ($paren_count >\
    \ 0) {\n            // Add the current character to the result\n            $result[]\
    \ = $current_char;\n        }\n    }\n\n    // Return the result\n    return $result;\n\
    }\n", "    $open_braces = array();\n    $closed_parens = array();\n    $paren_string\
    \ = preg_replace('/\\s+/', '', $paren_string);\n    $pattern = '~(' . implode('|',\
    \ $open_braces) . ')(?:(' . implode('|', $closed_parens) . '))*~';\n    preg_match_all($pattern,\
    \ $paren_string, $matches);\n    return $matches[1];\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI thought this was going to be the best answer, but unfortunately it turned\
    \ out to be the worst :(\n<|/ c |>\n<| c |>\nWhat did it turn out to be?\n<|/\
    \ c |>\n<| c |>\nI couldn't get any of the other solutions to work for me in PHP7.2\
    \ (so I gave up on them in the end) so I used yours and modified it a bit. It\
    \ worked fine after I made a slight change to it (to make the regex be case-insensitive).\
    \ But I did have to change `preg_match_all($pattern, $string, $matches);` to `preg_match_all($pattern,\
    \ $string, $matches, PREG_SET_ORDER);`. I used this because it made it easy to\
    \ get the index of the matched group since `preg_match_all` returns an array,\
    \ but `preg_match` returns an array.\n<|/ c |>\n<| a tags=regex,php |>\nThe regex\
    \ \\((?:\\((?:\\((?:\\((?:\\((?:\\((?2)(?:\\((?3)(?:\\((?4)(?:\\((?5)(?:\\((?6)\\\
    )|\\((?1)\\))?\\)|\\((?7)\\))?\\)|\\((?8)\\))?\\)|\\((?9)\\))?\\)|\\((?10)\\))?\\\
    )|\\((?11)\\))?\\)|\\((?12)\\))?\\)|\\((?13)\\))?\\)|\\((?14)\\))?\\)|\\((?15)\\\
    ))?\\)|\\((?16)\\))?\\)|\\((?17)\\))?\\)|\\((?18)\\))?\\)|\\((?19)\\))?\\)|\\\
    ((?20)\\))?\\)|\\((?21)\\))?\\)|\\((?22)\\))?\\)|\\((?23)\\))?\\)|\\((?24)\\))?\\\
    )|\\((?25)\\))?\\)|\\((?26)\\))?\\)|\\((?27)\\))?\\)|\\((?28)\\))?\\)|\\((?29",
  "    $paren_string_arr = explode('(', $paren_string);\n    $parent_string_arr =\
    \ array();\n    foreach ($paren_string_arr as $paren_string) {\n        $parent_string_arr[]\
    \ = preg_replace('/\\s+/', '', $paren_string);\n    }\n    return $parent_string_arr;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is not an answer. You should edit your question\
    \ to add this information and delete the comment.\n<|/ c |>\n<| c |>\nI added\
    \ a little explanation. Thanks for your input!\n<|/ c |>\n<| a |>\n<code>\npreg_match_all('/\\\
    (([^\\(\\)]+)\\)[^\\(\\)]*/', $string, $matches);\n</code>\n<|/ a tags=php,regex\
    \ dscore=1 |>\n<| a dscore=0 |>\nThe function below will do the trick:\n<code>\n\
    <?php", "    $paren_groups = array();\n    $stack = array();\n    // Add items\
    \ to stack\n    foreach (str_split($paren_string) as $char) {\n        if ($char\
    \ == '(') {\n            array_push($stack, '(');\n        } elseif ($char ==\
    \ ')') {\n            while (count($stack)) {\n                $last_char = array_pop($stack);\n\
    \                if ($last_char == ')') {\n                    break;\n      \
    \          } elseif ($last_char == ')(') {\n                    // Found unbalanced\
    \ parens inside the stack. Add those to the stack and start a new parens group\n\
    \                    $paren_groups[] = substr($stack, 0, -1);\n              \
    \      $stack = array();\n                    break;\n                } else {\n\
    \                    // Found unbalanced parens inside this group. Add those to\
    \ the stack and start a new parens group\n                    $stack[] = $last_char;\n\
    \                }\n            }\n        }\n        // Add char to stack\n \
    \       $stack[] = $char;\n    }\n    // Add remainder of stack to paren_groups\
    \ if necessary\n    while (count($stack)) {\n        $paren_groups[] = substr($stack,\
    \ 0, -1);\n        $stack = array();\n    }\n\n    return $paren_groups;\n}\n",
  "    $paren_string_len = strlen($paren_string);\n    $out_string = \"\";\n    $paren_stack\
    \ = [];\n    $found_empty_stack = false;\n    for ($i = 0; $i < $paren_string_len;\
    \ $i++) {\n        $char = substr($paren_string, $i, 1);\n        if ($char ==\
    \ \")\") {\n            if (empty($paren_stack)) {\n                throw new\
    \ \\Exception(\"Unexpected parenthesis at position $i\");\n            }\n   \
    \         array_pop($paren_stack);\n        } else {\n            if ($char ==\
    \ \")\" && empty($paren_stack)) {\n                throw new \\Exception(\"Unexpected\
    \ ) at position $i\");\n            }\n            if (empty($paren_stack)) {\n\
    \                if ($char == \")\") {\n                    $out_string .= $char;\n\
    \                } else {\n                    $out_string .= $char;\n       \
    \         }\n            } else {\n                if ($char == \")\") {\n   \
    \                 if ($paren_stack[count($paren_stack) - 1] == $char) {\n    \
    \                    // Make sure this group is closed properly\n            \
    \            if (empty($paren_stack)) {\n                            $out_string\
    \ .= $char;\n                            $found_empty_stack = true;\n        \
    \                    continue;\n                        } else {\n           \
    \                 $found_empty_stack = false;\n                        }\n   \
    \                 } else {\n                        $out_string .= $char;\n  \
    \                  }\n                } else if ($paren_stack[count($paren_stack)\
    \ - 1] == $char) {\n                    $paren_stack[count($paren_stack) - 1]\
    \ .= $char;\n                    $out_string .= $char;\n                } else\
    \ {\n                    $out_string .= $char;\n                }\n          \
    \  }\n        }\n    }\n    if (empty($paren_stack) && !$found_empty_stack) {\n\
    \        throw new \\Exception(\"Unexpected end of parenthesis string\");\n  \
    \  }\n    return $out_string;\n}\n", "    // The function will be used to return\
    \ each individual group\n    // The function will be called recursively to continue\
    \ splitting the input string until all groups are found\n    $list_of_groups =\
    \ array();\n\n    // Set up a variable to keep track of the number of open parens\n\
    \    // A running count of all open parens will be used to determine how many\
    \ open parens there are to close before a new group is created\n    // Initialize\
    \ it to zero\n    $open_paren_count = 0;\n\n    // Split the input string into\
    \ an array of strings using spaces as delimiters\n    $input_string = explode('\
    \ ', $paren_string);\n\n    // Iterate through each string in the input string\n\
    \    foreach ($input_string as $group_string) {\n        // If the input string\
    \ does not contain a group (only one paren exists)\n        // Then return the\
    \ input string\n        if (!isset($group_string)) {\n            // Return the\
    \ input string\n            return $input_string;\n        }\n\n        // If\
    \ the input string contains a group (more than one paren exists)\n        // Then\
    \ start a recursive function call to continue splitting the input string until\
    \ a group is found\n        if (strpos($group_string, '(') !== FALSE) {\n    \
    \        // Increase the count of open parens within the string\n            $open_paren_count\
    \ += 1;\n\n            // Create a function that will return the list of groups\
    \ that make up the input string\n            $list_of_groups[] = separate_paren_groups($group_string);\n\
    \        } else {\n            // If there are no more open parens to close, then\
    \ add this group to the output list\n            // If the number of open parens\
    \ has reached the number of parens within the string before a new group is created\
    \ (which means there is no more open parens to close)\n            // Then close\
    \ the last group and start a new group\n            if ($open_paren_count ===\
    \ $open_paren_count) {\n                // Add the group to the output list\n\
    \                $list_of_groups[] = $group_string;\n                // Initialize\
    \ a new counter so that a new group is created\n                $open_paren_count\
    \ = 0;\n            } else {\n                // Close the previous group (if\
    \ there is one)\n                if (isset($list_of_groups[count($list_of_groups)\
    \ - 1])) {\n                    $list_of_groups[count($list_of_groups) - 1] .=\
    \ ')';\n                }\n                // Initialize a new counter so that\
    \ a new group is created\n                $open_paren_count = 0;\n           \
    \ }\n        }\n    }\n\n    // Return the list of groups that make up the input\
    \ string\n    return $list_of_groups;\n}\n</code>\nHere are some example results\
    \ for your test input string:\n<code>\n$testInput = '( )  ( )  ( )  ( ( ( ( )\
    \ ))) ()  ( )  ( )  ( )  ( )  ( ) ( )  ( )  ( )';\necho '<pre>';\nvar_dump(separate_paren_groups($test",
  "    $paren_groups = array();\n\n    // The index of the previous closing paren\
    \ character\n    $prev_paren_char_index = false;\n\n    // Iterate through the\
    \ input\n    for ($i = 0; $i < strlen($paren_string); $i++) {\n        if ($paren_string[$i]\
    \ == ' ') {\n            // Ignore spaces\n            continue;\n        }\n\n\
    \        // Get the character at $i\n        $cur_char = $paren_string[$i];\n\n\
    \        // If it is the last character or it is a closing paren character\n \
    \       // Add it to the current paren group\n        if ($i == strlen($paren_string)\
    \ - 1 || $cur_char == ')') {\n            $paren_groups[] = substr($paren_string,\
    \ 0, $i);\n            // If the previous closing paren character is NOT the beginning\
    \ of the string\n            // Then set the index to the beginning of the next\
    \ paren group\n            if ($prev_paren_char_index !== false) {\n         \
    \       $prev_paren_char_index = -1;\n            }\n            // Otherwise\
    \ set the index to the end of the previous paren group\n            else {\n \
    \               $prev_paren_char_index = $i - 1;\n            }\n        }\n \
    \       // Otherwise the character is part of the next paren group\n        else\
    \ {\n            $prev_paren_char_index = $i;\n        }\n    }\n\n    return\
    \ $paren_groups;\n}\n", "    // Store all found groups in an array\n    $matches\
    \ = [];\n\n    // Loop through all matches of parenthesis\n    preg_match_all('/\\\
    ((.+?)\\)/', $paren_string, $matches);\n\n    // Return array of found groups\n\
    \    return $matches[1];\n}\n", "    $paren_groups = preg_split('/\\s*((\\((?>[^()]+|(?R))*\\\
    ))|$)/u', $paren_string);\n    return array_filter($paren_groups);\n}\n", "  $paren_stack\
    \ = array();\n  $paren_string = preg_replace('/\\s+/', '', $paren_string);\n \
    \ $paren_string = preg_replace('/\\(|\\)|\\(\\s+\\)|\\(\\s+\\)\\s+\\)/', '', $paren_string);\n\
    \  preg_match_all('/\\((?>([^()]+|(?R))*)\\)/', $paren_string, $paren_matches);\n\
    \  foreach ($paren_matches[1] as $value) {\n    $paren_stack[] = $value;\n   \
    \ if (count($paren_stack) == 1) {\n      continue;\n    }\n    $last_open_brace\
    \ = array_pop($paren_stack);\n    if ($paren_stack[count($paren_stack) - 1] ==\
    \ $last_open_brace) {\n      continue;\n    }\n    if ($last_open_brace != '(')\
    \ {\n      return array();\n    }\n  }\n  return $paren_stack;\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=1 tags=regex,php |>\nI did it using preg_split and regular\
    \ expression. Hope it will help.\n<code>\n<?php\n\n$parens = array();\n$parens['parens_open']\
    \ = preg_split('/[^(\\)]+/', '( ) (( )) (( )( ))');\n$parens['parens_close'] =\
    \ preg_split('/\\s+/', str_replace('(', '', $parens['parens_open']));\n\nvar_dump($parens);\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nI wrote a regex that does what you need,\
    \ hope it helps:\n<code>\n<?php\n\n$string = '(( )) (( )) (( )) (( )) (( )) ((\
    \ )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) ((\
    \ )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) ((\
    \ )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) ((\
    \ )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) (( )) ((\
    \ )) (( )) (( )) (( )) (( )) (( )) (( )) ((", "    // Split string into an array\
    \ of strings of individual parens\n    $paren_array = preg_split('/\\s+/', $paren_string,\
    \ -1, PREG_SPLIT_NO_EMPTY);\n    $paren_array = [$paren_string];\n    // Reverse\
    \ the array so the inner parentheses are at the beginning\n    $paren_array =\
    \ $paren_array[count($paren_array) - 1];\n    // Go through the array backwards\
    \ while we find any closing parens\n    for ($i = count($paren_array) - 1; $i\
    \ >= 0; $i--) {\n        // If the closing paren is found, remove it from the\
    \ array and break the loop\n        if ($paren_array[$i] == '(') {\n         \
    \   unset($paren_array[$i]);\n            break;\n        }\n    }\n    // If\
    \ there are no more closing parentheses, just return the array\n    if (count($paren_array)\
    \ === 0) {\n        return [''];\n    }\n    // Create an array of strings of\
    \ remaining parens, starting with the innermost paren\n    $remaining_paren_array\
    \ = array_slice($paren_array, count($paren_array) - 1);\n    // Return an array\
    \ of strings\n    return $remaining_paren_array;\n}\n", "    // First, extract\
    \ all nested parentheses\n    $nested_parens = preg_match_all('/\\(([^\\)]*)\\\
    )/', $paren_string, $matches);\n\n    // Second, extract the non-nested parens\n\
    \    $nonnested_parens = preg_match_all('/([^\\(\\)]*)/', $paren_string, $matches);\n\
    \n    // Third, combine the two lists together\n    return array_merge($matches[1],\
    \ $matches[2]);\n}\n", "    // Store paren groups found\n    $paren_groups = array();\n\
    \n    // Loop through all characters in $paren_string\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n\n        // If opening brace is found, remember it\n        if ($paren_string[$i]\
    \ === '(') {\n            $paren_groups[] = '';\n        }\n\n        // If closing\
    \ brace is found\n        if ($paren_string[$i] === ')') {\n            // If\
    \ we have seen an opening paren, pop it off our stack\n            if (count($paren_groups)\
    \ > 0) {\n                array_pop($paren_groups);\n            }\n        }\n\
    \n        // If closing brace is found, add what's on the stack to our current\
    \ paren group\n        if ($paren_string[$i] === ')') {\n            $paren_groups[]\
    \ = $paren_groups[count($paren_groups) - 1] . substr($paren_string, $i, 1);\n\
    \        }\n\n        // If opening brace is found, remember it\n        if ($paren_string[$i]\
    \ === '(') {\n            $paren_groups[] = '';\n        }\n    }\n\n    // Return\
    \ list of paren groups\n    return $paren_groups;\n}\n", "\t$paren_array = array();\n\
    \t$paren_counter = 0;\n\t$nested_count = 0;\n\tfor ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n\t\t$char = $paren_string[$i];\n\t\t// Beginning of a group\n\t\tif\
    \ ($char == '(') {\n\t\t\t$paren_array[$paren_counter] = substr($paren_string,\
    \ 0, $i);\n\t\t\t$paren_counter++;\n\t\t}\n\t\t// End of a group\n\t\telseif ($char\
    \ == ')') {\n\t\t\t$nested_count--;\n\t\t\tif ($nested_count == 0) {\n\t\t\t\t\
    $paren_array[$paren_counter] = substr($paren_string, 0, $i + 1);\n\t\t\t\t$paren_counter++;\n\
    \t\t\t}\n\t\t}\n\t\t// New sub-nested group\n\t\telseif ($char == ' ') {\n\t\t\
    \t$nested_count++;\n\t\t}\n\t}\n\treturn $paren_array;\n}\n", "    $output = [];\n\
    \    $open_braces = 0;\n    $in_string = false;\n\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        if ($paren_string[$i] == \"(\") {\n            if ($in_string)\
    \ {\n                $output[$i] = $in_string;\n            }\n            $in_string\
    \ = true;\n            $open_braces++;\n        } elseif ($paren_string[$i] ==\
    \ \"(\") {\n            $in_string = false;\n            $open_braces++;\n   \
    \     } elseif ($paren_string[$i] == \")\") {\n            if ($open_braces >\
    \ 0) {\n                $open_braces--;\n            }\n        }\n    }\n\n \
    \   return $output;\n}\n</code>\n<|/ a tags=arrays,php,string |>\n<| a tags=arrays,php,string\
    \ |>\n<code>", "    $matches = array();\n\n    $pos = 0;\n    $open_parens = 0;\n\
    \    $nested_depth = 0;\n    for ($i = 0; $i < strlen($paren_string); $i++) {\n\
    \        if ($paren_string[$i] == ' ') {\n            if ($open_parens == 0) {\n\
    \                $nested_depth++;\n            }\n\n            if ($open_parens\
    \ > 0 && $nested_depth == 0) {\n                $nested_depth++;\n           \
    \ }\n\n            if ($open_parens == 0) {\n                $open_parens++;\n\
    \            }\n        } elseif ($paren_string[$i] == '(') {\n            $nested_depth++;\n\
    \            if ($nested_depth == 1) {\n                $pos = $i;\n         \
    \       $open_parens++;\n            }\n        } elseif ($paren_string[$i] ==\
    \ ')') {\n            $nested_depth--;\n            if ($nested_depth == 0) {\n\
    \                $matches[] = substr($paren_string, 0, $pos + 1);\n          \
    \  }\n            $open_parens--;\n        }\n    }\n\n    return $matches;\n\
    }\n", "    // Create an array of strings from the input string\n    $paren_strings\
    \ = explode(')', $paren_string);\n\n    // Initialize an empty array to store\
    \ results of recursive calls\n    $result = [];\n\n    // Loop through all the\
    \ strings in the input array\n    foreach ($paren_strings as $s) {\n        //\
    \ If the string is empty (i.e. a space or new line character) skip it\n      \
    \  if (empty($s)) {\n            continue;\n        }\n\n        // Otherwise,\
    \ add it to the output array and call the function recursively\n        $result[]\
    \ = separate_paren_groups($s);\n    }\n\n    return $result;\n}\n", "    $paren_array\
    \ = array();\n    $open_braces = 0;\n    for ($i = 0; $i < strlen($paren_string);\
    \ $i++) {\n        $char = $paren_string[$i];\n        // Ignore spaces\n    \
    \    if ($char === ' ' || $char === ',') {\n            continue;\n        }\n\
    \        if ($char === '(') {\n            $paren_array[] = $paren_string[$i];\n\
    \            $open_braces += 1;\n        } else if ($char === ')') {\n       \
    \     $open_braces -= 1;\n            if ($open_braces === 0) {\n            \
    \    $paren_array[] = $paren_string[$i];\n            }\n        }\n    }\n  \
    \  return $paren_array;\n}\n", "  $opening_parens = array();\n  $closing_parens\
    \ = array();\n\n  $opening_parens_match = '';\n  $closing_parens_match = '';\n\
    \  $opening_parens_depth = 0;\n  $closing_parens_depth = 0;\n\n  for ($i = 0;\
    \ $i < strlen($paren_string); $i++) {\n    if ($paren_string[$i] == ')' && $closing_parens_depth\
    \ == 0) {\n      $closing_parens_match = $paren_string[$i];\n      $closing_parens_depth\
    \ = 1;\n    }\n    else if ($paren_string[$i] == ')' && $closing_parens_depth\
    \ > 0) {\n      $closing_parens[] = $paren_string[$i];\n      $closing_parens_depth++;\n\
    \    }\n    else if ($paren_string[$i] == '(' && $opening_parens_depth == 0) {\n\
    \      $opening_parens_match = $paren_string[$i];\n      $opening_parens_depth\
    \ = 1;\n    }\n    else if ($paren_string[$i] == '(' && $opening_parens_depth\
    \ > 0) {\n      $opening_parens[] = $paren_string[$i];\n      $opening_parens_depth++;\n\
    \    }\n  }\n\n  if ($opening_parens_depth > 0) {\n    $opening_parens[] = $paren_string[strlen($paren_string)\
    \ - 1];\n  }\n  if ($closing_parens_depth > 0) {\n    $closing_parens[] = $paren_string[0];\n\
    \  }\n\n  return array_merge($opening_parens, $closing_parens);\n}\n</code>\n\
    <|/ a tags=javascript,php,recursion |>\n<| a dscore=0 tags=javascript,php,recursion\
    \ |>\nI have written a php script for this. In a first time, it works very well.\
    \ \n<code>", "  $paren_groups = array();\n  // Each open parenthesis has a corresponding\
    \ closing parenthesis. Track each paren group and add\n  // to our list.\n  foreach\
    \ (str_split($paren_string) as $char) {\n    if ($char === '(') {\n      // We\
    \ just opened a group\n      array_push($paren_groups, '(');\n    }\n    if ($char\
    \ === ')') {\n      // We just closed a group\n      if ($paren_groups[count($paren_groups)\
    \ - 1] === ')') {\n        // The last element was a closing paren - ignore this\
    \ one\n        array_pop($paren_groups);\n      } else {\n        array_push($paren_groups,\
    \ ')');\n      }\n    }\n  }\n  return $paren_groups;\n}\n", "    if (!is_string($paren_string))\
    \ {\n        return [];\n    }\n    $groups = explode('(', $paren_string);\n \
    \   $result = array();\n    foreach ($groups as $group) {\n        $closed = false;\n\
    \        $group = trim($group);\n        $open_braces = 0;\n        while (($open_braces\
    \ > 0) && ($closed === false)) {\n            $open_braces = substr_count($group,\
    \ '(');\n            if ($open_braces === 0) {\n                $closed = true;\n\
    \            } else {\n                $closed = substr_count($group, ')') ===\
    \ $open_braces;\n            }\n            $group = trim(substr($group, 0, -1));\n\
    \        }\n        $result[] = $group;\n    }\n    return $result;\n}\n</code>\n\
    This works for all cases, but I didn't check any edge cases.\n<|/ a dscore=1 tags=recursion,php,arrays,string\
    \ |>\n<| a dscore=1 |>\nThis should work:\n<code>\n$str = '( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( (", "    // First we split the string into an array where each group is\
    \ a set of nested parentheses.\n    $paren_arr = explode(\"((\", $paren_string);\n\
    \n    // Then we loop over those groups and separate them into separate groups\
    \ of parenthesized elements.\n    $paren_arr = [];\n    $open_paren_count = 0;\n\
    \    foreach ($paren_arr as $value) {\n        if (strlen($value) == 0) {\n  \
    \          continue;\n        }\n        if ($open_paren_count > 0) {\n      \
    \      $paren_arr[] = $value;\n        } else {\n            $paren_arr[] = \"\
    ($value)\";\n        }\n\n        $open_paren_count += substr_count($value, \"\
    (\");\n    }\n\n    return $paren_arr;\n}\n", "    // initialize variables\n \
    \   $paren_string = trim($paren_string);\n    $paren_string = str_replace(\"\\\
    t\", \" \", $paren_string);\n    $paren_string = str_replace(\"\\n\", '', $paren_string);\n\
    \    $paren_string = str_replace(\"\\r\", '', $paren_string);\n    $paren_string\
    \ = str_replace(\"\\f\", '', $paren_string);\n\n    // open paren group\n    $open_brace_count\
    \ = 0;\n    $open_brace_stack = array();\n    $open_brace_stack[] = $paren_string[0];\n\
    \    $open_brace_count++;\n    $open_paren_group_string = $paren_string[0];\n\n\
    \    // iterate through each character in the string\n    $strlen = strlen($paren_string);\n\
    \    for ($i = 1; $i < $strlen; $i++) {\n        // increment the open brace count\
    \ if encountered\n        if ($paren_string[$i] === '(') {\n            $open_brace_count++;\n\
    \        }\n        if ($paren_string[$i] === ')') {\n            $open_brace_count--;\n\
    \        }\n        // add the character to the open brace stack\n        if ($open_brace_count\
    \ === 0) {\n            if (count($open_brace_stack) > 0) {\n                //\
    \ pop the last element from the open brace stack and add to open paren group string\n\
    \                $open_paren_group_string .= $open_brace_stack[count($open_brace_stack)\
    \ - 1];\n                $open_brace_stack = array_pop($open_brace_stack);\n \
    \               $open_paren_group_string .= $paren_string[$i];\n            }\
    \ else {\n                // character is part of open paren group, but unbalanced\n\
    \                $open_paren_group_string .= $paren_string[$i];\n            }\n\
    \        }\n    }\n    // close the last open paren group (if it exists)\n   \
    \ if (count($open_brace_stack) > 0) {\n        $open_paren_group_string .= $open_brace_stack[count($open_brace_stack)\
    \ - 1];\n    }\n\n    return array($open_paren_group_string);\n}\n", "    // Initialize\
    \ the array\n    $paren_array = [];\n    // Loop through the string and add each\
    \ group to the array\n    for ($i=0; $i < strlen($paren_string); $i++) {\n   \
    \     // If the character is a space\n        if ($paren_string[$i] == ' ') {\n\
    \            // Append the array to the return value\n            $paren_array[]\
    \ = $paren_string;\n            // Reset the array\n            $paren_string\
    \ = $paren_string.'';\n        // If the character is a close parenthesis\n  \
    \      } else if ($paren_string[$i] == '(') {\n            // Add it to the array\n\
    \            $paren_array[] = $paren_string;\n            // Reset the string\n\
    \            $paren_string = $paren_string.'';\n        // If the character is\
    \ a close bracket\n        } else if ($paren_string[$i] == '[') {\n          \
    \  // Add it to the array\n            $paren_array[] = $paren_string;\n     \
    \       // Reset the string\n            $paren_string = $paren_string.'';\n \
    \       // If the character is a close brace\n        } else if ($paren_string[$i]\
    \ == '{') {\n            // Add it to the array\n            $paren_array[] =\
    \ $paren_string;\n            // Reset the string\n            $paren_string =\
    \ $paren_string.'';\n        // If the character is a close bracket or a backslash\n\
    \        } else if ($paren_string[$i] == '\\\\') {\n            // Add it to the\
    \ array\n            $paren_array[] = $paren_string;\n            // Reset the\
    \ string\n            $paren_string = $paren_string.'';\n        // If the character\
    \ is a close curly brace\n        } else if ($paren_string[$i] == '}') {\n   \
    \         // Add it to the array\n            $paren_array[] = $paren_string;\n\
    \            // Reset the string\n            $paren_string = $paren_string.'';\n\
    \        // If the character is a close square bracket\n        } else if ($paren_string[$i]\
    \ == '[') {\n            // Add it to the array\n            $paren_array[] =\
    \ $paren_string;\n            // Reset the string\n            $paren_string =\
    \ $paren_string.'';\n        // If the character is a close curly bracket\n  \
    \      } else if ($paren_string[$i] == '{') {\n            // Add it to the array\n\
    \            $paren_array[] = $paren_string;\n            // Reset the string\n\
    \            $paren_string = $paren_string.'';\n        // If the character is\
    \ a close square bracket or a backslash\n        } else if ($paren_string[$i]\
    \ == '\\\\') {\n            // Add it to the array\n            $paren_array[]\
    \ = $paren_string;\n            // Reset the string\n            $paren_string\
    \ = $paren_string.'';\n        // Otherwise\n        } else {\n            //\
    \ Add it to the string\n            $paren_string = $paren_string.' '.$paren_string[$i];\n\
    \        }\n    }\n    // Add the string to the array\n    $paren_array[] = $paren_string",
  "    $paren_groups = array();\n\n    for ($i = 0; $i < strlen($paren_string); $i++)\
    \ {\n        $char = $paren_string[$i];\n\n        if ($char === '(' || $char\
    \ === ')') {\n            $open_brace = $char;\n            $nested_open = false;\n\
    \            for ($j = $i + 1; $j < strlen($paren_string); $j++) {\n         \
    \       $char2 = $paren_string[$j];\n\n                if ($char2 === ' ') {\n\
    \                    $nested_open = true;\n                } else if ($char2 ===\
    \ ')') {\n                    $nested_open = false;\n                    break;\n\
    \                } else if ($char2 === '(') {\n                    $nested_open\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if ($open_brace === '(' && $nested_open) {\n                $paren_groups[]\
    \ = $paren_string.substr($i, 1);\n                $i = $j;\n            } else\
    \ {\n                $paren_groups[] = $paren_string.substr($i, 1);\n        \
    \    }\n        } else {\n            $paren_groups[] = $paren_string[$i];\n \
    \       }\n    }\n\n    return $paren_groups;\n}\n", "    $open_brace = -1;\n\
    \    $close_paren = -1;\n    $open_paren = -1;\n    $groups = array();\n\n   \
    \ while (($close_paren == -1) && ($open_brace < strlen($paren_string))) {\n  \
    \      if ($paren_string[$open_brace] == '(') {\n            $open_paren = $open_brace;\n\
    \        }\n        if ($paren_string[$open_brace] == '[') {\n            $open_brace++;\n\
    \        }\n        if ($paren_string[$open_brace] == '{') {\n            $open_brace++;\n\
    \        }\n        $close_paren = strpos($paren_string, '}', $open_brace);\n\
    \        if ($close_paren != false && $close_paren >= $open_paren) {\n       \
    \     $groups[] = substr($paren_string, $open_paren, ($close_paren - $open_paren));\n\
    \        }\n        if ($close_paren == false) {\n            $close_paren = strpos($paren_string,\
    \ ')', $open_brace);\n        }\n        if ($close_paren != false && $close_paren\
    \ >= $open_paren) {\n            $groups[] = substr($paren_string, $open_paren,\
    \ ($close_paren - $open_paren));\n        }\n        if ($open_paren != -1) {\n\
    \            $open_paren = -1;\n        }\n        if ($close_paren != -1) {\n\
    \            $close_paren = -1;\n        }\n        $open_brace++;\n    }\n\n\
    \    return $groups;\n}\n", "  $paren_array = array();\n  $level = 0;\n  $open_brace_count\
    \ = 0;\n\n  foreach (str_split($paren_string) as $char) {\n    switch ($char)\
    \ {\n      case '(':\n      case '{':\n      case '[':\n        $open_brace_count++;\n\
    \        $level++;\n        break;\n      case ')':\n      case '}':\n      case\
    \ ']':\n        $open_brace_count--;\n        $level--;\n        break;\n    \
    \  case ' ':\n        // Do nothing.\n        break;\n      default:\n       \
    \ if ($open_brace_count == 0) {\n          $paren_array[] = substr($paren_string,\
    \ 0, $char);\n        }\n        break;\n    }\n  }\n\n  return $paren_array;\n\
    }\n", "  $parens = array();\n  $open_parens = false;\n  $strings = array();\n\
    \  $length = strlen($paren_string);\n\n  for ($i = 0; $i < $length; $i++) {\n\
    \    if ($paren_string[$i] == ' ') {\n      if ($open_parens) {\n        $parens[]\
    \ = '';\n        $open_parens = false;\n      }\n    } else {\n      $open_parens\
    \ = !$open_parens;\n      $parens[] = $paren_string[$i];\n    }\n  }\n\n  if ($open_parens)\
    \ {\n    $parens[] = '';\n  }\n\n  $paren_count = count($parens);\n\n  for ($i\
    \ = 0; $i < $paren_count; $i++) {\n    if ($parens[$i] == ')') {\n      $strings[]\
    \ = '';\n      $i = $i + 1;\n      while ($i < $paren_count) {\n        if ($parens[$i]\
    \ == ')') {\n          $strings[] = '';\n          break;\n        }\n\n     \
    \   if ($parens[$i] == ' ') {\n          $strings[] = '';\n          break;\n\
    \        }\n\n        $strings[] = $parens[$i];\n        $i++;\n      }\n    }\n\
    \  }\n\n  return $parens;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNice job answering\
    \ the question and providing the code, but I really think this should be posted\
    \ as a comment on the question, since you aren't really answering the question.\n\
    <|/ c |>\n<| c |>\nThe above code does what it's supposed to do based on the requirements\
    \ given. My first comment was posted as a comment to the OP's question before\
    \ I started reading your answer.\n<|/ c |>\n<| c |>\nIf you're going to use RegEx,\
    \ at least use it correctly. You're using it incorrectly.\n<|/ c |>\n<| c |>\n\
    I appreciate your feedback, but I don't see the issue with my use of the RegEx.\
    \ Could you elaborate on why? I'll admit, my RegEx isn't the best, but my code\
    \ is working for my needs.\n<|/ c |>\n<| c |>\nI wrote the RegEx using http://regex101.com/\
    \ and tested the string in my own code to ensure that it matched the expectations.\
    \ While it doesn't matter if the RegEx matches or not, my code is only meant to\
    \ return an array of matched groups. I don't see the problem with that.\n<|/ c\
    \ |>\n<| a tags=regex,php dscore=0 |>\nAfter reading your question and others'\
    \ answers, I think I understand what you want to do and I did it on my own.\n\
    <code>\n<?php\n\n$string = '( ) (( )) ((", "    $result = array();\n    $open_braces\
    \ = array();\n    $inside_parens = array();\n    $open_brace_depth = 0;\n    foreach\
    \ (explode(\"\\n\", $paren_string) as $line) {\n        foreach (explode(\"\\\
    n\", $line) as $item) {\n            $itemLength = strlen($item);\n          \
    \  $itemWithoutWhitespace = preg_replace('/\\s+/', '', $item);\n            if\
    \ (strpos($itemWithoutWhitespace, ' ') === false) {\n                $result[]\
    \ = $item;\n            } else {\n                if ($open_brace_depth === 0)\
    \ {\n                    $open_braces[] = $item;\n                } else if ($open_brace_depth\
    \ === 1 && $itemLength > 1) {\n                    $inside_parens[] = $item;\n\
    \                }\n            }\n        }\n    }\n    foreach ($open_braces\
    \ as $open_brace) {\n        $close_brace = array_pop($inside_parens);\n     \
    \   if ($close_brace !== '') {\n            $result[] = $open_brace;\n       \
    \     $open_brace_depth--;\n        }\n    }\n    if ($open_brace_depth !== 0)\
    \ {\n        throw new \\InvalidArgumentException(\"unclosed brace: ' {$paren_string}'\
    \ on line {$line}\");\n    }\n    return $result;\n}\n", "    $group_stack = array();\n\
    \    $output = '';\n    $num_stack = count($paren_string);\n    for($x = 0; $x\
    \ < $num_stack; $x++) {\n        $char = $paren_string[$x];\n        if($char\
    \ != '(' && $char != ')') {\n            if(($paren_string[$x - 1] == '(' && $char\
    \ == ' ') || ($paren_string[$x + 1] == '(' && $char == ' ')) {\n             \
    \   $group_stack[] = $char;\n            } else {\n                $output .=\
    \ $char;\n                $last = array_pop($group_stack);\n                if(!empty($group_stack))\
    \ {\n                    $output .= array_pop($group_stack);\n               \
    \ }\n                $output .= $last;\n            }\n        } else {\n    \
    \        $output .= $char;\n            $last = array_pop($group_stack);\n   \
    \         if(!empty($group_stack)) {\n                $output .= array_pop($group_stack);\n\
    \            }\n            $output .= $last;\n            $group_stack[] = $char;\n\
    \        }\n    }\n    return $output;\n}\n", "    $open_braces = [\n        '(',\n\
    \        '{',\n        '[',\n        '<',\n        '<<',\n        '<=',\n    \
    \    '>=',\n        '>=',\n        '!=>',\n        '!=',\n        '<=>',\n   \
    \     '&',\n        '|',\n        '^',\n        '!=',\n        '===',\n      \
    \  '!==',\n        '==',\n        '!=',\n        '!=',\n        '&&',\n      \
    \  '||',\n        '|',\n        '^',\n        '>>',\n        '<<=',\n        '>=',\n\
    \        '<=',\n        '->',\n        '++',\n        '--',\n    ];\n\n    $closed_braces\
    \ = [\n        '}',\n        ']',\n        ']>',\n        '}',\n        '}>',\n\
    \        ']',\n        '}',\n        '}',\n        '{',\n        '{>',\n     \
    \   '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n\
    \        '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n     \
    \   '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n\
    \        '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n    \
    \    '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n\
    \        '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n    \
    \    '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n\
    \        '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n     \
    \   '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n\
    \        '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n    \
    \    '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n\
    \        '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n    \
    \    '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n        '{>',\n\
    \        '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n     \
    \   '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n        '{',\n\
    \        '{>',\n        '}',\n        '{',\n        '{>',\n        '}',\n    \
    \    '{',\n        '{>',\n        '}',\n        '{", "    $paren_count = 0; //\
    \ Count of currently opened parenthesis\n    $paren_stack = []; // Stack of currently\
    \ opened parenthesis\n    $paren_stack_count = 0; // Count of opened parenthesis\
    \ stack\n    $paren_opened = false; // Whether any parenthesis is currently opened\n\
    \n    // Iterate through each character in the string\n    foreach(str_split($paren_string)\
    \ as $char) {\n        // If current character is one of the parenthesis characters,\
    \ push it to paren_stack\n        if($paren_opened === false && ($char === '('\
    \ || $char === '[' || $char === '{' || $char === '<')) {\n            $paren_stack[$paren_stack_count++]\
    \ = $char;\n        }\n        // If current character is not one of the parenthesis\
    \ characters, pop one character off the paren_stack\n        elseif($char ===\
    \ ')' || $char === ']' || $char === '}' || $char === '>') {\n            while(isset($paren_stack[$paren_stack_count--])\
    \ && $paren_stack[$paren_stack_count] === '(') {\n                unset($paren_stack[$paren_stack_count--]);\n\
    \            }\n        }\n        // If current character is the closing brace\
    \ for the first parenthesis in the stack\n        elseif($paren_opened === true\
    \ && $paren_stack[$paren_stack_count] === '(' && $char === '{') {\n          \
    \  $paren_stack_count--;\n        }\n        // If current character is the opening\
    \ brace for the first parenthesis in the stack\n        elseif($paren_opened ===\
    \ true && $paren_stack[$paren_stack_count] === '[' && $char === '<') {\n     \
    \       $paren_stack_count--;\n        }\n        // If current character is the\
    \ opening brace for the first parenthesis in the stack\n        elseif($paren_opened\
    \ === true && $paren_stack[$paren_stack_count] === '{' && $char === '{') {\n \
    \           $paren_stack_count--;\n        }\n        // If current character\
    \ is the opening brace for the first parenthesis in the stack\n        elseif($paren_opened\
    \ === true && $paren_stack[$paren_stack_count] === '<' && $char === '<') {\n \
    \           $paren_stack_count--;\n        }\n        // If current character\
    \ is one of the parenthesis characters, push it to paren_stack\n        elseif($paren_opened\
    \ === false && $char === ')' || $char === ']' || $char === '}' || $char === '>')\
    \ {\n            $paren_stack[$paren_stack_count++] = $char;\n        }\n    \
    \    // If current character is not one of the parenthesis character", "  $open_paren\
    \ = [];\n  $close_paren = [];\n  $paren_stack = [];\n  $paren_string = trim($paren_string);\n\
    \  $paren_string = preg_replace('/(^\\s+)|(\\s+$)/', '', $paren_string);\n  while\
    \ ($paren_string) {\n    if ($paren_string[0] === '(') {\n      $open_paren[]\
    \ = $paren_string;\n      $paren_string = substr($paren_string, 1);\n    } else\
    \ {\n      if ($paren_string[0] === '(') {\n        if (empty($paren_stack)) {\n\
    \          throw new Exception('Parentheses not balanced');\n        }\n     \
    \   if ($paren_stack[$paren_stack->length - 1] !== '(') {\n          throw new\
    \ Exception('Parentheses not nested');\n        }\n        $paren_string = substr($paren_string,\
    \ 1);\n        $paren_stack[] = $paren_string;\n      } elseif ($paren_string[0]\
    \ === ')') {\n        if (empty($paren_stack)) {\n          throw new Exception('Parentheses\
    \ not balanced');\n        }\n        if (!empty($paren_stack[$paren_stack->length\
    \ - 1])) {\n          throw new Exception('Parentheses not nested');\n       \
    \ }\n        $close_paren[] = $paren_string;\n        $paren_string = substr($paren_string,\
    \ 1);\n        unset($paren_stack[$paren_stack->length - 1]);\n      } else {\n\
    \        $paren_stack[] = $paren_string;\n        $paren_string = substr($paren_string,\
    \ 1);\n      }\n    }\n  }\n  if (empty($paren_stack)) {\n    return [];\n  }\n\
    \  return $open_paren;\n}\n", "    $paren_groups = preg_split(\"/\\\\)\\s(?![^\\\
    \\\\s]*\\\\s)|\\\\\\s/\", $paren_string);\n    $paren_groups = array_filter($paren_groups);\n\
    \    return $paren_groups;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks you!\
    \ Your code works perfectly, and now I understand how it works.\n<|/ c |>\n<|\
    \ c |>\nPlease note that your code will also split strings that begin with `(`,\
    \ such as `(a (b)(c)` or `((b))`. Not sure if this is desired behavior.\n<|/ c\
    \ |>\n<| c |>\nYes, that is exactly what I need.  Do you know of a way to detect\
    \ these cases and handle them separately?\n<|/ c |>\n<| c |>\nThe function `separate_paren_groups`\
    \ will handle that as long as it is run after removing the spaces surrounding\
    \ the parens by using `preg_replace`.\n<|/ c |>\n<| c |>\nAh yes, you were right\
    \ about that!  Thanks again.\n<|/ c |>\n<| a dscore=0 tags=php,parentheses,string,regex\
    \ |>\nHere's another solution:\n<code>\n$paren_string = '((( ( ) ( )) ( ))( ))(\
    \ ))((( ( ) ( )) ( ))';\n\n$paren_string = preg_replace('/\\s+/', ' ', $paren_string);\n\
    $paren_string = preg_replace('/\\s*\\(\\s*/', '(', $paren_string);\n$paren_string\
    \ = preg_replace('/\\)\\s*/', ')', $paren_string);\n\n$paren_string = preg_replace('/((?=\\\
    ()|(?<=\\))\\s))/', '|', $paren_string);\n\n$paren_string = str_replace('(|)',\
    \ '', $paren_string);\n$paren_string = str_replace('|)', ')', $paren_string);\n\
    $paren_string = str_replace('(|)', '|', $paren_string);\n\n$paren_string = preg_replace('/\\\
    |+/', ')', $paren_string);\n\necho $paren_string;\n</code>\nThe idea is to replace\
    \ all spaces, parens and spaces before and after the parens with \"|\". We then\
    \ remove these from $paren_string.\n<|/ a |>\n<| c |>\nI really like this one.\
    \  I didn't know about lookahead/lookbehind until now.  Thank you!\n<|/ c |>\n\
    <| a tags=php,parentheses,string,regex |>\nThis is how I did it (I used some ",
  "    $parens = preg_split('/(\\([^\\(\\)]+\\))/', $paren_string);\n    $results\
    \ = [];\n    for ($i = 0; $i < count($parens); $i++) {\n        $results[] = $parens[$i];\n\
    \    }\n    return $results;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
