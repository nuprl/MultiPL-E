name: HumanEval_44_change_base
language: php
prompt: "<?php\n// Change numerical base of input number x to base.\n// return string\
  \ representation after the conversion.\n// base numbers are less than 10.\n// >>>\
  \ change_base(8, 3)\n// '22'\n// >>> change_base(8, 2)\n// '1000'\n// >>> change_base(7,\
  \ 2)\n// '111'\nfunction change_base($x, $base) {\n"
tests: "function candidate(...$args) {\n    return change_base(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(8, 3) !== \"22\") { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(9, 3) !== \"100\") { throw new Exception(\"Test\
  \ failed!\"); }\n    if (candidate(234, 2) !== \"11101010\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(16, 2) !== \"10000\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(8, 2) !== \"1000\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(7, 2) !== \"111\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(2, 3) !== \"2\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(3, 4) !== \"3\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(4, 5) !== \"4\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(5, 6) !== \"5\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(6, 7) !== \"6\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(7, 8) !== \"7\") { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["  $base = (int)$base;\n  $sign = $x < (0)?'':'-';\n  $x *= $base;\n\
    \  $str = str_pad($x, $base, '0', STR_PAD_LEFT);\n  return $sign . $str;\n}\n\
    </code>\n<|/ a tags=php,hex,binary |>\n<| c |>\nthis solution does not work for\
    \ numbers > 255 when base is greater than 16 (e.g `0xFFFFFFFFFFFFF`)\n<|/ c |>\n\
    <| c |>\nThe question is about \"hex\", not \"base16\". It's a limitation of PHP\
    \ or the underlying system for \"hex\" numbers. See http://en.wikipedia.org/wiki/Hexadecimal\
    \ and http://en.wikipedia.org/wiki/Binary_numeral_system\n<|/ c |>\n<| a dscore=1\
    \ |>\nFor base up to 10, use base_convert() function.\nFor base up to 16, use\
    \ dechex() function. \nFor base up to 25, use sprintf() function. \nFor base up\
    \ to 26, use printf() function. \nFor base up to 10, use sprintf() function. \n\
    For base up to 16, use sprintf() function. \nFor base up to 26, use sprintf()\
    \ function. \nFor base up to 32, use sprintf() function. \nFor base up to 64,\
    \ use sprintf() function. \nFor base up to 256, use sprintf() function. \nFor\
    \ base up to 16384, use sprintf() function. \nFor base up to 65536, use sprintf()\
    \ function. \nFor base up to 262144, use sprintf() function. \nFor base up to\
    \ 1048576, use sprintf() function. \nFor base up to 16777216, use sprintf() function.\
    \ \nFor base up to 33554431, use sprintf() function. \nFor base up to 1073741823,\
    \ use sprintf() function. \nFor base up to 2147483647, use sprintf() function.\
    \ \nFor base up to 4294967295, use sprintf() function. \nFor base up to 1099511627775,\
    \ use sprintf() function. \nFor base up to 2199023255552, use sprintf() function.\
    \ \nFor base up to 4503599627370496, use sprintf() function. \nFor base up to\
    \ 17592186044416154, use sprintf() function. \nFor base up to 34359738368, use\
    \ sprintf() function. \nFor base up to 34359738368, use sprintf() function. \n\
    For base up to 5368709120, use sprintf() function. \nFor base up to 1073741823\
    \ and beyond, use sprintf() function. \nFor base up to 2147483647 and beyond,\
    \ use sprintf() function. \nFor base ", "    $x = abs($x); // Make positive number.\n\
    \    $base = (int) $base; // Make base.\n    if ($x < 0 || $base < 0 || $base\
    \ >= 10) {\n        return ''; // Return empty string.\n    }\n    if ($x == 0)\
    \ {\n        return ''; // Return empty string.\n    }\n    if ($x == 1) {\n \
    \       return chr($base); // Return just one character.\n    }\n    $digit =\
    \ 0;\n    $base2 = $base ** 2;\n    while (true) {\n        $x = floor($x / $base);\n\
    \        $digit++;\n        if ($x % $base == 0) {\n            return chr($digit\
    \ * $base) + change_base($x, $base2);\n        }\n    }\n}\n", "    $digits =\
    \ strlen($x) > $base ? strlen($x) - $base : 1;\n    if ($digits == 0) {\n    \
    \    return $x;\n    }\n    $base = (int) $base;\n    $mod = pow(10, $base);\n\
    \    return floor($x * $mod) / $mod;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=number-formatting,php\
    \ |>\nThis is my solution (not perfect for negative numbers)\n<code>", "  return\
    \ str_pad(base_convert($x, 10, $base), $base, '0', STR_PAD_LEFT);\n}\n</code>\n\
    <|/ a tags=php,base,number-systems,decimal dscore=3 |>\n<| c |>\nThis works great,\
    \ but `str_pad()` is not supported in all versions of PHP. https://php.net/manual/en/function.str-pad.php\n\
    <|/ c |>\n<| c |>\nWhat if I want to make it base 32?\n<|/ c |>\n<| a tags=php,base,number-systems,decimal\
    \ dscore=2 |>\nHere is a solution that works with the biggest base that PHP supports.\n\
    <code>\n<?php\n$a = '0';\n$b = '10';\n$c = '100';\n$d = '1000';\n$e = '10000';\n\
    $f = '100000';\n$g = '1000000';\n$h = '10000000';\n$i = '100000000';\n$j = '1000000000';\n\
    $k = '10000000000';\n$l = '100000000000';\n$m = '1000000000000';\n$n = '10000000000000';\n\
    $o = '100000000000000';\n$p = '1000000000000000';\n$q = '10000000000000000';\n\
    $r = '100000000000000000';\n$s = '1000000000000000000';\n$t = '10000000000000000000';\n\
    $u = '100000000000000000000';\n$v = '1000000000000000000000';\n$w = '10000000000000000000000';\n\
    $x = '100000000000000000000000';\n$y = '1000000000000000000000000';\n$z = '10000000000000000000000000';\n\
    $A = '100000000000000000000000000';\n$B = '1000000000000000000000000000';\n$C\
    \ = '10000000000000000000000000000';\n$D = '100000000000000000000000000000';\n\
    $E = '1000000000000000000000000000000';\n$F = '10000000000000000000000000000000';\n\
    $G = '100000000000000000000000000000000';\n$H = '1000000000000000000000000000000000';\n\
    $I = '100000000000000000000000000000000000';\n$J = '1000000000000000000000000000000000000';\n\
    $K = '10000000000000000000000000000000000000';\n$L = '100000000000000000000000000000000000000';\n\
    $M = '1000000000000000000000000000000000000000';\n$N = '10000000000000000000000000000000000000000';\n\
    $O = '100000000000000000000000000000000000000000';\n$P = ' 100000000000000000000000000000000000000000';\n\
    $Q = '1000000000000000000000000000000000000000000000000';\n$R = '10000000000000000000000000000000000000000000000000';\n\
    $S = '10000000000000000000000000000000000000000000000000';\n$T", "    $x = intval($x);\n\
    \    $base = intval($base);\n    if ($base == 0) {\n        $numeral = 0;\n  \
    \  } else {\n        $numeral = base_convert($x, 10, $base);\n    }\n    $numeral\
    \ = base_convert($numeral, 10, $base);\n    return $numeral;\n}", "  if ($x <\
    \ 10) {\n    $x = \"0\".$x;\n  }\n  $tmp = substr($x, 1, strlen($x) - 1);\n  $tmp\
    \ = (int)($tmp / $base);\n  $res = \"\";\n  while ($tmp >= 10) {\n    $tmp -=\
    \ 10;\n    $res .= \"0\";\n  }\n  $res .= $tmp;\n  return $res;\n}\n", "  if ($base\
    \ < 2 || $base > 10) {\n    die('Wrong base.');\n  }\n  if ($x > 0) {\n    $s\
    \ = \"\";\n    while ($x > 1) {\n      $x = floor($x / $base);\n      $base *=\
    \ 10;\n      $s .= $x;\n    }\n    return $s;\n  }\n  if ($x < 0) {\n    $s =\
    \ \"\";\n    while ($x < -1) {\n      $x = floor($x * $base);\n      $base *=\
    \ 10;\n      $s .= $x;\n    }\n    return $s;\n  }\n  if ($base) {\n    return\
    \ str_repeat($base, $x);\n  }\n  return $x;\n}", "    $x = $x + 0; // convert\
    \ numerical string to int.\n    $base = intval($base);\n    if ($base < 1 || $base\
    \ > 36) {\n        throw new InvalidArgumentException(\n            \"Base must\
    \ be between 1 and 36 (inclusive).\");\n    }\n    if ($x > 0) {\n        $x =\
    \ '1'.$x; // add zeros to front of string\n    }\n    $r = $x; // the result string\n\
    \    while ($base > 0) {\n        $r = $x.((ord($r) - ord('A') + $base) % $base);\
    \ // convert char value to ascii value.\n        $base = ($base - intval($base));\
    \ // remove value from base to convert to next higher base.\n    }\n    return\
    \ $r;\n}\n", "  if ($base > strlen($x)) {\n    return $x;\n  }\n  $sign = ($x\
    \ == '-') ? '-' : '';\n  $digits = strlen($x) - strrpos($x, '1') + 1;\n  if ($digits\
    \ > strlen($base)) {\n    return $sign . $base;\n  }\n  $y = intdiv($x, $base);\n\
    \  if ($y === 0 && $x == '-') {\n    $digits = strlen($base);\n  } else {\n  \
    \  $digits = strlen($y);\n  }\n  return $sign . str_pad($digits, $base, '0', STR_PAD_LEFT);\n\
    }\n", "  $bases = [\n    '10' => '000',\n    '11' => '001',\n    '12' => '010',\n\
    \    '13' => '011',\n    '14' => '100',\n    '15' => '101',\n    '16' => '110',\n\
    \    '17' => '111',\n  ];\n  // Ensure that base is valid\n  if (array_key_exists($base,\
    \ $bases)) {\n    // Convert number to string\n    $x = base_convert($x, $base,\
    \ strlen($bases[$base]));\n    // Convert the number back to a number\n    $x\
    \ = base_convert($x, $base, -strlen($bases[$base]));\n  }\n  return $x;\n}", " \
    \ $new_x = '';\n  $digits = strlen($x) - 1;\n  $base_index = $digits;\n  for ($i\
    \ = 0; $digits > $i; ++$i) {\n    $new_x += $x[($digits - $i) * -1];\n  }\n  if\
    \ ($base_index > 0) {\n    $new_x += base_pow($base, $base_index);\n  }\n  return\
    \ $new_x;\n}\n", "  $x = $x / ($base - 1); // Convert from base 10 to base ($base\
    \ < 10)\n  $res = '';\n  while ($x) { // Convert to lower case.\n    $res = $res\
    \ + ($x % $base);\n    $x = floor($x / $base);\n  }\n  return $res;\n}\n\n$n =\
    \ \"0\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"\
    11\";\n$n = $n . \"01\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\"\
    ;\n$n = $n . \"01\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n\
    $n = $n . \"01\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n\
    \ = $n . \"00\";\n$n = $n . \"00\";\n$n = $n . \"00\";\n$n = $", "    $r = \"\"\
    ;\n    if ($x < 10) {\n        $r = $x;\n    } else {\n        if ($base < 10)\
    \ {\n            $r = change_base($x / $base, 10) * $base;\n        } else {\n\
    \            $r = change_base($x % $base, 10) * $base;\n        }\n    }\n   \
    \ return $r;\n}\n", "    $result = '';\n    $negative = false;\n\n    if ($x <\
    \ 0) {\n        $negative = true;\n        $x = abs($x);\n    }\n\n    $base =\
    \ int($base);\n\n    do {\n        if ($x > 0) {\n            $result = $result\
    \ . base_convert($x % $base, $base, $base) . $base;\n        }\n        $x = intval($x\
    \ / $base);\n        $base = $base * 10;\n    } while ($base > 10);\n\n    if\
    \ ($negative) {\n        $result = '-' . $result;\n    }\n\n    return $result;\n\
    }\n", "    $str = strval($x);\n    if (strlen($str) < $base) {\n        $str =\
    \ '0'; // Ensure the string is at least as long as the base.\n        while (strlen($str)\
    \ < $base) {\n            $str = '0'.$str; // Ensure the string is at least as\
    \ long as the base.\n        }\n    }\n    return $str;\n}\n</code>\n<|/ a dscore=0\
    \ tags=php |>\n<| c |>\nI already tried this, but I think it can only change numbers\
    \ in the hundreds, not in the tens, because in other posts they changed it to\
    \ hundreds. I thought about using regex but I do not have much experience with\
    \ it yet.\n<|/ c |>\n<| c |>\nI updated the answer to show how to do it in both\
    \ bases.\n<|/ c |>\n<| c |>\nI tried it, but it only works when the number is\
    \ in the tenths of the hundreds, and when it is the hundreds it is too late, i\
    \ think i will just use if statements\n<|/ c |>\n<| c |>\nThe first two numbers\
    \ are in the tens, and it still didn't change it when I changed it to base 10\n\
    <|/ c |>\n<| c |>\nIt should be fine now, I tested it before I posted it.\n<|/\
    \ c |>\n<| a |>\nYou should be able to do it with sprintf (PHP Docs).  \n<code>\n\
    $x = 1;\necho sprintf(\"%010d\", $x); // Outputs 0000000001\n</code>\nThe %010d\
    \ will pad the number with leading zeros up to 10 characters, zero-padding the\
    \ digits you don't want to be padded.  \nIf it's always just 10 digits, then sprintf\
    \ will probably be more efficient than a regular expression since it only has\
    \ to parse the string once.\n<|/ a tags=php dscore=0 |>\n<| a tags=php dscore=0\
    \ |>\nTry to use PHP's str_replace function, here's a very basic example:\n<code>\n\
    $string = \"00071112223\";\n\n$newString = str_replace(array('0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9'), '', $string);\n\necho $newString;\n</code>\n\
    And here is an example using str_replace to change numbers in both bases:\n<code>\n\
    $string = \"00071112223\";\n$newString = str_replace(array('0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9'), '', $string);\n\n$newString2 = str_replace(array('0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9'), '', $newString);", "  if ($x <\
    \ 10) {\n    if ($base > 36 || $base < 2) return 'Invalid base';\n    $x = $x\
    \ - 9;\n  }\n  $r = intval($x / $base);\n  if ($r % $base == 0) $r .= $base;\n\
    \  return $r;\n}", "  return base_convert($x, 10, $base);\n}\n", "  if($base <\
    \ 2) {\n    throw new InvalidArgumentException('Base must be less than 10.');\n\
    \  }\n  if($base > strlen($x)) {\n    throw new InvalidArgumentException('Base\
    \ must be greater than or equal to length of x.');\n  }\n  $result = '';\n  while(strlen($x)\
    \ > 0) {\n    $mod = $x % $base;\n    $result = ($mod == 0) ? ($result . $mod)\
    \ : (($mod == 1) ? $result . '0' : $result . $mod . $base);\n    $x = floor($x\
    \ / $base);\n  }\n  return $result;\n}\n", "    $newBase = array('1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9', '10');\n    $baseLen = strlen($base);\n    $newBase\
    \ = array_reverse($newBase);\n    $x = $x - $base;\n    $x = $x % $baseLen;\n\
    \    $baseLen = strlen($newBase);\n    $digits = array();\n    foreach (str_split($newBase)\
    \ as $digit) {\n        $digits[] = $digit;\n    }\n    $digits = array_reverse($digits);\n\
    \    return $newBase[$x] . implode('', array_slice($digits, 0, $baseLen));\n}\n",
  "\tif ($x < 0 || $x >  10) {\n\t\treturn \"Invalid input: Base must be between 0\
    \ and 10.\";\n\t}\n\tif ($base < 2 || $base >  10) {\n\t\treturn \"Invalid input:\
    \ Base must be between 2 and 10.\";\n\t}\n\t$x = $x % $base;\n\treturn str_pad($x,\
    \ $base, \"0\", STR_PAD_LEFT);\n}\n", "    $x *= $base;\n    $x = intval($x);\n\
    \    return ($x == 0 || $x != 1) && ($x != $base || $x != ($x * $base)) ? \"$x\"\
    \ : '0';\n}\n", "  $bases = [1, 10, 100, 1000, 10000, 100000, 1000000];\n  $bases[$base]\
    \ = 10;\n  return ($x != 0) && ($x < $bases[$base]) ? str_pad(base_convert($x,\
    \ 10, $bases[$base]), $base, '0') : '';\n}", "\t$str = '';\n\twhile ($x > 0){\n\
    \t\t$mod = ($x % $base);\n\t\t$str = $base == 10 ? $mod : $bases[$mod].$str;\n\
    \t\t$x = floor($x / $base);\n\t}\n\treturn $str;\n}\n", "  $x = floor($x);\n \
    \ $digits = $x - $base;\n  if ($digits >= 0) {\n    $digits = $digits;\n  } else\
    \ {\n    $digits = $digits * -1;\n  }\n  $base10 = base_convert($digits, 10, $base);\n\
    \  return $base10;\n}", "\t$x = $x - 0;\n\t$base = strlen($base);\n\tif ($x ==\
    \ 0) return '0';\n\tif ($x == -1) return '-1';\n\t$ret = '';\n\twhile ($x > 0)\
    \ {\n\t\t$mod = $x % $base;\n\t\t$x = floor($x / $base);\n\t\tif ($mod == 0) $ret\
    \ = $base;\n\t\t$ret = $base.$ret.(isset($mod) ? $mod : '');\n\t}\n\treturn $ret;\n\
    }\n", "\t$a = intval($x);\n\t$b = intval($base);\n\t$sign = $a < 0 ? -1 : 1;\n\
    \tif ($a < $b / 2) {\n\t\treturn ($sign === 1) ? '' : 0;\n\t} else {\n\t\t$y =\
    \ intval($b / $a);\n\t\treturn ($sign === 1) ? $y . base_convert($x, $y, 10, $base)\
    \ : base_convert($x, $y, 10, $base);\n\t}\n}\n", "  $result = 0;\n  for ($i =\
    \ strlen($x) - 1; $i >= 0; $i--)\n    $result *= $base;\n  $result += $x[$i];\n\
    \  return $result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis returns different\
    \ results than the OP wants. For example, `change_base(10, 2)` gives 10, not 100.\
    \ Also, it does a lot of unnecessary multiplications. For example, `change_base(100,\
    \ 10)` gives 1000, but OP says \"return string representation after the conversion\"\
    . As it happens, the OP's example is even easier since it only needs to apply\
    \ the first digit.\n<|/ c |>\n<| c |>\nI believe it's because of the base calculation.\
    \ It just keeps the number as base, but returns it with a different base base.\
    \ Think of it as decimal base conversion. And the OP doesn't want decimal base,\
    \ he just wants to convert it back. Maybe I misunderstood the question?\n<|/ c\
    \ |>\n<| c |>\nYes, I think I may have misunderstood the question. My apologies.\
    \ I also believe the OP is looking for decimal base conversion. With base 3, `change_base(100,2)`\
    \ would give `11,001`, but OP wants `100,001`. With base 10, `change_base(100,\
    \ 10)` would give `1,000,000` but OP wants `1,000,00`.\n<|/ c |>\n<| c |>\nThank\
    \ you so much for taking the time to test this. I got it working on my own after\
    \ all. I was wondering if your method was more efficient than the previous ones\
    \ though? Also, I'm curious how you came up with this? I'm just learning PHP so\
    \ I'm trying to understand everything I can about it.\n<|/ c |>\n<| c |>\nI wrote\
    \ my own base conversion method in PHP after watching some tutorials on it. It's\
    \ a very simple algorithm. I've been trying to find a source to explain it, but\
    \ I haven't seen anything yet. I just wrote my own base conversion method. I'll\
    \ post the source here soon. I'll just leave the original method here in case\
    \ anyone needs it.\n<|/ c |>\n<| a tags=base,php,numbers |>\nAnother approach\
    \ that uses native functions:\n<code>\n<?php\n", "  // This code handles negative\
    \ numbers and zeroes\n  if ($x < 0) {\n    return \"-\" . change_base(-$x, $base);\n\
    \  } elseif ($x == 0) {\n    return \"0\";\n  }\n\n  // We need to handle large\
    \ numbers. These aren't that important\n  // because they take up more space,\
    \ but they do waste memory.\n  $base10digits = array('0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9');\n  $base26digits = array('A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z');\n  if ($base > count($base10digits)) {\n    // If\
    \ we try to get too many digits, we just give up on big numbers.\n    return \"\
    \";\n  }\n  $digits = str_split($x, $base);\n  foreach ($digits as $key => $digit)\
    \ {\n    $digits[$key] = $base10digits[$digit];\n  }\n  return implode('', $digits);\n\
    }\n", "    return ($x % $base) + 1;\n}", "\t$r = array();\n\twhile (strlen($x)\
    \ > 0) {\n\t\t$r = str_split($x);\n\t\t$r[$base-1]++;\n\t\t$x = '';\n\t\tforeach\
    \ ($r as $v) {\n\t\t\tif ($v) {\n\t\t\t\t$x .= $v;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ implode('', $r);\n}\n", "  $r = $x;\n  $digits = str_split($x);\n  $i = 0;\n\
    \  while ($i < count($digits)) {\n    $r = (($r << $base) + $digits[$i++]) % ($base\
    \ ** strlen($digits) - 1);\n  }\n  return $r;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=php |>\nThe most flexible way I have found is the following:\n<code>\n\
    class NumberHelper {\n\n    /**\n     * int\n     */\n    private $value;\n\n\
    \    /**\n     * int\n     */\n    private $base;\n\n    /**\n     * NumberHelper\n\
    \     */\n    public function __construct($value, $base) {\n        if (! is_int($value))\
    \ {\n            throw new \\InvalidArgumentException('First argument must be\
    \ an integer.');\n        }\n        if (! is_int($base)) {\n            throw\
    \ new \\InvalidArgumentException('Second argument must be an integer.');\n   \
    \     }\n        if ($base < 0) {\n            throw new \\InvalidArgumentException('Second\
    \ argument must be greater than 0.');\n        }\n        $this->value = $value;\n\
    \        $this->base = $base;\n    }\n\n    /**\n     * int\n     */\n    public\
    \ function getValue() {\n        return $this->value;\n    }\n\n    /**\n    \
    \ * int\n     */\n    public function getBase() {\n        return $this->base;\n\
    \    }\n\n    /**\n     * $value\n     * $base\n     * NumberHelper\n     */\n\
    \    public static function fromValueAndBase($value, $base) {\n        return\
    \ new self($value, $base);\n    }\n\n    /**\n     * NumberHelper $numberHelper\n\
    \     * int\n     */\n    public function add(NumberHelper $numberHelper) {\n\
    \        $this->value += $numberHelper->getValue();\n        return $this;\n \
    \   }\n\n    /**\n     * NumberHelper $numberHelper\n     * int\n     */\n   \
    \ public function subtract(NumberHelper $numberHelper) {\n        $this->value\
    \ -= $numberHelper->getValue();\n        return $this;\n    }\n\n    /**\n   \
    \  * NumberHelper $numberHelper\n     * int\n     */\n    public function multiply(NumberHelper\
    \ $numberHelper) {\n        $this->value *= $numberHelper->getValue();\n     \
    \   return $this;\n    }\n\n    /**\n     * NumberHelper $numberHelper\n     *\
    \ int\n     */\n    public function divide(NumberHelper $numberHelper) {\n   \
    \     $this->value /= $numberHelper->getValue();\n        return $this;\n    }\n\
    \n    /**\n     * int\n     */\n    public function getValueAsString() {\n   \
    \     $value = $this->getValue();\n        if ($this->base == 1) {\n         \
    \   return $value;\n        }\n        $stringValue = (string)($value * pow(10,\
    \ $this->getBase()));\n        if ($this->base > 1) {\n            $stringValue\
    \ = \"$", "\t$base_digits = array_reverse(str_split($base));\n\t$result = '';\n\
    \tforeach (str_split($x) as $digit) {\n\t\t$digit = array_search($digit, $base_digits);\n\
    \t\tif ($digit !== false) {\n\t\t\t$result .= $base_digits[$digit];\n\t\t} else\
    \ {\n\t\t\t$result .= '0';\n\t\t}\n\t}\n\treturn $result;\n}\n", "    $x = $x\
    \ * 10 ** ($base - 1);\n    $div = floor($x);\n    return $div == $x ? $x : change_base($div,\
    \ $base);\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=php |>\nThe answer\
    \ from is great, but has one disadvantage.\nIf the number to be converted is negative\
    \ the result will be wrong. The solution is to check first the sign of the number.\
    \ Because the sign of the number is not known, it is impossible to tell if negative\
    \ or positive.\n<code>", "  $x = $x + (($base - 10) % $base);\n  return ($x <\
    \ 10) ? \"0$x\" : $x;\n}\n</code>\nThe function now works with any numerical base,\
    \ including base 10 and base 16:\n<code>\n>>> change_base(12, 4)\n'14'\n>>> change_base(16,\
    \ 10)\n'101'\n>>> change_base(17, 10)\n'1001'\n>>> change_base(19, 10)\n'110001'\n\
    </code>\nThe same function also works with strings:\n<code>\n>>> change_base(\"\
    12\", 4)\n'14'\n>>> change_base(\"16\", 10)\n'101'\n>>> change_base(\"17\", 10)\n\
    '1001'\n>>> change_base(\"19\", 10)\n'110001'\n</code>\n<|/ a tags=math,php,base,numbers\
    \ dscore=3 |>\n<| c |>\nGood function, but I find it fails when base = 10. It\
    \ returns (for base 16) \"101010\"\n<|/ c |>\n<| c |>\n- I've added a version\
    \ that works with bases 10, 10 and 16\n<|/ c |>\n<| c |>\nIt should be `($base>10)\
    \ ? \"0\" . $base : $base` otherwise you get 10 if base is 10 and 10 when base\
    \ is 16 for example.\n<|/ c |>\n<| c |>\n- I've changed the last line of the function\
    \ so now it works correctly with base 10, 10 and 16\n<|/ c |>\n<| c |>\nThank\
    \ you. I've tried your function with base=10 and it didn't work. I changed the\
    \ last line to `return ($x < 10) ? \"0\" . $base : $x;` and now it works. But\
    \ I'm not sure why.\n<|/ c |>\n<| a |>\nI ran into this same problem trying to\
    \ convert a base16 string to a decimal number.  I wanted a solution that didn't\
    \ involve string conversion.\nMy solution in PHP\n<code>", "  $digits = strval($x).$base;\n\
    \  return strval($digits);\n}", "\tif ($x == 0)\n\t\t$x = 1;\n\telse\n\t\t$x =\
    \ $x + '';\n\twhile ($x = strrev($x)) {\n\t\tif ($x{0})\n\t\t\t$base = intval($x{0});\n\
    \t}\n\tif ($base < 10)\n\t\t$base = 10 + $base;\n\tif ($base < 2 || $base > 10)\n\
    \t\t$base = 10;\n\tif ($base > strlen($x)) {\n\t\t$x = str_pad($x, strlen($x),\
    \ '0', STR_PAD_RIGHT);\n\t\tif ($x[0] === '-' && $x[strlen($x) - 1] === '-')\n\
    \t\t\t$x = substr($x, 1, strlen($x) - 2);\n\t\t$x = '0'.$x;\n\t}\n\treturn $x;\n\
    }\n", "    if ($x < 0 || $base < 10) {\n        throw new \\InvalidArgumentException('Invalid\
    \ base');\n    }\n\n    $remainder = 0;\n    $result = '';\n    while ($x >= $base)\
    \ {\n        $digit = $x % $base;\n        $remainder = $x / $base;\n        $result\
    \ = (string) $base . $remainder;\n        $x = $digit;\n    }\n    if ($x == 0)\
    \ {\n        $result = $base;\n        $remainder = 0;\n    } else {\n       \
    \ $result = (string) $base;\n    }\n\n    if ($remainder != 0) {\n        $result\
    \ .= str_pad('', $remainder, '0');\n    }\n    return $result;\n}\n</code>\n<|/\
    \ a dscore=3 tags=python,php,algorithm |>\n<| c |>\nNice solution. +1 from my\
    \ side.\n<|/ c |>\n<| c |>\nThe `0` padding doesn't seem to work when `$x` is\
    \ `0`.\n<|/ c |>\n<| c |>\nThe zero padding works fine. It's the second argument\
    \ to `str_pad()`; it's supposed to represent the number of characters _after_\
    \ the padding (so `str_pad('0123', 3, '0', STR_PAD_LEFT)` would return `'000123'`).\n\
    <|/ c |>\n<| c |>\nThank you for pointing that out. My previous comment was wrong.\n\
    <|/ c |>\n<| c |>\nThank you for sharing your code.  Your answer helped me find\
    \ my own solution so I thought I'd share it here for future reference.\n<|/ c\
    \ |>\n<| a tags=python,php,algorithm dscore=2 |>\nAfter doing some research I\
    \ got this working in Python:\n<code>\ndef change_base(number, base):\n    number\
    \ *= base\n    number_str = str(number)\n    base_digits = len(number_str) - len(number_str\
    \ % base)\n    result_str = ''.join((number_str // base, '0')[base_digits:])\n\
    \    return int(result_str)\n</code>\n<|/ a |>\n<| c |>\nNice! This works great.\
    \ Slightly modified so it works with negative numbers.\n<|/ c |>\n<| a tags=python,php,algorithm\
    \ |>\nAs the other posters have noted, Python's string functions are really handy.\
    \ Here is how I solved it in PHP:\n<code>", "    $n = intval($x);\n    if ($base\
    \ == 0) {\n        return $n;\n    }\n    $fs = strlen($base);\n    $s = str_pad($n,\
    \ $fs, '0', STR_PAD_LEFT);\n    $base = intval($base);\n    if ($n < $base) {\n\
    \        return $s;\n    }\n    return str_pad(base_convert($n, 10, $base), $fs,\
    \ '0', STR_PAD_LEFT);\n}\n", "    if ($x < 10) {\n        return $x;\n    }\n\
    \    if ($base > strlen($x) || $base < 2) {\n        return \"\";\n    }\n   \
    \ $r = \"\";\n    while ($base > 0) {\n        if ($base & 1) {\n            $r\
    \ .= $x % 10;\n        }\n        $x /= 10;\n        $base >>= 1;\n    }\n   \
    \ return $r;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nYou can use the following\
    \ approach to count the frequency of characters in your input string:\n<code>\n\
    <?php", "    $x = intval($x);\n    if ($x < 0)\n        $x += intval($base);\n\
    \    if ($x < 1)\n        return $x;\n    $base = $base - 1;\n    $basepow = pow(10,\
    \ $base);\n    $y = $x % $basepow;\n    return $basepow * ($y - floor($y / $basepow));\n\
    }\n", "  if ($x < 10)\n    return strval($x);\n  return strval(base_convert($x,\
    \ $base, 10));\n}\n</code>\nYou can then easily convert a number to any base using\
    \ the following formula:\n<code>\n$base_number = change_base(base_convert($input,\
    \ 10, $base), $base);\n</code>\nThis formula is rather complicated but it's very\
    \ fast. You'll notice that the algorithm performs significantly better than using\
    \ strval because it's much faster. For example, if you have input of '10', and\
    \ base of '1', the conversion will take only 1 millisecond vs. 1 second with strval.\
    \ You should also note that if you're only trying to convert numbers of base 10\
    \ to base 10 without any other modifications, strval is still faster because it\
    \ does just that.\n<|/ a |>\n<| c |>\nIt should be noted that this will only work\
    \ for base-10 numbers (unless you add some extra code to do base-16 numbers and\
    \ such). For base-10 to base-2 conversions, it will work. Just to add to this,\
    \ because I spent a long time trying to understand how the function works, this\
    \ is how you'd convert base-10 numbers to base 16:\n`echo strval(base_convert($input,\
    \ 10, 16));`\n<|/ c |>\n<| c |>\nYeah, for base-10 to base 2 conversions it will\
    \ work for integers less than 10. I'm not sure if this will work for anything\
    \ else but 10. I'll edit my answer to include a comment about that.\n<|/ c |>\n\
    <| c |>\nThis answer is misleading.  It doesn't work for base-16 either.  You\
    \ need to convert it to a number using base_convert first.\n<|/ c |>\n<| c |>\n\
    You are right I didn't think of that. I've edited my answer to include a function\
    \ that will work for both bases 10 and 16. Thanks\n<|/ c |>\n<| c |>\nThis does\
    \ not work for negative numbers. Negative numbers are not accepted as the base\
    \ for the conversion because they are represented as a sign followed by the absolute\
    \ value of a number. So if you try converting to base 8 using base_convert(-4,\
    \ 8, 8) the result will be 8 and not -8.\n<|/ c |>\n<| a dscore=5 tags=php,base-conversion,math\
    \ |>\nYou could use this:\n<code>", "  $digits = base_convert($x, 10, $base);\n\
    \  return $digits;\n}\n", "\t$digits = array(\n\t\t1 => '0', 2 => '01', 3 => '011',\
    \ 4 => '0123', 5 => '01234', 6 => '012345',\n\t\t7 => '0123456', 8 => '01234567',\
    \ 9 => '012345678', 10 => '0123456789'\n\t);\n\n\treturn implode('', str_split($x,\
    \ $base));\n}", "  $base = $base < 10 ? $base: 10;\n  return strval($x) / strval($base);\n\
    }", "    $base2 = $base;\n    if ($base > 0 && $x < 10)\n        return str_pad($x,\
    \ $base, '0', STR_PAD_LEFT);\n    $base10 = $x;\n    $base10_digits = $base10;\n\
    \    $base2_digits = '';\n    while (true) {\n        $base2_digits = base_convert($base10_digits,\
    \ 10, $base2);\n        if ($base2_digits == $base10_digits)\n            break;\n\
    \        $base10_digits = $base2_digits;\n    }\n    return $base2_digits;\n}\n",
  "\t$xstr = strval($x);\n\t\n\tfor ($i = strlen($xstr); $i > 0; $i--) {\n\t\t$xstr[$i]\
    \ = str_pad(decbin(ord($xstr[$i]){0}), $i, '0', STR_PAD_LEFT);\n\t}\n\t\n\t$xstr\
    \ = (strlen($xstr) == 1) ? str_pad($xstr, $base, '0', STR_PAD_LEFT) : $xstr;\n\
    \t\n\treturn $xstr;\n}\n", "  $res = '';\n  for ($i = strlen($x); $i; $i--) {\n\
    \    $res += $x{0} . $base;\n    $x /= $base;\n  }\n  return $res;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=javascript,php |>\nHere's an implementation that\
    \ works with any input number and any base:\n<code>", "    $n = $x / $base;\n\
    \    $remainder = $n % $base;\n    return $remainder == 0 ? $n : $x*$base+$remainder;\n\
    }\n", "    $string = $x; // get number as string\n    $result = \"\"; // create\
    \ result\n    $num_digits = strlen($string); // count number of digits\n    \n\
    \    \n    if ($num_digits > $base) { // if number of digits is longer than base\n\
    \        if ($num_digits < $base) { // if number of digits is smaller than base\n\
    \            if ($base == 10) { // if base is 10\n                if ($num_digits\
    \ == 1) { // if number of digits is 1, we add 1\n                    $result .=\
    \ '1';\n                } else { // if number of digits is not equal to 1\n  \
    \                  $string = $num_digits . $string; // concatenate number of digits\n\
    \                }\n            } else {\n                for ($i = 0; $i < $base;\
    \ $i++) { // loop through the base\n                    $x = floor($x / $base);\
    \ // get the remainder from the division operation\n                    $string\
    \ .= $x; // concatenate the remainder to the string\n                }\n     \
    \       }\n        } else { // if base is smaller than 10\n            $string\
    \ = $num_digits . $string; // concatenate number of digits\n        }\n    } elseif\
    \ ($num_digits < $base) { // if number of digits is smaller than base\n      \
    \  for ($i = 0; $i < $base; $i++) { // loop through the base\n            $x =\
    \ floor($x * $base); // get the remainder from the multiplication operation\n\
    \            $result .= $x; // concatenate the remainder to the result\n     \
    \   }\n    }\n    \n    return $result; // return the result\n}\n\n\n$num1 = intval($_POST['num1']);\n\
    $num2 = intval($_POST['num2']);\n$num3 = intval($_POST['num3']);\n\n$num1 = change_base($num1,\
    \ 3);\n$num2 = change_base($num2, 3);\n$num3 = change_base($num3, 3);\n\n\n$result\
    \ = ($num1 * $num2) * $num3;\n\n$result_str = number_format($result, 3, '.', '');\n\
    \n$result_str = str_replace(\",\", \"k\", $result_str);\n\necho '$result = '.$result.'\
    \ k\u20AC<br>';\n\necho $result_str;\n", "    return base_convert($x, 10, $base);\n\
    }\n", "    $str = str_pad('', $x, '0', STR_PAD_LEFT);\n    $str = substr($str,\
    \ 0, $base);\n    $str = substr($str, 0, $x - $base);\n    return $str;\n}\n",
  "  $base10 = '';\n  $remainder = 0;\n  while ($x >= base) {\n    $remainder = $x\
    \ / base;\n    $base10 = $remainder == 0\n      ? str_pad('', $base, '0')\n  \
    \    : str_pad($remainder, $base, '0');\n    $x = $x - $remainder * $base;\n \
    \ }\n  return str_pad($base10, $base, '0');\n}\n\n$string = '73167176531330624919225119674426574742355349194934969835203127745063262395783180169848018694788518438586156078911294949545950173795833195285320880551112540698747158523863050715693290963295227443043557668966489504452445231617318564030987111217223831136222989342338030813533627661428280644448664523874930358907296290491560440772390713810515859307960866701724271218839987979087922749219016997208880937766572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397536978179778461740649551492908625693219784686224828397224137565705605749026140797296865241453510047482166370484403199890008895243450658541227588666881164271714799244429282308634656748139191231628245861786645835912456652947654568284891288314260769004224219022671055626321111109370544217506941658960408071984038509624554443629812309878799272442849091888458015616609791913387549920052406368991256071760605886116467109405077541002256983155200055935729725716362695618826704282524836",
  "  return base_convert($x, $base, $base);\n}\n", "    if ($base > 10) {\n      \
    \  $base = str_pad('', $base, '0');\n    }\n    $x = (string) $x;\n    $base =\
    \ str_pad('', $base, '0');\n    $baseLength = strlen($base);\n    $xLength = strlen($x);\n\
    \    // $output = '';\n    if ($xLength == 0) {\n        return $base;\n    }\n\
    \    if ($base == '0' && $xLength < $baseLength) {\n        return $x;\n    }\n\
    \    if ($xLength < $baseLength) {\n        return change_base($x, $baseLength);\n\
    \    }\n    $digitBase = array_fill(0, $baseLength, '0');\n    $convertedBase\
    \ = array_fill(0, $baseLength, '0');\n    for ($i = 0; $i < $baseLength; ++$i)\
    \ {\n        $convertedBase[$i] = $digitBase[$baseLength - $i - 1];\n    }\n \
    \   while ($xLength >= $baseLength) {\n        $convertedBase[($baseLength - 1)]\
    \ = $digitBase[$baseLength - 1];\n        $xLength = strlen($x);\n    }\n    for\
    \ ($i = $xLength; $i < $baseLength; ++$i) {\n        $convertedBase[$i] = $digitBase[$baseLength\
    \ - $i - 1];\n    }\n    $output = implode('', $convertedBase);\n    return $output;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is the easiest way to do it. The\
    \ only thing I would add is that you might want to put an if statement around\
    \ the whole foreach loop so you don't get an infinate loop from invalid input.\n\
    <|/ c |>\n<| c |>\nThanks. I updated the answer. You could also return an empty\
    \ string for invalid input, instead of returning $x.\n<|/ c |>\n<| a |>\nI did\
    \ a function to convert base-10 number to base-2 (which is not as simple as base_converter\
    \ function with base >10). Hopefully it helps someone:\n<code>", "  return (string)\
    \ base_convert($x, $base, $base);\n}\n</code>\n<|/ a tags=php dscore=0 |>\n<|\
    \ a dscore=0 tags=php |>\n<code>\n<?php\n$x = 8;\n$n = array();\nfor($i = 1; $i\
    \ < 10; $i++)\n{\n    $n[] = intval($x/pow(10, $i));\n}\necho implode(',',$n);\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\n<?php\n$x = 8; // $x = 8; $x = 8\n$n = [];\n\
    for($i = 1; $i < 10; $i++)\n{\n    $n[] = intval($x / pow(10, $i));\n}\n\necho\
    \ implode(',',$n);", "    $str = strval($x);\n    $str = preg_replace('/0*(\\\
    d+)(\\D)/', '$\\\\1\\\\2', $str);\n    return $str == $x ? '0' : (\n         \
    \   strlen($x) > strlen($str) ?\n                (strlen($x) - strlen($str) +\
    \ 1) : 0);\n}\n", "\tif ($x < 0)\n\t\treturn 0;\n\t$x = abs($x);\n\t$digits =\
    \ strlen($x);\n\t$x *= $base;\n\t$div = $x / $base;\n\t$mod = $x % $base;\n\t\
    $output = '';\n\twhile ($digits > 0) {\n\t\t$output .= ($div % 10).$mod;\n\t\t\
    $div = $div / 10;\n\t\t$digits--;\n\t\t$mod *= $base;\n\t}\n\treturn $output;\n\
    }\n", "\t$xstr = (string) $x;\n\tif (is_numeric($x) && is_numeric($base)) {\n\t\
    \t$xbase = intval($xstr);\n\t\t$xint = (int) $x;\n\t\t$xstr = ($xint / $base)\
    \ * $base;\n\t\t$xstr = (string) $xstr;\n\t\treturn $xstr;\n\t} else {\n\t\treturn\
    \ $xstr;\n\t}\n}\n", "    $base = $base < 10 ? str_pad($base, 2, '0', STR_PAD_LEFT)\
    \ : $base;\n    $base2 = (int) $base;\n    $res = '';\n    while ($x >= $base)\
    \ {\n        $res .= $x % $base2;\n        $x = floor($x / $base2);\n    }\n \
    \   return $res .= $x;\n}\n", "    $x = $x - ($x % $base);\n    $x = $x + ($base\
    \ * (int) log10($x) + 1);\n    return $x;\n}\n", "    $x = intval($x);\n    if\
    \ ($x < 10) {\n        $xs = strval($x);\n        $tens = strval($x);\n      \
    \  $tens_pos = strpos($xs, $tens);\n        $x = strlen($xs);\n    }\n    if ($base\
    \ < 2 || $base > 10) {\n        return \"No base $base in change function\";\n\
    \    }\n    if ($base == 2 && ($x % 2 == 0)) {\n        return $xs;\n    }\n \
    \   $bases = array(\"10\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"\
    8\", \"9\", \"11\");\n    $xs = $xs;\n    do {\n        $result = $xs . strval($x\
    \ / $base);\n        $x = $x % $base;\n        $xs = str_replace($result, $xs[$tens_pos\
    \ + $x], $xs);\n        $xs = str_replace($xs[$tens_pos + $x], $tens, $xs);\n\
    \    } while ($x != 0);\n    return $xs;\n}\n", "  if ($x < 10) {\n    return\
    \ $x; // less than 10.\n  }\n  $sign = ($x<0)?'-':'';\n  $digits = str_split($x,\
    \ $base);\n  return $sign . str_repeat('0', $base) . str_pad($digits, $base, '0',\
    \ STR_PAD_LEFT);\n}\n", "  $digits = strlen($x);\n  $result = \"\";\n  for ($i\
    \ = 0; $i < $digits; $i++) {\n    $result = $result . ($x{$i} >= $base\n     \
    \ ? ($x{$i} - $base)\n      : ($x{$i} - $base) * $base);\n  }\n  return $result;\n\
    }\n</code>\n<|/ a tags=decimal,php,base,binary |>\n<| c |>\nWhy would you use\
    \ `intval` with your base 2? It seems unnecessary.\n<|/ c |>\n<| c |>\nIf you\
    \ don't specify any base, it uses the default (base 10). Thus, intval() doesn't\
    \ make sense in this case. However, the other bases (2, 8, 16) also use base 10\
    \ internally, so intval() makes sense here.\n<|/ c |>\n<| c |>\nThis works for\
    \ me, but I needed to use $base = 2; for it to work properly in my code. Thanks.\n\
    <|/ c |>\n<| a tags=decimal,php,base,binary |>\n<code>", "    if ($x < 10) {\n\
    \        return $x;\n    }\n\n    // $x is larger than base 10.\n    // Find the\
    \ first $x digit with remainder 1.\n    // If the number is even, add 1 to the\
    \ base until the number is odd.\n    // If the number is odd, subtract 1 from\
    \ the base until the number is even.\n    $baseLen = strlen($base);\n    while\
    \ ($x > 0) {\n        // Calculate remainder after adding $x to base.\n      \
    \  $remainder = $x % $base;\n        if ($remainder == 0) {\n            // $x\
    \ is even.\n            // Add 1 to base.\n            $baseLen += 1;\n      \
    \  } else if ($remainder == 1) {\n            // $x is odd.\n            // Subtract\
    \ 1 from base.\n            $baseLen -= 1;\n        }\n\n        // Calculate\
    \ next digit.\n        $x = floor($x / $base);\n    }\n\n    // Return result\
    \ with leading zeros\n    return str_pad('', $baseLen, '0');\n}\n", "  $x_base\
    \ = 16;\n  while ($x_base != $base) {\n    $x = ($x - (($x % $base) + $base))\
    \ % $base;\n    $x_base--;\n  }\n  return $x;\n}\n\n$a = 1;", "    $newbase =\
    \ 10;\n    do {\n        $newbase = intval($x / $base);\n        $x -= $newbase\
    \ * $base;\n    } while (!($x == 0));\n    return $newbase;\n}", "  $str = strval($x);\
    \ // Convert the number to string.\n  $n = strlen($str); // Get the length of\
    \ the string.\n  $base = $base; // Store the base.\n\n  for ($i = 0; $i < $n;\
    \ $i++) { // Loop from the end to the beginning.\n    if ($str[$i] >= '0' && $str[$i]\
    \ <= '9') { // If it is not a digit.\n      $str[$i] = $str[$i] - $base; // Calculate\
    \ the new digit.\n      if ($str[$i] < 0) { // If the new digit is less than zero.\n\
    \        $str[$i] += 10; // Subtract the base.\n      }\n    } // End of if statement.\n\
    \  } // End of for statement.\n\n  return $str; // Return the resulting string.\n\
    }\n", "  $x = floor($x / $base);\n  $digits = str_pad('', $base, '0', STR_PAD_LEFT);\n\
    \  $digits[$x] = chr($base);\n  return implode('', $digits);\n}\n", "  $r = $x;\n\
    \  while ($x>0 && $x%$base==0) { $x/=$base; $r+=$base; }\n  return $r;\n}\n",
  "  $result = \"\";\n  while ($x >= $base) {\n    $result .= $x % $base;\n    $x\
    \ = floor($x / $base);\n  }\n  return $result . $x;\n}\n</code>\n<|/ a tags=php\
    \ |>\n<| a tags=php |>\nThe code below uses the pow() function which returns the\
    \ value of a number raised to a power. With the pow() function you can compute\
    \ integer powers and it does that correctly for both positive and negative numbers.\n\
    <code>\n<?php\n\n$base = 8; //The base number must be less than or equal to 10.\n\
    \n$result = pow($base, $number);\n\necho \"The result of raising $number to the\
    \ power of $base is $result\";\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIf you're\
    \ looking to perform this calculation, you should use PHP Math Functions\n<code>\n\
    <?php\necho pow($number);\n</code>\n<|/ a tags=php dscore=1 |>\n<| c |>\nThis\
    \ answer needs more information. Can you give some explanation as to why `pow()`\
    \ is the way to go?\n<|/ c |>\n<| a |>\nThis should help you out.\n<code>\n<?php\n\
    $number = 8;\n$base = 3;\n$output = $number * pow($base,$number);\necho $output;",
  "    $digits = str_split($x);\n    $result = \"\";\n    $power = 1;\n    foreach\
    \ ($digits as $digit) {\n        if ($digit < $base) {\n            $result .=\
    \ $digit;\n        } else {\n            $result .= $digits[$digit - $base] *\
    \ $power;\n            $power *= $base;\n        }\n    }\n    return $result;\n\
    }", "\tswitch ($base) {\n\t\tcase 2:\n\t\t\t$x_div_base = 2;\n\t\t\tbreak;\n\t\
    \tcase 4:\n\t\t\t$x_div_base = 3;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\t$x_div_base\
    \ = 4;\n\t\t\tbreak;\n\t}\n\t\n\treturn ($x * $x_div_base);\n}", "    $str = strval($x);\n\
    \    $base = strval($base);\n    if ($base == 10) {\n        $str = $x != 0 ?\
    \ '' . $str : '0';\n        return $str;\n    } elseif ($base > strlen($str))\
    \ {\n        $str = '0';\n    }\n\n    $strlen = strlen($str);\n    if ($base\
    \ < strlen($str) - 1) {\n        $base = $strlen;\n    }\n\n    if ($base > strlen($str)\
    \ - 1) {\n        $base = $strlen;\n    }\n\n    $output = '';\n    for ($i =\
    \ $base; $i >= 0; $i--) {\n        $strlen -= $i;\n        $output .= $str[$strlen];\n\
    \    }\n\n    return $output;\n}", "    if ($x < 10)\n        return $x;\n   \
    \ elseif ($base < 10)\n        return $base * $x + 1;\n    else\n        return\
    \ change_base($x / $base, $base);\n}", "    if ($base < 10)\n        return $x;\n\
    \    $digits = base_convert($x, 10, $base);\n    if ($digits < 0)\n        return\
    \ '';\n    return base_convert($digits, $base, $base);\n}", "    if ($base < 0\
    \ || $base > 10) {\n        $base = 10;\n    }\n\n    if ($x < 0) {\n        return\
    \ null;\n    }\n\n    $div = intval($x / $base);\n\n    return $div * $base;\n\
    }\n", "    $x = abs($x);\n    $base = abs($base);\n    $sign = ($x<0) ? '-' :\
    \ '+';\n    if ($x < 10) {\n        $sign = '';\n    }\n    $x = $sign + str_pad(decbin($x),32,0,STR_PAD_LEFT);\n\
    \    $x = ltrim($x,\"0\");\n    $x = preg_replace('/[^'.$base.'\\s]/','',$x);\n\
    \    if ($x=='') return '';\n    if ($x{0}==0) return $sign;\n    $l = strlen($x);\n\
    \    if ($base > strlen($x)) {\n        return $sign;\n    }\n    if ($x == $x{1})\
    \ return $sign;\n    $out = '';\n    for ($i = 2; $i <= strlen($x); $i++) {\n\
    \        $out .= substr($x,$i-1,1).($i%$base);\n    }\n    return $out;\n}\n</code>\n\
    <|/ a tags=php,number-theory,base,decimal |>\n<| a |>\nI used this one since it\
    \ worked fine for me\n<code>\n<?php\n$base = pow(10, 6);\n$num = 10000;\n$num\
    \ = str_pad(base_convert($num, 10, $base), 6, \"0\", STR_PAD_LEFT);\necho \"<small>$num</small>\"\
    ;\n</code>\n<|/ a tags=php,number-theory,base,decimal dscore=2 |>\n<| c |>\nThis\
    \ answer helped me a lot. Thanks\n<|/ c |>\n<| a dscore=1 |>\nI have found a way\
    \ and I hope this will help others also.\n<code>\n$base = $_POST['base'];\n$num\
    \ = $_POST['num'];\n\n$num = str_pad(base_convert($num, 10, $base), 6, \"0\",\
    \ STR_PAD_LEFT);\n\necho \"<small>$num</small>\";\n</code>\n<|/ a tags=php,number-theory,base,decimal\
    \ |>\n<| c |>\nThis worked like a charm for me. Thank you very much!\n<|/ c |>\n\
    <| c |>\nThis is the only thing that worked for me. Thank you.\n<|/ c |>\n<| a\
    \ dscore=0 tags=php,number-theory,base,decimal |>\nI found this page while searching\
    \ for the same answer. Here's the full solution:\n<code>\n<?php", "\tif ($x <\
    \ 10) {\n\t\t$str = str_pad(decbin($x), $base, '0', STR_PAD_LEFT);\n\t\treturn\
    \ $str;\n\t} else {\n\t\t$str = str_pad(decbin($x / $base), $base, '0', STR_PAD_LEFT);\n\
    \t\treturn $str;\n\t}\n}", "\t$x_str = str_pad($x, $base, STR_PAD_LEFT);\n\t$x_int\
    \ = strtr($x_str, '0123456789', '');\n\t$x = $x_int;\n\t$x_str2 = str_pad($x,\
    \ $base, STR_PAD_LEFT);\n\t$x_int2 = strtr($x_str2, '0123456789', '');\n\treturn\
    \ $x_int2;\n}\n", "\t$r = bcdiv($x, $base);\n\treturn $x != $r ? change_base($r,\
    \ $base) : $r;\n}\n", "  return base_convert($x, 10, $base);\n}\n", "\t$b = [1,\
    \ 10, 100, 1000, 1000000, 1000000000];\n\t$o = array_shift($b);\n\t$x = intval($x);\n\
    \tdo {\n\t\t$x = $x % $o + intval($x / $o) * $o + $b;\n\t} while ($x >= $o);\n\
    \treturn (string)$x;\n}", "    if ($x < 0 || $x > 9) return '';\n    return base_convert($x,\
    \ 10, $base);\n}", "    $y = $x + (10 ** ($base - 1));\n    return str_pad($y,\
    \ $base, str_pad('', $base - $x - 1, $base));\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I love this solution. Can I suggest an improvement, though? It currently doesn't\
    \ handle negative numbers. What about negative exponents?\n<|/ c |>\n<| c |>\n\
    Just add an `if` statement before `$y = $x + (10 ** ($base - 1));` to check for\
    \ negatives. `if($x < 0){ $y = \"-\" . $y;}`\n<|/ c |>\n<| a tags=base,php |>\n\
    <code>", "    if ($x == 0) return '0';\n    $x = abs($x); // Make sure $x is positive.\n\
    \    $base = abs($base); // Make sure $base is positive.\n    if ($base > strlen($x))\
    \ $base = strlen($x); // If base is greater than string length,\n    if ($base\
    \ == 0) $base = 10; // Just in case $x is all zeros.\n    $y = $x;\n    $z = $base;\n\
    \    $t = '';\n    while (1) {\n        if ($z != 0) {\n            $y = $y *\
    \ $z;\n            $t = $t . str_repeat('0', $base) . $y;\n        }\n       \
    \ if ($z != 1) $z = floor($z / 10);\n        if ($z == 0) break;\n        $z =\
    \ str_pad($z, $base, '0', STR_PAD_RIGHT);\n    }\n    return $t;\n}", "    $digits\
    \ = intval($x / $base);\n    return $digits * $base;\n}\n", "\tif ($x == 0) return\
    \ 0;\n\t$str = '';\n\twhile ($x > 0) {\n\t\t$str = chr($x % $base) . $str;\n\t\
    \t$x = floor($x / $base);\n\t}\n\treturn $str;\n}", "    if ($base < 0 || $base\
    \ > 10) {\n        throw new InvalidArgumentException('Base must be between 0\
    \ and 10.');\n    }\n    $base = str_pad('', $base, '0', STR_PAD_LEFT);\n    $digits\
    \ = strpos($x, '.');\n    if ($digits === false) {\n        return $x . $base;\n\
    \    }\n    if ($digits === 0) {\n        return $base;\n    }\n    $tens = strlen($x)\
    \ - $digits - 1;\n    return substr($x, 0, $tens) . $base . substr($x, $tens +\
    \ 1);\n}\n", "  $x = $x * ($base ** abs(floor(log($base, 10))));\n  return ($x)\
    \ ? round($x) : \"\";\n}", "  $str = '';\n  $x_str = (string) $x;\n  if (is_int($base))\
    \ {\n    $base_str = (string) $base;\n    for ($i = 0, $count = strlen($x_str);\
    \ $i < $count; $i++) {\n      $digit = $x_str[$i];\n      // add additional digits\
    \ in $base as needed\n      // if $base is smaller than 10,\n      // add additional\
    \ digit zeros based on the value of $base\n      if ($i < $count - 1 && $digit\
    \ >= $base &&\n          $base_str < $base) {\n        $digit = '0' . $base_str\
    \ % $base;\n      }\n      $str .= $digit;\n      $base_str = ($base_str - $digit)\
    \ % $base;\n    }\n    return $str;\n  }\n}", "  $str = str_split($x);\n  foreach\
    \ ($str as &$i) {\n    $i = $base^$i;\n  }\n  return implode('', $str);\n}\n",
  "\tif ($base < 1 || $base > 10) {\n\t\tthrow new \\Exception(\"Base must be in range\
    \ of 1 to 10\");\n\t}\n\tif ($x < 0) {\n\t\treturn \"-\".change_base(-$x, $base);\n\
    \t}\n\tif ($x == 0) {\n\t\treturn \"0\";\n\t}\n\tif ($x < 1) {\n\t\treturn $x.$base;\n\
    \t}\n\t$base = 10 * $base;\n\t$number = floor($x / $base);\n\treturn $number.$base;\n\
    }", "  $x = $x * pow(2, $base - 1);\n  $r = floor($x);\n  $r = $r / pow(2, $base);\n\
    \  return $r;\n}\n</code>\nIf you want a faster version, then use decimal values\
    \ instead of integer values.\n<|/ a dscore=3 tags=biginteger,php |>\n<| c |>\n\
    This was my first thought, but for large numbers it doesn't work as expected.\
    \ For example change_base(121, 36) returns 1679875487041748000, while 121 decimal\
    \ = 15311 decimal.\n<|/ c |>\n<| c |>\nYes, the algorithm is wrong. Try [this\
    \ one](http://stackoverflow.com/questions/4292768/big-integer-library-in-php/7339900#7339900).\n\
    <|/ c |>\n<| a tags=biginteger,php dscore=3 |>\nYou can use the GMP extension.\n\
    <|/ a |>\n<| c |>\nCan you provide an example please?\n<|/ c |>\n<| c |>\n$a =\
    \ gmp_init(\"123\");\n$b = gmp_sub($a,gmp_init(100));\n<|/ c |>\n<| c |>\nTo use\
    \ GMP you have to install [gmp](http://www.php.net/manual/en/book.gmp.php).\n\
    <|/ c |>\n<| a |>\nThere is also a very simple library called BigInteger.\nYou\
    \ use it like this:\n<code>", "  $_x = abs($x);\n  $_factor = pow(10, $base);\n\
    \  return ($_x % $_factor == 0) ? sprintf('%d', $x/$_factor) : 'err';\n}", "\t\
    $base = abs($base);\n\tfor ($i = 1; $i < $base; ++$i) {\n\t\t$x = floor($x / $base)\
    \ * $base + $x;\n\t}\n\treturn $x;\n}\n", "    $x = intval($x);\n    $base = intval($base);\n\
    \    if ($base < 0 || $base > 10) {\n        // not between 0-10\n        return\
    \ 'Invalid base ' . $base;\n    }\n\n    if ($x < 0 || $x >= 10) {\n        //\
    \ not between 0-10\n        return 'Base must be between 0-10';\n    }\n\n   \
    \ if ($x == 0) {\n        // this case should never be reached, but anyway\n \
    \       return '0';\n    }\n\n    if ($base == 1) {\n        // base-1 case\n\
    \        $y = 1;\n    } else {\n        $y = 10 ** ($base - 1);\n    }\n\n   \
    \ return ($x * $y) / $y;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis should\
    \ be the accepted answer. It is the most accurate, fastest, and most readable\
    \ solution. Thank you!\n<|/ c |>\n<| a dscore=2 |>\nTry this :\n<code>\n<?php\n\
    \    $x = 98;\n    $x = base_convert($x, 10, 2);\n    echo $x;", "  $base = (int)\
    \ $base;\n  if ($base < 2 || $base > 10) {\n    trigger_error(\"Base must be between\
    \ 2 and 10\", E_USER_WARNING);\n    return \"\";\n  }\n  $x = str_pad($x, strlen($x),\
    \ '0', STR_PAD_RIGHT);\n  $x = base_convert($x, 10, $base);\n  return base_convert($x,\
    \ $base, $base);\n}\n\n$a = change_base(8, 3);\n$b = change_base(7, 2);\n\n$output\
    \ = ($a . $b);", "  $x = $x * $base;\n  $div = $x - (int) $x;\n  $mod = ($div\
    \ - 1) % $base;\n  return $div ? \"$mod$base\" : \"0\";\n}\n", "    $digits =\
    \ array();\n    $basestr = '';\n    while ($x >= 10) {\n        $digits[] = $x\
    \ % 10;\n        $x = floor($x / 10);\n    }\n    array_unshift($digits, $x);\n\
    \    while (count($digits) !== $base) {\n        $digits[] = '0';\n    }\n   \
    \ return implode('', $digits);\n}\n", "  $str = strval($x);\n  $base = intval($base);\n\
    \  if ($base > strlen($str)) {\n    $base %= strlen($str);\n  }\n  $mod = strlen($str)\
    \ - $base;\n  return $str[($mod < 0) ? $mod + strlen($str) : 0;\n}\n", "  $digits\
    \ = $x = strval($x);\n  if ($base > strlen($digits)) return \"Invalid base $base.\"\
    ;\n  $result = '';\n  while ($digits) {\n    $remainder = 10 ** ($base - strlen($digits));\n\
    \    $result = $digits[$remainder == 10 ? 0 : $remainder] + $result;\n    $digits\
    \ = substr($digits, 0, $base);\n    $base--;\n  }\n  return $result;\n}\n$result=change_base(8,\
    \ 3);\necho $result;", "  $sign = $x < 0 ? -1 : 1;\n  $base = str_pad('', $base,\
    \ '0', STR_PAD_LEFT);\n  if (strlen($x) < $base) {\n    return $sign * $base;\n\
    \  }\n  $y = intdiv($x, $base);\n  $z = $sign * $y;\n  $z = (string) $z;\n  $z\
    \ = str_pad($z, $base, '0', STR_PAD_LEFT);\n  return $z;\n}\n", "    $r = base_convert($x,\
    \ 10, $base);\n    $r = base_convert($r, 10, 10);\n    return $r;\n}\n", "   \
    \ if ($base < 1 || $base > 10) {\n        throw new \\InvalidArgumentException(\"\
    Base must be between 1 and 10\");\n    }\n    $x = $x * pow(10, $base - 1);\n\
    \    return $x;\n}\n", "  $base_str = '';\n  for ($i = 0; $i <= 9; $i++) {\n \
    \   if ($x % $base === 0) {\n      $base_str .= $i;\n    } else {\n      $base_str\
    \ .= $i == 10 ? $i : $base_str[0];\n    }\n  }\n  return $base_str;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nThe way I see it, there are two possible ways to answer this\
    \ question:\n\nYes, if the number is always going to be less than 10, you can\
    \ just keep dividing the number by 10 to get the individual digits, and then multiplying\
    \ by 10 the number of times you divided it by 10. This will give you the number\
    \ in reverse order. So, for example (81) = 2*10*10*10 = 120. \nNo, if the number\
    \ could be any number greater than 1, you would have to take the number and break\
    \ it down into its individual digits (like your example above). Then you would\
    \ have to reverse the order of each digit (so if the number was 8, the result\
    \ would be 100), and then combine them back together again (so if the number was\
    \ 80, the result would be 1000) to get a number that is in reverse order.\n\n\
    I personally would go with option #2. So for example, if you had the number 810,\
    \ you would have to break it down to 100 and 10. Then combine them back together\
    \ to get 10000.\n<|/ a tags=php,integer,string dscore=0 |>\n<| a tags=php,integer,string\
    \ |>\nIf you don't want to use string functions then:\n<code>\n$number = 32;\n\
    $digits = str_split($number);\n$new_digits = array_reverse($digits);\n$final_number\
    \ = implode('', $new_digits);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work for negative numbers, only positive.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\
    \    function getReverseOfNumber($num){\n        $num = (string)$num;\n      \
    \  $sum = 0;\n        for($i=0; $i<strlen($num); $i++){\n            $sum += $num[$i]*pow(10,(strlen($num)-$i-1));\n\
    \        }\n        return $sum;\n    }\n    echo getReverseOfNumber(32); // 1360\n\
    \    echo getReverseOfNumber(25); // 5", "    if ($base > 10) {\n        $base\
    \ = str_pad($base, strlen($x) + 1, '0', STR_PAD_LEFT);\n    }\n    return $x %\
    \ $base;\n}\n", "    return $x * pow($base, $base);\n}\n", "    if ($x < 10 &&\
    \ $base > 10) {\n        return $x;\n    }\n    $result = $x;\n    while ($base\
    \ > 0) {\n        $remainder = $result % $base;\n        $result = floor($result\
    \ / $base);\n        $result = $remainder * $base;\n    }\n    if ($result > 10)\
    \ {\n        $result = '0';\n    }\n    return $result;\n}\n", "  return $base\
    \ * $x;\n}\n</code>\n<|/ a dscore=0 tags=php,function |>\n<| a dscore=0 tags=php,function\
    \ |>\nTry this code:\n<code>", "    return implode('', array_map('base_convert',\
    \ $x, $base));\n}\n</code>\n<|/ a |>\n<| c |>\nHi Martin! This is exactly what\
    \ I was looking for, and it works perfectly. Thank you for sharing your code!\n\
    <|/ c |>\n<| a dscore=0 |>\nI recently came across this question, and found that\
    \ most of the code in the answers was not useful.\nI wanted something that would\
    \ not convert to a string or int/float, but would keep some information of the\
    \ original number type.\nI ended up making a class called 'number_wrapper'. The\
    \ only thing it does, is holding a reference to the original number, and a type\
    \ ('int', 'float', 'string'), in addition to a bunch of methods that just manipulate\
    \ the original number itself.\n<code>\n<?php\nnamespace App\\Core;\n\nclass number_wrapper\n\
    {\n    private $number;\n\n    public function __construct($number, $type, $precision\
    \ = null, $scale = null)\n    {\n        $this->number = $number;\n        $this->type\
    \ = $type;\n        $this->precision = $precision;\n        $this->scale = $scale;\n\
    \    }\n\n    public function __toString()\n    {\n        $value = $this->number->__toString();\n\
    \        $value = str_replace(',', '.', $value);\n\n        return $value;\n \
    \   }\n\n    public function __clone()\n    {\n        $clone = clone $this->number;\n\
    \        $clone->precision = $this->precision;\n        $clone->scale = $this->scale;\n\
    \        $clone->type = $this->type;\n\n        return $clone;\n    }\n\n    public\
    \ function __get($name)\n    {\n        switch ($name) {\n            case 'type':\n\
    \                return $this->type;\n            case 'precision':\n        \
    \        return $this->precision;\n            case 'scale':\n               \
    \ return $this->scale;\n        }\n        return $this->number->__get($name);\n\
    \    }\n\n    public function __set($name, $value)\n    {\n        switch ($name)\
    \ {\n            case 'type':\n                $this->type = $value;\n       \
    \         return;\n            case 'precision':\n                $this->precision\
    \ = $value;\n                return;\n            case 'scale':\n            \
    \    $this->scale = $value;\n                return;\n        }\n        return\
    \ $this->number->__set($name, $value);\n    }\n\n    public function __isset($name)\n\
    \    {\n        switch ($name) {\n            case 'type':\n                return\
    \ $this->type == $this->number->type;\n            case 'precision':\n       \
    \         return $this->precision == $this->number->precision;\n            case\
    \ 'scale':\n                return $this->scale == $this->number->scale;\n   \
    \     }\n        return $this->number->__isset($name);\n    }\n\n    public function\
    \ __unset($name)\n    {\n        switch ($name) {\n            case 'type':\n\
    \            case 'precision':\n", "  $x = $x * $base;\n  $y = $x;\n  $r = 1;\n\
    \  $base = 2; // set $base to largest base >= $base\n\n  while (true) {\n    if\
    \ ($x > 0) {\n      if ($x % $base == 0) {\n        $r = $r * $base;\n       \
    \ $x = floor($x / $base);\n      } else {\n        $x = floor($x / $base);\n \
    \       $r = $r + $base;\n      }\n    } else {\n      if ($y % $base == 0) {\n\
    \        $r = $r * $base;\n        $y = floor($y / $base);\n      } else {\n \
    \       $y = floor($y / $base);\n        $r = $r + $base;\n      }\n    }\n\n\
    \    if ($x == 0 || $y == 0 || $r > $base) {\n      return $r - 1;\n    }\n  }\n\
    }\n$val = \"3.141592653589793\";\n$nr = change_base($val, 10);\n$val2 = $val *\
    \ $nr;\necho round($val2, 2);", "  $sign = intval($x) < 0 ? '-' : '';\n  $x =\
    \ intval($x); //convert to integer\n  $base = intval($base); //convert to integer\n\
    \  if ($base > 2 || $base < 0)\n    return $sign;\n  $x_len = (strlen($x) + $base)\
    \ / $base;\n  if ($x_len > strlen($x))\n    $x_len = strlen($x); //if integer\
    \ is too long\n  $x = str_pad($x, $x_len, $base); //pad number to specified base\n\
    \  $result = \"\";\n  for ($i = 0; $i < strlen($x); $i++)\n    $result .= $x{$i}\
    \ . base_digit($i, $base);\n  return $sign. $result;\n}\n", "  $digits = \"\"\
    ;\n  do {\n    $digits .= $x%$base;\n    $x = floor($x/$base);\n  } while($x >\
    \ 0);\n  return $digits;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nThis is by far\
    \ the best solution, IMO. +1\n<|/ c |>\n<| a tags=php |>\nI believe this is what\
    \ you are looking for:\n<code>", "  $rexp = str_pad('', $base, '0');\n  $res =\
    \ '';\n  while ($x >= $base) {\n    $rexp = str_pad($rexp, $base, '0');\n    $res\
    \ = base_convert($x - $base, $base, $res);\n    $x = floor($x / $base);\n  }\n\
    \  return str_pad($rexp, $base, $res);\n}\n", "  if ($x < 10) {\n    return $x;\n\
    \  }\n  return base_convert($x, 10, $base);\n}", "  $r = \"\";\n  while($x >=\
    \ $base) {\n    $r++;\n    $x /= $base;\n  }\n  return $r;\n}\n</code>\n<|/ a\
    \ tags=php,algorithm |>\n<| c |>\nThis doesn't handle negative numbers properly.\n\
    <|/ c |>\n<| c |>\nI added a fix for negative numbers above, although it still\
    \ doesn't handle fractional numbers, see my comment on the question itself.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe simplest and most intuitive way is to just write\
    \ it out as string using str_pad to pad the numbers with leading 0's.\n<code>\n\
    $pad = str_pad($number, $digits, '0', STR_PAD_LEFT);\n</code>\nExample\n<code>\n\
    $number = 123456789;\n$digits = 2;\n$pad = str_pad($number, $digits, '0', STR_PAD_LEFT);\n\
    </code>\nOutput\n<code>\n$pad = 000123456789\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| c |>\nNot sure why this was downvoted... it solves the problem the best\
    \ way possible... also not really a duplicate question at all...\n<|/ c |>\n<|\
    \ c |>\nI didn't downvote, though I agree that it should be mentioned in the comment\
    \ that this doesn't handle negative numbers as well.\n<|/ c |>\n<| c |>\nIt's\
    \ actually a pretty good answer, because it handles the case where you don't have\
    \ enough digits to fill in the entire number that you want to fill in, and it\
    \ also doesn't require changing the base. The other answers also won't handle\
    \ the negative number case. My answer handles it and it's also a lot easier to\
    \ understand.\n<|/ c |>\n<| c |>\nYes, but your answer still doesn't handle fractional\
    \ numbers.\n<|/ c |>\n<| c |>\nAh yeah, I totally forgot that part, this answer\
    \ doesn't handle fractional numbers either :/.\n<|/ c |>\n<| a dscore=0 |>\nTo\
    \ convert from base 10 to base 16 (hexadecimal), use the following formula. This\
    \ formula can be easily adapted for any base, including base 16\n<code>\n$value\
    \ = 10 * pow(2, $base) - 10\n</code>\nExample: To convert from base 10 to base\
    \ 16, 10^16 = 10 * 2^16 - 10\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm\
    \ |>\nMy suggestion\n<code>\n$number = '111122223333444455555';\n$base = 16;\n\
    $padded = str", "    $xs = explode('.', $x);\n    $x1 = $xs[0];\n    $x2 = $xs[1];\n\
    \    $result = '';\n    if (is_numeric($x1)) {\n        if (is_numeric($x2)) {\n\
    \            $n1 = is_numeric($base) ? $base : base_convert($base, $x1, 10);\n\
    \            $n2 = is_numeric($base) ? $base : base_convert($base, $x2, 10);\n\
    \            $n1 = $n1 * pow(10, strlen($n2) - 1);\n            $result = $n1\
    \ + $n2;\n            $result = str_pad($result, strlen($n1), '0', STR_PAD_LEFT);\n\
    \        } else {\n            $result = $x1;\n        }\n    } elseif (is_numeric($x2))\
    \ {\n        if (is_numeric($x1)) {\n            $n1 = is_numeric($base) ? $base\
    \ : base_convert($base, $x1, 10);\n            $n2 = is_numeric($base) ? $base\
    \ : base_convert($base, $x2, 10);\n            $n1 = $n1 * pow(10, strlen($n2)\
    \ - 1);\n            $result = $n1 + $n2;\n            $result = str_pad($result,\
    \ strlen($n1), '0', STR_PAD_LEFT);\n        } else {\n            $result = $x2;\n\
    \        }\n    } elseif (is_numeric($base)) {\n        if (is_numeric($x1)) {\n\
    \            $n1 = is_numeric($base) ? $base : base_convert($base, $x1, 10);\n\
    \            $result = $n1 + $x2;\n            $result = str_pad($result, strlen($n1),\
    \ '0', STR_PAD_LEFT);\n        } else {\n            $result = $x2;\n        }\n\
    \    } else {\n        throw new Exception('Invalid input.');\n    }\n    return\
    \ $result;\n}\n", "  $base = 10 ** $base;\n  $factor = 1;\n  for ($i = 0, $y =\
    \ $x; $y >= 0; $x /= $base, ++$i, $y = $y / $base) {}\n  if ($i == $base) {\n\
    \    return $x;\n  }\n  return ($x - $y * $factor) / $base;\n}\n", '  $a = array(0,
    1, 1, 2, 8, 10, 11, 16, 21, 26, 36, 45, 55, 72, 88, 108, 131, 162, 194, 225, 258,
    278, 302, 313, 324, 346, 358, 372, 388, 402, 416, 429, 445, 469, 486, 502, 517,
    536, 554, 567, 574, 587, 604, 617, 629, 645, 660, 676, 692, 708, 725, 749, 764,
    788, 812, 825, 840, 856, 871, 888, 904, 919, 945, 966, 988, 1008, 1024, 1032,
    1047, 1062, 1077, 1094, 1110, 1126, 1142, 1158, 1173, 1188, 1213, 1230, 1256,
    1272, 1287, 1304, 1329, 1346, 1364, 1380, 1395, 1410, 1426, 1442, 1457, 1473,
    1489, 1504, 1519, 1535, 1550, 1566, 1573, 1589, 1605, 1620, 1636, 1651, 1667,
    1684, 1698, 1712, 1728, 1742, 1757, 1773, 1789, 1804, 1817, 1833, 1851, 1868,
    1885, 1900, 1916, 1931, 1945, 1960, 1975, 1990, 2005, 2012, 2017, 2028, 2042,
    2057, 2073, 2089, 2104, 2120, 2136, 2143, 2159, 2175, 2189, 2205, 2220, 2235,
    2250, 2265, 2280, 2295, 2310, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250,
    252, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268,
    269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284,
    285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300,
    301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316,
    317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332,
    333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 34', " \
    \   if ($base > 10) {\n        $base_string = str_repeat('0', $base);\n    } else\
    \ {\n        $base_string = '0';\n    }\n\n    $x = intval($x);\n    return ($x\
    \ * $base) + $base_string;\n}\n\n$number = '1560';\n\n$number = change_base($number,\
    \ 3);\necho $number . \"\\n\";\n$number = change_base($number, 2);\necho $number\
    \ . \"\\n\";\n$number = change_base($number, 1);\necho $number . \"\\n\";\n$number\
    \ = change_base($number, 0);\necho $number . \"\\n\";\n$number = change_base($number,\
    \ 5);\necho $number . \"\\n\";\n$number = change_base($number, 10);\necho $number\
    \ . \"\\n\";\n$number = change_base($number, 11);\necho $number . \"\\n\";\n$number\
    \ = change_base($number, 20);\necho $number . \"\\n\";\n$number = change_base($number,\
    \ 30);\necho $number . \"\\n\";\n$number = change_base($number, 40);\necho $number\
    \ . \"\\n\";\n$number = change_base($number, 50);\necho $number . \"\\n\";\n$number\
    \ = change_base($number, 60);\necho $number . \"\\n\";\n$number = change_base($number,\
    \ 70);\necho $number . \"\\n\";\n$number = change_base($number, 80);\necho $number\
    \ . \"\\n\";\n$number = change_base($number, 90);\necho $number . \"\\n\";", "\t\
    $x = $x * $base;\n\t$x = $x - floor($x);\n\treturn $x * pow(10, $base);\n}\n",
  "  $x = abs($x); // ignore sign\n  while ($x > 10) {\n    $x = floor($x/10) + ($x\
    \ > 0 ? 1 : 0); // add digit\n    $base++; // next base until 0\n  }\n  return\
    \ \"$base$x\";\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nVery helpful.  Thanks.\
    \  I actually used a slightly different variation on your approach.  I added a\
    \ loop to go through the numbers from one to the target and convert one at a time\
    \ using your function.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\n$number = 1;\n$base\
    \  = 2;\n", "\t$base = intval($base);\n\t$x = intval($x);\n\tif ($base > 10) {\n\
    \t\treturn false;\n\t}\n\tif ($base < 2 || $base > 36) {\n\t\treturn false;\n\t\
    }\n\t$digits = intval($x / $base);\n\t$rest = intval($x % $base);\n\treturn $x\
    \ * $base + $digits;\n}\n", "    $retval = \"\";\n    $remainder = $x;\n    while\
    \ ($remainder > 0) {\n        $retval .= $remainder % $base;\n        $remainder\
    \ = $remainder / $base;\n    }\n    return $retval;\n}\n", "\t$digits = str_split(base_convert($x,\
    \ $base, 10));\n\treturn implode('', $digits);\n}\n", "  $div = intval($x / $base);\n\
    \  return $div * $base;\n}", "\tif ($base > 9) die('base not supported (>10)');\n\
    \tif ($base == 0) return '0';\n\t$x_digits = $base;\n\t$x_str = str_pad(base_convert($x,\
    \ 10, $base), $x_digits, 0, STR_PAD_LEFT);\n\treturn $x_str;\n}\n", "\t\n\tif\
    \ ($x < 10) {\n\t\treturn $x;\n\t}\n\t\n\t$res = '';\n\t\n\twhile (1) {\n\t\t\
    $mod = $x % $base;\n\t\t$res = $base.$res;\n\t\tif ($mod == 0 || $x == 0) {\n\t\
    \t\tbreak;\n\t\t}\n\t\t$x = $x;\n\t\t$base = $base * 10;\n\t}\n\t\n\tif ($x ==\
    \ 0) {\n\t\treturn $res;\n\t}\n\t\n\treturn $res.$x;\n}\n", "    $div_base = intval($x\
    \ / $base);\n    $mod_base = $x % $base;\n    if ($div_base > 0) {\n        return\
    \ change_base($div_base, intval($base / $base)) . $mod_base;\n    } else {\n \
    \       return intval($base / $base) . $mod_base;\n    }\n}\n", "  return base_convert($x,\
    \ $base, 10);\n}\n", "  return intval(base_convert($x, 10, $base));\n}", "  $x\
    \ = $x * $base;\n  $x_rev = $x * $base;\n\n  $remainder = 0;\n\n  if ($x_rev <\
    \ $x) {\n    do {\n      $remainder = $x_rev % $base;\n    } while ($remainder\
    \ != 0 && $remainder != 1);\n\n    return $base == 10 ? $x : 10 * $x + $remainder;\n\
    \  } else {\n    do {\n      $remainder = $x % $base;\n    } while ($remainder\
    \ != 0 && $remainder != 1);\n\n    return $base == 10 ? $x_rev : 10 * $x_rev +\
    \ $remainder;\n  }\n}\n", "    if (!is_numeric($x)) {\n        $x = 0;\n    }\n\
    \    if (!is_numeric($base)) {\n        $base = 10;\n    }\n    if ($base < 2)\
    \ {\n        $base = pow(10, ceil(log($x, $base)));\n    }\n    $r = 1;\n    foreach\
    \ (str_split((string)$x) as $c) {\n        $r *= $base;\n        $r %= $base;\n\
    \        $r += $base;\n    }\n    return (int)$r;\n}\n", "  $n = bcdiv($x, $base,\
    \ 0);\n  $s = '';\n  while (strlen($n) > 3) {\n    $s = bcmod($n, $base) + $s;\n\
    \    $n = bcdiv($n, $base, 0);\n  }\n  return $s;\n}", "  $x = abs($x);\n  $y\
    \ = array();\n  do {\n    if ($x % $base == 0) {\n      $y[] = $x;\n      $x =\
    \ floor($x / $base);\n    } else {\n      $y[] = $base;\n      $x = $x - $base\
    \ * floor($x / $base);\n    }\n  } while ($x > 0);\n  return implode('', $y);\n\
    }\n</code>\n<|/ a tags=php,base-conversion |>\n<| c |>\nThis doesn't work when\
    \ given a negative number. For example `change_base(-11, 2)` returns `110` instead\
    \ of `-61`.\n<|/ c |>\n<| c |>\nI see. Added another solution that should work\
    \ with negative numbers.\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers,\
    \ for example `change_base(-11, 2)` returns `11` instead of `-11`.\n<|/ c |>\n\
    <| c |>\nThanks. I've fixed this bug and added another solution.\n<|/ c |>\n<|\
    \ c |>\nI tested this solution, and it works perfectly. The accepted answer is\
    \ buggy as it is now.\n<|/ c |>\n<| a dscore=5 |>\nA more simple solution with\
    \ no recursion and no string concatenation:\n<code>\n<?php\n", "    if ($x < 10)\
    \ {\n        return $x;\n    } else {\n        return base_convert($x, 10, $base);\n\
    \    }\n}\n", "  $base = intval($base);\n  // Handle negative numbers by multiplying\
    \ by base - 1.\n  if ($x < 0) {\n    $x = abs($x) * ($base - 1);\n  }\n  // Convert\
    \ to string.\n  $x = strval($x);\n  // Remove all characters that are not digits.\n\
    \  $x = preg_replace('~[^0-9]+~', '', $x);\n  // Trim trailing zeros.\n  $x =\
    \ ltrim($x, '0');\n  // Add padding back on left.\n  $x = '0'.$x;\n  // Convert\
    \ to numeric.\n  $x = intval($x);\n  // Return the number in base base (this could\
    \ also be done with strval()).\n  return $x;\n}\n", "    if ($base < 2) {\n  \
    \      return $x;\n    }\n    if ($base > strlen($x)-1) {\n        return $x;\n\
    \    }\n    $y = 1;\n    while ($y <= $base) {\n        $x = ($x*$y) % $base;\n\
    \        $y++;\n    }\n    return $x;\n}\n</code>\n<|/ a |>\n<| c |>\nYes, this\
    \ is the most elegant solution that I've seen in so many answers here.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nI believe this will be the simplest and most efficient\
    \ solution:\n<code>", "    $x= intval($x);\n    $base= intval($base);\n    if\
    \ ($x < 0 || $base < 0) {\n        return \"Error: negative values are not allowed\"\
    ;\n    }\n    while ($base) {\n        if ($x % $base === 0) {\n            return\
    \ $x;\n        }\n        $x= floor($x/$base);\n        $base--;\n    }\n    return\
    \ $x;\n}\n", "    $a = $x;\n    $b = 0;\n    if ($x < 0) {\n        $b = $base;\n\
    \        $x = -$x;\n    }\n    $r = 1;\n    while ($x >= $b) {\n        $r = $r\
    \ * $a + $b;\n        $a--;\n    }\n    return $r;\n}", "    if ($base < 1 ||\
    \ $base > 10) {\n        return false;\n    }\n    $sign = ($x < 0) ? '-' : '';\n\
    \    $x = abs($x);\n    $digits = '';\n    while ($x > 0) {\n        $digits .=\
    \ $x % $base;\n        $x = floor($x / $base);\n    }\n    return $sign + str_pad($digits,\
    \ strlen($digits), $base, '0', STR_PAD_LEFT);\n}\n", "  $num = intval($x);\n \
    \ $rest = intval($x % $base);\n  if ($rest > 0) {\n    return $num * $base + $rest;\n\
    \  } else {\n    return $num + $base;\n  }\n}\n", "  $_x = base_convert($x, 10,\
    \ $base);\n  return base_convert($_x, $base, $base);\n}", "    $str = strval($x);\n\
    \    $len = (strlen($str) - 1) * $base;\n    if ($len == 0) {\n        return\
    \ $str;\n    }\n    $power = strpos($str, '.');\n    if ($power > 0) {\n     \
    \   $len = strlen($str) - ($power + 1);\n    }\n    return round($x, $len) . '.'\
    \ . substr($str, $power, $base);\n}\n", "    $r = array();\n    while ($x >= $base)\
    \ {\n        $r[] = ($x % $base);\n        $x = floor($x / $base);\n    }\n  \
    \  $r[] = $x;\n    return implode('', $r);\n}\n\n/**\n * Prints the given number\
    \ using \"&bull\".\n * It may contain decimals and \"&bull;\".\n * It may also\
    \ contain \"&bull;\".\n * It doesn't print a space after the decimal.\n */", "\t\
    $str = base_convert($x, 10, $base);\n\t$str = str_pad($str, strlen($str), 0, STR_PAD_LEFT);\n\
    \treturn $str;\n}", "    if ($x < 10) {\n        $x = base_convert($x, 10, $base);\n\
    \    }\n    else {\n        $x = base_convert($x, 10, $base);\n    }\n    return\
    \ $x;\n}", "    if ($base < 10)\n        return $x;\n    return base_convert($x,\
    \ 10, $base);\n}\n", "    $base = intval($base);\n    $x = intval($x);\n    if\
    \ ($base > 10 || $base < 1) {\n        return false;\n    }\n    $x_digits = str_split($x);\n\
    \    $base = str_pad('', $base, '0', STR_PAD_LEFT);\n    $baseLen = strlen($base);\n\
    \    $res = '';\n    foreach ($x_digits as $x_digit) {\n        $x_digit = intval($x_digit);\n\
    \        $res .= $base[$x_digit % $baseLen];\n        $x_digit = (int) ($x_digit\
    \ / $baseLen);\n    }\n    return $res;\n}\n", "  $base10 = '';\n  $base1 = '';\n\
    \  $xstrlen = strlen($x);\n  for ($i = 0; $i < $xstrlen; $i++) {\n    $xc = substr($x,\
    \ $i, 1);\n    $xcval = base_convert($xc, $base10, 36);\n    $base10 = $xcval\
    \ . $base10;\n    if ($xc == '.') {\n      $base1 .= $base10;\n    }\n  }\n\n\
    \  return $base1;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=python,php,algorithm\
    \ |>\nThis should do it:\n<code>\ndef base_convert(num,base,length):\n    digits\
    \ = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    num = list(str(num))\n    result\
    \ = []\n    while num:\n        q, r = divmod(num[0], base)\n        result.append(digits[r])\n\
    \        num[0] = q\n    digits = ''.join(result)\n    return digits[:length]\n\
    \nprint base_convert(52, 11, 3)\n</code>\nOutput:\n<code>\nABC\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 tags=python,php,algorithm |>\nI took code from Nick's answer\
    \ and made it a little more robust (i.e. handles base conversions of numbers with\
    \ more than 36 digits, etc.)\n<code>\ndef base_convert(num,base,length):\n   \
    \ digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    num = list(str(num))\n\
    \    result = []\n    while num:\n        q, r = divmod(num[0], base)\n      \
    \  result.append(digits[r])\n        num[0] = q\n    if num[0] > 0:\n        result.reverse()\n\
    \    digits = ''.join(result)\n    return digits[:length]\n\nprint base_convert(1234567890,37,3)\n\
    </code>\n<|/ a |>\n<| c |>\nI tried to edit the code into the post, but it didn't\
    \ allow me to, so I created a new answer instead. Thanks for your help. I appreciate\
    \ it :-)\n<|/ c |>\n<| a dscore=1 |>\nI suggest you use base_convert($num, $from,\
    \ $to) function. \n<code>", "    $x = $x % $base;\n    return ($x == 0) ? 0 :\
    \ $base;\n}\n", "  $base = min(max((int)$x, 0), $base);\n  $x = $x % $base;\n\
    \  return str_pad($x, $base, \"0\", STR_PAD_LEFT);\n}\n", "    if ($base > 10)\n\
    \        return $x;\n    $digits = str_split($x, $base);\n    return implode('',\
    \ $digits);\n}\n</code>\n<|/ a dscore=5 tags=php,numbers |>\n<| c |>\nYup, this\
    \ is a great solution! Thanks!\n<|/ c |>\n<| c |>\nThis is a great solution. \
    \ It doesn't seem to be a standard function in PHP, so it might be worth mentioning\
    \ that this requires PHP >= 5.3.0. http://php.net/manual/en/function.number-format.php\n\
    <|/ c |>\n<| c |>\nI like that this uses `str_split`, but also that it gives you\
    \ control over the number of decimal places. [number_format()](http://php.net/manual/en/function.number-format.php)\
    \ doesn't allow you to control the number of decimal places.\n<|/ c |>\n<| c |>\n\
    This is an elegant solution and I love how simple it is. However, I'm a bit concerned\
    \ about using the built-in `number_format()` because it's not always available\
    \ (e.g. older versions of PHP). Is there any other way you know of to achieve\
    \ the desired output that doesn't involve the use of `number_format()`?\n<|/ c\
    \ |>\n<| c |>\n: I believe that PHP has had `number_format` since [PHP 5.1.1](http://php.net/releases/5_1_1.php)\
    \ (2001), and is not even supported on [PHP 5.1.4](http://php.net/releases/5_1_4.php)\
    \ (2007). You might want to add that to your answer.\n<|/ c |>\n<| a dscore=5\
    \ tags=php,numbers |>\nThe sprintf() function is the correct way to convert an\
    \ arbitrary base into any base.\n<code>\n$num = 987654321;\necho sprintf(\"%010d\"\
    , $num); // prints 98765432100\necho sprintf(\"%010d\", $num, 1); // prints 9876543210000\n\
    </code>\nSee sprintf() documentation for more info.\n<|/ a |>\n<| c |>\nThe question\
    \ is how to convert a number from base 10 to base 16. `sprintf` will convert from\
    \ base 10 to base 2. If you want to convert from base 16 to base 10, then you\
    \ need to use `bcscale`.\n<|/ c |>\n<| c |>\nI suppose you can always use [str_pad](http://www.php.net/manual/en/function.str-pad.php)\
    \ to pad to enough length for your base and then apply `bcscale()`\n<|/ c |>\n\
    <| c |>\n`", "  $base = int($base);\n  $y = pow(10, abs($base));\n  $new_base\
    \ = $base;\n  while ($x >= $y) {\n    $new_base *= 10;\n  }\n  $x = $x / $y;\n\
    \  $x = $x * $new_base;\n  if ($base < 0) {\n    $x = -$x;\n  }\n  $res = ltrim($x,\
    \ '0');\n  return $res;\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nYou can use the\
    \ GMP library:\n<code>\n<?php\n$x = \"1000\";\n$g = new GMP($x);\n$x->setPrecision(3);\n\
    echo $g->toPrecisionString();\n</code>\nwill output: 1.000.000\n<|/ a tags=php\
    \ |>\n<| c |>\nThe GMP library is amazing\n<|/ c |>\n<| a dscore=2 tags=php |>\n\
    This is how I do it:\n<code>", "    $digits = intval($x / $base);\n    $rest =\
    \ intval($x % $base);\n\n    return $digits . ($rest == 0 ? \"\" : \"\" . ($base\
    \ - $rest));\n}\n", "    $base = intval($base);\n    $digits = intval(log($x,\
    \ $base));\n    return $digits+$x*$base/pow(base, $digits);\n}", "    $x = str_pad($x,\
    \ $base, \"0\", STR_PAD_LEFT);\n    $x = str_pad($x, strlen($base), \"0\", STR_PAD_RIGHT);\n\
    \    return $x;\n}\n", "  $base10 = (int)$base;\n  if ($base10 < 2 || $base10\
    \ > 64) {\n    return NULL;\n  }\n  if ($base10 < 62) {\n    return chr($base10\
    \ + 64);\n  }\n  return ltrim(\n    strtoupper(\n      dechex(\n        ($base10\
    \ - ($base10 - 62) % ($base10 - 2))\n      )\n    ),\n    '0'\n  );\n}", "  $x\
    \ = abs($x);\n  $base = abs($base);\n  if ($x < 10) {\n    $out = '' . $x;\n \
    \ } else {\n    $out = '';\n    $exp = 10 - $base;\n    while ($exp > 0) {\n \
    \     $last = substr($out, -1);\n      if ($x % $base == 0) {\n        $out .=\
    \ $last;\n      }\n      $x = $x / $base;\n      $exp--;\n    }\n    $out .= $x;\n\
    \  }\n  return $out;\n}\n</code>\n<|/ a |>\n<| c |>\nThis answer would be a lot\
    \ more useful if it explained what it does and how it works. In its current form,\
    \ it looks like you're just dumping some code on us without really explaining\
    \ it.\n<|/ c |>\n<| c |>\nI added an explanation.\n<|/ c |>\n<| a tags=php,python,perl,math,javascript\
    \ |>\nThis is an example of a recursive function:\n<code>", "    $base = 10 **\
    \ $base;\n    if ($x == 0) {\n        return 0;\n    } elseif ($x < 0) {\n   \
    \     $base = -$base;\n        $x = abs($x);\n    }\n    return ($x * $base) /\
    \ $base;\n}\n", "    if ($base > 10) {\n        throw new \\InvalidArgumentException('Invalid\
    \ base ' . $base);\n    }\n    if ($base < 2) {\n        throw new \\InvalidArgumentException('Invalid\
    \ base ' . $base);\n    }\n\n    $base = pow(10, $base);\n    return $x * $base;\n\
    }\n", "  $x = abs($x);\n  $y = $base;\n  $xs = str_pad('', $x, '0', STR_PAD_LEFT);\n\
    \  $xss = substr($xs, strlen($xs) - $x);\n  $ans = \"\";\n  while ($xs > 0) {\n\
    \    $last = $x % $y;\n    $ans .= $ys[$last];\n    $x /= $y;\n    $xs = str_pad('',\
    \ $x, '0', STR_PAD_LEFT);\n    $xss = substr($xs, strlen($xs) - $x);\n  }\n  if\
    \ ($ans == \"\")\n    return $x;\n  else\n    return $ans;\n}\n", "  $y = $x;\n\
    \  while (true) {\n    $y = $y * $base;\n    if ($y == 0 || $y == $x) {\n    \
    \  return $x;\n    }\n  }\n}\n", "  $sign = ($x < 0) ? '-' : '';\n  $x = abs($x);\n\
    \  $digits = str_split(str_repeat('0', $base), $base);\n  for ($i = count($digits)\
    \ - 1; $i >= 0; $i--) {\n    $digits[$i] = ($x % $base) + $digits[$i];\n    $x\
    \ = floor($x / $base);\n  }\n  return $sign + implode('', $digits);\n}\n", " \
    \   if ($base > 10) return null;\n    if ($base == 0) return \"0\";\n    if ($x\
    \ <= 0) return null;\n    $xstr = strval($x);\n    $base = strval($base);\n  \
    \  $base = strval($base);\n    $l = 0;\n    $r = strlen($xstr) - 1;\n    while\
    \ ($r >= 0) {\n        $r = ($r + $base) % $base;\n        $l++;\n    }\n    $str\
    \ = $l;\n    for ($i = strlen($xstr) - 2; $i >= 0; $i--) {\n        $str = ($i\
    \ * $base) + $xstr[$i];\n    }\n    return $str;\n}", "\t$x = intval($x);\n\t\
    if ($base < 2 || $base > 10) {\n\t\tthrow new Exception('Base can only be a number\
    \ between 2 and 10');\n\t}\n\treturn (abs($x) < $base * abs($x - floor($x))) ?\
    \ ($x) : ((int) ($x / $base) * $base);\n}\n</code>\n<|/ a dscore=3 tags=php,binary,decimal\
    \ |>\n<| a dscore=2 |>\n<code>", "    if ($base < 2) {\n        return $x;\n \
    \   }\n    $sign = ($x > 0) ? '' : '-';\n    if ($x == 0 || $x == -0) {\n    \
    \    $result = '0';\n    } else if (is_infinite($x)) {\n        $result = $sign;\n\
    \        $x = -$x;\n    } else if (abs($x) == 1) {\n        $result = ($sign ==\
    \ '') ? '1' : ($sign == '-') ? '0' : '1';\n        $x = abs($x);\n    } else {\n\
    \        $result = '';\n    }\n    while (1) {\n        if ($x != 0) {\n     \
    \       $result = chr($x % $base) . $result;\n            $x = floor($x / $base);\n\
    \        } else {\n            break;\n        }\n    }\n    return $result;\n\
    }\n", "  if ($base < 2 || $base > 36) return $x;\n  $digits = strlen($x);\n  $sign\
    \ = $x[0] == '-' ? -1 : 1; // sign of x\n  $t = preg_match_all('~^([1-9]*)0+$~',\
    \ $x, $m);\n  $n = ($sign > 0 && $m[1][0][0]) ? $m[1][0][0] : -$m[1][0][0];\n\
    \  if ($n < 0) return $x;\n  $base = '0'.$base;\n  $r = substr($x, 1, $digits);\n\
    \  while ($n > 0) {\n    $r = bcmul($r, $base, $n);\n    $n -= strlen($base);\n\
    \  }\n  return $sign == -1 ? '-'.$r : $r;\n}\n</code>\n<|/ a dscore=1 tags=php,math\
    \ |>\n<| c |>\nIt's not clear what you are doing, but it seems that you're trying\
    \ to get an answer that doesn't exist at all.  You don't need a function to do\
    \ that.\n<|/ c |>\n<| c |>\nI appreciate the effort but you really shouldn't use\
    \ anything like this. It makes you reinvent the wheel and then you have no idea\
    \ why it's been done that way. Just because you're not going to do it doesn't\
    \ mean you shouldn't be asking. Even if you didn't think about it it's clear that\
    \ it's a bad idea to use this code.\n<|/ c |>\n<| c |>\n- I believe it's possible\
    \ to convert a number to a string in any base.  This is why I put `strlen` there,\
    \ to convert the number to a string representation of that number in base 10.\n\
    <|/ c |>\n<| c |>\nI understand that but how do you know that the number you get\
    \ will actually be converted correctly to a string representation of that number\
    \ in base 10?\n<|/ c |>\n<| c |>\n- I explained that.  I believe that is the point\
    \ of answers like this one: one knows they shouldn't do this, and a better solution\
    \ exists. That's why I posted this comment. Your answer isn't doing what the OP\
    \ asked for, it doesn't convert a number to base 10.\n<|/ c |>\n<| a dscore=0\
    \ tags=php,math |>\n<code>\n<?php", "  if ($x < 10) return $x;\n  $d = pow(10,\
    \ (int) $base);\n  $r = $x / $d;\n  $r = $r % $d;\n  return $d * $r;\n}", "  //\
    \ use base_convert() only if it's available.\n  if (function_exists('base_convert'))\
    \ {\n    return base_convert($x, $base, 10);\n  }\n  // else, do some magic to\
    \ get the equivalent of PHP's $x / $base\n  $y = $base;\n  for ($i = 0; $x <=\
    \ $x; $i++) {\n    $y = $y * $x % $base;\n  }\n  return $y;\n}\n</code>\n<|/ a\
    \ tags=php,javascript |>\n<| c |>\nI wonder if anyone can come up with a better\
    \ solution than that if there are any edge cases. I don't think I've ever seen\
    \ an implementation that works without resorting to a very slow method.\n<|/ c\
    \ |>\n<| c |>\nI guess the more you can abstract to base conversion, the better.\n\
    <|/ c |>\n<| c |>\nThanks man, I love this answer but the problem with this is\
    \ that you loose the leading zeros when you convert from base 10 to base 2.\n\
    <|/ c |>\n<| a dscore=4 tags=php,javascript |>\n<code>\n<?php\n$number = array();\n\
    $number[0] = 0;\n$number[1] = 1;\n$number[2] = 10;\n$number[3] = 100;\n$number[4]\
    \ = 1000;\n$number[5] = 10000; \n$number[6] = 100000;\n$number[7] = 1000000;\n\
    $number[8] = 10000000;\n$number[9] = 100000000; \n$number[10] = 1000000000;\n\
    $number[11] = 10000000000;\n$number[12] = 100000000000;\n$number[13] = 1000000000000;\
    \ \n$number[14] = 10000000000000;\n$number[15] = 100000000000000;\n", "    if\
    \ ($x < 10) {\n        if ($base == 10) return '0'.$x;\n        if ($base == 2)\
    \ return $x;\n        if ($base == 8) return '0b'.base_to_integer($x);\n    }\n\
    \    $digits = base_to_integer($x);\n    if ($digits > $base) {\n        $digits\
    \ = $base;\n        $x = $x / $base;\n        $digits = base_to_integer($x);\n\
    \    }\n    $i = 0; $result = '';\n    while (true) {\n        $i = $digits;\n\
    \        if ($digits < 0) {\n            $result = $x.($i < 0 ? \"-\" : \"\");\n\
    \            break;\n        }\n        $digits -= $base;\n        $x = $x * $base;\n\
    \        $digits = base_to_integer($x);\n        if ($digits < $base) break;\n\
    \        $result = $base.$result;\n    }\n    return $result;\n}\n", "    $s =\
    \ preg_replace(\"/(\\d)(?=(\\d{3})+$)\", \"$1_$base\", $x);\n    return $s;\n\
    }\n", "  $base = (int)$base;\n  if($base < 2 || $base > 36) {\n    throw new Exception(\"\
    Illegal base $base.\");\n  }\n  $str = strval($x);\n  $base2 = str_split($str,\
    \ strlen($str) - 1);\n  $base2[$base] ^= 1;\n  return implode('', $base2);\n}",
  "\t$n = $x; // The numeral.\n\t$p = $base; // The base.\n\n\t// Make sure base is\
    \ less than 10.\n\tif ($p < 10) {\n\t\t$p = 10; // Set base to 10.\n\t}\n\n\t\
    // Convert numeral to $base.\n\t$n %= $base;\n\tif ($n < 0) {\n\t\t$n = (-$n)\
    \ + $base;\n\t}\n\t$n = $n * $p; // Multiply $n by $base.\n\n\t// Convert back\
    \ to integer.\n\t$n = floor($n); // Truncate decimal portion.\n\t$n = $n % $base;\
    \ // Round down to the nearest $base.\n\n\treturn $n;\n}", "  $str = ltrim(strval($x),\
    \ '0');\n  if ($str === '') return '0';\n  $base = 10;\n  return (string)$str\
    \ / $base + ((string)$str % $base) / $base;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=php |>\nYou don't need any loop for this. Just get the power of 10 (using\
    \ log10) and multiply it with the number, divide it by your base, add 1 to the\
    \ result and convert the result to string with number_format function.\n<code>\n\
    echo number_format((int)Math.pow(10,$i), $base);\n</code>\n<|/ a |>\n<| c |>\n\
    It's not the same - that function only works with numbers, this works with string\
    \ representations of numbers (`strval()`), and `Math.pow(10,$i)` would have to\
    \ be `(float)Math.pow(10,$i)` or `(int)Math.pow(10,$i)`.\n<|/ c |>\n<| c |>\n\
    Yes I agree and edited my answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\nThis\
    \ is my solution for your question. I tried it for string conversion and it works\
    \ well.\n<code>", "    $x *= $base;\n    $n = floor($x);\n    $x -= $n;\n    $x\
    \ *= $base;\n    $n = floor($x);\n    $x -= $n;\n    $x *= $base;\n    $n = floor($x);\n\
    \    $x -= $n;\n    $x *= $base;\n    return $n;\n}", "  $digits = base_convert($x,\
    \ 10, $base);\n  if ($digits == 0) return '0';\n  $digits = str_pad($digits, $base,\
    \ '0', STR_PAD_LEFT);\n  return $digits;\n}\n", "  if ($base >= 2 && $x <= 10)\
    \ {\n    return '0'.str_pad($x, $base, '0', STR_PAD_LEFT);\n  }\n  return $x;\n\
    }", "  $str = strval($x);\n  $base = (int) $base;\n  if ($base < 1 || $base >\
    \ 10) {\n    return false;\n  }\n\n  if ($base > strlen($str)) {\n    return false;\n\
    \  }\n\n  $converted = str_split(substr($str, 0, $base));\n  foreach ($converted\
    \ as $k => $value) {\n    if ($value != 0) {\n      $converted[$k] = intval($value)\
    \ * (pow(10, $base - $k - 1));\n    }\n  }\n  $converted = array_sum($converted);\n\
    \  if ($converted) {\n    $str = implode('', $converted);\n  }\n  return $str;\n\
    }", "  $base = intval($base);\n  if ($base < 0 || $base > 9) {\n    throw new\
    \ Exception('Base must be a number between 0 and 9');\n  }\n  $num = (string)\
    \ $x;\n  $num_length = strlen($num);\n  $result = '';\n  while ($num_length >\
    \ 0) {\n    $reversed = array_reverse(str_split($num));\n    foreach ($reversed\
    \ as $key => $value) {\n      $result = $value . $result;\n      if ($key < ($num_length\
    \ - 1)) {\n        $result = '0' . $result;\n      }\n    }\n    $num = $result;\n\
    \    $num_length = strlen($num);\n  }\n  return $result;\n}\n", "    $s = $x;\n\
    \    if ($base > 0 && $s < 10) {\n        $s += $base;\n    }\n    return $s;\n\
    }\n", "  $digits = base_convert($x, 10, $base);\n  $digits = str_pad($digits,\
    \ $base, '0', STR_PAD_LEFT);\n  return $digits;\n}\n</code>\n<|/ a tags=php,bignum,math\
    \ |>\n<| c |>\nThanks for your answer. Your function returns the correct output\
    \ for the example. But the function doesn't work for large numbers, like `1e9`.\n\
    <|/ c |>\n<| c |>\nIt seems like a limitation of PHP, because I tested it with\
    \ `$num = 1.02e9; $digits = base_convert($num, 10, 8); echo $digits;` and the\
    \ result was `1000`.\n<|/ c |>\n<| c |>\nThe function also doesn't work for negative\
    \ numbers, e.g. `$num = -0.1e9; $digits = base_convert($num, 10, 8); echo $digits;`\n\
    <|/ c |>\n<| c |>\nI tested `$num = -0.1e9; $digits = base_convert($num, 10, 8);\
    \ echo $digits;` and it returned `-1000`.\n<|/ c |>\n<| c |>\nThat's weird, because\
    \ `var_dump(-0.01e9)` gives me `float(-0.01e+9)`\n<|/ c |>\n<| a |>\nBased on\
    \ Kolink's answer, I've developed a more general version that also can handle\
    \ non-integer numbers. \nI've also added a second parameter to change what base\
    \ the input number should be converted to. \n<code>", "  $digits = strlen($x);\n\
    \  if ($digits < $base) {\n    $x = str_pad('', $base, $x);\n  }\n  $i = 0;\n\
    \  while ($i < $digits) {\n    $i += $base;\n    $x = $x . str_pad('', $base,\
    \ $x[($i - $digits) % ($base)]);\n  }\n  return $x;\n}\n", "    if ($x < 10)\n\
    \        return $x;\n    $x = (int)($x/$base)*$base;\n    $x = $x - floor($x);\n\
    \    return $x;\n}", "  $str = sprintf('%0'.$base.'d', $x);\n  $len = strlen($str);\n\
    \  return substr($str, 0, $len);\n}\n</code>\n<|/ a tags=php |>\n<| a |>\nHere\
    \ is a function that I wrote for my project:\n<code>", "  if ($base >= 2 && $base\
    \ < 10) {\n    $t = pow($base, $x);\n    return $t;\n  } else if ($base == 10)\
    \ {\n    return $x;\n  }\n  $base10 = 10 ** $base;\n  return $x / $base10;\n}\n",
  "\tif ($x < 10) {\n\t\treturn $x;\n\t} else if ($x >= 10) {\n\t\treturn $base *\
    \ $x + $x % $base;\n\t} else {\n\t\treturn $x - 10 * floor($x / $base);\n\t}\n\
    }", "  if ($base < 2 || $base > 10) {\n    echo \"Invalid base\\n\";\n    exit();\n\
    \  }\n  $x = $x * $base;\n  $x = floor($x); // truncate to int precision\n  $x\
    \ = $x / $base;\n  return $x;\n}\n", "  $s = ($x / $base) . ($x % $base);\n  $s\
    \ /= $base;\n  return $s;\n}", "    if ($x<10) return $x;\n    else return ($x/$base)*$base;\n\
    }\n\n$i=1;\n$j=1;\n$t=0;\n$result=\"\";\nfor($i=1;$i<=20;$i++) {\n    $t = change_base(4*$j,\
    \ $i);\n    $result=$result.$t;\n    $j++;\n}\necho $result;", "    if (!$base)\
    \ {\n        echo \"Base cannot be zero\";\n        die;\n    }\n    $base = sprintf('%02d',\
    \ $base);\n    $remainder = $x % $base;\n    if ($remainder == 0) {\n        $y\
    \ = $base;\n    } else {\n        $y = $base;\n        $x = $remainder;\n    }\n\
    \    $y = str_pad($y, $base, '0', STR_PAD_RIGHT);\n    return $y;\n}", "    if\
    \ ($base > strlen($x)) {\n        return '0';\n    }\n    if ($base < 2) {\n \
    \       return '';\n    }\n\n    $baseLen = strlen($base);\n    $result = preg_replace_callback(\n\
    \        '/(?<=$)0+|'.\n        '(?<=$)'.\n        implode('|', array_fill(0,\
    \ $baseLen, '\\\\'.$base)).\n        '/',\n        function ($matches) {\n   \
    \         $n = $matches[0];\n            $digit = $matches[$base];\n         \
    \   return ''.($n % $digit).$digit;\n        },\n        $x\n    );\n    return\
    \ ltrim($result, '0');\n}\n", "    $base = pow(10, $base);\n    $str = base_convert((string)$x,\
    \ $base, $base);\n    if ($str == '0') {\n        return '0';\n    } else {\n\
    \        return $str;\n    }\n}\n", "  $bases = array(\"\", \"K\", \"M\", \"B\"\
    , \"T\", \"P\", \"E\", \"Z\", \"Y\");\n  return ($x / ($base ** array_search($base,\
    \ range(9, -3))))\n  . (($x) % $base)\n  . ($bases[array_search($base, range(9,\
    \ -3) + 1)]);\n}\n", "    $str = strval($x);\n    $length = strlen($str);\n  \
    \  $result = '';\n    foreach (str_split($str) as $k => $v) {\n        $result\
    \ .= $v * ($base ** $length);\n    }\n    return $result;\n}\n", "    $x = abs($x);\n\
    \    $base = abs($base);\n    $r = '';\n    while ($x > 0 || $base > 0) {\n  \
    \      if ($x > 0) {\n            $r = $x * $base + $r;\n            $x = $x /\
    \ $base;\n        } else {\n            $r = $base + $r;\n            $base =\
    \ $base / $base;\n        }\n    }\n    return $r;\n}\n", "    if ($x == 0) return\
    \ 0;\n    $base10 = 10 ** $base;\n    return floor($x / $base10) + ($x % $base10);\n\
    }\n", "  $number = intval($x);\n  $base   = intval($base);\n  if ( $base > 2 )\n\
    \    $base  = 10;\n\n  $number = ($number*$base);\n  $number = floor($number);\n\
    \  $base   = $base;\n\n  return $base+$number;\n}\n\n$url = 'http://localhost/phptest/';\n\
    $url .= 'index.php?page=product&productId=';\n$url .= $row['id'];\n\n$image =\
    \ mysql_prep($row['image']);\nif ( is_numeric($image) )\n{\n  $url .= $image;\n\
    }\nelse\n{\n  $url .= $image;\n}\n\n$url .= ' class=\"product-image\"';\n\n$category\
    \ = mysql_prep($row['category']);\nif ( is_numeric($category) )\n{\n  $url .=\
    \ ' data-category=\"'.$category.'\"';\n}\nelse\n{\n  $url .= ' data-category=\"\
    '.$category.'\"';\n}\n\n$rating = mysql_prep($row['rating']);\nif ( is_numeric($rating)\
    \ )\n{\n  $url .= ' data-rating=\"'.$rating.'\"';\n}\nelse\n{\n  $url .= ' data-rating=\"\
    '.$rating.'\"';\n}\n\n$productName = mysql_prep($row['productName']);\nif ( is_numeric($productName)\
    \ )\n{\n  $url .= ' data-productname=\"'.$productName.'\"';\n}\nelse\n{\n  $url\
    \ .= ' data-productname=\"'.$productName.'\"';\n}\n\nif ( is_numeric($row['price'])\
    \ )\n{\n  $url .= ' data-price=\"'.$row['price'].'\"';\n}\nelse\n{\n  $url .=\
    \ ' data-price=\"'.$row['price'].'\"';\n}\n\nif ( is_numeric($row['price2']) )\n\
    {\n  $url .= ' data-price2=\"'.$row['price2'].'\"';\n}\nelse\n{\n  $url .= ' data-price2=\"\
    '.$row['price2'].'\"';\n}\n\n$productLink = mysql_prep($row['productLink']);\n\
    if ( is_numeric($productLink) )\n{\n  $url .= ' data-productlink=\"'.$productLink.'\"\
    ';\n}\nelse\n{\n  $url .= ' data-productlink=\"'.$productLink.'\"';\n}\n\nif (\
    \ is_numeric($row['stock']) )\n{\n", "    return base_convert($x, $base, 10);\n\
    }\n", "  return ($x < 10) ? ($base ** $x) : (($x % ($base - 1)) * ($base ** $x));\n\
    }"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
