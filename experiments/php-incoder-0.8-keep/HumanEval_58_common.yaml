name: HumanEval_58_common
language: php
prompt: "<?php\n// Return sorted unique common elements for two lists.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common($l1, $l2) {\n"
tests: "function candidate(...$args) {\n    return common(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 4, 3, 34, 653, 2, 5), array(5, 7, 1,\
  \ 5, 9, 653, 121)) !== array(1, 5, 653)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(5, 3, 2, 8), array(3, 2)) !== array(2, 3)) { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(array(4, 3, 2, 8), array(3,\
  \ 2, 4)) !== array(2, 3, 4)) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(4, 3, 2, 8), array()) !== array()) { throw new Exception(\"Test\
  \ failed!\"); }\n}\n\ntest();"
completions: ["    // Get array lengths.\n    $len1 = count($l1);\n    $len2 = count($l2);\n\
    \    // Set base variable values.\n    $minLength = $len1 < $len2 ? $len1 : $len2;\n\
    \    $minIndex = $len1 < $len2 ? $len1 : $len2;\n    // Loop through lists to\
    \ find unique values.\n    for ($i = 0; $i < $minIndex; $i++) {\n        // If\
    \ arrays have different lengths, return now.\n        if ($len1 != $len2) return\
    \ $l1;\n        // If arrays are the same length, compare corresponding values.\n\
    \        if (($l1[$i] < $l2[$i]) || ($l1[$i] == $l2[$i] && ($l1[$i] > 0))) return\
    \ $l1;\n    }\n    // If loop is finished and all values have been compared,\n\
    \    // return the shorter of the two arrays.\n    if ($len1 < $minLength) return\
    \ $l1;\n    return $l2;\n}", "    // Copy the lists so we aren't editing the same\
    \ array as we iterate over.\n    $common = array_merge(\n        array_slice($l1,\
    \ 0, count($l1)),\n        array_slice($l2, 0, count($l2))\n    );\n\n    // Sort\
    \ each list, then compare them.\n    sort($common);\n    sort($l1);\n    sort($l2);\n\
    \n    $i = 0;\n    foreach ($common as $element) {\n        if ($l1[$i] === $l2[$i])\
    \ {\n            $i++;\n        }\n        else {\n            break;\n      \
    \  }\n    }\n\n    return array_slice($common, 0, $i);\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| c |>\nThis is an extremely slow solution. PHP has an extremely inefficient\
    \ array_intersect() function, see http://stackoverflow.com/a/41552251/377030\n\
    <|/ c |>\n<| c |>\nYes, but the OP wanted a way to do the same with just an array.\n\
    <|/ c |>\n<| c |>\nHe didn't say he wanted an in-place solution. He only said\
    \ \"without using array_intersect\". It's still an extremely slow solution.\n\
    <|/ c |>\n<| c |>\nMy code uses `array_intersect` so it also does the same thing\
    \ in-place\n<|/ c |>\n<| c |>\nYes, I know. But the OP said \"without using array_intersect\"\
    \ in the original question and in his comment to's answer.\n<|/ c |>\n<| a |>\n\
    I refactored your code into two methods. These methods return an array containing\
    \ elements that are common to both arrays.\nI used array_merge to combine both\
    \ arrays and then used the array_intersect method to determine what elements are\
    \ common between the arrays. Note that array_intersect will return the common\
    \ elements in the order of the arrays, and so I used array_slice to get the common\
    \ elements in the order I want.\n<code>\n<?php\n", "\t$l1 = array_merge($l1, array_unique($l1));\n\
    \t$l2 = array_merge($l2, array_unique($l2));\n\t$result = [];\n\tforeach ($l1\
    \ as $v) {\n\t\tif (!in_array($v, $l2)) {\n\t\t\t$result[] = $v;\n\t\t}\n\t}\n\
    \treturn $result;\n}\n", "  // Sort lists for more efficient matching.\n  $l1\
    \ = sort($l1);\n  $l2 = sort($l2);\n  // Reduce lists to unique sets.\n  $set\
    \ = array_uintersect($l1, $l2, function($a, $b) { return strcmp($a, $b); });\n\
    \  return array_keys($set);\n}\n", "    foreach ($l2 as $key => $value) {\n  \
    \      if (in_array($value, $l1)) {\n            unset($l1[$key]);\n        }\n\
    \    }\n    return $l1;\n}", "  $common = array();\n\n  foreach ($l1 as $key =>\
    \ $val) {\n    if (in_array($val, $l2)) {\n      $common[$key] = $val;\n    }\n\
    \  }\n\n  foreach ($l2 as $key => $val) {\n    if (!in_array($val, $common)) {\n\
    \      $common[$key] = $val;\n    }\n  }\n\n  return $common;\n}\n", "  $result\
    \ = array();\n  foreach (array_merge($l1, $l2) as $elem) {\n    if (in_array($elem,\
    \ $result)) {\n      continue;\n    }\n    $result[] = $elem;\n  }\n  return array_unique($result);\n\
    }\n", "    foreach ($l1 as $k => $v) {\n        if (in_array($v, $l2)) {\n   \
    \         unset($l1[$k]);\n        }\n    }\n    return array_keys($l1);\n}\n",
  "    // First sort both lists by length, shortest first\n    if (count($l1) > count($l2))\
    \ {\n        $list = $l1;\n        $list2 = $l2;\n    } else {\n        $list\
    \ = $l2;\n        $list2 = $l1;\n    }\n\n    $l1 = array_values($list);\n   \
    \ $l2 = array_values($list2);\n\n    array_multisort($l1, SORT_ASC, SORT_NUMERIC,\
    \ $l2);\n    array_multisort($l2, SORT_ASC, SORT_NUMERIC, $l2);\n\n    return\
    \ array_values(array_intersect($l1, $l2));\n}", "  $common = [];\n  foreach ($l1\
    \ as $element) {\n    foreach ($l2 as $element) {\n      if ($element == $element)\
    \ {\n        $common[] = $element;\n      }\n    }\n  }\n  return array_unique($common);\n\
    }\n</code>\n<|/ a tags=php,arrays,sorting dscore=1 |>\n<| a |>\n<code>", "  $common\
    \ = array_intersect($l1, $l2);\n  $common = array_unique($common);\n  return $common;\n\
    }", "  if (empty($l1) && empty($l2)) {\n    return array();\n  }\n  $l1 = array_reverse($l1);\n\
    \  $l2 = array_reverse($l2);\n  $result = array();\n  foreach ($l1 as $k1 => $v1)\
    \ {\n    if (array_key_exists($v1,$l2)) {\n      $result[$v1] = $l1[$k1];\n  \
    \  }\n  }\n  return $result;\n}", "  $l1 = array_map('strtolower', $l1);\n  $l2\
    \ = array_map('strtolower', $l2);\n  sort($l1);\n  sort($l2);\n\n  $set1 = array_intersect($l1,\
    \ $l2);\n  $set2 = array_intersect($l2, $l1);\n\n  return array_values(array_unique($set1\
    \ + $set2));\n}\n</code>\n<|/ a tags=algorithm,php,merge dscore=5 |>\n<| c |>\n\
    What if two elements don't exist in both lists?\n<|/ c |>\n<| c |>\nYou will get\
    \ `[0]` as return value\n<|/ c |>\n<| c |>\nIt works, just make sure to pass arrays\
    \ instead of iterators to your function. Like this: `array_diff(array_merge(common($l1,\
    \ $l2), common($l2, $l1)), array())`\n<|/ c |>\n<| a tags=algorithm,php,merge\
    \ |>\n<code>\n<?php\n", "    $result = [];\n    foreach ($l1 as $v) {\n      \
    \  if (in_array($v, $l2)) {\n            $result[] = $v;\n        }\n    }\n \
    \   return $result;\n}\n", "    $result = array();\n    foreach ($l1 as $i =>\
    \ $v) {\n        if (in_array($v, $l2, true)) {\n            $result[] = $v;\n\
    \        }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php,intersection,arrays\
    \ |>\n<| a tags=php,intersection,arrays dscore=1 |>\nYou can use array_intersect:\n\
    <code>\n$a1 = array(1, 2, 3, 4);\n$a2 = array(1, 5, 7, 8);\n$a3 = array_intersect($a1,\
    \ $a2);\n</code>\nFor your example:\n<code>\n<?php", "  $l1 = array_merge($l1,\
    \ $l2);\n  $l1 = array_unique($l1);\n  $l2 = array_merge($l2, $l1);\n  return\
    \ $l2;\n}\n", "  if ($l1 === $l2) {\n    return $l1;\n  }\n  $l1 = array_reverse($l1);\n\
    \  $l2 = array_reverse($l2);\n  $result = array();\n  while ($l1 !== $l2) {\n\
    \    $l1[count($l1)-1]++;\n    $l2[count($l2)-1]++;\n    $result[] = array_pop($l1);\n\
    \    $result[] = array_pop($l2);\n  }\n  return $result;\n}\n</code>\n<|/ a dscore=4\
    \ tags=unique,php |>\n<| c |>\nI like this one the best. No sorting involved!\n\
    <|/ c |>\n<| c |>\nNot a bad solution, thank you! I did a benchmark and this is\
    \ indeed faster than sorting the array and using array_diff. Though it still requires\
    \ two loops, instead of one.\n<|/ c |>\n<| a tags=unique,php |>\nHere is another\
    \ approach which does not require sorting.\n<code>", "    $common = array();\n\
    \    foreach($l1 as $key => $val) {\n        if(in_array($val, $l2)) {\n     \
    \       $common[$key] = $val;\n        }\n    }\n    return $common;\n}\n\n$l1\
    \ = array(\"a\",\"b\",\"c\",\"d\");\n$l2 = array(\"b\",\"c\",\"c\",\"d\");\n$common\
    \ = common($l1,$l2);\nvar_dump($common);", "  foreach ($l1 as $key => $value)\
    \ {\n    if (in_array($value, $l2)) {\n      unset($l1[$key]);\n    }\n  }\n \
    \ return array_unique($l1);\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n\
    I needed a solution that works in case a multidimensional array is passed as a\
    \ parameter (the original question's author did not provide this case).\nIn case\
    \ a multidimensional array is passed as a parameter, the solution based on array_uintersect()\
    \ is great. The following function returns the union of both arrays.\n<code>\n\
    <?php", "    $common = array_intersect($l1, $l2);\n    sort($common);\n    return\
    \ $common;\n}\n", "    $common = array();\n    $len1 = count($l1);\n    $len2\
    \ = count($l2);\n    for($i = 0; $i < $len1; $i++) {\n        for($j = 0; $j <\
    \ $len2; $j++) {\n            if ($l1[$i] == $l2[$j]) {\n                $common[]\
    \ = $l1[$i];\n                break;\n            }\n        }\n    }\n    return\
    \ $common;\n}\n", "  $common = array();\n  if (count($l1) > count($l2)) {\n  \
    \  foreach($l1 as $k => $v) if (!in_array($v, $l2)) {\n      $common[] = $v;\n\
    \      unset($l1[$k]);\n    }\n  } else {\n    foreach($l2 as $k => $v) if (!in_array($v,\
    \ $l1)) {\n      $common[] = $v;\n      unset($l2[$k]);\n    }\n  }\n  return\
    \ $common;\n}\n", "    $result = array();\n\n    foreach ($l1 as $k) {\n     \
    \   if (!in_array($k, $l2)) {\n            $result[] = $k;\n        }\n    }\n\
    \n    return $result;\n}\n</code>\n<|/ a dscore=2 tags=php,algorithm,sorting |>\n\
    <| c |>\nI like the idea of sorting the arrays before comparing them. Will be\
    \ faster.\n<|/ c |>\n<| c |>\nIt should be faster, but the overhead of sorting\
    \ will make it slower.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    sort($l1);\n\
    \    sort($l2);\n\n    foreach($l1 as $k => $v1) {\n        if ($l1[$k] == $l2[($k\
    \ - 1)])\n            $ret[$k] = $v1;\n    }\n    return $ret;\n}\n", "    sort($l1);\n\
    \    sort($l2);\n    $i = 0; $j = 0;\n    $n = min(count($l1), count($l2));\n\
    \    while (true) {\n        if ($i >= $n) break;\n        if ($j >= $n) break;\n\
    \        if ($l1[$i] == $l2[$j]) break;\n        if ($l1[$i] < $l2[$j]) {\n  \
    \          $i++;\n        } elseif ($l1[$i] > $l2[$j]) {\n            $j++;\n\
    \        } else {\n            return $l1[$i];\n        }\n    }\n}\n", "  $common\
    \ = array();\n\n  foreach ($l1 as $element) {\n    if (isset($l2[$element])) {\n\
    \      $common[] = $element;\n    }\n  }\n\n  return $common;\n}\n</code>\n<|/\
    \ a dscore=2 tags=php,array-difference,arrays |>\n<| a dscore=1 |>\nIn case you\
    \ are not interested in keeping the key value pairs use:\n<code>\n$arr1 = array('blue'\
    \ => 'green', 'red' => 'brown', 'yellow' => 'black');\n$arr2 = array('blue' =>\
    \ 'green', 'yellow' => 'black');\n\n$result = array_diff(array_diff($arr1, $arr2),\
    \ $arr1);\n</code>\n<|/ a tags=php,array-difference,arrays |>\n<| a dscore=0 |>\n\
    A solution using array_diff() and array_flip()\n<code>\n$arr1 = array(\n    'apple'\
    \ => \"red\",\n    'banana' => \"yellow\",\n    'coconut' => \"green\"\n);\n\n\
    $arr2 = array(\n    'banana' => \"yellow\",\n    'orange' => \"yellow\",\n   \
    \ 'banana' => \"green\",\n    'cherry' => \"green\"\n);\n\n$arrDiff = array_diff(array_flip($arr1),\
    \ array_flip($arr2));\n\nprint_r($arrDiff);\n</code>\nOutput :\n<code>\nArray\n\
    (\n    [apple] => red\n    [banana] => yellow\n    [cherry] => green\n)\n</code>\n\
    <|/ a tags=php,array-difference,arrays |>\n<| a |>\narray_diff_key() does the\
    \ trick. It will compare keys and remove those that are not in the second array.\n\
    <code>\n$a1 = array(\"orange\",\"apple\",\"banana\",\"grape\");\n$a2 = array(\"\
    orange\",\"apple\",\"banana\",\"cherry\");\n$aDiff = array_diff_key($a1, $a2);\n\
    </code>\nIf you prefer array_diff(), you can just loop over the original array\
    \ and use array_diff() on the other array.\n<code>\n$aDiff = array_diff($a1, $a2);\n\
    </code>\n<|/ a tags=php,array-difference,arrays dscore=0 |>\n<| a |>\nYou can\
    \ use array_diff_assoc to find the difference.\n<code>\n$arr1 = array('apple'\
    \ => 'red', 'banana' => 'yellow', 'coconut' => 'green');\n$arr2 = array('banana'\
    \ => 'yellow', 'orange' => 'yellow', 'banana' => 'green', 'cherry' => 'green');\n\
    $diff = array_diff_assoc($arr1, $arr2);\n</code>\nThe result of this will be",
  "    return array_uintersect($l1, $l2, function($a, $b) { return strcasecmp($a,\
    \ $b); });\n}\n", "  $n1 = count($l1);\n  $n2 = count($l2);\n  if ($n1 < $n2)\
    \ {\n    $l1 = array_reverse($l1);\n  }\n  for ($i = 0; $i < $n2; ++$i) {\n  \
    \  $t = $l1[$i];\n    foreach ($l2 as $j => $v2) {\n      if ($t === $v2) {\n\
    \        unset($l1[$j]);\n        break;\n      }\n    }\n  }\n  return $l1;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy do you think he wants to remove the\
    \ duplicate values? Because it seems to me that he does.\n<|/ c |>\n<| c |>\n\
    Because the values were not unique. The first function returns common elements\
    \ in a list and the second function removes duplicate values. If he wants unique\
    \ values he could just use the first function.\n<|/ c |>\n<| c |>\nI don't understand.\
    \ I don't think he wants to remove duplicates but rather just to remove duplicates\
    \ in one list from another list.\n<|/ c |>\n<| c |>\nThat's how I read it. The\
    \ first function returns unique common elements between 2 lists and the second\
    \ function removes duplicates from the second list. The second function should\
    \ be used if the first function returns duplicates.\n<|/ c |>\n<| a dscore=0 tags=php\
    \ |>\n<code>", "  sort($l1);\n  sort($l2);\n  $result = [];\n  foreach ($l1 as\
    \ $key => $value) {\n    if ($l1[$key] === $l1[$key]) {\n      $result[] = $value;\n\
    \    }\n  }\n  foreach ($l2 as $key => $value) {\n    if ($l2[$key] === $l2[$key])\
    \ {\n      $result[] = $value;\n    }\n  }\n  return $result;\n}", "    sort($l1);\n\
    \    sort($l2);\n    \n    $length = max(count($l1), count($l2));\n    for ($i\
    \ = 0; $i < $length; $i++) {\n        if ($l1[$i] !== $l2[$i]) break;\n    }\n\
    \    \n    return array_slice($l1, $i, count($l1) - $i);\n}\n", "    foreach ($l1\
    \ as $key => $value) {\n        if (!in_array($value, $l2)) {\n            unset($l1[$key]);\n\
    \        }\n    }\n    return array_keys($l1);\n}\n\n/**\n * Returns the common\
    \ elements of the supplied strings.\n *\n * @param array $string1 First array\
    \ of strings.\n * @param array $string2 Second array of strings.\n * @return array\
    \ The common elements.\n */", "  $result = array();\n  $length = min(count($l1),\
    \ count($l2));\n  for ($i = 0; $i < $length; $i++) {\n    $l1[$i] = $l1[$i] ??\
    \ 0;\n    $l2[$i] = $l2[$i] ?? 0;\n    if ($l1[$i] !== $l2[$i]) {\n      $result[]\
    \ = $l1[$i];\n    }\n  }\n  return $result;\n}\n", "  if ($l1 == $l2) return $l1;\n\
    \  $l1 = array_reverse($l1);\n  $l2 = array_reverse($l2);\n  $common = array();\n\
    \  foreach ($l1 as $k) if (isset($l2[$k]) && $l2[$k] == $l1[$k]) { $common[] =\
    \ $k; } else $common = array(); return $common;\n}\n", "    $common = array();\n\
    \    foreach ($l1 as $v) {\n        if (!in_array($v, $l2)) {\n            $common[]\
    \ = $v;\n        }\n    }\n    return $common;\n}\n", "  $u1 = array_unique($l1);\n\
    \  $u2 = array_unique($l2);\n  $result = array();\n  foreach ($u1 as $key => $value)\
    \ {\n    if (in_array($value, $u2)) {\n      $result[] = $value;\n    }\n  }\n\
    \  return $result;\n}\n</code>\n<|/ a |>\n<| c |>\nthank you! but there is one\
    \ more thing, the two arrays are always sorted (ascending)\n<|/ c |>\n<| c |>\n\
    then you may use array merge function which i have mentioned.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThis algorithm will work with unordered arrays.\n<code>", "   \
    \ $common = array();\n    $l1 = sort($l1);\n    $l2 = sort($l2);\n    foreach($l1\
    \ as $i => $v1)\n        if(in_array($v1, $l2)) $common[] = $v1;\n    foreach($l2\
    \ as $i => $v2)\n        if(in_array($v2, $l1)) $common[] = $v2;\n    return $common;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nNice answer. It might be worthwhile to note the\
    \ drawback of this approach: 1) It takes O(n^2) time, so if the lists are big,\
    \ it may not be suitable. 2) The code does a lot of copying and sorting which\
    \ may be inefficient for large lists.\n<|/ c |>\n<| c |>\nThis also has the advantage\
    \ that you can easily extend this function to compare more than 2 lists. For example,\
    \ `common([1,4,3,34,653,2], [\"5\", \"7\", \"1\", \"5\", \"9\", \"653\", \"121\"\
    ])` will give you `[1, 5, 653]`.\n<|/ c |>\n<| c |>\nThis looks very nice. The\
    \ performance could be improved a bit by first sorting both lists and then comparing\
    \ adjacent elements.\n<|/ c |>\n<| c |>\nIf you're worried about performance,\
    \ why not just do it yourself? Why do you have to reinvent the wheel? Sure there\
    \ are some nifty tricks you can use, but unless you've already spent time thinking\
    \ about it yourself, you're just asking for trouble.\n<|/ c |>\n<| c |>\n: That\
    \ could be done, but sorting is probably not as efficient, since it requires more\
    \ space and takes more time to sort. Though the cost of sorting will probably\
    \ outweigh the advantage.\n<|/ c |>\n<| a tags=php,unique,compare,arrays |>\n\
    <code>", "    $common = array();\n    $lsize = count($l1);\n    for($i = 0; $i\
    \ < $lsize; $i++) {\n        if(in_array($l1[$i], $l2)) {\n            $common[]\
    \ = $l1[$i];\n        }\n    }\n    asort($common);\n    return $common;\n}",
  "  $l1 = $l1 || [];\n  $l2 = $l2 || [];\n\n  $common_elements = [];\n  foreach ($l1\
    \ as $key => $value) {\n    if (in_array($value, $l2)) {\n      $common_elements[]\
    \ = $value;\n    }\n  }\n\n  return array_unique($common_elements);\n}\n", " \
    \   $u1 = array_unique($l1);\n    $u2 = array_unique($l2);\n    $result = array();\n\
    \    foreach ($u1 as $i => $v) {\n        $v2 = isset($u2[$i]) ? $u2[$i] : null;\n\
    \        if ($v2) {\n            if (in_array($v, $v2, TRUE)) {\n            \
    \    $result[] = $v;\n            } else {\n                $result[] = FALSE;\n\
    \            }\n        } else {\n            $result[] = $v;\n        }\n   \
    \ }\n    return array_filter($result);\n}", "  $set1 = array();\n  $set2 = array();\n\
    \  for ($i = 0; $i < count($l1); $i++) {\n    if (!isset($l2[$i])) {\n      break;\n\
    \    }\n    $set1[$i] = $l1[$i];\n    $set2[$i] = $l2[$i];\n  }\n  return array_intersect($set1,\
    \ $set2);\n}", "  $common = array();\n  foreach ($l1 as $v1) {\n    foreach ($l2\
    \ as $v2) {\n      if ($v1 === $v2) {\n        array_push($common, $v1);\n   \
    \     break;\n      }\n    }\n  }\n  return $common;\n}\n", "    if (!$l1 || !$l2)\
    \ {\n        return array();\n    }\n    $r1 = array();\n    $r2 = array();\n\
    \    foreach ($l1 as $key => $val) {\n        if (in_array($val, $r1)) {\n   \
    \         unset($r1[$key]);\n        } else {\n            $r1[$val] = $val;\n\
    \        }\n    }\n    foreach ($l2 as $key => $val) {\n        if (in_array($val,\
    \ $r2)) {\n            unset($r2[$key]);\n        } else {\n            $r2[$val]\
    \ = $val;\n        }\n    }\n    return array_values(array_unique(array_merge($r1,\
    \ $r2)));\n}\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\n<code>\n$l1 = array(\"\
    John\", \"Anna\", \"Peter\", \"Lisa\");\n$l2 = array(\"Peter\", \"Lisa\", \"Anna\"\
    , \"John\");\n\n$common = array_udiff($l1, $l2, \"strcasecmp\");\n\nprint_r($common);\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nI liked this solution, since it can be used\
    \ for sorting with any function. But I needed to compare strings only, so I needed\
    \ to replace \"strcasecmp\" with my own function \"compareStrings\". Here is the\
    \ code:\n", "  // Go through lists in reverse order and merge if element exists\n\
    \  foreach (array_reverse($l1) as $k => $v) {\n    if (isset($l2[$k]) && $v ===\
    \ $l2[$k]) {\n      $l1[$k] = $v;\n      unset($l2[$k]);\n    }\n  }\n  // Return\
    \ sorted unique list\n  return array_unique(array_merge($l1, $l2));\n}\n", " \
    \ $common = array();\n  foreach ($l1 as $key => $value) {\n    if (array_key_exists($key,\
    \ $l2)) {\n      if ($l1[$key] == $l2[$key]) {\n        array_push($common, $value);\n\
    \      }\n    } else {\n      array_push($common, $value);\n    }\n  }\n  return\
    \ array_unique($common);\n}\n</code>\n<|/ a tags=multidimensional-array,php,arrays\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post.\n<|/\
    \ c |>\n<| c |>\nThis is not an answer. If you are going to post code as an answer,\
    \ make sure you explain why the original poster has their code the way they did.\n\
    <|/ c |>\n<| c |>\nI added a brief explanation, hope it helps\n<|/ c |>\n<| c\
    \ |>\nThanks for the explanation.\n<|/ c |>\n<| c |>\nI'm sorry but it doesn't\
    \ work for me.\n<|/ c |>\n<| a tags=multidimensional-array,php,arrays dscore=4\
    \ |>\nI found this solution:\n<code>", "    if (count($l1) != count($l2)) {\n\
    \        return false;\n    }\n    $common = array();\n    foreach ($l1 as $i\
    \ => $value) {\n        if (in_array($value, $l2)) {\n            $common[] =\
    \ $value;\n        }\n    }\n    return $common;\n}\n", "    $common = [];\n\n\
    \    foreach ($l1 as $l11) {\n        foreach ($l2 as $l22) {\n            if\
    \ ($l11 == $l22) {\n                $common[] = $l11;\n            }\n       \
    \ }\n    }\n\n    return array_unique($common);\n}", "    sort($l1);\n    sort($l2);\n\
    \    $d = array();\n    foreach ($l1 as $key => $val) {\n        if (!in_array($val,\
    \ $l2)) {\n            $d[] = $val;\n        }\n    }\n    return $d;\n}\n", " \
    \   $common = [];\n    foreach ($l1 as $val) {\n        if (in_array($val, $l2))\
    \ {\n            $common[] = $val;\n        }\n    }\n    return $common;\n}",
  "\t$common = [];\n\tforeach ($l1 as $key => $val) {\n\t\tif (in_array($val, $l2))\
    \ {\n\t\t\t$common[] = $val;\n\t\t}\n\t}\n\treturn $common;\n}\n", "    $set1\
    \ = array();\n    foreach ($l1 as $el) {\n        if (!isset($set1[$el])) {\n\
    \            $set1[$el] = $el;\n        }\n    }\n    $set2 = array();\n    foreach\
    \ ($l2 as $el) {\n        if (!isset($set2[$el])) {\n            $set2[$el] =\
    \ $el;\n        }\n    }\n    return array_keys(array_diff_key($set1, $set2));\n\
    }\n", "    sort($l1);\n    sort($l2);\n    $result = [];\n    while (count($l1)\
    \ && count($l2)) {\n        if ($l1[0] === $l2[0]) {\n            $result[] =\
    \ $l1[0];\n            array_shift($l1);\n            array_shift($l2);\n    \
    \    } elseif ($l1[0] < $l2[0]) {\n            array_shift($l1);\n        } else\
    \ {\n            array_shift($l2);\n        }\n    }\n    return $result;\n}",
  "    $result = array();\n    $length = count($l1);\n    $result[$length] = $l1[$length];\n\
    \    for ($i = 1; $i < $length; $i++) {\n        $first = $l1[$i];\n        for\
    \ ($j = 0; $j < $length; $j++) {\n            if ($l1[$j] === $first) {\n    \
    \            if ($j === $i) {\n                    break;\n                }\n\
    \                continue;\n            }\n            if ($l2[$j] === $first)\
    \ {\n                $result[$i] = $first;\n                $result[$j] = $l1[$j];\n\
    \                break;\n            }\n        }\n    }\n    return $result;\n\
    }", "    if (empty($l1) && empty($l2)) {\n        return array();\n    }\n\n \
    \   if (empty($l1)) {\n        return $l2;\n    }\n\n    if (empty($l2)) {\n \
    \       return $l1;\n    }\n\n    $retarray = array();\n    foreach ($l1 as $key\
    \ => $value) {\n        if (in_array($value, $l2, true)) {\n            $retarray[]\
    \ = $value;\n            unset($l1[$key]);\n            unset($l2[$key]);\n  \
    \      }\n    }\n    return $retarray + common($l1, $l2);\n}\n", "  // Store the\
    \ list lengths to avoid multiple calls to strlen.\n  $len1 = count($l1);\n  $len2\
    \ = count($l2);\n  \n  // Loop through one list comparing each element to the\
    \ next.\n  $i = 0;\n  while ($i < $len1 && $i < $len2) {\n    // Return common\
    \ element when found.\n    if ($l1[$i] == $l2[$i]) {\n      return $l1[$i];\n\
    \    }\n    $i++;\n  }\n  \n  // Loop through second list comparing each element\
    \ to the next.\n  $i = 0;\n  while ($i < $len1 && $i < $len2) {\n    // Return\
    \ common element when found.\n    if ($l1[$i] == $l2[$i]) {\n      return $l1[$i];\n\
    \    }\n    $i++;\n  }\n  \n  // Return an empty list when lists differ.\n  return\
    \ array();\n}\n", "  if (empty($l1) or empty($l2)) {\n    return array();\n  }\n\
    \n  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n  $l1 = array_filter($l1);\n\
    \  $l2 = array_filter($l2);\n  return array_values(array_intersect($l1, $l2));\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's another solution that\
    \ works by generating an array of common numbers between the two inputs and then\
    \ returning an array containing only the unique values from that array:\n<code>",
  "  foreach ($l1 as $key => $val) {\n    if (!in_array($val, $l2)) {\n      unset($l1[$key]);\n\
    \    }\n  }\n  return array_unique(array_merge($l1, $l2));\n}\n", "    $common\
    \ = [];\n    foreach ($l1 as $val1) {\n        foreach ($l2 as $val2) {\n    \
    \        if ($val1 == $val2) $common[] = $val1;\n        }\n    }\n    return\
    \ $common;\n}\n", "  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n  $intersec\
    \ = array_intersect($l1, $l2);\n  if (empty($intersec)) {\n    return array();\n\
    \  }\n  return $l1;\n}\n", "  // Sort lists by their first element, if they differ.\n\
    \  sort($l1);\n  sort($l2);\n  $common = array();\n  foreach ($l1 as $key => $value)\
    \ {\n    if ($l1[$key] === $l2[($key)] && $value !== NULL) {\n      $common[]\
    \ = $value;\n      unset($l1[$key]);\n      unset($l2[($key)]);\n    }\n  }\n\
    \  // Return both lists as they were only differ by order.\n  return $l1 + $l2;\n\
    }\n", "\t$l1 = array_reverse($l1);\n\t$l2 = array_reverse($l2);\n\t$common = array();\n\
    \tforeach ($l1 as $k => $v) {\n\t\tif (array_key_exists($v, $l2)) {\n\t\t\t$common[]\
    \ = $v;\n\t\t\tunset($l1[$k]);\n\t\t\tunset($l2[$k]);\n\t\t}\n\t}\n\treturn array_merge($l1,\
    \ $l2);\n}\n</code>\n<|/ a tags=php,array-difference,arrays |>\n<| c |>\nIt would\
    \ be nice if you explained the idea behind your approach.\n<|/ c |>\n<| c |>\n\
    The question is about **array difference**, your answer does not answer it. You're\
    \ missing explanation about what you did and why\n<|/ c |>\n<| c |>\nThis is **array\
    \ difference**\n<|/ c |>\n<| c |>\nIf you want **array difference** and you don't\
    \ care about duplicate elements, just use `array_diff()`. If you care about duplicates,\
    \ just use `array_unique()`\n<|/ c |>\n<| c |>\nPlease note that this solution\
    \ doesn't work if the array keys are the same!\n<|/ c |>\n<| a tags=php,array-difference,arrays\
    \ |>\nYou can try this :\n<code>\n$arr = array('a'=>1,'b'=>2,'c'=>3,'d'=>4);\n\
    $arr2 = array('a'=>'test','b'=>'test2','c'=>'test3','d'=>'test4');\n$arr3 = array();\n\
    $arr3[] = $arr['a'];\n$arr3[] = $arr['b'];\n$arr3[] = $arr['c'];\n$arr3[] = $arr['d'];\n\
    foreach($arr2 as $key=>$val){\n   $arr3[] = $arr2[$key];\n}\n$arr3[] = $arr['d'];\n\
    $arr3 = array_unique($arr3);\nprint_r($arr3);\n</code>\nOutput\n<code>\nArray\n\
    (\n    [0] => 1\n    [1] => test\n    [2] => 2\n    [3] => test2\n    [4] => 3\n\
    \    [5] => test3\n    [6] => 4\n    [7] => test4\n)\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n+1 because this also allows you to use different values than the\
    \ original array (which could be needed if your array keys are numeric).\n<|/\
    \ c |>\n<| c |>\nThe \"array_unique\" line ", "  $l1 = array_unique($l1);\n  $l2\
    \ = array_unique($l2);\n\n  $l1 = array_values($l1);\n  $l2 = array_values($l2);\n\
    \n  return array_intersect($l1, $l2);\n}\n", "  sort($l1);\n  sort($l2);\n  $intersect\
    \ = array_intersect($l1, $l2);\n  if (count($intersect)) {\n    return array_unique($intersect);\n\
    \  }\n  return array();\n}", "    $common = [];\n    foreach($l1 as $key => $value)\
    \ {\n        if (in_array($value, $l2)) {\n            $common[] = $value;\n \
    \       }\n    }\n    return $common;\n}\n</code>\n<|/ a tags=sorting,php |>\n\
    <| c |>\nThis is an elegant solution and I love it. I think it's really simple\
    \ to understand and I can implement it easily. Thanks so much!\n<|/ c |>\n<| c\
    \ |>\n, glad I could help. If this answer solved your problem, you can click the\
    \ checkmark next to the answer to \"accept\" it. You can find out more about that\
    \ here: https://stackoverflow.com/help/someone-answers\n<|/ c |>\n<| a dscore=0\
    \ tags=sorting,php |>\n<code>\n<?php\n$array1 = array(1, 4, 3, 34, 653, 2, 5);\n\
    $array2 = array(5, 7, 1, 5, 9, 653, 121);\n$array3 = array_intersect($array1,$array2);\n\
    $array4 = array_diff($array1,$array2);\nprint_r($array3);\nprint_r($array4);\n\
    </code>\n<|/ a |>\n<| c |>\nThis would not produce the desired output as it will\
    \ produce an intersection & difference of $array1 and $array2. See my answer for\
    \ more details.\n<|/ c |>\n<| a tags=sorting,php dscore=0 |>\n<code>", "  if (count($l1)\
    \ != count($l2)) {\n    return array();\n  }\n\n  $a = array_intersect($l1, $l2);\n\
    \  $b = array_diff($l1, $l2);\n  return array_merge($a, $b);\n}\n", "  $l1 = array_reverse($l1);\n\
    \  $l2 = array_reverse($l2);\n\n  $common = array();\n\n  // Loop through lists.\n\
    \  foreach ($l1 as $key => $value) {\n    foreach ($l2 as $key2 => $value2) {\n\
    \      // If both lists have the current value at the same key, remove it.\n \
    \     if ($key == $key2) {\n        unset($l1[$key]);\n      }\n    }\n  }\n\n\
    \  // Add the remaining values from list 2.\n  foreach ($l2 as $value) {\n   \
    \ $common[] = $value;\n  }\n\n  return array_reverse($common);\n}\n", "  $common\
    \ = array();\n  $length_1 = count($l1);\n  $length_2 = count($l2);\n  for($i =\
    \ 0; $i < $length_1; $i++) {\n    for($j = 0; $j < $length_2; $j++) {\n      if\
    \ ($l1[$i] === $l2[$j]) {\n        $common[] = $l1[$i];\n        break;\n    \
    \  }\n    }\n  }\n  return $common;\n}\n", "  $set = array_intersect($l1, $l2);\n\
    \  $list = array_diff($l1, $set);\n  $result = array_diff($l2, $list);\n  return\
    \ array_merge($list, $result);\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a dscore=0\
    \ |>\nYou can do it very easily with array_intersect() and array_diff() \n<code>\n\
    $firstArr = array(4, 6, 8, 10, 13, 15, 17);\n$secondArr = array(3, 6, 9, 12);\n\
    $result = array_intersect($firstArr, $secondArr);\n\nprint_r($result); // Array\
    \ ( [0] => 6 [1] => 9 )\n\n$result = array_diff($firstArr, $secondArr);\n\nprint_r($result);\
    \ // Array ( [0] => 4 [1] => 5 [2] => 8 [3] => 10 [4] => 13 [5] => 15 [6] => 17\
    \ )\n</code>\n<|/ a tags=php,arrays |>\n<| a tags=php,arrays |>\nI did it without\
    \ loops\n<code>\n$array1 = array_map('intval', explode(\",\", $array1));\n$array2\
    \ = array_map('intval', explode(\",\", $array2));\n", "    $intersection = array_intersect($l1,\
    \ $l2);\n    return array_unique($intersection);\n}\n", "  $common = array();\n\
    \  foreach($l1 as $value) {\n    if(in_array($value, $l2)) {\n      $common[]\
    \ = $value;\n    }\n  }\n  return $common;\n}\n", "  $common = [];\n  foreach\
    \ ($l1 as $v) {\n    if (in_array($v, $l2)) {\n      $common[] = $v;\n    }\n\
    \  }\n  foreach ($l2 as $v) {\n    if (in_array($v, $l1)) {\n      $common[] =\
    \ $v;\n    }\n  }\n  return array_unique($common);\n}", "    if ($l1 == $l2) {\n\
    \        return $l1;\n    }\n\n    // Return sorted unique common elements for\
    \ two lists.\n    // >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121])\n    // [1, 5, 653]\n    if ($l1 == null || $l2 == null) {\n        return\
    \ array();\n    }\n    $ret = array();\n    foreach (array_unique($l1) as $val)\
    \ {\n        $ret[] = $val;\n    }\n    foreach (array_unique($l2) as $val) {\n\
    \        $ret[] = $val;\n    }\n    sort($ret);\n    return $ret;\n}\n", "  $common\
    \ = array();\n  foreach ($l1 as $item) {\n    if (!in_array($item, $common)) {\n\
    \      $common[] = $item;\n    }\n  }\n  foreach ($l2 as $item) {\n    if (!in_array($item,\
    \ $common)) {\n      $common[] = $item;\n    }\n  }\n  return $common;\n}\n\n\
    /**\n * Merge two lists.\n *\n * Returns an array containing the items present\
    \ in both lists.\n *\n * @since 2.7.0\n *\n * @param array $list1 First list.\n\
    \ * @param array $list2 Second list.\n * @return array Merged list.\n */", " \
    \ foreach ($l1 as $k => $v) {\n    if (isset($l2[$k]) && $v === $l2[$k]) {\n \
    \     unset($l1[$k]);\n      unset($l2[$k]);\n    }\n  }\n  return array_merge(array_values($l1),\
    \ array_values($l2));\n}", "  return array_unique(array_merge($l1, $l2));\n}\n",
  "  if ($l1 === $l2)\n    return $l1;\n  $ret=array();\n  $i=0;\n  while ($i < min(count($l1),count($l2)))\n\
    \  {\n    $ret[]=$l1[$i];\n    $ret[]=$l2[$i];\n    $i++;\n  }\n  return array_unique($ret);\n\
    }\n", "  $set1 = array_map(\"intval\", $l1);\n  $set2 = array_map(\"intval\",\
    \ $l2);\n  return array_intersect($set1, $set2);\n}\n", "  $a = array_unique($l1);\n\
    \  $b = array_unique($l2);\n  $c = array_intersect($a, $b);\n  sort($c);\n  return\
    \ array_values($c);\n}", "  $set1 = new SplDoublyLinkedList();\n  $set2 = new\
    \ SplDoublyLinkedList();\n  foreach ($l1 as $item) {\n    $set1->append($item);\n\
    \  }\n  foreach ($l2 as $item) {\n    $set2->append($item);\n  }\n\n  return array_unique(array_merge($set1->toArray(),\
    \ $set2->toArray()));\n}\n", "  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n\
    \  // Sort lists.\n  sort($l1);\n  sort($l2);\n  $intersection = array_intersect($l1,\
    \ $l2);\n  $common = array_diff($l1, $l2);\n  return array_values(array_unique($intersection));\n\
    }\n", "    $result = array();\n    foreach ($l1 as $item) {\n        if (!in_array($item,\
    \ $l2)) {\n            $result[] = $item;\n        }\n    }\n    return $result;\n\
    }\n</code>\n<|/ a tags=arrays,sorting,php,arrays dscore=0 |>\n<| a dscore=0 |>\n\
    I suppose a possible way is to make an array with all the possible orders of elements\
    \ and then count the occurrences of each order.\nThe code would be something like\
    \ this (untested and by no means optimized ;)):\n<code>", "  // First sort the\
    \ lists.\n  $l1 = array_merge($l1, $l2);\n  sort($l1);\n  sort($l2);\n  $result\
    \ = [];\n  for ($i = 0; $i < count($l1); $i++) {\n    if (isset($l2[$i]) && $l1[$i]\
    \ === $l2[$i]) {\n      $result[] = $l1[$i];\n    }\n  }\n  return $result;\n}",
  "  $common = array();\n  foreach ($l1 as $elem) {\n    if (in_array($elem, $l2))\
    \ {\n      $common[] = $elem;\n    }\n  }\n  return array_unique($common);\n}",
  "  if (is_null($l1) or is_null($l2)) {\n    return null;\n  }\n\n  $common = array();\n\
    \  foreach ($l1 as $key => $value) {\n    if (in_array($value, $l2)) {\n     \
    \ $common[] = $value;\n    }\n  }\n  foreach ($l2 as $key => $value) {\n    if\
    \ (in_array($value, $l1)) {\n      $common[] = $value;\n    }\n  }\n\n  return\
    \ array_unique($common);\n}\n", "    // Return sorted unique common elements for\
    \ two lists.\n    $common = array_intersect($l1, $l2);\n    sort($common);\n \
    \   return $common;\n}", "  if (count($l1) > count($l2)) {\n    $l2 = array_slice($l2,\
    \ 0, -count($l1));\n  }\n  $output = [];\n  $l2 = array_reverse($l2);\n  foreach\
    \ ($l1 as $v) {\n    if (in_array($v, $l2)) {\n      $output[] = $v;\n    }\n\
    \  }\n  return $output;\n}\n</code>\n<|/ a |>\n<| c |>\nI didn't think about using\
    \ `array_diff`. +1\n<|/ c |>\n<| c |>\nVery nice! This is definitely the best\
    \ solution so far that I've seen.\n<|/ c |>\n<| c |>\n`array_diff` compares values\
    \ by reference (which doesn't work if your array values aren't numeric). The `array_diff_key`\
    \ function should be used instead.\n<|/ c |>\n<| a dscore=5 |>\nHere's a slight\
    \ variation of Marcelo's answer that doesn't have to use any loops:\n<code>\n\
    $common = array_intersect($array1, $array2);\n$common = array_unique($common);\n\
    </code>\narray_intersect will give you an array that contains a subset of $array1\
    \ and $array2. If $array1 contains elements $array2 doesn't have then those elements\
    \ will be excluded. \nThen array_unique will filter out any duplicates.\n<|/ a\
    \ tags=arrays,php |>\n<| c |>\nVery nice, and much quicker than any of the other\
    \ suggestions.\n<|/ c |>\n<| c |>\nFor future readers: this is now implemented\
    \ as a built-in [array_intersect()](http://www.php.net/array_intersect).\n<|/\
    \ c |>\n<| c |>\nThis is really nice, thank you!\n<|/ c |>\n<| c |>\narray_intersect\
    \ doesn't work when comparing numeric arrays for me. Just use array_diff with\
    \ array_unique and array_intersect after array_diff if you're not concerned with\
    \ duplicates.\n<|/ c |>\n<| c |>\narray_diff and array_intersect will do exactly\
    \ the same: compare each element of $array1 with each element of $array2 and return\
    \ the set difference between these two. What do you have in mind?\n<|/ c |>\n\
    <| a tags=arrays,php |>\nThis should do it...\n<code>", "  if (!count($l1) ||\
    \ !count($l2)) {\n    return array();\n  }\n\n  $result = array();\n  $i     \
    \ = 0;\n  $j      = 0;\n\n  while ($i < count($l1) && $j < count($l2)) {\n   \
    \ if ($l1[$i] == $l2[$j]) {\n      $result[] = $l1[$i];\n      $i++;\n      $j++;\n\
    \      continue;\n    }\n\n    if ($l1[$i] < $l2[$j]) {\n      $i++;\n      continue;\n\
    \    }\n\n    $result[] = $l2[$j];\n    $j++;\n  }\n\n  return $result;\n}", " \
    \ $intersect = array_intersect($l1, $l2);\n  $result = array_unique($intersect);\n\
    \  sort($result);\n  return $result;\n}\n\n/**\n * Returns the absolute value\
    \ of the integer.\n * @param $x\n * @return int\n */", "  $set = array();\n  foreach\
    \ ($l1 as $v) if (!in_array($v, $l2)) $set[] = $v;\n  return $set;\n}\n", "  \
    \  $common = [];\n    $l1 = sort($l1);\n    $l2 = sort($l2);\n    foreach ($l1\
    \ as $key => $val) {\n        if (in_array($val, $l2)) {\n            $common[]\
    \ = $val;\n            unset($l1[$key]);\n        }\n    }\n    return $common;\n\
    }\n</code>\n<|/ a tags=arrays,php |>\n<| c |>\nIt's interesting that this solution\
    \ can still be improved in PHP 7.4.\n<|/ c |>\n<| c |>\nI used [array_intersect()](https://php.net/manual/en/function.array-intersect.php)\
    \ instead, which is in PHP7.4.\n<|/ c |>\n<| c |>\nIn case someone wants PHP 7.4\
    \ or higher: `sort(array_flip($a));` and `sort(array_flip($b));` should be replaced\
    \ with `sort(array_flip(array_flip($a)));` and `sort(array_flip(array_flip($b)));`\n\
    <|/ c |>\n<| a tags=arrays,php dscore=2 |>\nI think you're looking for a function\
    \ like the one found in this post that returns the intersection.\n<code>", " \
    \   sort($l1);\n    sort($l2);\n    $result = [];\n    $j = 0;\n    $n1 = count($l1);\n\
    \    $n2 = count($l2);\n    while ($n1 > 0 && $n2 > 0) {\n        if ($l1[$j]\
    \ == $l2[0]) {\n            $result[] = $l1[$j++];\n            --$n1;\n     \
    \       --$n2;\n        } elseif ($l1[$j] < $l2[0]) {\n            $n2 = $n2-1;\n\
    \        } else {\n            $n1 = $n1-1;\n        }\n    }\n    return $result;\n\
    }\n", "  $i = $j = 0;\n  $count = count($l1);\n  $l1[$i] = $l2[$j];\n  while (++$i\
    \ < $count) {\n    if ($l1[$i] == $l2[$j]) {\n      $i++;\n      $j++;\n    }\
    \ else {\n      $l1[$i] = $l2[$j];\n    }\n  }\n  return array_slice($l1, 0, $i);\n\
    }", "    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n\n    $intersect\
    \ = array_intersect($l1, $l2);\n    if (count($intersect) !== count($l1) || count($intersect)\
    \ !== count($l2)) {\n        return [];\n    }\n    return $intersect;\n}\n",
  "\t$common = array();\n\n\tforeach($l1 as $val) {\n\t\tforeach($l2 as $key2) {\n\
    \t\t\tif ($val === $key2) {\n\t\t\t\t$common[] = $val;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t}\n\n\treturn array_unique($common);\n}\n", "  $r1 = $r2 = array();\n\
    \  for ($i = 0; $i < count($l1); $i++) {\n    $r1[$i] = $l1[$i];\n  }\n  for ($i\
    \ = 0; $i < count($l2); $i++) {\n    $r2 = array_intersect_key($l1, $l2, $r2);\n\
    \  }\n  return array_values(array_merge($r1, $r2));\n}", "    sort($l1);\n   \
    \ sort($l2);\n    $set1 = array();\n    $set2 = array();\n    foreach ($l1 as\
    \ $item) {\n        if (!in_array($item, $set1)) {\n            $set1[$item] =\
    \ 1;\n            $set2[$item] = 1;\n        } else {\n            $set1[$item]\
    \ += 1;\n        }\n    }\n    foreach ($l2 as $item) {\n        if (!in_array($item,\
    \ $set2)) {\n            $set2[$item] = 1;\n            $set1[$item] = 1;\n  \
    \      } else {\n            $set2[$item] += 1;\n        }\n    }\n    return\
    \ array_keys(array_filter($set1, function ($v) use ($set2) {\n        return $v\
    \ === array_sum($set2);\n    }));\n}", "    // Store a common array that we'll\
    \ return in case there are duplicates.\n    $common = array();\n    // Loop through\
    \ lists.\n    foreach ($l1 as $key => $val) {\n        if ($val == $l2[$key])\
    \ { $common[$key] = $val; } else { break; }\n    }\n    // Return sorted unique\
    \ list.\n    return array_unique($common);\n}\n</code>\nIf you want the list to\
    \ be ordered, then you can sort the list as it is returned by the function.\n\
    <|/ a dscore=4 |>\n<| c |>\nIt would be great to know which solution is faster\
    \ if the arrays are huge.\n<|/ c |>\n<| c |>\nI believe that this solution is\
    \ O(n^2)\n<|/ c |>\n<| a dscore=3 tags=arrays,php |>\nYou can use array_intersect()\
    \ for this\n<code>\n<?php\n$array1=array(1,2,3,4,5);\n$array2=array(1,2,3);\n\
    $result=array_intersect($array1, $array2);\nprint_r($result);", "    $result =\
    \ array();\n    foreach ($l1 as $key => $value) {\n        if (in_array($value,\
    \ $l2)) {\n            $result[] = $value;\n        }\n    }\n    return $result;\n\
    }\n", "  return array_unique($l1) & array_unique($l2);\n}", "    $result = array();\n\
    \    foreach ($l1 as $k => $v) {\n        if (!array_key_exists($k, $l2)) {\n\
    \            $result[$k] = $v;\n        } else {\n            if ($v != $l2[$k])\
    \ {\n                return 0;\n            }\n        }\n    }\n    return $result;\n\
    }\n", "    if ($l1 === $l2) {\n        return $l1;\n    }\n\n    $result = array();\n\
    \n    foreach ($l1 as $item) {\n        if (in_array($item, $l2)) {\n        \
    \    $result[] = $item;\n        }\n    }\n\n    return $result;\n}\n\n$firstnames\
    \ = common(\n    array('Michelle', 'Kathryn', 'James', 'Jessica'),\n    array('Michelle',\
    \ 'Johnson', 'James', 'Kathryn', 'Jessica')\n);\nprint_r($firstnames);\n", " \
    \ $intersect = array_intersect($l1, $l2);\n  if (empty($intersect)) {\n    return\
    \ array();\n  }\n  $common = array();\n  $size = min(count($l1), count($l2));\n\
    \  for ($i = 0; $i < $size; $i++) {\n    if (!in_array($l1[$i], $intersect)) {\n\
    \      $common[] = $l1[$i];\n    }\n  }\n  return $common;\n}\n", "    return\
    \ array_unique(array_filter(array_merge($l1, $l2), function($item) {\n       \
    \ return $item != null;\n    }));\n}\n", "  $result = array();\n  $l1 = array_keys($l1);\n\
    \  $l2 = array_keys($l2);\n  $l1 = array_flip($l1);\n  $l2 = array_flip($l2);\n\
    \  foreach($l1 as $k) {\n    if ($l2[$k]) {\n      $result[] = $k;\n    }\n  }\n\
    \  return $result;\n}\n", "    $common = [];\n    foreach ($l1 as $key => $value)\
    \ {\n        if (in_array($value, $l2)) {\n            $common[] = $value;\n \
    \       }\n    }\n    return $common;\n}\n", "    return array_filter(array_unique(array_merge(\n\
    \        array_diff($l1, $l2), array_diff($l2, $l1))), function($item) use ($l1,\
    \ $l2) {\n        return $item === $l1 || $item === $l2;\n    });\n}\n", "   \
    \ // Copy lists.\n    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n\
    \    // Remove duplicates.\n    sort($l1);\n    sort($l2);\n    // Return sorted\
    \ unique elements. Duplicates removed.\n    return array_intersect($l1, $l2);\n\
    }\n", "    if (!is_array($l1) || !is_array($l2)) {\n        return false;\n  \
    \  }\n    $n1 = count($l1);\n    $n2 = count($l2);\n    $common = array_merge(array_unique($l1),\
    \ array_unique($l2));\n    if ($n1 != $n2) {\n        return false;\n    }\n \
    \   return array_intersect($common, $common);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    It isn't clear where this is supposed to go - the OP needs to clarify what they\
    \ are expecting by showing the expected result.\n<|/ c |>\n<| c |>\nI don't see\
    \ anything obviously wrong with this code, unless the OP has unusual circumstances.\
    \ Perhaps there's a bug that we could address here.\n<|/ c |>\n<| c |>\nThe only\
    \ other thing I can think of is that there may be a bug in the PHP implementation\
    \ which is causing the issue and it is unlikely to be related to my code (as far\
    \ as I can tell). Perhaps some test case and sample data will help.\n<|/ c |>\n\
    <| c |>\nThe OP wants the result to be sorted too.  You just give the result as\
    \ is.\n<|/ c |>\n<| a tags=sorting,php dscore=0 |>\nI have written this piece\
    \ of code. You can use it.\n<code>", "\t$common = array();\n\t\n\tforeach ($l1\
    \ as $k => $v) if (!in_array($v, $l2)) $common[] = $v;\n\tforeach ($l2 as $k =>\
    \ $v) if (!in_array($v, $l1)) $common[] = $v;\n\t\n\treturn $common;\n}\n", " \
    \ // Iterate through elements. If they don't exist, create them\n  foreach ($l2\
    \ as $key => $value) {\n    if (!array_key_exists($key, $l1)) {\n      $l1[$key]\
    \ = $value;\n    }\n  }\n\n  return array_keys(array_flip($l1));\n}\n\n$common\
    \ = array_map(\n  // Convert to array\n  function($el) {\n    return explode(\"\
    :\", $el);\n  },\n  // Make unique for each\n  array_unique(\n    array_map(\n\
    \      // Remove duplicates first\n      function($el) {\n        return implode(\"\
    :\", array_unique(explode(\":\", $el)));\n      },\n      // Split to arrays\n\
    \      explode(\"\\n\", $contents)\n    )\n  )\n);", "  $result = array();\n \
    \ $i1 = 0;\n  $i2 = 0;\n\n  while ($i1 < count($l1) && $i2 < count($l2)) {\n \
    \   if ($l1[$i1] == $l2[$i2]) {\n      $result[] = $l1[$i1];\n      $i1++;\n \
    \     $i2++;\n      continue;\n    }\n    if ($l1[$i1] < $l2[$i2]) {\n      $i2++;\n\
    \    } else {\n      $i1++;\n    }\n  }\n  return $result;\n}", "  $common = [];\n\
    \  foreach ($l1 as $key => $value) {\n    if (isset($l2[$key])) {\n      if ($value\
    \ == $l2[$key]) {\n        $common[$key] = $value;\n      }\n    }\n  }\n  return\
    \ $common;\n}", "  list($l1, $l2) = is_array($l1) ? $l1 : func_get_args();\n \
    \ $common = array_intersect($l1, $l2);\n  if (count($common)) {\n    uasort($common,\
    \ function($a, $b) {\n      return $a < $b ? -1 : 1;\n    });\n    return $common;\n\
    \  }\n}\n", "  if (empty($l1) || empty($l2)) {\n    return array();\n  }\n\n \
    \ $i1 = array_keys($l1);\n  $i2 = array_keys($l2);\n  $k1 = count($i1);\n  $k2\
    \ = count($i2);\n  $i = 0;\n\n  while (count($i1) && ($i < $k1 || $i < $k2)) {\n\
    \    if ($i1[$i] == $i2[$i]) {\n      $i++;\n      continue;\n    }\n\n    if\
    \ ($i1[$i] < $i2[$i]) {\n      $return[$i1[$i]] = $i1[$i];\n      $i1[$i] = $i1[$i];\n\
    \    } else {\n      $return[$i2[$i]] = $i2[$i];\n      $i2[$i] = $i2[$i];\n \
    \   }\n\n    if ($i == $k1) {\n      $return = array_merge($return, $i1);\n  \
    \    break;\n    }\n    if ($i == $k2) {\n      $return = array_merge($return,\
    \ $i2);\n      break;\n    }\n  }\n\n  if (count($return) != $k1 && count($return)\
    \ != $k2) {\n    return array();\n  }\n\n  return $return;\n}\n", "    $common\
    \ = [];\n    $l1 = array_keys($l1);\n    $l2 = array_keys($l2);\n\n    foreach\
    \ ($l1 as $key => $value) {\n        if (isset($l2[$key])) {\n            do {\n\
    \                $c = $value;\n                $value = $l2[$key];\n         \
    \       $l2[$key] = $c;\n            } while ($c === $value);\n            $common[]\
    \ = $value;\n        }\n    }\n\n    return $common;\n}\n", "    $common = [];\n\
    \    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n    foreach($l1 as\
    \ $key => $item) {\n        if(in_array($item, $l2)) {\n            $common[]\
    \ = $item;\n            unset($l1[$key]);\n        }\n    }\n    return $common;\n\
    }", "    return array_unique(array_merge(\n        array_diff(array_unique($l1),\
    \ array_unique($l2)), \n        array_diff($l1, $l2)\n    ));\n}\n", "    $l =\
    \ max(count($l1), count($l2));\n    $result = [];\n    for($i = 0; $i < $l; $i++)\
    \ {\n        if($l1[$i] === $l2[$i]) {\n            $result[] = $l1[$i];\n   \
    \     }\n    }\n    return $result;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\n\
    This is probably the best solution so far. I'm still waiting for someone to come\
    \ up with an answer without using a loop :)\n<|/ c |>\n<| c |>\nThis is the best\
    \ solution so far. It would be nice if there was a way to optimize this algorithm\
    \ to use less memory than it currently does.\n<|/ c |>\n<| c |>\n: Thanks. I added\
    \ a memory optimized solution. Unfortunately PHP doesn't seem to offer a good\
    \ way to optimize this algorithm. http://stackoverflow.com/a/39626581/2532147\n\
    <|/ c |>\n<| c |>\nThanks for sharing. I was wondering if your solution would\
    \ have a different time complexity than mine. Is it possible to make my solution\
    \ linear? The one that uses O(n^2) is supposed to take O(n).\n<|/ c |>\n<| c |>\n\
    : I didn't expect it to *have* a different time complexity. I expect my solution\
    \ to be faster than yours. However, my solution is *more* memory-efficient than\
    \ yours. Since you use `$l1[$i] === $l2[$i]` it *requires* more memory. That difference\
    \ is probably negligible, and would only be significant if the arrays are huge.\
    \ But it *is* an important consideration.\n<|/ c |>\n<| a tags=php |>\nI really\
    \ don't know if there is an elegant way to do it but you can try this way\n<code>\n\
    <?php\n\n$arr1 = [1,2,3,4,5,6,7,8,9];\n$arr2 = [3,5,6,7,8,9,1,4,2];\n\n$unique\
    \ = array_diff(array_intersect($arr1, $arr2), array_intersect($arr2, $arr1));\n\
    \nprint_r($unique);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => 1\n    [1]\
    \ => 2\n    [2] => 3\n    [3] => 4\n    [4] => 5\n    [5] => 6\n    [6] => 7\n\
    \    [7] => 8\n    [8] => 9\n)\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe solution\
    \ with array_diff works but it is O(n^2), so it's better than mine solution in\
    \ performance terms. Thanks ", "    $set = array();\n    foreach ($l1 as $k =>\
    \ $v) {\n        if (!in_array($v, $l2))\n            $set[$k] = $v;\n    }\n\
    \    return $set;\n}\n</code>\n<|/ a |>\n<| c |>\nIt's a nice solution but I think\
    \ the O(n) algorithm is preferable\n<|/ c |>\n<| c |>\nI'm happy to have a downvote\
    \ with a comment explaining why, but I can't because I don't understand why the\
    \ O(n) algorithm is preferred over the O(nlogn) algorithm.  I agree that the O(n)\
    \ algorithm is better, but I don't see why it would be O(nlogn)\n<|/ c |>\n<|\
    \ c |>\nI think it's because if you sort both arrays, you're essentially doing\
    \ the same amount of work as `array_merge`... but with one less function call,\
    \ and it takes more memory.\n<|/ c |>\n<| c |>\n, I'm not saying it's faster,\
    \ but it's more readable, and it's definitely faster. At least, I think it is.\n\
    <|/ c |>\n<| c |>\nAh, I see the advantage of your version. Sort both arrays once\
    \ then compare them, this has O(n) complexity. I'll probably go with your solution\
    \ for my problem, thanks for your answer :)\n<|/ c |>\n<| a |>\nHow about using\
    \ array_diff and array_intersect?\n<code>\n$array1 = array(1, 2, 3, 4, 5);\n$array2\
    \ = array(2, 3, 4, 5);\n$array3 = array(1, 2, 3);\n\n$intersectedElements = array_intersect($array1,\
    \ $array2);\n$diff = array_diff($array3, $intersectedElements);\n</code>\n<|/\
    \ a tags=array-difference,php,arrays,sorting dscore=5 |>\n<| c |>\nThis is pretty\
    \ good too, it does it in O(n) and is probably the fastest too.\n<|/ c |>\n<|\
    \ c |>\nI didn't know it does it so well! I guess this method is faster!\n<|/\
    \ c |>\n<| c |>\n`array_intersect($array1, $array2, $array3)` can be written as\
    \ `array_intersect($array1, array_merge($array2, $array3))`.\n<|/ c |>\n<| a tags=array-difference,php,arrays,sorting\
    \ |>\n<code>\n$result = array_diff($array1, $array2);\n</code>\nor\n<code>\n$result\
    \ = array_diff($array2, $array1);\n</code>\n<|/ a dscore=", "    $common = [];\n\
    \    foreach ($l1 as $k => $v) {\n        if (isset($l2[$k]) && $v == $l2[$k])\
    \ {\n            $common[] = $v;\n            unset($l2[$k]);\n        }\n   \
    \ }\n    return $common;\n}\n", "    $l1 = array_reverse($l1);\n    $l2 = array_reverse($l2);\n\
    \    $common = array();\n\n    foreach ($l1 as $key => $value) {\n        if (array_search($value,\
    \ $l2) === false) {\n            $common[] = $value;\n        }\n    }\n\n   \
    \ return array_reverse($common);\n}\n", "    // If the lists are empty, return\
    \ an empty list\n    if ($l1 == [] || $l2 == []) {\n        return [];\n    }\n\
    \n    $l1 = array_flip($l1);\n    $l2 = array_flip($l2);\n\n    // Sort both lists\
    \ and keep only unique elements.\n    $l1 = array_intersect_key($l1, $l2);\n \
    \   $l2 = array_intersect_key($l2, $l1);\n\n    return array_keys($l1);\n}\n</code>\n\
    <|/ a tags=arrays,sorting,php dscore=0 |>\n<| a dscore=0 |>\nHere's a function\
    \ that returns the difference between two arrays in descending order.\n<code>",
  "  // Sort the lists.\n  if (!is_array($l1) || !is_array($l2)) {\n    throw new\
    \ Exception('Lists must be arrays');\n  }\n  sort($l1);\n  sort($l2);\n\n  //\
    \ Merge the lists.\n  $lc = array();\n  $i = 0;\n  foreach ($l1 as $key => $value)\
    \ {\n    $lc[$key] = $value;\n    if (isset($l2[$key]) && $lc[$key] == $l2[$key])\
    \ {\n      $lc[$key] = $key;\n      $i++;\n    }\n  }\n  return $lc;\n}\n", " \
    \   if (!is_array($l1) || !is_array($l2)) return array();\n    $l1 = array_map('intval',\
    \ $l1);\n    $l2 = array_map('intval', $l2);\n    return array_intersect($l1,\
    \ $l2);\n}\n", "  $u1 = array();\n  $u2 = array();\n  foreach ($l1 as $i => $v)\
    \ {\n    if (!in_array($v, $u1)) {\n      $u1[] = $v;\n    }\n  }\n  foreach ($l2\
    \ as $i => $v) {\n    if (!in_array($v, $u2)) {\n      $u2[] = $v;\n    }\n  }\n\
    \  return array_intersect($u1, $u2);\n}", "    $count = count($l1);\n    $result\
    \ = [];\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = $i + 1; $j <\
    \ $count; $j++) {\n            if ($l1[$i] == $l2[$j]) {\n                $result[]\
    \ = $l1[$i];\n                break;\n            }\n        }\n    }\n    return\
    \ $result;\n}\n", "    $ret = [];\n    foreach ($l1 as $v) {\n        if (in_array($v,\
    \ $l2)) {\n            $ret[] = $v;\n        }\n    }\n    return $ret;\n}\n",
  "  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n  return array_intersect($l1,\
    \ $l2);\n}\n", "  $common = array();\n  $i1 = 0; $i2 = 0;\n  while (($i1 < $l1)\
    \ || ($i2 < $l2)) {\n    if ($i1 < $l1) {\n      if ($i2 < $l2) {\n        if\
    \ ($l1[$i1] == $l2[$i2]) {\n          $common[$i1] = $l1[$i1];\n          $i1++;\n\
    \          $i2++;\n        } else {\n          $common[] = $l1[$i1];\n       \
    \   $i1++;\n        }\n      } else {\n        $common[] = $l1[$i1];\n       \
    \ $i1++;\n      }\n    } else {\n      if ($i2 < $l2) {\n        $common[] = $l2[$i2];\n\
    \        $i2++;\n      } else {\n        $common[] = $l2[$i2];\n        $i2++;\n\
    \      }\n    }\n  }\n  return $common;\n}", "    $common = array();\n    foreach\
    \ ($l1 as $key => $value) {\n        if (in_array($value, $l2)) {\n          \
    \  $common[] = $value;\n        }\n    }\n    return $common;\n}\n", "  $set =\
    \ array_unique(array_merge($l1, $l2));\n  sort($set);\n  return $set;\n}\n</code>\n\
    This can be used for any kind of list, not only arrays.\n<|/ a dscore=5 |>\n<|\
    \ c |>\nThis is awesome. I'm running into an issue where the array that is being\
    \ returned has empty values. Is there a way to remove the empty values?\n<|/ c\
    \ |>\n<| c |>\nThanks for this. It's useful for getting a unique list of users\
    \ from an array of `User` instances. However, I have two arrays, and I want an\
    \ array of unique items from each array. `array_merge($array1, $array2);` returns\
    \ an array which contains duplicates between the two input arrays. I'd love to\
    \ see a solution that doesn't rely on sorting.\n<|/ c |>\n<| c |>\nI believe this\
    \ answer only works for an exact match of arrays. If the arrays are slightly different\
    \ in contents, array_intersect won't find it\n<|/ c |>\n<| c |>\nI believe the\
    \ point of this answer was to find unique items across two arrays. `array_intersect_assoc()`\
    \ and `array_intersect($array1, $array2)` will find the unique items, but only\
    \ if the arrays contain the same data in the same order. `array_intersect()` returns\
    \ duplicate items if any two items in `array_intersect($array1, $array2)` have\
    \ matching keys with identical values, while `array_intersect_assoc()` returns\
    \ duplicate items if any two items in `array_intersect_assoc($array1, $array2)`\
    \ have matching keys with identical values.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. Because it works even if there are differences within the\
    \ arrays. But it gives a wrong answer for `array(1, 2, 3, 4)` and `array(4, 1,\
    \ 2, 3)`\n<|/ c |>\n<| a tags=arrays,php,comparison |>\nYou could try something\
    \ like this:\n<code>\n<?php\n", "    $common = array();\n    $len = max(count($l1),\
    \ count($l2));\n    for ($i = 0; $i < $len; $i++) {\n        if ($l1[$i] == $l2[$i])\
    \ {\n            $common[] = $l1[$i];\n        }\n    }\n    return $common;\n\
    }", "    $l1 = array_filter($l1);\n    $l2 = array_filter($l2);\n    return array_unique(array_merge($l1,\
    \ $l2));\n}\n</code>\n<|/ a tags=php,arrays |>\n<| a tags=php,arrays dscore=0\
    \ |>\nThis worked for me in php:\n<code>\n$array1 = array(2,4,6,8,9);\n$array2\
    \ = array(6,8,7,9,4);\n$array3 = array_intersect($array1, $array2);\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nAnother way without using any php built-in functions:\n\
    <code>\n$a = array(1, 2, 3, 4);\n$b = array(2, 3, 6, 7);\n\n$result = array();\n\
    \nforeach ($a as $key => $value) {\n    foreach ($b as $keyb => $valueb) {\n \
    \       if ($valueb == $value) {\n            $result[] = $value;\n        }\n\
    \    }\n}\n\nprint_r($result);\n</code>\n<|/ a tags=php,arrays |>\n<| a dscore=0\
    \ |>\n<code>\n<?php \n\n$first=array(1,2,3,4,5,6,7,8,9,10);\n$second=array(1,2,3,4,5,6,7,8,9,10);\n\
    $third=array(1,2,3,4,5,6,7,8,9,10);\n\n$first=array_unique($first);\n$second=array_unique($second);\n\
    $third=array_unique($third);\n\n$result=array_diff($first,$second);\n$result=array_diff($result,$third);\n\
    $result=array_values($result);\n\nprint_r($result);\n", "  if (is_array($l1) &&\
    \ is_array($l2)) {\n    return array_intersect($l1, $l2);\n  }\n\n  $l1 = array_keys($l1);\n\
    \  $l2 = array_keys($l2);\n  if (count($l1) > count($l2)) {\n    $l2 = array_slice($l2,\
    \ array_fill(0, count($l2), 0));\n  } else {\n    $l1 = array_slice($l1, array_fill(0,\
    \ count($l1), 0));\n  }\n\n  $l1_count = count($l1);\n  $l2_count = count($l2);\n\
    \  $i = $j = 0;\n  $l3 = array();\n  while ($i < $l1_count || $j < $l2_count)\
    \ {\n    if ($i < $l1_count) {\n      if (isset($l2[$j]) && $l2[$j] === $l1[$i])\
    \ {\n        $l3[] = $l1[$i];\n        $j++;\n      } else {\n        $i++;\n\
    \      }\n    }\n    if ($j < $l2_count) {\n      if (isset($l1[$i]) && $l1[$i]\
    \ === $l2[$j]) {\n        $i++;\n      } else {\n        $j++;\n      }\n    }\n\
    \  }\n  return $l3;\n}\n", "    if ($l1 == $l2) return array();\n    $common =\
    \ array();\n    for ($i = 0; $i < min(count($l1), count($l2)); $i++) {\n     \
    \   if ($l1[$i] == $l2[$i]) {\n            $common[] = $l1[$i];\n        }\n \
    \   }\n    return $common;\n}\n", "    $ret = [];\n    foreach ($l1 as $i) {\n\
    \        if (in_array($i, $l2)) {\n            $ret[] = $i;\n        }\n    }\n\
    \    return $ret;\n}", "  usort($l1, function ($a, $b) {\n    return $b - $a;\n\
    \  });\n  usort($l2, function ($a, $b) {\n    return $b - $a;\n  });\n  return\
    \ array_unique(array_merge($l1, $l2));\n}", "    return array_filter(\n      \
    \  array_unique(\n            array_filter(\n                array_diff(\n   \
    \                 $l1,\n                    $l2\n                ),\n        \
    \        function ($x) {\n                    return in_array($x, $l1);\n    \
    \            }\n            )\n        ),\n        function ($x) {\n         \
    \   return in_array($x, $l2);\n        }\n    );\n}\n", "  $c = array();\n  foreach\
    \ ($l1 as $a1) {\n    foreach ($l2 as $a2) {\n      if ($a1 == $a2) $c[] = $a1;\n\
    \    }\n  }\n  return array_unique($c);\n}\n</code>\n<|/ a tags=arrays,sorting,php\
    \ dscore=1 |>\n<| a dscore=0 |>\n<code>", "  $common = array();\n  foreach ($l1\
    \ as $key => $value) {\n    if (in_array($value, $l2)) {\n      $common[$key]\
    \ = $value;\n    }\n  }\n  return $common;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nI think this code is missing a closing parenthesis.\n<|/ c |>\n<| c |>\n\
    - thank you for the catch. I've corrected the code.\n<|/ c |>\n<| a tags=php,arrays\
    \ |>\n<code>\n<?php\n\n$arr1 = array(\"1\"=>\"car\", \"2\"=>\"bike\", \"3\"=>\"\
    boat\", \"4\"=>\"airplane\", \"5\"=>\"bus\", \"6\"=>\"car\",\"7\"=>\"boat\", \"\
    8\"=>\"airplane\");\n$arr2 = array(\"1\"=>\"car\", \"2\"=>\"boat\", \"3\"=>\"\
    airplane\", \"5\"=>\"bus\", \"6\"=>\"car\");\n\n$arr1 = array_intersect($arr1,\
    \ $arr2);\n\nvar_dump($arr1);\n", "    $common = [];\n    foreach ($l1 as $key\
    \ => $value) {\n        if (in_array($value, $l2)) {\n            $common[] =\
    \ $value;\n            unset($l1[$key]);\n        }\n    }\n    return $common;\n\
    }\n</code>\n<|/ a tags=php,arrays,unique dscore=1 |>\n<| c |>\nThanks for your\
    \ answer. I don't think the array_diff method is efficient for large arrays, since\
    \ it has to check each element for uniqueness.\n<|/ c |>\n<| c |>\nYou're right.\
    \ I edited my answer and added a more elegant method based on array_filter which\
    \ I think is efficient enough.\n<|/ c |>\n<| a dscore=1 tags=php,arrays,unique\
    \ |>\nThe other answers have already pointed out the issue with your algorithm.\
    \ Here is my answer to solve that issue, although it does have the disadvantage\
    \ of having to be run every time.\n<code>\n$arr = array_unique($arr);\n$arr =\
    \ array_diff($arr, array_intersect($arr, $arr2));\n</code>\nThis code will take\
    \ your array and remove any elements that are already in both arrays. It will\
    \ only run once for both arrays. You only need to run it once, so this should\
    \ do it.\n<|/ a |>\n<| a tags=php,arrays,unique |>\nI didn't found anything like\
    \ array_unique, but this is my solution:\n<code>", "    if (count($l1) != count($l2))\
    \ {\n        return array();\n    }\n    foreach ($l1 as $k => $v) {\n       \
    \ if (!array_key_exists($k, $l2)) {\n            return $v; // If key missing\
    \ return value.\n        }\n        if ($l2[$k] != $v) {\n            return array();\
    \ // If values not same return empty.\n        }\n    }\n    return $l1;\n}\n",
  "\t$d = array_diff($l1, $l2);\n\t$a = array_diff($l2, $l1);\n\treturn array_intersect($d,\
    \ $a) ? array_intersect($d, $a) : $d;\n}\n", "\t$common = array();\n\t$l1 = array_unique($l1);\n\
    \t$l2 = array_unique($l2);\n\t$l1 = array_merge($l1, $l2);\n\t$l2 = array_merge($l2,\
    \ $l1);\n\tsort($l1, SORT_NUMERIC);\n\tsort($l2, SORT_NUMERIC);\n\tforeach ($l1\
    \ as $k => $val) {\n\t\t$isCommon = FALSE;\n\t\tforeach ($l2 as $k2 => $val2)\
    \ {\n\t\t\tif ($val === $val2) {\n\t\t\t\t$isCommon = TRUE;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tif (!$isCommon) {\n\t\t\t$common[] = $val;\n\t\t}\n\t}\n\treturn\
    \ $common;\n}\n", "    sort($l1);\n    sort($l2);\n    $ret = [];\n    foreach\
    \ (array_merge($l1, $l2) as $element) {\n        if (in_array($element, $ret,\
    \ true)) {\n            continue;\n        }\n        $ret[] = $element;\n   \
    \ }\n    return $ret;\n}", "  $common = array_intersect($l1, $l2);\n  asort($common);\n\
    \  return $common;\n}", "    $common = [];\n    foreach ($l1 as $k1 => $v1) {\n\
    \        foreach ($l2 as $k2 => $v2) {\n            if ($k1 == $k2 && $v1 == $v2)\
    \ {\n                $common[] = $v1;\n            }\n        }\n    }\n\n   \
    \ return $common;\n}\n", "  $seen = [];\n  $common = array_intersect($l1, $l2);\n\
    \  foreach($l1 as $key => $item) {\n    if (!isset($seen[$key])) {\n      $seen[$key]\
    \ = 1;\n      $common[] = $item;\n    }\n  }\n  foreach($l2 as $key => $item)\
    \ {\n    if (!isset($seen[$key])) {\n      $seen[$key] = 1;\n      $common[] =\
    \ $item;\n    }\n  }\n  return array_unique($common);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nFor this particular problem, you could get away with just 2 foreach\
    \ loops and a helper array. Something like this should work:\n<code>\n$l1 = [5,3,8,1];\n\
    $l2 = [5,3,8,1,9,2];\n$common = [];\nforeach($l1 as $key => $item) {\n    if(array_key_exists($item,$l2))\
    \ {\n        $common[] = $item;\n    }\n}\n$common = array_unique($common);\n\
    </code>\n<|/ a tags=arrays,php,unique dscore=1 |>\n<| a tags=arrays,php,unique\
    \ dscore=1 |>\nYou can use a combination of array_udiff and array_intersect to\
    \ remove duplicates from your two arrays.\n<code>\n$a = [5,3,8,1];\n$b = [5,3,8,1,9,2];\n\
    $c = array_udiff($a, $b, 'array_intersect_uassoc');\n$c = array_values($c);\n\
    print_r($c);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => 5\n    [1] => 8\n\
    \    [2] => 9\n)\n</code>\nThis uses array_udiff to compare the two arrays and\
    \ then array_intersect to remove the duplicates in the first array from the second.\n\
    <|/ a |>\n<| a dscore=1 |>\nIf you do not care about speed or memory consumption\
    \ and need something simple, then you can simply use the following: \n<code>\n\
    $a = array(5,3,8,1);\n$b = array(5,3,8,1,9,2);\n\nprint_r(array_diff(array_intersect($a,\
    \ $b), $a));\n</code>\n<|/ a tags=arrays,php,unique |>\n<| c |>\nThis doesn't\
    \ work if `$a` is `[0,5,3,8,1,9,2]`\n<|/ c |>\n<| c |>\nYou're right. I was assuming\
    \ that the OP did not care about speed or memory consumption. He just needed a\
    \ solution that works even if the lists contained duplicates.\n<|/ ", "  $o1 =\
    \ $l1;\n  $o2 = $l2;\n  uasort($o1, function($o1) use ($o2) {\n    return $o1\
    \ - $o2;\n  });\n  uasort($o2, function($o2) use ($o1) {\n    return $o1 - $o2;\n\
    \  });\n  $o1 = array_keys($o1);\n  $o2 = array_keys($o2);\n  sort($o1);\n  sort($o2);\n\
    \  ksort($o1);\n  ksort($o2);\n  return array_intersect($o1, $o2);\n}\n", "  \
    \  $shared = array();\n    $l1 = array_flip($l1);\n    $l2 = array_flip($l2);\n\
    \n    foreach($l1 as $k1 => $v1) {\n        if(array_key_exists($v1, $l2)) {\n\
    \            $shared[$k1] = $v1;\n        }\n    }\n    return $shared;\n}\n\n\
    $unique = array_flip(common($akeys, $bkeys));", "\t$result = array();\n\t$common\
    \ = array();\n\t$l1 = array_unique($l1);\n\t$l2 = array_unique($l2);\n\tforeach($l1\
    \ as $l) {\n\t\tif(in_array($l, $l2)) $common[] = $l;\n\t\telse $result = array_merge($result,\
    \ $common);\n\t}\n\treturn $result;\n}\n", "    $n1 = count($l1);\n    $n2 = count($l2);\n\
    \n    $a1 = array();\n    $a2 = array();\n    $ret1 = array();\n    $ret2 = array();\n\
    \n    for ($i = 0; $i < $n2; $i++) {\n        $t = $l1[$i];\n\n        $j = 0;\n\
    \        for ($k = 0; $k < $n1; $k++) {\n            if ($l1[$k] == $t) {\n  \
    \              $a1[$j] = $k;\n                $ret1[$j] = $t;\n              \
    \  $j++;\n                break;\n            }\n        }\n\n        $j = 0;\n\
    \        for ($k = $n1 - 1; $k >= 0; $k--) {\n            if ($l1[$k] == $t) {\n\
    \                $a1[$j] = $k;\n                $ret1[$j] = $t;\n            \
    \    $j++;\n                break;\n            }\n        }\n    }\n\n    for\
    \ ($i = 0; $i < $n1; $i++) {\n        $t = $l2[$i];\n\n        $j = 0;\n     \
    \   for ($k = 0; $k < $n2; $k++) {\n            if ($l2[$k] == $t) {\n       \
    \         $a2[$j] = $k;\n                $ret2[$j] = $t;\n                $j++;\n\
    \                break;\n            }\n        }\n\n        $j = 0;\n       \
    \ for ($k = $n2 - 1; $k >= 0; $k--) {\n            if ($l2[$k] == $t) {\n    \
    \            $a2[$j] = $k;\n                $ret2[$j] = $t;\n                $j++;\n\
    \                break;\n            }\n        }\n    }\n\n    return array_unique(array_merge($a1,\
    \ $a2));\n}\n</code>\n<|/ a tags=arrays,sorting,php dscore=0 |>\n<| a dscore=0\
    \ |>\nUse array_intersect() to find common items between 2 arrays and then sort\
    \ the results.\n<code>", "  // Create a set of unique elements from both lists.\n\
    \  $common = array_unique(array_merge($l1, $l2));\n  // Sort the unique elements.\n\
    \  sort($common);\n  // Remove duplicates.\n  $common = array_unique($common);\n\
    \  // Return result.\n  return $common;\n}", "  if (empty($l1) || empty($l2))\
    \ {\n    return array();\n  }\n  // Return common elements of both sorted lists.\n\
    \  $common = array();\n  foreach ($l1 as $key => $value) {\n    if (in_array($value,\
    \ $l2)) {\n      $common[] = $value;\n    }\n  }\n  return $common;\n}\n</code>\n\
    <|/ a tags=arrays,sorting,php dscore=5 |>\n<| c |>\nVery handy!  I had to change\
    \ it slightly to make it work with a multidimensional array, but otherwise this\
    \ works perfectly.\n<|/ c |>\n<| c |>\nThanks a lot! Helped me a lot!\n<|/ c |>\n\
    <| c |>\nThis is much better than the accepted answer. Thanks!\n<|/ c |>\n<| c\
    \ |>\nBest answer in terms of speed, not code\n<|/ c |>\n<| c |>\nI didn't get\
    \ how this works. Can you explain?\n<|/ c |>\n<| a tags=arrays,sorting,php |>\n\
    A variant on the previous answers which I believe is faster.\n<code>\n$a = array(1,2,3,4,5);\n\
    $b = array(4,5,2,1,3);\n\n$result=array_merge(array_intersect($a,$b),array_intersect($b,$a));\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nNice. Though I wonder how this code scales\
    \ to a large array (say 10x10 or more).\n<|/ c |>\n<| c |>\nThis answer is faster\
    \ and has less lines of code.\n<|/ c |>\n<| c |>\nThis is not correct. It gives\
    \ only intersections. To get all common elements in a and b, use: `$result=array_intersect($a,$b);`\
    \ `$result=array_intersect($b,$a);`\n<|/ c |>\n<| a tags=arrays,sorting,php dscore=5\
    \ |>\nYou could use the following function to get an array that contains all unique\
    \ elements in both arrays:\n<code>", "    $common = [];\n    foreach($l1 as $k\
    \ => $v) {\n        if(in_array($v, $l2)) {\n            $common[] = $v;\n   \
    \     }\n    }\n    return $common;\n}", "  $common = [];\n  foreach ($l1 as $item)\
    \ {\n    foreach ($l2 as $item) {\n      if ($item == $item2) {\n        $common[]\
    \ = $item;\n      }\n    }\n  }\n  return $common;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like how you used `array_intersect` for that, but I believe you\
    \ mean `array_merge`.\n<|/ c |>\n<| c |>\nOops, yes I meant array_merge. I'll\
    \ fix that.\n<|/ c |>\n<| c |>\nI think you meant `return array_merge($common,\
    \ $item);` instead of `return $common;`, but then again, I don't have the PHP\
    \ interpreter around to test it.\n<|/ c |>\n<| c |>\nOops, you're right. I fixed\
    \ it now.\n<|/ c |>\n<| a dscore=1 |>\nThis is probably the easiest solution with\
    \ minimal code:\n<code>", "    if (!is_array($l1) || !is_array($l2)) {\n     \
    \   return array();\n    }\n\n    $common = array_unique(array_merge($l1, $l2));\n\
    \    sort($common);\n    return $common;\n}\n", "    return array_unique(array_merge(sort($l1),\
    \ sort($l2)));\n}\n", "    $intersection = array_intersect($l1, $l2);\n    $l1\
    \ = array_keys($l1);\n    $l2 = array_keys($l2);\n    $common = array();\n\n \
    \   foreach ($l1 as $key => $val) {\n        if (in_array($val, $intersection))\
    \ {\n            $common[] = $val;\n            unset($l1[$key]);\n        }\n\
    \    }\n    foreach ($l2 as $key => $val) {\n        if (in_array($val, $intersection))\
    \ {\n            $common[] = $val;\n            unset($l2[$key]);\n        }\n\
    \    }\n\n    return $common;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,php |>\n\
    <code>", "    foreach ($l1 as $k => $v) {\n        if (in_array($v, $l2)) {\n\
    \            $l1[$k] = $v;\n            unset($l2[$k]);\n        }\n    }\n  \
    \  return array_values($l1);\n}\n", "    if ($l1 == $l2) return $l1;\n    $a1\
    \ = $l1; $a2 = $l2;\n    if (count($a1) > count($a2)) {\n        $a1 = array_slice($a1,\
    \ 0, count($a1) - 1);\n        $a2 = array_slice($a2, 0, count($a2) - 1);\n  \
    \  }\n    return array_intersect($a1, $a2);\n}", "    $c = [];\n    foreach($l1\
    \ as $k => $v) {\n        if (array_key_exists($k, $c)) {\n            $c[$k][]\
    \ = $v;\n        } else {\n            $c[$k] = [$v];\n        }\n    }\n    foreach($l2\
    \ as $k => $v) {\n        if (array_key_exists($k, $c)) {\n            $c[$k][]\
    \ = $v;\n        } else {\n            $c[$k] = [$v];\n        }\n    }\n    \n\
    \    foreach($c as $k => $v) {\n        $c[$k] = array_unique($v);\n    }\n  \
    \  \n    return array_keys($c);\n}\n</code>\n<|/ a |>\n<| c |>\nYes - this is\
    \ the perfect solution.\n<|/ c |>\n<| a |>\n<code>\n<?php\n\n$array1 = ['one',\
    \ 'two', 'three'];\n$array2 = ['one', 'one', 'two'];\n", "    $a = array_merge($l1,\
    \ $l2);\n    $a = array_unique($a);\n    sort($a);\n    return array_values($a);\n\
    }", "  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n  $intersect = array_intersect($l1,\
    \ $l2);\n  return array_unique($intersect);\n}", "    if (!is_array($l1) || !is_array($l2))\
    \ return array();\n    $l1 = array_map(create_function('$l2', 'return $l2;'),\
    \ $l1);\n    $l2 = array_map(create_function('$l1', 'return $l1;'), $l2);\n  \
    \  $common = array();\n    foreach ($l1 as $k => $v) {\n        if (isset($l2[$k]))\
    \ {\n            $common[] = $v;\n        }\n    }\n    return $common;\n}", "\t\
    $common = array();\n\tforeach ($l1 as $key => $value)\n\t\t$common[] = $value;\n\
    \tforeach ($l2 as $key => $value)\n\t\t$common[] = $value;\n\treturn array_unique(array_intersect($common,\
    \ $l2));\n}\n", "  $r1 = array_intersect($l1, $l2);\n  $r2 = array_intersect($l2,\
    \ $l1);\n  return array_unique($r1, $r2);\n}\n", "    // Copy lists to arrays\
    \ for easier manipulation.\n    $l1 = array_slice($l1, count($l1));\n    $l2 =\
    \ array_slice($l2, count($l2));\n\n    // Sort lists.\n    $l1 = array_merge($l1,\
    \ array_reverse($l2));\n    $l2 = array_merge($l2, array_reverse($l1));\n\n  \
    \  // Merge sorted lists.\n    $l1 = array_unique(array_merge($l1, $l2));\n  \
    \  return $l1;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is unnecessarily\
    \ complex. Why not just use a `while` loop instead?\n<|/ c |>\n<| c |>\nThis algorithm\
    \ is O(n^2), and since most of the work is done in array_unique, it is O(n) anyway.\n\
    <|/ c |>\n<| c |>\nThat is true. It can still be reduced to O(n) by using an `array_filter`\
    \ instead of `array_search`.\n<|/ c |>\n<| c |>\nAh yes, I didn't think about\
    \ that. Yeah, `array_filter` would be better, since it only takes one item from\
    \ each array at a time, instead of a linear search.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to include an O(n) algorithm based on `array_filter`.\n<|/ c |>\n\
    <| a tags=php,array-intersect,arrays,multidimensional-array,array-unique |>\n\
    This seems to be a good solution:\n<code>\n$arr1 = array(1,2,3,4,5);\n$arr2 =\
    \ array(1,2,3,4,5,6);\n$result = array_diff(array_unique($arr1), $arr2);\n</code>\n\
    I ran it and it returned the following: Array ( [0] => 4 )\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nThis should be faster:\n<code>", "  $common = array();\n  if\
    \ (count($l1) > count($l2)) {\n    foreach ($l1 as $k => $v) {\n      if (in_array($v,\
    \ $l2)) {\n        unset($l1[$k]);\n      }\n    }\n  }\n  else {\n    foreach\
    \ ($l2 as $k => $v) {\n      if (in_array($v, $l1)) {\n        unset($l1[$k]);\n\
    \      }\n    }\n  }\n  $common = array_intersect($l1, $l2);\n  return $common;\n\
    }\n", "    $intersect = array_intersect($l1, $l2);\n    sort($intersect);\n  \
    \  return array_unique($intersect);\n}\n</code>\n<|/ a tags=php,arrays,sorting\
    \ dscore=0 |>\n<| a |>\nAnother way to get the result is using array_unique().\
    \ array_intersect() + array_unique() will get you your desired result.\nCode\n\
    <code>\n$a = [1,2,4,6];\n$b = [1,5,6,2];\n\n$c = array_intersect($a, $b);\n$c\
    \ = array_unique($c);\nprint_r($c);\n</code>\nOutput\n<code>\nArray\n(\n    [0]\
    \ => 1\n    [1] => 5\n    [2] => 6\n)\n</code>\n<|/ a dscore=0 tags=php,arrays,sorting\
    \ |>\n<| a tags=php,arrays,sorting |>\nHere is another solution with array_intersect\
    \ and array_unique:\n<code>\n<?php\n\n$l1 = array('a', 'b', 'c', 'e');\n$l2 =\
    \ array('b', 'c', 'd', 'e');\n\n$c = array_intersect($l1, $l2);\n$c = array_unique($c);\n\
    \nprint_r($c);\n", "  foreach ($l1 as $key => $value) {\n    if (in_array($value,\
    \ $l2)) {\n      unset($l2[$key]);\n    } else {\n      unset($l1[$key]);\n  \
    \  }\n  }\n  return array_values(array_intersect($l1, $l2));\n}\n", "\t$common\
    \ = [];\n\tfor ($i = 0; $i < min(count($l1), count($l2)); $i++) {\n\t\tif ($l1[$i]\
    \ === $l2[$i]) $common[] = $l1[$i];\n\t}\n\treturn $common;\n}\n", "    if (!is_array($l1))\
    \ {\n        return array();\n    }\n    if (!is_array($l2)) {\n        return\
    \ array();\n    }\n    $common = array();\n    foreach ($l1 as $key => $value)\
    \ {\n        if (in_array($value, $l2)) {\n            $common[] = $value;\n \
    \           unset($l1[$key]);\n        }\n    }\n    foreach ($l2 as $key => $value)\
    \ {\n        if (in_array($value, $l1)) {\n            unset($l2[$key]);\n   \
    \     }\n    }\n    return array_merge($common, $l1, $l2);\n}\n", "  // Return\
    \ an empty array if either list is empty.\n  if (!$l1 || !$l2)\n    return array();\n\
    \n  // Return an empty array if one of the lists is empty.\n  if (!$l1[0] || !$l2[0])\n\
    \    return array();\n\n  // If the lists have different numbers of elements,\n\
    \  // return an empty array if any of them is empty.\n  if (count($l1) != count($l2))\n\
    \    return array();\n\n  // Sort the lists so that they are guaranteed to be\n\
    \  // unique and consistent.\n  sort($l1);\n  sort($l2);\n\n  // Remove duplicate\
    \ elements from one of the lists.\n  // This may leave empty spots where one list\
    \ has a duplicate\n  // while the other does not.\n  $n1 = $l1;\n  $n2 = $l2;\n\
    \  array_splice($n2, array_search($l1, $n2), 1);\n  array_splice($n1, array_search($l2,\
    \ $n1), 1);\n\n  // If the lists are different lengths, return an empty array.\n\
    \  if (count($n1) != count($n2))\n    return array();\n\n  // Return the sorted\
    \ unique lists.\n  return array_unique(array_merge($n1, $n2));\n}", "    sort($l1);\n\
    \    sort($l2);\n    $set1 = array_flip($l1);\n    $set2 = array_flip($l2);\n\
    \    foreach($set1 as $k=>$v) {\n        if(isset($set2[$k])) {\n            $result[]\
    \ = $v;\n            unset($set2[$k]);\n        }\n    }\n    return array_values($result);\n\
    }\n", "  if (!$l1 || !$l2) {\n    return [];\n  }\n\n  $set = array_intersect($l1,\
    \ $l2);\n  $l1 = array_unique($l1);\n  $l2 = array_unique($l2);\n  foreach ($l1\
    \ as $key => $value) {\n    if (!isset($l2[$key])) {\n      unset($l1[$key]);\n\
    \    }\n  }\n  return array_merge($l1, $l2);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Why use such complex code and use \"if ($l1 !== $l2)\" instead of just \"$l1 ===\
    \ $l2\"? This just seems unnecessary here.\n<|/ c |>\n<| c |>\nI only used the\
    \ == as it is shorter to write it this way. Also, if there was a variable number\
    \ of arguments, or one could assume all are arrays, it could be written to include\
    \ that.\n<|/ c |>\n<| a |>\nI came up with another solution using array_merge_recursive\
    \ and array_unique. I just wrote a small function that compares the length and\
    \ returns the keys if the two arrays are exactly the same size.\n<code>", "  \
    \  $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n    $common = [];\n\
    \    foreach($l1 as $k1) {\n        foreach($l2 as $k2) {\n            if($k1\
    \ == $k2) $common[] = $k1;\n        }\n    }\n    return $common;\n}\n</code>\n\
    If you wanted to get fancy you could get fancy with the loops and use array_key_exists\
    \ (which is faster), but it's probably not worth it unless your data sets are\
    \ very large.\n<|/ a |>\n<| c |>\nIf your data is very large (>10^7 rows) you\
    \ may want to use [this answer](https://stackoverflow.com/a/44733430/273468) instead.\
    \ Your function will require about 850 MB of memory to process your two lists.\n\
    <|/ c |>\n<| a dscore=1 tags=php,arrays,unique |>\nSince your data is very large\
    \ (and you didn't specify whether your data will be sorted, or whether you might\
    \ have duplicate data), it may be a good idea to utilize the PHP function array_intersect_assoc()\
    \ from PHP >= 5.5.  \narray_intersect_assoc() will return the elements of an array\
    \ that have values which are present in all the arrays. In this case, you'll be\
    \ utilizing the fact that the data in the first array will be unique while preserving\
    \ each row of the first array as a \"key\" in the second array (with its corresponding\
    \ \"value\").\nHere is how you can utilize this function with your data.  I wrote\
    \ some code that will print out the number of unique items in both arrays.\nI\
    \ used a for loop to iterate through each row in the first array and compare it\
    \ to the unique elements in the second array.  Then, if the number of unique elements\
    \ in each row is greater than 0, I added the row to the unique items array.\n\
    <code>\n<?php\n$arr1 = [\n    [0] => Array\n        (\n            [0] => 1\n\
    \            [1] => 4\n            [2] => 3\n            [3] => 34\n         \
    \   [4] => 653\n            [5] => 2\n            [6] => 5\n            [7] =>\
    \ 7\n            [8] => 1\n            [9] => 5\n            [10] => 9\n     \
    \       [11] => 653\n            [12] => 121\n        )\n\n    [1] => Array\n\
    \        (\n            [0] => 5\n            [1] => 3\n            [2] => 2\n\
    \            [3] => 8\n            [4] => \n            [5] => \n            [6]\
    \ => \n            [7] => \n            [8] => \n            [9] => \n       \
    \     [10] => \n            [11] => \n            [12] => \n        )\n\n    [2]\
    \ => Array\n        (\n            [0] ", "\t$hash = [];\n\t$l1 = array_count_values($l1);\n\
    \tforeach ($l2 as $k) {\n\t\tif (isset($l1[$k])) {\n\t\t\t$hash[$l1[$k]] = $k;\n\
    \t\t}\n\t}\n\treturn array_intersect_key($l1, $hash);\n}\n\n/**\n * Finds the\
    \ intersection of two arrays (order doesn't matter)\n *\n * Note: to compare multidimensional\
    \ arrays, use the array_uintersect() function\n *\n * @param array $a1\n * @param\
    \ array $a2\n * @param callback $callback\n *\n * @return array\n */", "    if\
    \ (!is_array($l1) || !is_array($l2)) {\n        return array();\n    }\n\n   \
    \ sort($l1);\n    sort($l2);\n\n    $i1 = 0; $i2 = 0; $n1 = count($l1) - 1; $n2\
    \ = count($l2) - 1; $i = 0;\n    while ($i1 < $n1 && $i2 < $n2) {\n        if\
    \ ($l1[$i1] == $l2[$i2]) {\n            $i++;\n        } elseif ($l1[$i1] > $l2[$i2])\
    \ {\n            $i1++;\n        } else {\n            $i2++;\n        }\n   \
    \ }\n\n    return array_slice($l1, $i1, $i2 > $i1 ? $i2 - $i1 + 1 : 0);\n}\n</code>\n\
    <|/ a dscore=5 tags=php,arrays,multidimensional-array |>\n<| c |>\narray_uintersect\
    \ (http://php.net/manual/en/function.array-uintersect.php) works too, with a bit\
    \ different syntax.\n<|/ c |>\n<| c |>\nI needed to use a custom sort function\
    \ for the first argument of array_intersect. Your example showed how to do that\
    \ without needing to use uasort http://stackoverflow.com/a/28184971/2486990\n\
    <|/ c |>\n<| a tags=php,arrays,multidimensional-array |>\nAs an alternative to\
    \ the already mentioned array_intersect, I would use array_uintersect in combination\
    \ with array_column. As array_uintersect allows for sorting and matching multiple\
    \ array elements, the code can be simpler if sorting is irrelevant. \n<code>",
  "    $l1 = array_reverse($l1, true);\n    $l2 = array_reverse($l2, true);\n    $out\
    \ = array_merge($l1, $l2);\n    $out1 = array_slice($out, 0, count($l1));\n  \
    \  $out2 = array_slice($out, count($l1));\n    $out = array_merge($out1, $out2);\n\
    \    return array_unique($out);\n}\n", "    $l1 = array_flip($l1);\n    $l2 =\
    \ array_flip($l2);\n    $intersect = array_intersect($l1, $l2);\n    return array_unique($intersect);\n\
    }", "    $result = [];\n    foreach ($l1 as $key => $value) {\n        if (in_array($value,\
    \ $l2)) {\n            $result[] = $value;\n        }\n    }\n    return $result;\n\
    }\n", "    $l1 = array_unique($l1);\n    $l2 = array_unique($l2);\n    sort($l1);\n\
    \    sort($l2);\n    return array_diff(array_intersect($l1, $l2), $l1);\n}\n",
  "    $d = $l1 + $l2;\n    $s = $l1 - $l2;\n    while ($d != 0) {\n        $d = ($d\
    \ & ($d >> 1)) - $s;\n        $s++;\n    }\n    return $s;\n}\n</code>\n<|/ a\
    \ dscore=2 tags=math,java,arrays,php |>\n<| c |>\nVery nice but I don't think\
    \ it is exactly what you need, please see my answer for a different one.\n<|/\
    \ c |>\n<| a |>\nI think this may be what you're looking for:\n<code>\n$a = [1,\
    \ 4, 3, 34, 653, 2, 5, 7, 1, 5, 9, 653, 121];\n$b = [5, 3, 2, 8];\n$diff = array();\n\
    foreach (array_intersect($a, $b) as $x) {\n    $diff[$x]++;\n}\n$result = array();\n\
    foreach ($diff as $x => $count) {\n    for ($i = 0; $i < $count; $i++) {\n   \
    \     $result[] = $x;\n    }\n}\n</code>\n<|/ a dscore=2 tags=math,java,arrays,php\
    \ |>\n<| a tags=math,java,arrays,php |>\n<code>", "  $set1 = array_flip($l1);\n\
    \  $set2 = array_flip($l2);\n  $keys1 = array_keys($set1);\n  $keys2 = array_keys($set2);\n\
    \  foreach (array_unique($keys1) as $k1) {\n    if (!array_key_exists($k1, $set2))\
    \ {\n      return array($k1);\n    }\n  }\n  foreach (array_unique($keys2) as\
    \ $k2) {\n    if (!array_key_exists($k2, $set1)) {\n      return array($k2);\n\
    \    }\n  }\n  foreach ($set1 as $k1) {\n    if (!array_key_exists($k1, $set2))\
    \ {\n      return array($k1);\n    }\n  }\n  foreach ($set2 as $k2) {\n    if\
    \ (!array_key_exists($k2, $set1)) {\n      return array($k2);\n    }\n  }\n  return\
    \ array();\n}\n", "  if ($l1 === $l2) {\n    return $l1;\n  }\n  $l1 = array_unique($l1);\n\
    \  $l2 = array_unique($l2);\n  $l1 = array_filter($l1, function($element) {\n\
    \    return ! in_array($element, $l2);\n  });\n  $l2 = array_filter($l2, function($element)\
    \ {\n    return ! in_array($element, $l1);\n  });\n  return array_merge($l1, $l2);\n\
    }\n", "  if (empty($l1) || empty($l2)) {\n    return array();\n  }\n\n  // Sort\
    \ lists by value when values are equal.\n  // @see http://php.net/manual/en/function.ksort.php\n\
    \  uksort($l1, function($a, $b) { return $a == $b ? 0 : ($a < $b ? -1 : 1); });\n\
    \  uksort($l2, function($a, $b) { return $a == $b ? 0 : ($a < $b ? -1 : 1); });\n\
    \n  // Iterate list 1 forward and backwards comparing values with the current\
    \ value from list 2.\n  // @see http://php.net/manual/en/function.array-search.php\n\
    \  foreach (array_keys($l1) as $i => $key) {\n    $match = NULL;\n    foreach\
    \ (array_keys($l2) as $j) {\n      if ($key === $l1[$i] && $j === $l1[$i]) {\n\
    \        $match = $l1[$i];\n        break;\n      }\n    }\n    if (!$match) {\n\
    \      return array();\n    }\n  }\n\n  return $l1;\n}", "    $result = $l1;\n\
    \    foreach ($l2 as $item) {\n        if (in_array($item, $result)) {\n     \
    \       unset($result[$key]);\n        }\n    }\n    return $result;\n}", "  \
    \  if (count($l1) != count($l2)) {\n        trigger_error('Input lists are of\
    \ different lengths.', E_USER_WARNING);\n        return false;\n    }\n\n    $i\
    \ = count($l1);\n    $j = 0;\n    $common = array();\n    while ($i < $j) {\n\
    \        $j = 0;\n        while ($j < $i && $l1[$i] == $l2[$j]) {\n          \
    \  $j++;\n        }\n        if ($j == $i) {\n            $common[] = $l1[$i];\n\
    \        }\n        $i++;\n    }\n    return $common;\n}\n", "\t$common = array();\n\
    \t$l1 = array_unique($l1);\n\t$l2 = array_unique($l2);\n\tforeach ($l1 as $k =>\
    \ $v) {\n\t\tif (isset($l2[$k])) {\n\t\t\t$common[$v] = $l2[$k];\n\t\t}\n\t}\n\
    \treturn $common;\n}", "    $intersect = [];\n    foreach ($l1 as $v) {\n    \
    \    if (in_array($v, $l2)) {\n            $intersect[] = $v;\n        }\n   \
    \ }\n    return $intersect;\n}", "  $c = array();\n  $i = 0;\n  foreach ($l2 as\
    \ $item) {\n    while ($l1[$i] == $item) {\n      $i++;\n    }\n    $c[] = $l1[$i];\n\
    \    $i++;\n  }\n  $l1 = array_slice($l1, 0, $i);\n  $l2 = array_slice($l2, 0,\
    \ $i);\n  $result = array_intersect($l1, $l2);\n  sort($result);\n  return $result;\n\
    }\n", "  foreach ($l1 as $key => $value) {\n    if (empty($l2)) {\n      return\
    \ $value;\n    }\n    if ($l1 == $l2) {\n      return $value;\n    }\n    if (in_array($value,\
    \ $l2, true)) {\n      return $value;\n    }\n  }\n  return null;\n}", "    $result\
    \ = array();\n    foreach ($l1 as $val) {\n        foreach ($l2 as $val2) {\n\
    \            if ($val == $val2)\n                $result[] = $val;\n        }\n\
    \    }\n    return array_values(array_unique($result));\n}\n</code>\n<|/ a tags=sorting,arrays,php\
    \ |>\n<| a |>\nHere is a working function that will find common elements of two\
    \ sorted arrays. \nIt will find the common elements from both the arrays using\
    \ the merge method.\n<code>", "  global $common;\n  $common = array();\n  foreach($l1\
    \ as $item) {\n    if(!isset($common[$item])) {\n      $common[$item] = 1;\n \
    \   }\n  }\n  foreach($l2 as $item) {\n    if(!isset($common[$item])) {\n    \
    \  $common[$item] = 1;\n    }\n  }\n  ksort($common);\n  ksort($l2);\n  return\
    \ array_intersect($l1, $l2);\n}", "    // Sorting and then reversing lists increases\
    \ efficiency for large lists.\n    // See: http://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n\
    \    sort($l1);\n    sort($l2);\n    $result = array();\n    foreach ($l1 as $key\
    \ => $value) {\n        if (array_search($value, $l2) !== false) {\n         \
    \   continue 2;\n        }\n        $result[] = $value;\n    }\n    return $result;\n\
    }\n", "    // Sort the arrays to begin with\n    sort($l1);\n    sort($l2);\n\
    \    // Set up the helper arrays\n    $l1 = array_count_values($l1);\n    $l2\
    \ = array_count_values($l2);\n    // Now go through the elements and see where\
    \ they intersect\n    $l3 = array();\n    foreach ($l1 as $v1) {\n        if ($l1[$v1]\
    \ > 1) {\n            foreach ($l2 as $v2) {\n                if ($l1[$v1] ==\
    \ $l1[$v2] && $l2[$v2] == $l2[$v2]) {\n                    $l3[$v1]++;\n     \
    \           }\n            }\n        }\n    }\n    return array_keys($l3);\n\
    }\n</code>\n<|/ a tags=arrays,algorithm,php |>\n<| c |>\n`array_count_values()`\
    \ seems to be very expensive on large arrays (100k elements in my case) so this\
    \ is very inefficient but very useful indeed\n<|/ c |>\n<| c |>\n: You can always\
    \ cache the result of that call (so if the same input is given it will only run\
    \ once)\n<|/ c |>\n<| c |>\nI mean caching `array_count_values()` results per\
    \ each array in the loop to reduce the amount of calculations you perform on every\
    \ iteration. However I guess that would be the most memory consuming approach\n\
    <|/ c |>\n<| a tags=arrays,algorithm,php |>\n<code>\n<?php\n$array1 = [5, 3, 4,\
    \ 7, 2, 3];\n$array2 = [4, 5, 6, 2, 1, 8];\n", "  $result = [];\n  foreach($l1\
    \ as $v) {\n    if (array_search($v, $l2) === false) {\n      $result[] = $v;\n\
    \    }\n  }\n  return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution\
    \ will find all common elements and output them as a list, but does not find the\
    \ difference between them.\n<|/ c |>\n<| c |>\n, thanks for pointing that out.\
    \ I've edited my answer.\n<|/ c |>\n<| c |>\nThanks for the nice function ! Works\
    \ great ! The only problem is that it returns all the common elements, even when\
    \ they are not present in either of its argument lists.\n<|/ c |>\n<| a tags=arrays,php,sorting\
    \ |>\nYou can use array_diff to remove all items that are in array2 but not in\
    \ array1\n<code>\n$arr1 = array(\"apple\", \"banana\", \"carrot\");\n$arr2 = array(\"\
    banana\", \"carrot\", \"kiwi\", \"mango\");\n\n$result = array_diff($arr2, $arr1);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution will find all common elements\
    \ and output them as a list, but does not find the difference between them.\n\
    <|/ c |>\n<| a tags=arrays,php,sorting dscore=2 |>\nI made a function which returns\
    \ array with all elements in array1 which aren't in array2:\n<code>", "  return\
    \ sort($l1, function ($a, $b) use ($l2) {\n    return array_search($b, $l2);\n\
    \  }, ARRAY_FILTER_USE_BOTH);\n}\n", "    sort($l1);\n    sort($l2);\n    $i1\
    \ = 0;\n    $i2 = 0;\n    while ($i1 < count($l1) && $i2 < count($l2)) {\n   \
    \     if ($l1[$i1] == $l2[$i2]) {\n            $i1++;\n            $i2++;\n  \
    \      } else if ($l1[$i1] < $l2[$i2]) {\n            $i2++;\n        } else {\n\
    \            $i1++;\n        }\n    }\n    return array_slice($l1, 0, $i1 + 1);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`sort($l1);` should be `sort($l1, SORT_NUMERIC);`\
    \ because the items are numerical. Also `array_merge` will merge them in alphabetical\
    \ order when they have the same key.\n<|/ c |>\n<| c |>\nOh, and you should probably\
    \ use `array_unique` instead of `array_merge` for the last line, or just `array_intersect_key`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n$arr = array();\narray_push($arr, \"abc\"\
    , \"bcd\", \"cde\", \"efg\");\narray_push($arr, \"abc\", \"bcd\", \"cde\", \"\
    efg\");\narray_push($arr, \"abc\", \"bcd\", \"cde\", \"efg\");\n\nforeach($arr\
    \ as $key => $value) {\n    $arr[$key] = $value;\n}\n\nprint_r($arr);\n</code>\n\
    <|/ a tags=arrays,sorting,php |>\n<| a dscore=1 |>\nTry this\n<code>\n$array =\
    \ array(\"a\", \"b\", \"c\", \"d\",\"e\");\n", "  $l1 = array_unique($l1);\n \
    \ $l2 = array_unique($l2);\n  $intersection = array_intersect($l1, $l2);\n  if\
    \ (empty($intersection)) {\n    return array();\n  }\n\n  return array_intersect($l1,\
    \ $intersection);\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIn case anyone needs\
    \ something similar, but without recursion, here's a working solution:\n<code>\n\
    <?php"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
