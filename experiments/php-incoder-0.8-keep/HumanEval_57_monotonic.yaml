name: HumanEval_57_monotonic
language: php
prompt: "<?php\n// Return True is list elements are monotonically increasing or decreasing.\n\
  // >>> monotonic([1, 2, 4, 20])\n// True\n// >>> monotonic([1, 20, 4, 10])\n// False\n\
  // >>> monotonic([4, 1, 0, -10])\n// True\nfunction monotonic($l) {\n"
tests: "function candidate(...$args) {\n    return monotonic(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(1, 2, 4, 10)) !== true) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(1, 2, 4, 20)) !== true) { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(array(1, 20, 4, 10)) !== false)\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(4, 1, 0, -10))\
  \ !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(4,\
  \ 1, 1, 0)) !== true) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1,\
  \ 2, 3, 2, 5, 60)) !== false) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(array(1, 2, 3, 4, 5, 60)) !== true) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(9, 9, 9, 9)) !== true) { throw new Exception(\"Test\
  \ failed!\"); }\n}\n\ntest();"
completions: ["    $l = sort($l);\n    foreach ($l as $i => $elem) {\n        if ($elem\
    \ != $l[$i-1]) return true;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=4\
    \ tags=arrays,php |>\n<| a tags=arrays,php |>\nI came across this question when\
    \ I was looking to find the index of all elements that met a certain criteria.\
    \ This may help others as it took me a while to find the answer. \nIn my case,\
    \ I'm looking for the index for all of the elements in an array that have a value\
    \ greater than or equal to 10. The accepted answer will return an array of indexes\
    \ where the value at that index is greater than or equal to 10. \nIn order to\
    \ return only one index I used a foreach loop to iterate through the array and\
    \ if the element was greater than or equal to 10, I added it to the output array.\
    \ \n<code>\nforeach ($array as $key => $value) {\n  if ($value >= 10) {\n    array_push($output,\
    \ array_keys($array, $key));\n  }\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=arrays,php\
    \ |>\nThe best solution I found so far is this one: \n<code>\n$array = array(1,\
    \ 4, 5, 10, 20);\n$array = array_filter($array, function($e) {\n    return $e\
    \ > 10;\n});\n$array = array_keys($array);\n</code>\nIt filters the array and\
    \ returns the index numbers of the array that match the criteria. \nA drawback\
    \ here is that you have to store a temporary variable and also the memory requirements\
    \ are quite high (O(n * m)). \nHowever, you can improve this by a tiny bit: \n\
    <code>\n$array = array(1, 4, 5, 10, 20);\n$array = array_filter($array, function($e)\
    \ {\n    return $e > 10;\n});\n$array = array_keys($array);\n$result = array_flip($array);\n\
    </code>\nBy using this you only store the index-numbers of the array that match\
    \ your criteria and you only need to store the index-numbers of the array once\
    \ instead of once per value that matches the criteria. \nAnd even better is this:\n\
    <code>\n$array = array(1, 4, 5, 10, 20);\n$result = array_filter($array, function($e)\
    \ {\n    return $e > 10;\n});\n</code>\nBy using this you only store the index-numbers\
    \ of the array that match your criteria. \nHowever, as pointed out by this solution\
    \ will give you the first index if the criteria is met. The best approach for\
    \ getting all indexes where your criteria is met is this one: \n<code>\n$array\
    \ = array(1, 4, 5, 10, 20);\n$result = array_keys(array_filter($array, function($e)\
    \ {\n    return $e > 10;\n", "    $s = array_sum($l);\n    return $s == 0 || ($s\
    \ == 1 && $l[0] > 0);\n}\n\n/**\n * Checks whether a list contains monotonically\
    \ increasing or decreasing elements.\n *\n * If list elements are [A, B] and [B,\
    \ C], the function returns TRUE, because\n * [A, B] and [B, C] are monotonically\
    \ increasing.\n *\n * @param array $l List to check.\n *\n * @return bool TRUE\
    \ if the list contains monotonically increasing elements\n *    or FALSE otherwise.\n\
    \ */", "    $l = array_reverse($l);\n    $m = array_reduce($l, function ($p, $c)\
    \ {\n        return max($p, $c);\n    });\n    $n = array_reduce($l, function\
    \ ($p, $c) {\n        return min($p, $c);\n    });\n    return $m >= $n;\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis works great, but it would be nice to\
    \ have something that is both robust and performant. Since both algorithms will\
    \ require a lot of memory, I would be happy to get this to run quicker if I can\
    \ get rid of the unused variable `$p`.\n<|/ c |>\n<| c |>\nThe only thing you\
    \ really need here is to compare the differences between the two arrays; so you\
    \ can use `$n` and `$m` instead of `$p` and `$c` -- I'll edit the answer now.\n\
    <|/ c |>\n<| a |>\n<code>", "  return $l[0] > $l[count($l)-1];\n}\n", "    $l1\
    \ = $l[0];\n    foreach ($l as $e) {\n        $l2 = $e;\n        if ($l1 > $l2)\
    \ {\n            return false;\n        }\n        if ($l1 < $l2) {\n        \
    \    $l1 = $l2;\n        }\n    }\n    return true;\n}\n", "  $o = array();\n\
    \  for ($x = 1; $x < count($l); $x++) {\n    $x_min = $x_max = $l[$x];\n    for\
    \ ($y = $x; $y < count($l); $y++) {\n      if ($l[$y] < $x_min) {\n        if\
    \ ($x_max > $l[$y]) {\n          $x_max = $l[$y];\n        }\n      } else if\
    \ ($l[$y] > $x_max) {\n        if ($x_min < $l[$y]) {\n          $x_min = $l[$y];\n\
    \        }\n      }\n    }\n    if ($x_min > $x_max) {\n      return true;\n \
    \   }\n    $o[] = $x_min;\n  }\n  return $o[0];\n}\n", "  foreach ($l as $i =>\
    \ $e) {\n    if (!isset($l[$i - 1]) || $l[$i - 1] > $e) {\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "  // Find first element that has value greater\
    \ than or equal to every element\n  // and also less than the first element.\n\
    \  $min_value = array_reduce($l, function($result, $item) {\n    return $result\
    \ or $item <= $result; // or is commutative.\n  });\n  return $min_value === array_reduce($l,\
    \ function($result, $item) {\n    return $result or $item > $result; // or is\
    \ commutative.\n  });\n}", "    $l = array_reverse($l);\n    return $l[0] > $l[count($l)-1];\n\
    }\n", "    $r = $l[count($l)-1];\n    for ($i = count($l)-2; $i >= 0; --$i) {\n\
    \        if ($l[$i] < $r) {\n            break;\n        }\n        if ($l[$i]\
    \ > $r) {\n            return false;\n        }\n        $r = $l[$i];\n    }\n\
    \    return true;\n}\n", "\t$l = array_filter($l);\n\t$keys = array_keys($l);\n\
    \t$cmp = array_map(array($this, '_compare'), $keys, $keys);\n\treturn $cmp[0]\
    \ === 0 && $cmp[1] === count($l) - 1;\n}\n\n/**\n * Returns list elements that\
    \ appear in one array but not another or that\n * do not appear at all in the\
    \ first array.\n *\n * @param array $a Array to compare\n * @param array $b Array\
    \ to compare against\n * @return array List elements that *don't* appear in both,\
    \ or that appear in both\n *              but none of the elements are in the\
    \ other list.\n * @see http://en.wikipedia.org/wiki/Intersection_%28set_theory%29\n\
    \ */", "  // Monotonically increasing if first element is <= the last element.\n\
    \  return $l[0] < $l[count($l) - 1];\n}", "    $a = array_merge($l);\n    if ($a[0]\
    \ == $a[1]) {\n        // All elements are equal\n        return $a[0] == 0;\n\
    \    }\n    $cs = array_count_values($a);\n    $n = $cs[0];\n    for ($i = 1,\
    \ $last = max($n); $i < $n; $i++) {\n        if ($cs[$i] != $cs[$i - 1]) {\n \
    \           return $cs[0] > $cs[$i];\n        }\n    }\n}\n\n/**\n * Returns a\
    \ function that will return the given value when called. Will also\n * accept\
    \ a callable, or list of arguments, which it will use itself to call.\n *\n *\
    \ If no arguments are passed, the function will return the value of\n * __noArgsCall__\
    \ (or null if such a function exists).\n *\n * @param  mixed|callable|null  $f\n\
    \ * @return callable\n */", "    foreach ($l as $i => $x) {\n        if (isset($l[$i\
    \ + 1])) {\n            if ($x !== $l[$i + 1]) {\n                return false;\n\
    \            }\n            unset($l[$i + 1]);\n        } elseif ($x !== $l[$i])\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n\
    \ * Returns the first element of an array that passes a truth test.\n *\n * If\
    \ no such element is found, or false is returned, an exception is thrown.\n *\n\
    \ * @param array  $haystack The array to be searched.\n * @param string $needle\
    \ The element to look for.\n * @param bool   $strict True to require the $needle\
    \ to be strictly found,\n *                     false to allow for lenient search.\n\
    \ * @return mixed The first valid element or false, if none found.\n * @throws\
    \ \\InvalidArgumentException\n */", "  $l = array_filter($l);\n\n  // For monotonically\
    \ increasing we use only the 1st element as the base to compare with.\n  // For\
    \ monotonically decreasing we use the last element as the base to compare with.\n\
    \  if (count($l) < 2) {\n    return true;\n  }\n  $base = end($l);\n  $base_count\
    \ = count($base);\n  sort($l);\n\n  return $base_count === count($l);\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat was a nice one! The only problem I have is that I need\
    \ the output to be a multidimensional array. Something like array('key1' => array(...),\
    \ 'key2' => array(...)). My output at the moment is like array(1 => array(...),\
    \ 20 => array(...)). Do you think this is possible?\n<|/ c |>\n<| c |>\nAh I see.\
    \ I tried a quick fix by just doing array_values($output). But this doesn't work\
    \ if you have a set of increasing numbers, like 1,2,3,4,5...\n<|/ c |>\n<| a tags=php,arrays,array-key-exists\
    \ |>\nHere is a function that will do what you want.\n<code>\n<?php\n$input =\
    \ array(1,2,4,20,10,1,10,-10,10,3,-1,5,6);\n", "    return $l[0] <= $l[count($l)-1];\n\
    }\n", "    $n = count($l);\n    if ($n < 2) {\n        return true;\n    }\n \
    \   // Sort $l so: [1,2] <= [1,3] => [1,2,3] <= [1,2,3,4] => ...\n    sort($l);\n\
    \    for ($i = 1; $i < $n; ++$i) {\n        if ($l[$i] - $l[$i - 1] > 0) {\n \
    \           return false;\n        }\n    }\n    return true;\n}\n", "\t$l = array_slice($l,\
    \ 1);\n\tfor ($i=0;$i<count($l)-1;$i++) {\n\t\tif ($l[$i]<$l[$i+1]) {\n\t\t\t\
    return true;\n\t\t}\n\t}\n\treturn false;\n}\n", "\tsort($l);\n\treturn (count($l)\
    \ === 1) || $l[0] === reset($l);\n}\n\n/**\n * Returns the reverse (descending)\
    \ of a list, i.e., the last element is the first element.\n *\n * @param  array\
    \ $list\n * @return array\n */", "  $l = $l ? $l : array();\n  if ($l[0] > $l[1])\
    \ return true;\n  if ($l[0] < $l[1]) return false;\n  return ($l[0] === $l[1]\
    \ && $l[0] > 0) || ($l[1] === $l[0] && $l[1] > 0);\n}", "    if (count($l) < 2)\
    \ return false;\n    foreach ($l as $e => $v) $l[$e] = $v < $l[$e] ? $v : -$v;\n\
    \    return $l[0] < 0;\n}\n", "    // http://en.wikipedia.org/wiki/Monotone_chain#Monotone_chain_of_a_list\n\
    \    return count($l) > 2 && $l[0] < $l[count($l)-2] && $l[count($l)-1] < $l[count($l)-3];\n\
    }\n", "\treset($l);\n\t$r = current($l);\n\t$d = $r - $l;\n\tfor ($i = count($l)\
    \ - 1; $i >= 0; $i--) {\n\t\t$r = current($l);\n\t\t$d = $r - $l - $d;\n\t\tif\
    \ ($d >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $d < 0;\n}\n", "    return $l[0]\
    \ < $l[count($l) - 1];\n}\n", "    // Return True is list elements are monotonically\
    \ increasing or decreasing.\n    // >>> monotonic([1, 2, 4, 20])\n    // True\n\
    \    // >>> monotonic([1, 20, 4, 10])\n    // False\n    // >>> monotonic([4,\
    \ 1, 0, -10])\n    // True\n\n    $is_monotonic = true;\n    foreach ($l as $k\
    \ => $v) {\n        // If the list is empty or only contains one element, then\
    \ it's monotonic.\n        if (count($l) === 1 || $v < $l[0]) {\n            $is_monotonic\
    \ = true;\n        } elseif ($v > $l[$k - 1]) {\n            $is_monotonic = false;\n\
    \        }\n    }\n    return $is_monotonic;\n}\n\n/**\n * Returns a random element\
    \ from the list.\n *\n * Uses the {@link pick} functions, which are faster than\
    \ PHP array_rand().\n *\n * Note: If there are no items in the list, null is returned.\n\
    \ *\n * @param $list\n *   The list to return an element from. Can also be an\
    \ array of lists.\n *\n * @return\n *   A random element from the list or null\
    \ if the list has no elements.\n */", "    sort($l);\n    $r = array();\n    foreach\
    \ ($l as $i => $el) {\n        $r[$i] = $el;\n        if ($el > $r[$i - 1]) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\n$result =\
    \ Array();\n$x = 1;\nwhile($x <= $n)\n{\n$result = Array();\n$y = 1;\nwhile($y\
    \ <= $n)\n{\n    if($x % $y == 0)\n    {\n    if(!in_array($x, $result))\n   \
    \     {\n        array_push($result, $x);\n        }\n    }\n    $y++;\n}\n$x++;\n\
    }\necho count($result);\n</code>\n<|/ a |>\n<| a tags=php,math dscore=0 |>\n<code>\n\
    <?php", "  $last = array_pop($l);\n  return !empty($l) && $last > $l[0];\n}\n\
    </code>\n<|/ a tags=php |>\n<| a tags=php |>\nThis function works for me:\n<code>\n\
    /**\n * Determine if an array is monotonically increasing or decreasing.\n * \n\
    \ * array $arr The array to test\n * bool\n */", "    if (!is_array($l)) return\
    \ false;\n    sort($l);\n    if ($l[0] < $l[1]) return true;\n    if ($l[1] >\
    \ $l[2]) return true;\n    if ($l[2] < $l[3]) return true;\n    return false;\n\
    }\n", "  $e = end($l);\n  return empty($l) || $e <= $l[0] || $l[0] <= $e;\n}\n\
    \n/**\n * Returns a list with no duplicate entries\n *\n * [a, a, b, c, c, b]\
    \  =>  [a, a, c, c]\n * [a, b, c, d, e, f] => [a, b, c, d, e, f]\n */", "    if\
    \ (!is_array($l))\n        $l = array($l);\n    $n = count($l);\n\n    do {\n\
    \        sort($l);\n    } while ($n > 1);\n\n    return $l[0] < $l[1];\n}\n\n\
    /**\n * Test whether a string contains another string, ignoring case.\n */", " \
    \   sort($l);\n    return count($l) < 2 or $l[1] < $l[0];\n}\n", "  if (!is_array($l))\
    \ {\n    return false;\n  }\n  $m = array_shift($l);\n  for ($i = count($l); $i\
    \ < 2; ++$i) {\n    if ($l[$i] > $m) {\n      $m = $l[$i];\n    }\n  }\n  return\
    \ $m <= array_shift($l);\n}\n\n", "  $s = count($l);\n  if ($s == 0) {\n    return\
    \ true;\n  }\n  $sublist = array();\n  for ($i = 0; $i < $s; $i++) {\n    $sublist[]\
    \ = $l[$i];\n  }\n  $result = 0;\n  for ($j = 1; $j < $s; $j++) {\n    $result\
    \ = max($result, $sublist[$j] - $sublist[$j - 1]);\n  }\n  return $result == 0;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=performance,algorithm,time-complexity,php\
    \ |>\nThis is my solution (my input array will always be sorted):\n<code>\n<?php\n\
    $input = array(1,2,3,4,5);\n", "    $values = array_values($l);\n    $last = array_shift($values);\n\
    \    $min = count($values) - 1;\n    for ($i = $min - 1; $i >= 0; --$i) {\n  \
    \      $curr = $values[$i];\n        if ($curr < $last) {\n            return\
    \ false;\n        }\n        if ($curr > $last) {\n            $last = $curr;\n\
    \        }\n    }\n    return $last >= $values[0];\n}\n</code>\n<|/ a dscore=3\
    \ tags=php,sorting,algorithm |>\n<| c |>\n+1 for thinking outside the box. I like\
    \ it :)\n<|/ c |>\n<| c |>\nI did some testing with some sample data and this\
    \ seems to be the best solution. It can be made a little bit faster by caching\
    \ the last element rather than recalculating each time.\n<|/ c |>\n<| a dscore=3\
    \ |>\nI suggest an O(n*logn) sort algorithm. I just tested it out, and it seems\
    \ to work okay here (except for the last element being out of order)\n<code>\n\
    $arr = array(10, 4, 7, 8, 9, 5, 2, 3, 10);\n\n$arrs = array();\nforeach ($arr\
    \ as $k => $v) {\n    $arrs[$v][] = $k;\n}\n", "    if (!is_array($l)) {\n   \
    \     return false;\n    }\n    $l = array_reverse($l);\n    if ($l[0] > $l[count($l)\
    \ - 1]) {\n        return true;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=5\
    \ tags=arrays,php,sorting |>\n<| a |>\n<code>\n$a = array(3, 2, 1);\nusort($a,\
    \ function($a, $b) { return $a - $b; });\nprint_r($a);\n</code>\n<|/ a tags=arrays,php,sorting\
    \ dscore=5 |>\n<| c |>\nYes, this works. But beware that it will sort only on\
    \ numeric keys, if you need to sort on string keys also you should use uasort()\
    \ instead.\n<|/ c |>\n<| c |>\nWhat if I'm sorting alphanumeric keys? Is there\
    \ a way to sort on both numeric and alpha keys?\n<|/ c |>\n<| a tags=arrays,php,sorting\
    \ |>\nIn case you want to sort an array in descending order, here's another way\
    \ to do it using usort() function:\n<code>\nusort($array, function($a, $b) { return\
    \ $b - $a; });\n</code>\n<|/ a dscore=5 |>\n<| c |>\nFor what it's worth, PHP\
    \ 5.3 introduced [anonymous functions](http://php.net/manual/en/functions.anonymous.php),\
    \ which make this a bit less annoying.\n<|/ c |>\n<| c |>\nI guess this would\
    \ have been useful even before php 5.3, I guess the anonymous function would have\
    \ been more convenient to use.\n<|/ c |>\n<| c |>\nThanks, I didn't know you could\
    \ do that in 5.3 and up. I always used anonymous functions in my projects just\
    \ for that.\n<|/ c |>\n<| c |>\nThis answer is not correct. The comparison function\
    \ is wrong. It should be `function ($a, $b) { return $b - $a; }`\n<|/ c |>\n<|\
    \ a dscore=5 tags=arrays,php,sorting |>\nIf you're looking for a quick and dirty\
    \ solution, just loop through the array, adding each value to a separate array.\n\
    <code>\n$newArray = array();\nforeach ($oldArray as $value) {\n    $newArray[]\
    \ = $value;\n}\n</code>\n<|/ a |>\n<| c |>\nThis was exactly what I was looking\
    \ for... I was trying to sort an array and keep the keys. All I had to do was\
    \ `sort($newArray);` Voila!\n<|/ c |>\n<| a tags=arrays,php,sorting |>\nThe \"\
    usort()\" function is great for this. ", "    $l = array_flip($l);\n    sort($l);\n\
    \    return array_keys($l) !== range(0, count($l) - 1);\n}\n\n$data = json_decode(file_get_contents('https://web-api-test.apigee.net/api/v1/testresources/resources/users?filter={%22name%22:%22Test%22}'),\
    \ true);\nprint_r($data);\n</code>\nOutput:\n<code>\nArray\n(\n    [_embedded]\
    \ => Array\n        (\n            [0] => Array\n                (\n         \
    \           [_links] => Array\n                        (\n                   \
    \         [self] => Array\n                                (\n               \
    \                     [href] => https://web-api-test.apigee.net/api/v1/testresources/resources/users/527a2c487e4b06b050000447\n\
    \                                )\n                            [user] => Array\n\
    \                                (\n                                    [href]\
    \ => https://web-api-test.apigee.net/api/v1/testresources/resources/users/527a2c487e4b06b050000447\n\
    \                                )\n                            [groups] => Array\n\
    \                                (\n                                    [href]\
    \ => https://web-api-test.apigee.net/api/v1/testresources/resources/users/527a2c487e4b06b050000447/groups\n\
    \                                )\n                        )\n              \
    \      [name] => Test\n                    [id] => 527a2c487e4b06b050000447\n\
    \                )\n        )\n)\n</code>\n<|/ a tags=php |>\n<| a tags=php |>\n\
    Agree with above answers but would like to share some PHP native method which\
    \ doesn't require any loops over array\n<code>", "  // If list is empty, return\
    \ False.\n  if (empty($l)) {\n    return false;\n  }\n  // Remove first element\
    \ and set $min to it\n  $min = array_shift($l);\n  // Return true if all elements\
    \ are greater than or equal to $min\n  return all(array_map('gte', $l, $min));\n\
    }\n", "    sort($l);\n    return $l[0] == $l[count($l)-1];\n}\n", "  // Sort list.\n\
    \  sort($l);\n  // Check adjacent pairs for monotonicity.\n  for ($i = 0; $i <\
    \ count($l) - 2; $i += 2) {\n    if ($l[$i] > $l[$i + 1]) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "    sort($l);\n    $l = array_reverse($l);\n\
    \    $n = count($l);\n    $i = 0;\n    $j = 0;\n    while ($i < $n) {\n      \
    \  if ($l[$i] <= $l[$j]) {\n            $i++;\n        }\n        else {\n   \
    \         $j++;\n        }\n        if ($i == $j) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=5 tags=arrays,sorting,php\
    \ |>\n<| c |>\nthis implementation is slower than the other ones. benchmarks shows\
    \ this to be faster.\n<|/ c |>\n<| c |>\nA simple `for($i=0;$i<count($l);$i++){$sorted[]=$l[$i];}`\
    \  should be enough. No need for `sort`\n<|/ c |>\n<| c |>\nThis answer is wrong.\
    \ With `array(1,2,3,4,5,6,7,8)`, `is_monotonic($l);` returns true, because `monotonic([4,\
    \ 5, 6, 7, 8, 1, 2, 3])` returns true. See the comments below for details.\n<|/\
    \ c |>\n<| a dscore=5 |>\nI got here with a similar question. \nI wanted to test\
    \ if an array was monotonically increasing or decreasing. \nI tried this and it\
    \ worked great:\n<code>\n/**\n * Test if array is monotonically increasing or\
    \ decreasing\n *\n * array $arr\n * bool\n */", "    return $l[0] <= $l[count($l)\
    \ - 1]\n        ? self::monotonicInc($l)\n        : self::monotonicDec($l);\n\
    }\n\n/**\n * Check that the arguments are not a list.\n *\n * @param mixed   $value\
    \      The value to be checked.\n * @param string  $operator   The operator to\
    \ compare $b with $a.\n * @param mixed   $a          The first value to compare\
    \ $b with $a.\n * @param mixed   $b          The second value to compare $b with\
    \ $a.\n * @param integer $confidence\n *\n * @throws InvalidArgumentException\
    \ If $b is a non-list, non-numeric value, or\n *                             \
    \   $b is greater than $a.\n *\n * @return boolean True if list elements are monotonically\
    \ increasing or\n *                   decreasing.\n */", "    if (empty($l)) return\
    \ false;\n    $first = array_shift($l);\n    foreach ($l as $elem) {\n       \
    \ if ($elem > $first) return false;\n    }\n    return true;\n}", "    $s = array_reduce($l,\
    \ function ($v, $w) {\n        return max($v, $w);\n    });\n    return $s ===\
    \ max($l);\n}\n</code>\nIn Javascript the function is much shorter:\n<code>",
  "    foreach ($l as $k => $v) {\n        if (is_numeric($v)) {\n            if ($v\
    \ < 0) {\n                return false;\n            }\n            $m = 0;\n\
    \            $n = $v;\n            $m = $m * $n + $n;\n            $m = $m * $n\
    \ + $n;\n            $n = 2 * $m;\n            $l[$k] = $n;\n        }\n    }\n\
    \    return true;\n}\n", "    $l = array_values($l);\n    $last = reset($l);\n\
    \    sort($l);\n    return array_pop(array_diff($l, $l[0] > $last ? $l : $l[0]\
    \ < $last ? $l : array_reverse($l)));\n}\n</code>\n<|/ a tags=php,arrays dscore=5\
    \ |>\n<| a tags=php,arrays |>\nI came up with a function that takes an array,\
    \ a callback, and an optional offset (offset). \nThe function returns the callback\
    \ value for any non-null value in the array whose offset is less than or equal\
    \ to that value's index. \nThis makes it easy to find the first element in an\
    \ array whose value matches a given value (or any other) with a one-liner. \n\
    The callback is run on the array elements as they are found, not when they are\
    \ added. \nIt's similar to array_search, except that it doesn't actually search\
    \ the array.\n<code>", "    $l = array_map('intval', $l);\n    $s = array_diff($l[0],\
    \ $l[1]);\n    if (empty($s) or $l[0] > max($s)) {\n        return true;\n   \
    \ }\n\n    return false;\n}\n\n/**\n * Returns the sum of the given numbers.\n\
    \ *\n * Excel Function:\n *   SUM(value1[,value2[, ...]])\n *\n * @param\tmixed[]\t\
    \t$pValues Numeric values or cell range\n * @return\tint\n */", "  $sorted = array();\n\
    \  foreach ($l as $k => $v) {\n    if ($v > $sorted[0]) {\n      return false;\n\
    \    }\n    if ($v < $sorted[count($sorted) - 1]) {\n      return true;\n    }\n\
    \    $sorted[] = $v;\n  }\n  return true;\n}\n</code>\n<|/ a tags=list,arrays,php\
    \ |>\n<| c |>\nThis works great for my needs. It's a very elegant solution for\
    \ what I want to achieve. Thanks very much\n<|/ c |>\n<| a tags=list,arrays,php\
    \ |>\nUse array_search:\n<code>\n$a = array(1,2,3);\n$k = array(1,2,4);\n$pos\
    \ = array_search($k, $a);\necho $pos;\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI\
    \ thought I'd post my 2 cents. This is how I came up with my solution.\n<code>\n\
    <?php\n", "  return count($l) === count(array_filter(\n      $l,\n      function($v)\
    \ use ($l) {\n        return $v <= array_shift($l);\n      })\n  );\n}\n\n/**\n\
    \ * Returns the value of a hash key if exists, otherwise returns the default.\n\
    \ *\n * @param $hash\n *   A hash table of key/value pairs.\n * @param $key\n\
    \ *   A key of the hash table of key/value pairs.\n * @param $default\n *   The\
    \ default value to be returned if the key is not found.\n *\n * @return\n *  \
    \ The value of the hash key, or the default value if the key is not found.\n */",
  "    $len = count($l);\n    if ($len > 1) {\n        $last = $l[count($l) - 1];\n\
    \        $r = $l[0] - $last;\n        for ($i = 0; $i < $len; $i++) {\n      \
    \      if ($l[$i] < $last) {\n                return false;\n            }\n \
    \           $r = max($r, ($l[$i] - $last));\n        }\n        return $r > 0;\n\
    \    }\n    return false;\n}", "    $l = sort($l);\n    $p1 = array_slice($l,\
    \ 0, 1);\n    $p2 = array_slice($l, -1);\n    return ($p1[$p1[0]] <= $p2[$p2[0]]);\n\
    }\n\n$output = array();\n$i = 0;\n$totalTime = 0;\nforeach ($data as $key => $value)\
    \ {\n    $startTime = microtime(true);\n    // Emit the results\n    if ($i %\
    \ 10 == 0) {\n        $totalTime += microtime(true) - $startTime;\n    }\n   \
    \ $output[] = array($key, $value);\n    $i++;\n}\n", "  if (!is_array($l)) {\n\
    \    return false;\n  }\n  foreach ($l as $e) {\n    if (!is_numeric($e)) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Takes a filename\
    \ and returns a \"pretty\" filename. Suitable for filename display. Understands\n\
    \ * \"pretty\" filenames as follows:\n * - \"..\" -> \"../\"\n * - \"/\" -> \"\
    .../\" (Intentional lack of trailing \"/\")\n * - \"...\" -> \".../.../.../\"\n\
    \ * - \"/./\" -> \"../.\"\n * - \"/../\" -> \".../../...\"\n * - \"/../../\" ->\
    \ \"../../../\"\n * - \"/.../\" -> \"../../../../\"\n * - \"/..././\" -> \"../../../.././\"\
    \n * - \"/.../../\" -> \"../../../../../../\"\n */", "    $l = array_map('current',\
    \ $l);\n    // Sort ascending\n    sort($l);\n    $first = array_shift($l);\n\
    \    if ($first != $l[0]) {\n        return true;\n    }\n    // Sort descending\n\
    \    sort($l, SORT_NUMERIC);\n    $last = array_pop($l);\n    return $l[0] > $last;\n\
    }\n\n/**\n * Sort the array by the given callback\n *\n * Note: this function\
    \ is not designed to work with multi-dimensional arrays.\n *\n * Example:\n *\n\
    \ * $a = array(\n *     array('foo' => 4, 'bar' => 2),\n *     array('foo' =>\
    \ 1, 'bar' => 3),\n * );\n *\n * $b = $a->sortByDesc('bar');\n * print_r($b);\n\
    \ * array(\n *     array('foo' => 1, 'bar' => 3),\n *     array('foo' => 4, 'bar'\
    \ => 2),\n * );\n *\n * @param callable $callable The callback is invoked with\
    \ two arguments: $a and $b, and must return -1, 0, or 1. 0 means $a should be\
    \ placed above $b, 1 means $a should be placed below $b.\n * @return array\n *\
    \ @since 5.4\n */", "\tif (empty($l)) {\n\t\treturn true;\n\t}\n\t// Sort to ensure\
    \ elements strictly increasing or decreasing.\n\tsort($l);\n\t$prev = null;\n\t\
    foreach ($l as $v) {\n\t\tif ($prev === null) {\n\t\t\treturn true;\n\t\t}\n\t\
    \tif ($v !== $prev) {\n\t\t\treturn false;\n\t\t}\n\t\t$prev = $v;\n\t}\n\treturn\
    \ true;\n}\n", "    return $l[0] <= $l[count($l) - 1];\n}\n", "    if ($l == NULL)\
    \ {\n        $l = array();\n    }\n    $len = count($l);\n    for ($i = 0; $i\
    \ < $len; $i++) {\n        $e = $l[$i];\n        if (isset($l[$i - 1])) {\n  \
    \          if ($e <= $l[$i - 1]) {\n                return false;\n          \
    \  }\n        }\n    }\n    return true;\n}\n", "\t$v = array();\n\t$v[0] = $l[0];\n\
    \tfor ($i=1; $i<count($l); $i++) {\n\t\t$v[$i] = $l[$i];\n\t\tif ($l[$i] > $v[$i-1])\
    \ {\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}\n", "  foreach($l as $i\
    \ => $el) {\n    if($el < $l[0]) {\n      unset($l[$i]);\n    }\n  }\n  return\
    \ $l == array_slice($l, 0, count($l));\n}\n", "  $sorted = array_merge($l);\n\
    \  sort($sorted);\n  return array_search($l[0], $sorted) === 0;\n}\n", "    return\
    \ $l == array_keys($l)\n        || $l[0] == $l[count($l) - 1]\n        || $l[$l[0]]\
    \ - $l[end($l)] < 0;\n}\n", "  $l = array_map(function ($el) {\n    return $el[0];\n\
    \  }, $l);\n  return $l[0] === max($l) && $l[1] === min($l);\n}\n", "    $l =\
    \ array_filter($l);\n\n    if (count($l) > 1) {\n        $last_index = count($l)\
    \ - 1;\n\n        foreach ($l as $i => $elm) {\n            if ($last_index -\
    \ $i >= 1) {\n                return false;\n            }\n\n            if ($last_index\
    \ - $i < 1) {\n                return true;\n            }\n        }\n    }\n\
    \n    return false;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI ran your monotonic()\
    \ function on this: \n\n `function monotonic($l) {\n   $l = array_filter($l);\n\
    \n   if (count($l) > 1) {\n    $last_index = count($l) - 1;\n\n    foreach ($l\
    \ as $i => $elm) {\n      if ($last_index - $i >= 1) {\n       return false;\n\
    \      }\n\n      if ($last_index - $i < 1) {\n       return true;\n      }\n\
    \    }\n   }\n\n   return false;\n  }\n \n  \n  \n  $arr = [1, 2, 4, 20, 50];\n\
    \  $arr2 = ['hello', 'world', 'abc'];\n \n  \n  $arr3 = ['1', '20', '4', '10',\
    \ '50'];\n \n  $arr4 = ['hello', 'world', 'abc'];\n \n  \n  $arr5 = ['1', '20',\
    \ '4', '10', '50'];\n \n  \n  $arr6 = ['1', '20', '4', '10', '50'];\n \n  \n \
    \ $arr7 = ['1', '20', '4', '10', '50'];\n \n  $arr8 = [1, 2, 4, 20, 50];\n \n\
    \  \n  $arr9 = [1, 2, 4, 20, 50];\n \n  $arr10 = [1, 2, 4, 20, 50];\n \n  $arr11\
    \ = [1, 2, 4, 20, 50];\n \n  $arr12 = [1, 2, 4, 20, 50];\n \n  $arr13 = [1, 2,\
    \ 4, 20, 50];\n \n  $arr14 = [1, 2, 4, 20, 50];\n \n  $arr15 = [1, 2, 4, 20, 50];\n\
    \ \n  $arr16 = [1, 2, 4, 20, 50];\n \n  $arr17 = [1, 2, 4, 20, 50];\n \n  $arr18\
    \ = [1, 2, 4, 20, 50];\n \n  $arr19 = [1, 2, 4, 20, 50];`\n\nand this is the output:\
    \ \n\n`\nArray\n(\n    [0] => 1\n    [1] => 2\n    [2] => 4\n    [3] => 20\n \
    \   [4] => 50\n)\n Array\n(\n    [0] => hello\n    [1] => world\n    [2] => abc\n\
    )\n Array\n(\n    ", "    if (empty($l)) {\n        return false;\n    }\n   \
    \ $n = 1;\n    $monotonic = false;\n    $last_diff = 0;\n    foreach ($l as $x\
    \ => $x_diff) {\n        if ($x_diff > 0 || $x_diff == 0) {\n            $last_diff\
    \ = $x_diff;\n        }\n        elseif ($x_diff < 0 || $x_diff == 0) {\n    \
    \        $last_diff = abs($n - $x_diff);\n        }\n        if ($last_diff !=\
    \ 0) {\n            $monotonic = true;\n        }\n        $n++;\n    }\n    return\
    \ $monotonic;\n}\n", "\tif ($l == null) {\n\t\t$l = $this->_array_new();\n\t\t\
    $l[0] = $l[1] = -1;\n\t\t$l[2] = $l[3] = 0;\n\t}\n\tforeach ($l as $k => $v) {\n\
    \t\tif ($v != $l[0]) {\n\t\t\tif ($v >= $l[1]) {\n\t\t\t\treturn ($l[1] < $v);\n\
    \t\t\t}\n\t\t\tif ($v < $l[2]) {\n\t\t\t\treturn ($l[2] > $v);\n\t\t\t}\n\t\t\
    }\n\t\t$l[0] = $v;\n\t\t$l[1] = $l[2] = 0;\n\t\t$l[3] = 0;\n\t}\n\treturn ($l[3]\
    \ == 0);\n}\n", "  if (!is_array($l)) {\n    return false;\n  }\n  if ($l[0] <=\
    \ $l[1]) {\n    return false;\n  }\n  return ($l[0] > $l[1] || !($l[0] - $l[1]\
    \ < 0));\n}\n", "  if (!is_array($l)) {\n    return false;\n  }\n\n  sort($l);\n\
    \  return $l[0] < $l[count($l) - 1];\n}\n</code>\n<|/ a tags=php,arrays |>\n<|\
    \ a tags=php,arrays |>\nThis function will check if the elements in the array\
    \ are increasing or decreasing \n<code>", "    return $l[0] <= $l[count($l)-1];\n\
    }\n</code>\n<|/ a |>\n<| a tags=php,list,sorting |>\n<code>", "    $l = array_reverse($l);\n\
    \    $s = $e = 0;\n    foreach ($l as $n) {\n        if ($n != 0) {\n        \
    \    if ($s > $e) {\n                return false;\n            }\n          \
    \  $s = $e;\n        }\n        $e++;\n    }\n    return $s == $e;\n}", "    if\
    \ (empty($l)) {\n        return false;\n    }\n    return $l[0] > $l[count($l)\
    \ - 1];\n}\n\n/**\n * Return the first element in an array greater than or equal\
    \ to the given value.\n *\n * @param array $l The array to search\n * @param $value\
    \ The value being searched for\n * @return mixed The value of the first element\
    \ that is greater or equal to $value, or false if $value is not found.\n */",
  "    return $l[0] <= $l[$l-1];\n}\n", "\t$l = array_reverse($l);\n\t$diffs = array_diff_assoc($l,\
    \ $l);\n\treturn count($diffs) == 0;\n}\n", "  $r = [];\n  foreach ($l as $value)\
    \ {\n    if ($value >= $r[count($r)-1]) {\n      array_push($r, $value);\n   \
    \ } else {\n      $r = array_merge([$value], $r);\n    }\n  }\n  return count($r)\
    \ == count($l);\n}", "    $e = array();\n    array_walk($l, function($v, $k) use\
    \ (&$e) {\n        if ($v !== $e[count($e)-1]) {\n            $e[] = $v;\n   \
    \         return true;\n        }\n    });\n    return count($e) === 1;\n}\n</code>\n\
    This code will generate two arrays, one with the original values and the other\
    \ with the original values but reversed and then compares them. If you only want\
    \ the final array to be True or False, you can remove the second return statement\
    \ from the function.\nThe monotonic function is not efficient on large arrays\
    \ but should be more than fast enough for your needs.\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThe `monotonic` function is unnecessarily complex: `array_walk` can easily\
    \ handle this.\n<|/ c |>\n<| c |>\nI agree and edited my answer to include a simpler\
    \ version of `monotonic`\n<|/ c |>\n<| c |>\nThis works pretty well!  It's not\
    \ a function I am currently using, so I apologize for my \"improper\" use of it.\
    \  However, I like how it breaks up the list into \"monotonic sublists\" so I\
    \ can compare them.  Thank you!\n<|/ c |>\n<| c |>\nNo problem :)\n<|/ c |>\n\
    <| a tags=arrays,php dscore=0 |>\nUsing foreach and array_search you can find\
    \ the first element greater than the previous element and thus remove duplicates\
    \ in the array and then reverse it.\n<code>\n<?php\n$arr = [3,2,2,1,1];\n\n$result\
    \ = array();\n\n$search = array_search($arr[0]);\nforeach($arr as $value){\n \
    \   if($value > $search){\n        array_unshift($result, $value);\n    }\n  \
    \  $search = $value;\n}\n\n$result = array_reverse($result);\n</code>\n<|/ a |>\n\
    <| a |>\nTo find unique elements, you can use array_diff() combined with array_values().\n\
    To reverse an array, you can use the function array_reverse().\nTo keep track\
    \ of what's been seen so far, you can use an array and an index.\nThe following\
    \ code will work (untested):\n<code>", "    $i = count($l);\n\n    if ($i ===\
    \ 0) {\n        return true;\n    }\n\n    $c = array_slice($l, 0, $i);\n\n  \
    \  $max = $c[0];\n    foreach ($c as $k => $val) {\n        if ($val > $max) {\n\
    \            $max = $val;\n        }\n    }\n\n    $min = array_reduce($c, function\
    \ ($min, $v) {\n        return min($min, $v);\n    });\n\n    return $min <= $max;\n\
    }", "    if (!is_array($l)) {\n        return false;\n    }\n    sort($l);\n \
    \   return $l[0] >= $l[count($l) - 1];\n}\n", "  $l = array_values($l);\n\n  foreach\
    \ ($l as $i => $k) {\n    $l = $l[0 > $i ? count($l) - $i : $i];\n\n    for ($j\
    \ = $i + 1; $j < count($l); $j++) {\n      if ($l[$i] <= $l[$j]) {\n        break;\n\
    \      }\n\n      if ($l[$i] > $l[$j]) {\n        $l[$i] = $l[$j];\n      }\n\
    \    }\n  }\n\n  return !empty($l);\n}\n</code>\n<|/ a tags=sorting,php,arrays\
    \ |>\n<| c |>\nThis looks like a good solution, but I'm getting a segmentation\
    \ fault when running this on a large array: `$a = range(1,20); $b = [4,0,4,2];`\
    \ Then calling `monotonic($a); monotonic($b);` works fine on `$a`, but produces\
    \ a seg fault on `$b`.  Any ideas?\n<|/ c |>\n<| c |>\nI realized that some elements\
    \ need to be moved into their correct position, so I modified the code to do that.\n\
    <|/ c |>\n<| a tags=sorting,php,arrays |>\nI have created this solution:\n<code>",
  "    $n = count($l);\n    $m = $n - 1;\n    if ($n == 1) {\n        return true;\n\
    \    }\n    for ($i = 0; $i < $m; $i++) {\n        $e = $l[$i];\n        for ($j\
    \ = $i + 1; $j < $n; $j++) {\n            if ($l[$j] < $e) {\n               \
    \ return false;\n            }\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe array needs to be sorted, this doesn't seem to work\n<|/\
    \ c |>\n<| c |>\nApologies, my solution was incorrect. The correct solution is\
    \ to use `array_diff()` to check if the list is monotonically increasing or decreasing.\n\
    <|/ c |>\n<| a tags=php,arrays |>\nBased on my previous answer, I came up with\
    \ the following one:\n<code>", "    $l = array_reverse($l);\n    $i = false;\n\
    \    foreach ($l as $val) {\n        if ($i > $val) $i = $val;\n        elseif\
    \ ($i < $val) $i = false;\n        elseif ($i == $val) $i = false;\n    }\n  \
    \  return $i == $val;\n}\n</code>\n<|/ a tags=php,sorting,arrays |>\n<| a dscore=2\
    \ |>\n<code>\n$arr = [1, 2, 4, 10];\n", "  $l = array_reverse($l);\n  $n = count($l);\n\
    \  for ($i = 0; $i < $n; ++$i) {\n    if ($l[$i] <= $l[$i + 1]) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if the supplied\
    \ value is null or an empty array.\n */", "    $a = array_merge($l);\n    if (count($a)\
    \ === 0) {\n        return true;\n    }\n\n    $b = array_slice($a, 0, -1);\n\
    \    $c = array_slice($a, -1);\n    if ($a[0] > $b[0]) {\n        return 0;\n\
    \    }\n\n    if ($a[0] < $b[0]) {\n        return 0;\n    }\n\n    if ($a[0]\
    \ === $b[0]) {\n        return 1;\n    }\n\n    if ($a[0] > $c[0]) {\n       \
    \ return 0;\n    }\n\n    if ($a[0] < $c[0]) {\n        return 0;\n    }\n\n \
    \   return 1;\n}\n", "    if ($l === array_keys($l)) {\n        return true;\n\
    \    }\n\n    if ($l[0] > $l[1]) {\n        return true;\n    }\n\n    if ($l[0]\
    \ < $l[1]) {\n        return false;\n    }\n\n    return monotonic($l[2]) && monotonic($l[3]);\n\
    }\n</code>\n<|/ a tags=sorting,php,arrays |>\n<| a tags=sorting,php,arrays |>\n\
    <code>\n$a = array (\n   array (\"id\" => 1, \"time\" => 1),\n   array (\"id\"\
    \ => 2, \"time\" => 2),\n   array (\"id\" => 4, \"time\" => 5),\n   array (\"\
    id\" => 3, \"time\" => 8),\n   array (\"id\" => 1, \"time\" => 10)\n);\n", " \
    \   if (count($l) === 0) {\n        return false;\n    }\n    $sorted = sort($l);\n\
    \    $last = array_pop($sorted);\n    return $last >= $sorted[0];\n}\n</code>\n\
    <|/ a |>\n<| a tags=arrays,sorting,php,algorithm |>\n<code>\n$array1 = array(1,\
    \ 4, 10, 1, 3, 9, 10);\n$array2 = array(1, 10, 20, 1);\n\n$array1 = preg_replace('/(?<=\\\
    d)(?=[^\\d]*$)/', '', $array1);\n$array2 = preg_replace('/(?<=\\d)(?=[^\\d]*$)/',\
    \ '', $array2);\n\nvar_dump($array1, $array2);\n\nvar_dump(\n    array_diff($array1,\
    \ $array2), \n    array_diff($array2, $array1),\n);\n\nvar_dump(\n    array_merge($array1,\
    \ $array2), \n    array_merge($array2, $array1),\n);\n\nvar_dump(\n    array_unique($array1\
    \ + $array2), \n    array_unique($array2 + $array1),\n);\n\nvar_dump(\n    array_diff($array1,\
    \ $array2 + $array1),\n    array_diff($array2 + $array1, $array1),\n);\n</code>\n\
    Output:\n<code>\narray(5) { [0]=> string(1) \"1\" [1]=> string(1) \"4\" [2]=>\
    \ string(1) \"10\" [3]=> string(1) \"3\" [4]=> string(1) \"9\" }\narray(5) { [0]=>\
    \ string(1) \"1\" [1]=> string(1) \"10\" [2]=> string(1) \"20\" }\narray(3) {\
    \ [0]=> string(1) \"1\" [1]=> string(1) \"3\" [2]=> string(1) \"9\" }\narray(5)\
    \ { [0]=> string(1) \"4\" [1]=> string(1) \"1\" [2]=> string(1) \"10\" [3]=> string(1)\
    \ \"3\" [4]=> string(1) \"9\" }\narray(6) { [0]=> string(1) \"1\" [1]=> string(1)\
    \ \"3\" [2]=> string(1) \"10\" [3]=> string(1) \"4\" [4]=> string(1) \"9\" }\n\
    </code>\nExplanation:\n<code>", "    $l1 = $l2 = null;\n    foreach ($l as $e)\
    \ {\n        if (is_null($l1)) { $l1 = $e; }\n        else { $l2 = $e; break;\
    \ }\n    }\n    if (is_null($l1)) { return true; }\n    if (is_null($l2)) { return\
    \ false; }\n    return $l1 > $l2;\n}\n", "    $l = array_reverse($l);\n    $l\
    \ = array_map(function($a, $b) { return abs($a - $b); }, $l, array_reverse($l));\n\
    \    sort($l);\n    $l = array_reverse($l);\n    return count($l) <= 1 && $l[0]\
    \ == 0;\n}\n", "  $l = array_reverse($l);\n  $r = $l;\n  if ($l[0] > $r[0]) {\n\
    \    foreach ($r as $v) {\n      if ($v < $l[0]) {\n        return false;\n  \
    \    }\n    }\n    return true;\n  }\n  else {\n    foreach ($l as $v) {\n   \
    \   if ($v > $r[0]) {\n        return false;\n      }\n    }\n    return true;\n\
    \  }\n}\n", "    $l = array_reverse($l);\n    return !($l[0] > $l[$l[0]]);\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI ran this on a list of about 10,000 numbers\
    \ and it failed to find monotonically increasing numbers with more than 1 unique\
    \ number. I suspect that there may be issues with the code, especially with regards\
    \ to handling duplicates. I'll work on that.\n<|/ c |>\n<| c |>\nI tested it again\
    \ with a list of 10000 numbers and found that my initial code also failed to find\
    \ monotonically increasing numbers with more than 1 unique number. Your code was\
    \ also faster and seems to handle duplicates. Thanks for your help.\n<|/ c |>\n\
    <| c |>\nOkay, I made a mistake in my code when I tested it. The algorithm above\
    \ works well and should be more efficient than my code. I've corrected my code.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a simple solution that will tell you if the\
    \ sequence is monotonically increasing or not.\nIt relies on using the comparison\
    \ operator <. \nThe function will return true if the sequence is monotonically\
    \ increasing else it returns false.\n<code>", "  if (!is_array($l)) return false;\n\
    \  if (count($l) == 1) return true;\n  foreach ($l as $key => $value) {\n    if\
    \ ($value < $l[$key - 1]) {\n      $l[$key - 1] = $value;\n      unset($l[$key]);\n\
    \    } else if ($value > $l[$key - 1]) {\n      $l[$key - 1] = $value;\n     \
    \ unset($l[$key]);\n    }\n  }\n  return count($l) == 0;\n}\n", "    list($l,\
    \ $inc) = is_array($l)\n        ? array_pad($l, 2)\n        : array(1, -1);\n\
    \    $max = max($l) - $inc;\n    return $max >= 0 && $max < $l[0] + $inc;\n}\n",
  "  if (!is_array($l)) {\n    $l = array($l);\n  }\n  foreach ($l as $v) {\n    if\
    \ ($v < $l[0]) {\n      return false;\n    }\n  }\n  return true;\n}\n</code>\n\
    This seems to work.  It has some minor issues, e.g. $l is not sorted.\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "  $l2 = array_map(function($e) { return $e; }, $l);\n\
    \  sort($l2);\n  return $l2 == $l;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\n\
    $a = array(1,2,3,4,5);\n$b=array(5,6,7,8,9,10);", "  // Return False if list has\
    \ zero or one elements\n  if (count($l) <= 1) return false;\n  // Return True\
    \ if first element is strictly greater than all others\n  elseif ($l[0] > array_reduce($l,\
    \ function ($v, $w) { return $v && $w > $v ? $w : $v; })) return false;\n  //\
    \ Return True if last element is strictly less than all others\n  elseif ($l[count($l)\
    \ - 1] < array_reduce($l, function ($v, $w) { return $v && $w < $v ? $w : $v;\
    \ })) return false;\n  // Return True if first and last elements are equal\n \
    \ elseif ($l[0] == $l[count($l) - 1]) return true;\n  // Return True if first\
    \ element is less than all others\n  elseif ($l[0] < array_reduce($l, function\
    \ ($v, $w) { return $v && $w < $v ? $w : $v; })) return true;\n  // Return True\
    \ if last element is greater than all others\n  elseif ($l[count($l) - 1] > array_reduce($l,\
    \ function ($v, $w) { return $v && $w > $v ? $w : $v; })) return true;\n  // Return\
    \ False if list is not monotonic\n  else return false;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is the best answer I could find.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer!\n<|/ c |>\n<| a dscore=5 |>\nPHP 7 Solution :\nYou can\
    \ use array_reduce() to solve this issue:\n<code>", "    return rsort($l, function\
    \ ($a, $b) {\n        return $a < $b;\n    });\n}\n", "    return $l[0] > $l[1]\
    \ || $l[1] > $l[2] || $l[2] > $l[3];\n}\n\n/**\n * @author Nicolas Grekas <removed@example.com>\n\
    \ *\n * @see parse()\n * @see isError()\n */", "  return rsort($l)!==$l && krsort($l)!==$l;\n\
    }\n", "  $l = array_reverse($l);\n  return $l[0] < $l[count($l)-1];\n}\n", "\t\
    if (!is_array($l)) return $l;\n\tif ($l[0] < $l[1]) return true;\n\tif ($l[0]\
    \ > $l[1]) return false;\n\tif ($l[0] <= $l[2]) return true;\n\tif ($l[2] >= $l[3])\
    \ return false;\n\treturn monotonic($l[4]);\n}\n\n/*\n\n    array-walk-recursive\n\
    \n    http://github.com/krakjoe/array-walk-recursive\n    Version: 1.1.0\n   \
    \ Author: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n\n    Copyright\
    \ 2005 Kevin van Zonneveld.\n\n    This license is dual licensed under both MIT\
    \ and GPL licenses.\n\n    Permission is hereby granted, free of charge, to any\
    \ person\n    obtaining a copy of this software and associated documentation\n\
    \    files (the \"Software\"), to deal in the Software without\n    restriction,\
    \ including without limitation the rights to use,\n    copy, modify, merge, publish,\
    \ distribute, sublicense, and/or sell\n    copies of the Software, and to permit\
    \ persons to whom the\n    Software is furnished to do so, subject to the following\n\
    \    conditions:\n\n    The above copyright notice and this permission notice\
    \ shall be\n    included in all copies or substantial portions of the Software.\n\
    \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS\
    \ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY,\
    \ FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL\
    \ THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\
    \ LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\
    \    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER\
    \ DEALINGS IN THE SOFTWARE.\n\n*/\n\n/*\n\tIf you're looking for a polyfill of\
    \ Array.forEach for older browsers:\n\thttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n\
    */\nif (!Array.prototype.forEach) {\n\tArray.prototype.forEach = function(fun\
    \ /*, thisp*/ ) {\n\t\t\"use strict\";\n\n\t\tif (this === void 0 || this ===\
    \ null)\n\t\t\tthrow new TypeError();\n\n\t\tvar t = Object(this);\n\t\tvar len\
    \ = t.length >>> 0;\n\t\tif (typeof fun !== \"function\")\n\t\t\tthrow new TypeError();\n\
    \n\t\tvar thisp = arguments[1];\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif\
    \ (i in t)\n\t\t\t\tfun.call(thisp, t[i], i, t);\n\t\t}\n\t};\n}\n\n/*\n\tIf you're\
    \ looking for a polyfill of Array.indexOf for older browsers:\n\thttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\n\
    */\nif (!Array.prototype.indexOf) {\n\tArray.prototype.indexOf = function (searchElement\
    \ /*, fromIndex */ ) {\n\t\t\"use strict\";\n\t\tif (this === void 0 || this ===\
    \ null)\n\t\t\tthrow new TypeError();\n\n\t\tvar t = Object(this);\n\t\tvar len\
    \ = t.length >>> 0;\n\t\tif (len === 0)\n\t\t\treturn -1;\n\n\t\tvar n = 0;\n\t\
    \tif (arguments.length > 1)\n\t\t\tn = Number(arguments[1]);\n\t\tif (n !== n)\n\
    \t\t\tn = 0;\n\t\telse if (n !== 0 && n !== (1 / 0) && n ", "    $l2 = array_shift($l);\n\
    \    foreach ($l as $v) {\n        if ($v <= $l2) return false;\n    }\n    return\
    \ true;\n}\n", "    foreach ($l as $i => $v) {\n        if ($v < $l[$i - 1]) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n</code>\nThe\
    \ above will fail in some cases as well as in some edge cases. I did not test\
    \ them. \nIf you are looking for more robust monotonic sorting, than check out\
    \ the one that I wrote here\n<|/ a dscore=4 |>\n<| c |>\nThat fails for [1,1,2,4].\
    \ Should be [1,2,4,1]\n<|/ c |>\n<| c |>\n: You are right. Thanks. Corrected.\n\
    <|/ c |>\n<| c |>\nThanks for that. I was having trouble adapting it to an array.\
    \ I added a link to a version of it that actually works :)\n<|/ c |>\n<| c |>\n\
    : No problem. Please mark the answer as accepted if that helped you.\n<|/ c |>\n\
    <| c |>\nI added an extra test case that failed, but the code works great.\n<|/\
    \ c |>\n<| a dscore=3 tags=php,sorting,arrays |>\n<code>\narray_multisort($a,array_keys($a));\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't sort monotonically increasing, it sorts\
    \ alphabetically.\n<|/ c |>\n<| a dscore=2 |>\nTry this\n<code>", "    if (!is_array($l))\
    \ return false;\n    sort($l);\n    return array_reduce($l, function($acc, $val)\
    \ {\n        return $acc && $val >= $acc[-1];\n    }, true);\n}\n", "    $min\
    \ = reset($l);\n    reset($l);\n    return $min < end($l);\n}\n", "\tif (is_null($l))\
    \ {\n\t\treturn false;\n\t}\n\t$n = count($l);\n\tif ($n === 0) {\n\t\treturn\
    \ true;\n\t}\n\tforeach ($l as $k => $v) {\n\t\tif ($v < $l[$k - 1]) {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n/**\n * Checks if a variable is\
    \ numeric.\n * @link https://php.net/manual/en/function.is-numeric.php\n * @param\
    \ mixed $var Variable to check.\n * @return bool Returns true if the variable\
    \ is numeric.\n */", "  $i = count($l);\n  if (!$i) {\n    return true; // Monotonically\
    \ increasing.\n  }\n  for ($j = 1; $j < $i; $j++) {\n    for ($k = $j; $k < $i;\
    \ $k++) {\n      if ($l[$j] - $l[$k] > 0 || $l[$j] - $l[$k] < 0) {\n        if\
    \ ($j - $k > 1) {\n          $l[$k] = $l[$j];\n          $l[$j] = $k;\n      \
    \  }\n        return false; // Not monotonically increasing.\n      }\n    }\n\
    \  }\n  return true; // Monotonically increasing.\n}\n\n/**\n * Get list of elements\
    \ from string separated by passed separator.\n *\n * Example:\n *\n * $str = 'one#two#three';\n\
    \ * $list = str_list_split($str, '#');\n * // $list = ['one', 'two', 'three'];\n\
    \ *\n * @param string $str String to be splitted.\n * @param string $separator\
    \ Separator that should be used in splitting.\n * @return array List of string\
    \ elements.\n * @task str_list String list\n * @task str_list__split String list\
    \ splitting\n */", "    foreach ($l as $i => $v) {\n        if ($v !== $l[$i -\
    \ 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
  "    // Return True if $l is monotonically increasing or decreasing.\n    // >>>\
    \ monotonic([1, 2, 4, 20])\n    // True\n    // >>> monotonic([1, 20, 4, 10])\n\
    \    // False\n    // >>> monotonic([4, 1, 0, -10])\n    // True\n    if ($l[0]\
    \ <= $l[1]) {\n        return TRUE;\n    }\n    // Return False if $l is monotonically\
    \ increasing or decreasing.\n    // >>> monotonic([1, 2, 4, 20])\n    // False\n\
    \    // >>> monotonic([1, 20, 4, 10])\n    // False\n    // >>> monotonic([4,\
    \ 1, 0, -10])\n    // False\n    return FALSE;\n}\n</code>\n<|/ a tags=php,arrays\
    \ |>\n<| c |>\nNice, never thought of that, but I think OP is looking for the\
    \ difference of *consecutive values* like `$diff = array_diff($a, $b);` would've\
    \ done.\n<|/ c |>\n<| c |>\n: Good point. Your solution does seem better than\
    \ my suggestion, although I haven't tested it yet.\n<|/ c |>\n<| a dscore=1 |>\n\
    I have been using the following code for quite a while now.\n<code>\n<?php\n$a\
    \ = array(\n    array(\n        'product_id' => 1,\n        'type' => 'type1',\n\
    \        'date' => '2011-02-15 16:12:32',\n        'amount' => 5\n    ),\n   \
    \ array(\n        'product_id' => 1,\n        'type' => 'type2',\n        'date'\
    \ => '2011-02-15 16:12:32',\n        'amount' => 10\n    ),\n    array(\n    \
    \    'product_id' => 1,\n        'type' => 'type3',\n        'date' => '2011-02-15\
    \ 16:12:32',\n        'amount' => 8\n    ),\n    array(\n        'product_id'\
    \ => 1,\n        'type' => 'type4',\n        'date' => '2011-02-15 16:12:32',\n\
    \        'amount' => 7\n    ),\n    array(\n        'product_id' => 1,\n     \
    \   'type' => 'type1',\n        'date' => '2011-02-15 16:12:32',\n        'amount'\
    \ => 5\n    )\n);\n\n$b = array(\n    array(\n        'product_id' => 1,\n   \
    \     'type' => 'type1',\n        'date' => '2011-02-15 16:12:32',\n        'amount'\
    \ => 5\n    ),\n    array(\n        'product_id' => 1,\n        'type' => 'type2',\n\
    \        'date' => '2011-02-15 16:12:32',\n        'amount' => 10\n    ),\n  \
    \  array(\n        'product_id' => 1,\n        'type' => 'type3',\n        'date'\
    \ => '2011-02-15 16:12:32',\n        'amount' => 8\n", "  $l = array_reverse($l);\
    \ //put in order\n  if ($l[0] > $l[1]) {\n    $tmp = $l[0];\n    $l[0] = $l[1];\n\
    \    $l[1] = $tmp;\n  }\n  $i = 1;\n  foreach ($l as $value) {\n    if ($l[$i]\
    \ > $value) {\n      return (bool) ($l[$i] > $value);\n    }\n    $i++;\n  }\n\
    }\n", "  $s = $e = array_pop($l);\n  return $l && $e && $s[0] < $e;\n}\n", "\t\
    sort($l);\n\treturn ($l[0] < $l[1] || $l[1] < $l[2] || $l[2] < $l[3]);\n}\n\n\
    /**\n * Returns the first element in an array. Useful for checking if a variable\n\
    \ * is defined and non-null.\n *\n * <code>\n * <?php\n * function f($s) {\n *\
    \ \treturn isset($s) ? $s : \"\";\n * }\n * $s = '';\n * $x = 1;\n * f($s);\n\
    \ * // $s is now '', and $x is 1\n * ?>\n * </code>\n *\n * <code>\n * <?php\n\
    \ * function f($s) {\n * \techo $s;\n * \treturn $s;\n * }\n * $s = '';\n * $x\
    \ = 1;\n * f($s);\n * // nothing is printed\n * ?>\n * </code>\n *\n * @param\
    \ array $arr\n * @return mixed first element of $arr\n */", "    $l = array_filter($l,\
    \ function($item) {\n        return $item >= 0;\n    });\n    if (count($l) <\
    \ 1) {\n        return true;\n    }\n    $last = array_pop($l);\n    return $l[0]\
    \ < $last;\n}\n\n/**\n * Returns an associative array of the differences between\
    \ two arrays.\n *\n * @param  array $l An array to compare with $r.\n * @param\
    \  array $r An array to compare with $l.\n *\n * @return array An associative\
    \ array of the differences between $l and $r.\n *\n * @see http://book.cakephp.org/2.0/en/core-utility-libraries/hash.html#Hash::diff\n\
    \ */", "  $min = reset($l);\n  foreach ($l as $n) {\n    if ($n < $min) {\n  \
    \    $min = $n;\n    }\n  }\n  return !$min;\n}\n", "\tif ($l[0] < $l[1]) {\n\t\
    \t$l[0] = $l[1];\n\t}\n\tif ($l[1] < $l[2]) {\n\t\t$l[1] = $l[2];\n\t}\n\tif ($l[2]\
    \ < $l[3]) {\n\t\t$l[2] = $l[3];\n\t}\n\treturn ($l[0] < $l[1] || $l[1] < $l[2]\
    \ || $l[2] < $l[3]);\n}\n", "\tsort($l);\n\treturn (array_pop($l) - $l[0] < $l[1]\
    \ - $l[0]);\n}\n\n/**\n * Checks if a key exists in an array\n *\n * @param string\
    \ $key\n * @param array  $array\n * @return boolean\n */", "    $s = array_reverse($l);\n\
    \    $m = $s[0];\n    for($i = 1; $i < count($s); $i++) {\n        $m = $m < $s[$i]\
    \ ? $m : $s[$i];\n    }\n    return $m > 0 && $m <= $s[0];\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis is interesting. What does it do with an array of numbers that\
    \ are the same but not ordered?\n<|/ c |>\n<| c |>\nIt returns \"True\" because\
    \ an array containing one element is sorted and monotonically increasing, and\
    \ an array containing only one element is sorted and monotonically decreasing.\
    \ An array containing multiple equal values is sorted and monotonically increasing,\
    \ and an array containing multiple equal values is sorted and monotonically decreasing.\
    \ An array containing multiple non-equal values is sorted and monotonically increasing,\
    \ and an array containing multiple non-equal values is sorted and monotonically\
    \ decreasing.\n<|/ c |>\n<| c |>\nWhat does it do with an array of numbers that\
    \ are the same but not ordered? An example would help. Thank you.\n<|/ c |>\n\
    <| c |>\nIt returns \"True\" because an array containing one element is sorted\
    \ and monotonically increasing, and an array containing only one element is sorted\
    \ and monotonically decreasing. An array containing multiple equal values is sorted\
    \ and monotonically increasing, and an array containing multiple equal values\
    \ is sorted and monotonically decreasing. An array containing multiple non-equal\
    \ values is sorted and monotonically increasing, and an array containing multiple\
    \ non-equal values is sorted and monotonically decreasing.\n<|/ c |>\n<| c |>\n\
    This fails with `monotonic([1, 2, 4, 20, 20])`\n<|/ c |>\n<| a tags=php,algorithm\
    \ |>\nThe answer is based on Donal's answer, but modified to include only unique\
    \ values:\n<code>\n<?php", "    $l = array_reverse($l);\n    $d = array_diff_assoc($l,\
    \ $l);\n    return count($d) == 0;\n}\n", "    if (empty($l)) {\n        return\
    \ false;\n    }\n    if ($l[0] < $l[1]) {\n        return true;\n    }\n    if\
    \ ($l[0] > $l[1]) {\n        return false;\n    }\n    if ($l[0] == $l[1]) {\n\
    \        return $l[0] > 0 ? false : true;\n    }\n\n    $l[0] -= 1;\n    foreach\
    \ ($l as $i => $v) {\n        if ($v <= $l[0]) {\n            return false;\n\
    \        }\n        $l[$i] -= 1;\n    }\n    return true;\n}", "    $l = array_filter($l);\n\
    \    $l = array_map(function($a) { return $a<0?$a+count($l)-1:$a; }, $l);\n  \
    \  return $l[0]==$l[count($l)-1];\n}\n</code>\n<|/ a tags=arrays,php,sorting dscore=1\
    \ |>\n<| a dscore=0 |>\nIf you need to preserve the original order of the keys,\
    \ then a quicksort is the wrong tool for the job.\n<|/ a tags=arrays,php,sorting\
    \ |>\n<| a |>\nI know this thread is old but I just came across this problem and\
    \ I solved it using array_flip. If your array is big and you don't want to do\
    \ a linear search then this could be a better solution. It basically flips the\
    \ keys and you get an array where the key order matches the original array order.\n\
    <code>\n$array = [\n    'name' => 'John',\n    'age' => '27',\n    'sex' => 'female',\n\
    \    'height' => '185',\n];\n$flipped = array_flip($array);\n$array2 = array_intersect_key($array,\
    \ $flipped);\n$array3 = array_intersect_key($array2, array_flip($array));\n</code>\n\
    If you need it sorted again then use rsort.\n<|/ a dscore=0 tags=arrays,php,sorting\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nWhy not use [`ksort`](http://php.net/manual/en/function.ksort.php)?\n\
    <|/ c |>\n<| c |>\nThat's a good point, but ksort will only work on numeric arrays.\
    \ As the array is a custom object, ksort won't work. array_intersect_key($array,\
    \ $flipped) would probably work, though, although you would still have to flip\
    \ the keys to get the desired result.\n<|/ c |>\n<| a dscore=0 tags=arrays,php,sorting\
    \ |>\nI've used the solution provided by Ashwin Maurya. This is how I sort a multidimensional\
    \ array by keys:\n<code>", "    if (count($l) === 0) {\n        return true;\n\
    \    }\n\n    $first = reset($l);\n    for ($i = count($l) - 1; $i >= 0; --$i)\
    \ {\n        if ($l[$i] < $first) {\n            return false;\n        }\n  \
    \  }\n\n    return true;\n}\n", "  if ($l === NULL) { return FALSE; }\n  $result\
    \ = TRUE;\n  for ($i = 0; $i < count($l) - 1 && $result; $i++) {\n    $result\
    \ = $l[$i] <= $l[$i + 1];\n  }\n  return $result;\n}\n", "  if (!is_array($l))\n\
    \    throw new Exception('Monotonicity expects an array');\n\n  return $l[0] >\
    \ $l[$l[0] - 1];\n}\n", "\t$a = array_reverse($l);\n\tsort($a);\n\treturn $a ==\
    \ $l;\n}\n", "    $lc = array_count_values($l);\n    return array_sum(array_map('bccomp',\
    \ $lc, array_fill(0, count($lc), 0))) > 0;\n}\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nThe `monotonic()` function can be done in one line with a nested array-map\
    \ function.\n<|/ c |>\n<| c |>\nNice, but what about this test case: `monotonic([2,\
    \ 8, 2, 7, 1, 0])`? It returns false but I want it to return true.\n<|/ c |>\n\
    <| c |>\nThis fails on negative numbers: `$lc = array_count_values($l); return\
    \ array_sum(array_map('bccomp', $lc, array_fill(0, count($lc), 0))) == 0;`\n<|/\
    \ c |>\n<| c |>\nI see that the above answers already handle negative numbers.\
    \ So why not add an alternative solution using `array_filter` instead? `function\
    \ monotonic($arr) {\n    return array_filter(\n        array_count_values($arr),\
    \ \n        function($count) { return $count > 1; }, \n        ARRAY_FILTER_USE_KEY\n\
    \    );\n}`\n<|/ c |>\n<| c |>\nThe reason for using bccomp is that it is numerically\
    \ precise and compares numbers more quickly than other comparisons. https://stackoverflow.com/a/18196479/3317808\n\
    <|/ c |>\n<| a dscore=4 tags=sorting,arrays,php |>\nJust to build on top of Mike's\
    \ answer, you can also use array_count_values.\n<code>\n$monotonic = count($array)\
    \ == array_count_values($array)\n</code>\n<|/ a |>\n<| c |>\n`count($array) !=\
    \ array_count_values($array)`\n<|/ c |>\n<| c |>\nThat is true, but that wasn't\
    \ the question.\n<|/ c |>\n<| c |>\nThanks, I modified my answer :)\n<|/ c |>\n\
    <| a |>\nThis solution does not involve any loops:\n<code>", "    if (!is_array($l))\
    \ {\n        throw new Exception('monotonic() expects an array.');\n    }\n\n\
    \    $sortedArray = array_reverse($l);\n    return $sortedArray[0] < $sortedArray[count($sortedArray)-1];\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is the best solution I've found so\
    \ far.  Thanks for posting it.  (I'm surprised that there's no built-in function\
    \ to do this, though.)\n<|/ c |>\n<| a tags=php |>\nNot the most efficient, but\
    \ this is pretty much what I was looking for:\n<code>\n/**\n* Returns true if\
    \ the array is monotonically increasing or decreasing.\n* \n* array\n* bool\n\
    */", "    $s = array();\n    $n = count($l);\n    for($i = 0; $i < $n; $i++) {\n\
    \        $t = $l[$i];\n        if ($t > $s[$i] || $t < $s[$i-1]) {\n         \
    \   return false;\n        } else {\n            $s[] = $t;\n        }\n    }\n\
    \    return true;\n}", "    $l = array_filter($l);\n\n    $min = array_shift($l);\n\
    \    $max = array_shift($l);\n\n    return $min < $max;\n}\n", "  foreach($l as\
    \ $i => $v) {\n    $p[$i] = $i;\n    $p[$v] = $v;\n  }\n  array_multisort($p,\
    \ SORT_DESC, $l);\n  return ($p[0] == 0);\n}", "    foreach ($l as $k => $v) {\n\
    \        if ($v !== $l[$k + 1]) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=list,arrays,php,function\
    \ dscore=1 |>\nA possible solution (but not tested):\n<code>", "\t$r = array();\n\
    \tforeach ($l as $v) {\n\t\t$s = $r;\n\t\twhile ($s < $v || $s[$s - 1] < $v) {\n\
    \t\t\t$r[] = $s;\n\t\t\t$s++;\n\t\t}\n\t}\n\treturn $r == $l;\n}\n\n\n/**\n *\
    \ Returns the sum of an array of numbers\n *\n * @param float $start (Optional)\
    \ The starting number, defaults to 0.\n * \t\t\t\t\t\t\t\t\t\tIf no number is\
    \ passed, starts from 0.\n * @param float $inc  (Optional) Increment for each\
    \ iteration. If no\n * \t\t\t\t\t\t\t\t\t\tnumber is passed, increments by 1.\n\
    \ * \t\t\t\t\t\t\t\t\t\tIf omitted, uses $start by default.\n * @return\tfloat\n\
    \ */", "    return array_reduce($l, function ($out, $item) {\n        return $out\
    \ || ($item <= $out); \n    }, false);\n}", "    return $l[0] <= $l[count($l)\
    \ - 1];\n}\n\n/*\n * Return a new string with the elements of $str separated by\
    \ $sep.\n */", "    $l = array_filter($l);\n    return is_array($l) && array_reduce($l,\
    \ '', function($a, $b) {\n        if ($a > $b) {\n            return -1;\n   \
    \     } else if ($a < $b) {\n            return 1;\n        } else {\n       \
    \     return 0;\n        }\n    });\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3\
    \ |>\nI ended up using the following function. I feel like it is a bit less readable\
    \ than other functions but it seems to work well, and it's short.\n<code>", "\t\
    if (empty($l))\n\t\treturn true;\n\tsort($l);\n\treturn (array_pop($l) !== $l[0]);\n\
    }\n", "    $l = array_map('intval', $l);\n    $l = array_reverse($l);\n    $p\
    \ = $l[0];\n    for ($i = 1; $i < count($l); $i++) {\n        if ($l[$i] - $p\
    \ < 0 || $l[$i] - $p > 0) return false;\n        $p = $l[$i];\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere's an approach that works\
    \ in PHP and Python:\n<code>\n>>> def monotonic(L):\n...     L = [int(n) for n\
    \ in L]\n...     return all(L[i] > L[i-1] for i in xrange(1, len(L)))\n... \n\
    >>> monotonic([1, 2, 4, 20])\nTrue\n>>> monotonic([1, 20, 4, 10])\nFalse\n>>>\
    \ monotonic([4, 1, 0, -10])\nTrue\n</code>\n<|/ a tags=sorting,python |>\n<| c\
    \ |>\nHi, thank you for your quick reply! However, I'm really trying to implement\
    \ a Python solution, so your answer is probably more what I was looking for. However,\
    \ I tried implementing the Python version and it didn't work. `def monotonic(L):\n\
    \    L = [int(n) for n in L]\n    L.sort()\n    return L[-1] - L[0] < 0 or L[-1]\
    \ - L[0] > 0` I tried this with my example and it returned false for some reason.\n\
    <|/ c |>\n<| c |>\n`return L[-1] - L[0] < 0 or L[-1] - L[0] > 0` should work if\
    \ you use my function definition in your comment. Please try it out before posting\
    \ a question. It should work. Try using your function definition in a different\
    \ Python session, i.e. just copy & paste the code snippet into a new file.\n<|/\
    \ c |>\n<| c |>\nHi again, I've tried implementing the Python version again and\
    \ it doesn't work. I pasted it into the Python session and it says NameError:\
    \ name 'monotonic' is not defined I'm really confused at this point because when\
    \ I copy and paste the function into the Python session, it doesn't give me the\
    \ error.\n<|/ c |>\n<| c |>\nThat's because you are not defining `monotonic` in\
    \ your current session. Just copy & paste the code snippet I posted in my comment\
    \ into a new file. I edited the answer to show you how to do that.\n<|/ c |>\n\
    <| a dscore=0 |>\nYou could try using collections.Counter which will give you\
    \ the amount of times each number occurs in the list and sort from lowest to highest.\
    \ This will allow you to check whether the lowest number occurred once, or more\
    \ than once.\n", "    $l2 = $l2 ?: $l;\n    $l2 = array_reverse($l2);\n    return\
    \ isset($l2[0]) && $l2[0] >= $l2[count($l2) - 1];\n}\n\n/**\n * Sort an array\
    \ with the keys as sorting keys and the values as sorting values.\n *\n * <code>\n\
    \ * $arr = array(\n *     'a' => 'apple',\n *     'b' => 'banana',\n *     'c'\
    \ => 'cat'\n * );\n * array_multisort($arr, SORT_ASC, $arr);\n * var_dump($arr);\n\
    \ * </code>\n *\n * @param  array $arr\n * @param  int   $sortFlag Flag used to\
    \ specify which sorting criteria should be used.\n *                         \
    \ Flag values can be:\n *                                SORT_REGULAR: compare\
    \ items normally (don't change types)\n *                                SORT_NUMERIC:\
    \ compare items numerically\n *                                SORT_STRING: compare\
    \ items as strings\n *                                SORT_LOCALE_STRING: compare\
    \ items as strings, based on the current locale\n * @param  array $arr\n * @return\
    \ void\n */", "\t$l = array_reverse($l);\n\t$first = $l[0];\n\t$last = $l[count($l)-1];\n\
    \tfor ($i = 1, $max = count($l); $i < $max; $i++) {\n\t\tif ($l[$i] > $last &&\
    \ $l[$i] < $first) {\n\t\t\treturn true;\n\t\t} elseif ($l[$i] > $last) {\n\t\t\
    \treturn false;\n\t\t} elseif ($l[$i] < $first) {\n\t\t\treturn true;\n\t\t}\n\
    \t}\n\treturn false;\n}", "    if (!is_array($l)) {\n        return false;\n \
    \   }\n\n    $l = array_reverse($l);\n    $l = array_slice($l, 0, count($l) -\
    \ 1);\n\n    return $l[0] > array_shift($l);\n}\n", "\t$l = array_map('floatval',\
    \ $l);\n\t$l = array_filter($l);\n\tsort($l);\n\treturn (count($l) === count(array_unique($l)));\n\
    }\n", "\t$l = is_array($l) ? $l : func_get_args();\n\t$l = array_filter($l);\n\
    \tsort($l);\n\treturn $l == array_unique($l);\n}\n\n\n/**\n * Returns $value rounded\
    \ away from zero\n *\n * @param mixed $value\n * @return float Rounded Value\n\
    \ */", "\tsort($l);\n\treturn $l[0] > $l[count($l) - 1];\n}\n", "    if ($l ==\
    \ 0) {\n        return false;\n    }\n    $lo = array_shift($l);\n    return !($lo\
    \ === array_pop($l) || $lo === array_shift($l));\n}\n", "  return $l[0] > $l[1];\n\
    }\n\n", "    return array_reduce($l, function ($c, $v) {\n        return $c ||\
    \ ($v > $v[0] ?  $v > $v[1] ? false : true  :  $v > $v[2] ? false : true);\n \
    \   });\n}\n", "    $s = array_shift($l);\n    $last = array_pop($l);\n    return\
    \ ($s === $last) ? $true : $false;\n}\n\n/**\n * Test if an array is monotonically\
    \ increasing.\n *\n * Returns True when the array is monotonically increasing,\
    \ False otherwise.\n *\n * @param array $l an array\n * @return bool\n */", "\t\
    if (!is_array($l)) {\n\t\t$l = array($l);\n\t}\n\t\n\t// Sort list with least\
    \ to greatest as fast as possible.\n\tarray_multisort($l, SORT_ASC, $l);\n\t\n\
    \t// Check if list is monotonically increasing.\n\t$monotonic = FALSE;\n\t\n\t\
    // Check from first to last.\n\t$l = array_reverse($l);\n\t\n\t// Sort list with\
    \ greatest to least as fast as possible.\n\tarray_multisort($l, SORT_DESC, $l);\n\
    \t\n\t// Return True when list elements are monotonically increasing or decreasing.\n\
    \t// This follows the algorithm defined in:\n\t// \thttp://en.wikipedia.org/wiki/Monotonic_array\n\
    \tfor ($i = 0; $i < count($l); ++$i) {\n\t\t$current = $l[$i];\n\t\t$next = $l[($i\
    \ + 1)];\n\t\t\n\t\tif (($current <= $next) && ($current < $next)) {\n\t\t\t$monotonic\
    \ = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn $monotonic;\n}\n\n/**\n * Checks\
    \ that an index is valid for the $list array.\n *\n * @param int|array $index\
    \ The index of the list to validate.\n * @return bool True when index is valid,\
    \ false otherwise.\n */", "    if (is_array($l) && count($l) == 1) {\n       \
    \ $l = $l[0];\n    }\n    if (is_object($l)) {\n        $l = get_object_vars($l);\n\
    \    }\n\n    if ($l instanceof Traversable) {\n        $l = iterator_to_array($l);\n\
    \    }\n\n    $v = false;\n    $i = 0;\n    $j = 0;\n\n    foreach ($l as $k =>\
    \ $v) {\n        if ($v !== $l[$j]) {\n            if (($j - $i) > 1) {\n    \
    \            if ((!is_array($l) || $l[$j] < $l[$i]) && $j < $i) {\n          \
    \          $i = $j;\n                }\n            } else {\n               \
    \ $i = $j;\n            }\n        }\n        $j++;\n    }\n\n    return $j >\
    \ $i;\n}\n\n/**\n * Returns whether a value is an integer.\n *\n * @param mixed\
    \ $value The value to check\n * @return bool\n */", "  // Return True if $l is\
    \ monotonically increasing or decreasing.\n  // If $l is monotonically increasing,\
    \ return True even if its reversed.\n  // If $l is monotonically decreasing, return\
    \ False even if its reversed.\n  // If $l is neither increasing or decreasing,\
    \ return False.\n  // This code handles the special case where $l is empty or\
    \ contains only one value.\n  $l = array_values($l);\n  return $l[0] > $l[count($l)-1]\
    \ ? True : False;\n}\n</code>\n<|/ a tags=arrays,algorithm,php |>\n<| a dscore=0\
    \ |>\nI made a PHP function to do this, and it seems to work quite well for me:\n\
    <code>", "    $l = array_map('intval', $l);\n    $last = array_pop($l);\n    return\
    \ ($last < $l[0] || $l[0] == 0);\n}\n\n/**\n * Returns the largest element in\
    \ a list.\n *\n * @return\n *   The largest element of the list $l. If no element\
    \ can be found, an\n *   empty string is returned.\n */", "  $l = array_filter($l);\n\
    \  return count($l) === 0 && false === array_reduce($l, function($carry, $item)\
    \ {\n    return $carry && $item > $carry;\n  });\n}\n", "    $l = is_array($l)\
    \ ? $l : array($l);\n    $n = count($l);\n    if ($n == 0) {\n        return true;\n\
    \    }\n    if ($n == 1) {\n        return $l[0] > $l[0];\n    }\n\n    $d = 0;\n\
    \    $l = array_reverse($l);\n    foreach ($l as $k => $v) {\n        $d += ($v\
    \ - $l[0]) * ($k + 1);\n    }\n    return $d / $n > 0;\n}\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| c |>\nThis works great for small numbers, but when the list gets larger,\
    \ it becomes very slow (O(n^2)).\n<|/ c |>\n<| c |>\nIt also seems to not work\
    \ as intended for multiple occurrences of an element in the array (it returns\
    \ true for lists where every element is greater than the last).\n<|/ c |>\n<|\
    \ a tags=php,algorithm |>\n<code>\n$list = '1,2,3,4,5,6,7,8,9,10';\n\n$list =\
    \ explode(',', $list);\n$list = array_count_values($list);\n$list = array_reverse($list);\n\
    \n$result = 0;\nforeach ($list as $num => $count) {\n  if ($count != 1) {\n  \
    \  $result = $result;\n  }\n}\n\nif ($result < $list[1]) {\n  // Do something\
    \ here\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't take into account\
    \ that the list may be in any order. Sorting would be inefficient for this solution.\n\
    <|/ c |>\n<| c |>\nSorting is still O(nlogn), which is still not ideal.\n<|/ c\
    \ |>\n<| c |>\nActually it does take into account the order of the list.\n<|/\
    \ c |>\n<| a tags=php,algorithm |>\n<code>\n$list = '1,2,3,4,5,6,7,8,9,10';\n",
  "    if (!is_array($l)) {\n        $msg = sprintf('monotonic() expects parameter\
    \ 1 to be array, %s given', gettype($l));\n        throw new Exception($msg, 0,\
    \ E_USER_ERROR);\n    }\n\n    $n = array_shift($l);\n\n    foreach ($l as $v)\
    \ {\n        if ($v !== $n) {\n            return false;\n        }\n    }\n\n\
    \    return true;\n}\n", "  $l = array_reverse($l);\n  $len = count($l);\n  $first\
    \ = isset($l[0]) ? $l[0] : 0;\n  sort($l);\n  for ($i = 1; $i <= $len; ++$i) {\n\
    \    $last = $l[$i];\n    if ($last != $first) {\n      return $first <= $last;\n\
    \    }\n  }\n  return false;\n}\n", "    return $l[0] < $l[count($l) - 1];\n}\n",
  "\t$lcount = count($l);\n\t$ucount = 0;\n\t$l[0] = $l[0] > $l[1] ? $l[1] : $l[0];\n\
    \tfor ($i = 1; $i < $lcount; $i++) {\n\t\t$ucount = max($ucount, ($l[$i] <= $l[$i\
    \ - 1]) ? $i : 0);\n\t}\n\treturn $ucount < $lcount;\n}", "  foreach ($l as $k\
    \ => $v) {\n    $m[$k] = $v;\n  }\n\n  return $m == array_merge(array_keys($m),\
    \ [$m[count($m) - 1]]);\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 tags=php,arrays\
    \ |>\nYou can do it this way:\n<code>\n$data = array(\n    array('name' => 'Foo',\
    \ 'score' => 100),\n    array('name' => 'Bar', 'score' => 50),\n    array('name'\
    \ => 'Baz', 'score' => 70)\n);\n\n$result = [];\nforeach ($data as $val) {\n \
    \   $result[strval($val['score'])] = $val;\n}\n\n$result = [\n    '-' => array_shift($result),\n\
    \    '--' => $result,\n];\n\necho '<pre>', print_r($result), '</pre>';\n</code>\n\
    <|/ a |>\n<| a tags=php,arrays |>\nHere is another way using a foreach loop:\n\
    <code>\n<?php\n\n$data = array(\n    array('name' => 'Foo', 'score' => 100),\n\
    \    array('name' => 'Bar', 'score' => 50),\n    array('name' => 'Baz', 'score'\
    \ => 70)\n);\n\n$tempArray = [];\n$resultArray = [];\nforeach ($data as $item)\
    \ {\n    $tempArray[$item['score']] = $item;\n}\n\nforeach(array_keys($tempArray)\
    \ as $val) {\n    $resultArray[$val] = $tempArray[$val];\n}\n\nvar_dump($resultArray);\n\
    </code>\nOutput\n<code>\narray(2) {\n  [\"-\"]=>\n  array(2) {\n    [\"name\"\
    ]=>\n    string(3) \"Foo\"\n    [\"score\"]=>\n    int(100)\n  }\n  [\"--\"]=>\n\
    \  array(2) {\n    [\"name\"]=>\n    string(3) \"Bar\"\n    [\"score\"]=>\n  \
    \  int(50)\n  }\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can also\
    \ do this :\n<code>\n$array = array(\n    array('name' => 'Foo', 'score' => 100),\n\
    \    array('name' => 'Bar', 'score' => 50),\n    array('name' => 'Baz', 'score'\
    \ => 70)\n);\n$output = [];\n\n$i = 0;\nforeach ($array as $v) {\n    $output[$i][$v['score']]\
    \ = $v;\n    $i++;\n}\n\n$result = array_chunk($output, 2);\nvar_dump($result);\n\
    </code>\nOutput\n<code>\narray(2) {\n  ", "    $l = array_values($l);\n    $l\
    \ = array_shift($l);\n    return $l[0] < $l[1];\n}\n\n/*\n * Compute minimum value\
    \ from list of values. Also detects NaN values.\n */", "    $l = array_filter($l);\n\
    \    if (empty($l)) {\n        return true;\n    }\n    if ($l[0] > $l[count($l)\
    \ - 1]) {\n        return false;\n    }\n    return count($l) > 1;\n}\n", "  \
    \  return $l[0] >= $l[1] && $l[1] >= $l[2] && $l[2] >= $l[0] && $l[3] >= $l[0];\n\
    }\n</code>\n<|/ a tags=php |>\n<| a |>\nHere is my solution:\n<code>", "    //\
    \ Sort the input list for increased performance\n    sort($l);\n    $prev = $l[0];\n\
    \    $result = true;\n    foreach ($l as $cur) {\n        if ($cur != $prev) {\n\
    \            $result = false;\n        }\n        $prev = $cur;\n    }\n    return\
    \ $result;\n}\n", "    $l = array_reverse($l);\n    $diffs = array_diff_assoc($l,\
    \ $l);\n    return count($diffs) === 0;\n}\n</code>\n<|/ a dscore=0 tags=php,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  $l = array_reverse($l);\n  $l[0] = array_shift($l);\n\
    \  return $l === $l ? true : false;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    I know this is old, but here's another approach:\n<code>", "    if ($l == array())\
    \ {\n        return true;\n    }\n    $n = count($l);\n    for ($i = 2; $i <=\
    \ $n; ++$i) {\n        if ($l[$i - 1] > $l[$i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "\t$l = array_reverse($l);\n\tfor ($i\
    \ = 0; $i < count($l); $i++) {\n\t\t$a = $l[$i];\n\t\t$b = $l[$i - 1];\n\t\tif\
    \ ($a <= $b) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "    return\
    \ $l[0] < $l[count($l)-1] ||\n           (count($l)==1 && $l[0]==$l[count($l)-1]);\n\
    }\n", "  $l2 = array_reverse($l);\n  return $l2[0] > $l2[1];\n}\n\n", "  // http://en.wikipedia.org/wiki/Monotone_chain\n\
    \  $l = array_flip($l);\n  $keys = array_keys($l);\n  return $keys[count($keys)\
    \ - 1] + 0 == end($keys);\n}\n", "  $l = $l ?: [];\n  $sorted = array_unique($l);\n\
    \  $sorted = array_reverse($sorted);\n  do {\n    if ($sorted[0] > $sorted[1])\
    \ {\n      return false;\n    }\n  } while (array_pop($sorted) !== null);\n  return\
    \ true;\n}\n", "\tif (!isset($l[0])) return false;\n\t$first = $l[0];\n\tforeach\
    \ ($l as $k => $v) {\n\t\tif ($v <= $first) return false;\n\t\t$first = $v;\n\t\
    }\n\treturn true;\n}\n", "    $diffs = array_map(function($x, $y) {\n        return\
    \ abs($x - $y);\n    }, $l, $l);\n    return $diffs[0] < $diffs[1];\n}\n", " \
    \ $monotone = false;\n  $i = count($l) - 1;\n  foreach ($l as $k => $v) {\n  \
    \  if ($l[$k] > $l[$i]) {\n      $monotone = true;\n    } else if ($l[$k] < $l[$i])\
    \ {\n      $monotone = false;\n    } else {\n      $i = $k;\n    }\n  }\n  return\
    \ $monotone;\n}\n\n/**\n * Return the first element in a list\n *\n * @param \
    \ array $l\n *\n * @return  mixed\n */", "\t$l = array_reverse($l);\n\tsort($l);\n\
    \treturn $l == $l;\n}\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nthis one doesn't\
    \ even work if there's nothing between 2 numbers.\n<|/ c |>\n<| c |>\n: I fixed\
    \ this by adding 1 to the $max variable. Thanks for pointing this out.\n<|/ c\
    \ |>\n<| c |>\nIt worked fine as I was using it for comparing two arrays generated\
    \ from some database records. Worked like a charm.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "    // http://en.wikipedia.org/wiki/Monotone_chain\n    $m = count($l);\n\
    \    if ($m <= 2) {\n        return true;\n    }\n    $index = $m - 1;\n    $result\
    \ = false;\n    $previous = 0;\n    $first = $l[0];\n    for ($i = 1; $i < $m;\
    \ ++$i) {\n        if ($l[$i] <= $previous) {\n            $index = $i;\n    \
    \        $result = true;\n        }\n        $previous = $l[$i];\n    }\n    return\
    \ $result;\n}\n", "  $s = $l[0];\n  $l[0] = max($l[0], $s[0]);\n  for ($i = 1;\
    \ $i < count($l); $i++) {\n    $x = $l[$i];\n    if ($x >= $s[-1]) {\n      $s[count($s)]\
    \ = $x;\n    } else {\n      $s[-1] = max($s[-1], $x);\n    }\n  }\n  return $s[-1]\
    \ > $s[0] && count($s) > 1;\n}", "\tstatic $cache_inc = array();\n\tforeach ($l\
    \ as $k => $v) {\n\t\tif (!array_key_exists($k, $cache_inc)) {\n\t\t\t$cache_inc[$k]\
    \ = $v;\n\t\t} elseif ($cache_inc[$k] == $v) {\n\t\t\tunset($cache_inc[$k]);\n\
    \t\t} else {\n\t\t\t$cache_inc[$k] = $v;\n\t\t\treturn false;\n\t\t}\n\t}\n\t\
    return true;\n}\n\n/**\n * Returns a URL-encoded query string from the given parameters.\n\
    \ *\n * @param  array $params\n * @return string\n */", "\t$s = $l[0];\n\t$l =\
    \ array_slice($l, 1);\n\tforeach ($l as $e) {\n\t\tif ($e < $s) {\n\t\t\treturn\
    \ False;\n\t\t} else if ($e > $s) {\n\t\t\treturn True;\n\t\t}\n\t\t$s = max($s,\
    \ $e);\n\t}\n\treturn True;\n}\n\n/**\n * Returns the square root of the sum of\
    \ squares of input numbers. The numbers must be\n * integers.\n *\n * @param int[]\
    \ $l\n * @return int\n */", "    $s = array();\n    $j = $i = 1;\n    foreach\
    \ ($l as $n) {\n        if ($n > $s[$i-1]) {\n            $s[] = $n;\n       \
    \ } else if ($n < $s[$i-1]) {\n            return false;\n        } else {\n \
    \           $i = $j;\n            $s[] = $n;\n        }\n    }\n    return $j<$i;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice, even though I see a O(n^2) solution\
    \ (not really a problem for small lists). I can easily imagine a O(nlogn) solution\
    \ for large lists too.\n<|/ c |>\n<| c |>\nOkay, I added an O(nlogn) solution,\
    \ with some explanation. Thinking about it, though, I think the O(n) solution\
    \ is quite clever too. I just think it might be overkill if `n` is very large.\n\
    <|/ c |>\n<| c |>\nYes, you are right, an O(n) solution is definitely more elegant.\
    \ +1 :-)\n<|/ c |>\n<| a tags=algorithm,php,comparison dscore=1 |>\nAs pointed\
    \ out in the comments, the best solution is O(n log n) since it's better than\
    \ the O(n\xB2) solution (with regard to big lists). You can make it a little bit\
    \ faster by using binary search to find whether the two elements should be in\
    \ sorted order:\n<code>\n$l = [20, 4, 1, -10];\n", "\t$s = end($l);\n\t$t = $s[0];\n\
    \tfor ($i = 1; $i < count($l); $i++) {\n\t\t$t = max($t, $s[$i]);\n\t}\n\treturn\
    \ $t >= $s[0];\n}\n/*}}}*/\n/*{{{ Finding Nearest Monotonicity Point\nGiven a\
    \ list of monotonically increasing or decreasing values, this function\nfinds\
    \ the point at which the value is monotonically increasing or decreasing.\nIt\
    \ is useful for determining the value of an X axis on a graph.\n*/", "    $m =\
    \ $n = $curr = $prev = null;\n    foreach ($l as $n) {\n        if ($prev ===\
    \ null && $curr === null) {\n            $prev = $curr = $n;\n        } else if\
    \ ($prev !== null && $curr !== null) {\n            if ($n >= $curr && $n <= $prev)\
    \ {\n                $m = $prev;\n                $n = $curr;\n            } elseif\
    \ ($n >= $curr && $n > $prev) {\n                return false;\n            }\
    \ else {\n                $m = $curr;\n                $n = $prev;\n         \
    \   }\n        } else if ($n === $curr) {\n            if ($curr >= $prev) {\n\
    \                $m = $prev;\n                $n = $curr;\n            }\n   \
    \     }\n        $prev = $curr;\n        $curr = $n;\n    }\n    return $m ===\
    \ null;\n}\n\n/**\n * Helper function for normalizing image metadata.\n *\n *\
    \ Should not be called directly.\n *\n * @param  array  $data\n * @param  string\
    \ $format\n * @param  array  $meta\n * @return array\n */", "  if ($l[0] === $l[1])\
    \ {\n    return false;\n  }\n  if ($l[0] > $l[1]) {\n    return true;\n  }\n \
    \ foreach (array_slice($l, 2) as $val) {\n    if ($val > $l[0]) {\n      return\
    \ true;\n    }\n    if ($val < $l[1]) {\n      return false;\n    }\n  }\n  return\
    \ false;\n}\n", "\tforeach ($l as $k => $v) {\n\t\tif (is_array($v) && $v[0] ===\
    \ $v[count($v) - 1]) {\n\t\t\tunset($l[$k]);\n\t\t\tcontinue;\n\t\t}\n\t\tif ($v\
    \ < $l[0]) {\n\t\t\t$l[0] = $v;\n\t\t} elseif ($v > $l[count($l) - 1]) {\n\t\t\
    \t$l[count($l)] = $v;\n\t\t}\n\t}\n\treturn $l !== array_keys($l);\n}\n", "  $sorted\
    \ = array_reverse($l);\n  return !empty($sorted) && array_diff(range(array_shift($sorted),\
    \ $sorted), $sorted) == [];\n}", "  if (!is_array($l)) {\n    throw new Exception('monotonic\
    \ expects an array');\n  }\n\n  $s = $l[0];\n\n  for ($i = 1; $i < count($l);\
    \ $i++) {\n    if ($l[$i] - $s > 0) {\n      $s = $l[$i];\n    } else {\n    \
    \  return false;\n    }\n  }\n\n  return true;\n}\n", "    $l = array_reverse($l);\n\
    \    do {\n        $res = false;\n        foreach ($l as $elem) {\n          \
    \  if ($elem > $elem) {\n                $res = true;\n                break;\n\
    \            }\n        }\n    } while ($res);\n    return $res;\n}\n", "    if\
    \ (!is_array($l)) return false;\n    $l = array_reverse($l);\n    return array_reduce($l,\
    \ function ($a, $b) {\n        return $a && $b && $a > $b;\n    });\n}\n</code>\n\
    <|/ a tags=php,arrays,algorithm dscore=3 |>\n<| c |>\nThe original example is\
    \ not monotonic. `monotonic([1, 2, 4, 20])` returns `false` but is **not** monotonic\
    \ since `1 vs 20` should yield `1`.\n<|/ c |>\n<| c |>\n, that's because of the\
    \ `array_reduce()` function. `1 vs 20` should yield `1` but not `20` as it has\
    \ nothing to do with the previous values.\n<|/ c |>\n<| c |>\nNo. Try `array_reduce([1,\
    \ 2, 4, 20], function ($a, $b) {return $a && $b && $a > $b;})` which returns `true`.\n\
    <|/ c |>\n<| c |>\n, you are right. My mistake. Updated the answer.\n<|/ c |>\n\
    <| a dscore=3 tags=php,arrays,algorithm |>\nIf you know that there is at least\
    \ one element that is equal but not less than the previous one in the array, then\
    \ you can just check if $arr[$i] <= $arr[$i-1] and decrement $i until it does\
    \ so.\n<|/ a |>\n<| c |>\nYeah, I realised that and added an edit about that.\
    \ I think it still works though\n<|/ c |>\n<| c |>\nYes, this should work. After\
    \ each element you check if it's smaller than the previous element and increment\
    \ the loop. Maybe not the most efficient though. :)\n<|/ c |>\n<| a tags=php,arrays,algorithm\
    \ |>\nAssuming I understand your question correctly, here is my solution:\n<code>\n\
    <?php", "    $l1 = array_merge(array_keys($l), array_values($l));\n    return\
    \ $l1[$l1[count($l1) - 1]] > $l1[0] || $l1[$l1[count($l1) - 1]] == $l1[0] && !array_reduce($l1,\
    \ function ($min, $el) {\n        return $min && $el != $min;\n    });\n}\n",
  "  if (count($l) < 2) { return false; }\n  for ($i = 0, $n = count($l) - 1, $monotone\
    \ = true, &$c = 0; $c < $n; $c++) {\n    $v = $l[$c];\n    if ($v > $l[$c + 1])\
    \ { $monotone = false; break; }\n    if ($v < $l[$c]) { $monotone = false; break;\
    \ }\n  }\n  return $monotone;\n}", "  $l = array_filter($l);\n  if (empty($l))\
    \ {\n    return false;\n  }\n  $min_v = array_shift($l);\n  $max_v = array_pop($l);\n\
    \  return $max_v > $min_v;\n}\n\n/**\n * Helper function to return a human readable\
    \ string for a numeric input.\n *\n * @param int $n The number to format\n * @param\
    \ int $precision Number of decimals to show.\n * @return string\n */", "    $n\
    \ = count($l);\n    $s = 0;\n    $p = array_pad($l, $n, 0);\n    $s[0] = 1;\n\
    \    $p[0] = -1;\n    for ($i = 1; $i < $n; ++$i) {\n        $s[$i] = $s[$i -\
    \ 1] + $p[$i - 1];\n        if ($s[$i] < 0) {\n            $s[$i] = 0;\n     \
    \   }\n        if ($s[$i] > $n) {\n            $s[$i] = $n;\n        }\n    }\n\
    \    return $s[0];\n}", "  foreach ($l as $key => $value) {\n    if ($value <\
    \ $l[$key - 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  \
    \  $l = array_reverse($l);\n    $d = $l[0] - $l[1];\n    if ($d > 0) return true;\n\
    \    if ($d == 0) return false;\n    return array_key_exists($l[1], $l);\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=sorting,php,algorithm |>\nI hope\
    \ it can help someone :\n<code>\n$values = array(1 => 2,  2 => 3, 10 => 4, 50\
    \ => 5, 30 => 6);\n\n$values2 = array();\nforeach ($values as $key => $value)\
    \ {\n    if (!isset($values2[$value])) {\n        $values2[$value] = $key;\n \
    \   }\n}\n\nksort($values2);\n\nvar_dump($values2);\n", "  // Sort from least\
    \ to most positive by absolute value, and try to\n  // find an item where the\
    \ cumulative sum of absolute values exceeds the\n  // previous cumulative sum.\n\
    \  //\n  // This is an optimization that will scale O(n) when starting from sorted\n\
    \  // data and then work through unsorted data in linear time.\n  $l2 = array();\n\
    \  foreach ($l as $v) {\n    if (!isset($l2[$v])) $l2[$v] = 0;\n    $l2[$v]++;\n\
    \  }\n  if ($l2[0] < $l2[1]) {\n    $a = $l2[0];\n    $b = $l2[1];\n  } else {\n\
    \    $a = $l2[1];\n    $b = $l2[0];\n  }\n  if ($a > $b) {\n    $t = $a;\n   \
    \ $a = $b;\n    $b = $t;\n  }\n  foreach ($l2 as $v => $w) {\n    if ($w <= $a)\
    \ continue;\n    if ($w > $b) return false;\n    if ($a + $w <= $b) {\n      $a\
    \ = $a + $w;\n      if ($a > $b || $a < $b) {\n        $l[$v] = $a;\n      }\n\
    \    }\n  }\n  return true;\n}", "    if (is_null($l)) return false;\n    if (!is_array($l))\
    \ return false;\n    if (count($l) !== count(array_unique($l))) return false;\n\
    \    $sorted = sort($l);\n    $diff = array_diff($sorted, $l);\n    return $diff\
    \ === $sorted;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNice solution. I'd just\
    \ use `$diff === $sorted` instead of `array_diff($sorted, $l) === $sorted`, because\
    \ `array_diff` can have different keys.\n<|/ c |>\n<| c |>\nI updated my answer\
    \ with your suggestion.\n<|/ c |>\n<| c |>\nVery clever solution! The only thing\
    \ I'd change is to check for equality with `$l` instead of `$sorted`.\n<|/ c |>\n\
    <| c |>\nGood idea, I changed it. Thanks for pointing it out.\n<|/ c |>\n<| a\
    \ dscore=4 |>\nHere's a function that will tell you if all the elements in an\
    \ array are either increasing or decreasing according to some sort of \"sortedness\"\
    . You can also pass in a closure that will get called on each item in the array\
    \ and can then decide whether it should continue or not.\n<code>", "\t$l = $l\
    \ ? $l : array();\n\tforeach ($l as $i => $v) {\n\t\tif ($l[$i] == $l[0]) {\n\t\
    \t\treturn $i;\n\t\t}\n\t\tif ($v > $l[$i]) {\n\t\t\treturn $i;\n\t\t}\n\t\tif\
    \ ($v < $l[$i]) {\n\t\t\treturn $i + 1;\n\t\t}\n\t}\n\treturn count($l) - 1;\n\
    }\n\n/**\n * Checks if the passed array is empty\n *\n * @param  mixed $arr The\
    \ array to check\n *\n * @return boolean True if the array is empty, false otherwise\n\
    \ */", "    return $l[0] > $l[1];\n}\n", "  if (!is_array($l))\n    return false;\n\
    \  if ($l[0] > $l[count($l) - 1])\n    return true;\n  elseif ($l[0] < $l[count($l)\
    \ - 1])\n    return false;\n  else\n    return monotonic(array_slice($l, 0, -1))\
    \ && monotonic(array_slice($l));\n}\n\n/**\n * Returns the length of a list.\n\
    \ * This is most useful when you want to know the length of an array-like object\
    \ without knowing its contents.\n * This is useful if you have a bunch of objects\
    \ that have a length property but no indication how many\n * of those objects\
    \ are actually used. Otherwise, you should always use count() instead.\n * Example:\n\
    \ * $string = 'a b c d';\n * $array = explode(' ', $string);\n * assert(count($array)\
    \ == count($string));\n * assert(count($array) === 4); // the count\n * assert(count($array)\
    \ > 3); // the length\n * $array[0] = 'd'; // replace the element in the array\n\
    \ * assert(count($array) === 4); // the count would not change\n * assert(count($array)\
    \ > 3); // the length would not change\n * assert($string = 'a b c d e f'); //\
    \ the string would not be changed.\n * assert($array[0] === 'd'); // the new first\
    \ element\n * assert($array[1] === 'e'); // the new second element\n * assert($array[2]\
    \ === 'f'); // the new third element\n * assert($string = 'a b c d e f'); // the\
    \ string would not be changed.\n * assert($array[3] === 'f'); // the new fourth\
    \ element\n * $array[0] = 'd';\n * assert($array[0] === 'd'); // the first element\
    \ would not be 'd'\n * assert($array[1] === 'e'); // the second element would\
    \ not be 'e'\n * assert($array[2] === 'f'); // the third element would not be\
    \ 'f'\n * assert($array[3] === 'f'); // the fourth element would not be 'f'\n\
    \ * $array[2] = 'g';\n * assert($array[2] === 'g'); // the third element would\
    \ not be 'f'\n * assert($array[3] === 'g'); // the fourth element would not be\
    \ 'g'\n * $array[] = 'h';\n * assert($array[3] === 'h'); // the fourth element\
    \ would not be 'h'\n * assert($array[4] === 'g'); // the fifth element would not\
    \ be 'g'\n * assert($array[count($array)] === 'h'); // the fifth element would\
    \ not be 'h'\n * ", "  $min = array_shift($l);\n  foreach ($l as $item) {\n  \
    \  if ($item < $min) {\n      $min = $item;\n    }\n  }\n  return $min < 0;\n\
    }\n", "\t$n = count($l);\n\tif ($n<=1 || $n===0) {\n\t\treturn 1;\n\t}\n\t$l2\
    \ = array_slice($l, 0, $n-1);\n\t$ls2 = array_slice($l2, 1);\n\treturn $l2[0]\
    \ > $ls2[0] || $l2[0]==$ls2[0] && $l2[1] > $ls2[1];\n}", "  // Ensure that $l\
    \ is an array\n  if (!is_array($l)) {\n    $l = array($l);\n  }\n  $last = array_pop($l);\n\
    \  return count($l) < 2 || ($l[0] > $last && $l[1] > $last);\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| a dscore=2 tags=math,php,sorting |>\nI believe this question\
    \ is a bit old and already answered, but I'm going to take a crack at it.\nI find\
    \ that it is easier to understand my algorithms if I separate it into separate\
    \ statements rather than trying to explain it all at once. It also makes it more\
    \ readable and easier to debug if you have a problem.\nThe idea is that you sort\
    \ an array of numbers by their natural ordering but add some additional sorting\
    \ conditions.\n<code>", "    return $l[0] <= $l[count($l) - 1];\n}\n", "  $m =\
    \ array();\n  foreach ($l as $v) {\n    if ($v < $m[0]) {\n      $m = array($v);\n\
    \    }\n    else if ($v > $m[1]) {\n      $m = array($v);\n    }\n    else if\
    \ ($v === $m[0]) {\n      $m[] = $v;\n    }\n  }\n  return count($m) === count($l);\n\
    }\n</code>\n<|/ a tags=algorithm,php,array-difference,arrays |>\n<| c |>\nYou\
    \ forgot to put `$l[0] === $m[0]` in the first `if`. But otherwise this looks\
    \ good.\n<|/ c |>\n<| c |>\nYou don't need the initial check. Simply checking\
    \ `$l[0] == $m[0]` works. But this seems like a good enough answer to the question.\n\
    <|/ c |>\n<| c |>\n: Thanks I missed that, I've added it now.\n<|/ c |>\n<| c\
    \ |>\n: I have added an alternative solution.\n<|/ c |>\n<| a tags=algorithm,php,array-difference,arrays\
    \ dscore=1 |>\nI wrote a php function that does that in javascript. It will find\
    \ the longest increasing sub array from the array. \n<code>\n function longest_increasing_subsequence(arr)\
    \ {\n    var result = [];\n    var index = 0;\n    var subSequence = [];\n   \
    \ while(subSequence.length != 0) {\n       var maxInSubSequence = subSequence.slice(-1)[0];\n\
    \       subSequence = [];\n       for(var i = index; i < arr.length; i++) {\n\
    \          if(arr[i] > maxInSubSequence) {\n             result.push(maxInSubSequence);\n\
    \             subSequence.push(arr[i]);\n             index = i;\n           \
    \  maxInSubSequence = arr[i];\n          } else {\n             maxInSubSequence\
    \ = arr[i];\n          }\n       }\n    }\n    return result;\n }\n</code>\nYou\
    \ can test it here: \nhttp://jsbin.com/iJAyUQI/2/edit\n<|/ a |>\n<| c |>\nThis\
    \ doesn't seem to work. `longest_increasing_subsequence([3,1,2,5])` returns `[3,5]`\
    \ but `longest_increasing_subsequence([3,5,1,2,5])` returns `[3,5]`.\n<|/ c |>\n\
    <| c |>\nOh, yes. You are right, I was using another algorithm. Thanks for the\
    \ comment.\n<|/ c |>\n<| a dscore=0 |>\nYou can do this:\n<code>\n<?php", "  \
    \  $a = array_reverse($l);\n    $b = $a;\n    sort($a);\n    sort($b);\n    return\
    \ (!count($a) && !count($b)) || ($a[0] < $b[0]);\n}\n", "  $l = array_reverse($l);\n\
    \  return array_reduce($l, function ($carry, $item) {\n    return $carry || ($item\
    \ <= $carry);\n  });\n}\n</code>\n<|/ a tags=arrays,php |>\n<| a |>\nThis is my\
    \ solution, just in case anyone needs it for my personal project:\n<code>\n<?php\n\
    \n/**\n * Sort an array in the descending order\n *\n * http://stackoverflow.com/questions/3216135/sort-an-array-in-descending-order\n\
    \ *\n * array $array\n * array\n */", "  $l = $l ? array_reverse($l) : $l;\n \
    \ return count($l) > 1 && $l[0] < $l[count($l) - 1];\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nHi David. I understand that the test is supposed to return True\
    \ for monotonically increasing lists. But if you have a decreasing list like [4,\
    \ 1, 0, -10] it returns false. Can you please explain why?\n<|/ c |>\n<| c |>\n\
    I thought my answer was clearer than my comment. I'll try to give an explanation...\n\
    <|/ c |>\n<| c |>\nI think this answer is better and more complete than the accepted\
    \ answer.\n<|/ c |>\n<| a tags=php,arrays |>\n<code>\n<?php", "  return ($l[0]\
    \ > $l[1]) || ($l[0] == $l[1] && $l[2] > $l[3]);\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
