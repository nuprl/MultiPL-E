name: HumanEval_62_derivative
language: php
prompt: "<?php\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] *\
  \ x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n\
  // >>> derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> derivative([1, 2,\
  \ 3])\n// [2, 6]\nfunction derivative($xs) {\n"
tests: "function candidate(...$args) {\n    return derivative(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(3, 1, 2, 4, 5)) !== array(1, 4, 12, 20))\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1, 2, 3))\
  \ !== array(2, 6)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(3,\
  \ 2, 1)) !== array(2, 2)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(3,\
  \ 2, 1, 0, 4)) !== array(2, 2, 0, 16)) { throw new Exception(\"Test failed!\");\
  \ }\n    if (candidate(array(1)) !== array()) { throw new Exception(\"Test failed!\"\
  ); }\n}\n\ntest();"
completions: ["  $d = array_map(function ($x) {\n    return ($xs[1]);\n  }, array_slice($xs,\
    \ 1));\n  return array_map(function ($x) {\n    return ($x[0] * $d);\n  }, array_slice($xs,\
    \ 0));\n}\n", "  if (!$xs || count($xs) === 0) {\n    return [];\n  }\n  $d =\
    \ array_pop($xs);\n  if (!$d) {\n    return [];\n  }\n  $d2 = array_pop($xs);\n\
    \  if (!$d2) {\n    return [];\n  }\n  $xs[] = $d;\n  return array_map(function\
    \ ($d2) use ($xs) {\n    return $d * ($d2+$xs[count($xs)-1]);\n  }, $xs);\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=php,function,algorithm dscore=0 |>\n<code>",
  "  $dydxs = array();\n  $ys = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n\
    \    $ys += $xs[$i] * $i;\n    $dydxs[] = $ys;\n  }\n  return $dydxs;\n}", " \
    \ $ys = [];\n  for ($i = 0, $len = count($xs) - 1; $i < $len; ++$i) {\n    $ys[$i]\
    \ = array_shift($xs) * $xs[$i];\n  }\n  return $ys;\n}", "  $n = count($xs);\n\
    \  if (!$n) {\n    return [];\n  }\n  return array_fill(0, $n, array_fill(0, $n,\
    \ 0));\n}\n", "  $dx = array_fill(0, count($xs)-1, 0);\n  for ($i = 0; $i < count($xs)\
    \ - 1; $i++) {\n    $dx[$i] = $xs[$i+1] - $xs[$i];\n  }\n  return $dx;\n}\n",
  "  $f = array_shift($xs);\n  $d = array_shift($xs);\n  while ($xs) {\n    $d = $d\
    \ * $f + array_shift($xs);\n  }\n  return $d;\n}", "  $d = 0;\n  $ds = $xs[0];\n\
    \  for ($i = 1; $i < count($xs); $i++) {\n    $d += $xs[$i] * $ds;\n    $ds =\
    \ $d;\n  }\n  return $d;\n}\n", "  if (count($xs) < 2) {\n    return array($xs[0]);\n\
    \  }\n  $d = $xs[1];\n  for ($i = 0; $i < count($xs); $i++) {\n    $d *= $xs[$i];\n\
    \  }\n  return array(1 / ($d + $xs[0]));\n}\n", "  $ds = array_map(function($x)\
    \ {\n    return $x * $x;\n  }, $xs);\n  return $ds;\n}", "  $ys = array_map(function\
    \ ($x) {\n    return $x * $x;\n  }, $xs);\n  return array_map(function ($x, $i)\
    \ {\n    return $x - $ys[$i];\n  }, $xs, array_fill(0, count($ys), 0));\n}\n",
  "  $derivative = 0;\n  foreach($xs as $x) {\n    $derivative = $x * $derivative;\n\
    \  }\n  return $derivative;\n}\n\n$xs = [5, 1, 3, 1];\n$ys = [10, 2, 5, 9];\n\n\
    $dx = derivative($xs);\n$dy = derivative($ys);\n\n$error = ($ys[0] - $dx * $xs[0])\
    \ + ($ys[1] - $dx * $xs[1]) + ($ys[2] - $dx * $xs[2]);\n\necho 'The error is:\
    \ ' . $error . \"\\n\";\n\n$error = sqrt(pow(derivative([3, 1, 2, 4, 5]), 2) +\n\
    \               pow(derivative([1, 2, 3]), 2));\necho \"The error is: \" . $error\
    \ . \"\\n\";\n</code>\n<|/ a |>\n<| c |>\nWhat does it return? `$dy` should be\
    \ `[8,6,12]`\n<|/ c |>\n<| c |>\n`$dy` should be `[8, 6, 12]`.  See my edit. :)\n\
    <|/ c |>\n<| c |>\nI see it. But `derivative([8, 6, 12])` should be `[1, 4, 12]`?\n\
    <|/ c |>\n<| c |>\nNotice how I edited my answer a little.  I missed the `sqrt`\
    \ in `derivative($ys)`.  The `sqrt` was causing the error and hence my initial\
    \ response.  It's a good point that this is just an approximation algorithm and\
    \ not a good solution to the problem.  Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nI have changed my code to reflect the new expected result.  I agree with\
    \ you about the approximation algorithm.  My point is that this solution is not\
    \ going to work because of the inaccuracies in calculating derivatives.\n<|/ c\
    \ |>\n<| a tags=algorithm,math |>\nIt looks like the algorithm you're looking\
    \ for is known as the \"Newton-Raphson method\". I don't know any specific implementation\
    \ in any language, but searching for something like \"Newton-Raphson method implementation\"\
    \ should turn up some implementations. As a starting point, the Wikipedia page\
    \ has a good description about the algorithm.\n<|/ a dscore=3 |>\n<| a dscore=2\
    \ tags=algorithm,math |>\nThe error you're getting is most likely due to the fact\
    \ that in every iteration the derivative function of the derivative of your polynomial\
    \ increases. That means you get bigger and bigger values for every iteration.\
    \ \nWhen you evaluate f(a + b*x + c*x*x + d*x*x*x) you get f(a+b*x+c*x*x+d*",
  "  // Initialize result to be an empty array.\n  $r = array_fill(0, count($xs) -\
    \ 1, 0);\n\n  // Calculate derivative.\n  for ($i = count($xs) - 1; $i >= 0; --$i)\
    \ {\n    $r[$i] = $xs[$i] - $xs[$i - 1];\n  }\n\n  return $r;\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThe `derivative` function does nothing more than `return\
    \ array_reverse(array_merge(array_slice($xs, 1), [$xs[0]]));`.\n<|/ c |>\n<| a\
    \ |>\nThe simplest solution:\n<code>\n<?php\n    $a = array(3, 1, 2, 4, 5);\n\
    \    $b = array();\n    foreach($a as $key => $value)\n    {\n        $b[$key]\
    \ = $value - $a[0];\n    }\n    var_dump($b);", "  return array_reduce(\n    \
    \  array_slice($xs, 1),\n      function($acc, $x) {\n        return array_reduce(\n\
    \            range(1, count($acc)),\n            function($acc, $i) {\n      \
    \        return $acc * pow($x, $i);\n            },\n            $acc);\n    \
    \  },\n      array_shift($xs));\n}\n</code>\n<|/ a tags=php,function,php-7,arrays\
    \ |>\n<| c |>\nThanks for answer. I know about this function and already used\
    \ it but i need to do it in PHP 7 and i dont know how can i use it in PHP 7.\n\
    <|/ c |>\n<| c |>\nIf i get it right here you used a polynom that has 1 parameter\
    \ and its coefficient is defined like in this example: y^2 x^3 + 3x where y is\
    \ the constant and x is every number from 1-10. My polynom is a polynomial like\
    \ this:\n\nx^5 x^3 + x^2 x + 1\n<|/ c |>\n<| c |>\nHmmm, i dont really understand\
    \ how can i use your function to get my polynomial in this format:\nx^5 x^3 +\
    \ x^2 x + 1\n<|/ c |>\n<| a tags=php,function,php-7,arrays |>\nI see you already\
    \ got an answer but for those who also want a PHP version that works on PHP 7\
    \ and maybe others, you can use this function:\n<code>", "  // initialize and\
    \ fill in ys with zeros\n  $ys = array_fill(0, count($xs), 0);\n  // first term\
    \ of result is 1\n  $ys[1] = 1;\n  // next two are first and second terms\n  $ys[2]\
    \ = $ys[1];\n  foreach ($xs as $x => $coef)\n    $ys[$x + 2] = $ys[$x + 1] * $x\
    \ + $ys[$x + 1];\n  return $ys;\n}\n", "  $n = count($xs);\n  if (!$n) {\n   \
    \ return [];\n  }\n  $f = array_shift($xs);\n  $d = [$f];\n  for ($i = 0; $i <\
    \ $n; ++$i) {\n    $x = array_shift($xs);\n    $d[] = $x * $d[$i];\n  }\n  return\
    \ $d;\n}", "  // Get degree of this polynomial.\n  // Get number of coefficients\
    \ in this polynomial\n  // Get length of xs array.\n  $d = count($xs) - 1;\n \
    \ // Get number of coefficients in derivative polynomial.\n  // If degree < 0\
    \ then return []\n  // If coefficient of degree < 0 then return []\n  // If coefficient\
    \ of degree > number of coefficients return []\n  if ($d < 0) {\n    return [];\n\
    \  }\n  $deg = count($xs[$d]) - 1;\n  $coeffs = $d * [$d];\n  $coeffs = array_pad($coeffs,\
    \ $deg + 1, 0);\n  // multiply xs[d] coefficient by degree\n  for ($i = 0; $i\
    \ < $deg; $i++) {\n    $coeffs[$i] += $xs[$d][$i] * $deg;\n  }\n  return $coeffs;\n\
    }\n</code>\n<|/ a tags=php,polynomials dscore=1 |>\n<| c |>\nYou might want to\
    \ explain a bit about the algorithm rather than just posting a block of code.\n\
    <|/ c |>\n<| a |>\nI've written the code in R and used rpy2 to convert it to PHP.\
    \ \n<code>", "  $n = count($xs);\n  if ($n < 2) {\n    return null;\n  }\n\n \
    \ // This code will fail for an empty vector.\n  $dxs = array_fill(0, $n, 1);\n\
    \  for ($i = 1; $i < $n; ++$i) {\n    $dxs[$i - 1] = $xs[$i];\n    $dxs[$i] =\
    \ $xs[$i] - $xs[$i - 1];\n  }\n  return $dxs;\n}\n</code>\n<|/ a |>\n<| a dscore=3\
    \ |>\n<code>", "    if (empty($xs)) {\n        return null;\n    }\n    $n = count($xs);\n\
    \    if ($n === 0) {\n        return null;\n    }\n    $derivate = array();\n\
    \    foreach ($xs as $x) {\n        $derivate[] = $x * self::derivative($xs);\n\
    \    }\n    return $derivate;\n}\n\n/**\n * Calculate the average of two numbers.\n\
    \ * @param $x\n * @param $y\n * @return int|float\n */", "  $n = count($xs);\n\
    \  if ($n <= 2) {\n    return array(1);\n  }\n  $f = $xs[0];\n  for ($i = 1; $i\
    \ < $n; ++$i) {\n    $f *= $xs[$i];\n  }\n  return array($f / $n);\n}\n\n", " \
    \ $d = $xs[1];\n  for ($i = 0; $i < count($xs); $i++) {\n    $d *= ($xs[$i + 1]\
    \ - $xs[$i]);\n  }\n  return $d;\n}\n", "  // Return array of derivatives of xs.\n\
    \  // If x or xs is empty, return empty array.\n  // >>> derivative([1, 2, 3])\n\
    \  // [2, 6]\n  // >>> derivative([1, 2, 3])\n  // [2, 6]\n  // >>> derivative([])\n\
    \  // []\n  if (!$xs) return [];\n  $d = [];\n  for($x = count($xs) - 1; $x >\
    \ 0; $x --) {\n    $d[$x] = $d[$x - 1] * $xs[$x];\n  }\n  return $d;\n}\n", " \
    \ if (!is_array($xs)) return false;\n\n  if (count($xs) === 1) return array(1);\n\
    \  return array_map(function($x, $i) { return $x * $xs[$i]; }, $xs, array_fill(0,\
    \ count($xs) - 1, 1));\n}\n", "  $f = $xs;\n  list($first) = $xs;\n  for ($i =\
    \ count($xs) - 2; $i >= 0; $i -= 2) {\n    $f += [$xs[$i] * $xs[$i + 1]];\n  }\n\
    \  return $f;\n}\n", "  // Initialize result\n  $r = array(1);\n  // Loop over\
    \ all coefficients\n  for ($n = 0; $n < count($xs); $n++) {\n    // Multiply coefficient\
    \ by x^(n+1) and sum all\n    $r[] = $r[$n - 1] * pow($xs[$n], $n + 1);\n  }\n\
    \  // Return derivative\n  return $r;\n}", "    // Return derivative of a polynomial\
    \ in the same form.\n    // >>> derivative([3, 1, 2, 4, 5])\n    // [1, 4, 12,\
    \ 20]\n    // >>> derivative([1, 2, 3])\n    // [2, 6]\n    $d = new stdclass();\n\
    \    $d->c = 0;\n    $d->x = 0;\n    $d->y = 0;\n    $d->n = 0;\n    $d->m = count($xs);\n\
    \    \n    for($i = 0; $i < $d->m; $i++) {\n        $d->y += $xs[$i] * $i;\n \
    \       $d->c += $xs[$i];\n        $d->n++;\n    }\n    $d->y = $d->y / $d->c;\n\
    \    \n    // If degree is odd, add one to the power of x because polynomials\
    \ are differentiated wrt to x \n    if ($d->n % 2 == 1)\n        $d->x++;\n  \
    \  \n    return $d;\n}\n", "  $f = array_shift($xs);\n  $d = array_shift($xs);\n\
    \n  $d0 = $d * $f;\n  $d = $d0 - $f * $d;\n\n  return [round($d), $d];\n}\n",
  "  $dxs = array_fill(0, count($xs), 0);\n  $dxs[1] = 1;\n  for ($x = 2; $x < count($xs);\
    \ $x++) {\n    $dxs[$x - 1] = $dxs[$x] + $xs[$x] * $dxs[$x - 2];\n  }\n  return\
    \ $dxs;\n}\n", "    $result = array();\n    $a = count($xs);\n    for ($i = 0;\
    \ $i < $a; $i++) {\n        $result[$i] = $xs[$i];\n        for ($j = ($i - 1);\
    \ $j >= 0; $j--) {\n            $result[$i] -= $result[$j] * $xs[$j];\n      \
    \  }\n    }\n    return $result;\n}\n", "  $result = [];\n  foreach ($xs as $x)\
    \ {\n    $result[] = $x;\n  }\n  $result[] = 1;\n  return array_map(function ($x)\
    \ {\n    return $x * $result[0];\n  }, $xs);\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=php |>\nFor a more robust solution, you can use:\n<code>\n$xs = [1,\
    \ 2, 3, 4];\n$ys = [1, 3, 2, 4];\n\n$result = array();\nforeach ($xs as $i =>\
    \ $x) {\n    $result[] = ($ys[$i] - $ys[$i - 1]) / ($x - $xs[$i - 1]);\n}\n\n\
    var_dump($result);\n</code>\nThis should give you:\n<code>\narray (size=4)\n \
    \ 0 => float 0\n  1 => float 0.6666666666666667\n  2 => float 0.3333333333333333\n\
    \  3 => float 0\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is how to\
    \ calculate derivatives correctly with PHP\n<code>\n$xs = [1, 2, 3, 4, 5];\n$ys\
    \ = [1, 3, 2, 4, 5];\n\n$result = array();\nforeach ($xs as $i => $x) {\n    $result[]\
    \ = round($ys[$i] / $x, 6);\n}\n\nvar_dump($result);\n</code>\nResult:\n<code>\n\
    array (size=4)\n  0 => float 0\n  1 => float 0.666667\n  2 => float 0.33333\n\
    \  3 => float 0\n</code>\n<|/ a tags=php |>\n<| c |>\nIt's not the correct solution.\
    \ The question is about calculating the derivative of a polynomial in reverse.\n\
    <|/ c |>\n<| c |>\nI thought that was what the OP meant. Maybe you're right. I\
    \ added a line to show how to get the original array values back.\n<|/ c |>\n\
    <| c |>\nYeah, I'm wrong. I deleted my comment :)\n<|/ c |>\n<| a tags=php |>\n\
    I realise this is an old post but I was looking for the same thing and found a\
    \ great library that does this. \nhttp://php-derivative.sourceforge.net/\nThe\
    \ library is extremely versatile and allows you to create polynomials using arrays,\
    \ strings or numbers.\nYou can find the example here (scroll to the bottom): http://www.phpderivative.org/examples/example3.php\n\
    <code>\n$y = new Poly();\n$y->addTerms(new Poly(array('a' => 1, 'b' => 2)));\n\
    $y->addTerms(new Poly(array('a' => 3, 'b' => ", "  return array_map(function($x)\
    \ {\n    return $x * $x;\n  }, array_slice($xs, 1));\n}\n", "    $ys = [1 ];\n\
    \    for ($i = 2; $i < count($xs); $i++) {\n        $ys = array_merge($ys, array_fill(0,\
    \ $i, $xs[$i - 1] * $ys[$i - 1]));\n    }\n    return $ys;\n}\n", "  return array_map(function\
    \ ($x) {\n    return $x * $x;\n  }, array_slice($xs, 1));\n}", "  $nn = count($xs);\n\
    \  if ($nn < 2) {\n    return array_fill(0, $nn, 0);\n  }\n  $dd = [];\n  for\
    \ ($i = 0; $i < $nn; ++$i) {\n    $dd[$i] = $xs[$i];\n    for ($j = $i + 1; $j\
    \ < $nn; ++$j) {\n      $dd[$i] -= $xs[$j] * $dd[$j];\n    }\n  }\n  return $dd;\n\
    }\n", "    if (!count($xs)) return $xs;\n    // return pow($xs[0], count($xs)\
    \ - 1) * (pow(array_pop($xs), 1) ** count($xs));\n    $x = array_pop($xs);\n \
    \   $y = array_shift($xs);\n    return array_map(function ($a) use ($x, $y) {\n\
    \        return $a * ($x * ($y * $y));\n    }, range(1, count($xs)));\n}\n</code>\n\
    <|/ a dscore=3 tags=math,php,algorithm,curve-fitting |>\n<| c |>\nHow does it\
    \ \"work well\" for you? Have you tried my function? How is it different from\
    \ your function?\n<|/ c |>\n<| c |>\nI didnt test it myself, but i think its better\
    \ than my function, im going to try it.\n<|/ c |>\n<| c |>\ni tried it, and i\
    \ got these results:\n\nFor my function: 0.0000000000 \nFor yours: 0.00100000000000000004\n\
    <|/ c |>\n<| c |>\nThen you are probably doing something wrong. I just tried both\
    \ functions on random numbers and I get the same results. Are you sure you are\
    \ not using any kind of rounding or rounding errors? Are you testing it with some\
    \ random numbers? Can you give me a concrete example where it fails?\n<|/ c |>\n\
    <| c |>\nI tested with random numbers, my function is giving the same result,\
    \ yours is giving different results.\n<|/ c |>\n<| a dscore=2 |>\nI wrote some\
    \ code in Python to calculate this formula for you:\n<code>\ndef formula(x, a,\
    \ b, c, d):\n    return (-b + math.sqrt((b * b) - (4.0 * b * c + d * d))) / (2.0\
    \ * c)\n</code>\nThe first two arguments are the x and y coordinates. I used random\
    \ coordinates to test it out, and found the results similar to the ones above.\
    \ I found this formula on Wikipedia on curve-fitting, where you can also find\
    \ more information about these formulas in their own section.\nHere's my Python\
    \ code (I'm using Python 3.8.5, so if you're using something else, you might have\
    \ to replace 'math' with its module name):\n<code>\nimport random\n\ndef formula(x,\
    \ a, b, c, d):\n    return (-b + math.sqrt((b * b) - (4.0 * b * c + d * d))) /\
    \ (2.0 * c)\n\ndef random():\n    return random.uniform(-10, 10), random.uniform(-10,\
    \ 10)\n\ndef func(x, a, b, c, d):\n    return formula(x, a, b, c, d)\n\nfor i\
    \ in range(20):\n    x, y = random()\n    a, b, c, d = func(x, y, a, b, c)\n \
    \   print(x, y)\n</code>", "  $d = $xs[0];\n  for ($i = 1; $i < count($xs); $i++)\
    \ {\n    $d *= $xs[$i];\n  }\n  return $d;\n}\n", "  $result = [];\n  for ($i\
    \ = 0, $size = count($xs) - 1; $i < $size; $i++) {\n    $result[$i] = $xs[$i]\
    \ + $xs[$i + 1] * $xs[$i];\n  }\n  return $result;\n}\n", "  $n = count($xs) -\
    \ 1;\n  return array_map(function ($x) use ($n) {\n    return $xs[$n];\n  }, array_slice($xs,\
    \ 0, $n + 1));\n}\n</code>\n<|/ a tags=math,php |>\n<| c |>\nGreat solution. Thank\
    \ you!\n<|/ c |>\n<| c |>\nAh, very nice solution. Thank you!\n<|/ c |>\n<| a\
    \ |>\nI wrote a function for this. It calculates derivative of a polynomial using\
    \ recursion without loops or external arrays, just using recursion. \n<code>",
  "  return array_map(function($x) {\n    return ($x * $x) / array_reduce($xs, function($acc,\
    \ $v) {\n      return $acc + $v * $v;\n    }, 0);\n  }, array_fill(0, count($xs)\
    \ + 1, 0));\n}\n</code>\nNote that for these functions to work, you must have\
    \ access to anonymous functions, which may not be possible if you're running a\
    \ PHP version older than 5.3.\n<|/ a |>\n<| a |>\nA simple one-line solution in\
    \ PHP:\n<code>\n$array = range(1, 5);\n$array[] = array_sum($array) / count($array);\n\
    </code>\n<|/ a tags=math,php,arrays dscore=4 |>\n<| c |>\nThe array will be empty\
    \ after the sum.\n<|/ c |>\n<| c |>\nJust a warning, this solution is O(n\xB2\
    )\n<|/ c |>\n<| a |>\n<code>\n$array = array(1, 2, 3, 5, 8);\n$array[] = array_sum($array)\
    \ / count($array);\n</code>\n<|/ a tags=math,php,arrays dscore=4 |>\n<| a dscore=4\
    \ |>\nYou can write your own function that does the same. Something like that:\n\
    <code>", "  $x = array_shift($xs);\n  return array_map(function ($ys) use ($x)\
    \ {\n    return array_sum($ys * array_repeat($x, count($ys)));\n  }, $xs);\n}\n",
  "    if (empty($xs)) {\n        return array();\n    }\n\n    return $xs;\n}\n",
  "  $ds = [];\n  foreach ($xs as $x) {\n    $ds[] = $x * $x;\n  }\n  return $ds;\n\
    }\n", "  if (empty($xs)) return [];\n  $result = [];\n  $prev = $xs[0];\n  for\
    \ ($i = 1; $i < count($xs); $i++) {\n    $result[] = $prev * ($xs[$i] - $xs[$i\
    \ - 1]);\n    $prev = $xs[$i];\n  }\n  return $result;\n}\n", "  $deriv = [];\n\
    \  $x = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n    $x = $x * $xs[$i];\n\
    \    $deriv[$i] = $x;\n  }\n  return $deriv;\n}\n", "  if (!isset($xs[0])) return\
    \ null;\n  if (isset($xs[0])) return $xs[0];\n  if (count($xs) === 1) return null;\n\
    \  return array_sum($xs);\n}\n", "  $n = count($xs);\n  $dxs = array_fill(0, $n\
    \ - 1, 0);\n  $dxs[$n - 1] = 0;\n  for ($i = 1; $i <= $n; $i++) {\n    $dxs[$i]\
    \ = $dxs[$i - 1] * $xs[$i] + $xs[$i - 1];\n  }\n  return $dxs;\n}\n</code>\n<|/\
    \ a tags=php,math,polynomials dscore=5 |>\n<| c |>\n+1 for providing the correct\
    \ formula rather than the wrong formula. Also, good idea about the array sizes.\n\
    <|/ c |>\n<| c |>\nI added a comment at the top of the script explaining the usage\
    \ of xs[] and dxs[]\n<|/ c |>\n<| c |>\nVery neat solution. Just to add one more\
    \ thing. Be careful when evaluating a polynomial expression this way. You may\
    \ want to check if the degree of the polynomial is equal to degree of input array.\
    \ For instance if you want to evaluate `1^2+2^3+3^5` expression make sure you\
    \ add all the coefficients as separate elements to your array before evaluating\
    \ like `[1, 5, 25]`. Otherwise you will get wrong result.\n<|/ c |>\n<| c |>\n\
    Great solution. Just a minor clarification: You should be aware that PHP's [`pow()`](http://www.php.net/manual/en/function.pow.php)\
    \ function uses [**exponential notation**](http://www.mathsisfun.com/calculus/exponentiation.html),\
    \ so to evaluate `x^y`, you should actually use `pow(pow(x, y), 1)` instead of\
    \ `pow(x,y)`.\n<|/ c |>\n<| c |>\nOne problem here is that pow() returns a float,\
    \ so if you're trying to calculate something like `pow($x, $y) - $y` where $y\
    \ is a decimal number then the result of $x ^ $y will also be a float.\n<|/ c\
    \ |>\n<| a dscore=4 |>\nThe first formula is the way polynomial evaluation is\
    \ done in Computer Science.\nThe second formula is one approach to the problem.\
    \ Basically, the second formula is more of a calculus approach than a programming\
    \ approach.\nWikipedia has a nice article on Differential equations.\n<|/ a tags=php,math,polynomials\
    \ |>\n<| a tags=php,math,polynomials |>\nThe easiest way is to first convert the\
    \ input to coefficients and evaluate the polynomial in reverse order. The example\
    \ below takes input as string, converts it into array and evaluates the polynomial\
    \ equation.\n<code>\n<?php\nclass Polynomial {\n    private $coefficients = array();\n\
    \n", "    // Your code here\n    if (count($xs) > 1) {\n        return derivative(array_slice($xs,\
    \ 1)) * $xs[0];\n    }\n    return array_pop($xs);\n}", "  if (!is_array($xs))\
    \ return array(0);\n  $d = array();\n  for ($i = 0, $c = count($xs); $i < $c;\
    \ $i++) {\n    $d[$i] = $xs[$i];\n    for ($j = 1; $j <= $i; $j++) $d[$i] -= $xs[$j]\
    \ * $d[$j];\n  }\n  return $d;\n}\n", "  return array_map(function ($x) {\n  \
    \  return array_sum(array_map(function ($y) {\n      return pow($x, $y);\n   \
    \ }, range(1, count($xs) - 1)));\n  }, $xs);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This one works too, but I think it is too complicated and therefore not that easy\
    \ to understand. I would prefer a shorter one. But thank you anyway!\n<|/ c |>\n\
    <| a tags=php,math |>\nA simple way to find roots for polynomials is to use Newton's\
    \ method or secant method.\n<code>", "  $d = 1;\n  for ($i = count($xs) - 1;;\
    \ --$i) {\n    $xs[$i] += $d;\n    $d *= $xs[$i];\n    if (!$i) {\n      break;\n\
    \    }\n  }\n  return $d;\n}\n</code>\n<|/ a |>\n<| c |>\nI really appreciate\
    \ your help. Thank you, this is what I was looking for.\n<|/ c |>\n<| a |>\n<code>",
  "  $n = count($xs);\n  if ($n === 0) {\n    return [];\n  }\n  $d = [1 / ($xs[$n\
    \ - 1] + $xs[0])];\n  for ($i = 2; $i <= $n; ++$i) {\n    $d[$i] = $d[$i - 1]\
    \ * $xs[$i] - $d[$i - 2] * $xs[$i - 2];\n  }\n  return $d;\n}\n", "  // return\
    \ derivative of polynomial with 0 coefficients\n  if (count($xs) == 0) {\n   \
    \ return array(0);\n  }\n  // return the derivative\n  return array(\n    $xs[1],\n\
    \    $xs[2] + ($xs[0] * $xs[2])\n  );\n}\n</code>\n<|/ a |>\n<| c |>\nOh, yes\
    \ indeed. I made a mistake in my answer :) It would be more efficient to use an\
    \ array to store the coefficients instead of a string.\n<|/ c |>\n<| c |>\nThank\
    \ you very much. I tested your code, but with your example `echo derivative([2,\
    \ 3, 4, 5, 6, 7, 8]);` I get this output `0.000000 0.000000 0.000000 0.000000\
    \ 0.000000 0.000000 0.000000`. So I guess it's not working as expected. I'm sorry\
    \ for the inconvenience, I edited my question and added my php code in the question.\n\
    <|/ c |>\n<| c |>\nI tested your code, and I get the expected output with `echo\
    \ derivative([2, 3, 5, 7]);`. The output is `1.000000 2.000000 5.000000 7.000000`.\
    \ What exactly did you test? Please test it again and show me your exact input.\n\
    <|/ c |>\n<| c |>\nOh, I made a mistake. My fault. You're right, your code works\
    \ perfectly. I just tested it with my real datas and it worked. Thank you very\
    \ much!\n<|/ c |>\n<| c |>\nYou're welcome. Please accept my answer if you think\
    \ it solves your problem :)\n<|/ c |>\n<| a |>\nHere's a PHP implementation that\
    \ does not require a loop and is relatively fast. It also handles polynomials\
    \ with an even number of terms.\n<code>", "  if (count($xs) <= 1) return [];\n\
    \  $xs[0] *= $xs[1];\n  $xs[0] += $xs[2];\n  return array_slice($xs, 1, count($xs)\
    \ - 1);\n}", "  $ys = [];\n  for ($x = count($xs) - 1; $x >= 0; $x--) {\n    $xpow\
    \ = $xs[$x];\n    $ys[$x]   = $ys[$x-1] + $xpow;\n  }\n  return $ys;\n}\n\n/**\n\
    \ * Returns a factorial of a number.\n * >>> factorial(1)\n * 1\n * >>> factorial(2)\n\
    \ * 2\n * >>> factorial(5)\n * 120\n * >>> factorial(10)\n * 1040\n * >>> factorial(20)\n\
    \ * 479001600\n * >>> factorial(30)\n * 265252859812\n * >>> factorial(40)\n *\
    \ 140737488355328\n * >>> factorial(50)\n * 549755813888032\n * >>> factorial(60)\n\
    \ * 14073748835532800\n * >>> factorial(100)\n * 17179869184008601600\n * >>>\
    \ factorial(200)\n * 78813283317280000000000000000000000000000000000000000\n *\
    \ >>> factorial(300)\n * 15728640089637291200\n * >>> factorial(800)\n * 150000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(1000)\n * 11771463712000000000000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(2000)\n * 666200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(3000)\n * 400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(10000)\n * 33000000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(100000)\n * 3300000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(1000000)\n * 330000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(10000000)\n * 33000000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(100000000)\n * 3300000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(1000000000)\n * 330000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(10000000000)\n * 33000000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(100000000000)\n * 3300000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(1000000000000)\n * 330000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(10000000000000)\n * 33000000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(100000000000000)\n * 3300000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(1000000000000000)\n * 330000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(10000000000000000)\n * 33000000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(100000000000000000)\n * 3300000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(1000000000000000000)\n * 330000000000000000000000000000000000000000000000000\n\
    \ * >>> factorial(10000000000000000000)\n * 33000000000000000000000000000000000000000000000000\n\
    \ * >>> ", "  $result = [];\n  foreach ($xs as $x) {\n    $result[] = $x;\n  \
    \  $result[] = array_reduce($result, function ($acc, $value) {\n      return $acc\
    \ + $value * $x;\n    });\n  }\n  return $result;\n}", "  return [\n      array_reduce($xs,\
    \ 0, function ($acc, $x) {\n        return $acc + ($x * $x);\n      }),\n    \
    \  array_reduce($xs, 1, function ($acc, $x) {\n        return $acc + ($x * $x\
    \ * ($x - 1));\n      })\n  ];\n}", "  $ys = $xs[0];\n  for($i = 1, $len = count($xs)\
    \ - 1, $x = $xs[$i]; $i < $len; $i++) {\n    $ys = $x * $ys + $xs[$i];\n  }\n\
    \  return $ys;\n}\n", "    return array_map(function($x) {\n        return $x\
    \ * $x;\n    }, $xs);\n}\n", "  $fx = array_shift($xs);\n  return array_map(function\
    \ ($x) { return $fx * $x; }, $xs);\n}\n", "  $result = [];\n  for ($i = count($xs)\
    \ - 1; $i >= 0; $i--) {\n    $result[$i] = $xs[$i] * $xs[$i];\n  }\n  return $result;\n\
    }\n</code>\n<|/ a tags=php,math |>\n<| c |>\nthanks for the answer. I forgot to\
    \ mention that the polynomial is unknown, i.e. there could be n number of coefficients\
    \ and each of them should be used as an independent variable. Also, there could\
    \ be n number of independent variables. Please let me know if you can think of\
    \ any way around this.\n<|/ c |>\n<| c |>\n: You could store all values in a multidimensional\
    \ array. Multidimensional arrays are more or less a standard data structure in\
    \ PHP. Maybe try something like `array(\"x\" => array(1, 2, 3, ...), \"y\" =>\
    \ array(1, 2, 3, 4, ...))`\n<|/ c |>\n<| c |>\nI tried that but the problem is\
    \ that I have to find coefficients using the equation. For example, my polynomial\
    \ looks like this (10*x^2 + 20*x) and when using the equation 10*x^2 + 20*x, I\
    \ should find coefficients 2 and 3. But when I use your solution, I can find only\
    \ 1.\n<|/ c |>\n<| c |>\n: I understood what you're saying. You have to solve\
    \ the polynomial for a single `x` and then multiply this single value to the coefficients\
    \ of your polynomial. Something like `(x^2 + x)*(10*x^2 + 20*x) = (10*x^2 + 20*x)`\
    \ but since you only have one value, there's no way to get a second value. That's\
    \ why you only get the first coefficient.\n<|/ c |>\n<| c |>\n: I added another\
    \ solution for you.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n<?php\n\n$xs = array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);\n\
    \n$d = 0;\n$a = 1;\n$x= 1;\nforeach($xs as $x1)\n{\n    $d = $d + $a*$x;\n   \
    \ $a = $a*$x1;\n    $x = $x*$x1;\n}\n\n$result = $d;\n\necho '<pre>';\nprint_r($xs);\n\
    echo '</pre>';\necho '<pre>';\nprint_r($result);\necho '</pre>';", "  $d = [1\
    \ => 0];\n  foreach ($xs as $x) {\n    list($n,) = $x;\n    for ($i = 0; $i <\
    \ $n; $i++) {\n      $d = array_merge($d, array_fill(0, $n, 0));\n    }\n  }\n\
    \  return array_map(function($n) {\n    return array_sum($n);\n  }, $d);\n}\n\n\
    /**\n * Evaluate an expression using the coefficients stored in $xs.\n * $xs is\
    \ the list of variables in an expression.\n * Returns an array of doubles representing\
    \ the expression evaluation.\n */", "  if (empty($xs)) {\n    return array();\n\
    \  }\n  $result = array();\n  for ($i = 0, $len = count($xs); $i < $len; ++$i)\
    \ {\n    $result[] = ($xs[$i] - $xs[$i - 1]) / ($xs[$i] - $xs[i - 1]);\n  }\n\
    \  return $result;\n}\n", "  $n = count($xs);\n  if ($n == 0) {\n    return null;\n\
    \  }\n\n  $d = $xs[1];\n  for ($i = 1; $i < $n - 1; $i++) {\n    $d *= $xs[$i];\n\
    \  }\n  $d *= $xs[$n - 1];\n\n  return $d;\n}\n", "  $d = $xs;\n  for ($i = count($xs)\
    \ - 1; $i >= 0; $i--)\n    $d .= ($xs[$i] / $xs[$i + 1] - $d[count($d) - 1]);\n\
    \  return $d;\n}\n", "    if (count($xs) === 0) return null;\n    $d = $xs[0];\n\
    \    for ($i = 1; $i < count($xs); $i++) {\n        $d *= $xs[$i];\n    }\n  \
    \  return $d;\n}\n", "  $d = $xs[0];\n  for ($i = 1, $n = count($xs); $i < $n;\
    \ ++$i) {\n    $d *= ($xs[$i] - $xs[$i - 1]);\n  }\n  return $d;\n}\n", "  $x\
    \ = array_shift($xs);\n\n  // If it has only one point (point-at-zero case) then\
    \ we return it directly\n  // and do not evaluate the derivative.\n  if ($x ==\
    \ 0) {\n    return $xs;\n  }\n\n  // First we calculate the higher order derivative.\n\
    \  // >>> derivative([-2, 3, 1])\n  // [-2, '3 * 2^(-1) + 2', '3 * 2^(-1) - 1']\n\
    \  $ds = array_map(function ($x) {\n    // If the first order derivative is undefined\
    \ then we return undefined.\n    // >>> derivative([-2, 0])\n    // '2 * 2^(-1)\
    \ - 1'\n    return $x === 0 ? '' : \"$x * $x \";\n  }, array_slice($xs, 1));\n\
    \  $ds[0] .= '- 1';\n\n  // Now we iterate from the higher order derivative to\
    \ the lower order derivative.\n  // >>> derivative([-2, '3 * 2^(-1) + 2', '3 *\
    \ 2^(-1) - 1])\n  // ['-1', '-3 * (2 * 2^(-1) - 1) + 3', '-3 * (2 * 2^(-1) - 1)']\n\
    \  // >>> derivative(['-1', '-3 * (2 * 2^(-1) - 1) + 3', '-3 * (2 * 2^(-1) - 1)'])\n\
    \  // ['-1', '-3 * ((2 * 2^(-1) - 1) / 3) + 3', '-3 * ((2 * 2^(-1) - 1) / 3)']\n\
    \  $ds = array_map(function ($d) { return $d === '' ? '0' : ($d . '/ ' . str_replace(')',\
    \ ') * ' . $d); }, $ds);\n\n  // And now we evaluate each order.\n  // >>> derivative(['-1',\
    \ '-3 * ((2 * 2^(-1) - 1) / 3) + 3', '-3 * ((2 * 2^(-1) - 1) / 3)'])\n  // ['-1',\
    \ '-3 * (3 / 7) + 3', '-3 * (3 / 7)']\n  $ds = array_map(function ($d) { return\
    \ $d === '' ? $d : ($d . ' + ' . str_repeat($d, strlen($d) - 1) . ') / ' . str_replace(')',\
    \ ') * ' . $d; }, $ds);\n\n  return $xs[0] . ' + ' . implode(' + ', $ds);\n}\n",
  "  $xs = array_map(function ($x) { return $x * 1; }, $xs);\n  $product = array_shift($xs);\n\
    \  $d = array_shift($xs);\n  return array_map(function ($x) { return $product\
    \ / $x; }, $xs);\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nFor me the function\
    \ derivative is actually the inverse function.\n<code>\n<?php", "    return array_map(\n\
    \        function ($x) {\n            return pow($x, 2);\n        },\n       \
    \ $xs\n    );\n}\n", "  $d = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n\
    \    $d *= $xs[$i];\n  }\n  return $d;\n}\n", "  $x = array_shift($xs);\n  return\
    \ array_reduce($xs, function($result, $x) {\n    return array_map(function($r)\
    \ use ($x) {\n        return $r * $x;\n      }, $result);\n  }, array_fill(0,\
    \ count($xs) - 1, $x));\n}\n", "  $ys = [];\n  $y = 0;\n  foreach ($xs as $x)\
    \ { $y += $x * $x; $ys[] = $y; }\n  return $ys;\n}", "  return array_reduce($xs,\
    \ function ($acc, $x) {\n    return [$acc * $x];\n  });\n}\n", "  return array_map(function($x)\
    \ {\n    return $x * $x; // x * x\n  }, $xs);\n}\n", "    $xs = array_map(function($x)\
    \ { return $x * 1; }, $xs);\n    $result = array();\n    array_walk($xs, function(&$x,\
    \ $k) {\n        $result[$k] = $x;\n    });\n    return array_shift($result);\n\
    }\n", "  return array_map(function ($x) {\n    return $x * $xs;\n  }, range(1,\
    \ count($xs) + 1));\n}\n", "  // Return 0 if the array is empty.\n  if (!isset($xs[0]))\
    \ return 0;\n  // Return derivative of this polynomial in the same form.\n  return\
    \ $xs[0];\n}", "  $x = array_shift($xs);\n  $d = array_shift($xs);\n  return array_map(function($y)\
    \ use($x, $d) {\n    return $y / $x * $d + $y;\n  }, $xs);\n}", "  $n = count($xs);\n\
    \  if ($n < 2) {\n    return array(0);\n  }\n  $d = array();\n  for ($i = 0; $i\
    \ < $n - 1; $i++) {\n    $d[$i] = 0;\n    for ($j = $i + 1; $j < $n; $j++) {\n\
    \      $d[$i] += $xs[$j] * ($xs[$j + 1] - $xs[$i]);\n    }\n  }\n  return $d;\n\
    }", "    if (!is_array($xs)) $xs = array($xs);\n\n    if (count($xs) === 0) {\n\
    \        $derivative = array();\n    } else {\n        $derivative = array_shift($xs)\
    \ * array_shift($xs);\n        foreach ($xs as $x) $derivative .= $x * $derivative;\n\
    \    }\n\n    return $derivative;\n}\n", "  if (empty($xs)) {\n    return [];\n\
    \  }\n  return array_slice($xs, -1) + [$xs[count($xs) - 1]];\n}\n", "  // Initialize\
    \ derivative.\n  $dxs = array();\n  // Check coefficients count.\n  if (count($xs)\
    \ < 3) {\n    return $dxs;\n  }\n  // Save a copy of xs.\n  $xs_copy = $xs;\n\
    \  // For each element of xs.\n  for ($i = 0; $i < count($xs) - 1; $i++) {\n \
    \   // Calculate derivative element.\n    $dxs[$i] = $xs_copy[$i] + ($xs_copy[$i\
    \ + 1] - $xs_copy[$i]) / $i;\n  }\n  // Return derivative.\n  return $dxs;\n}",
  "  $d = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n    $d *= $xs[$i];\n \
    \ }\n  return $d;\n}\n", "  // Find highest order with roots.\n  $orders = array_map(function\
    \ ($x) {\n    return round(max($x));\n  }, array_values($xs));\n\n  // Evaluate\
    \ polynominal from highest order to lowest order.\n  $poly = array_shift($orders);\n\
    \  $poly = eval('return (' . $poly . ');');\n\n  // Create array of derivatives.\n\
    \  foreach ($orders as $order) {\n    $x = $order - 1;\n    $derivatives[$order]\
    \ = $x * $poly;\n  }\n\n  return $derivatives;\n}\n", "  // Get number of coefficients.\n\
    \  $n = count($xs);\n  // Return zero for empty polynomial.\n  if ($n < 1) return\
    \ array();\n  // Return vector of derivatives of empty polynomial.\n  return array(1\
    \ => $xs[0]);\n  // Get number of terms.\n  $m = floor($n / 2);\n  // Initialize\
    \ array of derivatives of last power of polynomial.\n  $d = array();\n  // Initialize\
    \ current power of polynomial.\n  $p = 1;\n  // Evaluate x(n) in terms of current\
    \ power and accumulate derivatives.\n  for ($i = 0; $i <= $n; $i++) {\n    //\
    \ For first derivative, use x(n) evaluated at current power.\n    if ($i == 0)\
    \ {\n      $d[$i] = $xs[$i];\n    // For other derivatives, use derivative of\
    \ x(n) evaluated at current power.\n    } else {\n      $d[$i] = $p * $xs[$i];\n\
    \    }\n    // Update current power of polynomial.\n    $p = $p * $xs[$i];\n \
    \ }\n  // Return vector of derivatives of polynomial.\n  return $d;\n}\n", " \
    \   if (count($xs) < 2) return array();\n    $f = array_shift($xs);\n    $fx =\
    \ array_shift($xs);\n    $n = count($xs);\n    $d = 0;\n    for($i = 0; $i < $n;\
    \ $i++) {\n        $d += $fx * pow($xs, $i);\n    }\n    return array($d);\n}\n",
  "  return array_map('self::_derivative', self::_flattenArray($xs));\n}\n", "  list($x,\
    \ $y) = each($xs);\n  if ($y == 0) {\n    return 0;\n  }\n  return array(1, $y,\
    \ $x * ($y - 1));\n}\n", "  $d = $xs[0];\n  for ($i = 1; $i < count($xs); $i++)\
    \ {\n    $d *= $xs[$i];\n  }\n  return $d;\n}\n", "  $d = [];\n  for ($i = 0,\
    \ $l = count($xs); $i < $l; $i++) {\n    $d[$i] = $i;\n  }\n  for ($i = 0, $l\
    \ = count($xs) - 1; $i < $l; $i++) {\n    $d[$i] -= 1;\n  }\n  $d = array_reverse($d);\n\
    \  $d = array_map(function ($value) use ($xs) {\n    return $value * $xs[$value];\n\
    \  }, $d);\n  return $d;\n}\n</code>\n<|/ a tags=php |>\n<| c |>\nI don't think\
    \ this works correctly when the input is a string.  You end up with an array like\
    \ `[\"1\", \"1\", \"1\", \"1\", \"1\"]`.\n<|/ c |>\n<| c |>\nYou are absolutely\
    \ right. But I guess that would not be the case if OP does not have a string like\
    \ \"12345\" but an array of strings like [\"1\", \"2\", \"3\", \"4\", \"5\"].\
    \ He should decide whether he wants to treat \"12345\" as a string like \"12345\"\
    \ or a string like an array of characters. I think that he should decide whether\
    \ he wants to treat \"12345\" as a string or as an array of characters. And then\
    \ he should consider whether \"12345\" is a string or a character array. I don't\
    \ know what is the best way to handle this.\n<|/ c |>\n<| c |>\nI like your answer\
    \ because it's simple. My solution was just using math instead of recursion, but\
    \ I'm still glad to have found this solution in SO. :)\n<|/ c |>\n<| a tags=php\
    \ |>\n<code>", "  if ($xs < 0 || count($xs) < 1) return null;\n  $s = array_shift($xs);\n\
    \  $product = array_shift($xs);\n  $product = array_shift($xs);\n  if (!$product)\
    \ $product = 1;\n\n  return array($product);\n}\n", "  if ($xs[0] == 0) {\n  \
    \  return [];\n  }\n\n  $d = [];\n  for ($i = 0, $size = count($xs) - 1; $i <\
    \ $size; $i++) {\n    $d[$i] = $xs[$i] * $xs[$i + 1];\n  }\n  return $d;\n}\n",
  "  $x = array_pop($xs);\n  return $x? $xs * derivative($xs) : $xs;\n}\n", "  $result\
    \ = [];\n  foreach ($xs as $x) {\n    $result[] = $x;\n    $result[] = $x * $x;\
    \ // dx^0\n    $result[] = array_sum($result); // dx^1\n  }\n  return $result;\n\
    }\n</code>\n<|/ a tags=math,php,polynomial-math,algorithm |>\n<| c |>\nPlease\
    \ provide some explanations.\n<|/ c |>\n<| c |>\nIt's not clear what your code\
    \ is trying to do. Explain what it does in plain English. Explain what this code\
    \ does and how it does it.\n<|/ c |>\n<| a dscore=1 tags=math,php,polynomial-math,algorithm\
    \ |>\n<code>", "    return array_map(function ($x) { return $x * $x; }, $xs);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour code works for 1 dimensional array,\
    \ But it won't work for multidimensional array\n<|/ c |>\n<| c |>\nHow would you\
    \ like to handle multi-dimensional arrays?\n<|/ c |>\n<| c |>\nYour code gives\
    \ me `[4, 6, 12, 24, 48, 100]` for your example data\n<|/ c |>\n<| c |>\nI have\
    \ edited my answer with a solution that handles multi-dimensional arrays as well.\n\
    <|/ c |>\n<| a dscore=0 |>\nAnother way of doing it would be to take the array\
    \ and perform a for loop with the number of elements. Then you could take each\
    \ element and multiply it by itself and that element is the answer. This would\
    \ work if you wanted to find the derivative of a polynomial equation. \nThe code\
    \ would look like this:\n<code>\n<?php\n", "  if (count($xs) < 3) return array();\n\
    \  $p = $xs[0];\n  $d = 1;\n  for ($i = 1; $i < count($xs) - 1; $i++) {\n    $d\
    \ *= $xs[$i];\n    $d -= $p;\n    $p = $d;\n  }\n  return array($p);\n}\n", " \
    \ $xs_size = count($xs);\n  $derivatives = array();\n  $derivatives[$xs_size-1]\
    \ = 1;\n  for($x = $xs_size-2; $x >= 0; $x--) {\n    $derivatives[$x] *= $xs[$x+1];\n\
    \  }\n  return $derivatives;\n}", "  $ds = [];\n  for ($i = 0; $i < count($xs);\
    \ $i++) {\n    $ds[] = $xs[$i] * $xs[$i - 1];\n  }\n  return $ds;\n}\n", "  $d\
    \ = [];\n  for ($i = 1; $i < count($xs); $i++) {\n    $d[$i] = $xs[$i - 1] * $xs[$i];\n\
    \  }\n  return $d;\n}\n</code>\nAnd this is the final solution:\n<code>", "  $derivative\
    \ = array();\n  for ($i = 0; $i < count($xs); $i++) {\n    $derivative[$i] = $xs[$i];\n\
    \  }\n  for ($i = 1; $i < count($xs) - 1; $i++) {\n    $derivative[$i] = $xs[$i]\
    \ + $derivative[$i - 1] * $xs[$i];\n  }\n  return $derivative;\n}\n", "  $result\
    \ = [];\n  foreach ($xs as $x) {\n    $result[] = $x * $xs;\n  }\n  return $result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI believe this is the solution I'm looking for.\
    \ Thank you so much! I've been struggling with this for days. I appreciate the\
    \ help very much!\n<|/ c |>\n<| c |>\nYou're welcome. If this answer solved your\
    \ problem please accept it.\n<|/ c |>\n<| c |>\nI have one more question for you.\
    \ Do you think it's possible to solve this problem without using recursion? I'm\
    \ very new to PHP and I haven't learned recursions yet. I know it's possible but\
    \ I'm having trouble visualizing how to do it. If it's not too much trouble, could\
    \ you help me understand how it would be done? Thanks so much!\n<|/ c |>\n<| c\
    \ |>\nYou will need to use a stack for this problem. Google it for a solution.\
    \ You could use recursion for this but it will not be the fastest solution.\n\
    <|/ c |>\n<| a |>\nA solution without recursion:\n<code>", "  $xs = array_reverse($xs);\n\
    \  foreach ($xs as $x) {\n    $xs[] = $x * $x;\n  }\n  return array_sum($xs) *\
    \ -1;\n}\n", "  $ds = array_fill(0, count($xs), 0);\n  for ($i = 1; $i < count($xs);\
    \ $i++) {\n    $ds[$i - 1] = $xs[$i] * $xs[$i - 1];\n  }\n  return $ds;\n}\n",
  "  $derivative = [];\n  $length = count($xs);\n  for ($i = 0; $i < $length; $i++)\
    \ {\n    $derivative[] = (isset($xs[$i + 1]) ? $xs[$i + 1] : 0) - $xs[$i];\n \
    \ }\n  return $derivative;\n}\n", "  $xs = array_slice($xs, 1);\n  $y = array_shift($xs);\n\
    \  $d = array_shift($xs);\n  return array_map(function($x) {\n    return $x *\
    \ $y;\n  }, $xs);\n}\n\n", "  $deriv = [];\n  foreach ($xs as $x) {\n    $deriv[]\
    \ = 1 + $x * $x;\n  }\n  return $deriv;\n}", "  $n = count($xs);\n  if ($n < 2)\
    \ {\n    return $xs;\n  }\n\n  $d = [];\n  for ($i = 0; $i < $n - 1; $i++) {\n\
    \    $x = $xs[$i];\n    for ($j = $i + 1; $j < $n; $j++) {\n      $xx = $xs[$j]\
    \ * $x;\n      $d[] = $xx;\n    }\n  }\n  return $d;\n}", "  $result = [];\n \
    \ for ($i = 0; $i < count($xs); $i++) {\n    $result[$i] = $xs[$i];\n  }\n  $result[0]\
    \ = 1;\n  for ($i = 1; $i < count($xs); $i++) {\n    $result[$i] = $result[$i\
    \ - 1] * $xs[$i];\n  }\n  return $result;\n}", "  return array_map(\n    function\
    \ ($x) {\n      return $x * $x;\n    },\n    array_slice($xs, 1)\n  );\n}", " \
    \ $n = count($xs);\n  if ($n < 2) {\n    return array();\n  }\n  $ys = array(1);\n\
    \  $x = array_shift($xs);\n  for ($i = 0; $i < $n; ++$i) {\n    $y = $x * $xs[$i];\n\
    \    array_push($ys, $y);\n    $x = $y;\n  }\n  return $ys;\n}", "    // Your\
    \ code here.\n}\n", "  $result = [0, 1];\n  for ($i = 0, $len = count($xs); $i\
    \ < $len; $i++) {\n    $result[0] += $xs[$i] * $result[1];\n    $result[1] = 0;\n\
    \  }\n  return $result;\n}\n", "    return array_map(function ($x) {\n       \
    \ return array_sum(array_map(__FUNCTION__, [$x]));\n    }, $xs);\n}\n</code>\n\
    <|/ a dscore=1 tags=php,arrays,polynomials,math |>\n<| a tags=php,arrays,polynomials,math\
    \ |>\nI made this recursive function using array_reduce, and it is working properly.\n\
    <code>", "  // xs is an array of coefficients\n  // return an array of coefficients\
    \ representing derivative\n  return array_map(function($c){return $c * $c;}, $xs);\n\
    }\n\n$xs = [1, 2, 3, 4, 5];\n\necho derivative($xs);\n", "    $xs = $xs[0];\n\
    \    if ($xs < 1) {\n        return [];\n    }\n    if ($xs <= 3) {\n        return\
    \ [$xs];\n    }\n\n    $d = ($xs[0] + $xs[1] * $xs[2]) / 3;\n\n    if ($xs[2]\
    \ > 0) {\n        $d[$xs[2]] = 3 * $d[$xs[2]];\n    }\n    if ($xs[1] > 0) {\n\
    \        $d[$xs[1]] = 3 * $d[$xs[1]];\n    }\n\n    return $d;\n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThank you very much! I appreciate it\n<|/ c |>\n<| c\
    \ |>\nThis works great in Ruby, but I have some issues in PHP.  I wrote a function\
    \ that works perfectly in Ruby, but fails in PHP.  I'll post it below.  Any idea\
    \ what the issue is?  Thanks!\n<|/ c |>\n<| c |>\nI don't have PHP installed right\
    \ now, but I think you are getting wrong results. Try `var_dump($xs);` before\
    \ `$xs = $xs[0];`, to see why you get wrong results. My guess is that `$xs` is\
    \ empty and you are trying to get first element from empty array.\n<|/ c |>\n\
    <| c |>\nI got it.  I put my answer at the bottom of my post.  Thanks so much!\n\
    <|/ c |>\n<| c |>\nThanks, you save my day\n<|/ c |>\n<| a tags=polynomials,php,math\
    \ |>\nThe previous answers didn't work for me in PHP (5.3.10).\nThe solution that\
    \ works is this:\n<code>", "  $ys = array_map(function ($x) {\n    return $x *\
    \ $x;\n  }, $xs);\n  return array_sum($ys);\n}\n", "  return array_map(function\
    \ ($x) {\n    return $x * $x * ($xs - 1);\n  }, $xs);\n}\n", "  $deriv = [];\n\
    \  for ($i = 0; $i < count($xs); $i++) $deriv[] = $xs[$i] * $i;\n  return $deriv;\n\
    }", "    return $xs;\n}\n", "  return array_slice($xs, 0, -1)\n    + array_reduce(array_slice($xs,\
    \ -1), function($acc, $term) {\n      return array_map(function($coeff) {\n  \
    \      return $coeff * $term;\n      }, $acc);\n    }, [ 1 ]);\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThank you, but I'm having trouble understanding how\
    \ this would integrate into my existing code. Can you help explain the code a\
    \ bit more? Thank you.\n<|/ c |>\n<| c |>\nI've expanded my answer, hopefully\
    \ that makes it clearer.\n<|/ c |>\n<| c |>\nThank you, it is really helpful!\
    \ Just a quick question - is it possible to have something like a loop counter\
    \ inside the recursive method?\n<|/ c |>\n<| c |>\nYou certainly could if you\
    \ really wanted to, but I'd just be more comfortable with doing it in a loop if\
    \ you can. If you really want a counter, I'd pass it to the function as a parameter:\
    \ `$x = 1; doDerivative($xs, $x++);` If you really need recursion for whatever\
    \ reason, I'd also just use a loop and call `doDerivative` inside the loop.\n\
    <|/ c |>\n<| c |>\nI see. Thank you again for your help.\n<|/ c |>\n<| a dscore=0\
    \ tags=recursion,php |>\nIt seems that you are looking for recursive functions:\n\
    <code>\n<?php\n", "  $result = array();\n  for ($x = 1; $x <= count($xs); $x++)\
    \ {\n    $result[] = ($xs[$x-1] + ($x * $xs[$x]));\n  }\n  return $result;\n}\n\
    </code>\nHope this helps!\n<|/ a |>\n<| c |>\nThanks for the help! I see you've\
    \ used recursion and I appreciate that, but my question was more along the lines\
    \ of how can I achieve the same result without using recursion. How would you\
    \ do this without recursion?\n<|/ c |>\n<| c |>\nThanks for that code, I understand\
    \ it but I'm having trouble understanding how it works when it loops back through\
    \ the values. For example how would it know that 4 is greater than 3? I assume\
    \ it loops through the function until it reaches the highest value. How does it\
    \ know that 4 is greater than 3 before it starts looping?\n<|/ c |>\n<| c |>\n\
    When it loops back through all the values it calculates the derivative for each\
    \ value.  The highest value is calculated at `6`.  The highest derivative is calculated\
    \ at `12`.  So the loop will go through each value up to the highest and calculate\
    \ the derivative for each value.  As soon as `x = 6` it will calculate 12.  Then\
    \ it will go on and do it for `x = 3` then `x = 2` then `x = 3`.  So each time\
    \ it loops back through and calculates the derivative for the highest value it\
    \ will calculate it for a new value.  The code you posted does this because when\
    \ you get to the highest value it calculates it for the new highest.\n<|/ c |>\n\
    <| a |>\nThe question is a little ambiguous, but I'm assuming you want the derivative\
    \ of a polynomial with one variable. An algorithm to calculate the derivative\
    \ is as follows:\n\nFor every element in the polynomial, calculate the value at\
    \ that element.\nCalculate the first derivative, and add it to the previous element\
    \ (which now represents the value at that element).\nCalculate the second derivative,\
    \ and add it to the previous element (which now represents the value at that element).\n\
    Go to step 2.\n\nThe algorithm is based on the observation that you can calculate\
    \ the derivative of a polynomial by following the derivative, multiplying it by\
    \ itself, plus the first derivative, and then adding the first derivative to the\
    \ second derivative.\nThe code below implements this. It takes an input array\
    \ of doubles, and outputs the array of doubles representing the derivative.\n\
    <code>\ndef derivative(a):\n    i = 0\n    ans = [0]\n    for x in a:\n      \
    \  ans.append(0)\n        i += x\n        ans[i] += ((i+1) * x)\n        ans[i+2]\
    \ += ((i+2)* x * x)\n    return ans\n</code>\n<|/ a tags=python,php,", "    $n\
    \ = count($xs);\n    if (!$n) {\n        return $xs;\n    }\n    $d = $xs[0];\n\
    \    for ($i = 1; $i < $n; ++$i) {\n        $d *= $xs[$i];\n    }\n    return\
    \ $d;\n}", "  $result = [];\n  $xs = [$xs];\n  for ($i = 0; $i < count($xs) -\
    \ 1; $i++) {\n    $result[] = $xs[$i] * $xs[$i - 1];\n  }\n  return array_reverse($result);\n\
    }\n", "  // return empty array if it's not an array\n  if (!is_array($xs)) return\
    \ array();\n\n  // if there's only one point, return an array of one element\n\
    \  if (count($xs) === 1) return array($xs[0]);\n\n  // find first derivative (positive\
    \ sign)\n  $d = $xs[1] - $xs[0];\n\n  // calculate derivative for all other points\n\
    \  $ds = $xs[2] - $d;\n\n  // calculate new first derivative\n  $d0 = $d * $xs[0];\n\
    \n  // create and return new array of derivatives\n  return array($d0 + ($ds /\
    \ $d));\n}\n", "  // $xs must be an array of integers and length 2\n  if ($xs.length\
    \ != 2) {\n    throw new Exception(\"derivative only accepts one argument\");\n\
    \  }\n\n  // Calculate the value of the polynomial at zero.\n  $value = 1;\n \
    \ for ($i = 0; $i < $xs[0]; $i++) {\n    $value *= $xs[1];\n  }\n  $value = $value;\n\
    \n  // Calculate the value of the polynomial at the first element of $xs.\n  for\
    \ ($i = 0; $i < $xs[1]; $i++) {\n    $value *= $xs[0];\n  }\n\n  return array($xs[0]\
    \ - $value, $xs[1] - $value, $value - 1);\n}", "    if (!$xs) {\n        $xs =\
    \ [0];\n    }\n\n    $d = array_shift($xs);\n    $x = array_shift($xs);\n    $d\
    \ = array_shift($xs);\n\n    return $d * pow($x, $xs);\n}\n", "  $n = count($xs);\n\
    \  $dxs = [];\n  for ($i = 0; $i < $n - 1; $i++) {\n    $dxs[] = $xs[$i] * $xs[$i\
    \ + 1];\n  }\n  return $dxs;\n}\n", "  $xs_size = count($xs);\n  if ($xs_size\
    \ < 2) { return [0]; }\n  $deriv = [];\n  for ($i = 0; $i < $xs_size; ++$i) {\n\
    \    $deriv[] = $xs[$i] * derivative($xs);\n  }\n  return $deriv;\n}", "  $ys\
    \ = [];\n  for ($i = 1; $i < count($xs); $i++) {\n    $ys[$i] = $xs[$i];\n  }\n\
    \  array_unshift($ys, 1);\n  return $ys;\n}\n", "  $d = 0;\n  for ($x = 0; $x\
    \ < count($xs); $x++) {\n    $d += $xs[$x];\n  }\n  return [1 - ($d / $this->n);];\n\
    }\n", "  $res = array();\n  $xs = array_reverse($xs);\n  $last = count($xs) -\
    \ 1;\n  for ($i = $last; $i >= 0; $i--) {\n    $res[$i] = $xs[$i] * $xs[$i + 1];\n\
    \  }\n  return $res;\n}\n</code>\nAnd finally the polynomial class:\n<code>\n\
    class Polynomial {\n  private $xs;\n  private $deg;\n  private $coef = array();\n\
    \n  public function __construct($xs) {\n    $this->xs = $xs;\n    $this->deg =\
    \ count($xs);\n    $this->coef = array(0 => 1);\n    for ($i = 0; $i < $this->deg;\
    \ $i++) {\n      $this->coef[$i] = $this->xs[$i];\n    }\n  }\n\n  public function\
    \ add($other) {\n    $res = new Polynomial();\n    $res->deg = count($this->xs);\n\
    \    for ($i = 0; $i < $res->deg; $i++) {\n      $res->coef[$i] = $this->coef[$i]\
    \ + $other->coef[$i];\n    }\n    return $res;\n  }\n\n  public function power($x)\
    \ {\n    $res = new Polynomial();\n    $res->deg = count($this->xs);\n    for\
    \ ($i = 0; $i < $res->deg; $i++) {\n      $res->coef[$i] = $this->coef[$i] * $x;\n\
    \    }\n    return $res;\n  }\n\n  public function derivative() {\n    return\
    \ derivative($this->xs);\n  }\n\n}\n</code>\n<|/ a |>\n<| c |>\nHow would you\
    \ implement it with the new polynomial class? I'm very interested in it.\n<|/\
    \ c |>\n<| c |>\nI've extended the answer.\n<|/ c |>\n<| c |>\nSorry for the super\
    \ late reply, but I got stuck on this. I'm just trying to understand it, but could\
    \ you provide me with the steps for creating the polynomials so I could better\
    \ understand? I'm so confused on how to use that function.\n<|/ c |>\n<| c |>\n\
    I've added some code to the answer. Also I've refactored the `Polynomial` class\
    \ so it would be easier to use.\n<|/ c |>\n<| a |>\nMy solution:\n<code>\nclass\
    \ Polynomial {\n    private $coef = array();\n\n    public function __construct($coef)\
    \ {\n        $this->coef = $coef;\n    }\n\n    public function add($other) {\n\
    \        $new = new self($this->coef);\n        $new->coef = array_merge($this->coef,\
    \ $other->coef);\n        return $new", "  if (!count($xs)) return array(); //\
    \ []\n  $xs = array_reverse($xs); // [x0, x1, x2]\n  $d = $xs[0]; // derivative\
    \ of x1 with respect to x1\n  for ($i = 1; $i < count($xs); $i++) {\n    $d *=\
    \ $xs[$i]; // d^nx1\n  }\n  $d = $d / $xs[0]; // normalize derivative to 1\n \
    \ return array_reverse($d); // [x1/dx1, x2/dx1, x3/dx1]\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis answer was useful, but I had to add the `array_reverse()`\
    \ after `$xs = array_reverse($xs);`, otherwise it gave an error.\n<|/ c |>\n<|\
    \ c |>\nNicely explained. Greatly appreciated.\n<|/ c |>\n<| c |>\nNice and concise\
    \ solution! Thanks!\n<|/ c |>\n<| c |>\nI think there might be a better way to\
    \ calculate this. What if I had a polynomial `y = x^2 + x^3 + x^4` and I wanted\
    \ to calculate the derivative of this polynomial by only using `x^3`? How would\
    \ I go about doing this?\n<|/ c |>\n<| c |>\n`derivative([3, 1, 2, 4, 5])` returns\
    \ `[1, 4, 12, 20]`\n<|/ c |>\n<| a |>\nIf you have your coefficients in an array\
    \ you can do this:\n<code>\n<?php\n$coefficients=array( 2, 1, 2, 0, -2);\n$firstDerivative=array_sum(array_reverse($coefficients))\
    \ / array_shift($coefficients);\necho $firstDerivative;\n</code>\nIf you had a\
    \ polynomial like (6*x^2+4*x+2)/x it would be like this:\n<code>\n<?php\n$coefficients=array(1,2,3,4,5,6,7);\n\
    $firstDerivative=array_sum(array_reverse($coefficients)) / array_shift($coefficients);\n\
    echo $firstDerivative;\n</code>\n<|/ a tags=php,math dscore=5 |>\n<| c |>\nNicely\
    \ explained. Greatly appreciated.\n<|/ c |>\n<| c |>\nNice! This is elegant :)\n\
    <|/ c |>\n<| c |>\nVery nice, simple, understandable, and I wish I had seen this\
    \ solution sooner.\n<|/ c |>\n<| c |>\nThis is good when the degree of the polynomial\
    \ is small and you can use a simple formula. However in some cases I needed to\
    \ calculate the derivatives of polynomials with more than 1000 coefficients and\
    \ this solution was too slow.", "    // Check arguments.\n    if (count($xs) <\
    \ 1) return array(0);\n    $deriv = array(1);\n    foreach ($xs as $x) {\n   \
    \     $deriv[] = $x;\n    }\n    array_pop($deriv);\n    return $deriv;\n}\n",
  "    $d = array_shift($xs);\n    $d2 = array_shift($xs);\n    return array_map(function\
    \ ($x) use ($d, $d2) {\n        return $x * $d2 / $d;\n    }, $xs);\n}\n", " \
    \ if (empty($xs)) {\n    return null;\n  }\n  $result = [];\n  $prev = $xs[0];\n\
    \  for ($i = 1; $i < count($xs); $i++) {\n    $product = $prev;\n    $prev = $xs[$i];\n\
    \    $result[] = $product / ($prev);\n  }\n  return $result;\n}\n", "  if (empty($xs))\
    \ {\n    return array();\n  }\n  $d = array();\n  for ($i = 0; $i < count($xs);\
    \ $i++) {\n    // $d[$i] = x[$i] * $xs[$i];\n    $d[$i] = $xs[$i] * $xs[$i];\n\
    \  }\n  return $d;\n}\n", "  $ys = [];\n  for ($x = 1; $x < count($xs); $x++)\
    \ {\n    $ys[$x] = $xs[$x];\n  }\n  for ($x = count($xs) - 2; $x >= 0; $x--) {\n\
    \    $ys[$x] = $ys[$x+1] * $xs[$x] + $ys[$x];\n  }\n  return $ys;\n}\n", "   \
    \ $y = [];\n    $xs = array_map('floatval', $xs);\n    for ($i = 1; $i < count($xs);\
    \ $i++) {\n        $y[$i] = $xs[$i - 1];\n        for ($j = 1; $j < $i; $j++)\
    \ {\n            $y[$i] *= $xs[$j];\n        }\n    }\n    return $y;\n}\n", " \
    \   return array_map(function($x) {\n        return $x * array_shift($xs);\n \
    \   }, $xs);\n}\n", "  if (!$xs) {\n    return null;\n  }\n  $result = array();\n\
    \  for ($c = count($xs) - 1; $c >= 0; --$c) {\n    $result[$c] = $xs[$c];\n  }\n\
    \  return $result;\n}\n", "    $result = [];\n    foreach ($xs as $i => $x) {\n\
    \        if (isset($result[$i])) {\n            $result[$i] *= $x;\n        }\
    \ else {\n            $result[$i] = $x;\n        }\n    }\n    return $result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nFor a pure PHP version, see Boris.\
    \ If you're using an older version of PHP, it can be implemented using array_reduce().\n\
    For a version that uses array_map() with some clever recursion, see:\n<code>\n\
    $derivative = function($xs) {\n    if (empty($xs)) {\n        return [];\n   \
    \ }\n    $x = array_shift($xs);\n    $result = array_reduce($xs, function($acc,\
    \ $x) use ($acc) {\n        $acc[] = $acc[0] / $x;\n        $acc[0] = $x;\n  \
    \      return $acc;\n    }, array_fill(0, count($xs) - 1, 1));\n    return array_merge([$x],\
    \ $result);\n};\n</code>\n<|/ a tags=math,php,function |>\n<| c |>\nFor a pure\
    \ PHP version, see Boris. If you're using an older version of PHP, it can be implemented\
    \ using array_reduce(). See my answer.\n<|/ c |>\n<| c |>\nYou do realize that\
    \ `array_reduce` isn't even PHP 5.3 compatible? Not even in it's [development\
    \ branch](http://php.net/array_reduce).\n<|/ c |>\n<| c |>\nYes, but since `array_reduce`\
    \ doesn't exist in PHP < 5.3, you either have to use a loop (which I've done in\
    \ my answer) or rewrite array_reduce yourself, which I did in my answer.\n<|/\
    \ c |>\n<| c |>\nSorry, I misunderstood what you meant by \"pure PHP version\"\
    . I'd suggest to update your answer with this new information.\n<|/ c |>\n<| a\
    \ tags=math,php,function |>\nI made this for fun and thought it would be interesting\
    \ to see if it can be done in one line.\nThe function returns a new array with\
    \ the first element being the value of $x and the rest of the elements being the\
    \ partial derivatives.\nIt also assumes that the input is an array of integers\
    \ representing the coefficients of the polynomial.\n<code>", "  $x = array_shift($xs);\n\
    \  $d = [array_shift($xs)];\n\n  while ($x > 0) {\n    $y = $x - 1;\n    foreach\
    \ ($xs as $k => $v) {\n      $d[$k] += $v * pow($y, $k);\n    }\n    $x = floor($x\
    \ / 2);\n  }\n  return $d;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for your\
    \ answer! The code works fine but I can't understand how it works. Could you explain\
    \ it to me please?\n<|/ c |>\n<| c |>\nYou're welcome. I've added some explanations,\
    \ hope it helps. :) Btw, your question has already been answered here: https://stackoverflow.com/questions/2065272/how-to-calculate-derivative-in-php\n\
    <|/ c |>\n<| a dscore=0 tags=php |>\nI solved it this way:\n<code>", "  $n = 0;\n\
    \  foreach ($xs as $x) {\n    $n++;\n  }\n\n  $x0 = array_shift($xs);\n  $d =\
    \ [1 / ($n * $x0)];\n  foreach ($xs as $x) {\n    $d[] = $x * $d[n];\n  }\n\n\
    \  return $d;\n}\n", "  return array_map(function($x) {\n    return $x * $x;\n\
    \  }, $xs);\n}\n", "  // Write your code here.\n}\n", "  return array_reduce($xs,\
    \ function ($acc, $x) {\n    return [$acc[1], $acc[0] * $x + $acc[2]];\n  }, [1]);\n\
    }\n", "    if (count($xs) < 2) {\n        return $xs;\n    }\n\n    $x = array_shift($xs);\n\
    \n    $ys = $xs;\n\n    for ($i = 0; $i < count($xs) - 1; $i++) {\n        $y\
    \ = $ys[$i];\n        $ys[$i] = $x * $y + $ys[$i + 1];\n        $ys[$i + 1] =\
    \ $y;\n    }\n\n    return $ys;\n}", "  $xs = array_values($xs);\n  $n = count($xs);\n\
    \  if ($n === 0) {\n    return array(0);\n  }\n  $d = $xs[0];\n  for ($i = 1;\
    \ $i < $n; $i++) {\n    $d *= $xs[$i];\n  }\n  return $d;\n}\n", "  $xs_length\
    \ = count($xs);\n  $result = [];\n  for($i = 0; $i < $xs_length; $i++) {\n   \
    \ $result[] = $xs[$i] * pow($i, $xs_length);\n  }\n  return $result;\n}\n", " \
    \ $n = count($xs);\n  $dys = array_fill(0, $n - 1, 1);\n  for ($i = 2; $i < $n;\
    \ $i++) {\n    $dys = array_merge($dys, array_fill(0, $i - 1, $xs[$i] * $dys[$i\
    \ - 1]));\n  }\n  return $dys;\n}\n", "  $xs = array_map(function ($x) { return\
    \ $x * $x; }, $xs);\n  $d = [];\n  for ($i = 0; $i < count($xs) - 1; ++$i) {\n\
    \    $d[] = $xs[$i] * $xs[$i + 1];\n  }\n  return $d;\n}", "  $ys = [];\n  foreach\
    \ ($xs as $x) {\n    $ys[] = $x * $x; // $x*x is independent from x\n  }\n  return\
    \ $ys;\n}", "  return array_map(function ($x) {\n    return $x * $x;\n  }, range(1,\
    \ count($xs) - 1));\n}\n", "  return array_map(function ($x) use ($xs) {\n   \
    \ return array_map(function ($y) use ($x) {\n      return pow($y, $x);\n    },\
    \ $xs);\n  }, range(0, count($xs) - 1));\n}\n", "  $results = [];\n  for ($i =\
    \ 0; $i < count($xs); $i++) {\n    $results[] = ($xs[$i] - $xs[$i - 1]) / $xs[$i];\n\
    \  }\n  return $results;\n}\n", "  $result = [];\n  foreach ($xs as $x) {\n  \
    \  $result[] = $x;\n    $result[] = 1;\n  }\n  return array_map(function ($x)\
    \ {\n    return array_sum($x);\n  }, array_chunk($result, 2));\n}\n", "  return\
    \ array_map(function($x) {\n    return ($xs[$x])\n        ? $xs[$x] * derivative($xs)\n\
    \        : 1;\n  }, range(0, count($xs) - 1));\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=math,php |>\nI did this recently, just wanted to share:\n<code>\n$xs\
    \ = [\n    3.171,\n    7.709,\n    14.799,\n    31.488,\n    52.814,\n    98.036,\n\
    \    153.739,\n    297.154,\n    455.665,\n    617.798,\n    833.725,\n    1088.322,\n\
    \    1554.789,\n    2061.347,\n    2555.164,\n    3211.610,\n    4068.296,\n];\n\
    \n$ys = [\n    4.628,\n    10.435,\n    21.105,\n    28.903,\n    37.552,\n  \
    \  43.173,\n    50.662,\n    57.435,\n    65.138,\n    74.777,\n    83.127,\n\
    \    92.014,\n    101.702,\n    112.415,\n    121.104,\n    131.705,\n    141.326,\n\
    \    150.921,\n    159.610,\n    169.309,\n    178.901,\n    188.553,\n    198.196,\n\
    \    208.817,\n    217.501,\n    224.187,\n    233.062,\n];\n\n$polynomial = \"\
    3 + 7*x + 14*x**2 - 7*x**3 + 15*x**4 - 2*x**5 + 23*x**6 - 4*x**7 + 27*x**8 - 8*x**9\
    \ + 33*x**10 + 40*x**11 + 42*x**12 + 42*x**13 + 42*x**14 - 8*x**15 + 33*x**16\
    \ - 7*x**17 + 19*x**18 - 3*x**19 + 5*x**20 - 7*x**21 + 6*x**22 - 5*x**23 - 7*x**24\
    \ - 3*x**25 - 7*x**26 - 3*x**27 - 2*x**28 + 5*x**29 + 2*x**30 - 7*x**31 - 3*x**32\
    \ - 2*x**33 - 4*x**34 - 5*x**35 - 7*x**36 - 3*x**37 - 7*x**38 - ", "  return array_map(\n\
    \      function($x) {\n        return $x * $x;\n      },\n      array_slice($xs,\
    \ 1)\n  );\n}", "  $n = count($xs);\n  if ($n === 0) {\n    return array();\n\
    \  }\n\n  $x = array_shift($xs);\n  $d = array($x);\n\n  for ($i = 1; $i < $n;\
    \ ++$i) {\n    $x = array_shift($xs);\n    $d[] = $x * $i;\n  }\n\n  return $d;\n\
    }\n\n$xs = array(1, 5, 8);\n$y = derivative($xs);\necho json_encode($y); // [4,\
    \ 8, 16]", "  if (!is_array($xs)) $xs = array($xs);\n  if (count($xs) < 2) return\
    \ array();\n  $d = 1;\n  for ($c = count($xs); $c-- > 1; ) {\n    $d *= $xs[--$c];\n\
    \  }\n  $r = array();\n  for ($c = count($xs) - 1; $c--; ) {\n    $r[$c] = $d\
    \ * ($xs[$c] - 1);\n  }\n  return $r;\n}", "  $d = [];\n  foreach ($xs as $x)\
    \ {\n    $d[] = $x;\n  }\n  $d[] = 1;\n  return array_map(\n    function ($x)\
    \ {\n      return $x * $x * ($x - 1);\n    }, $d);\n}", "  $result = array();\n\
    \  $xs[] = 1;\n  $n = count($xs);\n  for ($i = 0; $i < $n - 1; $i++) {\n    $result[$i]\
    \ = $xs[$i] * $result[$i + 1];\n  }\n  return $result;\n}\n", "  $d = 0;\n  foreach\
    \ ($xs as $x) {\n    $d += $x * $x;\n  }\n  return [$d];\n}\n", "  $n = count($xs);\n\
    \  if ($n < 1) return array(); // don't divide by zero\n  $d = array(1);\n  for\
    \ ($i = 0; $i < $n - 1; $i++) {\n    $xx = $xs[$i];\n    $d[$i] = $xx;\n    for\
    \ ($j = $i + 1; $j < $n; $j++) $d[$j] -= $xx * $xs[$j];\n  }\n  return $d;\n}\n",
  "  if (!is_array($xs) || empty($xs))\n    return [];\n\n  // Return derivative of\
    \ polynomial in the same form.\n  // >>> derivative([3, 1, 2, 4, 5])\n  // [1,\
    \ 4, 12, 20]\n  // >>> derivative([1, 2, 3])\n  // [2, 6]\n  array_walk($xs, create_function('&$val',\
    \ '$val *= $xs[0]'));\n  $ds = [];\n  foreach ($xs as $x) {\n    $ds[] = $x;\n\
    \    $ds[] = $x * $xs[2];\n  }\n  return $ds;\n}\n", "  if (!is_array($xs)) die('xs\
    \ must be an array');\n  // return derivative(xs) is like doing [derivative(2),\
    \ derivative(3), ...].\n  return array_map(function ($x) {\n    return $x * array_shift($xs);\n\
    \  }, $xs);\n}\n</code>\n<|/ a |>\n<| c |>\nI really like the idea of using array_map,\
    \ however it fails to take into account the fact that you need to take the second\
    \ derivative of the second derivative.\n<|/ c |>\n<| a tags=math,algorithm,polynomials,php\
    \ |>\nFor a more generic solution:\n<code>\n<?php\n", "  $n = count($xs);\n  //\
    \ use Horner's rule to calculate derivative\n  $dx = array_fill(0, $n, 0);\n \
    \ for ($i = 0; $i < $n - 1; $i++) {\n    $dx[$i + 1] = $xs[$i] + (($xs[$i + 1]\
    \ + $dx[$i]) * $xs[$i]);\n  }\n  return $dx;\n}", "  $xs_length = count($xs);\n\
    \  if (!$xs_length) return [];\n  $ys = [];\n  for ($x = 1; $x <= $xs_length;\
    \ $x++) {\n    $y = $xs[$x - 1] * $x;\n    for ($i = 1; $i < $xs_length; $i++)\
    \ {\n      $ys = array_merge($ys, array_slice($ys, $i, 1));\n      $y += $xs[$i]\
    \ * $i;\n    }\n  }\n  return $ys;\n}\n", "  return array_reduce($xs, function\
    \ ($xs, $x) {\n    return $xs .= $x * $x;\n  });\n}\n", "  $dx = array_fill(0,\
    \ count($xs), 0);\n  for ($i = 0, $n = count($xs) - 1; $i < $n; $i++) {\n    $dx[$i]\
    \ = $xs[$i] + ($xs[$i + 1] * $xs[$i]);\n  }\n  return $dx;\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThanks for the answer! I wonder if there is a way to do\
    \ this using arrays?\n<|/ c |>\n<| c |>\nYou can do it in an array too, but it\
    \ is way more complicated. You need to use recursion to keep track of previous\
    \ sum.\n<|/ c |>\n<| c |>\nThanks for the help and explanation, I've never heard\
    \ of recursion before, could you please explain a bit further what would be the\
    \ best way to do it with an array?\n<|/ c |>\n<| c |>\nI've added an example on\
    \ how to do it with an array now.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n$x = 3;\n\
    $f = $x * $x;\n$g = $f * $x;\n\nvar_dump($x);\nvar_dump($f);\nvar_dump($g);\n\
    </code>\nResult:\n<code>\n$x = 3;\n\n$f = $x * $x;\n\n$x = 3 * 3;\n\n$g = $f *\
    \ $x;\n\n$x = 3 * 3 * 3;\n\n$f = 15\n\n$g = 15 * 15;\n\n$x = 15 * 15 * 15\n</code>\n\
    So what you can do is store the previous value and current value in a variable\
    \ and when the value changes you know what the previous value was.\n<|/ a tags=php,math\
    \ |>\n<| a dscore=0 |>\nYou can store the previous value in a variable. \n<code>\n\
    <?php\n$x = 1;\n$y = 1;\n\nif($x != $y){\n    $prevX = $x;\n    $prevY = $y;\n\
    }\n\n$x = 2;\n\nif($x != $y){\n    $prevX = $x;\n    $prevY = $y;\n}\n</code>\n\
    <|/ a tags=php,math |>\n<| a dscore=0 tags=php,math |>\nYou can try this also.\
    \ \n<code>\n<?php \n    $a = 10;\n    $b = 5;\n    $c = 1;\n    $sum = $a + $b;\n\
    \    $count = 1;\n    while($sum > 0)\n    {\n        $sum = $sum - $c;\n    \
    \    $count++;\n        if($count > 1)\n        {\n            echo $a . \"<br>\"\
    ;\n            $a++;\n            $b++;\n            $c++;\n        }\n      \
    \  else", "  return array_map(function($x) {\n    return $x * $xs[0];\n  }, $xs);\n\
    }\n</code>\nNow for polynomials we can just add them together. Here's a function\
    \ to do that:\n<code>", "  $xs = array_reverse($xs);\n  $result = [];\n  $xs[0]\
    \ = 1;\n  foreach ($xs as $x) {\n    $result[] = $x * $result[-1];\n  }\n  return\
    \ array_reverse($result);\n}", "  $d = $xs[0];\n  for ($i = 1; $i < count($xs);\
    \ $i++) {\n    $d *= $xs[$i];\n  }\n  return $d;\n}", "  $dx = $ys = $y = 0;\n\
    \  $n = count($xs);\n  for ($i = 0; $i < $n; ++$i) {\n    $x      = $xs[$i];\n\
    \    $dx    += $x * $y;\n    $y      = $xs[$n+$i];\n    $ys    += $y * $x;\n \
    \ }\n  return [abs($dx), abs($ys)];\n}\n", "    if (empty($xs)) return [];\n \
    \   $r = $xs[0];\n    for ($i = 1; $i < count($xs); $i++) {\n        $r += $xs[$i]\
    \ * $i;\n    }\n    return [$r];\n}", "  $d = [];\n  foreach ($xs as $x) $d[]\
    \ = 1; // multiply by 1\n  foreach ($xs as $i => $x) $d[$i] *= $x; // multiply\
    \ by x\n  return $d;\n}\n", "  $n = count($xs);\n  if ($n === 0) {\n    throw\
    \ new Exception('Number of terms must be greater than zero.');\n  }\n\n  // Initialize\
    \ and result array\n  $f = array();\n  $f[0] = 1.0;\n  $f[1] = 1.0;\n\n  // Calculate\
    \ all terms using forward differencing\n  for ($i = 2; $i <= $n; $i++) {\n   \
    \ $f[$i] = $f[$i - 1] * $xs[$i];\n  }\n\n  // Calculate and return the derivative\n\
    \  return $f;\n}\n</code>\nNow we can do some testing:\n<code>\n<?php\n", "  $result\
    \ = $xs[0];\n  for ($i = 1; $i < count($xs); $i++) {\n    $result *= $xs[$i];\n\
    \  }\n  return $result;\n}\n</code>\nNow we can get the derivatives of a polynomial\
    \ simply by calling derivative function and pass it the list we got from our equation.\
    \ In our case, we can just pass the list [3, 1, 2, 4, 5] to it and it returns\
    \ the list [1, 4, 12, 20].\n<|/ a tags=python,algorithm,php |>\n<| c |>\nThanks,\
    \ I think this is the best way to do it with python and php right? I actually\
    \ need the algorithm to be in python and php since my client needs both of them\
    \ and he wants to know what he should implement in both since they both have different\
    \ languages.\n<|/ c |>\n<| c |>\nYes, you can use python for both python and php\
    \ if you want.\n<|/ c |>\n<| c |>\nAnd also please mark the answer as correct\
    \ if it helps you. Cheers.\n<|/ c |>\n<| c |>\nHi, please can you explain me how\
    \ can you get your polynomial function? For example your example is 3x1+2x2+4x5\
    \ and you get the derivative using an algorithm and you get the polynomial function\
    \ but this one I cannot. Thanks\n<|/ c |>\n<| c |>\nThe polynomial function is\
    \ simply the sum over all terms\n<|/ c |>\n<| a |>\nI got this one from my friend\
    \ who knows python :) Hope it'll help!\n<code>\ndef poly_diff(p, order):\n   \
    \ \"\"\"\n    Computes the derivative of a polynomial in the specified order.\n\
    \    \"\"\"\n    # Compute coefficients\n    poly = np.poly1d(p)\n    coef = poly.all_coeffs()\n\
    \n    # Compute differentiation\n    deriv = np.zeros(poly.order-1)\n    for n\
    \ in range(poly.order-1):\n        deriv[n] = coef[n+1] - coef[n]\n\n    # Normalize\
    \ differentiation\n    deriv /= poly.all_coeffs()\n\n    # Return polynomial\n\
    \    return poly*deriv\n</code>\n<|/ a dscore=2 tags=python,algorithm,php |>\n\
    <| c |>\nThanks for your help but I need to do this algorithm and I cant use libraries\
    \ except for math. I need to implement this algorithm. :(\n<|/ c |>\n<| a dscore=0\
    \ |>\nThis can be solved in python using sympy. Here is sample code that solves\
    \ your example.\n<code>\nimport sympy as sy\nimport numpy as np\n\nx1 = sy.symbols('x1')\n\
    x2 = sy.symbols('x2')\nx3 = sy.symbols('", "  $dx = 0;\n  foreach ($xs as $x)\
    \ $dx = $dx * $x + $xs[$x];\n  return $dx;\n}\n", "  $x = array_shift($xs);\n\
    \  if (count($xs) == 0) {\n    return array(1);\n  }\n  return array_map(function\
    \ ($ys) use ($x) {\n    return $ys * $x;\n  }, derivative(array_slice($xs, 1)));\n\
    }\n", "  $n = count($xs) - 1;\n  $x = array_pop($xs);\n\n  return array_reduce($xs,\
    \ function($acc, $x) {\n    return $acc + ($x * $x) * ($n--);\n  }, 1);\n}", " \
    \   $d = 0;\n    foreach ($xs as $x) {\n        $d *= $x;\n    }\n    return $d;\n\
    }\n", "    $ys = array_map('pow', array_slice($xs, 1), array_fill(0, count($xs),\
    \ 1));\n    return array_map(\n        function ($x) {\n            return $x\
    \ * array_sum(array_slice($ys, array_search($x, $xs) - 1));\n        },\n    \
    \    $xs\n    );\n}\n</code>\n<|/ a |>\n<| c |>\nthis answer is incomplete. the\
    \ main problem is not the coefficients and exponents, but the fact that one can't\
    \ just derive the polynomial from the coefficients\n<|/ c |>\n<| c |>\n: That's\
    \ a fair point. I'll edit to include this information. The solution is still not\
    \ trivial, but it's better than my proposed solution above.\n<|/ c |>\n<| c |>\n\
    : I've added an example function and some tests for your convenience.\n<|/ c |>\n\
    <| c |>\nyour first code was incorrect - it outputs the wrong result for derivative([3,\
    \ 1, 2, 4, 5])\n<|/ c |>\n<| a tags=polynomials,php,math dscore=4 |>\nSince nobody\
    \ has posted a solution yet I'll post my own\n<code>", "  $ys = array();\n  $ys[]\
    \ = 1;\n  for ($i = 2; $i < count($xs); $i++) {\n    $ys[] = $ys[count($ys) -\
    \ 1] * $xs[$i];\n  }\n  return $ys;\n}", "  // Return derivative of xs.\n  //\
    \ >>> derivative([3, 1, 2, 4, 5])\n  // [1, 4, 12, 20]\n  // >>> derivative([1,\
    \ 2, 3])\n  // [2, 6]\n  if (empty($xs)) {\n    return [];\n  }\n  $d = array_shift($xs);\n\
    \  $r = $d;\n  foreach ($xs as $x) {\n    $r += $x * $d;\n    $d *= $x;\n  }\n\
    \  return $r;\n}", "  $d = [];\n  for ($i = count($xs); $i--;) {\n    $d[] = $xs[$i]\
    \ * $xs[$i];\n  }\n  return $d;\n}\n", "  $d = 0;\n  for ($i = 1, $n = count($xs);\
    \ $i < $n; $i++) {\n    $d += $xs[$i] * $xs[$i - 1];\n  }\n  return $d;\n}\n",
  "  if (empty($xs)) return array();\n\n  $d = array();\n  $d[0] = 1;\n  for ($i =\
    \ 1, $j = count($xs); $j < count($xs); $j++) {\n    $d[$j] *= $xs[$j];\n  }\n\n\
    \  return array_map(function ($x) {\n    return $d[0] * $x;\n  }, $d);\n}\n\n\
    $result = array_map(function ($x, $y) {\n  return $x * $y;\n}, $a, $b);\n</code>\n\
    I hope it helps.\n<|/ a dscore=0 tags=php,multidimensional-array,arrays |>\n<|\
    \ c |>\nI think you should use `array_map` instead of `array_walk` because you're\
    \ doing the calculation on every element while `array_walk` would be doing the\
    \ calculation only once.\n<|/ c |>\n<| c |>\nThanks I didn't know that! I'll fix\
    \ that.\n<|/ c |>\n<| a |>\nYou can try this :\n<code>", "  $ys = array();\n \
    \ $x = $xs[0];\n  $y = 1;\n  for ($i = 1; $i < count($xs); $i++) {\n    $x *=\
    \ $xs[$i];\n    $y += $x;\n    $ys[$i] = $y;\n  }\n  return $ys;\n}\n", "  //\
    \ Return derivatives of the polynomial in the same form.\n  // >>> derivative([3,\
    \ 1, 2, 4, 5])\n  // [1, 4, 12, 20]\n  // >>> derivative([1, 2, 3])\n  // [2,\
    \ 6]\n  if (count($xs) === 0) return array(0);\n  return array_map(function ($x)\
    \ { return $x * $x; }, $xs);\n}\n", "  $ys = array_shift($xs);\n  return array_map(function\
    \ ($x) { return $x * $ys; }, $xs);\n}\n</code>\n<|/ a tags=math,php dscore=1 |>\n\
    <| a dscore=0 tags=math,php |>\nThis is a solution using array_map and array_sum.\
    \ Not sure if it is the most efficient, but I guess it is clear and concise.\n\
    <code>\n<?php", "  return array_map(function ($x) { return $x * $x; }, array_slice($xs,\
    \ 1));\n}\n</code>\n<|/ a tags=php,math dscore=3 |>\n<| c |>\nThis code was very\
    \ helpful. I needed a function to calculate the square root of any number. So\
    \ I used the iterative method and took care of the `0`s, as well as taking the\
    \ `1`s out of the square root by dividing it by it. I then replaced the `pow`\
    \ functions with `sqrt`. This also allows me to input any positive `integer` value\
    \ and it returns the same result. The function `squareroot` is what I used to\
    \ get my `square` function to work and is what I used in my answer. Thank you\
    \ for the help!\n<|/ c |>\n<| a |>\nHere you go\n<code>\n<?php", "  $d = array_shift($xs);\n\
    \  return $d * derivative($xs);\n}\n", "  if (!is_array($xs)) return null;\n \
    \ $n = count($xs);\n  if ($n==0) return null;\n  $d = 0;\n  for ($i=1; $i<$n;\
    \ $i++) {\n    $d += ($xs[$i] - $xs[$i-1])*$xs[$i];\n  }\n  return [$d];\n}",
  "  $result = array();\n  foreach ($xs as $x) {\n    $result[] = $x * $x;\n  }\n\
    \  return $result;\n}\n", "  return array_map(function($x) {\n    return [$x];\n\
    \  }, range(0, count($xs) - 1));\n}\n", "    return array_map(function($x) {\n\
    \        return $x * $x;\n    }, $xs);\n}\n", "  array_unshift($xs, 0);\n  return\
    \ $xs;\n}\n", "  $n = count($xs) - 1;\n  if ($n < 1) {\n    return array();\n\
    \  }\n\n  $xs = array_reverse($xs);\n  $d = array();\n  $x = $xs[0];\n  for ($i\
    \ = 0; $i <= $n; $i++) {\n    if ($i == $n) {\n      $d[] = $x;\n    }\n\n   \
    \ $x *= $xs[$i];\n  }\n\n  return $d;\n}", "  $y = $xs[1];\n  $xs = array_slice($xs,\
    \ 2);\n  $d = $xs[0] + $xs[1] * $y + $xs[2] * pow($y, 2);\n  for ($i = 3; $i <\
    \ count($xs); $i++) {\n    $d += ($xs[$i - 1] * $xs[$i]) * pow(pow($y, 2) - pow($xs[$i\
    \ - 1], 2), 3);\n  }\n  return [$d];\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
