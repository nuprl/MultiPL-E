name: HumanEval_21_rescale_to_unit
language: php
prompt: "<?php\n// Given list of numbers (of at least two elements), apply a linear\
  \ transform to that list,\n// such that the smallest number will become 0 and the\
  \ largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\nfunction rescale_to_unit($numbers) {\n"
tests: "function candidate(...$args) {\n    return rescale_to_unit(...$args);\n}\n\
  \nfunction test(): void {\n    if (candidate(array(2.0, 49.9)) !== array(0.0, 1.0))\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(100.0, 49.9))\
  \ !== array(1.0, 0.0)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(1.0,\
  \ 2.0, 3.0, 4.0, 5.0)) !== array(0.0, 0.25, 0.5, 0.75, 1.0)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(2.0, 1.0, 5.0, 3.0, 4.0)) !== array(0.25,\
  \ 0.0, 1.0, 0.5, 0.75)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(12.0,\
  \ 11.0, 15.0, 13.0, 14.0)) !== array(0.25, 0.0, 1.0, 0.5, 0.75)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["  $sum = 0;\n  for ($i = 0; $i < count($numbers); $i++) {\n    $sum\
    \ += $numbers[$i];\n  }\n  $scale = 1 / $sum;\n  foreach ($numbers as $i => $number)\
    \ {\n    $numbers[$i] = $scale * $number;\n  }\n  return $numbers;\n}\n", "  if\
    \ (!$numbers) {\n    return $numbers;\n  }\n  $min = $numbers[0];\n  $max = $numbers[0];\n\
    \  foreach ($numbers as $number) {\n    if ($min > $number) {\n      $min = $number;\n\
    \    }\n    if ($max < $number) {\n      $max = $number;\n    }\n  }\n  $length\
    \ = count($numbers);\n  foreach ($numbers as $i => $number) {\n    if ($number\
    \ !== 0 && $number !== 1) {\n      $numbers[$i] = $number / $length;\n    }\n\
    \  }\n  return $numbers;\n}\n", "  if (!$numbers) {\n    return array();\n  }\n\
    \  if (count($numbers) < 2) {\n    return array();\n  }\n  $sum = $numbers[0];\n\
    \  for ($i = 1; $i < count($numbers); $i++) {\n    $sum += $numbers[$i];\n  }\n\
    \  $len = count($numbers);\n  for ($i = 0; $i < $len - 1; $i++) {\n    $numbers[$i]\
    \ /= $sum;\n  }\n  return $numbers;\n}\n</code>\nAnd here is the corresponding\
    \ unit tests:\n<code>\nclass RescaleToUnitTest extends PHPUnit_Framework_TestCase\n\
    {\n  /**\n   * testRescaleToUnit\n   */\n  public function testRescaleToUnit()\n\
    \  {\n    $numbers = array(\n      0.0,\n      0.25,\n      0.5,\n      0.75,\n\
    \      1.0,\n    );\n    $expected = array(\n      0.0,\n      0.25,\n      0.5,\n\
    \      0.75,\n      1.0,\n    );\n    $this->assertEquals($expected, rescale_to_unit($numbers));\n\
    \  }\n\n  /**\n   * testRescaleToUnitWithZero\n   */\n  public function testRescaleToUnitWithZero()\n\
    \  {\n    $numbers = array(\n      0.0,\n      0.25,\n      0.5,\n      0.75,\n\
    \      0.0,\n    );\n    $expected = array(\n      0.0,\n      0.25,\n      0.5,\n\
    \      0.75,\n      0.0,\n    );\n    $this->assertEquals($expected, rescale_to_unit($numbers));\n\
    \  }\n\n  /**\n   * testRescaleToUnitWithNegativeNumber\n   */\n  public function\
    \ testRescaleToUnitWithNegativeNumber()\n  {\n    $numbers = array(\n      -2.0,\n\
    \      0.25,\n      0.5,\n      0.75,\n      1.0,\n    );\n    $expected = array(\n\
    \      -1.0,\n      0.25,\n      0.5,\n      0.75,\n      1.0,\n    );\n    $this->assertEquals($expected,\
    \ rescale_to_unit($numbers));\n  }\n}\n</code>\n<|/ a dscore=5 tags=arrays,math,php\
    \ |>\n<| c |>\nVery clever solution!\n<|/ c |>\n<| c |>\nThis is really clever\
    \ and elegant.\n<|/ c |>\n<| c |>\nFor those who don't have the math/statistics\
    \ package or can't use that class, this is a great solution.\n<|/ c |>\n<| c |>\n\
    What about array values that are negative? Ex: array (1,2,-2,-3,-4)\n<|/ c |>\n\
    <| c |>\nThis is actually a ", "  if (!is_array($numbers) || count($numbers) <\
    \ 2) {\n    return $numbers;\n  }\n\n  // Normalize input array so that smaller\
    \ numbers are normalized to 0\n  $min_number = min($numbers);\n  $numbers = array_map('round',\
    \ $numbers);\n  array_walk($numbers, 'array_multiply_by_fraction', $min_number);\n\
    \n  // Normalize input array so that bigger numbers are normalized to 1\n  $max_number\
    \ = max($numbers);\n  array_walk($numbers, 'array_multiply_by_fraction', $max_number);\n\
    \n  return $numbers;\n}\n", "    $min = array_reduce($numbers, function($carry,\
    \ $item) {\n        return $carry > $item ? $carry : $item;\n    });\n    return\
    \ array($min == $numbers[0] ? 0 : ($max - $min) / ($numbers[count($numbers) -\
    \ 1] - $min));\n}", "  $min = array_reduce($numbers, function($min, $el) {\n \
    \   return ($min < $el) ? $min : $el;\n  });\n\n  $max = array_reduce($numbers,\
    \ function($max, $el) {\n    return ($max > $el) ? $max : $el;\n  });\n\n  return\
    \ array_map(function($x) {\n    return ($x - $min) / ($max - $min);\n  }, $numbers);\n\
    }\n", "  if (!is_array($numbers)) {\n    return array();\n  }\n\n  $result = [];\n\
    \  foreach ($numbers as $number) {\n    if (!isset($result[$number])) {\n    \
    \  $result[$number] = 0.0;\n    }\n    $result[$number]++;\n  }\n\n  // We now\
    \ have a list of numbers (the original ones but with the smallest number set to\
    \ 0 and the largest set to 1)\n  // And an associated list of their corresponding\
    \ normalized values\n  return $result;\n}\n\n/**\n * Return true if two lists\
    \ of numbers are of equal length\n * @param $list1\n * @param $list2\n */", " \
    \ // Ensure there are two or more elements\n  if (count($numbers) < 2) {\n   \
    \ return $numbers;\n  }\n\n  $num_a = $numbers[0];\n  $num_b = $numbers[1];\n\n\
    \  // Determine the linear transformation that applies to both lists\n  $transform\
    \ = $num_b / $num_a;\n\n  // Convert the two lists so that they both start from\
    \ 0\n  $numbers[0] = ($num_a / $transform) - 0.5;\n  $numbers[1] = ($num_b / $transform)\
    \ + 0.5;\n\n  return $numbers;\n}\n", "    $smallest = min($numbers);\n    $largest\
    \ = max($numbers);\n\n    $scale = 1.0 / ($largest - $smallest);\n    $result\
    \ =  $smallest * $scale;\n\n    return $result;\n}\n", "  $smallest = $numbers[0];\n\
    \  $largest = $numbers[0];\n  foreach ($numbers as $number) {\n    if ($number\
    \ > $largest) {\n      $largest = $number;\n    } else if ($number < $smallest)\
    \ {\n      $smallest = $number;\n    }\n  }\n  $scale = ($largest - $smallest);\n\
    \  foreach ($numbers as $number) {\n    $numbers[$number] = $number / $scale;\n\
    \  }\n  return $numbers;\n}\n", "  $min_value = min($numbers);\n  $max_value =\
    \ max($numbers);\n  if ($max_value - $min_value < EPSILON) {\n    return $numbers;\n\
    \  }\n  $scale = $max_value - $min_value;\n  return array_map(\n    function($number)\
    \ use($scale) {\n      return $number * $scale;\n    },\n    $numbers\n  );\n\
    }\n", "  $min_val = min($numbers);\n  $max_val = max($numbers);\n  $factor = 1.0\
    \ / ($max_val - $min_val);\n  return array_map(function ($num) use ($factor) {\
    \ return $num * $factor; }, $numbers);\n}\n</code>\n<|/ a tags=arrays,php,normalization\
    \ dscore=1 |>\n<| a tags=arrays,php,normalization |>\n<code>\n$a = array (\n \
    \   'A' =>  2,\n    'B' =>  3,\n    'C' =>  4,\n    'D' =>  5,\n    'E' =>  6,\n\
    \    'F' =>  7,\n    'G' =>  8,\n    'H' =>  9,\n    'I' => 10,\n    'J' => 11,\n\
    \    'K' => 12,\n    'L' => 13,\n    'M' => 14,\n    'N' => 15,\n    'O' => 16,\n\
    \    'P' => 17,\n    'Q' => 18,\n    'R' => 19,\n    'S' => 20,\n    'T' => 21,\n\
    \    'U' => 22,\n    'V' => 23,\n    'W' => 24,\n    'X' => 25,\n    'Y' => 26,\n\
    \    'Z' => 27,\n);\n", "    return array_reduce($numbers, function($carry, $number)\
    \ {\n        return $carry + ($number / $numbers);\n    });\n}\n", "  $sum = 0;\n\
    \  foreach ($numbers as $value) {\n    $sum += $value;\n  }\n  return array_map(function\
    \ ($value) {\n    return $value / $sum;\n  }, $numbers);\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  assert($min < $max);\n  assert($min == 0.0 && $max\
    \ == 1.0);\n\n  $delta = $max - $min;\n  return array_map(function($number) {\
    \ return $number / $delta; }, $numbers);\n}\n", "  ksort($numbers);\n\n  // Sort\
    \ the numbers so largest comes first\n  asort($numbers);\n\n  // Make sure we\
    \ have enough elements\n  $size = count($numbers);\n  assert($size > 0);\n\n \
    \ // Keep track of smallest and largest\n  $smallest = $numbers[0];\n  $largest\
    \ = $numbers[0];\n  foreach ($numbers as $number) {\n    if ($number < $smallest)\
    \ {\n      $smallest = $number;\n    }\n    if ($number > $largest) {\n      $largest\
    \ = $number;\n    }\n  }\n\n  // Get difference between smallest and largest\n\
    \  $difference = $largest - $smallest;\n\n  // Get number of elements to multiply\
    \ the difference by\n  $scale = ($difference == 0) ? 0 : $difference / $largest;\n\
    \  if ($scale == 0) {\n    return array($smallest, $largest);\n  }\n\n  // Get\
    \ smallest and largest elements scaled down\n  $scaledown = array();\n  $scaledown[0]\
    \ = round($smallest * $scale);\n  for ($i = 1; $i < $size; $i++) {\n    $scaledown[$i]\
    \ = round($scaledown[$i - 1] + ($numbers[$i - 1] - $scaledown[$i - 1]) / $scale);\n\
    \  }\n\n  return $scaledown;\n}", "    return array_map(function ($value) {\n\
    \        return $value / min(1.0, max(0.0, $value));\n    }, $numbers);\n}\n</code>\n\
    Here I've used array_map to apply the function to the input array. In your case\
    \ it could be something like this:\n<code>", "    $scale = min($numbers);\n  \
    \  if ($scale == 0)\n        return array(0);\n    $lowest_number = min(array_keys($numbers));\n\
    \    $numbers[$lowest_number] = 1;\n    $result = array();\n    foreach ($numbers\
    \ as $number => $fraction) {\n        $result[] = $number / $scale;\n    }\n \
    \   return $result;\n}\n</code>\n<|/ a tags=php,math,javascript,algorithm,random\
    \ dscore=2 |>\n<| c |>\nThis could easily lead to rounding errors. If the smallest\
    \ number is 1, and the largest is 10, this approach will yield [0, 0.125, 0.375,\
    \ 0.625, 0.875] when it should be [0, 0.125, 0.375, 0.625, 0.84375]\n<|/ c |>\n\
    <| c |>\n: Yes, you're right, but that doesn't seem to matter for the OP's case\
    \ (although if it does, one could just fix the algorithm to not produce such numbers)\n\
    <|/ c |>\n<| c |>\nIt can matter for a lot of applications, like image filters\
    \ in Photoshop, which are very sensitive to floating point imprecision.\n<|/ c\
    \ |>\n<| c |>\n: Yes, I understand that. Still, I don't see a way to remedy it\
    \ short of introducing new numbers or introducing a new transformation.\n<|/ c\
    \ |>\n<| c |>\nThe first line of your code reads: `echo implode(',',array_map(function($x){\
    \ return sprintf(\"%0.2f\",$x);},rescale_to_unit(array_map('bcdiv',array(1,$numbers),array(0,$scale)))));`\n\
    <|/ c |>\n<| a tags=php,math,javascript,algorithm,random dscore=1 |>\nI ran into\
    \ this problem and I believe I came up with my own solution.  I wanted to take\
    \ a percentage of a random number and make it a percentage of the original number.\
    \  So, say you have the numbers 1,2,3,4 and you wanted 40%.  Then, I would first\
    \ choose a random number between 0 and 4 and divide it by 40 (that way it would\
    \ be 40% of the original number).\nThen, I would multiply that number by the original\
    \ number (40% of the original number).  So say I chose a random number between\
    \ 0 and 4 and divide it by 40 (that way it would be 40% of the original number).\
    \  Then, I multiply that number by 1.  So 40% of the original number would be\
    \ 40 * 1.  You would then take that number and divide it by 40 to get the 40%\
    \ of the original number.  So 40 * 1 = 4 and divide that number by 40 to ", " \
    \ if (count($numbers) <= 1) {\n    return $numbers;\n  }\n  $min = array_reduce($numbers,\
    \ function ($a, $b) {\n    return min($a, $b);\n  });\n  $max = array_reduce($numbers,\
    \ function ($a, $b) {\n    return max($a, $b);\n  });\n  $range = max(1, $max\
    \ - $min);\n  $new_numbers = array();\n  foreach ($numbers as $i => $num) {\n\
    \    $new_numbers[$i] = round(($num - $min) / $range * $range);\n  }\n  return\
    \ $new_numbers;\n}", "    $min = min($numbers);\n    $max = max($numbers);\n \
    \   if ($min == $max) {\n        return $numbers;\n    }\n    return array(\n\
    \        $min == 0 ? $max / $min : $min / ($max - $min),\n        $min == 0 ?\
    \ 0 : $max / $min,\n        $min == 0 ? 1 : 0,\n        $min == 0 ? $max / $min\
    \ : 0,\n        $max / ($max - $min),\n    );\n}\n", "  return array_map(function\
    \ ($number) {\n    return $number / (count($numbers) == 1 ? 1 : count($numbers));\n\
    \  }, $numbers);\n}\n\n/**\n * Takes a column of numbers and returns a list of\
    \ unique numbers.\n *\n * This function is useful when trying to figure out what\
    \ columns are needed to\n * generate a set of records to create a new column with,\
    \ given an array of existing\n * columns.\n *\n * In the example below, column\
    \ \"name\" has already been created from a \"name\" column in\n * record 0, and\
    \ column \"age\" has been generated from existing columns (including \"name\"\
    )\n * in record 1:\n *\n * ```\n * [\n *   0 => ['name' => 'Halle', 'age' => '18'],\n\
    \ *   1 => ['name' => 'Halle', 'age' => '21'],\n *   2 => ['name' => 'Halle',\
    \ 'age' => '19'],\n *   3 => ['name' => 'Halle', 'age' => '20'],\n *   4 => ['name'\
    \ => 'Halle', 'age' => '22'],\n *   5 => ['name' => 'Malle', 'age' => '18'],\n\
    \ *   6 => ['name' => 'Malle', 'age' => '20'],\n *   7 => ['name' => 'Malle',\
    \ 'age' => '22'],\n * ]\n * ```\n *\n * If the input array is sorted by the key,\
    \ then this function is idempotent.\n *\n * @param array $data An array of data\
    \ to use for determining the unique set of values.\n *   Each element of the array\
    \ is cast to a string for use as a column value.\n *   The array keys are preserved\
    \ as-is.\n * @param string $key The key to sort the array on.\n * @return array\
    \ A list of unique values from $data.\n */", "  $minimum = min($numbers);\n  $maximum\
    \ = max($numbers);\n\n  $scale = 1.0 / ($maximum - $minimum);\n  return array_map('round',\
    \ $numbers);\n}", "  // Find min and max values\n  $min = array_reduce($numbers,\
    \ function($x, $y) { return min($x, $y); });\n  $max = array_reduce($numbers,\
    \ function($x, $y) { return max($x, $y); });\n\n  // Apply transformation\n  $scaled\
    \ = [];\n  for ($i = $min; $i <= $max; $i++) {\n    $scaled[] = ($i - $min) /\
    \ ($max - $min);\n  }\n\n  // Apply reverse transformation to ensure numbers are\
    \ between 0 and 1\n  return array_map(\n    function($x) use ($max) { return $x\
    \ * $max + $min; },\n    $scaled\n  );\n}\n</code>\n<|/ a tags=php,arrays |>\n\
    <| c |>\nI like the way you thought about it. However, when I run this I get the\
    \ following output: `Array ( [0] => Array ( [0] => 0 [1] => 0.25 [2] => 0.5 [3]\
    \ => 0.75 [4] => 1 ) [1] => Array ( [0] => 1 [1] => 1 [2] => 1 [3] => 1 [4] =>\
    \ 1 ) [2] => Array ( [0] => 0.25 [1] => 0.75 [2] => 1 [3] => 1 [4] => 1 ) [3]\
    \ => Array ( [0] => 0 [1] => 0.25 [2] => 0.5 [3] => 0.75 [4] => 1 ) [4] => Array\
    \ ( [0] => 1 [1] => 1 [2] => 1 [3] => 1 [4] => 1 ) [5] => Array ( [0] => 0.25\
    \ [1] => 0.75 [2] => 1 [3] => 1 [4] => 1 ) [6] => Array ( [0] => 0 [1] => 0.25\
    \ [2] => 0.5 [3] => 0.75 [4] => 1 ) [7] => Array ( [0] => 1 [1] => 1 [2] => 1\
    \ [3] => 1 [4] => 1 ) [8] => Array ( [0] => 0.25 [1] => 0.75 [2] => 1 [3] => 1\
    \ [4] => 1 ) [9] => Array ( [0] => 0 [1] => 0.25 [2] => 0.5 [3] => 0.75 [4] =>\
    \ 1 ) )`\n<|/ c |>\n<| c |>\nIt seems to be working for me - see http://ideone.com/iG5r0U\
    \  ... are you sure you got the right input? I used the example array in my answer.\
    \ Maybe try it on a copy of it to be sure?\n<|/ c |>\n<| c |>\nThis did it! I\
    \ must have had a typo that kept it returning the full array. Thanks a ton for\
    \ the help!\n<|/ c |>\n<| c |>\nNo worries. I made a mistake in my last example.\
    \ It works with the `rescale_to_unit` function I gave, but doesn't with the one ",
  "  if (empty($numbers)) { return array(); }\n  sort($numbers);\n  $max = array_pop($numbers);\n\
    \  $min = array_pop($numbers);\n  if (!$max) { return array(0); }\n  return array_map(function($value)\
    \ use ($max, $min) { return $value / ($max - $min); }, $numbers);\n}\n", "   \
    \ $min = min($numbers);\n    $max = max($numbers);\n    return array_map(function\
    \ ($value) use ($min, $max) {\n        return $value / $max - $min;\n    }, $numbers);\n\
    }\n", "    // First calculate the minimum and maximum values\n    list($min, $max)\
    \ = $numbers;\n\n    // Now rescale all numbers to [0,1] using the min-max values\n\
    \    $scale = 1 / ($max - $min);\n    foreach ($numbers as $i => $num) {\n   \
    \     $numbers[$i] = $num * $scale;\n    }\n\n    return $numbers;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=php |>\nI needed this functionality to generate random\
    \ points for a map of points (the map was a world map) in a game, I needed a function\
    \ to generate a random point within the bounds of the map as I couldn't use a\
    \ grid because there would be too many points within the bounds and it would affect\
    \ the map\nI ended up having to do the following \n<code>", "    if (count($numbers)\
    \ < 2) {\n        return $numbers;\n    }\n\n    // Calculate min and max values\n\
    \    $min = min($numbers);\n    $max = max($numbers);\n    if ($min === $max)\
    \ {\n        return [$min / 2, $min / 2];\n    }\n\n    // Normalize the numbers\n\
    \    $results = [];\n    for ($i = 0; $i < count($numbers); $i++) {\n        if\
    \ ($numbers[$i] === $min) {\n            $results[$i] = 0;\n        } else {\n\
    \            $results[$i] = $numbers[$i] / $max;\n        }\n    }\n\n    return\
    \ $results;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. I'll check\
    \ this in a minute, and mark your answer if it works for me. Just a side note:\
    \ I actually found a way to do it with array_map, and I'm posting the code as\
    \ an answer.\n<|/ c |>\n<| c |>\nThanks for the update.  I like your use of `array_map()`\
    \ for this.  I added a version using `array_reduce()` which works just as well\
    \ here.\n<|/ c |>\n<| c |>\nOh wow, thank you! That works way better! I didn't\
    \ know this was possible with `array_map` because I've never used it before today.\
    \ I'll have to try your solution and compare the performance.\n<|/ c |>\n<| a\
    \ |>\n<code>\n$nums = array(1,2,3,4,5);\n$nums = array_map('divide', $nums);\n\
    print_r($nums);", "    $smallest  = min($numbers);\n    $largest   = max($numbers);\n\
    \    $new_numbers = array();\n    foreach ($numbers as $number) {\n        $new_numbers[]\
    \ = $number - $smallest;\n    }\n    array_multisort($new_numbers);\n    return\
    \ $new_numbers;\n}", "  // First, sort the list\n  usort($numbers, 'cmp');\n \
    \ // If there are less than two elements, there's no need to continue\n  if(count($numbers)\
    \ <= 2) {\n    return $numbers;\n  }\n  // We take the first two\n  $smaller =\
    \ array_slice($numbers, 0, 1);\n  $larger = array_slice($numbers, 1);\n  // Get\
    \ the intersection between the two sorted lists\n  $units = array_intersect($smaller,\
    \ $larger);\n  // Now subtract the smaller list from the larger list\n  return\
    \ array_map(function($value) {\n    return $value - array_shift($units);\n  },\
    \ $numbers);\n}", "    $min = min($numbers);\n    $max = max($numbers);\n    return\
    \ array($min * 1., $max * 1.);\n}\n", "  sort($numbers);\n  $min = reset($numbers);\n\
    \  usort($numbers, '_cmp');\n  array_pop($numbers);\n  $max = end($numbers);\n\
    \  $scale = ($max - $min) / (count($numbers) - 1);\n  for ($i = 0; $i < count($numbers)\
    \ - 1; $i++) {\n    $numbers[$i] -= $min;\n    $numbers[$i] /= $scale;\n  }\n\
    \  return $numbers;\n}\n\n", "    $min = min($numbers);\n    $max = max($numbers);\n\
    \    $range = max($max - $min);\n    return array_map(function ($num) use ($min,\
    \ $max, $range) {\n        return ($num - $min) / $range;\n    }, $numbers);\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  return array_map(function($x)\
    \ {\n    return $x - $min / ($max - $min);\n  }, $numbers);\n}\n", "    $max =\
    \ max($numbers);\n    $min = min($numbers);\n    $range = array_map('min', $numbers);\n\
    \n    return array_map(function($value) use($min, $max, $range) {\n        return\
    \ ($value - $min) / ($max - $min) * ($range[1] - $range[0]) + $range[0];\n   \
    \ }, $numbers);\n}\n", "  return array_map(function ($x) {\n    return $x / min(max($x,\
    \ 1), 0);\n  }, $numbers);\n}\n</code>\n<|/ a dscore=1 tags=php,arrays |>\n<|\
    \ c |>\nI'm having trouble implementing your second solution. I'm not quite sure\
    \ what to do with the `$min_max` variable. How does it apply to the array you\
    \ propose?\n<|/ c |>\n<| c |>\n`array_map` function accepts an array and an optional\
    \ callback function. As you can see from my answer above, it uses `array_filter`\
    \ to find the minimum and maximum value for each element. Then the `array_map`\
    \ function multiplies each element by the minimum and maximum value found. So\
    \ for `[1.0, 2.0, 3.0, 4.0, 5.0]` the minimum is `1` and the maximum is `5`. The\
    \ `array_map` function then multiplies each element in the array by the minimum\
    \ and maximum value found. Hence we get `[0.0, 0.25, 0.5, 0.75, 1.0]` as the output.\n\
    <|/ c |>\n<| c |>\nAh I see. Thank you for your help!\n<|/ c |>\n<| c |>\nYou're\
    \ welcome :) Let me know if there are any questions :)\n<|/ c |>\n<| a tags=php,arrays\
    \ dscore=1 |>\nFirst of all, thank you for the question!\nI think you can use\
    \ array_reduce to achieve this easily:\n<code>", "    $sum = array_sum($numbers);\n\
    \    if ($sum < 1) {\n        throw new \\LogicException('No numbers given to\
    \ rescale_to_unit');\n    }\n\n    return array_map(function ($number) {\n   \
    \     return $number / $sum;\n    }, $numbers);\n}\n", "  if (!is_array($numbers))\
    \ {\n    throw new InvalidArgumentException('Expected an array');\n  }\n  list($minimum,\
    \ $maximum) = array_pad($numbers, 2, 0);\n  $difference = $maximum - $minimum;\n\
    \  if ($difference == 0.0) {\n    return $numbers;\n  }\n  return array($minimum,\
    \ $maximum / $difference);\n}\n", "    $min = $numbers[0];\n    $max = min($numbers);\n\
    \    foreach ($numbers as $n) {\n        $n = ($n - $min) / ($max - $min);\n \
    \       $numbers[$i] = $n;\n    }\n    return $numbers;\n}\n", "  $range = array_diff(range(0,count($numbers)),\
    \ array_fill(0, count($numbers), 0));\n  $min_val = array_shift($range);\n  $max_val\
    \ = array_pop($range);\n  $scale = max($max_val - $min_val, $min_val - 0);\n \
    \ $output = [];\n  foreach ($numbers as $k => $v) {\n    $output[$k] = round($v\
    \ * $scale) / $scale;\n  }\n  return $output;\n}\n", "  // Get maximum and minimum\n\
    \  $max_value = max($numbers);\n  $min_value = min($numbers);\n\n  // Apply transformation\n\
    \  $numbers = array_map(function ($number) use ($min_value, $max_value) {\n  \
    \  return round(($number - $min_value) / ($max_value - $min_value));\n  }, $numbers);\n\
    \n  // Return rescaled list\n  return $numbers;\n}\n</code>\nIn case you need\
    \ to work with decimals as well (which is quite rare), you can use round() instead.\
    \ E.g.:\n<code>", "  $max = max($numbers);\n  $min = min($numbers);\n  $factor\
    \ = 100.0 / max($max - $min, $max);\n  $numbers = array_map(function ($value)\
    \ use ($factor) {\n    return $value * $factor;\n  }, $numbers);\n  return $numbers;\n\
    }\n", "  array_pop($numbers);\n  sort($numbers);\n  return array_map(function($x)\
    \ {\n    return ($x - $x[0]) / $x[1];\n  }, $numbers);\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  $delta = round($max - $min);\n  if ($delta == 0.0)\
    \ {\n    return array($min, $max);\n  }\n  $factor = ($delta / $max);\n  return\
    \ array(0, $min + ($factor * $numbers));\n}\n", "\t$min = min($numbers);\n\t$max\
    \ = max($numbers);\n\t$min = min($min, $max);\n\t$max = max($min, $max);\n\treturn\
    \ (array_map(function ($number) { return $number / $max; }, $numbers));\n}\n\n\
    /**\n * Return the largest value of a list\n *\n * @param array $items\n * @return\
    \ float\n */", "  $length = count($numbers);\n  array_pop($numbers);\n  array_pop($numbers);\n\
    \  return array_map('intdiv', $numbers, array_fill(0, $length, 0));\n}\n", " \
    \ $sum = array_sum($numbers);\n  $total_sum = 0;\n  foreach ($numbers as $number)\
    \ {\n    $total_sum += $number;\n  }\n  return array_map(function ($number) use\
    \ ($sum, $total_sum) {\n    return $sum / $total_sum * $number;\n  }, $numbers);\n\
    }\n", "    if (count($numbers) < 2) {\n        return $numbers;\n    }\n    $average\
    \ = array_sum($numbers) / count($numbers);\n    $magnitude = 0;\n    foreach ($numbers\
    \ as $number) {\n        $magnitude += pow($number, 2);\n    }\n    $magnitude\
    \ = sqrt($magnitude);\n    $rescaled = [];\n    foreach ($numbers as $number)\
    \ {\n        $rescaled[] = $number / $magnitude;\n    }\n    return $rescaled;\n\
    }\n</code>\n<|/ a tags=php,arrays |>\n<| c |>\nI think he is looking for something\
    \ that can take an array of values like 1,2,3,4,5 and return an array of values\
    \ like 0,0.25,0.5,0.75,1\n<|/ c |>\n<| c |>\nI guess the OP was just looking to\
    \ quickly scale a small array to a larger array. It could just as easily have\
    \ been a random list of numbers.\n<|/ c |>\n<| c |>\nI understand that, but I\
    \ think he is looking for a way to scale a large array to a small array. The scale\
    \ method he posted takes two arrays, where as he stated he wanted something that\
    \ can take an array of values like 1,2,3,4,5 and return an array of values like\
    \ 0,0.25,0.5,0.75,1.\n<|/ c |>\n<| c |>\nI didn't think you could multiply a number\
    \ by itself, but that does work. Thanks!\n<|/ c |>\n<| c |>\nIf anyone else wonders\
    \ why the method you posted was so slow with large arrays, check out this thread\
    \ on SO. https://stackoverflow.com/questions/4944956/why-are-php-foreach-loops-so-slow\n\
    <|/ c |>\n<| a |>\n<code>\n$numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30];\n\
    $numbers = array_map(\"round\", $numbers);\n$numbers = array_filter($numbers);\n\
    $numbers = array_unique($numbers);\n$numbers = array_pad($numbers, count($numbers)/2);\n\
    $numbers = array_map(function($v){return 1/$v;}, $numbers);\n</code>\n<|/ a tags=php,arrays\
    \ dscore=4 |>\n<| c |>\nWhy `array_map(\"round\", $numbers);`? The numbers in\
    \ `$numbers` are already integers and so won't be rounded.\n<|/ c |>\n<| c |>\n\
    I know, but I used `round()` for demonstration purposes, and a lot of people use\
    \ `intval()", "  $num_unit = 0.0;\n  $total_num = 0.0;\n  for ($i = 0; $i < count($numbers);\
    \ $i++) {\n    $total_num += $numbers[$i];\n    if ($numbers[$i] > 0) {\n    \
    \  $num_unit += $total_num / $numbers[$i];\n      $total_num = 0;\n    }\n  }\n\
    \  for ($i = 0; $i < count($numbers); $i++) {\n    $numbers[$i] /= $num_unit;\n\
    \  }\n  return $numbers;\n}", "  // Sort the list\n  sort($numbers);\n\n  $max\
    \ = array_pop($numbers);\n  $min = array_pop($numbers);\n\n  // Find the smallest\
    \ and largest numbers to avoid divide by zero\n  foreach ($numbers as $n) {\n\
    \    $min = min($min, $n);\n    $max = max($max, $n);\n  }\n\n  $scale = 1.0 /\
    \ max($max - $min, 0.00000001);\n  $new_numbers = array();\n  foreach ($numbers\
    \ as $n) {\n    $new_numbers[] = $n * $scale;\n  }\n\n  return $new_numbers;\n\
    }\n</code>\n<|/ a dscore=2 tags=php |>\n<| a tags=php |>\nThis function works\
    \ perfectly for me.\n<code>", "  $max_value = max($numbers);\n  $smallest_value\
    \ = min($numbers);\n  $min_value = min($numbers);\n  foreach ($numbers as &$value)\
    \ {\n    $value -= $min_value;\n    if ($value == 0) {\n      $value = 0.0;\n\
    \    }\n  }\n  $max_value -= $min_value;\n  $units = [];\n  foreach ($numbers\
    \ as $value) {\n    if ($value != 0) {\n      $units[] = $value / $max_value;\n\
    \    } else {\n      $units[] = 0.0;\n    }\n  }\n  return $units;\n}\n", "  $minimum\
    \ = min($numbers);\n  $maximum = max($numbers);\n\n  // Return an empty array\
    \ if there are no valid numbers\n  if ($maximum - $minimum == 0) {\n    return\
    \ array();\n  }\n\n  // Divide all numbers by their range\n  $scale = ($maximum\
    \ - $minimum);\n  foreach ($numbers as $number) {\n    $numbers[$number] = $number\
    \ / $scale;\n  }\n\n  return $numbers;\n}\n", "    // Get min and max values\n\
    \    $max_value  = $numbers[0];\n    $min_value  = $numbers[0];\n    $n = count($numbers);\n\
    \n    for($i=1; $i < $n; $i++) {\n        if($numbers[$i] > $max_value) {\n  \
    \          $max_value  = $numbers[$i];\n        } elseif($numbers[$i] < $min_value)\
    \ {\n            $min_value  = $numbers[$i];\n        }\n    }\n\n    // Return\
    \ array\n    return array_map(function($number) {\n        return $number - $min_value;\n\
    \    }, array_slice($numbers, 0, -1));\n}\n", "  $min_number = min($numbers);\n\
    \  $max_number = max($numbers);\n  return array_map(function ($n) {\n    return\
    \ round($n / $max_number * $min_number);\n  }, $numbers);\n}\n", "    if (count($numbers)\
    \ < 2) {\n        return $numbers;\n    }\n\n    // Sort the list\n    sort($numbers);\n\
    \n    // Get the min/max\n    $min = array_shift($numbers);\n    $max = array_pop($numbers);\n\
    \n    // Compute differences between the min and the max\n    $diff = $max - $min;\n\
    \n    // If there are no differences, just return the list\n    if ($diff ===\
    \ 0) {\n        return $numbers;\n    }\n\n    // Normalize all the elements in\
    \ the list\n    $numbers -= $min;\n\n    // Scale the list to have a maximum difference\
    \ of 1\n    $numbers /= $diff;\n\n    // Normalize the list again so that it becomes\
    \ a simple linear list\n    $numbers -= $min;\n\n    return $numbers;\n}\n</code>\n\
    <|/ a dscore=3 tags=php,math |>\n<| c |>\nThis worked for me but I had to subtract\
    \ $min in the end like so `$numbers -= $min;`\n<|/ c |>\n<| a tags=php,math |>\n\
    The only thing that worked for me was to invert the number by dividing it with\
    \ its maximum, than invert it again\n<code>\n$x = -( 1 / max($numbers) );\n$x\
    \ = 1 / $x;\n$x = 1 / $x;\n</code>\n<|/ a dscore=3 |>\n<| a |>\nI'm late to the\
    \ party, but I'm surprised no one has mentioned the obvious: simply multiply the\
    \ numbers by the inverse of their ranges.\nIf your range is 0 to 1, multiply the\
    \ numbers by their ranges:\n<code>\n$numbers = array(0.5, 1.0, 2.0);\n$numbers\
    \ = $numbers * 0.5;\n$numbers = $numbers * 1.0;\n$numbers = $numbers * 2.0;\n\n\
    var_dump($numbers); // [0.0, 0.5, 1.0]\n</code>\n<|/ a tags=php,math dscore=3\
    \ |>\n<| a dscore=3 |>\nI wrote a function to rescale numbers between 0 and 1\
    \ and back again.\n<code>\n<?php", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \  $diff = $max - $min;\n  $offset = round(($diff / 2));\n  $multiplier = $diff\
    \ / max($max - $offset, $min);\n  return array_map(function ($number) {\n    return\
    \ round(($number - $min) * $multiplier) + $offset;\n  }, $numbers);\n}\n</code>\n\
    <|/ a dscore=0 tags=algorithm,php |>\n<| a dscore=0 |>\nThe solution is simple:\n\
    <code>", "    $smallest = min(array_map('absval', $numbers));\n    $largest =\
    \ max(array_map('absval', $numbers));\n    $diff = $largest - $smallest;\n\n \
    \   return $diff ? array_map(function ($number) {\n        return $number / $diff;\n\
    \    }, $numbers) : $numbers;\n}\n", "    if (count($numbers) < 2) {\n       \
    \ return $numbers;\n    }\n\n    // Find the minimum and maximum values\n    $min\
    \ = min($numbers);\n    $max = max($numbers);\n\n    // Find the scale by dividing\
    \ the largest number in the list by the smallest one\n    $scale = 1 / ($max -\
    \ $min);\n\n    // Scale each number in the list\n    foreach ($numbers as $number)\
    \ {\n        $number *= $scale;\n    }\n\n    return $numbers;\n}\n", "  list($min,\
    \ $max) = array_pad(array_map('minmax', $numbers), 2);\n  return $max - $min;\n\
    }\n\n/**\n * Returns true if the given numbers are equal within a tolerance.\n\
    \ * @param float $a The first number in the comparison.\n * @param float $b the\
    \ second number in the comparison.\n * @param float $tolerance The tolerance.\n\
    \ * @return bool True if $a and $b are within the tolerance.\n */", "    $min\
    \ = min($numbers);\n    $max = max($numbers);\n\n    return array_map(function($number)\
    \ {\n        return $number / $max - $min;\n    }, $numbers);\n}\n", "  $min_val\
    \ = min($numbers);\n  $max_val = max($numbers);\n\n  $min_val_rescaled = min($numbers,\
    \ function() use ($min_val) {\n    return $min_val - 1;\n  });\n  $max_val_rescaled\
    \ = max($numbers, function() use ($max_val) {\n    return $max_val + 1;\n  });\n\
    \n  return array_map(\n    function ($value) use ($min_val_rescaled, $max_val_rescaled)\
    \ {\n      return $min_val_rescaled + ($value - $min_val) / ($max_val_rescaled\
    \ - $min_val_rescaled) * ($max_val - $min_val);\n    },\n    $numbers\n  );\n\
    }\n", "  $sum = 0;\n  $len = count($numbers);\n  for ($i = 0; $i < $len; ++$i)\
    \ {\n    $sum += $numbers[$i];\n  }\n  $sum *= 1.0 / $len;\n  for ($i = 0; $i\
    \ < $len; ++$i) {\n    $numbers[$i] += $sum;\n  }\n  return $numbers;\n}\n", " \
    \ if ($numbers == null) return null;\n  if (count($numbers) < 2) return $numbers;\n\
    \  if (count($numbers) == 2) return [$numbers[0] / $numbers[1]];\n  $min = min($numbers);\n\
    \  $max = max($numbers);\n  $min = $min == 0 ? 0.000001 : min($numbers);\n  $max\
    \ = $max == 0 ? 0.000001 : max($numbers);\n  return [$min / $max, $max / $min];\n\
    }\n</code>\n<|/ a tags=arrays,php,math dscore=1 |>\n<| a dscore=1 |>\nFor this\
    \ kind of work I prefer to work with arrays. You don't have to handle all edge-cases\
    \ and you can easily change the number of items or the unit. \nYou can do something\
    \ like this.\n<code>\n<?php\n$numbers = [1,2,3,4,5];\n\n$min = min(array_filter($numbers,\
    \ function($v){return $v>0;}));\n$max = max(array_filter($numbers, function($v){return\
    \ $v>0;}));\n\n$numbers = array_map(function($v) use ($min, $max){return ($v-$min)/(1-($max-$min));},\
    \ $numbers);\n\nvar_dump($numbers);\n</code>\nWorking example\n<|/ a tags=arrays,php,math\
    \ |>\n<| a dscore=1 |>\nI like the idea of using the array_map function. Here's\
    \ my solution:\n<code>\n<?php", "    $min = array_reduce($numbers, function($min,\
    \ $x) {\n        return min($min, $x);\n    });\n    $max = array_reduce($numbers,\
    \ function($max, $x) {\n        return max($max, $x);\n    });\n    return array_map(function($x)\
    \ {\n        return (1.0 - (($x - $min) / ($max - $min))) * ($max - $min);\n \
    \   }, $numbers);\n}\n", "    sort($numbers);\n    return array_map(function($a)\
    \ {\n        return ($a - array_shift($numbers)) / array_shift($numbers);\n  \
    \  }, $numbers);\n}\n</code>\n<|/ a |>\n<| c |>\nI haven't tested this but it\
    \ looks like it should work. I'll let you know when I do.\n<|/ c |>\n<| c |>\n\
    I ended up doing something similar to this, but it seems a bit convoluted. Thanks\
    \ for answering though!\n<|/ c |>\n<| c |>\nThis answer does not work. `array_map`\
    \ does not sort the array before applying the function provided as parameter.\
    \ The array must already be sorted in order to apply the provided function.\n\
    <|/ c |>\n<| a dscore=2 |>\nI suggest using array_map function with closure, \n\
    <code>", "    if (!$numbers) {\n        return [];\n    }\n    $min_number = null;\n\
    \    $max_number = null;\n    foreach ($numbers as $number) {\n        if ($min_number\
    \ === null || $min_number > $number) {\n            $min_number = $number;\n \
    \       }\n        if ($max_number === null || $max_number < $number) {\n    \
    \        $max_number = $number;\n        }\n    }\n    if ($max_number === $min_number)\
    \ {\n        return [$min_number];\n    }\n    $scale = 1.0 / ($max_number - $min_number);\n\
    \    $result = array();\n    foreach ($numbers as $number) {\n        $result[]\
    \ = $scale * $number;\n    }\n    return $result;\n}\n", "    if (count($numbers)\
    \ < 2) {\n        return $numbers;\n    }\n    $largest = max($numbers);\n   \
    \ $smallest = min($numbers);\n    $scale = ($largest - $smallest) / count($numbers);\n\
    \    return array_map('floatval', array_map(function($number) use($scale) {\n\
    \        return $number / $scale;\n    }, $numbers));\n}\n</code>\nThe reason\
    \ this works correctly is that if you subtract two values where one value is zero,\
    \ the result will be the same as that value itself.  In your examples, there are\
    \ two elements that are zero which both get halved by dividing by 2.\nThe key\
    \ insight is that if you subtract two values from each other where one value is\
    \ 0, you end up with a zero in that position.  If two values are the same, you\
    \ end up with the original value in the position.\nThis also works because if\
    \ you divide two numbers that are zero, the result will be 0.  If two numbers\
    \ are the same, they will both get divided by 2.\n<|/ a |>\n<| c |>\nWhy not just\
    \ `array_filter` the array down to elements where they're both zero? `array_filter($numbers,\
    \ function($i) { return $i == $i ? 0.0 : $i;});` would do the trick\n<|/ c |>\n\
    <| c |>\nThanks - I updated the question - I simplified the problem too much -\
    \ I actually have numbers that are not strictly 0's (but they are close enough\
    \ that it looks like a number that is 0). I am actually trying to do some calculations\
    \ with the data - so the 0's are actually not zero but very close to zero (not\
    \ quite zero but very close)\n<|/ c |>\n<| a dscore=0 |>\nI ended up coming up\
    \ with this solution :\n<code>\npublic function rescale_to_unit($numbers) {\n\n\
    \    // We want to rescale only if we have at least one element in the array\n\
    \    if (count($numbers) < 2) {\n        return $numbers;\n    }\n\n    // Get\
    \ the min and max element values\n    $min = min($numbers);\n    $max = max($numbers);\n\
    \n    // We want to divide all elements in the array by the max element value\n\
    \    // This is actually what we are doing\n    // $max - $min = (max($numbers)\
    \ - min($numbers)) / (count($numbers) - 1);\n    $scale = ($max - $min) / (count($numbers)\
    \ - 1);\n\n    return array_map('floatval', array_map(function($number) use($scale)\
    \ {\n        return $number * $scale;\n    }, $numbers));\n\n}\n</code>\n<|/ a\
    \ tags=php |>\n<| a tags=php |>\n<code>\n/**\n * array $numbers", "\t$min = min($numbers);\n\
    \t$max = max($numbers);\n\n\t$scale = 1.0 / ($max - $min);\n\n\treturn array_map(function($val)\
    \ { return $val * $scale; }, $numbers);\n}\n", "    foreach ($numbers as $number\
    \ => $ratio) {\n        if ($ratio > 1) {\n            $numbers[$number] = $number\
    \ * 1.0 / $ratio;\n        }\n    }\n    return $numbers;\n}\n\n/**\n * Converts\
    \ an array of numbers to an array.\n * All elements of the input array must be\
    \ scalars, and will have a unique key.\n * \n * @param  array  $input \n * @param\
    \  string $key_name \n * @param  mixed  $default \n * @return array\n */", " \
    \ $range_size = get_max_value($numbers);\n  foreach ($numbers as $number) {\n\
    \    $number = ($number - $range_size) / $range_size;\n    $numbers[$i] = $number;\n\
    \  }\n  return $numbers;\n}\n", "    $smallest = $numbers[0];\n    $largest =\
    \ $numbers[0];\n    foreach ($numbers as $n) {\n        if ($n < $smallest) {\n\
    \            $smallest = $n;\n        }\n        if ($n > $largest) {\n      \
    \      $largest = $n;\n        }\n    }\n    if ($smallest == $largest) {\n  \
    \      return $largest;\n    }\n\n    // Scale the smallest and largest to match\
    \ expected range of 0 to 1\n    // Then scale the list to convert from 0 to 1\n\
    \    return array_map(function ($n) use ($smallest, $largest) {\n        return\
    \ ($n - $smallest) / ($largest - $smallest);\n    }, $numbers);\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\nI needed this functionality to convert a\
    \ normalized image from 0-255 to 0-1 so I can use it in my CNN.\nI used the following\
    \ code to do it:\n<code>", "  $min = reset($numbers);\n  $max = end($numbers);\n\
    \n  return array_map(function ($item) use ($min, $max) {\n    return ($item -\
    \ $min) / ($max - $min);\n  }, $numbers);\n}", "  if (count($numbers) < 2) return\
    \ $numbers;\n  // Find minimum and maximum value\n  $min = min(array_map(function($v)\
    \ { return floatval($v); }, $numbers));\n  $max = max(array_map(function($v) {\
    \ return floatval($v); }, $numbers));\n  // Find the difference between min and\
    \ max\n  $range = abs($max - $min);\n  // Find multiplier such that smallest value\
    \ becomes 0 and largest becomes 1\n  $mul = (1 / ($range - 1));\n  $mul = pow(10,\
    \ floor(log10($mul)));\n  // Apply multiplication\n  return array_map(function($x)\
    \ { return $x * $mul; }, $numbers);\n}\n", "    $min = min($numbers);\n    $max\
    \ = max($numbers);\n    return array_map(function ($n) use ($min, $max) {\n  \
    \      return (1 - $n * $min / ($max - $min));\n    }, $numbers);\n}", "  $min_value\
    \ = min($numbers);\n  $max_value = max($numbers);\n  $scale = ($max_value - $min_value)\
    \ / max(count($numbers), 1);\n  return array_map(function ($x) {\n    return $x\
    \ * $scale;\n  }, $numbers);\n}\n\n/**\n * Given a list of numbers, determine\
    \ whether each element in the list is within the given threshold of 0.\n * >>>\
    \ is_zero_probability([0.5, 0.25, 0.25])\n * True\n * >>> is_zero_probability([0.25,\
    \ 0.5, 0.75])\n * False\n */", "    if (count($numbers) < 2) {\n        return\
    \ $numbers;\n    }\n    $smallest_num = min($numbers);\n    $max_num = max($numbers);\n\
    \    $range = $max_num - $smallest_num;\n    if ($range == 0.0) {\n        return\
    \ $numbers;\n    }\n    $scale = 1.0f / $range;\n    foreach ($numbers as $key\
    \ => $number) {\n        $numbers[$key] = $number * $scale;\n    }\n    return\
    \ $numbers;\n}\n", "  $min_number = min(array_values($numbers));\n  $max_number\
    \ = max(array_values($numbers));\n  return array_map(function($number) {\n   \
    \ return $number / max($min_number, $max_number);\n  }, $numbers);\n}\n", "  \
    \  $min = min($numbers);\n    $max = max($numbers);\n    // The maximum value\
    \ in the list is smaller than the minimum, so just set the minimum to 0\n    if\
    \ ($min > $max) {\n        $min = 0;\n    }\n    // The minimum value in the list\
    \ is greater than the maximum, so just set the maximum to 1\n    if ($min < $max)\
    \ {\n        $max = 1;\n    }\n    return array_map(function ($num) use ($min,\
    \ $max) {\n        return (float) $num / $max - $min;\n    }, $numbers);\n}\n\
    </code>\nI ran this test with this data:\n<code>\n$numbers = [1.1, 2.2, 3.3, 4.4,\
    \ 5.5, 6.6, 7.7, 8.8, 9.9];\n$results = rescale_to_unit($numbers);\n</code>\n\
    and got the following results:\n<code>\nArray\n(\n    [0] => 0\n    [1] => 0.25\n\
    \    [2] => 0.5\n    [3] => 0.75\n    [4] => 1\n)\n</code>\n<|/ a |>\n<| c |>\n\
    This looks promising, thank you for taking the time to test this.\n<|/ c |>\n\
    <| c |>\nThis doesn't work when we have negative numbers like `[-1.3, 1.2, 2.3,\
    \ 3.4, 4.5, 5.6, 6.7, 7.8, 8.9]`\n<|/ c |>\n<| a tags=math,arrays,php |>\n<code>",
  "  $min = array_reduce($numbers, function(a, b) { return min(a, b); });\n  $max\
    \ = array_reduce($numbers, function(a, b) { return max(a, b); });\n\n  return\
    \ array_map(\n    function() use ($min, $max) {\n      return (abs($max - $min)\
    \ / count($numbers)) * $min;\n    },\n    $numbers\n  );\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis seems to be the best solution. Especially the use of `array_reduce`\
    \ and `array_map` makes it a very clear answer. Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ is very nice, but it doesn't scale to more numbers, i.e. [1, 1, 10, 10, 100].\
    \  It should be [0.1, 0.2, 0.2, 0.8, 0.8]\n<|/ c |>\n<| c |>\n: You're right.\
    \ I updated my answer to fix that issue.\n<|/ c |>\n<| a tags=algorithm,math,php\
    \ dscore=3 |>\nIn case someone is looking for an alternative to array_map (like\
    \ me). I used this function for my project to get a random value between 0 and\
    \ 1:\n<code>", "    $scale = (isset($numbers[1]) ? $numbers[1] : 1);\n    if ($scale\
    \ != 0) {\n        $min = min($numbers);\n        $max = max($numbers);\n    \
    \    for ($i = 0; $i < count($numbers); $i++) {\n            $numbers[$i] = $numbers[$i]\
    \ / $scale;\n            if ($min == $max) {\n                break;\n       \
    \     }\n            if ($numbers[$i] < $min) {\n                $numbers[$i]\
    \ = $min;\n            } else if ($numbers[$i] > $max) {\n                $numbers[$i]\
    \ = $max;\n            }\n        }\n    }\n    return $numbers;\n}\n", "    list($min,\
    \ $max) = minmax($numbers);\n    if ($min == $max) {\n        return $numbers;\n\
    \    }\n\n    $rescale = $max - $min;\n    return array_map(function($x) { return\
    \ ($x - $min) / $rescale; }, $numbers);\n}\n", "  if (count($numbers) < 2) {\n\
    \    return $numbers;\n  }\n  $first_number = array_shift($numbers);\n  $last_number\
    \ = array_pop($numbers);\n  $factor = pow(10, ceil(log10($last_number - $first_number)));\n\
    \  return array_map('round', $numbers / $factor) * $factor;\n}\n</code>\nNote\
    \ that if you have negative numbers, this function does not handle them correctly.\
    \ You may want to check for them and only rescale the smallest and largest negative\
    \ numbers, or even scale them all to zero.\nThis works for any number of elements\
    \ in $numbers, except negative ones. If this does not work, you may want to use\
    \ the first function I gave you, which does not handle negative numbers:\n<code>",
  "    assert(count($numbers) > 0);\n    $minimum = min($numbers);\n    $maximum =\
    \ max($numbers);\n\n    // If there is a zero between the minimum and the maximum,\
    \ we add an epsilon to\n    // the minimum and maximum to ensure that the transformation\
    \ makes sense\n    if ($minimum == 0.0 || $maximum == 0.0) {\n        $epsilon\
    \ = 1e-12;\n        $minimum = $minimum - $epsilon;\n        $maximum = $maximum\
    \ + $epsilon;\n    }\n\n    // We calculate the linear transform (from minimum\
    \ to maximum) by dividing the list by the maximum\n    // If the maximum is 0,\
    \ we add an epsilon to the minimum to ensure that the transformation makes sense\n\
    \    if ($maximum == 0.0) {\n        $epsilon = 1e-12;\n        $minimum = $minimum\
    \ + $epsilon;\n    }\n\n    // We apply the linear transform\n    $new_numbers\
    \ = array();\n    foreach ($numbers as $number) {\n        $new_numbers[] = $number/$maximum;\n\
    \    }\n\n    return $new_numbers;\n}", "  // Get the min and max value\n  $min\
    \ = min($numbers);\n  $max = max($numbers);\n\n  // Calculate the scaling factor\n\
    \  $scalingFactor = 1 / $max - $min;\n\n  // Apply the scaling factor\n  return\
    \ array_map(function($v) use ($min, $max, $scalingFactor) {\n    return ($v -\
    \ $min) * $scalingFactor;\n  }, $numbers);\n}\n", "  if (count($numbers) < 2)\
    \ {\n    return $numbers;\n  }\n\n  sort($numbers);\n  $min_number = $numbers[0];\n\
    \  $max_number = $numbers[0];\n\n  for ($i = 1; $i < count($numbers); $i++) {\n\
    \    $min_number = min($min_number, $numbers[$i]);\n    $max_number = max($max_number,\
    \ $numbers[$i]);\n  }\n\n  $scale = 1 / ($max_number - $min_number);\n  return\
    \ array_map(function($number) use ($scale) {\n    return $number * $scale;\n \
    \ }, $numbers);\n}\n", "    // Sort the list by value\n    sort($numbers);\n\n\
    \    // Find the largest number\n    $largest = end($numbers);\n\n    // Find\
    \ the smallest number\n    $smallest = reset($numbers);\n\n    // Calculate the\
    \ linear transform\n    $scale = ($largest - $smallest) / (count($numbers) - 1);\n\
    \    return array_map(function($number) { return $number * $scale; }, $numbers);\n\
    }\n", "    // Convert to an array of floating point numbers\n    $numbers = array_map(function($x)\
    \ {\n        return $x * 1.0;\n    }, $numbers);\n\n    // Find the maximum and\
    \ minimum of the numbers, and use them to rescale the list\n    $min = min($numbers);\n\
    \    $max = max($numbers);\n    return array_map(function($x) {\n        // Subtract\
    \ the minimum and divide by the difference of the maximum and minimum\n      \
    \  return ($x - $min) / ($max - $min);\n    }, $numbers);\n}\n</code>\nNote that\
    \ in both versions, the input array is first converted to an array of floating\
    \ point numbers to avoid the need to handle strings. If you want the function\
    \ to work with any array, use the following versions:\n<code>\n<?php", "    if\
    \ (!count($numbers) || count($numbers) < 2) {\n        return $numbers;\n    }\n\
    \n    $min = min(array_keys($numbers));\n    $max = max(array_keys($numbers));\n\
    \    $length = max($max - $min);\n    $offset = min($min - 0, $max - $length);\n\
    \n    return $offset ? array_map(function ($value) use ($min, $max, $length, $offset)\
    \ {\n            return $value / $length + $offset;\n        }, $numbers) : array_map(function\
    \ ($value) use ($min, $max, $length) {\n            return $value / $length;\n\
    \        }, $numbers);\n}\n</code>\n<|/ a tags=php,math,statistics |>\n<| a |>\n\
    An elegant solution would be to subtract and sum all the numbers:\n<code>", " \
    \ $min = min($numbers);\n  $max = max($numbers);\n\n  foreach ($numbers as $x)\
    \ {\n    $diff -= $min;\n    $diff = $diff / $max;\n    $numbers[$x] = $diff;\n\
    \  }\n  return $numbers;\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \  if ($min == $max) {\n    // No scaling, just return\n    return $numbers;\n\
    \  }\n  // Scale by largest difference from original min to max\n  $ratio = $max\
    \ - $min;\n  $scaled = array();\n  for ($i = 0; $i < count($numbers); $i++) {\n\
    \    $scaled[] = ($numbers[$i] - $min) / $ratio;\n  }\n  return $scaled;\n}\n",
  "    $new_numbers = array();\n    $first_number = array_shift($numbers);\n    array_push($new_numbers,\
    \ $first_number);\n    foreach ($numbers as $number => $scale) {\n        $new_numbers[$number]\
    \ = $first_number + ($number * $scale);\n    }\n    return $new_numbers;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nWhat do you mean by \"the smallest number will become\
    \ 0 and the largest will become 1\"? If `[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8,\
    \ 0.9, 1.0]` is the original list, what will the output be?\n<|/ c |>\n<| c |>\n\
    The smallest number will become: `0.0` and the largest will become: `1.0`\n<|/\
    \ c |>\n<| c |>\nThanks for the response, but your code does not work as expected.\
    \ The result of the code you posted is `[0, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07,\
    \ 0.08, 0.1, 1]`. I am not sure why your output is different from the result I\
    \ got from the other answers.\n<|/ c |>\n<| c |>\nI see my mistake. I did not\
    \ account for the fact that the original list may not contain any elements. Now\
    \ it works.\n<|/ c |>\n<| c |>\nI am confused why you added `+ 0`, shouldn't it\
    \ just be `+ 1`? And why did you write `/ 1.0` instead of `/ $scale`?\n<|/ c |>\n\
    <| a tags=functional-programming,math,php |>\nHere a solution using array_map()\
    \ and a closure:\n<code>\n$arr = [\n  0,\n  0.02,\n  0.03,\n  0.04,\n  0.05,\n\
    \  0.06,\n  0.07,\n  0.08,\n  0.1,\n];\n\n$arr2 = array_map ( function ( $number\
    \ ) {\n  return $number / 1.0;\n}, $arr );\n\nprint_r( $arr2 );\n</code>\nOutputs:\n\
    <code>\nArray\n(\n  [0] => 0\n  [1] => 0\n  [2] => 0\n  [3] => 0\n  [4] => 0\n\
    \  [5] => 0\n  [6] => 0\n  [7] => 0\n  [8] => 0\n  [9] => 0\n)\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThis does not do what the OP wants unfortunately.\n<|/\
    \ c |>\n<| c |>\nOkay, that's why I didn't downvote, but my answer was a bit more\
    \ comprehensive...\n<|/ c ", "    $min = min(array_values($numbers));\n    $max\
    \ = max(array_values($numbers));\n    if ($min == 0) {\n        return array(1.0,\
    \ 0);\n    }\n    if ($max == 0) {\n        return array(0, 1);\n    }\n    $scale\
    \ = 1 / $max - $min;\n    return array_map(function($x) {\n        return round($x\
    \ * $scale);\n    }, $numbers);\n}\n</code>\nThe above function is actually a\
    \ modified version of the following python function:\n<code>\ndef rescale_to_unit(numbers):\n\
    \    # Find the min and max values of numbers\n    sorted_numbers = sorted(numbers)\n\
    \    min = sorted_numbers[0]\n    max = sorted_numbers[-1]\n\n    # If min is\
    \ 0, then rescale all numbers to 0, to ensure all numbers are scaled to the same\
    \ value.\n    if min == 0:\n        min_scaled = [0] * len(numbers)\n    else:\n\
    \        min_scaled = sorted_numbers[:1]\n\n    # If max is 0, then rescale all\
    \ numbers to 1, to ensure all numbers are scaled to the same value.\n    if max\
    \ == 0:\n        max_scaled = 1 * [0] * len(numbers)\n    else:\n        max_scaled\
    \ = sorted_numbers[-1:0:-1]\n\n    # Apply linear transform to each number in\
    \ numbers, and get the resulting scaled numbers\n    scaled_numbers = [((n - min)\
    \ / (max - min)) * (b - a) + a\n                      for (a, b) in zip(min_scaled,\
    \ max_scaled)]\n    return scaled_numbers\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    Your function is not correct if max is 0. It returns `[0.0, 0.0]` instead of `[0.0,\
    \ 0.0]`. Change `max_scaled = 1 * [0] * len(numbers)` to `max_scaled = [-1] *\
    \ len(numbers)` and it works.\n<|/ c |>\n<| c |>\nI believe it should be `-1 *\
    \ len(numbers)`. That is `[-1]` instead of `[0]`.\n<|/ c |>\n<| a tags=python,arrays,php\
    \ dscore=5 |>\nFor those looking for something similar in JavaScript:\n<code>\n\
    const rescale = function(nums, min=0, max=1) {\n    return nums.map(function(num)\
    \ {\n        return num / max - min;\n    });\n};\n</code>\n<|/ a |>\n<| c |>\n\
    This assumes you're using javascript which I was not clear of.\n<|/ c |>\n<| c\
    \ |>\nYou can do this in a very similar fashion in Python using numpy, which has\
    \ `min` and `max` as built-in functions. This solution works even if you aren't\
    \ using Javascript (for example in a React app).\n<|/ c |>\n<| a tags=python,arrays,php\
    \ |>\n<code>\n<?php\n", "    if (count($numbers) < 2) {\n        return $numbers;\n\
    \    }\n\n    $min = min($numbers);\n    $max = max($numbers);\n\n    return array((float)\
    \ $min / $max, (float) $max / $min);\n}\n", "    if ($numbers === null || count($numbers)\
    \ < 2) {\n        return $numbers;\n    }\n\n    $rescaled_numbers = array();\n\
    \    foreach ($numbers as $number) {\n        $rescaled_numbers[] = $number /\
    \ min(abs($number), abs($numbers[count($numbers) - 1]));\n    }\n    return $rescaled_numbers;\n\
    }\n", "  if (count($numbers) < 2) {\n    return $numbers;\n  }\n  $min = $numbers[0];\n\
    \  $max = array_pop($numbers);\n  return array_map(function ($x) { return $x -\
    \ $min / ($max - $min); }, $numbers);\n}\n", "  if (count($numbers) < 2) {\n \
    \   return $numbers;\n  }\n  $min_number = array_reduce($numbers, function($min,\
    \ $x) {\n    return min($min, $x);\n  });\n  $max_number = array_reduce($numbers,\
    \ function($max, $x) {\n    return max($max, $x);\n  });\n  $min_number = max(1,\
    \ $min_number);\n  $max_number = min(1, $max_number);\n  $range = max(abs($max_number),\
    \ abs($min_number));\n  $scale = abs(1 - $max_number / $range);\n  return array_map(function($x)\
    \ use ($scale) {\n    return $scale * $x;\n  }, $numbers);\n}\n</code>\nThe function\
    \ also accepts negative numbers, just in case you need it.\n<|/ a dscore=1 |>\n\
    <| a |>\nI used the following method to get some extra performance out of the\
    \ equation calculation and got the following results. I used a slightly different\
    \ approach than proposed but I think it might be useful in some situations. \n\
    The method I used is slightly more involved than the other methods and does require\
    \ that $numbers is a non-associative array. I had to loop through the array twice,\
    \ once to calculate the min and max, and then again to apply the transform. \n\
    <code>", "  $min = min($numbers);\n  $max = max($numbers);\n  if ($min == $max)\
    \ {\n    return $numbers;\n  }\n  $range = floatval($max - $min);\n  $scale =\
    \ $range / 1.0;\n  $scaled = array();\n  foreach ($numbers as $n => $x) {\n  \
    \  $scaled[$n] = $x * $scale;\n  }\n  return $scaled;\n}\n", "  if (count($numbers)\
    \ < 2) {\n    return $numbers;\n  }\n\n  $smallest = min($numbers);\n  $largest\
    \ = max($numbers);\n  $range = array(0, 1);\n\n  if ($smallest == $largest) {\n\
    \    return $range;\n  }\n\n  $min_value = min($numbers);\n  $max_value = max($numbers);\n\
    \n  for ($i = 0; $i < count($numbers); ++$i) {\n    $range[$i] = $range[$i - 1]\
    \ + ($numbers[$i] - $min_value) / ($max_value - $min_value);\n  }\n\n  return\
    \ $range;\n}\n", "  return array_map(function ($x) {\n    return $x / (count($numbers)\
    \ - 1);\n  }, $numbers);\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \  foreach ($numbers as &$number) {\n    $number /= ($max - $min);\n  }\n  return\
    \ $numbers;\n}", "    list($min, $max) = array_pad(array(), 2, array_min($numbers));\n\
    \    $min = min($min, $max);\n    $max = max($min, $max);\n    $range = $max -\
    \ $min;\n    $offset = 0.0;\n    if ($range == 0) {\n        return array($min\
    \ + $offset, 1);\n    }\n    // Make sure that $range is never zero, otherwise\
    \ the values will be incorrectly mapped to the interval [0, 1]\n    $range +=\
    \ 1.0;\n    if ($range <= SMALL) {\n        $offset -= (SMALL - $range) / 2.0;\n\
    \        $range += SMALL;\n    }\n    if ($range >= BIG) {\n        $offset +=\
    \ ($range - BIG) / 2.0;\n        $range -= BIG;\n    }\n    return array($min\
    \ + $offset, $range);\n}", "  // If the number of elements is less than 2, return\
    \ what we already have\n  if (count($numbers) < 2) {\n    return $numbers;\n \
    \ }\n\n  // Find minimum element of the array\n  $min = $numbers[0];\n  for ($i\
    \ = 1; $i < count($numbers); $i++) {\n    $min = ($min > $numbers[$i]) ? $numbers[$i]\
    \ : $min;\n  }\n\n  // Find the difference between maximum and minimum\n  $max_to_min\
    \ = abs($max - $min);\n  // If there is some difference between maximum and minimum,\
    \ divide all numbers by this difference\n  if ($max_to_min > 0) {\n    for ($i\
    \ = 0; $i < count($numbers); $i++) {\n      $numbers[$i] /= $max_to_min;\n   \
    \ }\n  }\n\n  // Apply the linear transformation\n  for ($i = 0; $i < count($numbers);\
    \ $i++) {\n    $numbers[$i] -= $min;\n    $numbers[$i] *= $scale;\n  }\n\n  return\
    \ $numbers;\n}\n", "  ksort($numbers);\n  $sum = 0;\n  for ($i = 0; $i < count($numbers);\
    \ $i++) {\n    $sum += ($numbers[$i]);\n  }\n  for ($i = 0; $i < count($numbers);\
    \ $i++) {\n    $numbers[$i] = (float) ($numbers[$i] / $sum);\n  }\n  array_unshift($numbers,\
    \ 0);\n  array_shift($numbers);\n  return $numbers;\n}\n", "    sort($numbers);\n\
    \    $min = reset($numbers);\n    $max = end($numbers);\n    foreach ($numbers\
    \ as $key => $value) {\n        $numbers[$key] = ($value - $min) / ($max - $min);\n\
    \    }\n    return $numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nHi, thanks for your\
    \ answer. I'm still a bit confused. Is this an attempt to find an algorithm or\
    \ are you just using php to calculate the percentages? Can you explain the first\
    \ part a bit more? Thank you :)\n<|/ c |>\n<| c |>\nNo offense, but I think you\
    \ should stop writing code that you don't understand. The first part is just an\
    \ algorithm that takes an array of numbers and produces an array of percentages.\n\
    <|/ c |>\n<| c |>\nAh I get it now. Thank you for the explanation. I did try it\
    \ out and it does work! But I never understood what the function was doing haha\n\
    <|/ c |>\n<| a dscore=0 |>\nI dont know if you are still looking for an answer\
    \ here, but this was my first SO answer and I have been looking a lot into this\
    \ problem myself. \nThe solution I ended up using, is as follows\n<code>", " \
    \ $rescaled = array();\n  foreach ($numbers as $value) {\n    // In order to do\
    \ this, we will have to find the min and max of the list\n    // So we will put\
    \ all the elements in the array into a new array, then call\n    // min and max\
    \ on that array to get our min/max values\n    $new_array = array();\n    foreach\
    \ ($numbers as $number) {\n      $new_array[] = $number;\n    }\n    $min = min(array_column($new_array));\n\
    \    $max = max(array_column($new_array));\n    // Now we simply need to scale\
    \ our original list by the difference between max and min\n    // So for example,\
    \ if our min/max are 50/50, then our new array will be 150\n    $scaled = ($max\
    \ - $min);\n    foreach ($numbers as $key => $value) {\n      $rescaled[] = $min\
    \ + ($value / $scaled);\n    }\n  }\n  return $rescaled;\n}\n\n/**\n * Takes a\
    \ raw data array and a field name as input, returns the total of the field grouped\
    \ by week\n * or total of all fields if group_by_field not provided\n *\n * @param\
    \ $data\n * @param $group_by_field\n * @return array\n */", "  $numbers_length\
    \ = count($numbers);\n  $min_number = min($numbers);\n  if ($min_number == 0)\
    \ {\n    return $numbers;\n  }\n  $unit_divisor = $numbers_length * $min_number;\n\
    \  // if $numbers_length == 1, then there's no reason to divide by this number\n\
    \  if ($unit_divisor == 1) {\n    return $numbers;\n  }\n  $scaled_numbers = array();\n\
    \  for ($i = 0; $i < $numbers_length; $i++) {\n    $scaled_numbers[$i] = round($numbers[$i]\
    \ / $unit_divisor);\n  }\n  return $scaled_numbers;\n}\n", "  return array_map(function($num)\
    \ { return $num / MIN($numbers); }, $numbers);\n}\n", "    if (!empty($numbers))\
    \ {\n        $min = $numbers[0];\n        $max = reset($numbers);\n        foreach\
    \ ($numbers as $key => $value) {\n            if ($value < $min) {\n         \
    \       $min = $value;\n            }\n            if ($value > $max) {\n    \
    \            $max = $value;\n            }\n        }\n\n        $diff = 1. *\
    \ $max - $min;\n        if ($diff == 0.) {\n            $unit = [0., 0., 0.];\n\
    \        } else {\n            $unit = [1. * $min / $diff, $max - $min, 0.];\n\
    \        }\n        return $unit;\n    }\n}\n", "    $min = min($numbers);\n \
    \   $max = max($numbers);\n    if ($min == $max) {\n        return $min;\n   \
    \ }\n    return $min / $max;\n}\n", "    $min_number = min($numbers);\n    $max_number\
    \ = max($numbers);\n\n    // The rescaled numbers are between 0 and 1, so we'll\
    \ calculate the\n    // ratio to rescale by\n    $rescale = ($max_number - $min_number)\
    \ / 0.0;\n\n    // The rescaled list will have a minimum value of 0, and a maximum\
    \ value of 1.\n    // To ensure the numbers are in the range 0 to 1, we'll rescale\
    \ by this ratio\n    $numbers = array_map(function ($number) {\n        return\
    \ $number * $rescale;\n    }, $numbers);\n\n    return $numbers;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=php,arrays |>\nI like the accepted answer (although\
    \ I actually prefer a one-liner). Here is a PHP implementation of it:\n<code>",
  "  // We can't do anything without at least one element\n  if(!$numbers)\n    return\
    \ array();\n\n  // Take the minimum and maximum of all numbers\n  $min = array_reduce($numbers,\
    \ 'min');\n  $max = array_reduce($numbers, 'max');\n\n  // Return scaled numbers\n\
    \  return array_map(function ($number) use ($min, $max) {\n    return $min + ($max\
    \ - $min) * $number;\n  }, $numbers);\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I'm not a PHP developer, but I've seen this implemented in Python before. I think\
    \ it's probably a very elegant solution.\n<|/ c |>\n<| a dscore=4 |>\nThe accepted\
    \ answer is very close, but misses some edge cases, e.g. with multiple min values\
    \ and/or multiple max values.\nThe following code will do the same as accepted\
    \ answer but will account for all of the edge cases:\n<code>", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  foreach ($numbers as $number) {\n    $numbers[$number]\
    \ = $number - $min;\n  }\n  $range = array();\n  foreach ($numbers as $number)\
    \ {\n    $range[] = $number / $max;\n  }\n  return $range;\n}\n</code>\n<|/ a\
    \ tags=math,mathematical-expressions,php |>\n<| c |>\nThat works well, except\
    \ for when there is only one number in the list, then it will return 0.1 instead\
    \ of 0 for the minimum number.\n<|/ c |>\n<| c |>\nIt looks like you're right,\
    \ I'll fix it in a moment.\n<|/ c |>\n<| c |>\nThanks for the fix. I'll be sure\
    \ to test it out later to make sure that it works with all cases as well. I'll\
    \ post back here as soon as I do, but I believe that this does now fulfill the\
    \ OP's requirements.\n<|/ c |>\n<| a tags=math,mathematical-expressions,php |>\n\
    I believe this is what you're looking for. I borrowed the rescale formula from\
    \ here. I added some comments to describe what each line of code is doing.\n<code>\n\
    <?php\n", "  if (count($numbers) < 2) {\n    return $numbers;\n  }\n  sort($numbers);\n\
    \  $midpoint = floor($numbers[count($numbers) / 2]);\n  return array(0, $midpoint,\
    \ $numbers[count($numbers) - 1], $numbers[0]);\n}\n", "    foreach ($numbers as\
    \ $i => $number) {\n        if ($number == 0) {\n            $numbers[$i] = 1;\n\
    \        }\n    }\n    $min = min($numbers);\n    $max = max($numbers);\n    if\
    \ ($min == 0) {\n        return $numbers;\n    }\n    $scale = 1 / ($max - $min);\n\
    \    foreach ($numbers as $i => $number) {\n        $numbers[$i] = (1 - $scale)\
    \ * $number + $min * $scale;\n    }\n    return $numbers;\n}\n", "  // We use\
    \ an array with two elements (one for maximum, one for minimum) to hold the result\n\
    \  $result = array_fill(0, 2, 0);\n  foreach ($numbers as $number) {\n    $result[0]\
    \ += $number;\n    if ($number < $result[1]) {\n      $result[1] = $number;\n\
    \    }\n  }\n  return $result;\n}\n", "  // We require that there is at least\
    \ one number\n  list($min) = array_merge([null], $numbers);\n  assert(!is_null($min));\n\
    \  // Now find the largest and smallest numbers\n  list($min, $max) = array_map('max',\
    \ $numbers);\n  // Now we scale each number in $numbers to be between\n  // $min\
    \ and $max\n  $numbers = array_map(function ($number) use ($min, $max) {\n   \
    \ return $min + ($number - $min) / ($max - $min);\n  }, $numbers);\n  return $numbers;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\nBased on the accepted answer, but with\
    \ added comments to help others understand what is happening. I did this in 2\
    \ steps:\n<code>\n$min_number = min(array_filter(array_column($numbers, 'value')));\n\
    $number_count = count($numbers);\n$new_numbers = array_map(function($number) {\n\
    \    // this returns the number as before but with 0 added at the end\n    return\
    \ $number + $min_number / ($number_count - 1);\n}, $numbers);\n</code>\nThe key\
    \ here being the use of array_filter to remove the nulls, then array_column to\
    \ extract the values from the array and array_map to perform the transformation.\n\
    <|/ a tags=php |>\n<| a |>\nA little modification to Sausage's answer\n<code>",
  "    foreach ($numbers as $k => $v) {\n        if ($v < $numbers[0]) {\n       \
    \     $numbers[$k] = 0.0;\n        }\n        else if ($v > $numbers[0]) {\n \
    \           $numbers[$k] = 1.0;\n        }\n    }\n    return $numbers;\n}\n\n\
    /**\n * Get a time duration string given a number of seconds multiplied by a multiplier.\n\
    \ *\n * @param float $seconds The number of seconds to multiply the time\n * @param\
    \ float $multiplier The multiplier to convert the time into\n * @return string\
    \ The time in formatted string\n */", "  if (count($numbers) < 2) {\n    throw\
    \ new InvalidArgumentException('Need at least two numbers');\n  }\n\n  $smallest\
    \ = $numbers[0];\n  $largest = array_pop($numbers);\n\n  foreach ($numbers as\
    \ $number) {\n    if ($number < $smallest) {\n      $smallest = $number;\n   \
    \ }\n\n    if ($number > $largest) {\n      $largest = $number;\n    }\n  }\n\n\
    \  return array_map(function ($number) {\n    return $number / $largest;\n  },\
    \ $numbers);\n}\n\n/**\n * Scales a number between 0 and 1 based on a list of\
    \ other numbers.\n *\n * If all the numbers are between 0 and 1 (exclusive) this\
    \ will return a number\n * between 0 and the number of elements in the list.\n\
    \ *\n * If all the numbers are between 0 and 1 this will return a number between\n\
    \ * 0 and the sum of all the numbers.\n *\n * If all the numbers are between -1\
    \ and 0 this will return a number between\n * -1 and 0 based on all the elements\
    \ in the list.\n *\n * If all the numbers are between 0 and -1 this will return\
    \ a number between\n * -1 and -sum(all the numbers) based on all the elements\
    \ in the list.\n *\n * Otherwise the function will throw an exception.\n *\n *\
    \ @param array $numbers - The numbers to scale between.\n *\n * @return float\
    \ - The value rescaled between 0 and 1.\n * @throws InvalidArgumentException\n\
    \ */", "  array_walk($numbers, 'rescale_to_unit_normalize');\n  return $numbers;\n\
    }", "  return array_map(function($number) {\n    return $number / array_sum($numbers);\n\
    \  }, $numbers);\n}\n", "  if (!$numbers) {\n    return $numbers;\n  }\n  $min\
    \ = $numbers[0];\n  $max = $numbers[0];\n  for ($i = 1; $i < count($numbers);\
    \ ++$i) {\n    if ($numbers[$i] < $min) {\n      $min = $numbers[$i];\n    } else\
    \ if ($numbers[$i] > $max) {\n      $max = $numbers[$i];\n    }\n  }\n  if (!isset($min)\
    \ || !isset($max)) {\n    return $numbers;\n  }\n  for ($i = 0; $i < count($numbers);\
    \ ++$i) {\n    $numbers[$i] /= ($max - $min);\n  }\n  return $numbers;\n}\n</code>\n\
    <|/ a tags=php |>\n<| c |>\nYou don't need the ternary operator here `($max ==\
    \ $min ? 0 : ($max - $min));`\n<|/ c |>\n<| c |>\nGood point. Removed it (along\
    \ with `++$i` since you were incrementing `$i` twice anyway)\n<|/ c |>\n<| a tags=php\
    \ |>\nI wrote this function that works both for positive and negative numbers.\
    \ It also takes the minimum and maximum limits.\n<code>", "    $min_number = min(array_map('current',\
    \ $numbers));\n    $max_number = max(array_map('current', $numbers));\n    return\
    \ array_map(function ($num) use ($min_number, $max_number) {\n        return $num\
    \ - $min_number * $max_number / $max_number;\n    }, $numbers);\n}\n", "  $min\
    \ = null;\n  $max = null;\n  foreach ($numbers as $num) {\n    if ($min === null\
    \ || $min > $num) {\n      $min = $num;\n    }\n    if ($max === null || $max\
    \ < $num) {\n      $max = $num;\n    }\n  }\n  // Normalize the list\n  $numbers\
    \ = array();\n  for ($i = $min; $i <= $max; $i += 0.5) {\n    $numbers[] = $i;\n\
    \  }\n  return $numbers;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis looks like\
    \ a great answer. I am curious though - are there any performance benefits to\
    \ using this over `array_intersect($array1, $array2)`?\n<|/ c |>\n<| c |>\nI expect\
    \ that `array_intersect()` uses some sort of binary search, which means it'd be\
    \ O(n) worst case (where n is the number of elements in the array), but if you\
    \ have 1000 elements, it would be O(1000n) = O(n). In other words, `array_intersect()`\
    \ would be a better choice here than `array_merge()` + `array_unique()`, since\
    \ `array_intersect()` will be faster (O(n)) than the merge/unique approach.\n\
    <|/ c |>\n<| c |>\nI guess this makes sense if you consider that the merge and\
    \ unique approaches will likely be O(n^2).\n<|/ c |>\n<| c |>\nFor me, it seems\
    \ like this approach is more robust in that it also preserves order. I tried running\
    \ it against the array_intersect() approach you proposed, and the results were\
    \ quite different. The array_intersect() approach returned the array as it was\
    \ inputted even when one of the arrays had duplicate values. With this approach,\
    \ the returned array had all unique values.\n<|/ c |>\n<| c |>\nYes, that's exactly\
    \ what `array_intersect()` is for. Because you always want the minimum number\
    \ to be zero, the returned array will have all the unique values (and it'll be\
    \ sorted in ascending order from zero). And because `array_intersect()` is a simple\
    \ string search, it will be O(n) worst case (where n is the number of elements\
    \ in the array), which is much better than using array_merge() + array_unique()\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is another approach you could try using array_diff().\n\
    <code>\n<?php\n$array1 = array(\n  0 => 'zero',\n  1 => 'one',\n  2 => 'two',\n\
    \  3 => 'three',\n);\n\n$array2 = array(\n  0 ", "    $min = array_shift($numbers);\n\
    \    $max = array_shift($numbers);\n    foreach ($numbers as $number) {\n    \
    \    $min *= $number;\n        $max *= $number;\n    }\n    return array_map(function\
    \ ($number) { return $number / $min; }, $numbers);\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=php |>\nYou could use array_map and array_min and array_max to get the\
    \ minimum and maximum numbers and then apply a division:\n<code>\n<?php", "  \
    \  if (count($numbers) < 2) {\n        throw new Exception('Number of elements\
    \ must be at least 2');\n    }\n\n    $min = min($numbers);\n    $max = max($numbers);\n\
    \n    if ($min === $max) {\n        return $numbers;\n    }\n\n    if ($min ===\
    \ 0) {\n        return [0 / (1 - (1 / $max))];\n    }\n\n    $diff = $max - $min;\n\
    \    $scale = (1 - (1 / $diff));\n    return array_map(function ($value) use ($scale)\
    \ {\n        return $scale * ($value - $min);\n    }, $numbers);\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI appreciate the idea, but this algorithm doesn't seem to work.\
    \ My example returns `[0.0, 0.25, 0.5, 0.75, 1.0]` for the numbers `[1.0, 2.0,\
    \ 3.0, 4.0, 5.0]`. That is the same as `[0.0, 0.25, 0.5, 0.75, 1.0]` if the input\
    \ was `[0.0, 0.2, 0.3, 0.4, 0.5]`.\n<|/ c |>\n<| c |>\nI changed my answer. I\
    \ used the wrong formula.\n<|/ c |>\n<| c |>\nThanks, that's what I get for trusting\
    \ myself with my math! I see why you did this and my original approach didn't\
    \ work (I kept thinking linear transforms would always be symmetrical and never\
    \ considered rescaling in the other direction). Your new approach is clearer than\
    \ my original attempt though, and it actually works.\n<|/ c |>\n<| c |>\nJust\
    \ noticed that this answer is wrong. My example numbers are wrong as well. I'll\
    \ update the question to reflect that.\n<|/ c |>\n<| c |>\nI updated the answer.\
    \ I was thinking of a way to compute the result with just two numbers. But I don't\
    \ think there is a good way to do that with more than two numbers.\n<|/ c |>\n\
    <| a tags=function,php dscore=1 |>\nI made a very simple solution for this task:\n\
    <code>\n<?php\n", "    return array_map(function($number) { return floor($number\
    \ * 100) / 100; }, $numbers);\n}\n", "    if (!empty($numbers)) {\n        return\
    \ array_map('round', $numbers);\n    }\n    return $numbers;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThanks for the answer, I've added a clarification.\n\
    <|/ c |>\n<| a dscore=0 |>\nAs you suggested, you could loop through each number\
    \ until you get the correct result then break and move on.\nAnother approach would\
    \ be to find the first difference between the maximum and minimum numbers then\
    \ subtract that from each number and that would give you the first number you\
    \ need.  In PHP it would be something like this:\n<code>", "  return $numbers\
    \ < $numbers[1] ? array(0.0, $numbers[0] / $numbers[1]) : array(1.0, $numbers[1]\
    \ / $numbers[0]);\n}\n", "  $min = min($numbers);\n  $max = max($numbers);\n \
    \ // Scale the given numbers by the linear scaling factor between the minimum\
    \ and maximum\n  return array_map(function($x) use($min, $max) {\n    return $min\
    \ + ($x - $min) * ($max - $min) / ($max - $min);\n  }, $numbers);\n}\n", "  $min\
    \ = $numbers[0];\n  $max = array_shift($numbers);\n  $minIndex = 0;\n  $maxIndex\
    \ = count($numbers) - 1;\n  foreach ($numbers as $number) {\n    if ($number <\
    \ $min) {\n      $min = $number;\n      $minIndex = $i;\n    } else if ($number\
    \ > $max) {\n      $max = $number;\n      $maxIndex = $i;\n    }\n    $i++;\n\
    \  }\n  $scaleFactor = $max - $min;\n  for ($i = 0; $i < count($numbers); $i++)\
    \ {\n    $scaled[$i] = $scaleFactor / $numbers[$i];\n  }\n  return array_reverse($scaled);\n\
    }\n", "  $scales = array_map(function ($x) { return $x / min($numbers); }, $numbers);\n\
    \  $rescaled = $numbers;\n  foreach ($numbers as $k => $x) {\n    $rescaled[$k]\
    \ = $x / max($numbers);\n  }\n  return $scales;\n}\n", "  $minimum = min($numbers);\n\
    \  $maximum = max($numbers);\n  $range = array();\n  foreach ($numbers as $number)\
    \ {\n    $range[$number] = $number - $minimum;\n  }\n  $scale = 1.0 / ($maximum\
    \ - $minimum);\n  foreach ($range as $number => $value) {\n    $range[$number]\
    \ = $value * $scale;\n  }\n  return $range;\n}\n</code>\n<|/ a |>\n<| a tags=function,php,math,arrays\
    \ |>\n<code>\n/**\n * array $numbers\n * array\n */", "    $n = count($numbers);\n\
    \    if ($n < 2) {\n        throw new \\InvalidArgumentException('Rescaling factors\
    \ cannot work with less than two elements');\n    }\n\n    $scale = [];\n    for\
    \ ($i = 0; $i < $n; ++$i) {\n        $scale[$i] = 1 / max($scale[$i], min($numbers[$i]));\n\
    \    }\n\n    return array_map(function ($number) use ($scale) {\n        return\
    \ round($number * $scale[0]);\n    }, $numbers);\n}", "  $min = array_reduce($numbers,\
    \ function($v, $w) { return min($v, $w); });\n  $max = array_reduce($numbers,\
    \ function($v, $w) { return max($v, $w); });\n\n  return array_map(function($v)\
    \ { return $v / max($max, $min); }, $numbers);\n}", "\t$total_length = count($numbers);\n\
    \tif ($total_length == 1) {\n\t\treturn $numbers;\n\t}\n\t$highest_number = array_pop($numbers);\n\
    \tfor ($i = 0; $i < $total_length; ++$i) {\n\t\t$numbers[$i] = (1 - ($numbers[$i]\
    \ / $highest_number)) * $highest_number;\n\t}\n\tarray_unshift($numbers, 0);\n\
    \treturn $numbers;\n}\n", "  if (empty($numbers)) {\n    return array();\n  }\n\
    \n  $result = array();\n  $smallest = $numbers[0];\n  $smallest_absolute = min($numbers);\n\
    \  foreach ($numbers as $number) {\n    $delta = $number - $smallest;\n    if\
    \ ($delta < 0) {\n      $delta += $smallest_absolute;\n    }\n    $smallest =\
    \ $number;\n    $result[] = $delta;\n  }\n\n  return $result;\n}\n", "  $min_number\
    \ = min($numbers);\n  $max_number = max($numbers);\n  return array($min_number\
    \ / $max_number, $max_number / $min_number);\n}\n", "  return array_map(\n   \
    \ function($n) { return ($n - min($numbers)) / (max($numbers) - min($numbers));\
    \ },\n    $numbers\n  );\n}\n", "  $scale = max($numbers);\n  $offset = $scale\
    \ == 0.0 ? '' : 1.0 / $scale;\n  return array_map(function ($number) {\n    return\
    \ $number * $scale + $offset;\n  }, $numbers);\n}\n", "    $min_value = min($numbers);\n\
    \    $max_value = max($numbers);\n    if ($min_value == $max_value) {\n      \
    \  return $numbers;\n    }\n    $result = [];\n    for ($i = 0; $i < count($numbers);\
    \ $i++) {\n        $result[$i] = $numbers[$i] / $max_value * ($max_value - $min_value)\
    \ + $min_value;\n    }\n    return $result;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks for that, but I need a solution that works even when values are\
    \ out of order. My question is how to create a mapping from [1.0, 2.0] to  [0.0,\
    \ 0.33, 0.66, 1.0] and [2.0, 3.0] to [0.0, 0.33, 0.66, 1.0].\n<|/ c |>\n<| c |>\n\
    Ah, sorry, I misinterpreted your question. I just thought you were looking for\
    \ a more mathematical approach rather than a PHP based solution. Maybe you could\
    \ edit your question to include an example of the kind of input you would get\
    \ if you had the above array in mind?\n<|/ c |>\n<| c |>\nNo problem - I will\
    \ add an example and thanks for your help.\n<|/ c |>\n<| a |>\nIf you want a pure\
    \ PHP solution, I think this is the simplest approach:\n<code>", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n\n  $factor = $max - $min;\n  if ($factor != 0) {\n\
    \    // Normalize input to be between 0 and 1\n    $numbers -= $min;\n    $numbers\
    \ /= $factor;\n    $numbers *= $factor + 1e-5;\n  }\n\n  return $numbers;\n}\n",
  "  // If less than two elements, return unmodified\n  if (count($numbers) < 2) {\n\
    \    return $numbers;\n  }\n\n  // If all numbers are the same, return an array\
    \ with all elements set to 1\n  if ($numbers[0] == $numbers[1]) {\n    return\
    \ array_fill(1, count($numbers), 1);\n  }\n\n  // Determine minimum and maximum\
    \ values\n  $min = min($numbers);\n  $max = max($numbers);\n\n  // Calculate scale\n\
    \  $scale = 1.0 / ($max - $min);\n\n  // Return an array of all elements in the\
    \ array divided by their range, scaled to [0, 1]\n  return array_map(function\
    \ ($number) {\n    return $number / $scale;\n  }, $numbers);\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is exactly what I was looking for!  Thank you for the detailed\
    \ answer!\n<|/ c |>\n<| a |>\nFor a very quick fix you can do:\n<code>\n$array\
    \ = array(1, 3, 6, 7);\n$scale = (max($array) - min($array)) / max(1, count($array));\n\
    \nforeach ($array as $value) {\n    $array[$value] = (1 / $scale) * $value;\n\
    }\n</code>\n<|/ a dscore=2 tags=php,math,arrays |>\n<| c |>\nThe $scale variable\
    \ is undefined inside the foreach loop. Not an issue.\n<|/ c |>\n<| c |>\nI see,\
    \ edited my answer to account for the undefined variable.\n<|/ c |>\n<| a |>\n\
    You can just use array_sum() & array_diff() and array_combine() functions together\
    \ to get what you're looking for. \nHere I'm taking your sample array & just dividing\
    \ each element by it's index :\n<code>\n$array = array(1.0, 2.0, 3.0, 4.0, 5.0);\n\
    \n$arr1 = array_sum($array)/count($array);\n$arr2 = array_diff($array, array(array_sum($array)/count($array)));\n\
    $arr3 = array_combine(range(0,count($array)-1), $arr2);\n\nprint_r($arr3);\n</code>\n\
    <|/ a tags=php,math,arrays dscore=1 |>\n<| c |>\nNot a very good answer, if you\
    \ look at the expected output you'll see that it has many more values than what\
    \ is shown here\n<|/ c |>\n<| a |>\nIf you want every value in the array to be\
    \ divided by its index you can use the following. \n<code>\nforeach ($array as\
    \ $key => $value) {\n    $array[$key] = $value/$key\n}\n</code>\n<|/ a dscore=1\
    \ tags=php,math,arrays |>\n<| a ", "  $range = count($numbers) - 1;\n  if ($range\
    \ <= 0) {\n    return array($numbers[0]);\n  }\n  sort($numbers);\n  $center =\
    \ $range/2;\n  $scale = array();\n  foreach ($numbers as $i => $num) {\n    if\
    \ ($num > $center) {\n      $scale[$i] = $center - $num;\n    } else {\n     \
    \ $scale[$i] = 0;\n    }\n  }\n  return $scale;\n}\n", "\t$smallest = (is_array($numbers)\
    \ ? $numbers[0] : $numbers);\n\t$largest = (is_array($numbers) ? $numbers[1] :\
    \ $numbers);\n\tfor ($i = 2; $i < count($numbers); $i++) {\n\t\t$smaller_number\
    \ = ($numbers[$i - 1] < $smallest ? $numbers[$i - 1] : $smallest);\n\t\t$larger_number\
    \ = ($numbers[$i] > $largest ? $numbers[$i] : $largest);\n\t\t$numbers[$i] = ($larger_number\
    \ - $smaller_number) / $larger_number;\n\t}\n\treturn $numbers;\n}\n", "    return\
    \ array_map(function($number) {\n        return $number / (max($number) - min($number));\n\
    \    }, $numbers);\n}", "  $min_number = min($numbers);\n  $max_number = max($numbers);\n\
    \  if ($min_number == 0.0 && $max_number == 0.0) {\n    return $numbers;\n  }\n\
    \  // Linearly map the original numbers to new numbers (between 0 and 1).\n  $normalized_numbers\
    \ = array_map(\n    function ($number) {\n      return $number - $min_number;\n\
    \    },\n    $numbers\n  );\n  sort($normalized_numbers);\n  return array_map(\n\
    \    function ($number) {\n      return $min_number + ($max_number - $min_number)\
    \ * $number;\n    },\n    $normalized_numbers\n  );\n}", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n\n  return array_map(function ($num) use ($min, $max)\
    \ {\n    return ($num - $min) / ($max - $min);\n  }, $numbers);\n}", "  if (empty($numbers))\
    \ return array();\n  $min = min($numbers);\n  $max = max($numbers);\n\n  return\
    \ array($min == $max ? 0.0 : (($max - $min) / (1 - $min)) * (1.0 + $numbers[0]\
    \ / $numbers[1]));\n}\n", "    $min = min($numbers);\n    $max = max($numbers);\n\
    \    $numbers = array();\n\n    for ($i = 0; $i < count($numbers); $i++) {\n \
    \       $numbers[$i] = (float) ($numbers[$i] - $min) / ($max - $min);\n    }\n\
    \n    return $numbers;\n}\n", "    $min_value = min(array_values($numbers));\n\
    \    $max_value = max(array_values($numbers));\n    $range = array(0, 1);\n  \
    \  if ($max_value == 0) {\n        return $numbers;\n    }\n    $diff = abs($max_value\
    \ - $min_value);\n    if ($diff > 0.001) {\n        $range_len = pow(10, ceil(log10($diff)));\n\
    \        $range[$range_len] = $range[$range_len - 1] * $diff;\n    }\n    for\
    \ ($i = 0; $i < count($numbers) - 1; $i++) {\n        $number = $numbers[$i];\n\
    \        if ($min_value == $number) {\n            $numbers[$i] = 0.0;\n     \
    \   } else {\n            $numbers[$i] = $range[$number - $min_value];\n     \
    \   }\n    }\n    return $numbers;\n}\n\n/**\n * Helper method to generate a list\
    \ of words from a string.\n *\n * @param string $string The source string.\n *\
    \ @param int $max_words The maximum number of words.\n * @return array The generated\
    \ words.\n */", "  if (count($numbers) < 2) {\n    return $numbers;\n  }\n  sort($numbers);\n\
    \  $sum = array_sum($numbers);\n  $scaled_numbers = array();\n  for ($i = 0; $i\
    \ < count($numbers); $i++) {\n    $scaled_numbers[$i] = $numbers[$i] / $sum;\n\
    \  }\n  return $scaled_numbers;\n}\n", "    foreach ($numbers as $key => $number)\
    \ {\n        if ($number > 1 || $number < 0) {\n            $numbers[$key] = 1;\n\
    \        }\n    }\n    return $numbers;\n}\n", "    if (empty($numbers)) {\n \
    \       return [];\n    }\n    sort($numbers);\n    $min = array_shift($numbers);\n\
    \    $min = min($numbers);\n    foreach ($numbers as $i => $n) {\n        $numbers[$i]\
    \ = $n - $min;\n    }\n    return $numbers;\n}\n", "  // Rescale all numbers by\
    \ their common factor\n  $factors = array_shift($numbers);\n\n  foreach ($numbers\
    \ as $key => $value) {\n    $numbers[$key] *= $factors[$key];\n  }\n\n  return\
    \ $numbers;\n}\n\n", "    // Return empty array if empty list provided\n    if\
    \ (empty($numbers)) return [];\n\n    // Loop through all numbers and compare\
    \ with min/max value\n    $result = array();\n    foreach ($numbers as $number)\
    \ {\n        if ($number > array_sum($result)) {\n            $result[] = $number;\n\
    \        }\n        if ($number < array_sum($result)) {\n            $result[]\
    \ = $number;\n        }\n    }\n\n    // Convert array result to float array\n\
    \    return array_map('floatval', $result);\n}\n</code>\n<|/ a dscore=1 tags=php\
    \ |>\n<| a |>\nThe best and fastest way in terms of execution time is:\n<code>",
  "  if (!$numbers) {\n    return array();\n  }\n  sort($numbers);\n  $smallest =\
    \ array_shift($numbers);\n  $largest = array_pop($numbers);\n  $ratio = $largest\
    \ / $smallest;\n  $numbers = array_map(function ($n) use ($ratio) {\n    return\
    \ $ratio * $n;\n  }, $numbers);\n  return $numbers;\n}\n</code>\n<|/ a dscore=1\
    \ tags=php |>\n<| c |>\nI like the approach of not having to worry about scaling\
    \ the other numbers by any means, it gives me an idea of how it might be done\n\
    <|/ c |>\n<| c |>\nI added an example of the code I actually used to solve the\
    \ original problem\n<|/ c |>\n<| a dscore=1 |>\nFor your example, the following\
    \ works:\n<code>\n$array = [0.3, 0.3, 0.7, 0.3, 0.7];\n$array = array_map(function\
    \ ($a) { return $a * (100 / min(count($array), count($array))); }, $array);\n\
    print_r($array);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => 0\n    [1] =>\
    \ 0.25\n    [2] => 0.5\n    [3] => 0.75\n    [4] => 1\n)\n</code>\nDemo on 3v4l.org\n\
    <|/ a tags=php |>\n<| c |>\nI went with something similar, only I did not take\
    \ the min / max into account. Thanks though\n<|/ c |>\n<| a dscore=0 tags=php\
    \ |>\nI ended up having to do something like this:\n<code>", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  return array_map(function($value) use ($min, $max)\
    \ {\n    return ($value - $min) / ($max - $min);\n  }, $numbers);\n}\n", "  return\
    \ array_map(function ($number) use ($numbers) {\n    return min($number, array_sum($numbers));\n\
    \  }, $numbers);\n}\n", "  foreach ($numbers as $number) {\n    $numbers[$number]\
    \ = min($number, max($numbers));\n  }\n  return $numbers;\n}\n", "    $min_number\
    \ = min(array_values($numbers));\n    $max_number = max(array_values($numbers));\n\
    \n    $rescaled_numbers = array();\n    foreach ($numbers as $number) {\n    \
    \    $rescaled_numbers[] = $number / $max_number - $min_number;\n    }\n\n   \
    \ return $rescaled_numbers;\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nYou can try\
    \ using array_map() with lambda functions:\n<code>\n$numbers = array(1.0,2.0,3.0,4.0);\n\
    $numbers = array_map('divide', $numbers);\n</code>\nThe above snippet will output:\n\
    <code>\narray(0.75,1.5,2.25,3.0)\n</code>\nWhere divide is the name of the lambda\
    \ function (the 3rd parameter of array_map()).\n<|/ a tags=php,arrays,function,math\
    \ |>\n<| c |>\nThank you! That was an extremely simple and effective answer. array_map\
    \ was just the function I was looking for\n<|/ c |>\n<| c |>\nFor people that\
    \ need to convert from decimal to binary, this won't work since binary is base\
    \ 2. You'll need to convert to base 10.\n<|/ c |>\n<| a dscore=3 |>\nI like to\
    \ use array_reduce for these sorts of problems. It's a little cleaner than array_map.\n\
    <code>", "  sort($numbers);\n  $results = [];\n  $min = reset($numbers);\n  $max\
    \ = null;\n  foreach ($numbers as $n) {\n    $results[] = ($n - $min) / ($max\
    \ - $min);\n  }\n  return $results;\n}\n", "  return $numbers == null || count($numbers)\
    \ <= 1 ? $numbers : array_map(function ($x) {\n    return 0 === $x ? 0 : $x /\
    \ max(1, $x);\n  }, $numbers);\n}\n", "\t$smallest_number = min(array_map('floatval',\
    \ $numbers));\n\t$largest_number = max(array_map('floatval', $numbers));\n\tif\
    \ ($smallest_number == 0.0) {\n\t\treturn [0.0];\n\t}\n\tif ($largest_number ==\
    \ 0.0) {\n\t\treturn [1.0];\n\t}\n\treturn [$smallest_number / $largest_number];\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  return array_map(function\
    \ ($value) {\n    return $value / ($max - $min);\n  }, $numbers);\n}\n</code>\n\
    <|/ a dscore=0 tags=php,math |>\n<| a |>\nThis is my solution\n<code>\n<?php\n\
    /**\n *\n * $a\n * $b\n * int $precision\n * float\n */", "    $scale = array_shift($numbers);\n\
    \    foreach ($numbers as &$number) {\n        $number /= $scale;\n    }\n   \
    \ return $numbers;\n}\n", "    $min_num = min($numbers);\n    $max_num = max($numbers);\n\
    \    $number_range = $max_num - $min_num;\n    if ($number_range == 0) {\n   \
    \     return array_fill(0, count($numbers), 0.25);\n    }\n    return $numbers;\n\
    }\n</code>\n<|/ a dscore=5 tags=php,math |>\n<| a dscore=5 |>\nThe easiest way\
    \ would be to divide the numbers by the max value.\nExample:\n<code>\n$numbers\
    \ = [1.0, 2.0, 3.0, 4.0, 5.0];\n$max = max($numbers);\n$result = array_map(function($value)\
    \ use($max) { return $value / $max; }, $numbers);\n</code>\n<|/ a tags=php,math\
    \ |>\n<| a dscore=3 |>\nA linear transformation can be done like this:\n<code>",
  "  $scale = 1;\n  foreach ($numbers as $number) {\n    $scale *= $number;\n  }\n\
    \  return array_map(function ($number) { return $number / $scale; }, $numbers);\n\
    }\n", "  if (count($numbers) < 2) {\n    return $numbers;\n  }\n\n  // Get the\
    \ max value of all numbers in the list\n  $max = $numbers[0];\n  for ($i = 1;\
    \ $i < count($numbers); $i++) {\n    $max = $max > $numbers[$i] ? $max : $numbers[$i];\n\
    \  }\n\n  $scale = 1 / $max;\n  $result = [];\n  for ($i = 0; $i < count($numbers);\
    \ $i++) {\n    $result[] = $scale * $numbers[$i];\n  }\n  return $result;\n}\n\
    \n/**\n * Maps a function to all the elements of an array.\n *\n * @param callable\
    \ $callback The function to be invoked on each element of the array\n * @param\
    \ array    $arr     The array that needs to be transformed\n * @param array  \
    \  $...     Additional arguments to pass to the callback function\n *\n * @return\
    \ array\n * @see array_map()\n * @see shuffle()\n */", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  return array_map(function($number) {\n    return ($number\
    \ - $min) / ($max - $min);\n  }, $numbers);\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThis doesn't work if the array is of length 1. In this case the array\
    \ is of length 1 and the rescaled result is `[0]` instead of `[0.0]`\n<|/ c |>\n\
    <| c |>\nOkay, you're right. Will delete this answer. Thanks for pointing it out!\n\
    <|/ c |>\n<| c |>\nThe function will fail for numbers that are not numeric. e.g.\
    \ `[0.0]`, but `[0.0, \"a\", \"b\"]` should return `[0.0, \"a\", b\"]`\n<|/ c\
    \ |>\n<| c |>\nI don't think that's a valid case for `rescale_to_unit`. Please\
    \ check my updated answer.\n<|/ c |>\n<| a tags=arrays,php dscore=0 |>\nYou could\
    \ use array_walk to iterate over the array and apply a function to each element:\n\
    <code>\n$numbers = [1,2,3];\narray_walk($numbers, function(&$number){$number *=\
    \ 2;});\nprint_r($numbers);\n</code>\nThis outputs:\n<code>\nArray\n(\n    [0]\
    \ => 2\n    [1] => 4\n    [2] => 6\n)\n</code>\n<|/ a |>\n<| a dscore=0 tags=arrays,php\
    \ |>\n<code>\n$numbers = [1,2,3];\n$numbers = array_map(function($num){return\
    \ $num * 2;}, $numbers);\n</code>\narray_map\n\narray_map() calls a user supplied\
    \ callback function on each member of a\n  given array. The return of the callback\
    \ function is the value that\n  will be returned from the function.\n<|/ a |>\n\
    <| c |>\nNot sure why this got downvoted. It's more concise than my answer\n<|/\
    \ c |>\n<| c |>\nNot sure why you got downvoted. I also think it's more concise\
    \ but it's worth pointing out that the callback function is the anonymous function\
    \ so this may require PHP 5.3+ for the closure feature to work.\n<|/ c |>\n<|\
    \ c |>\nThanks, I have never seen it used like this before so I didn't know it\
    \ worked.\n<|/ c |>\n<| c |>\nNot sure why you got downvoted. I think it's more\
    \ concise but it's worth pointing out that the callback function is the anonymous\
    \ function so this may ", "    sort($numbers);\n\n    // Return an empty array\
    \ if we have no numbers\n    if (empty($numbers)) {\n        return array();\n\
    \    }\n\n    // Sum all the numbers together to avoid divide by zero\n    $sum\
    \ = array_sum($numbers);\n\n    // Find the smallest and largest number\n    $smallest\
    \ = reset($numbers);\n    $largest = end($numbers);\n\n    // Divide all the numbers\
    \ together by their sum\n    // This also avoids divide by zero and makes the\
    \ smallest number the smallest one\n    foreach ($numbers as $n => $val) {\n \
    \       $numbers[$n] = $val / $sum;\n    }\n\n    // Add the smallest number to\
    \ all the numbers that are left\n    array_walk($numbers, function(&$v) use ($smallest,\
    \ &$sum) {\n        $v += $smallest;\n    });\n\n    // Make sure the largest\
    \ number is now 1\n    $numbers[count($numbers) - 1] = 1;\n\n    return $numbers;\n\
    }\n", "  $min = min($numbers);\n  $max = max($numbers);\n  return array_map(function($x)\
    \ { return $x - $min; }, $numbers);\n}", "    $max_value = max($numbers);\n  \
    \  $min_value = min($numbers);\n    $range_factor = $max_value - $min_value;\n\
    \    $units_counter = count($numbers);\n\n    return array_map(function($num)\
    \ {\n        return round(($num - $min_value) / $range_factor);\n    }, $numbers);\n\
    }\n\n$results = array();\n$i = 1;\n$total = 0;\nforeach ($data as $item) {\n \
    \   $item2 = $item->toArray();\n\n    foreach ($item_attributes as $attribute)\
    \ {\n        $attr = intval($item2[$attribute]);\n        $attr = $attr == 1 ?\
    \ $attr : 0;\n\n        if ($attr !== 0) {\n            $total = $total + $attr;\n\
    \            $results[] = round($attr / $total);\n        }\n    }\n\n    $i++;\n\
    }\n\n$results = rescale_to_unit($results);\n$results = array_fill(0, count($results),\
    \ round($total * 100));\n$results[count($results) - 1] = 1;\n$results = array_fill_keys(array_keys($results),\
    \ $results);\n$results = array_map(function($num) {\n    return $num;\n}, $results);\n\
    \necho json_encode($results);\n</code>\nThis outputs:\n<code>\n[\n    [\n    \
    \    \"0\",\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\"\n \
    \   ],\n    [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\",\n\
    \        \"0\"\n    ],\n    [\n        \"0\",\n        \"0\",\n        \"0\",\n\
    \        \"0\",\n        \"0\"\n    ],\n    [\n        \"0\",\n        \"0\",\n\
    \        \"0\",\n        \"0\",\n        \"0\"\n    ],\n    [\n        \"0\",\n\
    \        \"0\",\n        \"0\",\n        \"0\",\n        \"0\"\n    ],\n    [\n\
    \        \"0\",\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\"\
    \n    ],\n    [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\"\
    ,\n        \"0\"\n    ],\n    [\n        \"0\",\n        \"0\",\n        \"0\"\
    ,\n        \"0\",\n        \"0\"\n    ],\n    [\n        \"0\",\n        \"0\"\
    ,\n        \"0\",\n        \"0\",\n        \"0\"\n    ],\n    [\n        \"0\"\
    ,\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\"\n    ],\n   \
    \ [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\",\n        \"\
    0\"\n    ],\n    [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"\
    0\",\n        \"0\"\n    ],\n    [\n        \"0\",\n        \"0\",\n        \"\
    0\",\n        \"0\",\n        \"0\"\n    ],\n    [\n        \"0\",\n        \"\
    0\",\n        \"0\",\n        \"0\",\n", "    $min_val = min(array_filter($numbers,\
    \ function ($item) {\n        return !is_nan($item);\n    }));\n    $max_val =\
    \ max(array_filter($numbers, function ($item) {\n        return !is_nan($item);\n\
    \    }));\n\n    if ($min_val == $max_val) {\n        return $numbers;\n    }\n\
    \n    return array_map(\n        function ($value) use ($min_val, $max_val) {\n\
    \            return $value * $min_val / $max_val;\n        },\n        $numbers\n\
    \    );\n}\n</code>\n<|/ a dscore=2 tags=php,arrays,min |>\n<| c |>\nThis solution\
    \ works only when the number of elements inside the array are exactly 2 or more.\
    \ I'm looking for a solution that works even if there are more elements inside\
    \ the array.\n<|/ c |>\n<| c |>\nThe code was made to be used with 2 or more elements,\
    \ even though I said \"of at least 2 elements\"\n<|/ c |>\n<| c |>\nI made a function\
    \ that will work with more than 2 elements too :)\n<|/ c |>\n<| a tags=php,arrays,min\
    \ dscore=2 |>\nJust found this solution\n<code>\n<?php", "  return array_map(\n\
    \    function($number) use ($numbers) {\n      return $number / min(array_values($numbers));\n\
    \    },\n    $numbers\n  );\n}", "  // Get min and max\n  $min_number = min($numbers);\n\
    \  $max_number = max($numbers);\n  // Make them equal if max < min\n  if ($max_number\
    \ < $min_number) {\n    $max_number = $min_number;\n  }\n  // Scale all the numbers\
    \ between the min and max\n  $scaled_numbers = array();\n  foreach ($numbers as\
    \ $number) {\n    $scaled_numbers[] = $number * ($max_number - $min_number) /\
    \ ($max_number + $min_number);\n  }\n  return $scaled_numbers;\n}\n</code>\nIf\
    \ you wanted to be able to pass in a number of elements, the code would look like\
    \ this:\n<code>\n<?php\n\n/**\n * Scale a list of numbers to fit between zero\
    \ and one.\n *\n * In other words, this function will take a list of numbers and\
    \ scale it between 0 and\n * 1.\n * \n * For example, given a list of numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0], this function will\n * return [0.0, 0.25, 0.5, 0.75,\
    \ 1.0].\n *\n * list\n *   A list of numbers.\n * int $numbers_per_group\n * \
    \  The number of numbers per group (optional, defaults to\n *   $numbers_per_group\
    \ = count($numbers)).\n *\n * list\n *   A list of numbers.\n */", "  assert(count($numbers)\
    \ > 0);\n  $min = $numbers[0];\n  $max = min($numbers);\n  return array_map(function\
    \ ($number) {\n    return $number / $max - $min;\n  }, $numbers);\n}\n", "  $min\
    \ = array_reduce($numbers, function ($min, $x) {\n    return $min > $x ? $min\
    \ : $x;\n  });\n  $max = array_reduce($numbers, function ($max, $x) {\n    return\
    \ $max < $x ? $max : $x;\n  });\n  return array_map(function ($x) use ($min, $max)\
    \ {\n    return $x - $min / $max;\n  }, $numbers);\n}\n", "  $min = $numbers[0];\n\
    \  $max = array_shift($numbers);\n  $range = array_sum($numbers);\n\n  if ($range\
    \ == 0.0) {\n    return $numbers;\n  }\n\n  return $numbers / $range;\n}", " \
    \ if (count($numbers) < 2) {\n    return $numbers;\n  }\n  $min = min($numbers);\n\
    \  $max = max($numbers);\n  // In case $min == $max, we avoid dividing by zero\n\
    \  if ($min == $max) {\n    return $numbers;\n  }\n  $scale = (($max - $min) /\
    \ count($numbers));\n  foreach ($numbers as &$number) {\n    $number *= $scale;\n\
    \  }\n  return $numbers;\n}\n", "    $min = min(array_map('intval', array_filter($numbers,\
    \ 'is_int')));\n    $max = max(array_map('intval', array_filter($numbers, 'is_int')));\n\
    \    return array_map(function ($num) use ($min, $max) {\n        return $num\
    \ / max($max - $min);\n    }, $numbers);\n}\n</code>\n<|/ a dscore=3 tags=php,arrays,rounding,math\
    \ |>\n<| c |>\nThanks so much for this! I implemented it slightly differently\
    \ to take account of floats greater than 1.0 but otherwise works like a charm.\
    \ Thanks a million!\n<|/ c |>\n<| a tags=php,arrays,rounding,math |>\nI prefer\
    \ to use fmod, because the second method doesn't require you to define the min\
    \ and max values in advance.\n<code>", "  $min = min($numbers);\n  $max = max($numbers);\n\
    \  $scale = 1.0;\n  if ($max != $min) {\n    $scale = ($max - $min) / max(1, count($numbers));\n\
    \  }\n  return array_map(function ($n) use ($scale) {\n    return round($n * $scale);\n\
    \  }, $numbers);\n}\n", "  return array_map(function($x) {\n    return $x / min($numbers);\n\
    \  }, $numbers);\n}\n", "    if (!count($numbers)) {\n        return [];\n   \
    \ }\n    $min_number = min($numbers);\n    $max_number = max($numbers);\n    if\
    \ ($min_number == $max_number) {\n        return $numbers;\n    }\n    $scale\
    \ = ($max_number - $min_number) / (count($numbers) - 1);\n    return array_map(function\
    \ ($number) {\n        return round(($number - $min_number) * $scale);\n    },\
    \ $numbers);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nIt should be noted that\
    \ this function does **NOT** always return an array of integers. Some numbers\
    \ are mapped to zero, some to 1, and some to 0.5. The function only returns integers\
    \ when all numbers have the same value, which may or may not be the case. I had\
    \ a situation where the numbers were all 0, so my function returned an array of\
    \ 0.\n<|/ c |>\n<| c |>\n: Good point!\n<|/ c |>\n<| a tags=php |>\n<code>\n<?php\n",
  "    $min = min(array_map(function($n) { return $n; }, $numbers));\n    $max = max(array_map(function($n)\
    \ { return $n; }, $numbers));\n    return array_map(function($n) use ($min, $max)\
    \ {\n        return $n / $max - $min + $min;\n    }, $numbers);\n}\n</code>\n\
    <|/ a tags=php,arrays |>\n<| c |>\nWorks very well! Thank you! I was struggling\
    \ to write a function which could handle the array differently, and this was the\
    \ solution that worked out well in my situation.\n<|/ c |>\n<| c |>\nI've added\
    \ an update to the function to handle cases where the numbers aren't integers,\
    \ e.g. `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/\
    \ c |>\n<| c |>\nThanks! I didn't notice that before, but that definitely simplifies\
    \ the function a lot.\n<|/ c |>\n<| a |>\nAnother one \n<code>", "    if (count($numbers)\
    \ <= 1) {\n        return $numbers;\n    }\n    $min = $numbers[0];\n    $max\
    \ = max($numbers);\n    if ($min == $max) {\n        return $numbers;\n    }\n\
    \    $size = count($numbers) / 2;\n    $numbers = array_map(function ($x) { return\
    \ $x / $size; }, $numbers);\n    return array_combine($numbers, $numbers);\n}\n",
  "    if (count($numbers) <= 1) {\n        return $numbers;\n    }\n\n    $min_number\
    \ = min($numbers);\n    $max_number = max($numbers);\n\n    return array_map(function\
    \ ($number) use ($min_number, $max_number) {\n        return ($number - $min_number)\
    \ / ($max_number - $min_number);\n    }, $numbers);\n}\n", "    $min = min($numbers);\n\
    \    $max = max($numbers);\n\n    if ($min == $max) {\n        return array($min);\n\
    \    }\n\n    $scale = ($max - $min);\n    $offset = ($min * 0);\n\n    $new_numbers\
    \ = array();\n    foreach ($numbers as $number) {\n        $new_numbers[] = $offset\
    \ + $number / $scale;\n    }\n\n    return $new_numbers;\n}", "  $scale = array_shift($numbers);\n\
    \  $rescaled = array();\n  foreach ($numbers as $number) {\n    $rescaled[] =\
    \ $number / $scale;\n  }\n  return $rescaled;\n}", "    foreach ($numbers as &$number)\
    \ {\n        if ($number < 0.0) $number = 0.0;\n        if ($number > 1.0) $number\
    \ = 1.0;\n    }\n    return $numbers;\n}\n", "    return array_map(function($n)\
    \ {\n        return $n * (1.0 - 1.0 / max(1, count($numbers)));\n    }, $numbers);\n\
    }\n", "    assert(is_array($numbers));\n    $min = min($numbers);\n    $max =\
    \ max($numbers);\n    return array_map(\n        function($value) use ($min, $max)\
    \ {\n            return $value - $min;\n        },\n        $numbers\n    );\n\
    }\n</code>\n<|/ a tags=php |>\n<| a tags=php dscore=0 |>\n<code>\nclass arrayExtentions\
    \ {\n\n    public static function array_sort($array){\n        array_multisort(\n\
    \            array_map(function($v){\n                return $v;\n           \
    \ }, $array),\n            SORT_ASC\n        );\n        return $array;\n    }\n\
    }\n\n$array = [1,2,3,4,5,6,7,8,9,0];\n$newArr = arrayExtentions::array_sort($array);\n\
    print_r($newArr);\n\nOutput :\nArray\n(\n    [0] => 0\n    [1] => 0\n    [2] =>\
    \ 0\n    [3] => 0\n    [4] => 0\n    [5] => 0\n    [6] => 0\n    [7] => 0\n  \
    \  [8] => 0\n    [9] => 0\n)\n</code>\n<|/ a |>\n<| a |>\nThis is my solution:\n\
    <code>\n<?php\n\n$numbers = [\n    2,\n    3,\n    5,\n    7,\n    8,\n    9,\n\
    \    11,\n];\n\nsort($numbers);\n\n$smallest = min($numbers);\n$largest = max($numbers);\n\
    \nvar_dump($smallest, $largest);\n</code>\nThe result:\n<code>\nint(2)\nint(11)\n\
    </code>\n<|/ a dscore=0 tags=php |>\n<| a dscore=0 |>\n<code>", "    return array_map(\n\
    \        function ($number) {\n            return max(0, min(1, $number));\n \
    \       },\n        $numbers\n    );\n}\n", "  // If there is only one number,\
    \ return it unchanged\n  if (count($numbers) == 1) {\n    return $numbers[0];\n\
    \  }\n  // If there is only one element, make it the only number\n  if (count($numbers)\
    \ == 0) {\n    return [1.0, 0.0];\n  }\n\n  // Find the minimum and maximum values\
    \ first\n  $min_value = min($numbers);\n  $max_value = max($numbers);\n\n  //\
    \ Create an array of the numbers where the minimum value is zero\n  // and the\
    \ maximum value is one.\n  $zero_one_values = array_map('round', array_fill(0,\
    \ count($numbers)-1, $max_value));\n\n  // Create an array of the numbers where\
    \ the minimum value is one\n  // and the maximum value is zero.\n  $one_zero_values\
    \ = array_map('round', array_fill(0, count($numbers)-1, $min_value));\n\n  //\
    \ Calculate the scaling factor for each element in the array\n  $scales = array();\n\
    \  foreach ($zero_one_values as $key => $value) {\n    $scales[$key] = $value\
    \ / max($one_zero_values);\n  }\n\n  // Apply the scaling to each element in the\
    \ array\n  $result = array();\n  foreach ($numbers as $key => $value) {\n    $result[$key]\
    \ = $value * $scales[$key];\n  }\n\n  return $result;\n}\n", "  $min = min($numbers);\n\
    \  $max = max($numbers);\n  return array(0, (1 - $min) / ($max - $min));\n}\n\
    </code>\n<|/ a dscore=1 tags=php,math |>\n<| c |>\nThat seems really close, I'm\
    \ going to try it out now.\n<|/ c |>\n<| c |>\nIt doesn't seem to be working for\
    \ me when I implement the function into my code.\n<|/ c |>\n<| c |>\nIt should\
    \ be noted that this will likely be slower than the other answers.\n<|/ c |>\n\
    <| c |>\nYeah I doubt that it would be faster but this answer should work on any\
    \ number. Also the one on the other answers would fail on the edge case where\
    \ all numbers are negative.\n<|/ c |>\n<| a dscore=1 |>\nYou can use logarithm\
    \ to get log of every number and divide it by log 2 of total elements to get the\
    \ percentage\n<|/ a tags=php,math |>\n<| a |>\nHere is a quick way to do this\
    \ in Python\n<code>\ndef rescale_range(numbers):\n    numbers_array = []\n   \
    \ for number in numbers:\n        numbers_array.append(number)\n    numbers_array.sort()\n\
    \    number_sum = float(sum(numbers_array))\n    if number_sum > 0:\n        return\
    \ numbers_array\n    else: \n        number_sum = number_sum + 1\n        return\
    \ numbers_array + [number_sum]\n</code>\n<|/ a tags=php,math dscore=0 |>\n<| c\
    \ |>\nThis does work, however it seems like it only takes every second number\
    \ into the equation. I need it to take every even number into the equation.\n\
    <|/ c |>\n<| c |>\nOh, I thought you had every even number in there, sorry.\n\
    <|/ c |>\n<| c |>\nOk, I changed my answer to do that.\n<|/ c |>\n<| a tags=php,math\
    \ |>\nHere is another way to do it using PHP:\n<code>", "    foreach ($numbers\
    \ as &$number) {\n        $number = ($number / min(abs($number), 1.0)) * 1.0;\n\
    \    }\n    return $numbers;\n}\n", "    $min_number = min(array_map('floatval',\
    \ array_fill(0, count($numbers), NULL)));\n    return array_map(function ($num)\
    \ use ($min_number) {\n        return $num / $min_number;\n    }, $numbers);\n\
    }\n\n/**\n * Given a percentage value, return a float between 0 and 1\n * that\
    \ represents how far along one axis we can go\n * given the minimum axis length\
    \ and the maximum axis length\n * \n * E.g., if min=1, max=10, axis=10\n * we\
    \ can go from 0 to 1, 0 to 2, 0 to 3, 0 to 4, 0 to 5, 0 to 6, 0 to 7, 0 to 8 and\
    \ 0 to 9\n * \n * @param float $percentage percentage value to map to 0 to 1\n\
    \ * @param float $min minimum axis length\n * @param float $max maximum axis length\n\
    \ * @return float percentage value between 0 and 1\n */", "  // make sure all\
    \ numbers have a valid value, if not, return empty array\n  foreach($numbers as\
    \ $number) {\n    if ($number == NULL || $number == FALSE || !is_numeric($number))\
    \ {\n      return [];\n    }\n  }\n\n  // find the smallest and largest numbers\
    \ in the list\n  $min = min($numbers);\n  $max = max($numbers);\n\n  // calculate\
    \ the scaling factor between the smallest and largest values\n  $scale = 1.0 /\
    \ ($max - $min);\n\n  // return an array with all of the numbers in the list scaled\
    \ to the min and max values\n  return array_map('intval', array_map(function($number)\
    \ { return $number * $scale; }, $numbers));\n}\n", "    if (count($numbers) <\
    \ 2)\n        return $numbers;\n\n    // Find the smallest number\n    $smallest\
    \ = min($numbers);\n\n    // Find the largest number\n    $largest = max($numbers);\n\
    \n    // Find the difference between the smallest and the largest number\n   \
    \ $range = $largest - $smallest;\n\n    // Now create a list with the smallest\
    \ and largest number multiplied by the difference\n    $result = [];\n    $index\
    \ = 0;\n    foreach ($numbers as $number)\n        $result[$index++] = $smallest\
    \ * ($number / $range);\n\n    return $result;\n}\n</code>\n<|/ a dscore=5 tags=arrays,php\
    \ |>\n<| a |>\nThis works nicely:\n<code>", "  if (count($numbers) < 2) {\n  \
    \  return $numbers;\n  }\n  $min = min($numbers);\n  $max = max($numbers);\n \
    \ if ($min == 0.0) {\n    $min = max($numbers);\n  }\n  return array_map(function\
    \ ($num) use ($min, $max) {\n    return $num * $max / $min + 0.5;\n  }, $numbers);\n\
    }\n", "  if (count($numbers) < 2)\n    return $numbers;\n\n  // Sort $numbers\
    \ into descending order\n  rsort($numbers);\n\n  $min = reset($numbers);\n  $max\
    \ = end($numbers);\n\n  // Calculate the slope (derivative) of $min and $max\n\
    \  $slope = $max == 0 ? 0 : ($max - $min) / (count($numbers) - 1);\n\n  // Apply\
    \ slope to $numbers returning the new list of numbers\n  return array_map(function($number)\
    \ use ($slope) {\n    return $slope * $number + $min;\n  }, $numbers);\n}\n",
  "  foreach ($numbers as $key => $number) {\n    $numbers[$key] = abs($number);\n\
    \  }\n  $max_number = max($numbers);\n  $min_number = min($numbers);\n  return\
    \ array_map(function ($number) {\n    return $number / $max_number * 2 - 1;\n\
    \  }, $numbers);\n}\n\n/**\n * Rescale an array of numbers from [0 .. 1] to [0\
    \ .. 1].\n *\n * @param array $numbers Numbers to rescale\n * @return array Rescaled\
    \ numbers\n */"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
