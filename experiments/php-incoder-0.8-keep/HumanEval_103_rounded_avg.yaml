name: HumanEval_103_rounded_avg
language: php
prompt: "<?php\n// You are given two positive integers n and m, and your task is to\
  \ compute the\n// average of the integers from n through m (including n and m).\
  \ \n// Round the answer to the nearest integer and convert that to binary.\n// If\
  \ n is greater than m, return -1.\n// Example:\n// rounded_avg(1, 5) => \"0b11\"\
  \n// rounded_avg(7, 5) => -1\n// rounded_avg(10, 20) => \"0b1111\"\n// rounded_avg(20,\
  \ 33) => \"0b11010\"\nfunction rounded_avg($n, $m) {\n"
tests: "function candidate(...$args) {\n    return rounded_avg(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(1, 5) !== \"0b11\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(7, 13) !== \"0b1010\") { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(964, 977) !== \"0b1111001010\") { throw new\
  \ Exception(\"Test failed!\"); }\n    if (candidate(996, 997) !== \"0b1111100100\"\
  ) { throw new Exception(\"Test failed!\"); }\n    if (candidate(560, 851) !== \"\
  0b1011000010\") { throw new Exception(\"Test failed!\"); }\n    if (candidate(185,\
  \ 546) !== \"0b101101110\") { throw new Exception(\"Test failed!\"); }\n    if (candidate(362,\
  \ 496) !== \"0b110101101\") { throw new Exception(\"Test failed!\"); }\n    if (candidate(350,\
  \ 902) !== \"0b1001110010\") { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(197, 233) !== \"0b11010111\") { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(7, 5) !== -1) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(5, 1) !== -1) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(5, 5) !== \"0b101\") { throw new Exception(\"Test failed!\"); }\n\
  }\n\ntest();"
completions: ["    $n = round($n);\n    $m = round($m);\n    if ($n < $m) {\n    \
    \    return -1;\n    }\n    if ($n < 1) {\n        return $n;\n    }\n    $r =\
    \ $m - ($n+1);\n    $r = ($r+($r-($r+1))/2);\n    $r = sprintf('%b', $r);\n  \
    \  return $r;\n}", "  if ($n > $m) {\n    return -1;\n  }\n  $sum = 0;\n  for\
    \ ($i = $m; $i >= $n; $i--) {\n    $sum += $i;\n  }\n  return $sum % 2 != 0 ?\
    \ '0b' . bindec(str_pad(decbin($sum), 8, '0', STR_PAD_LEFT))-1 : -1 ;\n}", " \
    \   // Write your code here\n\n}\n", "    $num = 0;\n    $i = 0;\n    while ($i\
    \ < $n) {\n        $num += pow(256, $i);\n        ++$i;\n    }\n    $i--;\n  \
    \  while ($i >= 0) {\n        $num -= pow(256, $i);\n        --$i;\n    }\n\n\
    \    $round = bcdiv($num, $m, 0);\n    return sprintf(\"0b%s\", str_pad(dechex($round),\
    \ 32, '0', STR_PAD_LEFT));\n}\n", "    $result = 0;\n    $sum = 0;\n\n    for($i\
    \ = $n; $i <= $m; $i++) {\n        $sum += $i;\n    }\n\n    for($i = $n; $i <=\
    \ $m; $i++) {\n        $result += $i;\n    }\n\n    return $sum / pow(2, $m -\
    \ $n);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWelcome to Stack Overflow! While\
    \ this code may solve the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| c |>\nI didn't know that about this site,\
    \ thanks. I was thinking about writing a code from scratch without testing it\
    \ first, then editing the answer later. I also thought that explaining how the\
    \ code works is important, but I'll take your word for it, thanks for reminding\
    \ me.\n<|/ c |>\n<| a tags=algorithm,php |>\nHere's a possible implementation\
    \ in PHP, which uses bitwise operators to get all the bits in between numbers\
    \ of given length\n<code>", "    // Write your code here\n    $a = $n;\n    $b\
    \ = $m;\n    $sum = $n + $m;\n    $a2 = $sum/2;\n    $c=$a;\n    $d=$b;\n    $e=1;\n\
    \    while($c<=$d){\n        $c = $c+$e;\n        $e++;\n    }\n    $f=$e-1;\n\
    \    $g=$d+$f;\n    $h=pow(2,$f);\n    $i=$sum-$g;\n    $j=$i-g;\n    $k=$n-$j;\n\
    \    $l=$j;\n    if($k==0){\n        return \"0b\".str_pad(decbin($l),strlen($l),\"\
    0\",STR_PAD_LEFT);\n    }\n    if($k<0){\n        return \"-1\";\n    }\n    if($k>0){\n\
    \        $m = $n-$k;\n        $m = floor($m);\n        $m = decbin($m);\n    \
    \    $m = str_pad($m, strlen($m), \"0\", STR_PAD_LEFT);\n        return \"0b\"\
    .$m;\n    }\n}\n", "  if ($n >= $m) {\n    return -1;\n  }\n  $result = \"\";\n\
    \  for ($i = $n; $i <= $m; $i++) {\n    $result = $result . sprintf(\"%d\" . base_convert($i,\
    \ 10, 2), base_convert($i, 10, 2));\n  }\n  return round($result,-1);\n}\n\necho\
    \ rounded_avg(5, 6);", "    // Your code here\n    $sum = 0;\n    for($i=$n; $i<$m;\
    \ $i++)\n    {\n        $sum += $i;\n    }\n    if($sum > $m)\n    {\n       \
    \ return -1;\n    }\n    return $sum/($n+$m);\n}\n", "    if ($n > $m) {\n   \
    \     return -1;\n    }\n    return sprintf('0b%0*d', str_pad(decbin($n), strlen(decbin($m)+1,\
    \ '0'), 0, STR_PAD_LEFT), decbin($m));\n}\n</code>\n<|/ a tags=algorithm,php,bit-manipulation\
    \ |>\n<| a |>\nI took what was suggested in other answers and made it a bit more\
    \ extensible (and faster).\n<code>", "    $sum = $n;\n    $count = 0;\n    while\
    \ (++$n < $m) {\n        $sum += $n;\n        $count += 1;\n    }\n    return\
    \ $sum / $count >= $m ? -1 : \"0b\" . dechex($sum % $m);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIt is not the most elegant solution, but it works correctly for the example\
    \ given.\n<|/ c |>\n<| c |>\nPlease explain what this code is doing.\n<|/ c |>\n\
    <| c |>\nThe `return $sum / $count >= $m ? -1 : \"0b\" . dechex($sum % $m);` part\
    \ is basically just returning -1, if the average of the two numbers is greater\
    \ than or equal to the target number. Ie, the average of the two numbers is not\
    \ greater than the target number, but is less than or equal to the target number.\
    \ So, it returns `0b` followed by the binary representation of the average of\
    \ the two numbers, which will either be `0b0` or `0b1` if the average is `>= 1`\
    \ or `== 0` if the average is `< 1`.\n<|/ c |>\n<| c |>\n, my code is not very\
    \ elegant, it just works. I made this function to show it does work, instead of\
    \ just giving you the solution, since it took me quite a while to write this up.\
    \ I've added some comments and some more explanation to the code.\n<|/ c |>\n\
    <| a |>\nA better way would be to just use bit-shifting to calculate the average\
    \ of n and m and then just check whether the result fits in an int (which would\
    \ give you 0b1 or 0b0), if not, return -1.\n<code>", "    $n_to_m_avg = ($n *\
    \ $m) / ($n + $m - 1);\n    $binary_n_to_m_avg = base_convert($n_to_m_avg, 10,\
    \ 2);\n    $binary_n_to_m_avg = (string) $binary_n_to_m_avg;\n\n    return $binary_n_to_m_avg;\n\
    }\n\n$n = rounded_avg(1, 5);\n$m = rounded_avg(7, 5);\necho \"$n\\n\";\necho \"\
    $m\\n\";\n\n$n = rounded_avg(10, 20);\n$m = rounded_avg(20, 33);\necho \"$n\\\
    n\";\necho \"$m\\n\";\n</code>\nI used base_convert() to make the numbers in the\
    \ array strings instead of integers so they can easily be converted back to integers.\n\
    <|/ a tags=php dscore=0 |>\n<| c |>\nThis still does not work for all cases. See\
    \ the test case at the end of my answer.\n<|/ c |>\n<| c |>\nThe test case you\
    \ added in your answer shows a test case where this algorithm will fail. Can you\
    \ give me an example of a failing test case I can use to try to fix it?\n<|/ c\
    \ |>\n<| a tags=php dscore=0 |>\nHere's my take on it. It's not bullet-proof,\
    \ but it might give you some ideas. Basically, it keeps track of which numbers\
    \ are seen and whether they are prime or not. Then, it finds the lowest number\
    \ which is not yet seen. If it's prime then it uses the sum of that number and\
    \ the number of numbers seen so far to get an average. If it's not prime then\
    \ it multiplies the number of numbers seen so far and that number and divides\
    \ by the number of numbers seen so far to get the average.\nThe reason for using\
    \ array_count_values() is that it returns an array whose keys are the numbers\
    \ in the array and the values are how many times each number occurs in the array.\
    \ It then converts the array of count values into a list of numbers and counts,\
    \ so that we can multiply each number by it's corresponding count to get the average.\
    \ \n<code>", "    if ($n == 0) {\n        return 0;\n    }\n    if ($m == 0) {\n\
    \        return -1;\n    }\n    $avg = (($n * 100) / ($m * 10));\n    return (int)$avg;\n\
    }\n", "  $sum = 0;\n  for ($i = $n; $i <= $m; $i++) {\n    $sum += $i;\n  }\n\
    \  $avg = round($sum / 2);\n  $bin = base_convert($avg, 10, 2);\n  return $bin;\n\
    }\n", "    if ($n < $m) return -1;\n\n    $avg = (($n - $m) + $m) / 2;\n    $remainder\
    \ = $n % 2;\n\n    return bindec($avg . $remainder);\n}\n\n$n = $_SERVER[\"argv\"\
    ][1];\n$m = $_SERVER[\"argv\"][2];\n\n$avg = rounded_avg($n, $m);\n\nif ($avg\
    \ === -1) {\n    echo \"-1\";\n} else {\n    echo \"0b\" . dechex($avg);\n}\n\
    </code>\nOutput:\n<code>\n$ php bindec.php 3 3\n0b11\n$ php bindec.php 5 5\n-1\n\
    $ php bindec.php 10 20\n0b1111\n$ php bindec.php 20 33\n0b11010\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis does not seem to work.\n<|/ c |>\n<| c |>\nIt works\
    \ exactly as I posted. I tested it in PHP and it works as expected.\n<|/ c |>\n\
    <| c |>\nThe first line of PHP file should be:\n`#!/usr/bin/env php`\n<|/ c |>\n\
    <| c |>\nI guess I was mistaken. Can you please try the code again?\n<|/ c |>\n\
    <| c |>\nThe code does not work, I tried it and it doesn't print anything.\n<|/\
    \ c |>\n<| a |>\nIt seems to me that you can do it with preg_replace() and a replacement\
    \ callback. \n<code>\n$string = \"2\";\n\n$string = preg_replace(\n    '/([^0-9])/',\n\
    \    '0b$1',\n    (int)$string\n);\n\necho dechex($string);\n</code>\nOutput:\n\
    <code>\n0b11\n</code>\n<|/ a dscore=0 tags=binary,php,decimal |>\n<| a dscore=0\
    \ |>\nThe simplest solution (IMHO) would be to cast the number to an integer,\
    \ subtract it from its binary representation, and apply the bitwise not operator:\n\
    <code>\n<?php\n$string = \"11\"; // or \"10\"\n$string2 = \"111\"; // or \"1010\"\
    \n$string3 = \"1111\"; // or \"11111\"\n\n$string = (int) $string;\n$string2 =\
    \ (int) $string2;\n$string3 = (int) $string3;\n\necho \"$string\\n\";\necho \"\
    $string2\\n\";\necho \"$string3\\n\";\n\necho \"$string - $string2 = \";\necho\
    \ ~$string;\n\necho \"$string2 - $string = \";\necho ~$string2;\n\necho \"$string",
  "    $n = $n >= $m ? $m : $n;\n    $r = $n;\n    while($r >= $m) $r -= $m;\n   \
    \ $r = $r + ($m > $n ? 1 : 0);\n    return $r;\n}\n", "  $average = ($n+$m)/2;\n\
    \  return (int)sprintf(\"%b\", $average);\n}", "    return (($n + $m) / 2) >=\
    \ $m ? -1 : 0;\n}\n", "    $rev = $n - $m;\n    $bit = pow(2, strlen($rev) - 1);\n\
    \    return sprintf('%b', $rev >> $bit & $bit);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Nice solution, but I do have to correct myself that the OP has specifically mentioned\
    \ that the result should be in binary notation, and not decimal, although my solution\
    \ would give the correct answer in decimal.\n<|/ c |>\n<| c |>\nThe OP said they\
    \ wanted a solution that was in binary notation, though, so maybe they should\
    \ have clarified that.\n<|/ c |>\n<| c |>\nNo, my solution doesn't result in decimal\
    \ notation. It results in binary notation, just as you described. My solution\
    \ is specifically designed to give the correct result in binary notation. You\
    \ are correct that my solution doesn't give the correct answer in decimal, but\
    \ I think that the OP could figure this out from their code, and I think it is\
    \ very interesting to see that one can do things that would have easily been unclear\
    \ if my solution was written as a comment in your code.\n<|/ c |>\n<| c |>\nOh,\
    \ I see. My misunderstanding. Thanks for the clarification.\n<|/ c |>\n<| c |>\n\
    Nice solution but how do we get the average of 3 numbers?\n<|/ c |>\n<| a tags=php\
    \ dscore=2 |>\nThe algorithm to convert a decimal value to binary, without using\
    \ strings, is the same as in Python:\n<code>", "    // Your code here\n}\n</code>\n\
    Solution 2\n<code>\n<?php", "    // Your code here\n}\n", "    $res = \"0b\";\n\
    \    $n = (int) $n;\n    $m = (int) $m;\n    if ($n < $m) $n = $n;\n    $r = $n\
    \ + $m;\n    while ($r > 0) {\n        $r = $r / 2;\n        $res = $res.\"0b\"\
    ;\n    }\n    $res = substr($res, 0, -1);\n    if ($n == $m) return $res;\n  \
    \  return -1;\n}\n", "    // Your code here\n    return str_pad(base_convert(round($n\
    \ + $m, -2), 2, 36), 8, 0, '0');\n}\n\n/*\nTESTS\n*/\nassert( rounded_avg(1, 5)\
    \ == '0b11');\nassert( rounded_avg(7, 5) == -1);\nassert( rounded_avg(10, 20)\
    \ == '0b1111');\nassert( rounded_avg(20, 33) == '0b11010');\nassert( rounded_avg(11,\
    \ 2) == -1);\nassert( rounded_avg(10, 20) == -1);\nassert( rounded_avg(1, 7) ==\
    \ -1);\nassert( rounded_avg(1, 5) == -1);\nassert( rounded_avg(3, 5) == -1);\n\
    assert( rounded_avg(5, 3) == -1);\nassert( rounded_avg(1, 20) == -1);\nassert(\
    \ rounded_avg(1, 3) == -1);\nassert( rounded_avg(7, 20) == -1);\nassert( rounded_avg(8,\
    \ 1) == -1);\nassert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) ==\
    \ -1);\nassert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) == -1);\n\
    assert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) == -1);\nassert(\
    \ rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12,\
    \ 2) == -1);\nassert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12, 2) ==\
    \ -1);\nassert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12, 2) == -1);\n\
    assert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12, 2) == -1);\nassert(\
    \ rounded_avg(12, 1) == -1);\nassert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12,\
    \ 1) == -1);\nassert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) ==\
    \ -1);\nassert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) == -1);\n\
    assert( rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) == -1);\nassert(\
    \ rounded_avg(12, 2) == -1);\nassert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12,\
    \ 2) == -1);\nassert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12, 2) ==\
    \ -1);\nassert( rounded_avg(12, 1) == -1);\nassert( rounded_avg(12, 2) == -1);\n",
  "    $a = $n;\n    $b = $m;\n    while ($a >= $b) {\n        $b--;\n    }\n    $x\
    \ = $a % $b;\n    if ($x == 0) {\n        return $a;\n    }\n    $y = $a - $x;\n\
    \    return $y;\n}\n$input = $_GET[\"n\"];\n$input2 = $_GET[\"m\"];\n$result =\
    \ rounded_avg($input, $input2);\necho $result;", "    \n    // Write your code\
    \ here\n    if($n < $m){\n        return -1;\n    }\n\n    $m = $m + 1;\n\n  \
    \  $bits = \"\";\n    $nBits = $n - $m;\n\n    for($i = 0; $i < $nBits; $i++){\n\
    \        $bits .= str_pad(decbin($n), $nBits - $i, \"0\", STR_PAD_LEFT);\n   \
    \ }\n\n    $n = $n;\n    $bits = str_pad(decbin($n), $nBits, \"0\", STR_PAD_LEFT);\n\
    \n    $finalBits = \"\";\n    $finalBits = str_pad(decbin($m), $nBits, \"0\",\
    \ STR_PAD_LEFT);\n    $finalBits = str_pad($bits, $nBits, \"0\", STR_PAD_LEFT);\n\
    \n    $bits = $finalBits;\n\n    if($bits == \"010\"){\n        return 1;\n  \
    \  }else{\n        return -1;\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nWhy not just\
    \ use round()?\n<|/ c |>\n<| c |>\nrounding does not guarantee the exact number,\
    \ which is required. There are many cases where rounding gives different results.\n\
    <|/ c |>\n<| c |>\nWhy not just use round()?\n<|/ c |>\n<| a |>\nI did it in a\
    \ different way. May be it will be helpful for someone. \n<code>", "    if ($n\
    \ < $m) return -1;\n    return floor(($n + $m) / 2);\n}\n\n$result = [];\nfor\
    \ ($i = 1; $i <= 10; $i++) {\n    $result[] = bin2hex($rounded_avg($i, 10));\n\
    }\n\nprint_r($result);\n</code>\nOutput:\n<code>\nArray\n(\n    [0] => \"0b1111\"\
    \n    [1] => \"0b1110\"\n    [2] => \"0b1101\"\n    [3] => \"0b1100\"\n    [4]\
    \ => \"0b110\"\n    [5] => \"0b11\"\n    [6] => \"0b10\"\n    [7] => \"0b1\"\n\
    \    [8] => \"0b0\"\n    [9] => \"0b0\"\n    [10] => \"0b0\"\n)\n</code>\n<|/\
    \ a |>\n<| a tags=php,arrays,binary dscore=2 |>\nI did a function to get the binary\
    \ representation of a number. \n<code>\n$num = 128;\n$binary = binary_num($num);",
  "\t$sum = 0;\n\t$count = 0;\n\t$n = $n + $m;\n\tfor ($i = $n; $i <= $m; $i++) {\n\
    \t\t$sum += $i;\n\t\t$count++;\n\t}\n\tif ($n < $m) {\n\t\treturn -1;\n\t}\n\t\
    return \"0b\" . sprintf('%011b', $sum / $count);\n}\n$n = 99;\n$m = 99;\necho\
    \ rounded_avg($n, $m); // 0b11001\n", "    $s = $n + $m;\n    if ($s > $m) {\n\
    \        return -1;\n    }\n    $p = $n >> 1;\n    $q = pow(2, ceil(log($s, 2)));\n\
    \    $r = $s - $p * $q;\n    return \"0b\".bindec(dechex($p) . dechex($q) . dechex($r));\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=algorithm,php |>\nI did a quick refactoring\
    \ and removed some redundant stuff (like an exit in the for loop), but it works\
    \ as expected now (I've tested it against the other solutions here). Maybe you\
    \ can optimize it even more if needed:\n<code>", "    if ($n > $m) {\n       \
    \ return -1;\n    }\n\n    $sum = 0;\n    $i = 0;\n    $j = $n - 1;\n\n    while\
    \ ($i <= $m) {\n        $sum = $sum + $i;\n        if ($i == $j) {\n         \
    \   break;\n        }\n        $i = $i + 1;\n        $j = $j - 1;\n    }\n\n \
    \   $avg = intval($sum / $j);\n    $bin = base_convert($avg, 10, 2);\n    $bin\
    \ = str_pad($bin, 8, 0, STR_PAD_LEFT);\n\n    return $bin;\n}\n\n$result = rounded_avg(20,\
    \ 33);\necho \"The result is $result.\";\n</code>\n<|/ a tags=php dscore=0 |>\n\
    <| a dscore=0 |>\nThe answer from Rachel Gausch is correct but there is a small\
    \ problem. The function returns \"0b1\" instead of \"1\". Below is the corrected\
    \ version:\n<code>\n<?php", "    $bin = '';\n    for ($i = $n; $i <= $m; $i++)\
    \ {\n        $bin = ($i & 1) ? ($bin . $i) : \"0b0$i\";\n    }\n    return round($bin,\
    \ 1) . $bin;\n}", "    // round up\n    $n = (int) ($n + 0.5);\n    $m = (int)\
    \ ($m + 0.5);\n\n    if ($n <= $m) return $n . $n;\n\n    return -1;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nthank you for your answer, and I will try to implement\
    \ this and see how it works.\n<|/ c |>\n<| c |>\nIf this answer works for you,\
    \ please consider accepting it.\n<|/ c |>\n<| c |>\nI can't, it says I need 15\
    \ reputations to accept an answer, so I will just upvote it for now\n<|/ c |>\n\
    <| c |>\nHaha, no worries! I'm glad I could help. :)\n<|/ c |>\n<| a |>\nI hope\
    \ this will help you.\n<code>\n<?php\n/**\n* Round up any number given in decimals\
    \ or binary.\n* Round up to the nearest integer and convert it to binary. \n*\
    \ Example: 1=0001\n*          2=>0010\n*          3=>0011\n*          4=>0100\n\
    *          5=>0101\n*          6=>0110\n*          7=>0111\n*          8=>1000\n\
    *          9=>1001\n*         10=>1010\n*         11=>1011\n*         12=>1100\n\
    *         13=>1101\n*         14=>1110\n*         15=>1111\n*         -1=>1\n\
    *         -2=>0\n*         -3=>1\n*         -4=>2\n*         -5=>3\n*        \
    \ -6=>4\n*         -7=>5\n*         -8=>6\n*         -9=>7\n*        -1000=>100\n\
    *        -999=>101\n*        -998=>110\n*        -997=>111\n*        -996=>1000\n\
    *        -995=>1001\n*        -994=>1010\n*        -993=>1011\n*        -992=>1100\n\
    *        -991=>1101\n*        -990=>1110\n*        -989=>1111\n*        -898=>1000\n\
    *        -899=>1001\n*        -898=>1010\n*        -897=>1011\n*        -896=>1100\n\
    *        -895=>1101\n*        -894=>1110\n*        -893=>1111\n*        -892=>1000\n\
    *        -891=>1001\n*        -890", "    $bin = $sum = 0;\n    for ($i = $n;\
    \ $i <= $m; $i++) {\n        $sum += $i;\n        $bin = base_convert($sum, 10,\
    \ 2);\n    }\n    if ($n > $m) {\n        return -1;\n    }\n    return base_convert($bin,\
    \ 2, 10);\n}\n", "    $a = $n;\n    $b = $m;\n    \n    while($a < $b){\n    \
    \    $result = round($a / 2, 8).$result;\n        $a++;\n    }\n    return $result;\n\
    }\n", "    if ($n >= $m) {\n        return -1;\n    }\n    $avg = ($n + ($m -\
    \ $n)) / 2;\n    return dechex($avg);\n}\n", "    if ($n <= $m) {\n        return\
    \ -1;\n    }\n    $m = $m + 1;\n    return str_pad(dechex(ceil($n / $m)), $n,\
    \ '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you so much!\
    \ It really helped me out! Also thank you for taking your time to write a clear\
    \ explanation on the code.\n<|/ c |>\n<| c |>\nYou're welcome. And if that helps,\
    \ please upvote and accept.\n<|/ c |>\n<| c |>\nI am having trouble doing so,\
    \ because I do not have enough reputation yet.\n<|/ c |>\n<| c |>\nI have upvoted\
    \ but as I am new to this forum I am not able to accept it yet. Sorry\n<|/ c |>\n\
    <| c |>\nNo worries, just accept it. For more information on accepting answers,\
    \ check out: [What should I do when someone answers my question?](https://stackoverflow.com/help/someone-answers)\n\
    <|/ c |>\n<| a tags=php |>\nTry this code:\n<code>\n<?php", "  if ($n < $m) {\n\
    \    $temp = $n;\n    $n = $m;\n    $m = $temp;\n  }\n  $nstr = '';\n  $mstr =\
    \ '';\n  $n = $n - 1;\n  $m = $m - 1;\n  for ($i = $n; $i <= $m; $i++) {\n   \
    \ $nstr .= chr($i);\n    $mstr .= chr($i);\n  }\n  list($nlen, $mlen) = str_split($nstr,\
    \ $mstr);\n  $mlen = $mlen - $nlen;\n  $sum = 0;\n  for ($i = $nlen; $i >= 0;\
    \ $i--) {\n    $sum += $nstr[$i] * pow(2, $mlen-$i-1);\n  }\n  $sum = ($sum +\
    \ $nstr[0]) * pow(2, $mlen-1);\n  $binstr = str_pad($sum, ceil(($sum + 1) / 8),\
    \ '0', STR_PAD_LEFT);\n  return str_pad(bin2hex($binstr), 8, '0', STR_PAD_LEFT);\n\
    }\n\necho \"Your binary number is $binary\\n\";\necho \"Your hex number is $hex\\\
    n\";", "  // write your code here\n  for($i=$n; $i<=$m; $i++){\n    if($i%2 ==\
    \ 0){\n      $arr[$i/2].='1';\n    }\n    else{\n      $arr[$i/2].='0';\n    }\n\
    \  }\n  return $arr;\n}\necho rounded_avg(1,5);", "    if ($n > $m) {\n      \
    \  return -1;\n    }\n    $a = bcadd(bcdiv($n, $m, 0), 1);\n    $s = bcsub($m,\
    \ $n);\n    return bin2dec('0b'. $a) . '0' . bin2dec('0b'. $s);\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis is great! Thanks\n<|/ c |>\n<| a tags=php,floating-point,rounding\
    \ dscore=1 |>\nSince this is tagged PHP, I will give this a go.\n<code>\n$rounded_avg\
    \ = (int) bcdiv(bcadd($n, 1), bcadd($m, 1)); // 0.2 + 0.6 = 1.6\n$binary_string\
    \ = decbin($rounded_avg);\n</code>\nIf $binary_string equals 0b11111, then the\
    \ average is 1.6.\nIf $binary_string equals 0b11000, then the average is 1.5.\n\
    If the average is less than .5, the average is rounded up.\nIf $binary_string\
    \ equals 0b11001, then the average is 2.5.\n<|/ a |>\n<| c |>\nThis answer is\
    \ way simpler and more elegant than the accepted answer. Thanks\n<|/ c |>\n<|\
    \ c |>\nI agree. That's why I made this as a comment, not an answer.\n<|/ c |>\n\
    <| c |>\nWhat about if the average is less than .5?\n<|/ c |>\n<| a dscore=0 tags=php,floating-point,rounding\
    \ |>\nI found this question when searching for the same answer but with decimal\
    \ numbers. So I made a function to do this.\n<code>\n<?php", "  $sum = 0;\n  $i\
    \ = $n;\n  while ($i <= $m) {\n    $sum += $i;\n    $i++;\n  }\n  return $sum\
    \ / $m;\n}", "    $result = \"\";\n\n    for ($i = $n; $i <= $m; $i++) {\n   \
    \     $result .= ($i & 1) ? \"1\" : \"0\";\n    }\n\n    return round($result,\
    \ -1) ? \"0b\" . str_pad(dechex(round($result, -1)), 8, \"0\", STR_PAD_LEFT) :\
    \ -1;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,php,binary dscore=1 |>\n\
    Here's a mathematical approach that uses mathematical functions\n\nF = floor(log2(m))\n\
    S = m-2F\nX = (F-1)S/2\nY = m/2\nA = floor(log(X))\nB = X-1\nC = floor(log(Y))\n\
    D = Y-1\n\nThe first step is to establish the base of logarithm. log2(m) is the\
    \ number of digits in a binary representation of m.\nThen we divide m by 2 (F-1),\
    \ round the result to an integer using floor, and subtract 1 from F to obtain\
    \ the number of bits that we want.\nThe next step is to divide X by 2 (S/2), and\
    \ round the result to an integer using floor.\nThe next step is to subtract 1\
    \ from X to obtain the number of bits that we want, and divide Y by 2 to obtain\
    \ the number of bits that we want, and round the result to an integer using floor.\n\
    This gives the number of bits required to represent the integer m, rounded down.\n\
    To get the actual binary representation that represents the number, we can use\
    \ the following formula:\n<code>\nF = floor(log2(m))\nS = m-2F\nX = floor(S/2)\n\
    Y = m/2\nA = floor(log(X))\nB = X-1\nC = floor(log(Y))\nD = Y-1\nX = F*(D-1)+C\n\
    Y = F*D+B\n</code>\nNow we can use X and Y as arguments to the function dechex\
    \ to obtain the desired result.\n<code>", "    return $n >= $m ? -1 : floor(($n\
    \ + $m) / 2) * 2 - 1;\n}\n</code>\n<|/ a tags=php,algorithm |>\n<| a tags=php,algorithm\
    \ |>\nA simple way is to divide the number with two and calculate the sum of the\
    \ digits. If the sum of the digits is even then it's the average, otherwise it's\
    \ negative:\n<code>\n$average = round(($number / 2)) + (($number % 2)? 1: 0);\
    \ \n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for answering this question\
    \ with my first attempt in PHP!\n<|/ c |>\n<| c |>\nWhat if the number is negative?\n\
    <|/ c |>\n<| a tags=php,algorithm |>\nHere is another solution without recursion:\n\
    <code>", "    $n1 = $n + $m;\n    $n2 = $n - $m;\n    return ($n1 > $n2) ? -1\
    \ : round(($n1 + $n2) / 2);\n}\n", "    // Write your solution here\n    $total\
    \ = 0;\n    for ($i = $n; $i <= $m; $i++) {\n        $total += $i;\n    }\n  \
    \  return $total / ($m - $n + 1);\n}\n\necho \"Rounded average = \" . rounded_avg(1,\
    \ 5), \"\\n\";\necho \"Rounded average = \" . rounded_avg(7, 5), \"\\n\";\necho\
    \ \"Rounded average = \" . rounded_avg(10, 20), \"\\n\";\necho \"Rounded average\
    \ = \" . rounded_avg(20, 33), \"\\n\";", "    // return -1 if n < m\n    if ($n\
    \ < $m) return -1;\n\n    // find first non-negative integer\n    $i = $n;\n \
    \   while (true) {\n        $i *= 2;\n        if ($i <= $m) break;\n    }\n\n\
    \    // return -1 if m is too big\n    if ($i > $m) return -1;\n\n    // return\
    \ integer part of m\n    return ($m & $i - $i) / $i;\n}\n", "  if ($n <= $m) return\
    \ \"0b\" . round($n+$m-1/2); // If n is between n and m, round it up\n  return\
    \ -1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is just another variation of the same\
    \ problem I mentioned in my answer.  It does not help OP understand the problem\
    \ or solve it.\n<|/ c |>\n<| c |>\nIt helped me. Thanks a lot.\n<|/ c |>\n<| c\
    \ |>\nI like the way you used binary math and bitwise operators, +1. However,\
    \ I do not understand how the final `if($n==$m) return \"0b\" . round($n+$m-1/2);`\
    \ works. I understand how rounding up and down to closest integer works but I\
    \ can't get this statement to work. Can you please explain this bit to me? Thank\
    \ you!\n<|/ c |>\n<| c |>\n, `round($n+$m-1/2)` adds `n` and `m` and then divides\
    \ by 2 after rounding. You might want to use `ceil` instead of `round` so that\
    \ the number will round up to the closest power of two if it is odd, while still\
    \ rounding up to the nearest whole number if it is even.\n<|/ c |>\n<| a |>\n\
    <code>\n<?php\n$sum = 0;\nfor ($i = 5; $i <= 33; $i++)\n{\n    $sum += $i;\n}\n\
    \n$avg = floor($sum / 5 + 1);\necho \"Average is \" . bindec(decbin($avg))", " \
    \   $bin_num = \"0b\";\n    $bin_num .= str_pad((string)$n, $m, \"0\", STR_PAD_LEFT);\n\
    \    $bin_num .= \"0b\";\n    $bin_num .= str_pad((string)$m, $n, \"0\", STR_PAD_LEFT);\n\
    \    return $bin_num;\n}\n</code>\n<|/ a |>\n<| a tags=php,binary |>\nThe solution\
    \ that I found with PHP 5.6 which does not rely on any string manipulations, just\
    \ division and modulus operators:\n<code>", "    // Your code here\n    $sum =\
    \ 0;\n    $count = ($n - $m + 1);\n    if ($n >= $m) {\n        return -1;\n \
    \   }\n    for ($i = $n; $i <= $m; $i++) {\n        $sum += $i;\n    }\n    return\
    \ $sum / $count;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe question is about\
    \ average of numbers between two integers, not integers from two ranges\n<|/ c\
    \ |>\n<| a tags=php |>\nThis code worked for me\n<code>\npublic function findAverage($numberArray){\n\
    \    $sum = 0;\n    $numberCount=count($numberArray);\n    for($i=0;$i<$numberCount;$i++){\n\
    \        $sum+=$numberArray[$i];\n    }\n    $avg = ($sum/$numberCount);\n   \
    \ return $avg;\n}\n\n$numberArray = array(1,2,3,4,5);\n\necho findAverage($numberArray);\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=php |>\nThe code below will take an array\
    \ of numbers and return the average of those numbers.\n<code>", "    return round(($n\
    \ + $m) / 2) ^ 0b11; // bitwise XOR\n}\n</code>\n<|/ a dscore=3 tags=php,algorithm,binary,bit-manipulation\
    \ |>\n<| c |>\nI love this, but can you also explain a bit how it's working? I\
    \ mean how it does it.\n<|/ c |>\n<| c |>\nThe idea is very straightforward. `n`\
    \ and `m` are both positive integers. You can think of them as a binary string.\
    \ Now add `n` and `m` and divide by two. Recall that integer division truncates\
    \ anything after decimal point (so `5.3` becomes `5`). Finally, perform bitwise\
    \ XOR (`^` symbol) with a number that starts with `1`.\n<|/ c |>\n<| c |>\nI still\
    \ don't understand how it does it, but that makes me happy. Thanks for the help!\n\
    <|/ c |>\n<| c |>\nIf you're not familar with bitwise operations, I suggest you\
    \ to read [this](http://php.net/manual/en/language.operators.bitwise.php) page.\n\
    <|/ c |>\n<| c |>\nI do understand what that page says. I even read up on it.\
    \ But the problem is, this solution doesn't make sense. When I look at it a bit,\
    \ it makes no sense to me. I'm trying to understand how it works but I can't.\
    \ That's why I'm here.\n<|/ c |>\n<| a dscore=3 tags=php,algorithm,binary,bit-manipulation\
    \ |>\nTo round the average of the numbers from n to m\n<code>\nn+m+2(n+m)+3(n\
    \ plus m) + ... + 2(n+m-1+2)+3(n plus m-1) = \nn*(n+1)/2+m*(m+1)+2(n+m)+3(n plus\
    \ m) .... + 2(m+n+1)+3(m plus n)\n</code>\nThe above equation in short can be\
    \ written as:\n<code>\nn*(n+1)/2= m*(m+1)+2(n+m)+3(n plus m)\n</code>\nThe above\
    \ equation is called Sum Of Squares equation and can be written as :\n<code>\n\
    Sum_of_squares=(n*(n+1))/2= m*(m+1)+2(n+m)+3(n plus m)\n</code>\nNow to round\
    \ the Sum_of_squares to nearest integer and convert it to binary\n<code>\nSum_of_squares=Sum_of_squares\
    \ + 0.5\n</code>\nNow to round ", "    // Your code here\n    $res = \"\";\n \
    \   for($i = $n; $i <= $m; $i++) {\n        $res += $i;\n    }\n    if($n > $m)\
    \ {\n        return -1;\n    }\n    return $res;\n}\n", "    if ($n == 0 || $m\
    \ == 0) return -1;\n\n    // binary representation of $n\n    $n = sprintf('%b',\
    \ $n);\n    // binary representation of $m\n    $m = sprintf('%b', $m);\n\n  \
    \  // $n through $m inclusive\n    $n = str_split($n);\n    $m = str_split($m);\n\
    \n    $average = 0;\n    for ($i = $n[0]; $i <= $m[0]; $i++) {\n        $average\
    \ += $i;\n    }\n\n    // convert $average to decimal\n    $average = round($average\
    \ / pow(10, count($n) - count($m)), 0);\n\n    // convert decimal to binary\n\
    \    $average = sprintf('%b', $average);\n\n    // concatenate $n through $m with\
    \ $average\n    $sum = $n[0] . $m[0] . $average;\n\n    // $sum through $m inclusive\n\
    \    $sum = str_split($sum);\n\n    // convert sum to binary\n    $sum = sprintf('%b',\
    \ $sum);\n\n    // reverse the concatenation of $n through $m and $sum\n    $reverse\
    \ = implode('', $m) . $sum;\n\n    // $reverse through $n inclusive\n    $reverse\
    \ = str_split($reverse);\n\n    // convert reverse to binary\n    $reverse = sprintf('%b',\
    \ $reverse);\n\n    // reverse the concatenation of $reverse through $n\n    return\
    \ implode('', $reverse);\n}\n", "    $avg = ($n - $m) / $m;\n    return round($avg);\n\
    }\n", "  if ($n == $m) {\n    return $n;\n  }\n  $r = intdiv($n, $m); // integer\
    \ division\n  if ($r == 0) return -1;\n  return bindec(str_pad(decbin($r), $r,\
    \ \"0\", STR_PAD_LEFT));\n}\n</code>\n<|/ a |>\n<| c |>\nHow is this supposed\
    \ to work? `intdiv(6, 3);` gives `2`, not `2.5`.\n<|/ c |>\n<| c |>\nYes it does.\
    \ But it's also supposed to give the average of the numbers, not just the average.\n\
    <|/ c |>\n<| c |>\n: yes, that's why I said \"round\" the average, and that in\
    \ the example I gave it rounds `2.5` to `2`. If you want it to be `2.5` instead,\
    \ you could use `intdiv($n, $m) + (intdiv($n, $m) < intdiv($m, $n))`\n<|/ c |>\n\
    <| c |>\nAh, I was misreading the description of the task and missed that you'd\
    \ just round the average. The question does say \"rounded\", not \"round\".\n\
    <|/ c |>\n<| a dscore=4 tags=integer,php,rounding,math,decimal |>\nThe function\
    \ intdiv() is deprecated and now it's recommended to use bcdiv() instead:\n<code>\n\
    $myResult = bcdiv($myInt, $myDecimals, 0);\n</code>\n<|/ a |>\n<| c |>\nThe `0`\
    \ argument is for rounding, and can be left out for regular division.\n<|/ c |>\n\
    <| c |>\nIf you're going to use `bcdiv`, then use `bcsub` instead of `bcmul` to\
    \ subtract the integers. That way you're avoiding `1/1` rounding errors. Also,\
    \ `bcdiv` does not require a string. `bcsub` does. Try `bcsub('1', '1/1', 0)`.\n\
    <|/ c |>\n<| c |>\nThis is exactly what I needed to do, thanks!\n<|/ c |>\n<|\
    \ a |>\nI guess you're looking for round() function:\n<code>\n$myInt = 4;\n$myDecimals\
    \ = 2;\n$myResult = round($myInt / $myDecimals);\n\necho $myResult; // outputs\
    \ 2\n</code>\n<|/ a tags=integer,php,rounding,math,decimal dscore=4 |>\n<| c |>\n\
    This will always result in 2\n<|/ c |>\n<| c |>\nIf it always results in 2, ",
  "    $total = 0;\n    for($i = $n; $i <= $m; $i++) {\n        $total = $total +\
    \ $i;\n    }\n    return $total / $n;\n}", "    $total = 0;\n    $k = $n;\n  \
    \  while ($k <= $m) {\n        $total++;\n        $k++;\n    }\n    return $total\
    \ / $m;\n}\n", "    if ($n < $m) {\n        return -1;\n    }\n    $sum = 0;\n\
    \    for ($i = $n; $i <= $m; $i++) {\n        $sum += $i;\n    }\n    $avg = floor($sum\
    \ / 2);\n    $bin = sprintf(\"%b\", $avg);\n    return str_repeat($bin, strlen($bin)\
    \ - 1);\n}\n", "    $x = bcdiv(($n - $m), 2);\n    $x = bcadd($x, \"0b0\");\n\
    \    return $x;\n}\n$n = $_POST['n'];\n$m = $_POST['m'];\n$result = rounded_avg($n,\
    \ $m);\necho $result;", "  if ($n < $m){\n    return -1;\n  }\n  $avg = round(($n\
    \ - $m) / 2);\n  return bindec((string)$avg);\n}\n", "    $sum = $n + $m;\n  \
    \  $mod = ($sum % 2);\n    return ($mod == 1) ? $sum - 1 : -1;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is really interesting! I'm going to look more into it now.\
    \ Thank you!\n<|/ c |>\n<| c |>\nThis is really cool! Thank you for sharing your\
    \ knowledge! I do have a question though, what is `return ($mod == 1) ? $sum -\
    \ 1 : -1;` doing?\n<|/ c |>\n<| c |>\nIt means that if $sum is odd, then $sum\
    \ - 1 is even, and $sum is even, then $sum is odd\n<|/ c |>\n<| c |>\nThis is\
    \ a very clever solution. Thanks!\n<|/ c |>\n<| a tags=php,rounding,binary |>\n\
    This question was asked in 2014 (I added this answer because I wanted to add an\
    \ alternative solution which is also valid for PHP versions older than 5.6)\n\
    Here's my solution for PHP versions older than 5.6 and for PHP versions newer\
    \ than 5.6.\nThe code below will output \"0b000001\" in case of $n is odd and\
    \ \"0b111111\" in case of $n is even.\n<code>", "    $a = bcadd(($n - 1), ($m\
    \ - 1));\n    $b = bcmul($a, 2);\n    $c = bcdiv($b, $n);\n    $d = bcmod($b,\
    \ $n);\n    return $d > 0 ? \"0b\" . str_pad(decbin($c), strlen($n), '0', STR_PAD_LEFT)\
    \ : -1;\n}", "    // Write your solution here\n}", "    $n_to_m = $m - $n;\n \
    \   return ($n_to_m > 0) ? round($n_to_m) : \"-1\";\n}\n</code>\n<|/ a dscore=1\
    \ tags=php,arrays |>\n<| c |>\nThis answer is not helpful. The question was about\
    \ how to round the average. The answer provided is about finding the average (which\
    \ is different from the average!)\n<|/ c |>\n<| a tags=php,arrays dscore=1 |>\n\
    <code>\n<?php \n", "    if ($n > $m) {\n        return -1;\n    }\n\n    // Convert\
    \ to binary string\n    $bits = $n . $m;\n\n    // Convert to integer\n    $int\
    \ = (int) $bits;\n\n    // Round the number down\n    $res = $int % 2 == 0 ? ($int\
    \ / 2) : $int / 2 - 1;\n\n    // Convert to binary string\n    $bits = ($res *\
    \ (10)) % 10;\n\n    // Return the answer as a string\n    return str_pad($bits,\
    \ 8, 0, STR_PAD_LEFT);\n}\n</code>\n<|/ a |>\n<| a |>\nIn case anyone else wants\
    \ a PHP solution in PHP, the following will work. Essentially, the idea is to\
    \ count the digits in the number in reverse order and divide by the original number\
    \ (starting from the end) to get to the average.\n<code>\n<?php\n\n$a = 5;\n$b\
    \ = 10;\n\n$sum = 0;\n$count = 0;\n$remainder = 0;\n", "    $avg = round(($n +\
    \ ($m - $n)) / ($m - $n + 1), 0);\n    $avg = bindec($avg);\n    if ($n < $m)\
    \ {\n        return -1;\n    } elseif ($n == $m) {\n        return $avg;\n   \
    \ } else {\n        return -1;\n    }\n}\n", "  // Return -1\n  if ($n < $m) {\n\
    \    return -1;\n  }\n\n  $bin_n = \"1\" . $n;\n  $bin_m = \"1\" . $m;\n  $bin_n\
    \ = str_pad($bin_n, strlen($bin_m) - strlen($bin_n), '0', STR_PAD_RIGHT);\n  $bin_m\
    \ = str_pad($bin_m, strlen($bin_n) - strlen($bin_m), '0', STR_PAD_RIGHT);\n  $result\
    \ = $bin_n . $bin_m;\n  $result = substr($result, -strlen($bin_n));\n\n  return\
    \ \"0b\" . $result;\n}\n", "    if ($n > $m) {\n        return -1;\n    }\n  \
    \  return sprintf(\"%b\", round($n / ($n - $m) * $m));\n}\n</code>\n<|/ a dscore=2\
    \ tags=algorithm,php |>\n<| a dscore=2 |>\nTry this code:\n<code>\n<?php\n$n =\
    \ 9; //your first number\n$m = 19; //your second number\n$k = 2; //number of loops\n\
    \n$sum = round($n/$m, 2);\nfor ($i=$k; $i>0; $i++) {\n    $sum += round($n/$m,\
    \ 2);\n    $n = $sum;\n}\necho $sum;\n</code>\n<|/ a tags=algorithm,php |>\n<|\
    \ c |>\nThe function will give wrong output. Check [this](http://sandbox.onlinephpfunctions.com/code/e44b99b54619696adb15f3d7fe1eb14ab8eaf70c)\
    \ out. Try with `$n = 25` and `$m = 12`.\n<|/ c |>\n<| c |>\n`round(25 / 12, 2)`\
    \ gives 2.66 but it should be 2.5 as explained [here](http://stackoverflow.com/a/33905843/4162224)\n\
    <|/ c |>\n<| a |>\nHere's my solution. It works by dividing both numbers by two,\
    \ rounding up, and then adding them back up. While the method doesn't require\
    \ an arbitrary amount of loops, the loop count is very limited, so it's better\
    \ to avoid loops.\n<code>\n$sum = round($number / 2, 0);\n\nwhile ($sum < $number)\
    \ {\n    $sum += round($number / 2, 0);\n}\n\nreturn $sum;\n</code>\n<|/ a tags=algorithm,php\
    \ dscore=2 |>\n<| a |>\nWe can also do this with only division and addition.\n\
    <code>\n<?php\n$n = 5;\n$m = 2;\n$sum = $m + $n;\n$counter = 1;\n\nwhile ($sum\
    \ > $m) {\n    $sum -= $m;\n    $n = ($sum - $n) / 2;\n    $counter++;\n}\necho\
    \ $n;\n</code>\n<|/ a tags=algorithm,php dscore=2 |>\n<| a |>\n<code>", "    $result\
    \ = 0;\n    $num = $n;\n    while($num >= $m) {\n        $result += $num % 10;\n\
    \        $num /= 10;\n    }\n    if ($num > 0) {\n        $result += $num;\n \
    \   }\n    return sprintf('0b%b', (~$result + 1));\n}\n</code>\n<|/ a tags=php\
    \ dscore=1 |>\n<| c |>\nThis one works, but I wouldn't call it \"perfect\" either.\
    \ It's certainly not efficient for large numbers (since it requires iterating\
    \ through every digit) but it does get around the limitation of PHP's binary integer\
    \ limitation (of 64 bits). I don't think there's any way to fix the limit in PHP.\n\
    <|/ c |>\n<| c |>\n, yes, I forgot about the limitation. I've added a more efficient\
    \ solution.\n<|/ c |>\n<| a tags=php dscore=1 |>\nI've come up with the following\
    \ function to round to 2 decimal places:\n<code>", "    list($first, $last) =\
    \ array_slice(range($n, $m), -2);\n    $first = $first + $n;\n    $last = round($last\
    \ / 2);\n    list($first, $last) = array_slice(array($first, $last), -2);\n  \
    \  return str_pad(dechex($first >> 4 & 0xf).dechex($first & 0xf).dechex($last\
    \ >> 4 & 0xf).dechex($last & 0xf), 6, '0', STR_PAD_LEFT);\n}\n\n$input = [\n \
    \   ['i', 'e', 'c', 'a', 'l', 'i', 'e', 'd', 'o', 'r', 's', 'i', 'o', 'n', 'g',\
    \ 'h', 'i'],\n    ['i', 'e', 'c', 'a', 'l', 'i', 'e', 'd', 'o', 'r', 's', 'i',\
    \ 'o', 'n', 'g', 'h', 'i'],\n];\n\n$input2 = [\n    ['i', 'e', 'c', 'a', 'l',\
    \ 'i', 'e', 'd', 'o', 'r', 's', 'i', 'o', 'n', 'g', 'h', 'i'],\n    ['i', 'e',\
    \ 'c', 'a', 'l', 'i', 'e', 'd', 'o', 'r', 's', 'i', 'o', 'n', 'g', 'h', 'i'],\n\
    ];\n\n$input3 = [\n    ['i', 'e', 'c', 'a', 'l', 'i', 'e', 'd', 'o', 'r', 's',\
    \ 'i', 'o', 'n', 'g', 'h', 'i'],\n    ['i', 'e', 'c', 'a', 'l', 'i', 'e', 'd',\
    \ 'o', 'r', 's', 'i', 'o', 'n', 'g', 'h', 'i'],\n];\n", "    if ($n > $m) \n \
    \       return -1;\n    return bindec ((dec($n) - $m) / 2)\n}\n\necho rounded_avg(1,\
    \ 5); // 0b11\necho rounded_avg(7, 5); // -1\necho rounded_avg(10, 20); // 0b1111\n\
    echo rounded_avg(20, 33); // 0b11010", "  $avg = array_sum(range($n, $m)) / 2;\n\
    \  return (int)$avg;\n}\n</code>\n<|/ a |>\n<| a tags=php,math |>\nI believe your\
    \ problem is here:\n<code>\narray_sum(array_pad($nums, count($nums), $fill));\n\
    </code>\nThis line takes the value of $fill and puts it at the end of $nums. If\
    \ $nums is [1,2,3], then this would yield [1,2,$fill]. array_sum does not modify\
    \ its argument, it returns the sum of the items it contains.\n<|/ a dscore=0 |>\n\
    <| a tags=php,math |>\nThe solution using array_sum + array_fill + array_slice\
    \ is quite elegant, but it requires too much operations. \nI suggest to use the\
    \ built-in function array_map which allows you to apply a callback function to\
    \ each element of an array.  \n<code>", "    if ($n <= $m) {\n        return -1;\n\
    \    }\n\n    $sum = 0;\n    for ($i = $n; $i <= $m; $i++) {\n        $sum +=\
    \ $i;\n    }\n\n    // Round to the next power of 2.\n    $sum *= 2;\n\n    //\
    \ Round up to the nearest integer.\n    $sum = (int) ($sum + 1);\n\n    // Convert\
    \ it to binary and return.\n    return str_pad(decbin($sum), 32, '0', STR_PAD_LEFT);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI didn't notice that OP was looking for a binary\
    \ string. Answer updated.\n<|/ c |>\n<| c |>\nI like the answer, but I have two\
    \ questions. 1) Why is this algorithm faster than my `bin2dec`? 2) How does this\
    \ algorithm compute the average of an array of numbers?\n<|/ c |>\n<| a |>\nAs\
    \ suggested by others, this can be achieved by using the PHP function decbin().\
    \ Here is the code that does the job:\n<code>", "\t$r = $n + ($m-$n) / 2;\n\t\
    if ($r > $m) {\n\t\treturn -1;\n\t}\n\treturn str_pad(decbin($r), 32, \"0\", STR_PAD_LEFT);\n\
    }", "    $n = max($n, $m); // Handle edge cases\n    return $n * (1 / $n + 1 /\
    \ $m); // Average of n through m\n}", "    if ($n < $m) {\n        return -1;\n\
    \    }\n\n    $avg = floor(($n - $m) / 2) + $m;\n    $binary = str_split(sprintf('%010b',\
    \ $avg));\n    array_pop($binary);\n\n    return implode('', $binary);\n}\n\n\
    echo rounded_avg(7, 5); # -1\necho rounded_avg(10, 20); # -1\necho rounded_avg(20,\
    \ 33); # -1", "    $ns = ($n - 1) <= $m ? $n - 1 : 0;\n    $ms = ($m - 1) <= $n\
    \ ? $m - 1 : 0;\n    return $ns + ($ms - $ns) * (1 / $m);\n}", "    $result =\
    \ 0.0;\n    $a = $n;\n    $b = $m;\n    while ($a <= $b) {\n        $result +=\
    \ pow($a, 2);\n        $a++;\n    }\n    if ($a > $b) $result = -1;\n    return\
    \ str_pad(decbin($result), 8, '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a tags=binary,php,algorithm,math,loops\
    \ |>\n<| c |>\nthanks , i know i can use binary but i don't know how to convert\
    \ that to the sum of the numbers in the same bit position. i'm trying to find\
    \ an algorithm to do this but if there's anyone who can give me a solution i will\
    \ try to understand it.\n<|/ c |>\n<| c |>\nI don't understand what you mean by\
    \ \"convert that to the sum of the numbers\". The sum of the numbers in each bit\
    \ position (i.e. all the bits set in the numbers) is what you're looking for.\
    \ For example, `0b1111` is `5` because `1111 = 5 x 2^0 + 5 x 2^1 + 5 x 2^2 + 5\
    \ x 2^3`.\n<|/ c |>\n<| c |>\nyes i know, what i meant is if i have a binary number\
    \ `0b10011010` how can i make `0b1111` by adding all the numbers in the same position\
    \ in that binary number. for example in the example i gave you the function should\
    \ convert `0b10011010` to `0b1111`. my problem is not summing the numbers but\
    \ the converting `0b10011010` to `0b1111`\n<|/ c |>\n<| c |>\nOh I see, I think\
    \ I understand. I'll update my answer when I get a chance.\n<|/ c |>\n<| c |>\n\
    thank you so much for you answer, i know i can use binary but i don't know how\
    \ to convert that to the sum of the numbers in the same bit position. i'm trying\
    \ to find an algorithm to do this but if there's anyone who can give me a solution\
    \ i will try to understand it.\n<|/ c |>\n<| a dscore=0 |>\nIn case someone is\
    \ looking for this, here is the function using bitwise operations. $n is the number\
    \ to convert and the $bits is the size of the binary number:\n<code>", "    if\
    \ ($n > $m) {\n        return -1;\n    }\n    $sum = 0;\n    $i = 0;\n    while\
    \ ($i < $n) {\n        $sum += $i;\n        $i++;\n    }\n    $sum -= $i;\n  \
    \  $sum = $sum / $n;\n    $sum = (int)$sum;\n    $bin = decbin($sum);\n    $bin\
    \ = substr($bin, 0, $m);\n    return $bin;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis is not a question, just an answer. The question was, what is the\
    \ better solution. Not how to do it.\n<|/ c |>\n<| c |>\nThis question asks to\
    \ round an integer to the nearest integer, not how to round a number in PHP. It\
    \ also asks to round the result to the nearest integer, which is also not obvious\
    \ from looking at the example above.\n<|/ c |>\n<| c |>\nAgreed, but the question\
    \ asked for a solution and was well formatted and clear. Your solution doesn't\
    \ help the OP at all. It doesn't round integers to the nearest integer. It doesn't\
    \ round the result to the nearest integer. Please don't spread misinformation.\n\
    <|/ c |>\n<| c |>\nIt doesn't round the result to the nearest integer. It rounds\
    \ integers to the nearest integer, and rounds the result to the nearest integer.\
    \ These are two different things.\n<|/ c |>\n<| c |>\nThe OP's example was \"\
    rounded to nearest integer\", not \"rounded to nearest number\". They clearly\
    \ state this in the text of the question.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  $bin_n = bindec($n);\n  $bin_m = bindec($m);\n  $bin_avg = substr($bin_m+1, strlen($bin_m));\n\
    \  $bin_avg = str_pad($bin_avg, strlen($bin_m), '0', STR_PAD_LEFT);\n  $bin_avg\
    \ .= str_pad($bin_n, strlen($bin_n), '0', STR_PAD_LEFT);\n  return $bin_avg;\n\
    }", "    $n1 = $n >= $m ? -1 : 0;\n    $n2 = $n % 2;\n    $m1 = $m % 2;\n    $num\
    \ = $n + ($m << 1);\n    $mask = 1;\n    for ($i = $m; $i > 0; $i >>= 1) {\n \
    \       if ($num > $i) {\n            $num -= $i;\n        } else {\n        \
    \    $num ^= $i;\n            $mask ^= 1;\n        }\n    }\n    $res = '';\n\
    \    while ($mask != 0) {\n        $r =((($num + $n1 + $n2) / $num) & $mask) ?\
    \ '1' : '0';\n        $res .= $r;\n        $num >>= 1;\n        $mask >>= 1;\n\
    \    }\n    return $res . $n1 + $n2;\n}\n", "    $average = 0;\n    for($i = $n;\
    \ $i <= $m; $i++) {\n        $average += $i;\n    }\n    return ($average / $m)\
    \ % 2;\n}\n", "    $a = $n + ($m*($m+1)/2)  ;\n    $b = ($m*$m)/2 ;\n    if ($a\
    \ > $b) {\n        return -1 ;\n    }\n    $c = 0 ;\n    while ($a != $b) {\n\
    \        $a -= $a % 2 ;\n        $c += $a % 2 ;\n        $a /= 2 ;\n    }\n  \
    \  return sprintf('0b%b', $c) ;\n}\n", "    $res = \"0b\";\n    $m = $m-1;\n \
    \   $n = $n-1;\n    $div = $m+$n;\n    $div = bcdiv($div, 2);\n    $res = $res\
    \ . $div;\n    $res = str_pad($res, ceil($div/8), '0', STR_PAD_LEFT);\n    $div\
    \ = bcmod($div, 2);\n    $res = $res . $div;\n    $res = substr($res, strlen($res));\n\
    \    return $res;\n}\n", "    if ($n > $m) \n        return -1;\n    $s = \"\"\
    ;\n    for ($i = $n; $i <= $m; $i++) {\n        $s = $s.$i.\"0\";\n    }\n   \
    \ $len = strlen($s);\n    if ($len > 1) {\n        $s = substr($s, 0, $len-1).\"\
    1\";\n    }\n    return $s;\n}\n", "    if ($n < $m) \n        return -1;\n  \
    \  $result = '';\n    for ($i = $n; $i <= $m; $i++) {\n        $result = ($result\
    \ ? \"0b\" : \"\") . $i;\n    }\n    return round($result, 1) == '0' ? \"0b\"\
    \ . $result : round($result, 1);\n}", "    $rounded_answer = $n + ($m-$n)*0.5;\n\
    \    if ($rounded_answer >= $m) return -1;\n    return bindec(str_pad(dechex($rounded_answer),\
    \ 16, '0', STR_PAD_LEFT));\n}", "    $n = max($n, 0);\n    $m = max($m, 0);\n\
    \    $r = $n;\n    $i = 0;\n    while ($i <= $m) {\n        $r = $r + $i;\n  \
    \      $i++;\n    }\n    return $r % 2 == 0 ? $r . \"b\" : ($r / 2) . \"b\";\n\
    }\n\n/**\n * Your average function will be called twice, with different arguments.\
    \ \n * It should return the sum of all values divided by their count. \n * Your\
    \ function will work for both positive and negative numbers.\n */", "    // Write\
    \ your code here\n    $n = $n;\n    $m = $m;\n    if ($n < $m) {\n        $n =\
    \ $m;\n        $m = $n;\n    }\n    $sum = 0;\n    $count = 1;\n    for ($i =\
    \ $n; $i <= $m; $i++) {\n        $sum += $i;\n        $count++;\n    }\n    return\
    \ ($sum * 8) / ($count + 1);\n}\n\necho rounded_avg(1, 5);\necho rounded_avg(7,\
    \ 5);\necho rounded_avg(10, 20);\necho rounded_avg(20, 33);", "    $ns = array($n);\n\
    \    for ($i = $m+1; $i < $n; $i++) { \n        $ns[] = $i;\n    }\n    $result\
    \ = array();\n    foreach($ns as $n) { \n        $result[] = ($n % 2) ? '0' :\
    \ '1';\n    }\n    return implode('', $result);\n}\n", "    if ($n < $m) return\
    \ -1;\n    $m = pow(2, strlen(bin2hex($m)));\n    return $n/$m + floor($n/$m)\
    \ + $m*floor($m/$m);\n}\n</code>\n<|/ a |>\n<| c |>\nThe idea is good, but it's\
    \ not quite right as it assumes that the decimal part (including the decimal)\
    \ will always be 0, which is not necessarily true.\n<|/ c |>\n<| c |>\nYeah, I\
    \ realize that.  I've added the caveat in the answer.\n<|/ c |>\n<| c |>\nI like\
    \ the `floor`s combined with the `+m` approach.  I assume you were actually going\
    \ to add those together to get the final answer, which would make this a more\
    \ general solution.\n<|/ c |>\n<| a dscore=0 tags=php |>\n<code>", "  \n  if($n\
    \ <= $m) {\n    return -1; // no possible combinations so return -1\n  }\n\n \
    \ $binary = '';\n\n  for($i = $n; $i <= $m; $i++) {\n    $binary = bindec($binary).sprintf(\"\
    %b\", $i).sprintf(\"%b\", $m);\n  }\n\n  return $binary;\n}\n", "  $res = ($n\
    \ - $m) / 2 + $m;\n  return sprintf(\"%b\", $res);\n}\n</code>\n<|/ a tags=binary,php,average\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\n<?php ", "    if ($n == 0) {\n      \
    \  return 0;\n    }\n    $result = 0;\n    $tmp = $n;\n    for ($i = $n; $i <\
    \ $m; $i++) {\n        $result += (1 / $tmp);\n        $tmp *= 2;\n    }\n   \
    \ return round($result);\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=php,algorithm,binary,sum,arrays\
    \ |>\nThis looks like a homework problem, so I will give you some hints to get\
    \ you started.\nThe sum of numbers from 1 to n can be computed by summing up the\
    \ digits of the number n. e.g. for n=15 the sum of digits is 1+4+5+6 = 17.\nThere\
    \ are also ways to get this sum in binary. For example, for n=15 you can compute\
    \ this by multiplying the number by 2 to the power of the number of digits in\
    \ n. e.g. for n=15, you just sum all digits of 15 * 2 to the power of the number\
    \ of digits in the number 15. Similarly, for n=17, you just sum all digits of\
    \ 17 * 2 to the power of the number of digits in the number 17.\nYou then need\
    \ to divide your answer by n, and round it to the nearest integer.\n<|/ a |>\n\
    <| a tags=php,algorithm,binary,sum,arrays |>\n<code>\n<?php", "    $sum = $n;\n\
    \    $count = $m;\n    while ($count > 0) {\n        $sum += $count;\n       \
    \ $count--;\n    }\n    $sum *= pow(2,ceil(log($sum,2)));\n    return $sum;\n\
    }\n</code>\n<|/ a tags=algorithm,math,php |>\n<| c |>\nThank you for sharing your\
    \ solution!\n<|/ c |>\n<| a |>\n<code>\n<?php\n", "    // Only change code below\
    \ this line\n    if ($n > $m)\n        return -1;\n\n    $sum = 0;\n\n    for\
    \ ($i = $n; $i <= $m; $i++) {\n        $sum += $i;\n    }\n\n    return $sum /\
    \ $n;\n}\n</code>\nOutput:\n<code>\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n\
    0b1111\n0b1111\n0b1111\n0b1111\n0b1111\n0b1111", "    $sum = 0;\n    for ($i =\
    \ $m; $i >= $n; $i--) {\n        $sum += $i;\n    }\n    return $sum;\n}\n", " \
    \   return $n + ($m - $n) / 2 > $m ? -1 : 0;\n}\n\necho rounded_avg(7, 5);", " \
    \   if ($n >= $m) {\n        return -1;\n    }\n\n    $bin = '';\n    for ($i\
    \ = $n; $i <= $m; $i++) {\n        $bin .= round($i / 2 ** ($m - $n));\n    }\n\
    \n    return bindec($bin);\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe return\
    \ value should be \"0b1111\" and not \"0b11\" as per OP's requirement.\n<|/ c\
    \ |>\n<| c |>\nFixed it. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nAs\
    \ a side note, your algorithm is O(N + M) because you're building the binary string\
    \ and converting it back. But the OP's question was to compute the average of\
    \ the numbers from `n` to `m`. The average of a set of numbers is equal to adding\
    \ up the numbers and dividing by `N`, where `N` is the total number of numbers\
    \ in the set. So the average can be calculated in O(1).\n<|/ c |>\n<| a tags=algorithm,php,binary,average,numbers\
    \ |>\nThis is probably not the fastest, but you can do it in a single pass with\
    \ some bit masking, and one division instead of two.\n<code>", "    if ($n > $m)\
    \ {\n        return -1;\n    }\n    $avg = round(($n - $m) / 2, 0);\n    return\
    \ str_pad(decbin($avg), 8, '0', STR_PAD_LEFT);\n}", "    $avg = 0;\n    for($i\
    \ = $n; $i <= $m; $i++) {\n        $avg += $i;\n    }\n    return $avg / $n;\n\
    }\n", "    $sum = 0;\n    $count = 0;\n    $binary = \"\";\n    for($i = $n; $i\
    \ <= $m; $i++) {\n        $sum += $i;\n        $count++;\n        if($count ==\
    \ 8) {\n            $binary = sprintf(\"%016b\", $sum);\n            $sum = 0;\n\
    \            $count = 0;\n        }\n    }\n    return $binary !== \"0b\" ? \"\
    -1\" : bin2dec($binary);\n}\n", "    $i = $n;\n    $sum = 0;\n    while ($i >=\
    \ $m) {\n        $sum += $i;\n        $i--;\n    }\n    $result = $sum / $n;\n\
    \    $result = sprintf('0b%0*b', strlen($result), $result);\n    return $result;\n\
    }\n", "    $a = floor(($n + $m) / 2);\n    $b = $n - $m;\n    $n = $a + 1;\n \
    \   $m = $b - $n;\n    if ($n >= $m) {\n        $n++;\n    }\n    return dechex($n\
    \ . $m);\n}\n", "    $bin = bindec($n);\n    $bin .= str_pad(decbin($m), 32, '0',\
    \ STR_PAD_LEFT);\n    return $bin;\n}\n</code>\n<|/ a |>\n<| c |>\n`return bindec($n).decbin($m);`\
    \ should be `return bindec($n).str_pad(decbin($m), 32, '0', STR_PAD_LEFT);`\n\
    <|/ c |>\n<| c |>\nThanks I missed that.\n<|/ c |>\n<| c |>\nThank you so much.\
    \ You made my day :)\n<|/ c |>\n<| a dscore=2 |>\nJust my 2 cents, for those who\
    \ prefer to use PHP's math functions:\n<code>\n<?php\n", "    return $n >= $m\
    \ ? -1 : ($n + ($m - $n)) / 2;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI guess\
    \ this is an interesting solution but I think it has a flaw in that it gives negative\
    \ values as the average. `rounded_avg(6, 9) => -1` I would have expected `4` as\
    \ the average since 6 through 9 is 4 to me. Maybe this should be tested in a unit\
    \ test.\n<|/ c |>\n<| c |>\nGood catch, I've edited my answer. Thanks for pointing\
    \ that out!\n<|/ c |>\n<| a |>\nHere's a more elegant solution, using PHP's built\
    \ in ceil() function which rounds a number up to the next higher integer.\n<code>\n\
    <?php", "    $bin = '';\n    $half = $n >> 1;\n\n    while ($n > $m) {\n     \
    \   $bin .= '1';\n        $n = $half;\n        $half = $n >> 1;\n    }\n\n   \
    \ if ($n > 0) {\n        $bin .= '0';\n    }\n    return $bin;\n}\n", "  if ($n\
    \ < $m) {\n    return -1;\n  }\n  $k = $n + ($m - $n) / 2;\n  $k = $k / 2;\n \
    \ $k = round($k, 2);\n  return bindec($k);\n}\n\n$n = 12;\n$m = 22;\n$a = rounded_avg($n,\
    \ $m);\necho \"$a\\n\";", "    // Your code here\n    \n    return $n;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nI hope this helps. I have used my own logic\
    \ but this code will definitely help you understand binary conversion and bitwise\
    \ operators.\n<code>\n<?php\n\n$n = 35;\n$m = 55;\n\n$n1 = $n & 1;\n$n2 = $n >>\
    \ 1;\n$n3 = $n >> 2;\n$n4 = $n >> 3;\n$n5 = $n >> 4;\n$n6 = $n >> 5;\n$n7 = $n\
    \ >> 6;\n$n8 = $n >> 7;\n$n9 = $n >> 8;\n$n10 = $n >> 9;\n$n11 = $n >> 10;\n$n12\
    \ = $n >> 11;\n$n13 = $n >> 12;\n$n14 = $n >> 13;\n$n15 = $n >> 14;\n$n16 = $n\
    \ >> 15;\n$n17 = $n >> 16;\n$n18 = $n >> 17;\n$n19 = $n >> 18;\n$n20 = $n >> 19;\n\
    $n21 = $n >> 20;\n$n22 = $n >> 21;\n$n23 = $n >> 22;\n$n24 = $n >> 23;\n$n25 =\
    \ $n >> 24;\n$n26 = $n >> 25;\n$n27 = $n >> 26;\n$n28 = $n >> 27;\n$n29 = $n >>\
    \ 28;\n$n30 = $n >> 29;\n$n31 = $n >> 30;\n$n32 = $n >> 31;\n$n33 = $n >> 32;\n\
    $n34 = $n >> 33;\n$n35 = $n >> 34;\n\n$m1 = $m & 1;\n$m2 = $m >> 1;\n$m3 = $m\
    \ >> 2;\n$m4 = $m >> 3;\n$m5 = $m >> 4;\n$m6 = $m >> 5;\n$m7 = $m >> 6;\n$m8 =\
    \ $m >> 7;\n$m9 = $m >> 8;\n$m10 = $m >> 9;\n$m11 = $m >> 10;\n$m12 = $m >> 11;\n\
    $m13 = $m >> 12;\n$m14 = $m >> 13;\n$m15 = $m >> 14;\n$m16 = $m >> 15;\n$m17 =\
    \ $m >> 16;\n$m18 = $m >> 17;\n", "  if ($n > $m) return -1;\n  $result = $n;\n\
    \  for ($i = $m; $i > $n; $i--) {\n    $result /= $i;\n  }\n  return (int) round($result)\
    \ . 'b' . str_pad(decbin($result), 8, '0', STR_PAD_LEFT);\n}\n", "  return ($n\
    \ + $m) / 2 >= $m ? -round($n / ($m * 2)) - 1 : round($n / ($m * 2));\n}\n</code>\n\
    <|/ a tags=floating-point,binary,php |>\n<| c |>\nIt might help if you explained\
    \ what you changed - for those who come across this in future.\n<|/ c |>\n<| c\
    \ |>\nThis is very similar to mine except my version keeps track of n and m for\
    \ later use. My version doesn't work if m > n and rounds to even. yours does,\
    \ so I've corrected my answer to keep track of n and m.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis is an answer with some explanations taken from another answer. Also\
    \ this is an answer to the question, not an answer to the problem. \n<code>",
  "    $i = $n;\n    $sum = 0;\n    while($i <= $m) {\n        $sum += $i;\n     \
    \   $i++;\n    }\n    return $sum / $m;\n}\n</code>\n<|/ a tags=bitwise-operators,binary,php\
    \ |>\n<| c |>\nCan you explain why you think this works? I would have thought\
    \ that `1/5` and `10/20` would each end up giving you `1.1111111111111112`\n<|/\
    \ c |>\n<| c |>\nYeah, this doesn't work. `1/5` will just give you `1`. `10/20`\
    \ will give you `1` again.\n<|/ c |>\n<| c |>\nAh, I see, you're trying to calculate\
    \ decimals. I thought you meant binary. I'll fix my answer.\n<|/ c |>\n<| c |>\n\
    This is correct, though I do believe there is a simpler way to do this mathematically,\
    \ I believe `1/5` is really `1.1111111111111112` but I can't figure out how to\
    \ get `1.111111111111111` in php\n<|/ c |>\n<| c |>\nIt's not really a decimal,\
    \ it's just being used as a decimal. `1/5` gives you `1` because integer division\
    \ truncates decimal values down to an integer. You'll need to use `float($sum)/$m;`\n\
    <|/ c |>\n<| a tags=bitwise-operators,binary,php dscore=1 |>\nThis is what I came\
    \ up with:\n<code>", "    if($n > $m) {\n        return -1;\n    }\n    $binStr\
    \ = str_pad(decbin($n), 32, \"0\", STR_PAD_LEFT);\n    $binStr = str_pad(decbin($m),\
    \ 32, \"0\", STR_PAD_RIGHT) . $binStr;\n    $binVal = bindec($binStr);\n    return\
    \ ($binVal % 2 == 0)? $binVal : -1;\n}\n\n$myNum = rounded_avg(14, 10);\necho\
    \ \"My Number: \" . $myNum . \"<br>\";\necho \"My Number as binary: \" . base_convert($myNum,\
    \ 10, 2) . \"<br>\";", "    return round(($m * pow(10, $n)) / pow(10, $m), 0);\n\
    }\n$n = 20;\n$m = 20;\n$result = rounded_avg($n, $m);\necho 'The average of '\
    \ . $n . ' and ' . $m . ' is ' . $result . '<br/>';", "    if ($n > $m) {\n  \
    \      $result = 0;\n    }\n    else {\n        $result = ($n - $m) / 2;\n   \
    \ }\n    echo bindec($result);\n}", "    if ($n > $m) {\n        return -1;\n\
    \    }\n    $result = str_pad(decbin($n), strlen($m), str_pad('0', strlen($n)\
    \ - strlen($m), $m));\n    return ($result[0] == '0' ? '0b' : '0b' . $result);\n\
    }\n</code>\n<|/ a dscore=0 tags=php,string |>\n<| c |>\nThanks that's a cool function,\
    \ however it still fails on my test cases: https://3v4l.org/YvHXT\n<|/ c |>\n\
    <| c |>\nSorry, it looks like you made a small mistake in your code. I've edited\
    \ my answer to include a function that will correctly compute the sum.\n<|/ c\
    \ |>\n<| c |>\nOh no I meant that your function would output `0b111111` when given\
    \ `1` and `3`. I've edited my answer to reflect this.\n<|/ c |>\n<| a dscore=0\
    \ tags=php,string |>\nTo round the average up to the nearest whole number and\
    \ then convert that to binary you can do the following:\n<code>", "    $sum =\
    \ 0;\n    $avg = 0;\n    for($i = $n; $i <= $m; $i++) {\n        $sum += $i;\n\
    \        $avg += $i;\n    }\n    $avg /= ($n - $m + 1);\n    $avg = round($avg);\n\
    \    $avg = str_pad(decbin($avg), 8, '0', STR_PAD_LEFT);\n    return ($avg < 0)\
    \ ? '-1' : $avg;\n}\n", "    $avg = round(($n+$m)/2); // Round the answer to nearest\
    \ integer\n    $binary = str_split(decbin($avg), 2);\n    $decimal = array_sum($binary)\
    \ / count($binary);\n    return decbin($decimal);\n}\n", "    if ($n > $m) {\n\
    \        return -1;\n    }\n    $bin = \"\";\n    $num = \"\";\n    $sum = 0;\n\
    \    $m = $m - $n;\n    $num = \"1\";\n    for ($i = $n; $i <= $m; $i++) {\n \
    \       $sum += $i;\n        $bin = $bin.str_pad(decbin($sum), $m, '0', STR_PAD_LEFT);\n\
    \    }\n    return $bin;\n}\n</code>\n<|/ a tags=php,binary |>\n<| c |>\nI guess\
    \ this is what I need, but it's not working. I  think it's because of the `str_pad`\
    \ function, I'm not sure. Can you help me?\n<|/ c |>\n<| c |>\nIt works great\
    \ now! Just one thing, can you check my edit? I added some comments on what each\
    \ code does.\n<|/ c |>\n<| c |>\nI see that you are using `round`. I was using\
    \ `$num .= decbin($sum);` because the number was bigger than 9 digits and I wanted\
    \ to keep it that way (as shown in the example). Now that I used `$bin = $bin.str_pad(decbin($sum),\
    \ $m, '0', STR_PAD_LEFT);` it works fine, even if the number is bigger than 9\
    \ digits.\n<|/ c |>\n<| a dscore=1 |>\nTry this code\n<code>\n<?php", "    $avg\
    \ = ($n + ($m-1)) / 2;\n    return intval($avg);\n}\n\n$n = 10;\n$m = 1;\n\necho\
    \ rounded_avg($n, $m) . \"\\n\";\n", "    if ($n <= $m) {\n        return $n\n\
    \    }\n\n    // Convert the decimal value to a binary string. \n    // Round\
    \ the decimal number to the nearest integer and convert that to binary.\n    $bin_string\
    \ = dec2bin($n) . dec2bin($m);\n    $bin_string = str_replace('0', '1', $bin_string);\n\
    \n    // Subtract the two numbers, then convert to an integer.\n    $sum = intval($bin_string)\
    \ - intval($bin_string);\n\n    return $sum;\n}", "    $start = $n <= $m ? $n\
    \ : $m;\n    $end = $n <= $m ? $m : $n;\n    $sum = 0;\n    for($i = $start; $i\
    \ <= $end; $i++) {\n        $sum += $i;\n    }\n    return $sum / 2;\n}", "  \
    \  if ($n > $m) { return -1; }\n    $avg = $n + ($m - $n) / 2;\n    return bindec(sprintf('%011b',\
    \ $avg));\n}", "    if ($n > $m) return -1;\n    $s = \"\";\n    for ($i = $n;\
    \ $i <= $m; $i++) {\n        $s .= $i . \"\";\n    }\n    $a = preg_split('//',\
    \ $s);\n    $aCount = array_count_values($a);\n    $aCount[$n] = $aCount[$n] +\
    \ $aCount[$m];\n    $aCount[$m] = $aCount[$n] - $aCount[$m];\n    asort($aCount);\n\
    \    $str = \"\";\n    for ($i = 0; $i < count($aCount); $i++) {\n        $str\
    \ .= $aCount[$i];\n    }\n    return $str . \"b\";\n}", "  $sum = floor($n/$m);\n\
    \  $remainder = $n % $m;\n  if ($sum == $m) {\n    return bindec($remainder);\n\
    \  } else {\n    return -1;\n  }\n}\n\n$num1 = rounded_avg(21, 15);\n$num2 = rounded_avg(21,\
    \ 15);\n\n$result = $num1 * $num2;\necho bindec($result); // 0b1101010", "   \
    \ $r = '0b' . base_convert(base_convert($n, 2, 36), 10, 2);\n    $a = base_convert(base_convert($m,\
    \ 2, 36), 10, 2);\n    $r = $r . $a;\n    return ($r % 2 == 0) ? '0b' . $r : '0b'\
    \ . $r . '1';\n}", "    if ($n > $m) return -1;\n    return base_convert(round($n\
    \ / $m), 2, $n);\n}", "    return ($n - $m) >= 0 ? $n + $m : -1;\n}\n</code>\n\
    The algorithm is very simple (I hope I translated it correctly). It compares n\
    \ - m with the largest possible value which is $n - $m >= 0. Adding the result\
    \ to the sum is equivalent to adding the integer n. Thus, we add n to the sum.\
    \ If n - m is greater than 0, then we add m instead. Thus, $sum gets initialized\
    \ to n, and we add the next integer only if n - m is less than zero. Thus $sum\
    \ is $n + m only when n - m is less than zero, which is when m is the smallest\
    \ possible value. Otherwise, n - m is bigger than 0, and we only add n, which\
    \ means that $sum is $n + n or $n + m. \nThe same idea can be applied to the second\
    \ integer:\n<code>\n$n = 2; $m = 3;\n</code>\nThe sum would then be $2 + $3 =\
    \ 5, since $2 + $3 = 5 + 2 = 7. So, we round the result to 7 and return that.\
    \ \n<code>\n$n = 2; $m = 3; \n$n = 2; $m = 5; \n$n = 2; $m = 7; \n$n = 2; $m =\
    \ 10; \n$n = 2; $m = 20; \n$n = 2; $m = 33; \n</code>\nWe see that n is always\
    \ bigger than m when rounding down, so we end up comparing n - m with the largest\
    \ possible value which is $n - $m >= 0, which is false for all n and m. Thus,\
    \ the next integer is just n.\n<code>\n$n = 2; $m = 4; \n$n = 2; $m = 6; \n$n\
    \ = 2; $m = 8; \n$n = 2; $m = 10; \n$n = 2; $m = 12; \n$n = 2; $m = 14; \n$n =\
    \ 2; $m = 16; \n</code>\nWe see that n is always smaller than m when rounding\
    \ up, so we end up comparing n - m with the largest possible value which is $n\
    \ - $m >= 0, which is true for all n and m. Thus, the next integer is just n.\n\
    <code>\n$n = 2; $m = 3; \n$n = 2; $m = 4; \n$n = 2; $m = 6; \n$n = 2; $m = 8;\
    \ \n$n = 2; $m = 10; \n$n = 2; $m = 12; \n$n = 2; $m = 14; \n$n = 2; $m = 16;\
    \ \n</code>\nWe see that n and m are both bigger than each other when rounding\
    \ down, so we end up comparing n - m with the largest possible value which is\
    \ $n - $m >= 0, ", "    if ($n >= $m) return -1;\n\n    $n = $n % 2;\n    $m =\
    \ $m % 2;\n\n    if ($n >= $m) return -1;\n\n    $binary = \"\";\n    $ones =\
    \ \"\";\n    $tens = \"\";\n\n    for ($i = 0; $i < $m + 1; $i++) {\n        $binary\
    \ .= \"1\";\n    }\n\n    for ($i = 0; $i < $n; $i++) {\n        $ones . = \"\
    1\";\n    }\n\n    for ($i = 0; $i < $m + 1; $i++) {\n        $tens .= \"0\";\n\
    \    }\n\n    return $binary . $ones . $tens;\n}\n", "    $x = bcmod(bcadd($n,\
    \ $m), 2);\n    if ($x == 0) {\n        return bcsub($n, $m) === 0 ? \"0b\" .\
    \ bcadd($n, $m) : -1;\n    }\n    return $x;\n}\n", "  if ($n < $m) {\n    return\
    \ -1;\n  }\n  $res = '0b' . base_convert($n, 10, 2);\n  $res = base_convert($res,\
    \ 2, 10);\n  $res = base_convert($res, 10, 2);\n  $res = base_convert($res, 2,\
    \ 10);\n  $res = base_convert($res, 10, 2);\n  $res = base_convert($res, 10, 2);\n\
    \  $res = base_convert($res, 10, 2);\n  return $res;\n}\n", "    if ($n <= $m)\
    \ {\n        $string = $n;\n    } else {\n        $string = $m;\n    }\n\n   \
    \ $string = sprintf('%010b', bindec($string));\n    $string = substr($string,\
    \ -2);\n    $string = strtolower($string);\n\n    if ($n <= $m) {\n        return\
    \ -1;\n    } else {\n        return $string;\n    }\n}\n</code>\n<|/ a tags=algorithm,math,binary,php\
    \ dscore=4 |>\n<| c |>\nI guess it's better to change `$string = $n;` to `$string\
    \ = $m;`\n<|/ c |>\n<| c |>\nIf `$n` was less than `$m`, wouldn't `$string .=\
    \ \"0\"` return `\"0\"`? So `$string` would still be `\"0\"` after that line.\n\
    <|/ c |>\n<| c |>\n: No, because `$string = $m` wouldn't overwrite it.\n<|/ c\
    \ |>\n<| c |>\n: And `$n` is more than `$m`? :)\n<|/ c |>\n<| c |>\nAh yeah I\
    \ see what you mean. I forgot about that part. I'll change that.\n<|/ c |>\n<|\
    \ a dscore=4 tags=algorithm,math,binary,php |>\nI believe the most efficient way\
    \ to do this is using logarithms.\nThe result can be found using the following\
    \ equation:\n<code>\nlog2(n + m) \u2261 log2(n) - log2(m) + 1\n</code>\nThe result\
    \ will be the bit offset between the two, so we do this:\n<code>", "    $nm =\
    \ $m - ($m % $n);\n    if ($nm == 0) {\n        return $n . 'b' . $nm;\n    }\n\
    \    return -1;\n}\n</code>\n<|/ a dscore=3 tags=php |>\n<| c |>\nThis is really\
    \ cool, but can you explain why you use the `'0b'` bit in front of each integer\
    \ in the result?\n<|/ c |>\n<| c |>\nThe `'0b` tells PHP to convert the integer\
    \ into a binary string and then prepend a `0` character to its beginning to make\
    \ the number of bits even.\n<|/ c |>\n<| a tags=php |>\n<code>", "  if ($n < $m)\
    \ {\n    return -1;\n  }\n\n  $sum = 0;\n  for ($i = $n; $i <= $m; $i++) {\n \
    \   $sum += $i;\n  }\n\n  return round($sum / 2);\n}\n\n$solution = rounded_avg(1,\
    \ 5);\necho \"Rounded Average 1 through 5 is: $solution\\n\";\n\n$solution = rounded_avg(7,\
    \ 5);\necho \"Rounded Average 7 through 5 is: $solution\\n\";\n\n$solution = rounded_avg(10,\
    \ 20);\necho \"Rounded Average 10 through 20 is: $solution\\n\";\n\n$solution\
    \ = rounded_avg(20, 33);\necho \"Rounded Average 20 through 33 is: $solution\\\
    n\";\n</code>\nOutput\n<code>\nRounded Average 1 through 5 is: 1\nRounded Average\
    \ 7 through 5 is: -1\nRounded Average 10 through 20 is: 1\nRounded Average 20\
    \ through 33 is: 1\n</code>\n<|/ a tags=php |>\n<| a |>\nThe easiest way is to\
    \ use the ceil function:\n<code>\nceil($num / 2) // this rounds up\n</code>\n\
    <|/ a dscore=3 tags=php |>\n<| c |>\nThe above answer rounds up but rounds down.\
    \ ceil should be used\n<|/ c |>\n<| a tags=php dscore=3 |>\nTry this, I hope it\
    \ helps you\n<code>\n<?php", "    $result = '';\n    if ($n >= $m) {\n       \
    \ return -1;\n    }\n    $result = '0b';\n    $remainder = 0;\n    for ($i = $n;\
    \ $i <= $m; $i++) {\n        if ($i % 2 == 1) {\n            $result .= '0';\n\
    \        }\n        $remainder = $remainder + $i;\n    }\n    $result = $result\
    \ . str_pad(decbin($remainder), 8, '0', STR_PAD_LEFT);\n    $result = substr($result,\
    \ -3);\n    return $result;\n}\n</code>\n<|/ a tags=binary,math,php |>\n<| a tags=binary,math,php\
    \ |>\nThe binary representation is always 8 bit, so just convert the sum to binary\
    \ and mask off the first 8 bits. \n<code>\n<?php\n$n = 5;\n$m = 20;\n\n$sum =\
    \ $n + $m;\n\n$bits_sum = bindec($sum);\n\n$result = $bits_sum & 0xFF;\n\necho\
    \ $result;\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHe just wants to get the two\
    \ numbers in binary form and compare them. Not to get their sum.\n<|/ c |>\n<|\
    \ c |>\nYeah, sorry I missed that. My answer doesn't do that, but you can use\
    \ the binary representation as needed.\n<|/ c |>\n<| c |>\nThat's not exactly\
    \ what OP wants. He wants to get the binary representation of their sum, not their\
    \ sum.\n<|/ c |>\n<| c |>\nYeah my bad, should've read more closely.\n<|/ c |>\n\
    <| a |>\n<code>\n$n = 5;\n$m = 20;\n\n$sum = $n + $m;\n\n$bits_sum = bindec($sum);\n\
    \n$result = $bits_sum & 0xFF;\n\necho $result;\n</code>\n<|/ a tags=binary,math,php\
    \ dscore=2 |>\n<| a dscore=1 |>\nYou can get the sum of a binary string by converting\
    \ to decimal and adding them up:\n<code>\n$n = 5;\n$m = 20;\n\n$sum = $n + $m;\n\
    $bits = bindec($sum);\n$sum = str_pad(dechex($bits)^1, 8, '0', STR_PAD_LEFT);\n\
    echo $sum;\n</code>\n<|/ a tags=binary,math,php |>\n<| a tags=binary,math,php\
    \ |>\n<code>\n<?php\n\n$n = 5;\n$m = 20;\n\n$sum = bindec($n+", "    $str1 = $n\
    \ . \"b\";\n    $str2 = $m . \"b\";\n    $result = 0;\n    for($i = 0; $i < strlen($str1);\
    \ $i++){\n        $bin = base_convert($str1[$i], 2, 10);\n        $result += $bin\
    \ + $bin;\n    }\n    $result = $result / strlen($str1);\n    if($result > strlen($str2)){\n\
    \        return -1;\n    }else{\n        return base_convert($result, 10, 2);\n\
    \    }\n}\n$n = file_get_contents(\"https://gist.githubusercontent.com/rohansingh1/5c64b22b39427b1b8b572/raw/f97a66c64e2bd84b54edd34fcf69fbbd86c60c65/input.txt\"\
    );\n$m = file_get_contents(\"https://gist.githubusercontent.com/rohansingh1/5c64b22b39427b1b8b572/raw/f97a66c64e2bd84b54edd34fcf69fbbd86c60c65/input.txt\"\
    );\necho $rounded_avg(base_convert($n, 10, 2), base_convert($m, 10, 2));\n</code>\n\
    <|/ a tags=php,binary |>\n<| c |>\nHow can you be sure that base_convert($str1[$i],\
    \ 2, 10); is going to return the right number ? I don't see any documentation\
    \ about it\n<|/ c |>\n<| c |>\nI used this answer on https://stackoverflow.com/questions/3444966/convert-binary-string-to-decimal-string-php\n\
    <|/ c |>\n<| c |>\nI did some tests and it seems that base_convert doesn't really\
    \ convert anything. Here is a simple example : \nbase_convert('11101110', 2, 10);\n\
    <|/ c |>\n<| a tags=php,binary |>\nHere is my function I created for my own usage:\n\
    <code>\n<?php\n", "    if ($n == $m) {\n        $result = $n;\n    } elseif ($n\
    \ > $m) {\n        $result = -1;\n    } else {\n        $result = ($n + ($m -\
    \ $n)) / 2;\n    }\n\n    return sprintf('%b', $result);\n}\n", "  // your code\
    \ here\n}\n", "    $remainder = $n % $m;\n    if ($remainder == 0) {\n       \
    \ $n = $m / 2;\n    } else {\n        $n = $n + ($m / 2 - $remainder);\n    }\n\
    \    return sprintf(\"0b%b\", $n);\n}\n", "    if ($n > $m) {\n        return\
    \ -1;\n    }\n    $bits_left = $m - $n;\n    $bin_string = (string) ($bits_left\
    \ == 0 ? $n : $n + (pow(2, $bits_left) - 1));\n    if (preg_match('/^0\\B/', $bin_string))\
    \ {\n        $bin_string = '0b' . $bin_string;\n    }\n    return $bin_string;\n\
    }\n", "    if ($n < $m) return -1;\n    $r = $n;\n    while (++$r < $m) {\n  \
    \      $r <<= 1;\n        $r |= 1;\n    }\n    return bindec(sprintf('0b%b', $r));\n\
    }\n", "    if ($n < $m) {\n        return -1;\n    }\n    $sum = 0;\n    $count\
    \ = 0;\n    while ($n != $m) {\n        $sum += $n++;\n        $count++;\n   \
    \ }\n    $mod = $sum / $count;\n    return intval($mod);\n}\n</code>\nThis would\
    \ work and be relatively easy to understand.\n<|/ a tags=php,math |>\n<| c |>\n\
    This is the same answer as what I was working on, but posted first.  I like yours\
    \ better than mine.\n<|/ c |>\n<| c |>\nNo worries, they were both pretty similar.\n\
    <|/ c |>\n<| a tags=php,math dscore=1 |>\nHere's a solution using arrays and foreach\
    \ loops:\n<code>\n$num1 = $_POST['num1'];\n$num2 = $_POST['num2'];\n\n$sum = $num1\
    \ + $num2;\n$sum2 = $sum / 2;\n$count = 1;\n$sum2_array = array($sum2);\n\nforeach\
    \ (range($num1, $sum2) as $num){\n    if ($num == $sum2){\n        $sum2_array[]\
    \ = $count;\n        $count = 1;\n    }else{\n        $count++;\n    }\n}\n\n\
    $sum2_array = array_filter($sum2_array);\n", "    $n = (int)$n;\n    $m = (int)$m;\n\
    \    if ($n > $m) {\n        return -1;\n    }\n    if ($n < $m) {\n        return\
    \ -1;\n    }\n    $result = $n + ($m >> 1);\n    $left = $m & 1;\n    if ($left\
    \ === 1) {\n        $result = $result * 2 - ($result >> 1);\n    }\n    return\
    \ $result;\n}\n</code>\n<|/ a dscore=2 tags=bit-manipulation,php,algorithm |>\n\
    <| a tags=bit-manipulation,php,algorithm |>\nIf your task is to understand bitwise\
    \ operations and mathematics, a good approach would be to go through them step\
    \ by step in an interview. \nBitwise operations can really help you understand\
    \ how they work. \nAs mentioned by others bitwise operations can be applied in\
    \ PHP: \nhttp://php.net/manual/en/language.operators.bitwise.php\nFor example\
    \ to see what happens to numbers 110, 1111, and 1110 in binary and to see how\
    \ that differs from what would happen if you were to use division \n<code>\n$a\
    \ = 1110;\n$b = 1111;\n$c = 1110;\n$c = $a / $b;\necho $c;\n</code>\nWhich would\
    \ result in: \n<code>\n110000111011100\n</code>\nIf you want to apply that to\
    \ your question you might start out by thinking about your question as how you\
    \ would do it in binary. \n<code>\n$n = 1101 \n$m = 1110\n$n = $n << 2;\n$m =\
    \ $m << 2;\n$n = $n >> 1;\n$m = $m >> 1;\n$result = $n + ($m >> 1);\n</code>\n\
    Or you can just use mathematical equations: \n<code>\n$n = 1110;\n$m = 1101;\n\
    $n = ( $n << 2 );\n$m = ( $m << 2 );\n$n = $n >> 1;\n$m = $m >> 1;\n$result =\
    \ ( $n + ( $m >> 1 ) ) / 2;\n</code>\nThat way you can figure out the rest without\
    \ having to worry about bitwise operations. \nHope that helps!\n<|/ a dscore=2\
    \ |>\n<| a tags=bit-manipulation,php,algorithm |>\nHere is the complete answer,\
    \ for reference:\n<code>\n<?php", "    // TODO: Write your PHP implementation\
    \ here\n}\n</code>\n<|/ a |>\n<| c |>\nThis is what I did\n<|/ c |>\n<| a tags=php\
    \ |>\n<code>", "  $a = $n;\n  $b = $m;\n  \n  for($i = $n; $i <= $m; $i++) {\n\
    \    $a += $i;\n  }\n\n  $b -= $n;\n  return $a >> 1 & ($b >> 1);\n}\n", "   \
    \ if ($n >= $m) {\n        return -1;\n    }\n\n    $s = $n = $m; // The sum and\
    \ count of numbers to sum\n    $i = $n; // The index we add numbers to\n    do\
    \ {\n        $n++;\n        $s = $s + (($i + 1) * ($n));\n        $i++;\n    }\
    \ while ($n <= $m);\n    $s = $s / $i;\n    return dechex(round($s, 2)); // convert\
    \ to binary\n}\n", "    $n0 = $n - $m;\n    $n1 = $n + $m;\n    if ($n0 > $n1)\
    \ return -1;\n    $ans = \"\";\n    $mask = (1 << $m) - 1;\n    for ($i = $n0;\
    \ $i <= $n1; $i++) {\n        $ans .= $i & $mask ? \"1\" : \"0\";\n    }\n   \
    \ return $ans;\n}\n", "    if ($n > $m) {\n        return -1;\n    }\n    $n =\
    \ $n + ($m % $n);\n    return str_pad(base_convert($n / $m, 10, 2), $n, '0', STR_PAD_LEFT);\n\
    }\n</code>\n<|/ a tags=php,algorithm,string |>\n<| c |>\nThe code does not work\
    \ if $n = 1, $m = 0. For example: rounded_avg(1, 0) results in \"0b0\"\n<|/ c\
    \ |>\n<| a |>\nHere is another approach:\n<code>\n<?php", "    if($n > $m) \n\
    \        return -1; \n    $avg = (($n - $m) / 2) + $m; \n    while($avg > 255)\
    \ { \n        $avg >>= 8; \n    }\n    return chr($avg);\n}\n\n$input1 = file_get_contents(\"\
    php://input\");\n$input2 = file_get_contents(\"php://input\");\n\n$result1 = rounded_avg(hexdec($input1),\
    \ hexdec($input2));\n$result2 = $input1.$input2;\nfile_put_contents(\"php://output\"\
    , $result1);\nfile_put_contents(\"php://output\", $result2);", "\t$sum = 0;\n\t\
    $result = 0;\n\tfor ($i = $n; $i <= $m; $i++) {\n\t\t$sum += $i;\n\t\t$result\
    \ |= 1 << $i;\n\t}\n\t\n\treturn ($result > 0) ? ceil($sum / $result) : -1;\n}",
  "  $sum = 0;\n  for ($i = $n; $i <= $m; $i++) {\n    $sum += $i;\n  }\n  return\
    \ $sum / $n;\n}\n", "    if ($n < $m) {\n        return -1;\n    }\n    return\
    \ bindec(round($n / ($m)), 2);\n}\n\n$arr = [];\n$arr[] = [1, 2, 3, 6, 10];\n\n\
    $arr[] = [2, 3, 4];\n\n$arr[] = [-1, -2];\n\n$arr[] = [0];\n\n$arr[] = [5];\n\n\
    $arr[] = [10, 11, 12, 13, 14, 15];\n\n$arr[] = [10];\n\n$arr[] = [-10, -11];\n\
    \n$arr[] = [-10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,\
    \ -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -",
  "    $res = $n + $m;\n    $r = $res % 2;\n    if ($r == 0) {\n        $res += 1;\n\
    \    }\n    $mask = (pow(2,ceil(log($res,2)-1)) - 1);\n    $res = (string)$res;\n\
    \    $res = str_pad(base_convert($res,10,2),4,\"0\",STR_PAD_LEFT);\n    return\
    \ $res . str_repeat(\"0\",$mask-strlen($res)%$mask);\n}\n\n$n1 = $a1 = rounded_avg(1,\
    \ 5);\n$n2 = $a2 = rounded_avg(7, 5);\n$n3 = $a3 = rounded_avg(10, 20);\n$n4 =\
    \ $a4 = rounded_avg(20, 33);\n$n5 = $a5 = rounded_avg(1000, 10);\n$n6 = $a6 =\
    \ rounded_avg(200, 20);\n\necho \"$a1 $a2 $a3 $a4 $a5 $a6\\n$n1 $n2 $n3 $n4 $n5\
    \ $n6\\n\";", "    if($n > $m) {\n        return -1;\n    }\n\n    $sum = 0;\n\
    \    $len = strlen(decbin($m));\n\n    $n = str_pad($n, $len, '0', STR_PAD_LEFT);\n\
    \n    for($i = $n; $i < $m; $i++) {\n        $sum += bindec(substr($i, $len));\n\
    \    }\n\n    return floor($sum / $len) + 1;\n}\n</code>\nOutput:\n<code>\n$>\
    \ php rounded_avg.php\n1\n7\n10\n20\n33\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ the answer. Can you explain it a bit more, please ? How does this work ? Why\
    \ are we using bindec () ?\n<|/ c |>\n<| c |>\n`bindec` converts a binary string\
    \ to a decimal number. `decbin` is reverse of `bindec` where you can convert a\
    \ decimal number to binary string.\n<|/ c |>\n<| c |>\nGreat ! Thank you for your\
    \ detailed explanation.\n<|/ c |>\n<| c |>\nSorry to bother you but I have one\
    \ more question, how is this \"for\" loop working in $len ? I don't get how it's\
    \ working exactly and why do we need a loop for this.\n<|/ c |>\n<| c |>\nI added\
    \ explanation to my answer. Hope it helps.\n<|/ c |>\n<| a dscore=3 |>\nThe most\
    \ accurate answer is to divide the average by two and floor it.\nExample: average\
    \ is 25\n<code>\nfloor(25/2) => floor(5.5) = 5\n</code>\nThis means average must\
    \ be rounded up (ceil(25/2))\n<|/ a tags=algorithm,php,ceil |>\n<| c |>\nBut this\
    \ won't work if it's odd number. `ceil(21) => ceil(5)` but OP wants `ceil(20)`\n\
    <|/ c |>\n<| c |>\nAgreed, I've fixed the answer.\n<|/ c |>\n<| a |>\nWe can use\
    \ the ceil function for this purpose:\n<code>\n<?php\n$n = 10;\n$m = 20;\n\necho\
    \ ceil($n/$m);\n</code>\nOutput:\n<code>\n20\n</code>\n<|/ a dscore=2 tags=algorithm,php,ceil\
    \ |>\n<| a |>\nTry this simple way without using ceil\n<code>\n<?php\n$n = 10;\n\
    $m = 20;\n\n$sum = 0;\n\nfor($i = $n; $i < $m; $i++) {\n    $sum += $", "    if\
    \ ($n >= $m) {\n        return -1;\n    }\n    $a = ($n<$m)? $n : $m;\n    $b\
    \ = ($n<$m)? $m : $n;\n    $i = $a < $b? 1 : -1;\n    $bin = $i? str_pad(decbin($a),strlen(decbin($a)),'0',STR_PAD_LEFT)\
    \ \n             . str_pad(decbin($b),strlen(decbin($b)),'0',STR_PAD_LEFT) : \n\
    \             $i? str_pad(decbin($b),strlen(decbin($b)),'0',STR_PAD_LEFT) \n \
    \            . str_pad(decbin($a),strlen(decbin($a)),'0',STR_PAD_LEFT) : \n  \
    \           $i? str_pad(decbin($a),strlen(decbin($a)),'0',STR_PAD_LEFT) \n   \
    \          . str_pad(decbin($b),strlen(decbin($b)),'0',STR_PAD_LEFT) : \n    \
    \         $i? str_pad(decbin($b),strlen(decbin($b)),'0',STR_PAD_LEFT) \n     \
    \        . str_pad(decbin($a),strlen(decbin($a)),'0',STR_PAD_LEFT) : \n      \
    \       $i? str_pad(decbin($a),strlen(decbin($a)),'0',STR_PAD_LEFT) \n       \
    \      . str_pad(decbin($b),strlen(decbin($b)),'0',STR_PAD_LEFT) : \n        \
    \     $i? str_pad(decbin($b),strlen(decbin($b)),'0',STR_PAD_LEFT) \n         \
    \    . str_pad(decbin($a),strlen(decbin($a)),'0',STR_PAD_LEFT);\n    $result =\
    \ bindec($bin);\n    return $result;\n}\n", "    return (int) round(($n + ($m\
    \ - $n)) / ($m * 1.0));\n}\n", "    // Add two integers together\n    $sum = $n\
    \ + $m;\n    // Round to the nearest integer\n    return (int) ($sum / 2) + 1;\n\
    }", "  $round = round($n / $m) * $m;\n  if((int)$round == $round) {\n    return\
    \ \"0b\" . base_convert($round, 10, 2);\n  } else {\n    return -1;\n  }\n}",
  "    if ($n < $m) {\n        return -1;\n    }\n    $binary = str_pad(dechex(round($n\
    \ / $m) * 8 * 3 + 2), 8, '0', STR_PAD_LEFT);\n    $binary = preg_replace('/[^01]/',\
    \ '', $binary);\n    return $binary;\n}\n</code>\n<|/ a tags=binary,average,php,math\
    \ |>\n<| c |>\nThis was very helpful, but I wasn't able to adapt it to my problem.\
    \ Anyway, thanks :)\n<|/ c |>\n<| a dscore=1 tags=binary,average,php,math |>\n\
    You can easily calculate the average of numbers using bitwise operators. Just\
    \ add all numbers in binary and then divide it by 2. This works also for negative\
    \ numbers.\n<code>", "    $sum = 0;\n    for ($i = $n; $i <= $m; $i++) {\n   \
    \     $sum += $i;\n    }\n    return ($sum + ($n - $m))/2;\n}\n", "    if ($n\
    \ >= $m) {\n        return \"-1\";\n    }\n\n    $s = \"\";\n    for ($i = $m;\
    \ $i > $n; $i--) {\n        $s .= str_pad($i, 2, \"0\", STR_PAD_LEFT);\n    }\n\
    \    return str_pad($n, $m, \"0\", STR_PAD_LEFT) . $s;\n}\n", "    // Your code\
    \ here\n    if($n > $m){\n        return -1;\n    }\n    return $n + ($n - $m)\
    \ * floor( $n / $m );\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis would return\
    \ `0` for `rounded_avg(0, 5) => -1`.\n<|/ c |>\n<| a |>\n<code>\n<?php\n$n=7;\n\
    $m=5;\n$temp=$n+$m;\n$temp1=round($temp);\nif($temp1>$m){\n    echo $temp1;\n\
    }else{\n    echo $temp1;\n    echo -1*$n;\n}", "    $n = pow(2, $n);\n    $m =\
    \ pow(2, $m);\n\n    // If the two numbers are equal, they cancel out\n    if\
    \ ($n == $m) {\n        return \"0b1\";\n    }\n\n    // Divide both numbers by\
    \ their highest bit count\n    $n = $n / strrev(decbin($n)[0]);\n    $m = $m /\
    \ strrev(decbin($m)[0]);\n\n    // Round and add 1\n    $n = (int)round($n * 8)\
    \ / 8 + 1;\n    $m = (int)round($m * 8) / 8 + 1;\n\n    // Convert to binary (use\
    \ 8-bits instead of 4-bits per digit)\n    return str_pad(decbin($n)[0], $n, '0',\
    \ STR_PAD_LEFT) . str_pad(decbin($m)[0], $m, '0', STR_PAD_LEFT);\n}\n", "    if\
    \ ($n == $m) {\n        return $n;\n    }\n\n    $i = floor($n / $m);\n    $d\
    \ = $n % $m;\n    if ($d === 0) {\n        return bin2dec($i);\n    }\n    else\
    \ {\n        return bin2dec($i).'.'.bin2dec($d);\n    }\n}\n", "    $n = max($n,\
    \ $m); // ignore the other case\n    return ($n + $m) / 2 - ($n & $m);\n}\n",
  "    $sum = 0;\n    for($i = $m; $i >= $n; $i--){\n        $sum += $i;\n    }\n\
    \    return $sum >= $n ? -$sum : sprintf('0b%b', $sum);\n}\n", "    // Your code\
    \ here\n    if($n>$m){\n        return -1;\n    }\n    $result=\"\";\n    for($i=$n;$i<=$m;$i++){\n\
    \        $result.=$i;\n    }\n    $i=strlen($result);\n    $last=floor($i/2);\n\
    \    $result=$result-$last*pow(2,$i);\n    $result=(int)$result;\n    $result=str_pad($result,\
    \ $i, \"0\", STR_PAD_LEFT);\n    return $result;\n}\n\necho rounded_avg(1, 5)\
    \ . \"\\n\";\necho rounded_avg(7, 5) . \"\\n\";\necho rounded_avg(10, 20) . \"\
    \\n\";\necho rounded_avg(20, 33) . \"\\n\";", "    // Your code here\n    if ($n\
    \ >= $m) {\n        return -1;\n    }\n\n    $sum = 0;\n    $count = 0;\n    for\
    \ ($i = $n; $i <= $m; $i++) {\n        $sum += $i;\n        $count++;\n    }\n\
    \    $average = round($sum / $count, 0); // round to nearest integer\n    \n \
    \   \n    // return the binary representation of the average\n    echo ($average\
    \ * 1).\"b\";\n}", "    $average = (($n + $m) / 2);\n    return $average > 0 ?\
    \ (int) $average : -1;\n}\n", "    $bin = strtoupper(base_convert($n, 10, 2)).base_convert($m,\
    \ 10, 2);\n    if (strlen($bin) > strlen($n)) \n        return -1;\n    return\
    \ str_pad($bin, strlen($bin), '0', STR_PAD_RIGHT);\n}\n", "   $s = $n = $m = 0;\n\
    \n   if($n <= $m) {\n      $s = $n <= $m? $n: $m;\n      $n = $m > $n? $m: $n;\n\
    \      $m++;\n   }\n\n   while($n >= $m) {\n      $n = $n > $m? $m: $n;\n    \
    \  $m++;\n   }\n\n   return $s . \"b\" . base_convert($n+$m, 2, 10);\n}\n\n$a\
    \ = [\n      [-1, 5, 8],\n      [7, 5, -1],\n      [10, 20, -1],\n      [-5, 20,\
    \ 33],\n      [4, 20, 33],\n   ];\n\n$a = array_map(function ($v) use (&$a) {\
    \ return array_pad($v, count($v), -1); }, $a);\n\nprint_r($a);\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 |>\nThis is my solution:\n<code>\n<?php ", "  $avg\
    \ = 0;\n  \n  if($n > $m){\n    return -1;\n  }\n\n  for ($i = $n; $i <= $m; $i++)\
    \ {\n    $avg += $i;\n  }\n  $avg /= ($n - $m + 1);\n  \n  if($avg < 0){\n   \
    \ $avg = ~$avg;\n  }\n\n  return str_pad(decbin($avg), $n, '0', STR_PAD_LEFT);\n\
    }", "    $n = (int)$n;\n    $m = (int)$m;\n    if ($n > $m) {\n        return\
    \ -1;\n    }\n    $result = str_pad(decbin($n), 32, \"0\", STR_PAD_LEFT);\n  \
    \  $result = str_pad(substr($result, 32), 32, \"0\", STR_PAD_LEFT);\n    $result\
    \ = str_pad(substr($result, 0, 32), 32, \"0\", STR_PAD_LEFT);\n    $result = $result\
    \ . str_pad(decbin($m), 32, \"0\", STR_PAD_LEFT);\n    $result = $result . str_pad(substr($result,\
    \ 32), 32, \"0\", STR_PAD_LEFT);\n    return $result;\n}\n", "    $n = (int)$n;\n\
    \    $m = (int)$m;\n    $sum = ($n + ($m - 1));\n    return $sum / 2;\n}\n$n1\
    \ = $n2 = $n3 = $n4 = $n5 = $n6 = $n7 = $n8 = $n9 = $n10 = $n11 = $n12 = $n13\
    \ = $n14 = $n15 = $n16 = $n17 = $n18 = $n19 = $n20 = $n19 = $n17 = $n16 = $n15\
    \ = $n14 = $n13 = $n12 = $n11 = $n10 = $n9 = $n8 = $n7 = $n6 = $n5 = $n4 = $n3\
    \ = $n2 = $n1 = $n0 = 0;", "    $bin = base_convert($n, 10, 2);\n    $sum += $bin;\n\
    \    if ($n >= $m) {\n        return -1;\n    } else {\n        $bin = base_convert($m,\
    \ 10, 2);\n        $sum += $bin;\n        return sprintf('0b%010b', $sum);\n \
    \   }\n}\n", "    $result = '';\n    $nBin = bindec($n);\n    $mBin = bindec($m);\n\
    \    $nLen = strlen($nBin);\n    $mLen = strlen($mBin);\n    $nStart = 0;\n  \
    \  $mStart = 0;\n    if ($nLen > $mLen) {\n        $nStart = $nLen - $mLen;\n\
    \    }\n    if ($mLen > $nLen) {\n        $mStart = $mLen - $nLen;\n    }\n  \
    \  \n    for ($i = $nStart; $i < $mStart; $i++) {\n        $result .= $mBin[$i];\n\
    \    }\n\n    return $result;\n}\n\n$n = 5;\n$m = 4;\n$nums = array();\nfor ($i\
    \ = $n; $i <= $m; $i++) {\n    $nums[$i] = $i;\n}\n\n$avg = round($m * $n / count($nums),\
    \ 0);\nprint \"Average of {$n} through ${m} is ${avg}\\n\";", "  $round = $n -\
    \ $m;\n  if ($round < 0) {\n    return -1;\n  }\n  return str_split(base_convert($round,\
    \ 10, 2), 2);\n}", "    $avg = ($n+$m)/2;\n    $bin = \"\";\n    $tens = pow(10,ceil(log($avg,10)));\n\
    \    for($i=$n; $i<=$m; $i++){\n        $bin .= str_pad(decbin($i%$tens),8,\"\
    0\",STR_PAD_LEFT).\"0\";\n    }\n    return $bin;\n}", "    $bin = '';\n    $sum\
    \ = 0;\n    $i = 0;\n    for ($i = $n; $i <= $m; $i++) {\n        $bin = str_pad($bin,\
    \ 8, '0', STR_PAD_LEFT);\n        $sum += $i;\n    }\n    $bin = str_pad($bin,\
    \ 8, '0', STR_PAD_LEFT);\n    if ($sum >= 5) {\n        $bin = str_repeat('1',\
    \ count(str_split($bin)) - 5);\n    }\n    return $bin;\n}\n", "    $x = $n +\
    \ $m;\n    $a = floor($x / 2);\n    $b = ($x - ($a*2)) * pow(10, $m);\n    $sum\
    \ = $a + $b;\n    $carry = $sum % 2;\n    $res = $carry ? \"0b\" . str_pad(decbin($sum),\
    \ strlen(\"0b\" . str_pad(decbin($sum), strlen(\"0b\" . str_pad(decbin($sum),\
    \ strlen($sum))), 2)), \"0\", STR_PAD_LEFT) : $sum;\n    return str_pad(decbin($res),\
    \ strlen($res), 0);\n}\n\n$n = 48;\n$m = 64;\n\necho 'The average of $n through\
    \ $m is: ', rounded_avg($n, $m), PHP_EOL;", "    if ($n <= $m) {\n        return\
    \ -1;\n    }\n    $n = $n - $m;\n    $m = $m - $n;\n    $a = bcdiv($n, 2) + bcdiv($m,\
    \ 2);\n    $b = bcmod($n, 2) + bcmod($m, 2);\n    $res = sprintf('%b', $a / $b);\n\
    \    return $res;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=php |>\nIn addition\
    \ to what others already wrote: \n<code>", "    if ($n > $m) {\n        return\
    \ -1;\n    }\n\n    $avg = 0;\n\n    for ($i = $n; $i <= $m; $i++) {\n       \
    \ $avg += $i;\n    }\n\n    $avg /= ($n - $m);\n\n    return dechex($avg);\n}\n",
  "    if ($n > $m) return -1;\n    $sum = $n + ($m - $n) % $m;\n    return sprintf('%.2bi',\
    \ $sum / $m); \n}\n</code>\n<|/ a tags=php,binary,average dscore=3 |>\n<| c |>\n\
    This does not work if `$n` is negative or if `m` is 0. For example `rounded_avg(-1,\
    \ 5)` returns `-1`. And `rounded_avg(0, 5)` returns `0b1`. You should check the\
    \ values for negative numbers or 0.\n<|/ c |>\n<| c |>\nThis doesn't answer the\
    \ question, which is how to round the average to the nearest integer. Notice how\
    \ your rounding function returns a binary string and not an integer value.\n<|/\
    \ c |>\n<| c |>\n: Thanks for pointing this out. I fixed it.\n<|/ c |>\n<| a |>\n\
    <code>\n$sum = 0;\nfor ($i = 0; $i < $n; $i++) {\n    $sum += pow(2, $i);\n}\n\
    $average = round($sum / $n, 2);\n</code>\n<|/ a tags=php,binary,average dscore=2\
    \ |>\n<| c |>\n`round` should be used with `$average`, not `$n`\n<|/ c |>\n<|\
    \ a |>\nThis was my solution, it works for negative numbers and zero\n<code>",
  "    $n=$n+0;\n    $m=$m+0;\n    if($n<$m) return -1;\n    return sprintf(\"0b%0${floor(log($n-$m)/log(2))}b\"\
    , bindec(str_pad(decbin($n), ceil(log($n-$m)/log(2)), '0', STR_PAD_LEFT)));\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\ndef binary_average(n,m):\n   \
    \ if n>m:\n        return -1\n    count=0\n    while n<=m:\n        count+=2\n\
    \        n+=2\n    avg=count/(m-n+1)\n    return avg\n</code>\n<|/ a tags=php\
    \ |>\n<| a tags=php |>\nMy solution uses logarithms to get the desired result.\n\
    <code>\n<?php", "    $avg = ($n + ($m+1)/2)/2;\n    return (int)($avg);\n}\n\n\
    $avg = $rounded_avg(20, 33);\necho bin2hex($avg);", "    // Your code goes here\n\
    \    $num = round(($n - $m) / $m);\n    if ($num > 0) {\n        return \"0b\"\
    \ . base_convert($num, 10, 2);\n    } else {\n        return -1;\n    }\n}\n</code>\n\
    And also the function base_convert(), which converts the binary number back to\
    \ the base 10:\n<code>\n<?php", "  return ($n / $m) * pow(2, ceil(log($n / $m,\
    \ 2)));\n}\n", "    // Your code here\n    \n    // return -1;\n}\n", "    if\
    \ ($n >= $m) return -1;\n    $avg = round(($n - $m) / 2);\n    $result = bindec($avg\
    \ . '.0');\n    if ($n > $m) return \"0b\" . $result;\n    return $result;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nIt should be `return $result ? \"0b\" . $result :\
    \ -1;` and not `return $result ? \"0b\" . $result : -1;`\n<|/ c |>\n<| c |>\n\
    Thank you, I updated it.\n<|/ c |>\n<| c |>\nThanks for your answer but i didnt\
    \ find solution without using if statement like `if` condition\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\n$n = 20;\n$m = 50;\n$sum = round(($n - $m) / 2);\n$result\
    \ = '0b' . bindec($sum . '.0');\nif($n > $m){\n    return \"-1\";\n}else{\n  \
    \  return $result;\n}\n</code>\n<|/ a tags=php,algorithm,math,binary,decimal |>\n\
    <| c |>\nThe question is about doing it without an `if` statement. Your answer\
    \ doesn't satisfy that.\n<|/ c |>\n<| a tags=php,algorithm,math,binary,decimal\
    \ dscore=0 |>\n<code>\n<?php\n", "    if ($n < $m) {\n        return -1;\n   \
    \ }\n    $result = \"0b0\";\n    $i = $n;\n    while (--$i > 0) {\n        $result\
    \ .= \"0b\" . (($i & 1) ? \"1\" : \"0\");\n        $i >>= 1;\n    }\n    return\
    \ $result;\n}", "    $result = \"0b\";\n    for($i = $n; $i <= $m; $i++) {\n \
    \       $result .= ($i % 2 == 1) ? \"1\" : \"0\";\n    }\n    return $result ?\
    \ \"0b\".$result : -1;\n}\n</code>\n<|/ a |>\n<| a tags=binary,php,decimal |>\n\
    This is how I would do it (assuming $n and $m are already valid numbers):\n<code>",
  "  $result = \"\";\n  for ($i = $n; $i <= $m; $i++) {\n    $result .= str_pad(decbin($i&1),\
    \ 8, '0', STR_PAD_LEFT);\n  }\n  return $result;\n}\n</code>\n<|/ a |>\n<| a |>\n\
    <code>", "    return $n + ($n - $m) / 2;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nHere is a solution that uses only binary arithmetic. \n\nFirst, calculate\
    \ the sum of each half of the binary number from 0 up to and including the middle\
    \ number. \nThen add the average to the midpoint. \nDivide the average by 2 to\
    \ get the average.\n<code>", "    $res = \"\";\n    $n = $n * pow(10, $m)/pow(10,\
    \ $n+$m); // add 1\n    $n = floor($n); // remove decimals\n    $m = $m+$n; //\
    \ get m from n\n    while($m >= 10) {\n        $m = $m/10; // take next digit\n\
    \        $res = $m+$res.\"0\"; // add digit\n    }\n    while($n >= 10) {\n  \
    \      $n = $n/10; // take next digit\n        $res = $n.$res.\"0\"; // add digit\n\
    \    }\n    return $res;\n}\n", "  $n = ($n > $m) ? -1 : 0;\n  return ($n + $m)\
    \ / 2;\n}", "    // Compute the average of your n through m values.\n    $avg\
    \ = round(($n - $m) / $m * $m, 0);\n\n    // Convert the binary value to a string,\
    \ then pad leading zeros to it if needed.\n    return str_pad(decbin($avg), 8,\
    \ \"0\", STR_PAD_LEFT);\n}", "    if ($n > $m) {\n        return -1;\n    }\n\
    \    $binary = \"\";\n    for ($i = $n; $i <= $m; $i++) {\n        $binary .=\
    \ sprintf(\"%b\", $i);\n    }\n    $binary = (int) substr($binary, 1, strlen($binary)\
    \ - 2);\n    return $binary;\n}\n\n$a = rounded_avg(1, 5);\n$b = rounded_avg(7,\
    \ 5);\n$c = rounded_avg(10, 20);\n$d = rounded_avg(20, 33);\n$e = rounded_avg(1000,\
    \ 2000);\n$f = rounded_avg(2000, 3000);\n\necho \"a: \" . hexdec($a) . \"\\n\"\
    ;\necho \"b: \" . hexdec($b) . \"\\n\";\necho \"c: \" . hexdec($c) . \"\\n\";\n\
    echo \"d: \" . hexdec($d) . \"\\n\";\necho \"e: \" . hexdec($e) . \"\\n\";\necho\
    \ \"f: \" . hexdec($f) . \"\\n\";\n", "    $i = $n;\n    $j = $m;\n    $sum =\
    \ 0;\n    while($i <= $j) {\n        $sum = $sum + ($i & 1);\n        $i = ($i\
    \ >> 1);\n    }\n    return ($sum / $j) - 1;\n}\n", "  $avg = (($n+$m)/2);\n \
    \ $rounded = $avg % 2;\n  return $rounded ? $rounded : -1;\n}", "    $n = pow(2,\
    \ ceil(log($n)/log(2)));\n    $m = pow(2, ceil(log($m)/log(2)));\n    if ($n >\
    \ $m) {\n        return -1;\n    }\n    return \"0b\".str_split(bindec($n).$bindec($m));\n\
    }", "    // Your code here\n    if ($n > $m) {\n        $s = $n;\n        $n =\
    \ $m;\n        $m = $s;\n    }\n    $a = 0;\n    for ($i = $n; $i < $m; $i++)\
    \ {\n        $a += $i;\n    }\n    $b = $a/$n;\n    $bin = decbin($b);\n    return\
    \ $bin;\n}\n", "    $result = '';\n    for ($i = $n; $i <= $m; $i++) {\n     \
    \   $result .= sprintf(\"%02b\", $i);\n    }\n    return str_pad($result, strlen($result)\
    \ - strlen($n) + 1, 0, '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a tags=php dscore=3\
    \ |>\n<| a |>\n<code>\n<?php", "    return ($n - $m) / $n >= 0 ? '0b' . bindec(str_split(sprintf('0b%b',\
    \ $n * pow(2, $m - $n)))) : '0b-1';\n}\n", "    if ($n >= $m) {\n        return\
    \ -1;\n    }\n\n    $round = round($n / $m) * $m;\n\n    $bin = (string) $round;\n\
    \    $bin = str_pad($bin, strlen($bin) - 4, '0', STR_PAD_LEFT);\n\n    return\
    \ $bin;\n}\n"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
