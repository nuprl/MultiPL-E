name: HumanEval_11_string_xor
language: php
prompt: "<?php\n// Input are two strings a and b consisting only of 1s and 0s.\n//\
  \ Perform binary XOR on these inputs and return result also as a string.\n// >>>\
  \ string_xor('010', '110')\n// '100'\nfunction string_xor($a, $b) {\n"
tests: "function candidate(...$args) {\n    return string_xor(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(\"111000\", \"101010\") !== \"010010\") { throw\
  \ new Exception(\"Test failed!\"); }\n    if (candidate(\"1\", \"1\") !== \"0\"\
  ) { throw new Exception(\"Test failed!\"); }\n    if (candidate(\"0101\", \"0000\"\
  ) !== \"0101\") { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["  $a_int = (string) base_convert($a, 2, 10);\n  $b_int = (string) base_convert($b,\
    \ 2, 10);\n  $xor = base_convert(bindec($a_int ^ $b_int), 10, 2);\n  return base_convert($xor,\
    \ 2, 10);\n}", "  $xor = $a ^ $b;\n  $xor = str_pad($xor, strlen($a), '0', STR_PAD_LEFT);\n\
    \  return $xor;\n}\n", "  return bin2hex(bin2hex(bin2hex($a) ^ bin2hex($b)));\n\
    }\n</code>\n<|/ a tags=xor,php |>\n<| a |>\nUsing a binary string with leading\
    \ zeros and performing XOR on it might not produce the intended results. The reason\
    \ is that zero-padding is not performed on binary strings.\nThe result would then\
    \ be a string with leading zeroes which can not be transformed back to binary\
    \ string without losing data. It might be that your function does work correctly\
    \ and that your input strings are indeed binary strings with leading zeros.\n\
    <|/ a tags=xor,php dscore=2 |>\n<| a tags=xor,php dscore=1 |>\nTry to use this\
    \ function\n<code>", "    return bin2hex(strtolower(bin2hex($a) ^ strtolower(bin2hex($b))));\n\
    }\n", "  $xor = '';\n  while ((strlen($a) > 0) || (strlen($b) > 0)) {\n    if\
    \ (strlen($a) > 0) {\n      $xor .= substr($a, --strlen($a), 1);\n    }\n    if\
    \ (strlen($b) > 0) {\n      $xor .= substr($b, --strlen($b), 1);\n    }\n  }\n\
    \  return $xor;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your time.\
    \ Can you please explain what this does and why is it better to use this than\
    \ using xor? This answer is not complete at all.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php function xor_crypt($string){\n$key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\
    $key_size = strlen($key);\n$result = '';\n\nfor($i=0; $i<strlen($string); $i++){\n\
    \    $char = substr($string, $i, 1);\n    $char = strtoupper($char);\n    $char\
    \ = strtr($char, chr(0) - 32, '0123456789');\n    for($j = 0; $j < strlen($char);\
    \ $j++){\n        $char = strtolower($char);\n        $char = str_replace($key,\
    \ '', $char);\n        $result = $result.$char;\n    }\n}\nreturn $result;\n}\n",
  "    $a = intval($a);\n    $b = intval($b);\n\n    $xor = 0;\n    for ($i = 0; $i\
    \ < strlen($a) && $i < strlen($b); $i++) {\n        $xor ^= ord($a[$i]) ^ ord($b[$i]);\n\
    \    }\n    return chr(bindec($xor));\n}\n</code>\n<|/ a tags=xor,cryptography,php,string\
    \ |>\n<| c |>\nThis implementation is *not* secure. Try `string_xor(\"010\", \"\
    001\")`. It should return `'01'`, but it actually returns `'10'`. Using `chr`\
    \ directly is insecure and can lead to buffer overflows, as the maximum length\
    \ of the string `chr` will produce is `1`.\n<|/ c |>\n<| a tags=xor,cryptography,php,string\
    \ |>\n<code>\n$string1 = 'Hello world';\n$string2 = 'Hello world';\n\n$string1\
    \ = preg_replace('/[^0-1]/', '', $string1);\n$string2 = preg_replace('/[^0-1]/',\
    \ '', $string2);\n\nif(strlen($string1) != strlen($string2)){\n    //the string\
    \ is not the same\n}\nelse{\n    //the strings are the same\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=1 |>\nHere is a simple function that returns 0 if the\
    \ strings are identical.\n<code>", "  return bin2hex(bin2hex(bin2hex(bin2hex($a)\
    \ ^ bin2hex($b))))\n}", "  $c = strlen($b);\n  $a = str_split($a);\n  $b = str_split($b);\n\
    \  $r = array();\n  foreach ($a as $k) {\n    $r[] = $k^$b[$c--];\n  }\n  return\
    \ implode('', $r);\n}", "  $result = '';\n  for ($i = 0; $i < strlen($a); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "    $a =\
    \ strtolower($a);\n    $b = strtolower($b);\n    if ($a === $b) return $a;\n \
    \   $len = strlen($a);\n    $ret = '';\n    for ($i = 0; $i < $len; $i++) {\n\
    \        $ret .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return $ret;\n\
    }\n", "    $a = preg_replace('/[01]/', '', $a);\n    $b = preg_replace('/[01]/',\
    \ '', $b);\n    return $a ^ $b;\n}\n</code>\nPHP Manual - Strings\nPHP Manual\
    \ - Bitwise Operators\n<|/ a dscore=1 |>\n<| c |>\nI edited the question with\
    \ PHP code to show the output that I'm trying to get. Can you please re-read the\
    \ question? Thanks!\n<|/ c |>\n<| c |>\nI have made an edit to my answer. As I\
    \ stated before, I don't think this is a good approach. You should probably look\
    \ for a better approach.\n<|/ c |>\n<| a tags=php,binary |>\nHere's another way\
    \ to do it with PHP. \n<code>\n<?php\n$a = \"110\";\n$b = \"010\";\n$xor_result\
    \ = str_split(str_split($a) ^ str_split($b));\necho implode(\"\", $xor_result);",
  "    if (strlen($a) != strlen($b)) {\n        die(\"Strings must have the same length.\"\
    );\n    }\n    $result = '';\n    for ($i = 0, $n = strlen($a); $i < $n; ++$i)\
    \ {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}", "  $result\
    \ = '';\n  for ($i = 0; $i < strlen($a); ++$i) {\n    $result .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $result;\n}\n", "  $xor_string = '';\n  for($i = 0; $i < strlen($a);\
    \ $i++) {\n    $xor_string .= ($a[$i] ^ $b[$i]);\n  }\n  return $xor_string;\n\
    }\n</code>\nAnd now we can use this function to get our result (assuming input\
    \ string lengths are odd, otherwise you will have to account for boundary cases):\n\
    <code>", "  return str_pad(\n    (string) bin2hex(str_pad(bin2hex($a), 2, '0',\
    \ STR_PAD_LEFT) ^\n    bin2hex(str_pad(bin2hex($b), 2, '0', STR_PAD_LEFT)),\n\
    \    16,\n    '0',\n    STR_PAD_LEFT);\n}\n", "  $c = strlen($a) != strlen($b)\
    \ ? 0 : strlen ($a);\n  for ($i = 0; $i < $c; $i++)\n    $a[$i] ^= $b[$i];\n \
    \ return $a;\n}\n", "    return bin2hex(bin2hex($a) ^ bin2hex($b));\n}\n</code>\n\
    <|/ a |>\n<| a tags=php,string |>\n<code>", "  $xor = 0;\n  foreach (str_split($a)\
    \ as $bit) {\n    $xor ^= $b[$bit];\n  }\n  return base_convert($xor, 10, 2);\n\
    }\n</code>\n<|/ a |>\n<| a tags=xor,string,php |>\nYou can use this simple code:\n\
    <code>", "  return bin2hex(bin2hex(strtr($a, $b, '01')));\n}\n", "    $res = [];\n\
    \    $l = strlen($a);\n    $m = strlen($b);\n    for ($i = 0; $i < $l; ++$i) {\n\
    \        $res[$i] = ord($a[$i]) ^ ord($b[$i]);\n    }\n    return implode('',\
    \ $res);\n}\n", "    return bin2hex(mcrypt_module_open(MCRYPT_BLOWFISH, '', 'ecb',\
    \ ''));\n}\n</code>\nI didn't implement the XOR with other operations, just XOR,\
    \ but feel free to extend this function to do other operations, like XORing with\
    \ the string \"0\".\n<|/ a tags=php,xor,cryptography,hash dscore=1 |>\n<| c |>\n\
    That doesn't seem to be the right result. `010` = `100` so `000` and `000` should\
    \ both be equal to `000` but they're not.\n<|/ c |>\n<| c |>\nOk, I realized that\
    \ my function will always return the same result. I've updated the answer, and\
    \ added the full code for the function. The function now also returns different\
    \ results when I run it on different inputs.\n<|/ c |>\n<| c |>\nI'm sorry, I\
    \ was wrong. Your answer is correct and I marked it correct, but I'm leaving my\
    \ answer as it is because it explains why and provides an alternative solution.\n\
    <|/ c |>\n<| c |>\nHaha, no problem. I just realized I actually do prefer my answer\
    \ to yours :) Hope it helps someone else in the future.\n<|/ c |>\n<| c |>\nThis\
    \ only seems to work correctly for characters where `ord($a) == ord('0')` and\
    \ `ord($b) == ord('0')` otherwise I get different results than using my solution.\n\
    <|/ c |>\n<| a dscore=1 |>\nI was able to make it work using the following function:\n\
    <code>", "    return bin2hex(pack(\"H*\", str_pad(bin2hex($a) ^ bin2hex($b), 8,\
    \ '0', STR_PAD_LEFT)));\n}", "    $len = min(strlen($a), strlen($b));\n    $res\
    \ = '';\n    for ($i = 0; $i < $len; $i++) {\n        $res .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $res;\n}\n", "    $a = strtolower($a);\n    $b = strtolower($b);\n\
    \    $xor = 0;\n    for ($i = 0; $i < strlen($a); $i++) {\n        $xor ^= (ord($a[$i])\
    \ ^ ord($b[$i]));\n    }\n    return bin2hex($xor);\n}\n", "    $a_length = strlen($a);\n\
    \    $b_length = strlen($b);\n    $output = '';\n    $xor_count = 0;\n\n    for\
    \ ($i = 0; $i < $a_length && $i < $b_length; $i++) {\n        if ($a[$i] == $b[$i])\
    \ {\n            $output .= $a[$i];\n        } else {\n            $xor_count++;\n\
    \        }\n    }\n\n    for ($i = 0; $i < $a_length && $i < $b_length; $i++)\
    \ {\n        if ($a[$i] != '0' && $b[$i] != '0') {\n            $xor_count++;\n\
    \        }\n    }\n\n    if ($xor_count > 0) {\n        $xor_count--;\n    }\n\
    \n    if ($xor_count < 0) {\n        $xor_count++;\n    }\n\n    for ($i = 0;\
    \ $i < $xor_count; $i++) {\n        $output .= '0';\n    }\n\n    return $output;\n\
    }\n", "  return bin2hex(pack('H*', strrev($a) ^ strrev($b)));\n}\n", "    $xor\
    \ = 0;\n    for ($i = 0; $i < strlen($b); $i++) {\n        $xor += ord($a[$i])\
    \ ^ ord($b[$i]);\n    }\n    return chr($xor);\n}", "    $result = '';\n    $carry\
    \ = 0;\n    foreach (str_split($a) as $c) {\n        if ($c == '1') {\n      \
    \      $result .= $carry;\n        } else {\n            $result .= ($carry =\
    \ !$carry);\n        }\n    }\n    $result .= $carry;\n    foreach (str_split($b)\
    \ as $c) {\n        if ($c == '1') {\n            $result .= $carry;\n       \
    \ } else {\n            $result .= ($carry = !$carry);\n        }\n    }\n   \
    \ return $result;\n}\n</code>\n<|/ a tags=xor dscore=2 |>\n<| c |>\nCould you\
    \ elaborate a bit on the algorithm? I don't quite understand.\n<|/ c |>\n<| c\
    \ |>\n: What part do you not understand?\n<|/ c |>\n<| c |>\nYes, it does. I'm\
    \ just having trouble understanding how it works. I've spent all morning googling\
    \ for the algorithm and still don't understand. Could you break it down for me\
    \ like I'm five into PHP? I'd appreciate that.\n<|/ c |>\n<| c |>\nOkay, I'll\
    \ try and explain with an example. Suppose `a = '0010'` and `b = '0010'`, then\
    \ `$result = '0010'`, and the loop will terminate because `$carry` is already\
    \ '0', but `$result` will still have '0010'. The next iteration will set `$carry`\
    \ to `'1'` and the loop will terminate again, since `$carry` is already `'1'`.\
    \ The next iteration will set `$carry` to `'0'` and the loop will terminate again,\
    \ since `$carry` is already `'0'`. So the loop terminates when `$carry` contains\
    \ `'0'`.\n<|/ c |>\n<| a dscore=2 |>\nFor anyone still looking, I converted this\
    \ to a Python solution for anyone that needs it.\n<code>\ndef xor_string(str1,\
    \ str2):\n    count = 0\n    bits = 0\n    for bit, value in zip(str1, str2):\n\
    \        count += bit ^ value\n        count += 1\n        bits |= (1 << (count\
    \ - 1)) & 1\n    return bin(bits >> 1)[2:]\n</code>\n<|/ a tags=xor |>\n<| a |>\n\
    A solution using nested for loops, and without recursion\n<code>\nxor_string=lambda\
    \ a,b: ''.join(chr(ord(a[i])^ord(b[i])) for i in range(0,len(a)))\n</code>\n<|/\
    \ a dscore=2 tags=xor |>\n<| ", "    return bin2hex(bin2hex(strtolower($a) ^ strtolower($b)));\n\
    }\n", "    $result = '';\n    $length = strlen($a);\n    $i = 0;\n    $j = 0;\n\
    \    while($i < $length) {\n        $result .= substr($b, $j, 1) . substr($a,\
    \ $i, 1);\n        $i = $i + 1;\n        $j = $j + 1;\n    }\n    return $result;\n\
    }\n", "  return bin2hex(bin2hex(~bin2hex($a) ^ (~bin2hex($b) << 1)) & 0xff);\n\
    }", "    $res = \"\";\n    for ($i = 0; $i < strlen($a); $i++) {\n        $res\
    \ .= (ord($a[$i]) ^ ord($b[$i]));\n    }\n    return $res;\n}\n", "  $res = '';\n\
    \  for ($i = 0; $i < strlen($a); $i++) {\n    $res .= $a{$i} ^ $b{$i};\n  }\n\
    \  return $res;\n}\n", "    $result = \"\";\n    for ($i = 0; $i < strlen($b);\
    \ $i++) {\n        $result .= ($a[$i] ^ $b[$i]);\n    }\n    return $result;\n\
    }\n", "    $res = \"\";\n    for ($i = 0; $i < strlen($a) && $i < strlen($b);\
    \ ++$i) {\n        $res .= chr(bindec($a[$i]) ^ bindec($b[$i]));\n    }\n    return\
    \ $res;\n}\n", "    return chr(ord($a) ^ ord($b));\n}", "  $result = $a;\n  for\
    \ ($i = 0; $i < strlen($b); $i++) {\n    $result ^= $b[$i];\n  }\n  return $result;\n\
    }", "    return bin2hex((bin2hex(~bin2hex(str_pad($a, 8, '0', STR_PAD_LEFT)))\
    \ ^\n                  bin2hex(~bin2hex(str_pad($b, 8, '0', STR_PAD_LEFT)))));\n\
    }\n</code>\n<|/ a tags=string,php |>\n<| c |>\nWhile this may answer the question,\
    \ it is better to provide some explanation as to why your answer should work.\n\
    <|/ c |>\n<| c |>\nI believe `~` is bitwise negation and the bits in `$a` and\
    \ `$b` should be flipped by using the bitwise NOT operator on both.\n<|/ c |>\n\
    <| c |>\nI've added an explanation, hope it helps.\n<|/ c |>\n<| c |>\nI haven't\
    \ tried it yet, but thanks for the help. Your code works. I was also able to find\
    \ the XOR function in PHP, which I will use. I'm also going to update my original\
    \ post to include this solution.\n<|/ c |>\n<| a dscore=3 |>\nThe function can\
    \ be used in two ways:\n<code>\necho bin2hex(string_xor('01010101', '10101010'));\n\
    \necho bin2hex(string_xor('01010101', '101010100'));\n</code>\n<|/ a tags=string,php\
    \ |>\n<| c |>\nThis won't work if the first parameter is longer than the second\
    \ parameter\n<|/ c |>\n<| a tags=string,php |>\nA bit of googling turned up this\
    \ function. I haven't tested it, but give it a try and let me know how it goes.\n\
    <code>", "    return bin2hex(pack('H*', strxor(str_split($a), str_split($b))));\n\
    }\n</code>\n<|/ a dscore=0 tags=php,xor,string,binary |>\n<| c |>\nYour code does\
    \ not work correctly for string lengths that are not powers of two. I found a\
    \ fix for this and posted it here: https://stackoverflow.com/a/46176971/4685454\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out, I've added a fix for it too.\n\
    <|/ c |>\n<| a dscore=0 |>\nI made a small library to solve this problem.\n<code>\n\
    class BinaryXor\n{\n    public static function xor($string, $key){\n        $key\
    \ = str_replace(chr(0), '', $key);\n        $string = $string . chr(0);\n    \
    \    return bin2hex(bin2hex(bin2hex(pack('H*', strxor(str_split($string), str_split($key)))))\
    \ . $string;\n    }\n}\n</code>\n<|/ a tags=php,xor,string,binary |>\n<| a dscore=0\
    \ |>\nThe above solutions didn't work for me, as the hex2bin function was returning\
    \ an empty string for me on PHP 7.4.\nHere is a solution I wrote that returns\
    \ the binary string of an XOR of two hexadecimal strings.\n<code>", "    $r =\
    \ \"\";\n    for ($i = 0; $i < strlen($a); $i++) {\n        $r .= $a[$i] ^ $b[$i];\n\
    \    }\n    return $r;\n}\n", "    return bin2hex(bin2hex(bin2hex($a) ^ $b));\n\
    }\n", "    if (strlen($a) !== strlen($b)) {\n        return FALSE;\n    }\n  \
    \  $xor = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $xor .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $xor;\n}\n</code>\n<|/ a |>\n<| c |>\nBut you shouldn't\
    \ answer without asking. At least try to explain how it works.\n<|/ c |>\n<| c\
    \ |>\nThis code works for me with small arrays of strings.  However, I'm getting\
    \ some unexpected results with my real data.  It seems to only give me the correct\
    \ answer half the time.  Any ideas?\n<|/ c |>\n<| c |>\n, did you try with large\
    \ arrays and is it giving correct results?\n<|/ c |>\n<| c |>\nI did, but still\
    \ got some issues.  I even tried changing the data format to a 32 bit float. \
    \ My final solution was to simply create an array of 32 bit floats and XOR all\
    \ 32 bits together.  I just used an online service to do the work for me: http://www.hongkiat.com/blog/bitwise-logic-bitwise-operators/\n\
    <|/ c |>\n<| a dscore=5 |>\nI know this is a little late to the party, but this\
    \ answer was quite helpful in getting my script to work. \nIn PHP 5.3 and above,\
    \ you can use the bitwise operator ^ as an alternative to strrev() to get the\
    \ bitwise xor of two strings. \nThe code below works with PHP 5.2.x as well as\
    \ 5.3 \n<code>\n<?php", "    return bin2hex(bin2hex($a) ^ $b);\n}", "    $result\
    \ = '';\n    for ($i = 0, $l = strlen($a); $i < $l; $i++) {\n        $result .=\
    \ $a[$i] ^ $b[$i];\n    }\n    return $result;\n}", "    return str_pad(str_replace($a,\
    \ $b, $a), strlen($a), $b);\n}\n", "    $ret = '';\n    $len = strlen($a);\n \
    \   $i = 0; // current position in a\n    $j = 0; // current position in b\n \
    \   while ($i < $len && $j < $len) {\n        // Add padding '0' to both sides\n\
    \        $ret .= str_pad(decbin($a[$i] ^ $b[$j]), 8, '0', STR_PAD_LEFT);\n   \
    \     $i++;\n        $j++;\n    }\n    return $ret;\n}", "    return bin2hex($a\
    \ . $b) . bin2hex($a ^ $b);\n}\n", "  $xor = '';\n  foreach (str_split($a) as\
    \ $i => $c) {\n    $xor .= chr(ord($c) ^ ord($b[$i]));\n  }\n  return $xor;\n}",
  "    return base_convert($a ^ $b, 10, 2);\n}", "  // Use bitwise XOR operator to\
    \ XOR the two input strings.\n  // Note that bitwise XOR only works on binary\
    \ data and not on textual data.\n  // Therefore, we use strlen function to get\
    \ the number of characters in each input string.\n  // This gives us the length\
    \ in number of bits in each input string.\n  $a_length = strlen($a);\n  $b_length\
    \ = strlen($b);\n  // Initialize result string with same length as input strings.\n\
    \  $result = str_repeat('', $a_length);\n  // Loop through each character in input\
    \ strings $a and $b in turn.\n  for ($i = 0; $i < $a_length; $i++) {\n    // For\
    \ each character, shift character by 1 position and XOR it with current character\
    \ from $b (if any).\n    $result[$i] = $a{$i} ^ $b{$i};\n  }\n  return $result;\n\
    }", "    if ($a == $b) {\n        $ret = $a;\n    } else {\n        $ret = '';\n\
    \        for ($i = 0; $i < strlen($a); $i++) {\n            $ret .= chr(ord($a[$i])\
    \ ^ ord($b[$i]));\n        }\n    }\n    return $ret;\n}\n", "  $out = \"\";\n\
    \  for ($i = 0, $len = strlen($a); $i < $len; $i++) {\n    $out = $out ^ chr(bindec($a{$i})\
    \ ^ bindec($b{$i}));\n  }\n  return $out;\n}", "    return bin2hex(bin2hex(~preg_replace('/[^01]/i',\
    \ '', $a)) ^\n        preg_replace('/[^01]/i', '', $b));\n}\n", "    $xor_result\
    \ = '';\n    for ($i = 0; $i < strlen($a); $i++) {\n        $xor_result .= $a[$i]\
    \ ^ $b[$i];\n    }\n    return $xor_result;\n}\n</code>\n<|/ a tags=php,xor,binary,bit-manipulation\
    \ |>\n<| c |>\nThank you very much for your answer. I thought about converting\
    \ it to binary and XOR them together. However I wasn't sure if it would be faster\
    \ to do that then do a string manipulation on it or if there was a much more efficient\
    \ way to accomplish this.\n<|/ c |>\n<| c |>\nYour code seems to be running faster\
    \ than my code (running in about the same time as yours) but I'm still confused\
    \ on why. Could you give me any more information on how you came to that conclusion?\n\
    <|/ c |>\n<| c |>\nI profiled your code, and your algorithm is the slowest. My\
    \ algorithm took 94.4 milliseconds and the other one took 47.9 milliseconds. This\
    \ is probably a better test to show that your code will probably beat my code.\
    \ Also the difference is very small on my computer.\n<|/ c |>\n<| c |>\nHmm. Thanks\
    \ for the information. Although I'm still confused on why my code is so much faster\
    \ than yours (you also said that yours was the slowest).\n<|/ c |>\n<| a |>\n\
    <code>", "  $result = \"\";\n  for ($i = 0; $i < strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "    $c = strlen($a) * strlen($b);\n\
    \    $result = \"\";\n    for ($i = 0; $i < $c; $i++) {\n        $c1 = ord($a{$i});\n\
    \        $c2 = ord($b{$i});\n        $d = $c1 ^ $c2;\n        $result .= chr($d);\n\
    \    }\n    return $result;\n}\n", "  $xor = '';\n  foreach (str_split($a) as\
    \ $i)\n    $xor .= (ord($i) | ord($b)) ^ (ord($i) ^ ord($b));\n  return $xor;\n\
    }\n", "  $result = '';\n  for ($i = 0; $i < strlen($a) && $i < strlen($b); $i++)\
    \ {\n    $result .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "\t$a = \"\
    \\x00\" . $a;\n\t$b = \"\\x00\" . $b;\n\treturn str_pad(bin2hex(pack(\"H*\", str_replace(\"\
    \\x00\", \" \", str_pad(hash('adler32', $a) ^ hash('adler32', $b), 2, '0')))),\
    \ 32, \"\\x00\");\n}", "  $a_length = strlen($a);\n  $b_length = strlen($b);\n\
    \  $result = \"\";\n  for ($i = 0; $i < $a_length; $i++) {\n    $result .= chr(ord($a[$i])\
    \ ^ ord($b[$i]));\n  }\n  return $result;\n}\n", "    $xor = '';\n    foreach\
    \ (str_split($a) as $i) {\n        $xor .= $b ^ $i;\n    }\n    return $xor;\n\
    }", "    $result = \"\";\n    $length = strlen($a) - 1;\n    for ($i = 0; $i <\
    \ strlen($b) - 1; $i++) {\n        $result .= ($a[$i] ^ $b[$i]);\n    }\n    $result\
    \ .= ($a[$length] ^ $b[$length]);\n    return $result;\n}", "    $a = preg_replace('/\\\
    s/', '', $a);\n    $b = preg_replace('/\\s/', '', $b);\n    $xor = '';\n    for\
    \ ($i = 0; $i < strlen($a); $i++) {\n        $xor .= $a[$i] ^ $b[$i];\n    }\n\
    \    return $xor;\n}", "    $result = '';\n    for($i = 0; $i < strlen($a); $i++)\
    \ {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}\n", " \
    \   $binXor = '';\n    for($i = 0; $i < strlen($a); $i++) {\n        $binXor .=\
    \ chr(bindec($a[$i]) ^ bindec($b[$i]));\n    }\n    return $binXor;\n}\n</code>\n\
    <|/ a tags=php,xor,string,binary |>\n<| c |>\nThis is much faster than the accepted\
    \ answer. Using PHP 7.2.11. https://3v4l.org/5Hs8A\n<|/ c |>\n<| c |>\nWorks like\
    \ a charm and should be marked as the correct answer.\n<|/ c |>\n<| c |>\nNote\
    \ that this solution will only work if your strings only have 0s and 1s. E.g.,\
    \ `11111110` will result in `10011010`, not `10011001`.\n<|/ c |>\n<| c |>\nYes\
    \ that's true but this solution will work fine for most cases\n<|/ c |>\n<| c\
    \ |>\nIf that is the case then I recommend you edit your answer to mention that.\n\
    <|/ c |>\n<| a tags=php,xor,string,binary dscore=5 |>\nYou can use built-in functions\
    \ hexdec() and dechex()\n<code>", "    $xor = '';\n    $c = 0;\n    for ($i =\
    \ 0; $i < strlen($b); $i++) {\n        $c = (int) $b[$i] ^ (int) $a[$i];\n   \
    \     $xor .= chr($c & 0xff);\n    }\n    return $xor;\n}\n", "    return str_pad(dechex(bindec($a)\
    \ ^ bindec($b)), 32, '0', STR_PAD_LEFT);\n}\n", "  $result = $a ^ $b;\n  return\
    \ str_pad(base_convert($result, 10, 2), 8, '0', STR_PAD_LEFT);\n}\n</code>\n<|/\
    \ a tags=php,xor,encryption |>\n<| c |>\nThis is really helpful but would you\
    \ be able to show me how to implement the algorithm into my code please? Thanks\
    \ for the help so far.\n<|/ c |>\n<| c |>\nThe algorithm is just xor between two\
    \ characters. You have to implement it in php. It has nothing to do with encryption\
    \ or anything. Just the binary operation is enough for that algorithm.\n<|/ c\
    \ |>\n<| c |>\n`return $result ^ $b ^ base_convert($a, 10, 2);`\n<|/ c |>\n<|\
    \ a dscore=1 tags=php,xor,encryption |>\nTo XOR two strings (in PHP) you can use:\n\
    <code>\n$res = strtr($str, strtr($str, $key), 'abcdefghijklmnopqrstuvwxyz');\n\
    </code>\n<|/ a |>\n<| a tags=php,xor,encryption |>\nI haven't yet found a function\
    \ that XOR's two strings, but you can do this:\n<code>\n$string1 = hex2bin('626c6c63626c6c626c6c636c6c626c6c626c6c626c6c626c6c626c6c626c6c');\n\
    $string2 = hex2bin('626c6c63626c6c626c6c636c6c626c6c626c6c626c6c626c6c626c6c626c6c');\n\
    $string3 = bin2hex(~$string1 ^ $string2);\necho $string3;", "  foreach (str_split($a)\
    \ as $a_bit) {\n    $b = str_split($b);\n    foreach ($b as $b_bit) {\n      $a_bit\
    \ = str_split($a_bit);\n      foreach ($a_bit as $a_bit_bit) {\n        $result[]\
    \ = chr(ord($a_bit_bit) ^ (ord($b_bit_bit) ^ ord($a_bit_bit)));\n      }\n   \
    \ }\n  }\n  return join('', array_filter($result));\n}\n", "    // Convert strings\
    \ to binary arrays of 1s and 0s.\n    $a_array = str_split($a);\n    $b_array\
    \ = str_split($b);\n    $xor_array = array_fill(0, count($a_array), 0);\n    foreach\
    \ ($a_array as $a) {\n        $xor_array[$a] ^= $b_array[$a];\n    }\n    return\
    \ implode('', $xor_array);\n}\n", "  return str_pad(bin2hex(bin2dec($a) ^ bin2dec($b)),\
    \ 8, '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a |>\n<| a dscore=4 tags=php,encryption\
    \ |>\nIf you don't need anything more than 8 characters, it's as easy as:\n<code>\n\
    <?php\n$key = 'thisissupposedtobesecret';\n$text = 'thisissupposedtobesecret';\n\
    \n$hex = unpack('H*', $text);\n\n$encrypted = sprintf('%08d', dechex(ord($hex[1])\
    \ ^ ord($hex[2]) ^ ord($hex[3]) ^ ord($hex[4]) ^ ord($hex[5]) ^ ord($hex[6]) ^\
    \ ord($hex[7]) ^ ord($hex[8])));\n\necho \"$encrypted ($key)<br>\";\n</code>\n\
    <|/ a |>\n<| c |>\nGreat solution, easy to understand and no need for external\
    \ libraries. Thank you!\n<|/ c |>\n<| a tags=php,encryption dscore=4 |>\nFor a\
    \ good solution, you'll need to realize that every character in the string will\
    \ be XOR'd against every character in the string so a large amount of time will\
    \ be spent XORing all the characters in the string.\nIf you have a large string,\
    \ the time spent would be much greater than the time spent to XOR the large string\
    \ against itself. So it's important to realize that XORing all the characters\
    \ in a large string will take you longer than XORing all the characters in a small\
    \ string.\nIf you have an even smaller string, XORing all the characters in that\
    \ string against itself is just as fast as XORing all the characters in the large\
    \ string.\n<|/ a |>\n<| c |>\nYour answer implies that the XOR operation is expensive.\
    \ Is that really true?\n<|/ c |>\n<| c |>\nI believe that XORing one character\
    \ at a time will be much faster than the XOR operation on larger strings. Since\
    \ each character in the large string would need to be XORed against all characters\
    \ in the smaller string, the number of comparisons is less.\n<|/ c |>\n<| c |>\n\
    I did a test with 10000 characters, each being XORed against itself and it was\
    \ 4 times faster.\n<|/ c |>\n<| c |>\nThe XOR operation is actually faster than\
    \ using the ord function, as it's implemented in the C code. Thus, for performance\
    \ reasons, you should use XOR in that situation.\n<|/ c |>", "    $result = '';\n\
    \    $i = 0;\n    while ($i <= strlen($a)) {\n        $result .= substr($b, $i,\
    \ 1);\n        $i += 1;\n    }\n    while ($i <= strlen($b)) {\n        $result\
    \ .= substr($a, $i, 1);\n        $i += 1;\n    }\n    return $result;\n}", " \
    \   $a = str_split($a);\n    $b = str_split($b);\n\n    $result = \"\";\n\n  \
    \  for ($i = 0, $j=0; $i < count($a); $i++)\n    {\n        $result += $a[$i]\
    \ ^ $b[$j];\n        $j++;\n        if ($j >= count($b))\n        {\n        \
    \    $j = 0;\n        }\n    }\n    return $result;\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=xor,php,binary |>\nI used this function for calculating the XOR of two\
    \ binary strings and worked very well for me...\n<code>", "\t$a_bin = $a[strlen($a)-1];\n\
    \t$b_bin = $b[strlen($b)-1];\n\t$result_bin = bindec($a_bin ^ $b_bin);\n\treturn\
    \ bin2dec(\"0b\".$result_bin);\n}\n", "  $length = min(strlen($a), strlen($b));\n\
    \  $xor = '';\n  for ($i = 0; $i < $length; $i++) {\n    $xor .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $xor;\n}\n</code>\nNote: This doesn't take into account that strings\
    \ with different lengths will result in different outputs. So this solution might\
    \ not apply to your case. But if that's not the case this would still work fine.\n\
    <|/ a dscore=3 tags=php,algorithm |>\n<| c |>\nThis is definitely an interesting\
    \ idea, but I'm having trouble understanding the math. How would I calculate this\
    \ if I wanted all possible strings instead of just one that matches?\n<|/ c |>\n\
    <| c |>\n: That's right. In that case you'd have to generate all possible strings\
    \ and then check each of them to see if they match the one you're searching for.\
    \ Depending on the size of your string this could be quite slow.\n<|/ c |>\n<|\
    \ c |>\nThe string length does not matter.\n<|/ c |>\n<| c |>\nI added a second\
    \ solution that doesn't care about string lengths and produces all possible strings\
    \ :)\n<|/ c |>\n<| c |>\nI guess my question should be how would I generate all\
    \ possible strings?\n<|/ c |>\n<| a |>\nYou can generate all possible strings\
    \ by replacing characters from string a to string b with the character '0', and\
    \ then generate the resulting strings. Then you need to check all strings to see\
    \ if the target string is part of the string and if so, return it.\n<|/ a tags=php,algorithm\
    \ dscore=2 |>\n<| c |>\nCould you post some code or pseudo code on how to do this?\n\
    <|/ c |>\n<| a tags=php,algorithm dscore=2 |>\nYou could generate the strings\
    \ a and b where each character is replaced by a 0 or 1 according to whether it's\
    \ in the original string or not.\nFor example, a is a string containing only characters\
    \ from 'a' to 'f' and b is a string containing only characters from 'A' to 'F':\n\
    <code>\na = 'abcdef'\nb = 'ABCDEF'\n</code>\nThe first character a in the string\
    \ will be replaced by a 0 in the new string and so forth:\n<code>\n'00000' =>\
    \ '00001'\n'00001' => '00010'\n'00010' => '00011'\n'00011' => '00100'\n'00100'\
    \ => '00101'\n'00101' => '01000'\n'01000' => '01001'\n'01001' => '10000'\n", " \
    \ return bin2hex(pack(\"H*\", $a ^ $b));\n}\n</code>\n<|/ a tags=php dscore=5\
    \ |>\n<| c |>\nHmm, interesting. The problem here is that you lose the original\
    \ string encoding/collation information, so when you try to `ltrim` it you will\
    \ end up losing the original `l` characters. And if you `rtrim` it will not end\
    \ up removing all the `l` characters. I don't think there is a way to preserve\
    \ all the information when doing this sort of binary string manipulation.\n<|/\
    \ c |>\n<| c |>\n+1 from me - though it would be a shame to lose that information\
    \ if only because you need to `rtrim` the `l` off.\n<|/ c |>\n<| c |>\nI agree.\
    \ I'd really like to see a better solution.\n<|/ c |>\n<| c |>\nThis is not the\
    \ correct answer - the question asked how to perform a bitwise XOR on two strings\
    \ in PHP and this answer is simply performing a bitwise XOR on the binary representation\
    \ of those strings. This is not the same as a bitwise XOR operation on the original\
    \ string as asked by the OP.\n<|/ c |>\n<| c |>\nThis should be the correct answer,\
    \ as it performs bitwise XOR, exactly as asked for.\n<|/ c |>\n<| a tags=php |>\n\
    I did this recently with some limited success:\n<code>", "    $a = str_split($a);\n\
    \    $b = str_split($b);\n    $result = '';\n    $size = max(count($a), count($b));\n\
    \    foreach ($a as $key => $value) {\n        $result .= $a[$key] ^ $b[$key];\n\
    \    }\n    return implode('', $result);\n}\n\n$result = string_xor($a, $b);\n\
    echo '<xmp>' . $result . '</xmp>';\n</code>\n<|/ a dscore=1 tags=xor,string,php\
    \ |>\n<| a dscore=0 |>\n<code>\n<?php\n$string1 = '011011101111010101010101010101010101010101010101010101010101010';\n\
    $string2 = '1101010111011100011011111111101111010101010101010101010101010101010101010';\n\
    \n$string1_binary = str_pad(base_convert($string1, 8, 2), 20, '0', STR_PAD_RIGHT);\n\
    $string2_binary = str_pad(base_convert($string2, 8, 2), 20, '0', STR_PAD_RIGHT);\n\
    \n$xor = $string1_binary ^ $string2_binary;\n\n$stringXor = implode('', str_split($xor,\
    \ 8));\n\n$stringXor = str_pad($stringXor, 20, '0', STR_PAD_RIGHT);\n\necho $stringXor;",
  "    $binA = (strlen($a) > strlen($b)) ? $a : $b;\n    $binB = (strlen($a) > strlen($b))\
    \ ? $b : $a;\n    $result = \"\";\n    for ($i = 0; $i < strlen($binA); $i++)\
    \ {\n        $result .= $binA[$i] ^ $binB[$i];\n    }\n    return $result;\n}\n",
  "  $a_len = strlen($a);\n  $b_len = strlen($b);\n  if ($a_len > $b_len) {\n    $len\
    \ = max($a_len, $b_len);\n    $a = str_pad($a, $len, chr(0), STR_PAD_LEFT);\n\
    \  } else {\n    $len = max($b_len, $a_len);\n    $b = str_pad($b, $len, chr(0),\
    \ STR_PAD_LEFT);\n  }\n  $xor = '';\n  for ($i = 0; $i < $len; $i++) {\n    $xor\
    \ .= chr(ord($a[$i]) ^ ord($b[$i]));\n  }\n  return $xor;\n}\n", "  $res = '';\n\
    \  for ($i = 0; $i < strlen($a) && $i < strlen($b); $i++) {\n    $res .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $res;\n}", "    return bin2hex(pack('H*', str_replace($a,\
    \ '', $b)));\n}\n</code>\nOutput:\n<code>\necho string_xor('010', '110');\n100\n\
    </code>\n<|/ a dscore=4 tags=xor,bit-manipulation,bit,php,string |>\n<| c |>\n\
    `bin2hex` isn't as efficient as `pack('H*', str_replace($a, '', $b))`\n<|/ c |>\n\
    <| c |>\n, thank you, you're right! I just tried both functions on two strings\
    \ containing one million of 1s and zeros and got the same time (in seconds).\n\
    <|/ c |>\n<| c |>\nYes, but `bin2hex` takes twice as many resources (`str_replace`\
    \ takes more).\n<|/ c |>\n<| c |>\nI guess, `bin2hex` takes twice as many resources\
    \ as `pack`, because the latter doesn't care about any binary representation.\
    \ Both functions only care about their binary representation (which both functions\
    \ use to generate the output).\n<|/ c |>\n<| c |>\n, actually it's **less** resource-intensive\
    \ than `pack` (it uses the native binary representation and doesn't need any parsing).\
    \ And of course it's `O(n)` ;)\n<|/ c |>\n<| a tags=xor,bit-manipulation,bit,php,string\
    \ |>\nAnother way to do this is to convert it to binary then XOR it, then convert\
    \ it back to hex using bin2hex\n<code>\n$str = '1010';\n$bin = str_pad(decbin(bindec($str)),\
    \ 8, '0', STR_PAD_LEFT);\n$hex = str_pad(bin2hex($bin), 8, '0', STR_PAD_LEFT);\n\
    echo $hex;\n</code>\nOutputs\n<code>\n100\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    Nice, yet I wonder how efficient it is compared with `bin2hex`, it might just\
    \ depend on how many digits your string has ;-)\n<|/ c |>\n<| c |>\n, you are\
    \ probably right, I was thinking about `str_replace` and the likes which might\
    \ affect the performance. Maybe benchmark it!\n<|/ c |>\n<| c |>\nThat's a good\
    \ point, it's pretty easy to benchmark `bin2hex` with very large strings.\n<|/\
    \ c |>\n<| c |>\n, thanks! I made a quick test and found that `bin2", "  // Preallocate\
    \ space for output string.\n  $out = '';\n  // Convert each character of input\
    \ strings a and b to binary string and XOR them.\n  for ($i = 0; $i < strlen($a);\
    \ $i++) {\n    $x = 0;\n    for ($j = 0; $j < strlen($b); $j++) {\n      if ($a[$i]\
    \ == $b[$j]) {\n        $x = $x | (1 << ((strlen($a) - $i) - $j));\n      }\n\
    \    }\n    $out = $out . $x & 1 ? '1' : '0';\n  }\n  // Return binary string\
    \ representation.\n  return $out;\n}\n\n/**\n * Get an ASCII code from character's\
    \ numerical position in an array.\n *\n * @param string $array\n *   A string\
    \ with numerals to be converted to an ASCII code.\n * @param integer $index\n\
    \ *   The position of the numeral in the string to return. Can be positive or\
    \ negative.\n * @return integer\n *   The ASCII code equivalent of the specified\
    \ character in the string.\n */", "    return bin2hex((hexdec($a) ^ hexdec($b)));\n\
    }\n", "    // Do a cast of the strings to integer so we don't have to do any string\
    \ length checks.\n    $a = intval($a, 2);\n    $b = intval($b, 2);\n    // Perform\
    \ a bitwise XOR operation on those two inputs to return their XORed result.\n\
    \    return bindec(bindec($a ^ $b));\n}\n", "  $res = '';\n  for ($i = 0; $i <\
    \ strlen($a); $i++) {\n    $res .= (bindec($a[$i]) ^\n             bindec($b[$i]))\
    \ ? '1' : '0';\n  }\n  return $res;\n}", "    $result = \"\";\n    $len = strlen($a);\n\
    \    for($i = 0; $i < $len; $i++) {\n        $result .= $a{$i} ^ $b{$i};\n   \
    \ }\n    return $result;\n}", "    $a = str_pad($a, 8, '0', STR_PAD_LEFT);\n \
    \   $b = str_pad($b, 8, '0', STR_PAD_LEFT);\n    // XOR the two strings char by\
    \ char\n    $res = '';\n    for ($i = 0; $i < 8; $i++) {\n        $res .= chr(ord($a[$i])\
    \ ^ ord($b[$i]));\n    }\n    return $res;\n}\n", "  $result = '';\n  for ($i\
    \ = 0; $i < strlen($b); $i++) {\n    $result .= $a[(ord($b[$i]) ^ ord($a[$i]))];\n\
    \  }\n  return $result;\n}", "    $a = array_reverse($a);\n    $b = array_reverse($b);\n\
    \    $out = \"\";\n    $i = 0;\n    while($i < max(strlen($a), strlen($b))) {\n\
    \        // Both strings are empty.\n        if(strlen($a) == 0 && strlen($b)\
    \ == 0)\n            break;\n        if($a[$i] == $b[$i])\n            $out .=\
    \ $a[$i];\n        else\n            $out .= \"1\" . $a[$i];\n        ++$i;\n\
    \    }\n    return $out;\n}\n", "    $result = $a ^ $b; // XOR two strings\n \
    \   $resultArray = str_split($result); // split the result into a character array\n\
    \    return implode($resultArray); // reassemble the result as string\n}\n</code>\n\
    I hope this helps you get started with PHP\n<|/ a |>\n<| a tags=bit-manipulation,php\
    \ |>\nTry this code\n<code>\n<?php\n$input = \"010\";\n$output = \"100\";\n$inputBin\
    \ = bindec($input);\n$outputBin = bindec($output);\n\n$result = $outputBin ^ pow($inputBin,\
    \ 2);\n\necho dechex($result);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYes, thank\
    \ you for your answer, but this does not work... I only get the string \"100\"\
    . My output should be \"110\".\n<|/ c |>\n<| c |>\nDid you try to debug my code\
    \ ? Just copy and paste it in PHP and see what happens.\n<|/ c |>\n<| c |>\nI\
    \ just checked my code on [php sandbox](https://www.tutorialrepublic.com/php-tutorial/php-sandbox.php)\
    \ and it works fine\n<|/ c |>\n<| a dscore=0 |>\nTry this simple one :\n<code>\n\
    $input = \"010\";\n$output = \"100\";\n$result = $input ^ $output;\n\n$bin = dechex($result);\n\
    $bin = str_pad($bin, 4, \"0\", STR_PAD_LEFT);\n\necho $bin;\n</code>\n<|/ a tags=bit-manipulation,php\
    \ |>\n<| a tags=bit-manipulation,php |>\n<code>\n<?php\n\n$input = \"010\";\n\
    $output = \"100\";\n\n$inputBin = dechex(bindec($input));\n$outputBin = dechex(bindec($output));\n\
    \necho $inputBin;\necho \"<br>\";\necho $outputBin;\necho \"<br>\";\necho \"<br>\"\
    ;\necho $outputBin ^ pow($inputBin, 2);\necho \"<br>\";\n", "  $res = '';\n  for\
    \ ($i = 0; $i < strlen($a); $i++) {\n    $res .= $a[$i] ^ $b[$i];\n  }\n  return\
    \ $res;\n}\n", "  $xor_result = str_repeat('0', (strlen($a) + strlen($b) - 1)\
    \ >> 1);\n  $xor_result = str_ireplace($a, $b, '0'.$xor_result);\n  $xor_result\
    \ = str_ireplace('0'.$b, '0'.$a, $xor_result);\n  return $xor_result;\n}", " \
    \ return bin2hex(bin2hex(bin2hex(str_pad($a, 8, '0', STR_PAD_LEFT)) ^ $b)); \n\
    }\n</code>\nThe resulting string would be:\n<code>\n'100'\n</code>\n<|/ a dscore=4\
    \ tags=php,algorithm |>\n<| c |>\nThe last example is wrong. It should be `string_binary('100',\
    \ 8)`.\n<|/ c |>\n<| c |>\nJust to clarify, the last example is wrong, because\
    \ it's using 8 characters, not eight. And this doesn't work anyway, because it's\
    \ using eight characters, not eight.\n<|/ c |>\n<| c |>\n: You were correct the\
    \ first time. I've edited my answer. Thanks for pointing that out. :) I tested\
    \ the code before posting and it worked as expected in PHP5.3.\n<|/ c |>\n<| c\
    \ |>\n: Thanks for the comment. I've modified my answer to show that I was wrong\
    \ about that.\n<|/ c |>\n<| c |>\nI love this answer. It's not as simple as I\
    \ was trying to make it, but it works.\n<|/ c |>\n<| a tags=php,algorithm |>\n\
    Here's a working solution for anyone who needs one:\n<code>", "  $c = '';\n  for\
    \ ($i = 0; $i < strlen($a); $i++) {\n    $c .= chr(bindec($a[$i]) ^ bindec($b[$i]));\n\
    \  }\n  return $c;\n}\n", "  return bin2hex(bin2hex(dechex(bindec($a)) ^ bindec($b)));\
    \ # hexadecimal number\n}\n", "    $a_len = strlen($a);\n    $b_len = strlen($b);\n\
    \    $res = \"\";\n    // Return empty string if inputs are of different lengths.\n\
    \    if ($a_len != $b_len)\n        return \"\";\n    for ($i = 0; $i < $a_len;\
    \ $i++) {\n        $res .= chr(ord($a[$i]) ^ ord($b[$i]));\n    }\n    return\
    \ $res;\n}", "    if ($a == $b) {\n        return $a;\n    }\n\n    $res = '';\n\
    \    $len = min(count($a), count($b));\n    for ($i = 0; $i < $len; $i++) {\n\
    \        if ($a[$i] != $b[$i]) {\n            $res .= '1';\n        } else {\n\
    \            $res .= '0';\n        }\n    }\n\n    return $res;\n}\n", "  return\
    \ $a ^ $b;\n}\n</code>\n<|/ a tags=xor,php |>\n<| c |>\nI agree with you but that\
    \ doesn't solve the issue. OP wants a bitwise operator with PHP. XOR is what that\
    \ operator is called, not XOR+.\n<|/ c |>\n<| c |>\nI actually found this page\
    \ while trying to figure out how to do bitwise operations on strings via PHP.\n\
    <|/ c |>\n<| c |>\nThe OP wants to use `xor` instead of `^`. XOR is what `^` does.\
    \ What you propose would be a XOR+, i.e. `^+` but that's not possible in PHP.\n\
    <|/ c |>\n<| c |>\n- I agree, but it would be a XOR+. XOR is what `^` is called.\
    \ I also added an example of binary XOR. Thanks.\n<|/ c |>\n<| c |>\n- Your answer\
    \ does indeed solve the issue. +1. But the point is that the OP needs to learn\
    \ how to use XOR in the first place.\n<|/ c |>\n<| a tags=xor,php |>\nThe Bitwise\
    \ operators do work in the same way as you would expect them to in other languages.\
    \ \n<code>\n$a = hexdec($a); // Convert your binary string to hex\n$b = hexdec($b);\
    \ // Convert your binary string to hex\n$result = ($a | $b); // Bitwise OR\n$result\
    \ = ($a & $b); // Bitwise AND\n$result = ($a ^ $b); // Bitwise XOR\n$result =\
    \ ($a << 1 // Bitwise shift to left with 1\n$result = ($a >> 1 // Bitwise shift\
    \ to right with 1\n</code>\nYou can read more here http://php.net/manual/en/language.operators.bitwise.php\
    \ \nThe only difference is that you have to convert the string into binary first.\
    \ \n<code>\n$result = hexdec($a) ^ $b; // XOR\n</code>\n<|/ a dscore=5 |>\n<|\
    \ a dscore=4 |>\nXOR operator is what you need, it is bitwise operator but with\
    \ different meaning.\n<code>\n$a = hexdec($a); // Convert your binary string to\
    \ hex\n$b = hexdec($b); // Convert your binary string to hex\n$result = ($a |\
    \ $b); // Bitwise OR\n$result = ($a & $b); // Bitwise AND\n$result = ($a ^ $b);\
    \ // Bitwise XOR\n$result = ($a << 1 ", "  return bin2hex(openssl_xor_string($a,\
    \ $b));\n}", "\t$out = \"\";\n\t$len = min(strlen($a), strlen($b));\n\tfor($i\
    \ = 0; $i < $len; $i++) {\n\t\tif($a[$i] != $b[$i]) {\n\t\t\t$out .= \"0\"; //\
    \ Output a leading 0\n\t\t}\n\t\telse {\n\t\t\t$out .= $a[$i];\n\t\t}\n\t}\n\t\
    return $out;\n}", "    return str_pad(decbin(bindec($a) ^ bindec($b)), 8, '0',\
    \ STR_PAD_LEFT);\n}", "  foreach (str_split($a) as $c) {\n    if ($b[$c] === 1)\
    \ {\n      $b[$c] = 0;\n    } else {\n      $b[$c] = 1;\n    }\n  }\n  return\
    \ implode('', $b);\n}\n", "  if (strlen($a) != strlen($b)) {\n    return false;\n\
    \  }\n  $result = \"\";\n  for ($i = 0; $i < strlen($a); $i++) {\n    $result\
    \ .= $a[$i] ^ $b[$i];\n  }\n  return $result;\n}\n", "    return bin2hex(\n  \
    \      pack('H*', str_pad(implode('', array_map('ord', str_split($b))), 4, \"\\\
    0\")) ^\n        pack('H*', str_pad(implode('', array_map('ord', str_split($a))),\
    \ 4, \"\\0\"))\n    );\n}\n</code>\n<|/ a tags=php,bitwise-operators dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\n$data = \"0101010\";\n$key = \"11111110\";\n\n\
    $binaryData = hex2bin($data);\n$binaryKey = hex2bin($key);\n$result = bin2hex(~$binaryData^$binaryKey);\n\
    </code>\n<|/ a tags=php,bitwise-operators |>\n<| c |>\nAlthough this code may\
    \ help to solve the problem, it doesn't explain _why_ and/or _how_ it answers\
    \ the question. Providing this additional context  would significantly improve\
    \ its long-term value. Please [edit] your answer to add explanation, including\
    \ what limitations and assumptions apply.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    <?php\n", "    // Convert strings to binary representations and perform XOR operation\n\
    \    $binA = bin2hex($a);\n    $binB = bin2hex($b);\n    return bin2hex(hexdec($binA)\
    \ ^ hexdec($binB));\n}\n", "    $a = str_split($a);\n    $b = str_split($b);\n\
    \    $result = '';\n    for ($i = 0; $i < max(count($a), count($b)); $i++) {\n\
    \        if ($a[$i] != $b[$i]) {\n            $result .= '0';\n        } else\
    \ {\n            $result .= '1';\n        }\n    }\n    return $result;\n}\n",
  "  return bin2hex(bin2hex(bin2hex(str_pad($a, 8, '0', STR_PAD_RIGHT))) ^ bin2hex(bin2hex(str_pad($b,\
    \ 8, '0', STR_PAD_RIGHT))));\n}\n", "    // Convert input strings to binary representations\n\
    \    $a_hex = unpack('H*', str_pad(dechex(ord($a)), 2, '0', STR_PAD_LEFT));\n\
    \    $b_hex = unpack('H*', str_pad(dechex(ord($b)), 2, '0', STR_PAD_LEFT));\n\n\
    \    // Perform binary XOR on both binary representations and convert to string\n\
    \    return str_pad(dechex(ord($a_hex[0] ^ ord($b_hex[0]))), 2, '0', STR_PAD_LEFT);\n\
    }\n", "  $binA = $a;\n  $binB = $b;\n  $res = '';\n  while ($binA || $binB) {\n\
    \    $res = $res == 0 ? '0' : $res;\n    $res = $res == 1 ? '1' : '0' . $res;\n\
    \    $binA = $binA ? '1' : '0';\n    $binB = $binB ? '1' : '0';\n  }\n  return\
    \ $res;\n}\n", "    $xor = 0;\n    for ($i = 0, $l = strlen($b); $i < $l; $i++)\
    \ {\n        $xor |= ord($a[$i]) ^ ord($b[$i]);\n    }\n    return chr($xor);\n\
    }\n", "    $c = strlen($a);\n    $d = strlen($b);\n    $e = 0;\n    while ($c\
    \ > 0 || $d > 0) {\n        $c--; $d--; // Count leading zeros\n        $e +=\
    \ $a & $b;\n        $a = $a ^ $b; // Binary XOR $a with $b\n        $b = (($e\
    \ << 1) & 0x55) | ($e >> 2); // Shift $b left one and add high bit of $e\n   \
    \     $e = (($e << 1) & 0x55) | ($e >> 2); // Shift $e left one and add high bit\
    \ of $e\n    }\n    return str_pad($e, 16, 0, STR_PAD_LEFT);\n}\n</code>\nThe\
    \ algorithm used here is a standard XOR swap but with less branches. We have two\
    \ loops over our strings. The first loop counts the leading zeros in both strings\
    \ and stores it in the variable $e. The second loop does the XOR swap and shifts\
    \ $b left one and adds the high bit of $e to the result. The loop stops when either\
    \ string is empty or when both strings run out of leading zeros and we get a 16\
    \ character long binary string. It then pads the result with leading zeros to\
    \ get 16 characters and returns the result.\nThis algorithm runs in O(n) time.\
    \ We can see this running here:\n<code>\n<?php\nfor ($i = 0; $i < 100; $i++) {\n\
    \    echo time(), ': ', string_xor('010', '110') . \"\\n\";\n}\n</code>\nwhich\
    \ outputs\n<code>\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376:\
    \ 100\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n\
    0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376:\
    \ 100\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n\
    0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376: 100\n0.222072376:\
    \ 100\n0.222072376: 100\n0.222072376: 100\n", "    $r = $a ^ $b;\n    return bin2hex($r);\n\
    }\n", "    $aBinaryStr = decbin($a);\n    $bBinaryStr = decbin($b);\n\n    //\
    \ Get rid of leading zeros and zeros in the end of the strings\n    while (substr($aBinaryStr,\
    \ 0, 1) === '0') {\n        $aBinaryStr = substr($aBinaryStr, 1);\n    }\n   \
    \ while (substr($bBinaryStr, 0, 1) === '0') {\n        $bBinaryStr = substr($bBinaryStr,\
    \ 1);\n    }\n\n    // XOR strings together\n    return $bBinaryStr ^ $aBinaryStr;\n\
    }", "    return bin2hex(bin2hex(bin2hex(str_pad(substr($a, 0, 8),\n          \
    \  8, '0', STR_PAD_LEFT)) ^\n            str_pad(substr($b, 0, 8), 8, '0', STR_PAD_LEFT)))\n\
    }", "    return str_pad(dechex(bindec($a) ^ bindec($b)), 2, '0', STR_PAD_LEFT);\n\
    }", "  $xor = strlen($a) > strlen($b) ? strlen($a) : strlen($b);\n  $res = '';\n\
    \  for ($i=0; $i<$xor; $i++) {\n    if ($a[$i] != $b[$i]) {\n      $res .= '0';\n\
    \    }\n    else {\n      $res .= '1';\n    }\n  }\n  return $res;\n}\n", "  \
    \  $a = bin2hex($a);\n    $b = bin2hex($b);\n    $out = '';\n    for ($i = 0;\
    \ $i < max(strlen($a), strlen($b)); $i++) {\n        if ($a[$i] != $b[$i]) {\n\
    \            break;\n        }\n    }\n    for ($i = 0; $i < strlen($a); $i++)\
    \ {\n        $out .= $a[$i];\n    }\n    for ($i = 0; $i < strlen($b); $i++) {\n\
    \        $out .= $b[$i];\n    }\n    return bin2hex(str_split($out, 2));\n}\n",
  "    $result = $a ^ $b;\n    return $result;\n}\n", "  $xor = '';\n  foreach (str_split($a)\
    \ as $aa) {\n    $xor .= $b[$aa ^ 1];\n  }\n  return $xor;\n}\n", "  return pack('H*',\
    \ sha1_file($a) ^ $b);\n}\n", "    return bin2hex( strtoupper(bin2hex(bin2hex(bin2hex(\
    \ $a ^ $b )))) );\n}\n</code>\n<|/ a dscore=2 tags=php,xor,c++,bit-manipulation\
    \ |>\n<| a tags=php,xor,c++,bit-manipulation |>\nPHP XOR function\n<code>\n<?php\n\
    $xor_text = \"1234\";\n$xor_num = \"5678\";\n$xor_text = $xor_text ^ $xor_num;\n\
    echo \"XOR text: $xor_text\";", "\t$result = '';\n\tfor ($i = 0; $i < strlen($a);\
    \ $i++) {\n\t\tif (ord($a[$i]) ^ ord($b[$i])) {\n\t\t\t$result .= chr($ord[$a[$i]\
    \ ^ ord($b[$i])]);\n\t\t}\n\t}\n\treturn $result;\n}\n", "  return bin2hex(pack('H*',\
    \ str_pad(bin2hex(strtr($a, '01', '00')), '64', '0')) ^ bin2hex(pack('H*', str_pad(bin2hex(strtr($b,\
    \ '01', '00')), '64', '0')));\n}\n</code>\nIf you have a large string and performance\
    \ is an issue, you might want to look into memcache, but even so it's probably\
    \ not worth it.\n<|/ a tags=php,xor,cryptography,encryption |>\n<| c |>\nAwesome!\
    \ I've never seen this before.\n<|/ c |>\n<| c |>\n, this is awesome. I have a\
    \ problem with a very large string, it gives me memory error when I try to run\
    \ the function on a large string. Do you know how I can fix this?\n<|/ c |>\n\
    <| c |>\nWhat are the requirements?  Do you need to be able to handle very large\
    \ strings?  If not, I'd probably just use an ordinary [XOR implementation](https://stackoverflow.com/questions/3582101/php-xor-encryption-algorithm).\
    \  If you do need performance, I'd look at [php's native mcrypt](http://php.net/manual/en/book.mcrypt.php).\
    \  It uses AES, so it's pretty fast, and it can handle very large strings if you\
    \ set the key correctly.  You also have [Zend Crypto library](http://framework.zend.com/manual/1.12/en/zend.crypto.library.html)\
    \ that has some [examples](http://framework.zend.com/manual/1.12/en/zend.crypto.examples.html).\
    \  I haven't used either of those, so I can't really help with that.\n<|/ c |>\n\
    <| c |>\n- Thanks for your quick reply!\n<|/ c |>\n<| a tags=php,xor,cryptography,encryption\
    \ |>\nThe XOR of 2 strings is the result of the bitwise 'xor' operation on each\
    \ bit of the binary strings. PHP has a bitwise 'xor' operator: ^. \n<code>", " \
    \   return bin2hex(pack('H*', strtr(base64_decode($a), ['-' => '_', '+' => '-',\
    \ '_' => '-']))) ^\n           bin2hex(pack('H*', strtr(base64_decode($b), ['-'\
    \ => '_', '+' => '-', '_' => '-'])));\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    You can do the following:\n<code>", "    $a = strtolower($a);\n    $b = strtolower($b);\n\
    \    $len = (strlen($a) + strlen($b));\n    $res = '';\n    for ($i = 0; $i <\
    \ $len; $i++) {\n        $res .= $a{$i} ^ $b{$i};\n    }\n    return $res;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThank you for your answer.  This works well for my\
    \ situation.\n<|/ c |>\n<| a dscore=0 |>\nThis is not an answer but a clarification\
    \ of your question. I am unable to comment as I do not have 50 reputation as you\
    \ do.\nIf you had to perform a mathematical operation on numbers given as strings.\
    \ You can not only perform XOR on these two strings, but you can perform other\
    \ operations such as subtraction, addition, multiplication, division or exponentiation.\
    \ \nFor example \"1\" + \"1\" + \"1\" + \"1\" + \"0\" + \"1\" + \"1\" + \"0\"\
    \ + \"1\" is equal to \"101010\" if you perform the operation \"1\" ^ \"0\" and\
    \ \"1\" ^ \"1\"\n\"1\" + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"1\" + \"1\"\
    \ + \"1\" is equal to \"101010\" if you perform the operation \"1\" ^ \"0\" and\
    \ \"0\" ^ \"1\"\n\"1\" + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"0\" + \"1\"\
    \ + \"1\" is equal to \"101010\" if you perform the operation \"1\" ^ \"0\" and\
    \ \"0\" ^ \"0\"\n\"1\" + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\"\
    \ + \"1\" is equal to \"101010\" if you perform the operation \"1\" ^ \"0\" and\
    \ \"0\" ^ \"0\"\n\"1\" + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\"\
    \ + \"0\" is equal to \"1\" if you perform the operation \"1\" ^ \"0\"\n\"0\"\
    \ + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\" + \"1\" is equal to\
    \ \"1\" if you perform the operation \"0\" ^ \"1\"\n\"0\" + \"1\" + \"1\" + \"\
    1\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" is equal to \"1\" if you perform the\
    \ operation \"0\" ^ \"0\"\n\"0\" + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"\
    0\" + \"0\" + \"0\" is equal to \"1\" if you perform the operation \"0\" ^ \"\
    0\"\n\"0\" + \"1\" + \"1\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" is\
    \ equal to \"0\" if you perform the operation \"0\" ^ \"0\"\n\"0\" + \"1\" + \"\
    1\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" is equal to ", "  $a_c = str_split($a);\n\
    \  $b_c = str_split($b);\n  $c = array();\n  foreach($a_c as $k => $v) {\n   \
    \ $c[] = chr(ord($v) ^ $b_c[$k]);\n  }\n  return implode('', $c);\n}\n", "   \
    \ $a = ltrim($a, '0');\n    $b = ltrim($b, '0');\n    return str_pad(decbin(ord($a)\
    \ ^ ord($b)), 8, '0', STR_PAD_LEFT);\n}\n", "    $out = \"\";\n    for ($i = 0;\
    \ $i < strlen($a); $i++) {\n        $out = $a[$i] ^ $b[$i] . $out;\n    }\n  \
    \  return $out;\n}", "  return bin2hex(bin2hex(bin2hex($a) ^ bin2hex($b))); \n\
    }", "  $result = '';\n  for ($i = 0; $i < min(strlen($a), strlen($b)); $i++) {\n\
    \    $result .= ($a[$i] ^ $b[$i]);\n  }\n  return $result;\n}\n", "  if (strlen($a)\
    \ != strlen($b)) {\n    return false;\n  }\n  $xor = '';\n  foreach (str_split($a)\
    \ as $k => $v) {\n    $xor .= str_pad(decbin(ord($v) ^ ord($b[$k])), 8, '0', STR_PAD_LEFT);\n\
    \  }\n  return $xor;\n}\n\n$xor_result = string_xor('111', '10');\n$xor_expected\
    \ = bin2hex(bin2hex('100'));\nif ($xor_result !== $xor_expected) {\n  print \"\
    FAIL: XOR'ing strings together\\n\";\n  print \"  Expected result = $xor_expected\\\
    n\";\n  print \"  Actual result = $xor_result\\n\";\n}\n\n$xor_result = string_xor('111',\
    \ '11');\n$xor_expected = bin2hex(bin2hex('110'));\nif ($xor_result !== $xor_expected)\
    \ {\n  print \"FAIL: XOR'ing strings together\\n\";\n  print \"  Expected result\
    \ = $xor_expected\\n\";\n  print \"  Actual result = $xor_result\\n\";\n}\n",
  "  $a_len = strlen($a);\n  $b_len = strlen($b);\n  if ($a_len != $b_len) {\n   \
    \ // If the lengths do not match, return an empty string.\n    return '';\n  }\n\
    \  $xor = '';\n  for ($i = 0; $i < $a_len; ++$i) {\n    $xor .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $xor;\n}\n\n$a = '010';\n$b = '110';\n$c = string_xor($a, $b);\n\
    print \"$c\\n\";", "  assert('is_string($a)');\n  assert('is_string($b)');\n \
    \ return bin2hex(bin2hex(str_pad(str2hex($a), 32, '0', STR_PAD_LEFT) ^ str2hex($b)));\n\
    }\n\n/**\n * Perform a bitwise AND on two strings a and b.\n * @param $a\n * @param\
    \ $b\n * @return string string $a AND $b in hexadecimal\n */", "  return str_pad(base_convert($a\
    \ ^ base_convert($b, 10, 2), 10, 2), 8, '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\nThis code will work for any base:\n<code>", "    $binary = str_repeat('0',\
    \ max(strlen($a),strlen($b))-2);\n    $binary = str_pad($binary, strlen($a), $a,\
    \ STR_PAD_LEFT) ^\n            str_pad($binary, strlen($b), $b, STR_PAD_LEFT);\n\
    \    return base_convert($binary, 2, 10);\n}", "    $result = '';\n    for ($i\
    \ = 0; $i < strlen($a); $i++) {\n        if ($a[$i] == $b[$i]) {\n           \
    \ $result .= '1';\n        } else {\n            $result .= '0';\n        }\n\
    \    }\n    return $result;\n}\n", "    // Create two array a & b consisting of\
    \ only 0s and 1s respectively.\n    $a_rev = str_split(strrev($a));\n    $b_rev\
    \ = str_split(strrev($b));\n    $c = [];\n    // Loop through both arrays and\
    \ perform XOR on them and push the result to c array.\n    foreach ($a_rev as\
    \ $k => $v) {\n        $c[] = chr($v ^ $b_rev[$k]);\n    }\n    return implode('',\
    \ $c);\n}", "    return bin2hex(\n        pack('H*', str_pad(bin2hex($a), 8, '0',\
    \ STR_PAD_LEFT) ^\n            str_pad(bin2hex($b), 8, '0', STR_PAD_LEFT))\n \
    \   );\n}", "    return bin2hex(pack('H*', str_pad(dechex(bin2de($a)) ^ $b, 2)));\n\
    }", "    return str_pad(decbin(bindec($a) ^ bindec($b)), strlen($a) * 8, '0',\
    \ STR_PAD_LEFT);\n}", "    if (strlen($a) != strlen($b)) {\n        throw new\
    \ Exception(\n            'Strings length are different'\n        );\n    }\n\
    \    $result = \"\";\n    for ($i = 0; $i < strlen($a); $i++) {\n        $result\
    \ .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n}", "  if ($a == $b) return\
    \ $a;\n  return str_pad(base_convert(bin2hex(str_pad($a, 8, '0', STR_PAD_LEFT)\
    \ ^ $b), 16, 2), 8, '0', STR_PAD_LEFT);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    Good catch! I've corrected the answer to reflect this.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing this out! I've updated the answer to include the corrected code.\n\
    <|/ c |>\n<| a tags=string,xor,php |>\nI really liked Jon's answer above, but\
    \ I was unhappy with the PHP string handling code - I found it overly complicated.\
    \ I wanted to write a simple function to handle XOR operations, for my own usage.\
    \ Here's my version:\n<code>", "  return bin2hex(bin2hex($a) ^ bin2hex($b));\n\
    }\n</code>\nThe above function is slightly inefficient because it uses two hex2bin()\
    \ calls per string input, and because hex2bin() takes up memory to store the output\
    \ which isn't needed after the function exits.\nA better (but more complicated)\
    \ function would be to convert each string to a binary string with hex2bin() using\
    \ str_split() and then perform the binary XOR operations using PHP's bitwise operators:\n\
    <code>", "    $a = str_split($a);\n    $b = str_split($b);\n    $result = '';\n\
    \    foreach ($a as $i => $x) {\n        $result .= $x ^ $b[$i];\n    }\n    return\
    \ $result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe `str_split()` function is a PHP\
    \ 7 feature, no? I do not think I am using any PHP7 features.\n<|/ c |>\n<| c\
    \ |>\nYes, but this PHP function works in PHP5 too. http://php.net/manual/en/function.str-split.php\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can easily use pack() method of PHP and convert\
    \ the strings into binary string.\n<code>\n$input1 = '100';\n$input2 = '110';\n\
    echo pack('c', $input1 ^ $input2); // output: 100\n</code>\n<|/ a tags=php,algorithm\
    \ |>\n<| c |>\nThe `pack` function is interesting. But it does not convert a string\
    \ to an actual binary string.\n<|/ c |>\n<| c |>\nYes, I know. But it can make\
    \ you more efficient then using XOR operator. Check my updated answer.\n<|/ c\
    \ |>\n<| a tags=php,algorithm |>\nXOR is more efficient for long string than strcmp\
    \ but for short strings XOR will be better because XOR is faster.\nHere are some\
    \ benchmark results (with PHP7 & XOR):\n<code>\nXOR speed: 18\nStrCmp speed: 32\n\
    </code>\nCode:\n<code>\n$a = array(0 => '001', 1 => '100', 2 => '011', 3 => '111',\
    \ 4 => '1000', 5 => '1001', 6 => '010', 7 => '110', 8 => '0111', 9 => '1111',\
    \ 10 => '100000', 11 => '10001', 12 => '0100', 13 => '1100', 14 => '0010', 15\
    \ => '1101', 16 => '0011', 17 => '1011', 18 => '0111', 19 => '11111', 20 => '100000',\
    \ 21 => '10001', 22 => '0100', 23 => '1100', 24 => '0010', 25 => '1101', 26 =>\
    \ '0011', 27 => '1011', 28 => '0111', 29 => '11111', 30 => '100000', 31 => '10001',\
    \ 32 => '0100', 33 => '1100', 34 => '0010', 35 => '1101', 36 => '0011', 37 =>\
    \ '1011', 38 => '0111', 39 => '11111', 40 => '100000', 41 => '10001', 4", "  return\
    \ bin2hex(pack('H*', strxor(strrev(bin2hex($a)), strrev(bin2hex($b)))));\n}\n",
  "    // Convert input to a binary string.\n    // The input strings are assumed\
    \ to consist only of 0s and 1s.\n    $a_binary = str_pad(decbin($a), 32, '0',\
    \ STR_PAD_LEFT);\n    $b_binary = str_pad(decbin($b), 32, '0', STR_PAD_LEFT);\n\
    \n    // XOR is commutative, so we reuse the binary strings.\n    $a_xor_binary\
    \ = $a_binary;\n    $b_xor_binary = $b_binary;\n\n    $a_xor_binary = str_replace('1',\
    \ '0', $a_xor_binary);\n    $b_xor_binary = str_replace('1', '0', $b_xor_binary);\n\
    \n    // Return result as a binary string.\n    return $a_xor_binary . $b_xor_binary;\n\
    }\n", "  $c = '';\n  for ($i = 0; $i < strlen($b); $i++) $c .= $a[$b[$i]] ^ $a[$i];\n\
    \  return $c;\n}\n", "    $result = $a ^ $b;\n    return $result;\n}\n</code>\n\
    <|/ a dscore=0 tags=php,php-password-hash,sha-256,encryption |>\n<| c |>\nYour\
    \ function doesn't work correctly. Consider `'10001'` and `'11000'`. For both\
    \ of these values, your function returns `'100'`. The correct result would be\
    \ `'11'`, because of the XOR operation you perform in the function.\n<|/ c |>\n\
    <| c |>\nThanks for noticing that! I've updated my answer based on your feedback.\n\
    <|/ c |>\n<| c |>\nNo, you should update your answer with the correct code for\
    \ the function to work as expected, because your function doesn't work correctly.\
    \ Consider `'10001'` and `'11000'`. For both of these values, your function returns\
    \ `'100'`. The correct result would be `'11'`, because of the XOR operation you\
    \ perform in the function.\n<|/ c |>\n<| c |>\nAnd since you seem to have some\
    \ problem with code formatting, please take your time to format your code properly.\n\
    <|/ c |>\n<| c |>\nUpdated as requested. Thank you.\n<|/ c |>\n<| a |>\n<code>\n\
    <?php", "  return str_pad(decbin(bindec($a ^ $b)),  strlen($a),  '0', STR_PAD_LEFT);\n\
    }\n", "    return str_pad(base_convert($a ^ $b,  10, 2), 4, \"0\", STR_PAD_LEFT);\n\
    }\n</code>\n<|/ a |>\n<| a tags=php |>\n<code>\n<?php\n$input1 = '01010100110';\n\
    $input2 = '01100100100';\n$output = '';\n\n$input1 = str_split($input1);\n$input2\
    \ = str_split($input2);\n\nfor ($i = 0; $i < count($input1); $i++) {\n    $output\
    \ .= chr(bindec($input1[$i] ^ $input2[$i]));\n}\necho($output);\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n<?php\n\n$x = [\n    '01010100110',\n\
    \    '01100100100',\n];\n", "    $xor = '';\n    for ($i = 0; $i < min(strlen($a),\
    \ strlen($b)); $i++) {\n        if ($a[$i] != '1' && $b[$i] != '1') {\n      \
    \      $xor .= '0';\n        } else {\n            $xor .= '1';\n        }\n \
    \   }\n    return $xor;\n}\n", "  $result = $a;\n  for ($i = 0; $i < strlen($b);\
    \ $i++) {\n    $result .= $b[strpos($a, $b[$i])];\n  }\n  return $result;\n}",
  "  return bin2hex(pack('H*', strtr($a, $b, $a ^ $b)));\n}", "  return $a ^ $b;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=4 tags=python,bitwise-operators,php |>\nThis\
    \ is not an answer but an alternative that could make things a bit easier if you\
    \ can change the way you are trying to do your bit-operations.\nIf you are using\
    \ PHP7 or higher you could use Bitwise Operators introduced in PHP 7. \n<code>\n\
    $bin1 = bindec(\"1010\"); // 0b1010\n$bin2 = bindec(\"1011\"); // 0b1011\n\n$result\
    \ = $bin1 ^ $bin2;", "  // Cast to a string\n  $a = strtolower($a);\n  $b = strtolower($b);\n\
    \  return bin2hex(\n    // Binary XOR all letters of A and B and then convert\
    \ to hex\n    strtolower(strtr(\n      str_pad(\n        strtoupper($a) . $b,\n\
    \        8, \"0\", STR_PAD_BOTH\n      ),\n      '01',\n      '10'\n    )),\n\
    \    true\n  );\n}\n</code>\n<|/ a tags=php |>\n<| c |>\n`bin2hex` does more than\
    \ `str_pad(..., '0', STR_PAD_BOTH)` - it doesn't pad binary strings to 8 characters\
    \ with `0` characters. So this could potentially be dangerous.\n<|/ c |>\n<| c\
    \ |>\nThe `bin2hex()` function adds `0` characters if there are less than 8 binary\
    \ characters. You can try it here: https://3v4l.org/nH1YG\n<|/ c |>\n<| c |>\n\
    Ah, that's right! I misread your answer as saying that the `str_pad(..., '0',\
    \ STR_PAD_BOTH)` part is redundant - and that it is actually adding `0` characters.\
    \ Apologies.\n<|/ c |>\n<| c |>\nI think I may have misread. The `bin2hex()` does\
    \ _not_ add any leading zeroes. So the padding is redundant.\n<|/ c |>\n<| c |>\n\
    This doesn't seem to work right if the hex string has leading 0s. For example,\
    \ `bin2hex(string_xor('010', '100'))` returns `48656c6c6f00`, when it should return\
    \ `48656c6c6f`. Any ideas on how to fix this?\n<|/ c |>\n<| a |>\nIf you want\
    \ it quick and dirty, you can use str_split (docs) and array_reduce (docs):\n\
    <code>\n$hexString = '01001';\n\n$hexString = array_reduce(str_split($hexString,\
    \ 2), function($carry, $i) {\n    return $carry . $i;\n});\n</code>\n<|/ a tags=php\
    \ dscore=1 |>\n<| c |>\nThis doesn't seem to work right if the hex string has\
    \ leading 0s. For example, `bin2hex(string_xor('010', '100'))` returns `48656c6c6f00`,\
    \ when it should return `48656c6c6f`. Any ideas on how to fix this?\n<|/ c |>\n\
    <| c |>\nYou can solve it with str_pad, ", "    return bin2hex(bin2hex(~bin2hex(str_pad($a,\
    \ 8, '0', STR_PAD_LEFT)) ^\n                          str_pad($b, 8, '0', STR_PAD_LEFT)));\n\
    }\n</code>\n<|/ a tags=php,xor,string,byte dscore=4 |>\n<| c |>\nThe second `bin2hex`\
    \ is redundant. `~` negates a hexadecimal number, not an array.\n<|/ c |>\n<|\
    \ c |>\n: Yes, that's a problem with my testing code. Thanks. Fixed.\n<|/ c |>\n\
    <| a tags=php,xor,string,byte |>\n<code>\n/**\n * Performs XOR on two hex strings.\
    \ The length of the two strings must\n * be the same and only the characters that\
    \ are common between them will\n * be taken into account.\n *\n * string $a\n\
    \ * string $b\n * string\n */", "    $a = (string) $a;\n    $b = (string) $b;\n\
    \    $len = min(strlen($a), strlen($b));\n    $result = '';\n    for ($i = 0;\
    \ $i < $len; $i++) {\n        $result .= $a[$i] ^ $b[$i];\n    }\n    return $result;\n\
    }\n", "  $c = strlen($a);\n  $d = strlen($b);\n  assert($c == $d);\n  $ret = '';\n\
    \  for ($i = 0; $i < $c; $i++) {\n    $ret .= ($a[$i] ^ $b[$i]);\n  }\n  return\
    \ $ret;\n}\n", "  return bin2hex(bin2hex(bin2hex($a) ^ $b));\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is an interesting solution, but it is also O(n^2), which\
    \ is really not ideal for bigger inputs. I'd go with David's solution here, but\
    \ it does require PHP 5.6+.\n<|/ c |>\n<| c |>\nIt is not O(n^2), but it doesn't\
    \ require a binary XOR function, and it's likely not faster than a native one.\
    \  The big advantage of David's approach is that it is much more compact, easier\
    \ to read, and less prone to typos, as you have all your logic contained in one\
    \ place.\n<|/ c |>\n<| c |>\nSure it's not O(n^2) it's O(2^n) but still, it's\
    \ O(n). You only have to check the bits which were affected as far as I can see,\
    \ so it's O(n). Of course it's also O(n^2) if the XOR function does a lot of work.\n\
    <|/ c |>\n<| c |>\nI suppose you are saying that if I have three functions `A`,\
    \ `B`, and `C` that do XOR on input `a` and `b`, I will need `A`, `B`, and `C`\
    \ as `n` functions. That is correct.\n<|/ c |>\n<| c |>\nYes, that's what I meant.\
    \ O(n^2) where n is the number of bits of input plus some constant. I think this\
    \ is actually O(log(n)) because if you do XOR all you do is check the bits that\
    \ were affected so you do only `log(n)` bits to do this. In any case, I wouldn't\
    \ call it O(n) because it's still a quadratic function, which is a bit overly\
    \ pedantic.\n<|/ c |>\n<| a dscore=0 tags=string,xor,php,binary |>\nFor those\
    \ who are interested, here's a slightly improved version of the string_xor function\
    \ mentioned above.  You can pass it any number from 0-9 and it will return a string\
    \ consisting of any given character x'ed with the string itself.  It uses only\
    \ 1 function instead of 3 like in some of the other answers:\n<code>\n<?php\n",
  "    $xor_string = '';\n    for ($i = 0; $i < strlen($b); $i++) {\n        $xor_string\
    \ .= ($a[$i] ^ $b[$i]);\n    }\n    return $xor_string;\n}\n", "  $result = '';\n\
    \  for ($i = 0; $i < strlen($a); $i++) {\n    $result .= chr(bindec(substr($a,\
    \ $i, 1)) ^ bindec(substr($b, $i, 1)));\n  }\n  return $result;\n}", "  return\
    \ bin2hex(bin2hex($a) ^ $b);\n}", "    $length = strlen($a);\n    $xor = '';\n\
    \    for ($i=0; $i<$length; $i++) {\n        $xor .= $a[$i] ^ $b[$i];\n    }\n\
    \    return $xor;\n}\n", "  $out = str_pad(base_convert($a, 2, 10), strlen($a),\
    \ 0);\n  $out = str_pad(base_convert($b, 2, 10), strlen($b), 0);\n  return base_convert(bindec($out\
    \ ^ $out), 2, 10);\n}\n", "  $res = \"\";\n  for ($i = 0; $i < strlen($a); $i++)\
    \ {\n    $res .= $a[$i] ^ $b[$i];\n  }\n  return $res;\n}\n", "  $res = '';\n\
    \  $length = strlen($a);\n  for ($i = 0; $i < $length; $i++) {\n    $res .= $a[$i]\
    \ ^ $b[$i];\n  }\n  return $res;\n}", "  return bin2hex(bin2hex(bin2hex(strtr(pack('H*',\
    \ str_split($a))), pack('H*', str_split($b))) ^\n                        pack('H*',\
    \ str_split($a)) ^\n                        pack('H*', str_split($b)));\n}", " \
    \   // Return empty string if either inputs are empty.\n    if (strlen($a) ==\
    \ 0 || strlen($b) == 0) {\n        return '';\n    }\n    // Return empty string\
    \ if a has length less than or equal to b.\n    // This happens when the strings\
    \ consist of 0s or 1s.\n    if (strlen($a) < strlen($b)) {\n        $a = str_pad($a,\
    \ strlen($b), chr(0), STR_PAD_RIGHT);\n    } else {\n        $b = str_pad($b,\
    \ strlen($a), chr(0), STR_PAD_RIGHT);\n    }\n    $a_arr = str_split($a);\n  \
    \  $b_arr = str_split($b);\n    $result = array();\n    for ($i = 0; $i < strlen($a);\
    \ $i++) {\n        $result[] = chr(bindec($a_arr[$i]) ^ bindec($b_arr[$i]));\n\
    \    }\n    return implode('', $result);\n}\n</code>\n<|/ a tags=php,cryptography\
    \ |>\n<| c |>\nThis does not seem to work for me. The result I get is still not\
    \ the same. I'm using the PHP function \"hash_hmac(\u2018sha1\u2019,\u2019data\u2019\
    ,\u2019password\u2019);\" Could it be the wrong hash type I'm using?\n<|/ c |>\n\
    <| c |>\nNo, SHA1 is correct for passwords because the SHA-1 hash function returns\
    \ 160 bits or 20 bytes. Your input data contains 1025 bits.\n<|/ c |>\n<| c |>\n\
    I used a password like \"123456\" to test it.\n<|/ c |>\n<| c |>\nI used a password\
    \ like \"123456\" to test it. Then I tested a hash_hmac on that and the result\
    \ was different.\n<|/ c |>\n<| c |>\nThe PHP `hash_hmac()` function uses the SHA-1\
    \ hash function, not SHA-2. While the two hash functions are related, they are\
    \ not the same.\n<|/ c |>\n<| a tags=php,cryptography dscore=2 |>\nYou can use\
    \ this code to create password hash:\n<code>", "    $bin1 = array_pad(str_split($a),\
    \ 8, '0');\n    $bin2 = array_pad(str_split($b), 8, '0');\n    $out = str_pad(bin2hex(array_reduce($bin1,\
    \ 'array_sum', '0')), 0, 8, '0');\n    return $out;\n}\n", "    $result = $a ^\
    \ $b;\n    return $result;\n}\n</code>\n<|/ a tags=php,string,binary |>\n<| c\
    \ |>\nThis is wrong. The OP specified \"binary xor\", not \"logical xor\".\n<|/\
    \ c |>\n<| c |>\nThe OP specified binary XOR. His example string has two 1's,\
    \ and a 0. So the result should be 100. Why would you say it's wrong?\n<|/ c |>\n\
    <| c |>\nNo, he does specify \"binary xor\", but the code above performs logical\
    \ XOR, and thus returns `110` in my example (as expected).\n<|/ c |>\n<| c |>\n\
    The OP said \"two strings a and b are a binary string having 1's and 0's\". And\
    \ he did not say \"two strings a and b are a binary string\". He said \"two strings\
    \ a and b are a binary strings that consists only of 1's and 0's\"\n<|/ c |>\n\
    <| c |>\n\"Two strings a and b are a binary string that consists only of 1's and\
    \ 0's\" is what my answer says.\n<|/ c |>\n<| a dscore=2 tags=php,string,binary\
    \ |>\nYou can do it like this:\n<code>\n$a = '010';\n$b = '110';\n", "  // Convert\
    \ the strings to numbers.\n  $n1 = bindec($a) & 0xFF;\n  $n2 = bindec($b) & 0xFF;\n\
    \  // Perform the XOR operation and return the result.\n  return chr($n1 ^ $n2);\n\
    }", "    $xor_str = str_pad(base_convert(sha1(bin2hex($a) . bin2hex($b)), 16,\
    \ 2),\n                        16, '0', STR_PAD_RIGHT);\n    return strtoupper(bin2hex($xor_str));\n\
    }\n", "    return bin2hex(pack('H*', bin2hex(dechex(bindec($a)) ^ bindec($b))))\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution is great if you have PHP\
    \ 5.3 or greater, because `pack('H*', ...)` is supported from PHP 5.3.\n<|/ c\
    \ |>\n<| c |>\nVery smart solution, thanks! Just a little bit of explanation:\
    \ `pack()` packs binary data in hexadecimal (`H*` means \"hexadecimal\") and `dechex()`\
    \ converts hexadecimal to binary data (`dechex()` returns hexadecimal characters).\
    \ `bindec()` converts binary to decimal and `bin2hex()` converts decimal to hexadecimal.\n\
    <|/ c |>\n<| c |>\nThis doesn't work with a signed 16 bit number. I get the following\
    \ error: `PHP Fatal error:  Function name must be a string in...` The `bindec()`\
    \ function returns `0` even if the number is a negative number.\n<|/ c |>\n<|\
    \ c |>\nThis also doesn't work for 32-bit integers. `bindec()` returns `0` for\
    \ 32-bit integers, and the result doesn't make any sense when converted to hexadecimal.\n\
    <|/ c |>\n<| c |>\nI see you fixed a bug with the negative numbers. I have updated\
    \ the answer to fix the issue with 32-bit integers.\n<|/ c |>\n<| a |>\nI wanted\
    \ to share my own answer too, because I've been looking for the same function\
    \ without success in PHP. There are solutions like the one above with bin2hex()\
    \ or with bitwise operators, but they do not work with signed integers. I'm sharing\
    \ the solution that I have found, that uses pack(), bindec() and hexdec() functions.\
    \ Hope it will help someone. :)\n<code>\n<?php\n", "    return bin2hex(pack('H*',\
    \ str_pad(dechex(bindec($a) ^bindec($b)), 2, '0', STR_PAD_LEFT)));\n}\n", "  \
    \  $result = '';\n    foreach (str_split($a) as $val) {\n        $result .= chr(ord($a)\
    \ ^ $val);\n    }\n    foreach (str_split($b) as $val) {\n        $result .= chr(ord($b)\
    \ ^ $val);\n    }\n    return $result;\n}", "  return bin2hex(pack(\"H*\",$a ^\
    \ $b));\n}\n", "    $a = str_split($a);\n    $b = str_split($b);\n    $xor = '';\n\
    \    foreach ($a as $key => $value) {\n        $xor .= $a[$key] ^ $b[$key];\n\
    \    }\n    return $xor;\n}\n", "  $a_len = strlen($a);\n  $b_len = strlen($b);\n\
    \  $xor = '';\n  for ($i = 0; $i < $a_len; ++$i) {\n    $xor .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $xor;\n}\n</code>\n<|/ a tags=php,bit-manipulation |>\n<| c |>\n\
    `str_pad` is probably the worst choice for a XOR function as it makes a lot of\
    \ assumptions about what is expected and what happens. And it won't work when\
    \ strings are longer than 32 characters. Better use `strlen` in the loop and add\
    \ an \"padding\" string to the beginning of the result to keep the whole string\
    \ length constant.\n<|/ c |>\n<| c |>\nI agree with you, but that's what the OP\
    \ wanted I guess. Anyway, this is not a critic, it was just an opinion and I added\
    \ the padding just to help OP to avoid troubles with strings that do not end with\
    \ zeros (or anything else).\n<|/ c |>\n<| c |>\nI disagree with the padding bit,\
    \ when a string is less than 32 characters long, the padding will be appended\
    \ in the end, so if you use the padding string for XOR, your XOR result will never\
    \ be 32 characters in length, and in that case, it's just wasted space. If the\
    \ string is longer, you'll have 32 characters of padding in the end.\n<|/ c |>\n\
    <| c |>\nThe padding is done in the `xor` function, since strings with less than\
    \ 32 characters will always end with the padding characters. If you don't do it,\
    \ you will always get 32 characters even if the string is longer, and that may\
    \ cause problems.\n<|/ c |>\n<| c |>\nI see what you mean, but you misunderstood.\
    \ By adding '0' to the end of the result string you force the result to be 32\
    \ characters long.\n<|/ c |>\n<| a dscore=2 |>\nI guess there is a much more efficient\
    \ and readable way of doing this. But this is what I came up with. Since I have\
    \ no idea how long your strings are, I used a preg_replace_callback to make sure\
    \ it works even if the length is a bit over 32. This should work on PHP 5.4+ and\
    \ PHP >= 5.3.\n<code>", "    $a_len = strlen($a);\n    $b_len = strlen($b);\n\
    \    $result = str_pad('', $a_len + $b_len, '0');\n    for ($i = 0; $i < $a_len;\
    \ $i++) {\n        $result[$i] ^= $a[$i];\n    }\n    for ($i = 0; $i < $b_len;\
    \ $i++) {\n        $result[$a_len + $i] ^= $b[$i];\n    }\n    return $result;\n\
    }\n</code>\n<|/ a tags=php,xor,cryptography,encryption dscore=0 |>\n<| c |>\n\
    Thanks. I like the idea of using XOR but I want to see if there is an actual encryption\
    \ solution that can be implemented in PHP.\n<|/ c |>\n<| c |>\nI added a PHP version\
    \ of what I was suggesting earlier. The XOR function above is implemented using\
    \ XOR (^) since it's commutative.\n<|/ c |>\n<| c |>\nHmm, XOR is commutative,\
    \ but not associative.  For example, `010 ^ 110` is `100 ^ 101` not `010 ^ 111`.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe other answer using XOR is clever and should work\
    \ if all your values are only 0s and 1s. However, it doesn't scale up so well,\
    \ which is why I would suggest a different solution.\nRather than XORing, you\
    \ could use a cryptographic hashing algorithm like Blowfish. This algorithm has\
    \ a low collision rate compared to the XOR algorithm you were attempting, and\
    \ is much faster to compute.\nHere's an implementation using PHP's crypt() function:\n\
    <code>", "    return ltrim(bin2hex(mcrypt_create_iv(16, MCRYPT_DEV_URANDOM)),\
    \ '0');\n}\n", "  // Convert a and b to binary representation.\n  $a_s = str_pad(decbin($a),\
    \ 8, '0', STR_PAD_LEFT);\n  $b_s = str_pad(decbin($b), 8, '0', STR_PAD_LEFT);\n\
    \  // Convert binary representations of both strings to decimal representations.\n\
    \  $a_n = base_convert($a_s, 10, 2);\n  $b_n = base_convert($b_s, 10, 2);\n  //\
    \ Perform binary XOR on decimal representations.\n  $result = base_convert(str_pad(decbin\
    \ (bindec($a_n) ^ bindec($b_n)), 8, 0, STR_PAD_LEFT), 2, 10);\n  // Convert back\
    \ to string\n  return str_pad(dechex($result), 8, 0, STR_PAD_LEFT);\n}\n", " \
    \   return str_pad(strtr(base_convert(bin2hex($a), 2, 16), array('+' => '-', '='\
    \ => '_'), \"\\n\"), 8, '0', STR_PAD_RIGHT);\n}", "    return ltrim(strtoupper(bin2hex(pack('H*',\
    \ str_split($a, 2))\n        ^ pack('H*', str_split($b, 2))\n    )));\n}\n", "\t\
    $xor = '';\n\tfor ($i = 0; $i < strlen($b); $i++) {\n\t\tif ($a[$i] == $b[$i])\
    \ {\n\t\t\t$xor .= $a[$i];\n\t\t} else {\n\t\t\t$xor .= '0';\n\t\t}\n\t}\n\treturn\
    \ $xor;\n}\n", "  return bin2hex(~bin2hex($a) ^ ~bin2hex($b));\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis isn't quite what I'm looking for as this just returns\
    \ a hex value with spaces between each character - I'm looking to return a single\
    \ string with all the bits inverted.\n<|/ c |>\n<| a |>\nYou can use the Bitwise\
    \ Operators to do it. This will also work for multibyte chars instead of only\
    \ single byte chars.\n<code>\n$string = \"11001100110011\";\n$string1 = \"1111\"\
    ;\n$string2 = \"1110\";\n\necho bin2hex(~bin2hex($string)) . PHP_EOL;\necho bin2hex(~bin2hex($string1))\
    \ . PHP_EOL;\necho bin2hex(~bin2hex($string2)) . PHP_EOL;\n</code>\nOutput:\n\
    <code>\n11001100110011\n11110000111010\n11110000000000\n</code>\nEDIT\nOkay, I\
    \ think I understand the question better now. One more thing, you cannot invert\
    \ more than 32 binary characters. You can do some hackery that you can read more\
    \ about here\n<code>", "  $result = $a;\n  for ($i = 0, $l = strlen($b); $i <\
    \ $l; $i++) {\n    $result .= $b[$i] ^ $a[$i];\n  }\n  return $result;\n}\n",
  "    $a_length = strlen($a);\n    $b_length = strlen($b);\n    $output_length =\
    \ $a_length <= $b_length ? $a_length : $b_length;\n    $xor = str_repeat(chr(0),\
    \ $output_length);\n\n    for ($i = 0; $i < $output_length; $i++) {\n        if\
    \ ($a[$i] == $b[$i]) {\n            $xor[$i] = $a[$i];\n        } else {\n   \
    \         $xor[$i] = chr(1 ^ ord($a[$i]));\n        }\n    }\n\n    return $xor;\n\
    }\n\n/**\n * Convert binary string to hex string\n *\n * @param string $binary_string\n\
    \ * @return string\n */", "    $res = '';\n    for ($i=0; $i<strlen($a) && $i<strlen($b);\
    \ $i++) {\n        $res .= (substr($a, $i, 1) ^ substr($b, $i, 1));\n    }\n \
    \   return $res;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere is an\
    \ optimized version which doesn't require a for loop as it compares char by char:\n\
    <code>\n$a = str_split($str1);\n$b = str_split($str2);\n$c = array_map(function\
    \ ($x, $y) use ($a) {\n    return (in_array($x, $a)) ? $x : false;\n}, $b, $a);\n\
    $res = implode('', $c);\n</code>\n<|/ a tags=php,xor,string |>\n<| a tags=php,xor,string\
    \ dscore=2 |>\nHere's a PHP 5.5 solution, based on the excellent answer from-phai\n\
    <code>\n$a = 'abcdefg';\n$b = 'cdefgh';\n", "    if (strlen($a) != strlen($b))\
    \ {\n        throw new Exception('a and b should of equal length');\n    }\n\n\
    \    $res = '';\n    for ($i = 0, $len = strlen($a); $i < $len; ++$i) {\n    \
    \    $res .= (bindec($a[$i]) ^ bindec($b[$i]));\n    }\n    return $res;\n}\n\
    </code>\n<|/ a tags=string,php,binary |>\n<| c |>\nThanks. That was really helpful,\
    \ but I solved my own problem by using a combination of PHP's `str_repeat` and\
    \ `implode`.\n<|/ c |>\n<| c |>\nGlad to hear you solved it. If you would like\
    \ to post your own solution as an answer, I will upvote it.\n<|/ c |>\n<| c |>\n\
    It would be nice if you posted your solution\n<|/ c |>\n<| a tags=string,php,binary\
    \ |>\nA quick search brought up this solution :\n<code>\n$bin = str_repeat('1',\
    \ strlen($str)); \n$bin = implode('', array_map('decbin', str_split($str)));\n\
    </code>\nThe str_repeat() function creates a string that repeats the input value\
    \ up to its desired length (in this case, it is the length of the string, as you\
    \ asked) using its first parameter as the repeat count. Then, the implode() function\
    \ converts a string of binary numbers into its equivalent decimal string representation.\
    \ From there, you can convert the string back into binary numbers by using the\
    \ array_map() function and a custom function that converts binary numbers to decimal.\
    \ Finally, you can convert it back into a string by using str_split().\n<|/ a\
    \ dscore=5 |>\n<| a tags=string,php,binary dscore=4 |>\nHere's an even more functional\
    \ version:\n<code>", "    $a_length = strlen($a);\n    $b_length = strlen($b);\n\
    \    $result_length = max($a_length, $b_length);\n    $result = \"\";\n    for\
    \ ($i = 0; $i < $result_length; $i++) {\n        $result[$i] = $a[$i] ^ $b[$i];\n\
    \    }\n    return $result;\n}", "    if (strlen($a) !== strlen($b)) {\n     \
    \   throw new \\Exception('Length of two strings must be the same');\n    }\n\n\
    \    $res = [];\n    for ($i = 0; $i < strlen($a); ++$i) {\n        $res[] = $a[$i]\
    \ ^ $b[$i];\n    }\n\n    return implode('', $res);\n}\n", "    $res = 0;\n  \
    \  for ($i = 0; $i < strlen($a); $i++) {\n        $res ^= (bindec($a[$i]) ^ bindec($b[$i]));\n\
    \    }\n    return str_pad(decbin($res), 8, '0', STR_PAD_LEFT);\n}\n", "  $c =\
    \ strlen($a);\n  $d = strlen($b);\n  $ret = $a ^ $b;\n  if (strlen($ret) < $c)\
    \ {\n    $ret = str_pad($ret, $c, '0', STR_PAD_BOTH);\n  }\n  return $ret;\n}",
  "  $xor = '';\n  for ($i = 0, $len = strlen($a); $i < $len; ++$i) {\n    $xor .=\
    \ $a[$i] ^ $b[$i];\n  }\n  return $xor;\n}\n", "  $x = \"\";\n  for($i = 0; $i\
    \ < strlen($a); $i++) {\n    $x .= (ord($a[$i]) ^ ord($b[$i]));\n  }\n  return\
    \ $x;\n}\n", "  $res = [];\n  for ($i = 0; $i < strlen($a); $i++) {\n    $res[$i]\
    \ = bindec($a[$i] ^ $b[$i]);\n  }\n  return implode('', $res);\n}\n", "  return\
    \ bin2hex(bin2hex(pack('H*', $a) ^ $b));\n}\n</code>\n<|/ a tags=php,binary,string,xor,hex\
    \ |>\n<| c |>\nI'm assuming OP wants to get the binary representations of these\
    \ two hex strings. So the final answer should be `100` in this case. It will be\
    \ useful to show the actual values OP wants to end up with.\n<|/ c |>\n<| c |>\n\
    Yes this is what I want. Thanks for sharing the solution.\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>\n<?php", "    $binA = (string)$a;\n    $binB = (string)$b;\n\n  \
    \  if (strlen($binA) !== strlen($binB)) {\n        throw new \\InvalidArgumentException('Input\
    \ strings must have the same length');\n    }\n\n    $result = '';\n    for ($i\
    \ = 0; $i < strlen($binA); $i++) {\n        $result .= $binA[$i] ^ $binB[$i];\n\
    \    }\n\n    return $result;\n}", "  $c = strlen($a);\n  $d = strlen($b);\n \
    \ for ($i = 0; $i < min($c, $d); ++$i) {\n    $a[$i] ^= $b[$i];\n  }\n  return\
    \ implode('', $a);\n}\n", "  $a_length = strlen($a);\n  $b_length = strlen($b);\n\
    \  $res = '';\n  for ($i = 0; $i < $a_length; $i++) {\n    $res .= $a[$i] ^ $b[$i];\n\
    \  }\n  return $res;\n}"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
