name: HumanEval_136_largest_smallest_integers
language: r
prompt: "# Create a function that returns a tuple (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in a list.\n\
  # If there is no negative or positive integers, return them as None.\n# Examples:\n\
  # largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([])\
  \ == (None, None)\n# largest_smallest_integers([0]) == (None, None)\nlargest_smallest_integers\
  \ <- function(lst) {"
tests: "test_humaneval <- function() {\ncandidate <- largest_smallest_integers\n \
  \   if(!identical(candidate(c(2, 4, 1, 3, 5, 7)), c(NULL, 1))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(2, 4, 1, 3, 5, 7, 0)), c(NULL, 1))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(1, 3, 2, 4, 5, 6, -2)), c(-2, 1))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(4, 5, 3, 6, 2, 7, -7)), c(-7, 2))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(7, 3, 8, 4, 9, 2, 5, -9)), c(-9, 2))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c()), c(NULL, NULL))){quit('no', 1)}\n    if(!identical(candidate(c(0)),\
  \ c(NULL, NULL))){quit('no', 1)}\n    if(!identical(candidate(c(-1, -3, -5, -6)),\
  \ c(-1, NULL))){quit('no', 1)}\n    if(!identical(candidate(c(-1, -3, -5, -6, 0)),\
  \ c(-1, NULL))){quit('no', 1)}\n    if(!identical(candidate(c(-6, -4, -4, -3, 1)),\
  \ c(-3, 1))){quit('no', 1)}\n    if(!identical(candidate(c(-6, -4, -4, -3, -100,\
  \ 1)), c(-3, 1))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  neg_max <- max(lst[lst < 0])\n  pos_min <- min(lst[lst > 0])\n\
    \  if (is.na(neg_max)) {\n    neg_max <- None\n  }\n  if (is.na(pos_min)) {\n\
    \    pos_min <- None\n  }\n  c(neg_max, pos_min)\n}\nlargest_smallest_integers(c(2,\
    \ 4, 1, 3, 5, 7))\nlargest_smallest_integers(c())\nlargest_smallest_integers(c(0))\n",
  "\n  negs <- c()\n  poss <- c()\n  for (elem in lst) {\n    if (elem > 0) {\n  \
    \    poss <- c(poss, elem)\n    } else if (elem < 0) {\n      negs <- c(negs,\
    \ elem)\n    }\n  }\n  if (length(negs) == 0) {\n    negs <- NULL\n  } else {\n\
    \    negs <- max(negs)\n  }\n  if (length(poss) == 0) {\n    poss <- NULL\n  }\
    \ else {\n    poss <- min(poss)\n  }\n  return(c(negs, poss))\n}\n", "\n  return(tuple(min(lst[which(lst\
    \ < 0)]), max(lst[which(lst > 0)])))\n}\nlargest_smallest_integers(lst)\n", "\n\
    \  neg <- max(lst[lst < 0])\n  pos <- min(lst[lst > 0])\n  if (neg == 'NaN') {\n\
    \    neg <- NULL\n  }\n  if (pos == 'NaN') {\n    pos <- NULL\n  }\n  c(neg, pos)\n\
    }", "\n  if (length(lst) > 0) {\n    neg <- lst[lst < 0]\n    pos <- lst[lst >\
    \ 0]\n    if (length(neg) > 0) {\n      neg_max <- max(neg)\n    } else {\n  \
    \    neg_max <- NULL\n    }\n    if (length(pos) > 0) {\n      pos_min <- min(pos)\n\
    \    } else {\n      pos_min <- NULL\n    }\n    return(c(neg_max, pos_min))\n\
    \  } else {\n    return(c(NULL, NULL))\n  }\n}\n", "\n  if(length(lst) == 0) return(c(None,\
    \ None))\n  else {\n    mx = max(lst)\n    mn = min(lst)\n    if(mx < 0) {\n \
    \     if(mn > 0) {\n        return(c(mx, mn))\n      } else {\n        return(c(mx,\
    \ None))\n      }\n    } else {\n      if(mn > 0) {\n        return(c(None, mn))\n\
    \      } else {\n        return(c(None, None))\n      }\n    }\n  }\n}\n", "\n\
    \  if (length(lst) == 0) {\n    return(c(None, None))\n  }\n  positives <- lst[lst\
    \ > 0]\n  negatives <- lst[lst < 0]\n  c(max(negatives, na.rm = TRUE), min(positives,\
    \ na.rm = TRUE))\n}\n", "\n    negatives <- lst[lst < 0]\n    positives <- lst[lst\
    \ > 0]\n    if(length(negatives) == 0) negatives <- None\n    if(length(positives)\
    \ == 0) positives <- None\n    return(negatives, positives)\n}\n", "\n  lst <-\
    \ lst[lst != 0]\n  largest <- max(lst)\n  smallest <- min(lst)\n  largest_neg\
    \ <- min(lst[lst < 0])\n  smallest_pos <- max(lst[lst > 0])\n  tuple <- c(largest_neg,\
    \ smallest_pos)\n  tuple[is.na(tuple)] <- None\n  return(tuple)\n}\n\nlargest_smallest_integers(c(2,\
    \ 4, 1, 3, 5, 7)) == c(None, 1)\nlargest_smallest_integers(c()) == c(None, None)\n\
    largest_smallest_integers(c(0)) == c(None, None)\n", "\n  low <- high <- NULL\n\
    \  # Process the list\n  if (length(lst) > 0) {\n    # Find the largest negative\n\
    \    low <- min(lst[lst < 0])\n    # Find the smallest positive\n    high <- min(lst[lst\
    \ > 0])\n  }\n  # Return the result\n  return(c(low, high))\n}\n", "\n    if(length(lst)\
    \ == 0) return(c(None, None))\n    lst_neg <- lst[lst < 0]\n    lst_pos <- lst[lst\
    \ > 0]\n    return(c(max(lst_neg, na.rm = TRUE), min(lst_pos, na.rm = TRUE)))\n\
    }\nlargest_smallest_integers(c(2, 4, 1, 3, 5, 7))\nlargest_smallest_integers(c())\n\
    largest_smallest_integers(c(0))\n", "\n  if (length(lst) == 0) {\n    return(c(None,\
    \ None))\n  } else {\n    max_negative <- None\n    min_positive <- None\n   \
    \ for (element in lst) {\n      if (element < 0) {\n        if (max_negative ==\
    \ None) {\n          max_negative <- element\n        } else {\n          if (element\
    \ > max_negative) {\n            max_negative <- element\n          }\n      \
    \  }\n      } else {\n        if (min_positive == None) {\n          min_positive\
    \ <- element\n        } else {\n          if (element < min_positive) {\n    \
    \        min_positive <- element\n          }\n        }\n      }\n    }\n   \
    \ return(c(max_negative, min_positive))\n  }\n}\n", "\n  if (length(lst) == 0)\
    \ return(c(None, None))\n  negatives <- lst[lst < 0]\n  positives <- lst[lst >\
    \ 0]\n  c(ifelse(length(negatives) > 0, max(negatives), None),\n    ifelse(length(positives)\
    \ > 0, min(positives), None))\n}\n", "\n  pos <- lst[lst > 0]\n  neg <- lst[lst\
    \ < 0]\n  return(c(neg %>% max(), pos %>% min()))\n}\nlst <- c(1, 2, -3, -4, 5,\
    \ -7, 8, -9)\nlargest_smallest_integers(lst)\n", "\n  has_positive_integer <-\
    \ false\n  has_negative_integer <- false\n  smallest_positive_integer <- 0\n \
    \ largest_negative_integer <- 0\n  for (i in lst) {\n    if (i > 0) {\n      has_positive_integer\
    \ <- true\n      if (i < smallest_positive_integer || smallest_positive_integer\
    \ == 0) {\n        smallest_positive_integer <- i\n      }\n    } else if (i <\
    \ 0) {\n      has_negative_integer <- true\n      if (i > largest_negative_integer\
    \ || largest_negative_integer == 0) {\n        largest_negative_integer <- i\n\
    \      }\n    }\n  }\n  if (has_positive_integer == false) {\n    smallest_positive_integer\
    \ <- None\n  }\n  if (has_negative_integer == false) {\n    largest_negative_integer\
    \ <- None\n  }\n  return (list(largest_negative_integer, smallest_positive_integer))\n\
    }\n", "\n  if (is.null(lst)) return(c(None, None))\n  if (length(lst) == 0) return(c(None,\
    \ None))\n  pos = which(lst > 0)\n  neg = which(lst < 0)\n  max_neg = if (length(neg)\
    \ == 0) None else max(lst[neg])\n  min_pos = if (length(pos) == 0) None else min(lst[pos])\n\
    \  return(c(max_neg, min_pos))\n}", "\n  if(length(lst) == 0) {\n    return(c(None,\
    \ None))\n  }\n  minp <- min(lst[lst>0])\n  maxn <- max(lst[lst<0])\n  if(is.na(minp))\
    \ {\n    minp <- None\n  }\n  if(is.na(maxn)) {\n    maxn <- None\n  }\n  return(c(maxn,\
    \ minp))\n}\n\nprint(largest_smallest_integers(c(2, 4, 1, 3, 5, 7)))\nprint(largest_smallest_integers(c()))\n\
    print(largest_smallest_integers(c(0)))\nprint(largest_smallest_integers(c(-2,\
    \ -1, -3)))\nprint(largest_smallest_integers(c(2, 4, 1, 3, -5, -7)))\n", "\n \
    \   max <- NULL\n    min <- NULL\n    for (i in 1:length(lst)) {\n        if (lst[i]\
    \ > 0) {\n            if (is.null(min) || lst[i] < min) {\n                min\
    \ <- lst[i]\n            }\n        } else if (lst[i] < 0) {\n            if (is.null(max)\
    \ || lst[i] > max) {\n                max <- lst[i]\n            }\n        }\n\
    \    }\n    return (c(max, min))\n}\nlargest_smallest_integers(list(2, 4, 1, 3,\
    \ 5, 7))\nlargest_smallest_integers(list())\nlargest_smallest_integers(list(0))\n\
    \ \n ", "\n    if (all(lst == 0))\n        return(c(None, None))\n    lst <- lst[lst\
    \ != 0]\n    if (all(lst > 0))\n        return(c(None, min(lst)))\n    if (all(lst\
    \ < 0))\n        return(c(max(lst), None))\n    c(max(lst[lst < 0]), min(lst[lst\
    \ > 0]))\n}\nlargest_smallest_integers(c(2, 4, 1, 3, 5, 7))\n", "\n  a <- NULL\n\
    \  b <- NULL\n  for (i in lst) {\n    if (i < 0) {\n      if (a == NULL) {\n \
    \       a <- i\n      } else if (i > a) {\n        a <- i\n      }\n    } else\
    \ if (i > 0) {\n      if (b == NULL) {\n        b <- i\n      } else if (i < b)\
    \ {\n        b <- i\n      }\n    }\n  }\n  c(a, b)\n}"]
stop_tokens:
- "\n#"
- "\n```"
