name: HumanEval_10_make_palindrome
language: r
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n\
  # 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\nmake_palindrome <- function(string)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- make_palindrome\n    if(!identical(candidate(''),\
  \ '')){quit('no', 1)}\n    if(!identical(candidate('x'), 'x')){quit('no', 1)}\n\
  \    if(!identical(candidate('xyz'), 'xyzyx')){quit('no', 1)}\n    if(!identical(candidate('xyx'),\
  \ 'xyx')){quit('no', 1)}\n    if(!identical(candidate('jerry'), 'jerryrrej')){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  len <- nchar(string)\n  suffix <- rev(substr(string, start = 1,\
    \ stop = len))\n  prefix <- sub(\"[^ ]*$\", \"\", string)\n  return(sprintf(\"\
    %s%s\", string, suffix))\n}\n", "\n  n <- nchar(string)\n  if (n == 0) {\n   \
    \ return(string)\n  }\n  # A position in a string at which the palindromic suffix\
    \ ends.\n  position <- n\n  while (TRUE) {\n    # Check if the string prefix is\
    \ a palindrome.\n    is_palindrome <- TRUE\n    # Start from left and right ends\
    \ of the prefix.\n    i <- 1\n    j <- position - 1\n    while (i < j) {\n   \
    \   if (substr(string, i, i) != substr(string, j, j)) {\n        is_palindrome\
    \ <- FALSE\n        break\n      }\n      i <- i + 1\n      j <- j - 1\n    }\n\
    \    if (is_palindrome) {\n      # Found the first palindromic suffix.\n     \
    \ break\n    }\n    position <- position - 1\n  }\n  # Append the reversed string\
    \ prefix.\n  string <- paste(string, substr(string, 1, position - 1), sep = '')\n\
    \  return(string)\n}\n\ntests <- function() {\n  print(make_palindrome(''))\n\
    \  print(make_palindrome('cat'))\n  print(make_palindrome('cata'))\n}\n\ntests()\n\
    \ \n ", "\n  if (nchar(string) == 0) {\n    return(string)\n  }\n  if (nchar(string)\
    \ == 1) {\n    return(string)\n  }\n  if (string[1] == string[nchar(string)])\
    \ {\n    return(string)\n  }\n  if (all(string[1:(nchar(string) - 1)] == string[(nchar(string)):1]))\
    \ {\n    return(string)\n  }\n  longest_palindrome <- function(s) {\n    if (nchar(s)\
    \ == 0) {\n      return(s)\n    }\n    if (nchar(s) == 1) {\n      return(s)\n\
    \    }\n    if (s[1] == s[nchar(s)]) {\n      return(c(s[1], longest_palindrome(s[2:(nchar(s)\
    \ - 1)]), s[1]))\n    }\n    return(longest_palindrome(s[1:(nchar(s) - 1)]))\n\
    \  }\n  suffix <- longest_palindrome(string)\n  if (suffix == string) {\n    return(string)\n\
    \  }\n  reversed_prefix <- c(rev(string[1:(nchar(string) - nchar(suffix))]), string)\n\
    \  return(reversed_prefix)\n}\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n\
    make_palindrome('cataa')\nmake_palindrome('cats')\nmake_palindrome('catt')\nmake_palindrome('catc')\n\
    make_palindrome('catac')\n", "\n    L <- nchar(string)\n    postfix <- string\n\
    \    while (L > 0) {\n        if (stringr::str_detect(stringr::str_reverse(postfix),\
    \ stringr::str_c(string, collapse = '|'))) {\n            prefix <- stringr::str_sub(string,\
    \ 1, L)\n            break\n        }\n        postfix <- stringr::str_sub(postfix,\
    \ 2)\n        L <- L - 1\n    }\n    return(stringr::str_c(string, stringr::str_reverse(prefix)))\n\
    }\n", "\n    return(supplied_string)\n}\n\nmake_palindrome('cata')\n", "\n  if\
    \ (string == '') return('')\n  # Get the length of the string.\n  string_length\
    \ <- nchar(string)\n  # Get a slice of the string from index 0 to length - 1.\n\
    \  suffix <- substr(string, 0, string_length - 1)\n  # Find the longest palindromic\
    \ suffix of the string.\n  palindromic_suffix <- find_longest_palindromic_suffix(suffix)\n\
    \  # Get the length of the palindromic suffix.\n  palindromic_suffix_length <-\
    \ nchar(palindromic_suffix)\n  # Get a slice of the palindromic suffix from index\
    \ 0 to length - 1.\n  prefix <- substr(palindromic_suffix, 0, palindromic_suffix_length\
    \ - 1)\n  # Create a string that is a reverse of the prefix.\n  reversed_prefix\
    \ <- paste(rev(prefix), collapse = '')\n  # Concatenate the supplied string with\
    \ the reversed prefix.\n  return(paste(string, reversed_prefix, sep = ''))\n}\n",
  "\n    if(nchar(string) == 0) {\n        return(string)\n    }\n\n    # Reverse\
    \ of a string.\n    reverse <- function(string) {\n        res <- ''\n       \
    \ for(i in 1:nchar(string)) {\n            res <- paste(res, substr(string, i,\
    \ i), sep='')\n        }\n        return(res)\n    }\n\n    # Manacher's algorithm\
    \ for finding the longest palindromic substring.\n    manacher <- function(string)\
    \ {\n        if(nchar(string) == 0) {\n            return('')\n        }\n\n \
    \       # Transform string into new string that has unique boundaries between\
    \ letters.\n        # E.g. 'aba' -> '$#a#b#a#@'.\n        # The idea of this is\
    \ that the longest palindromic substring with center in letter 'a'\n        #\
    \ has boundaries with letters 'b'. So 'aba' is the longest palindromic substring.\n\
    \        new_string <- '$'\n        for(i in 1:nchar(string)) {\n            new_string\
    \ <- paste(new_string, '#', substr(string, i, i), sep='')\n        }\n       \
    \ new_string <- paste(new_string, '#@', sep='')\n\n        # The longest palindromic\
    \ substring.\n        res <- ''\n\n        # A list that contains radii of the\
    \ longest palindromic substring for a center in letter.\n        d <- list()\n\
    \n        # An index of the letter with the longest palindromic substring.\n \
    \       max_right <- 1\n        max_right_index <- 1\n\n        # Index of the\
    \ letter with the longest palindromic substring.\n        for(i in 1:nchar(new_string))\
    \ {\n            d[[i]] <- 1\n            if(i <= max_right) {\n             \
    \   d[[i]] <- min(d[[2 * max_right_index - i]], max_right - i)\n            }\n\
    \            while(substr(new_string, i - d[[i]], i - d[[i]]) == substr(new_string,\
    \ i + d[[i]], i + d[[i]])) {\n               ", "\n  l <- nchar(string)\n  if\
    \ (l == 0) {\n    return(string)\n  }\n  # Find the longest palindromic suffix\n\
    \  suffix <- l\n  while (suffix > 0) {\n    if (string[suffix] == string[l]) {\n\
    \      if (is_palindrome(string[suffix:l])) {\n        break\n      }\n    }\n\
    \    suffix <- suffix - 1\n  }\n  if (suffix == 0) {\n    # The whole string is\
    \ already a palindrome\n    return(string)\n  }\n  # append reverse of a string\
    \ prefix before the palindromic suffix\n  return(paste(string, rev(string[1:(l\
    \ - suffix)]), sep=''))\n}\n", "\n  # find the longest palindromic suffix\n  for\
    \ (i in seq_len(nchar(string))) {\n    j <- nchar(string) - i + 1\n    prefix\
    \ <- substr(string, 1, i)\n    if (prefix == rev(prefix)) {\n      # we have a\
    \ palindromic suffix; return the prefix, reversed and appended\n      return(paste(string,\
    \ rev(substr(string, j, nchar(string))), sep = ''))\n    }\n  }\n  # all chars\
    \ of the supplied string are a palindrome\n  return(string)\n}\n\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\n", "\n  # TODO: write code here\n\
    \  longest_postfix <- function(string) {\n    # TODO: write code here\n  }\n \
    \ string <- paste(string, gsub(\"\", \" \", string), sep=\"\")\n  string\n}\n\n\
    print(\"make_palindrome:\")\ntestthat::expect_equal(make_palindrome(\"\"), \"\"\
    )\ntestthat::expect_equal(make_palindrome(\"a\"), \"a\")\ntestthat::expect_equal(make_palindrome(\"\
    aa\"), \"aa\")\ntestthat::expect_equal(make_palindrome(\"aaa\"), \"aaa\")\ntestthat::expect_equal(make_palindrome(\"\
    baba\"), \"bababa\")\ntestthat::expect_equal(make_palindrome(\"cat\"), \"catac\"\
    )\ntestthat::expect_equal(make_palindrome(\"taco\"), \"tacocat\")\ntestthat::expect_equal(make_palindrome(\"\
    catac\"), \"catac\")\ntestthat::expect_equal(make_palindrome(\"cataca\"), \"catacataca\"\
    )\ntestthat::expect_equal(make_palindrome(\"catacat\"), \"catacat\")\ntestthat::expect_equal(make_palindrome(\"\
    ababa\"), \"abababa\")\ntestthat::expect_equal(make_palindrome(\"racecar\"), \"\
    racecar\")\ntestthat::expect_equal(make_palindrome(\"mom\"), \"mom\")\ntestthat::expect_equal(make_palindrome(\"\
    deed\"), \"deedeed\")\ntestthat::expect_equal(make_palindrome(\"rotor\"), \"rotorotor\"\
    )\n ", "\n  postfix_begin <- nchar(string)\n  postfix_end <- nchar(string)\n \
    \ while (postfix_begin > 0) {\n    while (postfix_end <= nchar(string)) {\n  \
    \    if (is_palindrome(substr(string, postfix_begin, postfix_end))) {\n      \
    \  prefix <- substr(string, 1, postfix_begin - 1)\n        return(paste(string,\
    \ substr(prefix, 1, nchar(prefix) - 1), sep=''))\n      }\n      postfix_end <-\
    \ postfix_end + 1\n    }\n    postfix_begin <- postfix_begin - 1\n    postfix_end\
    \ <- postfix_begin\n  }\n  string\n}\n", "\n  # How to find the longest palindromic\
    \ suffix?\n  # Let's make the code a bit more generic and split the string into\
    \ prefix and suffix.\n  # We'll then be able to reuse the find_palindrome function\
    \ to find the longest palindromic suffix.\n  string_length <- nchar(string)\n\
    \  prefix <- string[1:(string_length-1)]\n  suffix <- string[string_length]\n\
    \  palindrome <- find_palindrome(suffix, prefix)\n  # Once we know the palindromic\
    \ suffix, we prepend to it the reverse of the string prefix that comes before\
    \ the palindromic suffix.\n  suffix <- palindrome\n  prefix <- string[1:(string_length-1)]\n\
    \  prefix <- paste(rev(string_split(prefix, split = '')[[1]]), collapse = '')\n\
    \  # And we're done.\n  paste(prefix, suffix, sep = '')\n}\n", "\n  N <- nchar(string)\n\
    \  if (N == 0) {\n    return(string)\n  }\n  # Preallocate for palindrome\n  palindrome\
    \ <- string\n  # Start from the end of string to find the longest palindromic\
    \ suffix.\n  for (i in seq_len(N - 1)[[1]]) {\n    substr <- substr(string, i\
    \ + 1, N)\n    if (is_palindrome(substr)) {\n      palindrome <- paste0(string,\
    \ substr(string, 1, i))\n      break\n    }\n  }\n  return(palindrome)\n}\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\n", "\n  # Note: R's 'rev' is\
    \ not an alias for 'reverse', but for 'reversed'\n  lcp <- function(x, y) {\n\
    \    lcp <- rep(0, min(nchar(x), nchar(y)))\n    for (i in seq_along(lcp))\n \
    \     if (substr(x, start = i, stop = i) == substr(y, start = i, stop = i))\n\
    \        lcp[i] <- lcp[i - 1] + 1\n    return(lcp)\n  }\n  max_i <- max(which(lcp(string,\
    \ rev(string)) == nchar(string):1))\n  return(paste(string, substring(string,\
    \ 1, (nchar(string) - max_i)), sep = ''))\n}", "\n    palindrome_suffix <- longest_palindrome_suffix(string)\n\
    \    return(paste(string, string[1:(nchar(string) - nchar(palindrome_suffix))],\
    \ sep = ''))\n}\n", "\n  longest_palindrome <- find_longest_palindrome(string)\n\
    \  prefix <- substr(string, 1, nchar(string) - nchar(longest_palindrome))\n  return(paste(string,\
    \ paste(strsplit(prefix, \"\")[[1]], collapse=\"\"), sep=\"\"))\n}", "\n  if (string\
    \ == '') return('')\n  len <- nchar(string)\n  j <- 1\n  while (j <= len && string[j]\
    \ == string[len]) {\n    j <- j + 1\n    len <- len - 1\n  }\n  if (j > len) {\n\
    \    return(string)\n  }\n  prefix <- substr(string, 1, j - 1)\n  postfix <- substr(string,\
    \ j, len)\n  return(paste(prefix, make_palindrome(postfix), prefix, sep = ''))\n\
    }\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n", "\n\
    \  prefix <- substr(string, 1, nchar(string) - length(suffix))\n  suffix <- string[gregexpr('(.*)(.*)(\\\
    \\2)(\\\\1)', string, perl=TRUE, fixed=TRUE)[[1]][2]:nchar(string)]\n  return(paste(string,\
    \ prefix, sep=''))\n}", "\n  if (nchar(string) == 0) return(string)\n  prefix\
    \ <- substr(string, 1, nchar(string)-1)\n  if (is_palindrome(string)) return(string)\n\
    \  if (is_palindrome(prefix)) return(string)\n  if (nchar(prefix) == 0) return(paste(string,\
    \ string, sep=''))\n  return(paste(string, rev(make_palindrome(prefix)), sep=''))\n\
    }\n", "\n    # find the longest palindromic postfix\n    longest_postfix <- longest_palindromic_subsequence(string)\n\
    \    # add the prefix as reversed string.\n    prefix <- sub(longest_postfix,\
    \ '', string)\n    return(paste(string, stringReverse(prefix), sep=''))\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
