name: HumanEval_49_modp
language: r
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\nmodp <- function(n, p) {"
tests: "test_humaneval <- function() {\ncandidate <- modp\n    if(!identical(candidate(3,\
  \ 5), 3)){quit('no', 1)}\n    if(!identical(candidate(1101, 101), 2)){quit('no',\
  \ 1)}\n    if(!identical(candidate(0, 101), 1)){quit('no', 1)}\n    if(!identical(candidate(3,\
  \ 11), 8)){quit('no', 1)}\n    if(!identical(candidate(100, 101), 1)){quit('no',\
  \ 1)}\n    if(!identical(candidate(30, 5), 4)){quit('no', 1)}\n    if(!identical(candidate(31,\
  \ 5), 3)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n    #base cases\n    if (n < 0) return(0)\n    if (n == 0) return(1)\n\
    \    if (n == 1) return(2)\n    #recursive case\n    return(mod(2 * modp(n - 1,\
    \ p), p))\n}\n", "\n    x <- 1\n    for (i in 1:n) {\n        x <- x * 2 %% p\n\
    \    }\n    return(x)\n}\n", "\n  prod <- 1\n  for (i in 1:n) {\n    prod <- prod*2\
    \ %/% p\n  }\n  prod\n}", "\n    if (n == 0) {\n        return(1)\n    }\n   \
    \ if (n == 1) {\n        return(2)\n    }\n    if (n == 2) {\n        return(4)\n\
    \    }\n    if (n % 2 == 0) {\n        return(modp(n / 2, p) ^ 2 %% p)\n    }\n\
    \    return(2 * modp(n - 1, p) %% p)\n}\n", "\n    # CODE\n    res = 0\n    while\
    \ (n > 0) {\n        res = res * 2\n        if (res > p) {\n            res =\
    \ res - p\n        }\n        n = n - 1\n    }\n    return(res)\n}", "\n  if (n\
    \ == 0) {\n    return(1)\n  }\n  if (n % 2 == 0) {\n    pow <- modp(n / 2, p)\n\
    \    return(mod(pow * pow, p))\n  }\n  return(mod(n * modp(n - 1, p), p))\n}\n",
  "\n    nExp <- 1\n    nSquared <- n\n    while (n > 0) {\n        if (n %% 2 ==\
    \ 1) {\n            nExp <- (nExp * nSquared) %% p\n        }\n        nSquared\
    \ <- (nSquared * nSquared) %% p\n        n <- floor(n / 2)\n    }\n    return(nExp)\n\
    }\n", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n %% 2 == 0) {\n    x <- modp(n/2,\
    \ p)\n    return((x*x) %% p)\n  }\n  return((2*modp(n-1, p)) %% p)\n}\n", "\n\
    \  if (n == 0) return(1)\n  return((2 * modp(n - 1, p)) %% p)\n}\n", "\n    result\
    \ <- 1\n    cur <- 2 %%% p\n    for (i in 1:n) {\n        if (i %% 1000 == 0)\
    \ {\n            cat(i, '\\n')\n        }\n        if (n %% 2^i == 0) {\n    \
    \        result <- (result * cur) %%% p\n        }\n        cur <- (cur^2) %%%\
    \ p\n    }\n    return(result)\n}\n\nsource('tests.R')\n", "\n    if (n == 0)\
    \ {\n        return (1)\n    } else if (n == 1) {\n        return (2)\n    } else\
    \ {\n        return (modp(n - 1, p) * 2 %/% p)\n    }\n}", "\n    n <<- n %% p\n\
    \    if (n == 0) 1 else (2 * modp(n - 1, p)) %% p\n}\n", "\n  if (n == 0) {\n\
    \    return(1)\n  }\n  if (n == 1) {\n    return(2)\n  }\n  a <- 2;\n  for (i\
    \ in 2:n) {\n    a <- (a*2) %% p\n  }\n  return(a)\n}", "\n\tif (n == 0) return(1)\n\
    \t\n\t# n is even, n = 2 * x\n\tif (n %% 2 == 0) {\n\t\tm <- modp(n / 2, p)\n\t\
    \tm^2 %% p\n\t}\n\t# n is odd, n = 2 * x + 1\n\telse {\n\t\tm <- modp((n - 1)\
    \ / 2, p)\n\t\t2 * m^2 %% p\n\t}\n}\n", "\n  res <- 1\n  while (n > 0) {\n   \
    \ if (n%%2 == 1) {\n      res <- (res * 2)%%p\n    }\n    n <- n/2\n  }\n  return(res)\n\
    }\n", "\n\tres <- 1\n\twhile (n > 0) {\n\t\tif (n %% 2 == 1) {\n\t\t\tres <- (res\
    \ * n) %% p\n\t\t}\n\t\tn <- n / 2\n\t}\n\treturn(res)\n}\n", "\n  v <- c(1)\n\
    \  for (i in 1:n) {\n    v <- c(v[length(v)]*2, mod(c(v, v[length(v)]), p))\n\
    \  }\n  return(v[length(v)])\n}\n ", "\n\tif (n == 0) return(1)\n\tif (n == 1)\
    \ return(2)\n\tif (n %% 2 == 0) return(modp(n/2, p) ^ 2 %% p)\n\tif (n %% 2 ==\
    \ 1) return(2 * modp(n-1, p) %% p)\n}\n", "\n    p2 <- 1\n    while (n > 0) {\n\
    \        if (n %% 2 == 1) {\n            p2 <- p2 * 2 %% p\n        }\n      \
    \  n <- n >> 1\n    }\n    return(p2)\n}\n", "\n  if (n==0) {return(1)}\n  else\
    \ {\n    z <- modp(n-1, p)\n    z * n %% p\n  }\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
