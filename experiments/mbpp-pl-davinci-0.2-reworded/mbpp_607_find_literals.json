{
  "name": "mbpp_607_find_literals",
  "language": "pl",
  "prompt": "# Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\nsub find_literals {\n    my($text, $pattern) = @_;\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py",
  "prompt_terminology": "reworded",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&find_literals;\n        if(eq_deeply($candidate->(\"The quick brown fox jumps over the lazy dog.\", \"fox\"),[\"fox\", 16, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Its been a very crazy procedure right\", \"crazy\"),[\"crazy\", 16, 21])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Hardest choices required strongest will\", \"will\"),[\"will\", 35, 39])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my $index = 0;\n    my $length = length($text);\n    my $pattern_length = length($pattern);\n    while($index < $length) {\n        my $substring = substr($text, $index, $pattern_length);\n        if($substring eq $pattern) {\n            return ($substring, $index, $index + $pattern_length - 1);\n        }\n        $index++;\n    }\n    return undef;\n}",
    "    my $match = $text =~ /$pattern/;\n    return $match ? ($&, $-[0], $+[0]) : ();\n}",
    "    my $regex = qr/$pattern/;\n    if ($text =~ /$regex/) {\n        return ($&, $-[0], $+[0]);\n    }\n    return;\n}",
    "    my @matches = ();\n    my $match;\n    while ($text =~ /$pattern/g) {\n        $match = substr($text, $-[0], $+[0] - $-[0]);\n        push @matches, [$match, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$&, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my $regex = qr/$pattern/;\n    my @matches = ();\n    while ($text =~ /$regex/g) {\n        push @matches, [$1, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my $regex = qr/$pattern/;\n    if ($text =~ $regex) {\n        return ($&, $-[0], $+[0]);\n    }\n    return;\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$&, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my $start = index($text, $pattern);\n    my $end = $start + length($pattern) - 1;\n    return ($start, $end, $pattern);\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$1, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my $match = $text =~ /$pattern/;\n    return ($match, $-[0], $+[0]);\n}",
    "    my @matches = ();\n    my $start = 0;\n    my $end = 0;\n    while($text =~ /$pattern/g){\n        $start = $-[0];\n        $end = $+[0];\n        push @matches, [$&, $start, $end];\n    }\n    return @matches;\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$1, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my @matches = ();\n    my @patterns = split(/\\|/, $pattern);\n    foreach my $p (@patterns) {\n        my $index = index($text, $p);\n        if ($index != -1) {\n            push @matches, [$p, $index, $index + length($p)];\n        }\n    }\n    return @matches;\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$1, $-[1], $+[1]];\n    }\n    return @matches;\n}",
    "    my @matches = ();\n    while($text =~ /$pattern/g){\n        push @matches, [$1, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$&, $-[0], $+[0]];\n    }\n    return @matches;\n}",
    "    my $regex = qr/$pattern/;\n    my @matches = $text =~ m/$regex/g;\n    return @matches;\n}",
    "    my $regex = qr/$pattern/;\n    my @matches = $text =~ /$regex/g;\n    my @indices = ();\n    my $index = 0;\n    foreach my $match (@matches) {\n        my $start = index($text, $match, $index);\n        my $end = $start + length($match);\n        push @indices, [$match, $start, $end];\n        $index = $end;\n    }\n    return @indices;\n}",
    "    my @matches;\n    while ($text =~ /$pattern/g) {\n        push @matches, [$&, $-[0], $+[0]];\n    }\n    return @matches;\n}"
  ]
}