{
  "name": "mbpp_18_remove_dirty_chars",
  "language": "pl",
  "prompt": "# Write a function to remove characters from the first string which are present in the second string.\nsub remove_dirty_chars {\n    my($string, $second_string) = @_;\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py",
  "prompt_terminology": "reworded",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&remove_dirty_chars;\n        if(eq_deeply($candidate->(\"probasscurve\", \"pros\"),\"bacuve\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"digitalindia\", \"talent\"),\"digiidi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"exoticmiles\", \"toxic\"),\"emles\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my $result = '';\n    my %second_string_hash = map { $_ => 1 } split //, $second_string;\n    for my $char (split //, $string) {\n        $result .= $char unless exists $second_string_hash{$char};\n    }\n    return $result;\n}",
    "    my @chars = split //, $string;\n    my @dirty_chars = split //, $second_string;\n    my %dirty_chars = map { $_ => 1 } @dirty_chars;\n    my @clean_chars;\n    for my $char (@chars) {\n        push @clean_chars, $char unless $dirty_chars{$char};\n    }\n    return join '', @clean_chars;\n}",
    "    my %dirty_chars = map {$_ => 1} split //, $second_string;\n    my @clean_chars = grep {!$dirty_chars{$_}} split //, $string;\n    return join '', @clean_chars;\n}",
    "    my %hash;\n    my $result = '';\n    for my $char (split //, $second_string) {\n        $hash{$char} = 1;\n    }\n    for my $char (split //, $string) {\n        $result .= $char unless $hash{$char};\n    }\n    return $result;\n}",
    "    my %second_string_chars = map { $_ => 1 } split(//, $second_string);\n    my @clean_string = grep { !$second_string_chars{$_} } split(//, $string);\n    return join('', @clean_string);\n}",
    "    my $clean_string = '';\n    my %second_string_chars = map { $_ => 1 } split(//, $second_string);\n    for my $char (split(//, $string)) {\n        $clean_string .= $char if !$second_string_chars{$char};\n    }\n    return $clean_string;\n}",
    "    my %hash;\n    my @array = split //, $second_string;\n    foreach my $char (@array) {\n        $hash{$char} = 1;\n    }\n    my @new_array = split //, $string;\n    my @result;\n    foreach my $char (@new_array) {\n        if (not exists $hash{$char}) {\n            push @result, $char;\n        }\n    }\n    return join '', @result;\n}",
    "    my $result = \"\";\n    my %hash = map { $_ => 1 } split(//, $second_string);\n    for my $char (split(//, $string)) {\n        $result .= $char unless $hash{$char};\n    }\n    return $result;\n}",
    "    my %hash;\n    my @chars = split(//, $second_string);\n    foreach my $char (@chars) {\n        $hash{$char} = 1;\n    }\n    my @string_chars = split(//, $string);\n    my @result;\n    foreach my $char (@string_chars) {\n        if (!$hash{$char}) {\n            push(@result, $char);\n        }\n    }\n    return join('', @result);\n}",
    "    my %hash = map {$_ => 1} split //, $second_string;\n    my $result = '';\n    for my $char (split //, $string) {\n        $result .= $char unless $hash{$char};\n    }\n    return $result;\n}",
    "    my @chars = split(//, $second_string);\n    my %hash = map { $_ => 1 } @chars;\n    my @new_chars = grep { !$hash{$_} } split(//, $string);\n    return join('', @new_chars);\n}",
    "    my @dirty_chars = split(//, $second_string);\n    my %dirty_chars = map { $_ => 1 } @dirty_chars;\n    my @clean_string = grep { !$dirty_chars{$_} } split(//, $string);\n    return join('', @clean_string);\n}",
    "    my %hash = map { $_ => 1 } split //, $second_string;\n    my $new_string = '';\n    for my $char (split //, $string) {\n        $new_string .= $char unless $hash{$char};\n    }\n    return $new_string;\n}",
    "    my @chars = split //, $second_string;\n    my %dirty_chars = map { $_ => 1 } @chars;\n    my @clean_chars = grep { !$dirty_chars{$_} } split //, $string;\n    return join '', @clean_chars;\n}",
    "    my %dirty_chars = map { $_ => 1 } split //, $second_string;\n    my @clean_chars = grep { !$dirty_chars{$_} } split //, $string;\n    return join '', @clean_chars;\n}",
    "    my $result = '';\n    for my $char (split //, $string) {\n        $result .= $char unless $second_string =~ /$char/;\n    }\n    return $result;\n}",
    "    my @chars = split(//, $second_string);\n    my %hash = map { $_ => 1 } @chars;\n    my @result = grep { !$hash{$_} } split(//, $string);\n    return join(\"\", @result);\n}",
    "    my $new_string = '';\n    foreach my $char (split //, $string) {\n        $new_string .= $char unless $second_string =~ /$char/;\n    }\n    return $new_string;\n}",
    "    my %hash;\n    my @chars = split(//, $second_string);\n    foreach my $char (@chars) {\n        $hash{$char} = 1;\n    }\n    my @string_chars = split(//, $string);\n    my $result = \"\";\n    foreach my $char (@string_chars) {\n        if(!$hash{$char}) {\n            $result .= $char;\n        }\n    }\n    return $result;\n}",
    "    my $result = \"\";\n    my %hash = map {$_ => 1} split(//, $second_string);\n    for my $char (split(//, $string)) {\n        $result .= $char unless $hash{$char};\n    }\n    return $result;\n}"
  ]
}