{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "pl",
  "prompt": "# Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nsub k_smallest_pairs {\n    my($nums1, $nums2, $k) = @_;\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&k_smallest_pairs;\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 1),[[1, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif($i + 1 < @$nums1) {\n            $i++;\n        } else {\n            $j++;\n        }\n        push @res, [$nums1->[$i], $nums2->[$j]];\n    }\n    return \\@res;\n}",
    "    my @result;\n    my @indexes = (0) x @$nums1;\n    while (@result < $k) {\n        my $min = undef;\n        my $min_index = undef;\n        for my $i (0 .. $#$nums1) {\n            next if $indexes[$i] >= @{$nums2};\n            if (!defined $min || $nums1->[$i] + $nums2->[$indexes[$i]] < $min) {\n                $min = $nums1->[$i] + $nums2->[$indexes[$i]];\n                $min_index = $i;\n            }\n        }\n        last if !defined $min;\n        push @result, [$nums1->[$min_index], $nums2->[$indexes[$min_index]]];\n        $indexes[$min_index]++;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && $k > 0) {\n        my $a = $nums1->[$i];\n        my $b = $nums2->[$j];\n        if($a + $b < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$a, $b];\n            $i++;\n        } else {\n            push @res, [$a, $b];\n            $j++;\n        }\n        $k--;\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    return \\@res if $len1 == 0 or $len2 == 0;\n    my $pq = new Heap::Binary();\n    $pq->add([0, 0, $nums1->[0] + $nums2->[0]]);\n    my %visited;\n    $visited{\"0,0\"} = 1;\n    while ($k-- > 0) {\n        my $pair = $pq->extract_top();\n        last if not defined $pair;\n        push @res, [$nums1->[$pair->[0]], $nums2->[$pair->[1]]];\n        if ($pair->[0] + 1 < $len1 and not exists $visited{($pair->[0] + 1) . \",\" . $pair->[1]}) {\n            $pq->add([$pair->[0] + 1, $pair->[1], $nums1->[$pair->[0] + 1] + $nums2->[$pair->[1]]]);\n            $visited{($pair->[0] + 1) . \",\" . $pair->[1]} = 1;\n        }\n        if ($pair->[1] + 1 < $len2 and not exists $visited{$pair->[0] . \",\" . ($pair->[1] + 1)}) {\n            $pq->add([$pair->[0], $pair->[1] + 1, $nums1->[$pair->[0]] + $nums2->[$pair->[1] + 1]]);\n            $visited{$pair->[0] . \",\" . ($pair->[1] + 1)} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2) && scalar(@result) < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i == 0 || $sum > $nums1->[$i - 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @result, [$nums1->[$i - 1], $nums2->[$j]];\n            $j++;\n        }\n    }\n    while ($i < scalar(@$nums1) && scalar(@result) < $k) {\n        push @result, [$nums1->[$i], $nums2->[$j - 1]];\n        $i++;\n    }\n    while ($j < scalar(@$nums2) && scalar(@result) < $k) {\n        push @result, [$nums1->[$i - 1], $nums2->[$j]];\n        $j++;\n    }\n    return \\@result;\n}",
    "    my $result = [];\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < $n1 && $j < $n2 && $count < $k) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @$result, $pair;\n        $count++;\n        if ($i == $n1 - 1) {\n            $j++;\n        } elsif ($j == $n2 - 1) {\n            $i++;\n        } elsif ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return $result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    my @idx;\n    for my $i (0..$len1-1) {\n        push @idx, [$i, 0];\n    }\n    while (@res < $k && @idx) {\n        my $min = $idx[0];\n        for my $i (1..$#idx) {\n            if ($nums1->[$idx[$i][0]] + $nums2->[$idx[$i][1]] < $nums1->[$min->[0]] + $nums2->[$min->[1]]) {\n                $min = $idx[$i];\n            }\n        }\n        push @res, [$nums1->[$min->[0]], $nums2->[$min->[1]]];\n        if ($min->[1] == $len2 - 1) {\n            splice @idx, $min->[0], 1;\n        } else {\n            $idx[$min->[0]][1]++;\n        }\n    }\n    return \\@res;\n}",
    "\n    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }",
    "    my @res;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $min_heap = Heap::Simple->new(\n        order => '<',\n        elements => 'Any',\n        use_extract_priority => 1,\n    );\n    $min_heap->insert([0, 0, $nums1->[0] + $nums2->[0]]);\n    my %visited;\n    $visited{\"0,0\"} = 1;\n    while ($min_heap->count > 0 && scalar @res < $k) {\n        my $cur = $min_heap->extract_top;\n        push @res, [$nums1->[$cur->[0]], $nums2->[$cur->[1]]];\n        if ($cur->[0] + 1 < $len1 && !exists $visited{($cur->[0] + 1) . \",\" . $cur->[1]}) {\n            $min_heap->insert([$cur->[0] + 1, $cur->[1], $nums1->[$cur->[0] + 1] + $nums2->[$cur->[1]]]);\n            $visited{($cur->[0] + 1) . \",\" . $cur->[1]} = 1;\n        }\n        if ($cur->[1] + 1 < $len2 && !exists $visited{$cur->[0] . \",\" . ($cur->[1] + 1)}) {\n            $min_heap->insert([$cur->[0], $cur->[1] + 1, $nums1->[$cur->[0]] + $nums2->[$cur->[1] + 1]]);\n            $visited{$cur->[0] . \",\" . ($cur->[1] + 1)} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "\n    my @pairs;\n    for my $i (0 .. $#$nums1) {\n        for my $j (0 .. $#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }",
    "    my @res;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    return [] if $n1 == 0 || $n2 == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $n1 && $j < $n2 && $k > 0) {\n        if ($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        $k--;\n    }\n    while ($i < $n1 && $k > 0) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $i++;\n        $k--;\n    }\n    while ($j < $n2 && $k > 0) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n        $k--;\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif ($i + 1 < @$nums1) {\n            $i++;\n        } else {\n            $j++;\n        }\n        push @result, [$nums1->[$i], $nums2->[$j]];\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return [] if $m == 0 || $n == 0;\n    for (my $i = 0; $i < $m; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    heapify(\\@heap);\n    for (my $i = 0; $i < $k && $i < $m * $n; $i++) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if ($pair->[2] < $n - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n        heapify(\\@heap);\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @result;\n    return \\@result if $len1 == 0 || $len2 == 0;\n    my $pq = new PriorityQueue;\n    $pq->enqueue(0, 0);\n    while ($k > 0 && !$pq->is_empty) {\n        my $pair = $pq->dequeue;\n        my($i, $j) = @$pair;\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($j + 1 < $len2) {\n            $pq->enqueue($i, $j + 1);\n        }\n        if ($j == 0 && $i + 1 < $len1) {\n            $pq->enqueue($i + 1, $j);\n        }\n        $k--;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $len1 && $j < $len2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return [@pairs[0..$k-1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2) && $count < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        last if @res >= $k;\n    }\n    return \\@res;\n}",
    "    my @pairs;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    return [sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @pairs][0..$k-1];\n}"
  ]
}