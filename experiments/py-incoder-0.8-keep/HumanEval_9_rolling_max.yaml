name: HumanEval_9_rolling_max
language: py
prompt: "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n\
  \    \"\"\" From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3,\
  \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1,\
  \ 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n\
  \    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n\ndef test_check():\n\
  \    check(rolling_max)\n\ntest_check()\n"
completions: ["    sum = 0\n    for num in numbers:\n        sum += num\n        if\
    \ sum > numbers[-1]:\n            break\n    return numbers[:]\n", "    rolling_max_list\
    \ = [0] * len(numbers)\n    for i, number in enumerate(numbers):\n        rolling_max_list[i]\
    \ = max(rolling_max_list[i-1], number)\n    return rolling_max_list\n", "    \n\
    \    \n    return max(numbers)\n    ", "    def rolling_max_rec(numbers: List[int],\
    \ i: int) -> List[int]:\n        \"\"\" Recursive function that perform rolling\
    \ max operation on given list at given moment \"\"\"\n        if i >= len(numbers):\n\
    \            return []\n        elif numbers[i] == numbers[0]:\n            return\
    \ rolling_max_rec(numbers[:i], i) + 1\n        else:\n            rolling_max\
    \ = numbers[0]\n            for n in numbers[1:]:\n                if n < rolling_max:\n\
    \                    rolling_max = n\n            if rolling_max != numbers[-1]:\n\
    \                numbers = rolling_max_rec(numbers, i + 1)\n            else:\n\
    \                numbers = rolling_max_rec(numbers, i)\n            numbers.append(rolling_max)\n\
    \            return numbers\n    return rolling_max_rec([i for i in numbers],\
    \ 0)\n", "    \n    result = []\n    \n    for i in numbers:\n        result.append(i)\n\
    \        \n        for i in range(len(result) - 1):\n            if result[i]\
    \ > result[i + 1]:\n                result[i] = result[i]\n            else:\n\
    \                break\n    \n    return result\n    \n", "    \n    length =\
    \ len(numbers)\n    \n    if length <= 0:\n        return []\n    \n    # first\
    \ and last elements are the same one\n    if length == 1:\n        rolling_max_list\
    \ = []\n        rolling_max_list.append(numbers[0])\n        rolling_max_list.append(numbers[0])\n\
    \        return rolling_max_list\n    \n    # first and last elements are different\n\
    \    if length == 2:\n        rolling_max_list = []\n        rolling_max_list.append(numbers[0])\n\
    \        rolling_max_list.append(numbers[1])\n        return rolling_max_list\n\
    \    \n    rolling_max_list = []\n    \n    # rolling max from current position\n\
    \    for i in range(length-1):\n        rolling_max_list.append(max(numbers[i],\
    \ numbers[i+1]))\n    \n    # rolling max from next position\n    rolling_max_list.append(max(numbers[length-1],\
    \ numbers[length-2]))\n    \n    return rolling_max_list\n\n", "    \n    rolling_max_list\
    \ = []\n    \n    for i in range(len(numbers)):\n        \n        rolling_max_list.append(max(numbers[i:]))\n\
    \    \n    return rolling_max_list\n", "    max_rolling_list: List[int] = []\n\
    \    max_rolling_list.extend(numbers)\n    for num in numbers:\n        for index\
    \ in range(num - 1):\n            max_rolling_list.append(max(max_rolling_list[index],\
    \ max_rolling_list[index + 1]))\n    return max_rolling_list\n", "    rolling_max\
    \ = []\n    for i in reversed(range(len(numbers))):\n        rolling_max.append(max(numbers[:i+1]))\n\
    \    return rolling_max\n", "    max_roll_up = 0\n    max_element = 0\n    for\
    \ elem in numbers:\n        if elem > max_element:\n            max_element =\
    \ elem\n            max_roll_up = 0\n        elif elem == max_element:\n     \
    \       max_roll_up += 1\n        else:\n            max_element = elem\n    \
    \        max_roll_up = 1\n    return [max_element]*max_roll_up\n", "    res =\
    \ []\n    currentMax = numbers[0]\n    for number in numbers:\n        if number\
    \ > currentMax:\n            res.append(currentMax)\n        currentMax = max(number,\
    \ currentMax)\n    res.append(currentMax)\n    return res\n", "    rolling_max_elements\
    \ = []\n    if len(numbers) == 0:\n        return rolling_max_elements\n    window_size\
    \ = len(numbers) - 1\n    for i in reversed(range(len(numbers))):\n        rolling_max_elements.append(numbers[i])\n\
    \        if i <= window_size - 1:\n            rolling_max_elements.append(max(rolling_max_elements[i-1:window_size+1]))\n\
    \        else:\n            rolling_max_elements.append(max(rolling_max_elements[i-1:window_size+1]))\n\
    \    return rolling_max_elements\n", "    max_window = []\n    rolling_sum = 0\n\
    \    for i in range(len(numbers)):\n        rolling_sum += numbers[i]\n      \
    \  if rolling_sum > numbers[i]:\n            max_window.append(numbers[i])\n \
    \           rolling_sum -= numbers[i]\n        else:\n            rolling_sum\
    \ = 0\n    return max_window\n", "    max_number = max(numbers)\n    # rolling_max\
    \ = [0] * len(numbers)\n    rolling_max = [0] * len(numbers)\n    rolling_max[0]\
    \ = 1\n    index = len(numbers)-1\n    index_to_roll = 1\n    \n    for number\
    \ in numbers:\n        rolling_max[index] = number\n        index += 1\n     \
    \   if index == index_to_roll:\n            index += 1\n            index_to_roll\
    \ = index_to_roll * 2\n            rolling_max[index] = max_number\n    \n   \
    \ return rolling_max\n", "    n = len(numbers)\n    numbers_max = []\n    current\
    \ = 0\n    \n    for i in range(n//2):\n        if numbers[i] > current:\n   \
    \         numbers_max.append(numbers[i])\n        current = max(numbers[i], current)\n\
    \n    for i in range(n//2, n):\n        if numbers[i] > current:\n           \
    \ numbers_max.append(numbers[i])\n        current = max(numbers[i], current)\n\
    \n    numbers_max.append(current)\n    return numbers_max\n", "    maximum = numbers[0]\n\
    \    maximums = []\n    for number in numbers:\n        if number > maximum:\n\
    \            maximum = number\n        else:\n            maximums.append(maximum)\n\
    \            maximum = number\n    maximums.append(maximum)\n    return maximums\n\
    \n", "    \n    numbers_max_roll = []\n    # Init first element of rolling max\
    \ list\n    numbers_max_roll.append(numbers[0])\n    \n    for i in range(1, len(numbers)):\n\
    \        if numbers[i] >= numbers[i - 1]:\n            numbers_max_roll.append(numbers[i])\n\
    \        else:\n            numbers_max_roll.append(numbers[i - 1])\n\n    return\
    \ numbers_max_roll\n", "    if not numbers:\n        return []\n    max_list =\
    \ []\n    numbers.sort()\n    last_value = numbers[0]\n    rolling_max_found =\
    \ False\n    for value in numbers:\n        if last_value == value:\n        \
    \    continue\n        if value == max_list[-1]:\n            rolling_max_found\
    \ = True\n        else:\n            if rolling_max_found:\n                max_list.append(value)\n\
    \            else:\n                max_list.append(value)\n            rolling_max_found\
    \ = False\n        last_value = value\n    return max_list\n", "    if not numbers:\n\
    \        return []\n    min_i = numbers[0]\n    max_i = numbers[0]\n    for i\
    \ in range(1, len(numbers)):\n        if numbers[i] >= max_i:\n            max_i\
    \ = numbers[i]\n        elif numbers[i] < min_i:\n            min_i = numbers[i]\n\
    \        else:\n            max_i = numbers[i]\n\n    return [max_i] * len(numbers)\n",
  "    if len(numbers) == 0:\n        return []\n    else:\n        rolling_max =\
    \ numbers[0]\n        rolling_max_size = 1\n        rolling_max_index = numbers.index(rolling_max)\n\
    \        if rolling_max_index > 0:\n            rolling_max_size = rolling_max_index\n\
    \        for i in range(1, rolling_max_index + 1):\n            rolling_max =\
    \ max(rolling_max, numbers[i])\n            rolling_max_size = i + 1\n       \
    \     if rolling_max_index == i:\n                rolling_max_index = 1\n    \
    \        else:\n                rolling_max_index += 1\n        return [rolling_max,\
    \ rolling_max_index]\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
