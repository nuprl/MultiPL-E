name: HumanEval_99_closest_integer
language: py
prompt: "def closest_integer(value: str) -> int:\n    \"\"\"\n    Create a function\
  \ that takes a value (string) representing a number\n    and returns the closest\
  \ integer to it. If the number is equidistant\n    from two integers, round it away\
  \ from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"\
  15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given\
  \ number is equidistant\n    from two integers, the one you should return is the\
  \ one that is the\n    farthest from zero. For example closest_integer(\"14.5\"\
  ) should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \"\
  \"\"\n"
tests: "def check(candidate):\n    assert candidate('10') == 10\n    assert candidate('14.5')\
  \ == 15\n    assert candidate('-15.5') == -16\n    assert candidate('15.3') == 15\n\
  \    assert candidate('0') == 0\n\ndef test_check():\n    check(closest_integer)\n\
  \ntest_check()\n"
completions: ["    if not value.endswith('.0'):\n        value += '.0'\n\n    number\
    \ = int(value)\n    increment = 1\n\n    # Loop over integers larger than the\
    \ number we're trying to round away\n    # from zero (so long as it's an integer)\n\
    \    while increment * number <= abs(number):\n        number += increment\n \
    \       increment *= 10\n\n    # Round the number up to the nearest integer\n\
    \    difference = abs(number - int(number))\n    if difference != 0:\n       \
    \ number += 1\n        number //= 10\n\n    return number\n\n", "    integer_value\
    \ = int(value)\n    distance_from_zero = (integer_value - round(integer_value))\n\
    \n    if distance_from_zero > 0:\n        return integer_value\n    else:\n  \
    \      return round(integer_value, -1)\n\n", "    int_value = float(value)\n \
    \   delta_value = abs(int_value - int(int_value))\n\n    def f(value: float) ->\
    \ int:\n        return int(round(value + delta_value))\n\n    return f\n\n", " \
    \   int_value: int = int(value)\n    if value == int_value:\n        return int_value\n\
    \    \n    diff: int = (int_value - int(value)) * 0.5\n    if diff == 0:\n   \
    \     return int_value\n    elif diff > 0:\n        return int_value + int(diff)\n\
    \    else:\n        return int_value - int(diff)\n\n", "    return int(round(value))\n\
    \n", "    int_value = int(value)\n\n    def rounder(number) -> float:\n      \
    \  return round(number, 0)\n\n    # Check if value can be converted to an integer.\n\
    \    if int_value == value:\n        return int_value\n\n    # If the value is\
    \ negative, return negative integer closest to zero.\n    if int_value < 0:\n\
    \        return -closest_integer(str(abs(int_value)))\n\n    # If both numbers\
    \ equal zero, return zero.\n    if int_value == 0.0:\n        return 0.0\n\n \
    \   # If the value is positive, return the closest integer positive.\n    if int_value\
    \ > 0:\n        return rounder(int_value)\n\n    # If we are here, the value is\
    \ greater than the largest integer\n    # in the given range.\n    diff = abs(int_value\
    \ - int_value % 1)\n    return rounder(int_value + diff)\n\n\n@lru_cache(maxsize=16)",
  "    # Round values away from zero as appropriate:\n    return int(math.ceil(float(int(value))\
    \ - 0.5))\n\n", "    number = float(value)\n    integer = int(number)\n\n    if\
    \ number == float(number):\n        return integer\n\n    distances = []\n\n \
    \   if integer > 0:\n        distances.append(abs(integer - round(number)))\n\
    \    if integer < 0:\n        distances.append(abs(abs(integer) - round(number)))\n\
    \n    return distances.index(min(distances))\n\n", "    value_as_float = float(\n\
    \        re.sub(r'[^\\d]', '', value)\n    )  # remove non-digits and convert\
    \ value to float\n    value_as_float = math.floor(value_as_float)  # remove decimals\n\
    \    value_as_int = math.floor(value_as_float)\n    return value_as_int\n\n",
  "    try:\n        return int(value)\n    except ValueError:\n        pass\n   \
    \ lower, upper, guess = None, 0, None\n    for char in value:\n        if char.isdigit():\n\
    \            upper = lower + 1 if lower is not None else 1\n            guess\
    \ = (lower + upper) // 2\n        elif char == \"-\":\n            if lower is\
    \ None:\n                lower = guess\n            elif upper is None:\n    \
    \            upper = guess\n            else:\n                upper = guess +\
    \ 1\n        else:\n            lower = guess\n    return guess\n\n", "    decimal\
    \ = Decimal(value)\n    int_part = \".{}\".format(decimal)\n    float_part = decimal\n\
    \    if decimal.is_integer():\n        int_part = str(decimal)\n        float_part\
    \ = \".0\"\n\n    def func(value: str) -> int:\n        number = Decimal(value)\n\
    \        diff = abs(number - int_part)\n        return diff.quantize(Decimal(10)\
    \ ** -8)\n\n    return func\n\n", "    # pylint: disable=import-outside-toplevel\n\
    \    from math import ceil, floor\n\n    number = float(value)\n    if number\
    \ == 0.0:\n        return number\n    elif number < 0:\n        return -closest_integer(-number)\n\
    \    else:\n        return ceil(number)\n\n", "    integer = int(value)\n    delta\
    \ = abs(integer - int(value))\n    if delta == 0:\n        return integer\n  \
    \  else:\n        return int(round(integer + delta))\n\n", "    return abs(int(value))\n\
    \n", "    return round(int(value), 1)\n\n", "    def func(value: str) -> int:\n\
    \        val = float(value)\n        if val == 0:\n            raise ValueError(\"\
    Cannot return closest integer to zero\")\n        else:\n            return int(val)\n\
    \    return func\n\n", "    int_from_value = int(value)\n    def func(num: int)\
    \ -> int:\n        \"\"\"\n        Rounding away from zero means that if the given\
    \ number is equidistant\n        from two integers, the one you should return\
    \ is the one that is the\n        farthest from zero.\n        \"\"\"\n      \
    \  difference = abs(num - int_from_value)\n        if difference > 0:\n      \
    \      return num\n        elif difference == 0 and num > 0:\n            return\
    \ int_from_value\n        else:\n            return int_from_value + 1\n    return\
    \ func\n\n", "    try:\n        val = float(value)\n    except ValueError:\n \
    \       raise ValueError(f\"'{value}' is not a number.\")\n\n    def f(v):\n \
    \       v_to_float = float(v)\n        if v_to_float == v:\n            return\
    \ v\n\n        closest_value = 0\n        closest_diff = abs(v - v_to_float)\n\
    \n        for ii in range(1, int(math.log(v_to_float, 2)) + 1):\n            v_to_float_pow\
    \ = v_to_float ** ii\n            diff = abs(v - v_to_float_pow)\n\n         \
    \   if diff < closest_diff:\n                closest_value = v_to_float_pow\n\
    \                closest_diff = diff\n\n        return closest_value\n\n    return\
    \ f\n\n\n@attr.s(frozen=True)", "    try:\n        number = float(value)\n   \
    \ except ValueError:\n        raise ValueError(f\"Expected a numeric value but\
    \ instead got: {value}\")\n\n    int_value = int(number)\n    diffs = [abs(int_value\
    \ - i) for i in (int_value, int_value - 1, int_value + 1)]\n\n    if diffs ==\
    \ sorted(diffs):\n        return int_value\n    elif diffs:\n        return diffs[diffs.index(min(diffs))]\n\
    \    else:\n        raise ValueError(\n            \"Failed to find a closest\
    \ integer function to this value.\"\n            \" Try casting to an integer\
    \ first.\"\n        )\n\n", "    num = float(value)\n    if num == 0:\n      \
    \  raise ValueError(\"Cannot use 0 as closest integer.\")\n    if num < 0:\n \
    \       return -1 * closest_integer(-num)\n    else:\n        return int(num)\n\
    \n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
