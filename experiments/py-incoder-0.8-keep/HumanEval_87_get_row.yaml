name: HumanEval_87_get_row
language: py
prompt: "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int)\
  \ -> List[Tuple[int, int]]:\n    \"\"\"\n    You are given a 2 dimensional data,\
  \ as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
  \    each row may contain a different number of columns.\n    Given lst, and integer\
  \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
  \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
  \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
  \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
  \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n\
  \    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
  \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
  \    assert candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
  \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([[1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6],\
  \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
  \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([],\
  \ 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1],\
  \ [1, 2, 3]], 3) == [(2, 2)]\n\ndef test_check():\n    check(get_row)\n\ntest_check()\n"
completions: ["    results = []\n    for row in lst:\n        results.append((row[x],\
    \ _get_max(row)))\n        results.append((row[x], _get_min(row)))\n    results.sort(key=lambda\
    \ tup: (tup[1], tup[0]))\n    results.sort(key=lambda tup: (tup[1], tup[0]), reverse=True)\n\
    \    return results\n", "    row = [i for i in range(len(lst))]\n    row.sort(key\
    \ = lambda x: (x[0], -x[1]))\n    \n    if not lst:\n        return []\n    \n\
    \    \n    coords = []\n    \n    coord_index = 0\n    \n    for row in row:\n\
    \        \n        col = lst[row][x] \n        \n        coords.append((row, col))\n\
    \        \n        lst[row].remove(lst[row][col])\n        lst[row].insert(col,\
    \ x)\n        lst[row].sort(key = lambda x: (x[0], -x[1]))\n        lst[row].sort(key\
    \ = lambda x: (x[1], x[0]))\n        \n    return coords\n\n", "    \n    lst\
    \ = sorted(lst, key=lambda x:x[0])\n    lst.sort(key=lambda x:x[0], reverse=True)\n\
    \    \n    lst = [(x-1, y-1) for x, y in lst]\n    \n    if x not in lst:\n  \
    \      return lst \n    \n    for idx, coord in enumerate(lst):\n        if coord[0]\
    \ == x:\n            return [(coord[0], coord[1])] + lst[idx+1:]\n    return []\n\
    \    \n", "    \n    # Your code here\n    \n    return [(i, j) for i, row in\
    \ enumerate(lst) for j, val in enumerate(row) if x == val]\n    \n    ", "   \
    \ row, columns = len(lst), len(lst[0]) if lst else 0\n    \n    def col_gen():\n\
    \        yield 0\n        yield columns\n        for row in range(rows-2):\n \
    \           for col in range(columns):\n                if row == rows - 1 and\
    \ col != columns:\n                    yield col\n                else:\n    \
    \                yield col + 1\n    \n    col = col_gen()\n    \n    def row_gen():\n\
    \        for row in range(rows):\n            yield row + 1, next(col)\n    \n\
    \    row, _ = next(row_gen())\n    \n    return [(row-1, col) for _ in range(x)]\n\
    </cell>\n<text>\nTests\n\n</text>\n<cell>\nget_row([], 1) == []\nassert get_row([],\
    \ 1) == []\nassert get_row([1], 1) == [(1,1)]\nassert get_row([1,2,3], 2) == [(1,0),\
    \ (2,1)]\nassert get_row([1,2,3,4,5,6], 2) == [(1,0), (1,3), (2,0), (2,1), (3,0),\
    \ (3,1)]\nassert get_row([1,2,3,4,5,6], 3) == [(1,0), (1,3), (1,2), (1,1), (1,0),\
    \ (2,2), (2,1), (2,0), (2,0), (3,1), (3,0), (3,0), (3,1), (3,0)]\nassert get_row([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\
    \ 2) == [(1,0), (1,3), (2,0), (2,1), (3,0), (3,1), (4,0), (4,1), (5,0), (5,1),\
    \ (6,0), (6,1), (7,0), (7,1), (8,0), (8,1), (9,0), (9,1), (10,0), (10,1), (11,0),\
    \ (11,1), (12,0), (12,1), (13,0), (13,1), (14,0), (14,1), (15,0), (15,1), (16,0),\
    \ (16,1), (17,0), (17,1), (18,0), (18,1), (19,0), (19,1)]\nassert get_row([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\
    \ 3) == [(1,0), (1,3), (1,2), (1,1), (1,0), (2,2), (2,1), (2,0), (2,0), (2,1),\
    \ (3,0), (3,1), (3,0), (3,0), (3,1), (3,0), (3,0), (3,0), (3,0), (3,0), (3,0),\
    \ (3,0), (3,0), (3,0), (3,0), (3,0), (3,0)]\nassert get_row([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\
    \ 10) == [(1,0), (1,3), (1,2), (1,1), (1,0), (2,2), (2,1), (2,0), (2,0), (2,1),\
    \ (3,0), (3,1), (3,0), (3,0), (3,1), (3,0), (3,0), (3,0), (3,0), (3,0), (3,0),\
    \ (3,0), (3,0), (3,0), (3,0), (3,0), (3,", "    \n    lst = sorted(lst, key=lambda\
    \ l: l.index(x))\n    \n    lst2 = []\n    \n    for i, row in enumerate(lst):\n\
    \        lst2.append((i, max(row, key=lambda x: -x.index(x))))\n        \n   \
    \ lst2.sort(key=lambda c: (-c[1], c[0]))\n    \n    return lst2\n</cell>\n<cell>\n\
    get_row([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n], 1)\n\
    </cell>\n<text>\nQ. Given a list of integers, return a new list such that each\
    \ element of the new list is calculated from every two adjacent elements in the\
    \ original list. Calculate this new list without using loops.\n    For example,\
    \ given [1,2,3,4,5,6], return [2,3,5,7,10].\n\n\n</text>\n<cell>", "    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    # write your code in\
    \ Python 3.6\n    \n    # initialize variables\n    coords = []\n    rows = 0\n\
    \    cols = 0\n    \n    # check if input is empty\n    if lst:\n        for row\
    \ in lst:\n            rows += 1\n            cols = max(cols, len(row))\n   \
    \ \n    # check if x is an integer\n    if type(x) != int:\n        raise TypeError(f'Expected\
    \ int, received {type(x)}')\n    \n    # iterate through input list to check for\
    \ x\n    for row in lst:\n        if x in row:\n            coords.append((rows,\
    \ cols))\n            coords = sorted(coords, key=lambda coord: coord[0]) # sort\
    \ by rows\n            coords = sorted(coords, key=lambda coord: coord[1], reverse=True)\
    \ # sort by cols\n            break\n            \n    return coords\n", "   \
    \ if lst == []:\n        return [(i, 0) for i in range(x)]\n    if x == 0 or len(lst[x-1])\
    \ != len(lst):\n        return []\n    \n    if x % 2 != 0:\n        lst.sort(key=lambda\
    \ lst: lst[x-1])\n        lst.sort(reverse=True, key=lambda lst: lst[x-1])\n \
    \   else:\n        lst.sort(key=lambda lst: lst[x-1])\n    \n    result = []\n\
    \    lst = sorted(lst, key=lambda x: x[x-1])\n    for i in range(len(lst)):\n\
    \        result.append((i, lst[i][x-1]))\n    return result\n\n", "    # TODO:\
    \ Write your code here\n    # sort in descending order by columns\n    # sort\
    \ by rows\n    # sort by rows and columns\n    pass\n", "    row = [0] * len(lst)\n\
    \    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n       \
    \     if lst[i][j] == x:\n                row[i] = [j, i]\n                break\n\
    \    row = sorted(row, key=lambda v: v[1], reverse=True)\n    row = sorted(row,\
    \ key=lambda v: v[0])\n    return row\n", "    if lst:\n        row = [lst[i][0]\
    \ for i in range(len(lst))]\n        row.sort(reverse = True)\n        col = [lst[i][1]\
    \ for i in range(len(lst))]\n        col.sort()\n        return [(row[i], col[i])\
    \ for i in range(len(lst)) if col[i] == x]\n    else:\n        return []\n", " \
    \   \n    #initialize output\n    output = []\n\n    # iterate through each row\n\
    \    for row in lst:\n        # sort the row by columns in descending order\n\
    \        row_sorted = sorted(row, key=lambda x: x[::-1])\n\n        # iterate\
    \ through each column of the row\n        for column in row_sorted:\n        \
    \    # if the column is at x, then append a tuple to output\n            if column\
    \ == x:\n                # add the coordinates of the tuple to the output\n  \
    \              output.append((row, column))\n\n    # sort output by rows in ascending\
    \ order\n    return sorted(output, key=lambda x: x[0])\n", "    \n    # Sort the\
    \ list by the first element in each row\n    lst = sorted(lst, key=lambda lst:\
    \ lst[0])\n    # Sort the list by the last element in each row\n    lst = sorted(lst,\
    \ key=lambda lst: lst[-1])\n    # Sort the list by the first element in each row\n\
    \    lst = sorted(lst, key=lambda lst: lst[0])\n\n    # sort by rows in ascending\
    \ order\n    lst = sorted(lst, key=lambda lst: lst[0])\n    # sort by columns\
    \ in descending order\n    lst = sorted(lst, key=lambda lst: lst[-1])\n    \n\
    \    # Find the right row index\n    row = -1 \n    for i in range(len(lst)):\n\
    \        row = i\n        if lst[i][0] == x:\n            break\n        \n  \
    \  # return the list of tuples\n    return [(row + i, j) for (i, j) in lst]\n\
    </cell>\n<cell>", "    row, col, vals = len(lst), len(lst[0]), 0\n    sorted_lst\
    \ = sorted(lst, key=lambda x: (x[0], -x[1]))\n    \n    for row in range(len(sorted_lst)):\n\
    \        for col in range(len(sorted_lst[0])):\n            if sorted_lst[row][col]\
    \ == x:\n                vals = col + col\n                return [(x+1, y+1)\
    \ for x in range(row+1)]\n            elif vals == col:\n                return\
    \ [(x+1, y+1) for x in range(row+1)]\n            elif vals < col:\n         \
    \       row += 1\n                vals = col\n                col = 0\n      \
    \      col += 1\n", "    def helper(lst: List[List[int]], x: int) -> List[Tuple[int,\
    \ int]]:\n        ans = []\n        for i in range(len(lst)):\n            for\
    \ j in range(len(lst[i])):\n                if x == lst[i][j]:\n             \
    \       ans.append((i, j, x))\n        ans.sort(key=lambda tup: tup[2])\n    \
    \    ans.sort(key=lambda tup: tup[0], reverse=True)\n        return ans\n    \n\
    \    if not lst:\n        return []\n    \n    ans = helper(lst, x)\n    \n  \
    \  if not ans:\n        return ans \n        \n    ans.sort(key=lambda tup: tup[0],\
    \ reverse=True)\n    \n    ans.sort(key=lambda tup: tup[2], reverse=True)\n  \
    \  \n    return ans\n\n", "    \n    len_list = len(lst)\n    \n    # Handle edge\
    \ case\n    if len_list == 0:\n        return [(0,0)]\n    elif len_list == 1:\n\
    \        row = [x] if x == lst[0][0] else []\n        col = [x] if x == lst[0][0]\
    \ else []\n        return [(x, x) for x in range(0, len(col))]\n    \n    # Handle\
    \ edge case\n    if x > lst[0][-1]:\n        return get_row(lst[1:], x)\n    elif\
    \ x == lst[0][-1]:\n        return [(lst[0][0], x)]\n    \n    # Iterate through\
    \ all list items, adding new coordinate if needed\n    new_coords = []\n    \n\
    \    for x in range(0, len(lst[0])):\n        if x == lst[0][x]:\n           \
    \ row = x\n            col = lst[1][x]\n        else:\n            row = lst[0][x]\n\
    \            col = lst[1][x]\n        \n        new_coords.append((row, col))\n\
    \    \n    return sorted(new_coords, key=lambda tup: tup[0], reverse=True)\n\n",
  "    \n    def helper(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n\
    \        if not lst: return []\n        \n        coordinates: List[Tuple[int,\
    \ int]] = []\n        row = lst[0]\n        \n        if len(lst) > 1:\n     \
    \       for i in range(1, len(lst)):\n                row_copy = row.copy()\n\
    \                row_copy.sort()\n                column_copy = row_copy[::-1]\n\
    \                coordinates.append((row_copy[i], column_copy[i]))\n         \
    \       \n        coordinates.append((row, row))\n        return coordinates\n\
    \    \n    return helper(lst, x)\n", "    # your code here\n    lst=sorted(lst,key=lambda\
    \ x:x[0])\n    lst2=sorted(lst,key=lambda x:x[-1],reverse=True)\n    return [(i,j)\
    \ for i,j in zip(lst,lst2)]\n\nprint(get_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n\
    \  [1,2,3,4,5,1]\n], 1))\n\nprint(get_row([], 1))\n\nprint(get_row([[], [1], [1,\
    \ 2, 3]], 3))\n", "    \n    if x not in lst:\n        return []\n    \n    row\
    \ = 0\n    col = len(lst[0]) - 1\n    \n    # sort by rows in ascending order\n\
    \    sort_func = {\n        0: lambda x: x,\n        1: lambda x: -x\n    }\n\
    \    \n    # sort by columns in descending order\n    sort_func_column = {\n \
    \       0: lambda x: -x,\n        1: lambda x: x\n    }\n    \n    while True:\n\
    \        \n        if row >= len(lst):\n            break\n        \n        #\
    \ check if x is on the top row\n        if x not in lst[row]:\n            row\
    \ += 1\n            continue\n        \n        if row == 0:\n            return\
    \ []\n        \n        # sort by the value of each cell in each row by the column\
    \ index\n        lst = sorted(lst[row], key=sort_func[col])\n        \n      \
    \  # sort by the value of each cell in each row by the column index\n        lst\
    \ = sorted(lst, key=sort_func_column[col])\n        \n        # update row and\
    \ col\n        row += 1\n        col -= 1\n        \n    \n    return [(x, y)\
    \ for y in range(len(lst)) for x in lst]\n    \n    \nlst = get_row([\n    [1,2,3,4,5,6],\n\
    \    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n], 1)\nprint(lst)\nprint(get_row([], 1))\n\
    print(get_row([[], [1], [1, 2, 3]], 3))\n</cell>\n<text>\n11. Given two strings\
    \ str1 and str2, return True if they are anagrams of each other.\nIf either str1\
    \ or str2 is None, return False.\nFor example str1=\"abc\" and str2=\"cba\" return\
    \ True.\n\n\n</text>\n<cell>"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
