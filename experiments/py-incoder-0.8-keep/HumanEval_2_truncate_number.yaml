name: HumanEval_2_truncate_number
language: py
prompt: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
  \ floating point number, it can be decomposed into\n    and integer part (largest\
  \ integer smaller than given number) and decimals\n    (leftover part always smaller\
  \ than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
  \    0.5\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
  \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
  \ntest_check()\n"
completions: ["    return float(number) - int(number)\n\n", "    if number == int(number):\n\
    \        return int(number)\n    elif number % 1:\n        return number\n   \
    \ return int(number) - 1\n\n", "    if number == 0:\n        return 0\n    else:\n\
    \        integer, decimal = math.modf(number)\n        decimal = int(decimal)\n\
    \        return number - decimal\n", "    integer, decimal = math.modf(number)\n\
    \    return decimal\n\n", "    return number - int(number) if number < 0 else\
    \ number\n\n", "    if number < 1.0:\n        raise ValueError(\"Cannot truncate\
    \ number below 1.0: {}\".format(number))\n    remaining_number = number - int(number)\n\
    \    decimals = remaining_number - int(remaining_number)\n    return decimals\n\
    \n", "    return math.trunc(number * 100) / 100\n\n", "    return number - math.ceil(number)\
    \ if number > 0 else math.floor(number)\n\n", "    integer = int(number)\n   \
    \ decimal = int(number - integer)\n    if decimal == 0:\n        return integer\n\
    \    return number - integer - decimal\n\n", "    return math.floor(number) if\
    \ number > 0 else math.ceil(number)\n", "    return number - (number * int(number\
    \ % 1))\n", "    number = float(number)\n    decimal_part = int(number)\n    if\
    \ decimal_part < 1:\n        return number\n\n    integer_part = number - decimal_part\n\
    \    integer_part = round(integer_part)\n    return float(str(integer_part) +\
    \ '.' + str(decimal_part))\n\n", "    return number - int(number)\n\n", "    if\
    \ number < 1.0:\n        return number\n    factor = 10.0\n    while number %\
    \ factor > 0:\n        factor = factor * 10\n    return number / factor\n\n",
  "    precision = number.as_tuple().exponent\n    if precision > 0:\n        precision\
    \ += 1\n        number = round(number, precision)\n    return number\n\n", " \
    \   if not (-1.0 < number < 1.0):\n        raise ValueError(\"The provided number\
    \ %f is not positive.\" % number)\n    if number == int(number):\n        return\
    \ float(number)\n    if number % 1:\n        raise ValueError(\"The provided number\
    \ %f cannot be decomposed into integers.\" % number)\n    exponent = int(math.ceil(math.log10(number)))\n\
    \    number = number - round(number * pow(10, -exponent))\n    decimals = pow(10,\
    \ exponent)\n    return number * decimals\n\n", "    int_part = int(number)\n\
    \    decimal_part = number - int_part\n    if decimal_part >= 0.0 and isinstance(decimal_part,\
    \ float):\n        decimal_part = math.trunc(decimal_part)\n    return decimal_part\n\
    \n", "    return number - int(number * Decimal('0.000000001'))\n\n", "    int_part\
    \ = int(number)\n    remainder = number - int_part\n    return remainder if remainder\
    \ >= 1.0 else 0.0\n\n", "    int_part = int(number)\n    if number - int_part\
    \ < EPSILON:\n        return number\n    decimal_part = number - int_part\n  \
    \  decimal_part = math.ceil(decimal_part * 10**(decimal_part*-1))\n    return\
    \ int_part + decimal_part\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
