name: HumanEval_20_find_closest_elements
language: py
prompt: "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float])\
  \ -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length\
  \ at least two) select and return two that are the closest to each\n    other and\
  \ return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
  \ == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n\
  \    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert\
  \ candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1,\
  \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\ndef test_check():\n    check(find_closest_elements)\n\
  \ntest_check()\n"
completions: ["    smallest = numbers[0]\n    largest = numbers[-1]\n    smallest_index\
    \ = 0\n    largest_index = len(numbers) - 1\n    \n    while smallest_index !=\
    \ largest_index:\n        index_of_smallest = smallest_index\n        index_of_largest\
    \ = largest_index\n        \n        if index_of_smallest < index_of_largest:\n\
    \            largest = numbers[index_of_largest]\n            largest_index =\
    \ largest_index - 1\n            index_of_largest = largest_index\n        else:\
    \ \n            smallest = numbers[index_of_smallest]\n            smallest_index\
    \ = smallest_index + 1\n            index_of_smallest = smallest_index\n    \n\
    \    return smallest, largest\n", "    differences = []\n    for n in numbers:\n\
    \        differences.append(abs(n - numbers[0]))\n\n    closest_to_smallest =\
    \ min(differences)\n    closest_to_largest = max(differences)\n    return closest_to_smallest,\
    \ closest_to_largest\n\n", "    # Find the smallest number\n    smallest_number\
    \ = min(numbers)\n    # Find the largest number\n    largest_number = max(numbers)\n\
    \    # Find the number that is closest\n    closest_number = smallest_number\n\
    \    closest_number_distance = None\n    for number in numbers:\n        distance\
    \ = abs(number - closest_number)\n        if closest_number_distance is None or\
    \ distance < closest_number_distance:\n            closest_number_distance = distance\n\
    \            closest_number = number\n    return closest_number, closest_number_distance\n",
  "    smallest = numbers[0]\n    largest = numbers[0]\n    for i in range(len(numbers)):\n\
    \        if numbers[i] > largest:\n            largest = numbers[i]\n        elif\
    \ numbers[i] < smallest:\n            smallest = numbers[i]\n    return (smallest,\
    \ largest)\n", "    return min(numbers, key=lambda x:abs(x-numbers[0])), max(numbers,\
    \ key=lambda x:abs(x-numbers[0]))\n\n", "    closest_elements = [min(numbers),\
    \ max(numbers)]\n    smallest_distance = closest_elements[0] - closest_elements[1]\n\
    \    larger_distance = closest_elements[1] - closest_elements[0]\n    if smallest_distance\
    \ < larger_distance:\n        return closest_elements, smallest_distance\n   \
    \ else:\n        return closest_elements, larger_distance\n", "    smallest: float\
    \ = numbers[0]\n    largest: float = numbers[-1]\n    # If the list is empty,\
    \ return no results\n    if len(numbers) == 0:\n        return None, None\n  \
    \  # If the list is one number or less, return it as the closest\n    if len(numbers)\
    \ <= 1:\n        return numbers[0], numbers[0]\n    for i in range(len(numbers)):\n\
    \        if numbers[i] < smallest:\n            smallest = numbers[i]\n      \
    \  if numbers[i] > largest:\n            largest = numbers[i]\n    return smallest,\
    \ largest\n\n", "    return min(enumerate(numbers), key=lambda t: abs(t[1] - t[0]))\n",
  "    smallest_distance = None\n    smallest_number = None\n    largest_distance\
    \ = None\n    largest_number = None\n    for number in numbers:\n        distance_to_smallest\
    \ = abs(number - smallest_number)\n        if smallest_distance is None or distance_to_smallest\
    \ < smallest_distance:\n            smallest_number = number\n            smallest_distance\
    \ = distance_to_smallest\n        distance_to_largest = abs(number - largest_number)\n\
    \        if largest_distance is None or distance_to_largest < largest_distance:\n\
    \            largest_number = number\n            largest_distance = distance_to_largest\n\
    \    return smallest_number, largest_number\n", "    numbers.sort()\n    return\
    \ numbers[round(len(numbers) * (numbers[0] - numbers[1]) / (1.0 * (numbers[-1]\
    \ - numbers[-2])))], numbers[round(len(numbers) * (numbers[-1] - numbers[-2])\
    \ / (1.0 * (numbers[0] - numbers[1])))]\n", "    assert len(numbers) >= 2, 'The\
    \ list must have at least two elements before finding the closest elements.'\n\
    \    return min(numbers), max(numbers)\n", "    if len(numbers) < 2:\n       \
    \ raise ValueError(f\"List must have at least two elements, found {len(numbers)}\"\
    )\n    if len(numbers) == 2:\n        return numbers[0], numbers[1]\n    \n  \
    \  numbers = sorted(numbers)\n    \n    minimum = numbers[0]\n    maximum = numbers[1]\n\
    \    \n    for number in numbers[2:]:\n        if minimum > number:\n        \
    \    minimum = number\n        elif maximum < number:\n            maximum = number\n\
    \    \n    return minimum, maximum\n    \n    ", "    \n    if len(numbers) <\
    \ 2:\n        raise ValueError(\"Must supply at least two numbers\")\n    \n \
    \   # Find the smallest number and largest number in our list\n    smallest_number\
    \ = min(numbers)\n    largest_number = max(numbers)\n    \n    # Find the middle\
    \ point between the two numbers\n    middle_number = (smallest_number + largest_number)\
    \ / 2\n    \n    # Create a list that is as long as our original list\n    middle_number_list\
    \ = [0] * len(numbers)\n    \n    # Fill our new list with the middle number\n\
    \    middle_number_list[len(numbers) // 2] = middle_number\n    \n    # Fill the\
    \ first and last number with the smallest and largest numbers\n    middle_number_list[0]\
    \ = smallest_number\n    middle_number_list[len(numbers) -1] = largest_number\n\
    \    \n    # Sort the middle number list\n    middle_number_list.sort()\n    \n\
    \    # Calculate the difference between the middle number and the middle numbers\n\
    \    difference = abs(middle_number - middle_number_list[len(numbers) //2])\n\
    \    \n    # Return the two numbers that are closest to the middle number\n  \
    \  return middle_number_list[0], middle_number_list[len(numbers)-1], difference\n",
  "    return min(numbers), max(numbers)\n", "    if numbers:\n        smallest =\
    \ numbers[0]\n        largest = numbers[0]\n        closest_pair = (smallest,\
    \ largest)\n        smallest_distance = largest_distance = 0\n        smallest_index,\
    \ largest_index = 0, 0\n\n        for number in numbers:\n            if number\
    \ < smallest:\n                smallest_index = smallest\n                smallest\
    \ = number\n            elif number > largest:\n                largest_index\
    \ = largest\n                largest = number\n            elif smallest_distance\
    \ == 0:\n                smallest_distance = number\n                closest_pair\
    \ = (smallest, largest)\n            elif number == closest_pair[0] and number\
    \ < closest_pair[1]:\n                smallest_distance = number\n           \
    \     closest_pair = (smallest, largest)\n            elif number == closest_pair[1]\
    \ and number > closest_pair[0]:\n                largest_distance = number\n \
    \               closest_pair = (smallest, largest)\n            else:\n      \
    \          smallest_distance = number\n                largest_distance = number\n\
    \        smallest_index += 1\n        largest_index += 1\n        if smallest_distance\
    \ == largest_distance:\n            smallest_distance += 1\n        return (closest_pair[0],\
    \ closest_pair[1])\n    else:\n        return (None, None)\n\n", "    smallest\
    \ = numbers[0]\n    largest_index = 0\n\n    for index, number in enumerate(numbers):\n\
    \        if number > smallest:\n            if index > largest_index:\n      \
    \          largest_index = index\n                smallest = number\n        \
    \    elif index <= largest_index:\n                smallest = number\n\n    if\
    \ smallest != numbers[-1]:\n        smallest = numbers[-1]\n        largest_index\
    \ = len(numbers) - 1\n\n    return smallest, numbers[largest_index]\n\n", "  \
    \  # Your code here\n    min_diff = numbers[0]\n    min_idx = 1\n    for i in\
    \ range(1, len(numbers)):\n        diff = abs(numbers[i] - numbers[min_idx])\n\
    \        if diff < min_diff:\n            min_diff = diff\n            min_idx\
    \ = i\n    return numbers[min_idx], numbers[min_idx+1]\n</cell>\n<cell>\nprint(find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]))\nprint(find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0]))\n</cell>\n<text>\nQuestion 4\nWrite a function that takes in a list\
    \ of numbers and returns a new list containing the same numbers but reordered\n\
    in ascending order.\n\n>>> reorder_numbers([1, 2, 3, 4, 5, 6])\n[1, 2, 3, 4, 5,\
    \ 6]\n\n</text>\n<cell>", "    if len(numbers) <= 1:\n        raise ValueError('List\
    \ of numbers should contain at least 2 elements')\n\n    difference = [abs(numbers[i]\
    \ - numbers[i - 1]) for i in range(1, len(numbers))]\n    return numbers[difference.index(min(difference))]\n",
  "    assert numbers, \"Supplied list is empty\"\n    assert min(numbers) <= max(numbers),\
    \ f\"List of numbers must be sorted. First number is {min(numbers)}, last is {max(numbers)}\"\
    \n\n    # Return first two numbers that are closest to each other\n    closest_nums\
    \ = []\n    closest_dists = []\n\n    for num in numbers:\n        closest_num,\
    \ closest_dist = smallest_difference(num, numbers)\n        closest_nums.append(closest_num)\n\
    \        closest_dists.append(closest_dist)\n    \n    closest_nums = zip(closest_nums[0::2],\
    \ closest_nums[1::2])\n    closest_dists = zip(closest_dists[0::2], closest_dists[1::2])\n\
    \    \n    return sorted(closest_nums, key=lambda tup: tup[1])\n", "    min_difference\
    \ = float(\"inf\")\n    closest_number = None\n    closest_element = float(\"\
    inf\")\n\n    for num in numbers:\n        difference = abs(num - closest_number)\n\
    \n        if difference < min_difference:\n            closest_number = num\n\
    \            closest_element = num\n            min_difference = difference\n\
    \        elif difference == min_difference:\n            closest_element = num\n\
    \            closest_number = num\n\n    return (closest_number, closest_element)\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
