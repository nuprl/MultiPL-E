name: HumanEval_120_maximum
language: py
prompt: "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n\
  \    \"\"\"\n    Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n\
  \    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\
  \n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n     \
  \   Output: [2]\n\n    Note:\n        1. The length of the array will be in the\
  \ range of [1, 1000].\n        2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n\
  \    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1,\
  \ 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0, 1, 2, -3], 3)\
  \ == [2, 20, 123]\n    assert candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3,\
  \ 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1,\
  \ 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert\
  \ candidate([-10, 10], 2) == [-10, 10]\n    assert candidate([1, 2, 3, -23, 243,\
  \ -400, 0], 0) == []\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n"
completions: ["    pass\n</cell>\n<cell>", "    if len(arr) == 0:\n        return\
    \ []\n\n    # Step 1: Divide arr into 2 subarrays smaller than or equal to k\n\
    \    sub_max_list = [arr[:k]]\n    sub_min_list = [arr[k:]]\n\n    # Step 2: Repeat\
    \ Step 1 for all subarrays of arr\n    while len(sub_max_list) > 0 and len(sub_min_list)\
    \ > 0:\n        sub_max_max_list = []\n        sub_max_min_list = []\n       \
    \ sub_min_max_list = []\n        sub_min_min_list = []\n\n        # Step 3: Get\
    \ maximums from sub_max_list and sub_min_list\n        if len(sub_max_list) >\
    \ 0:\n            max_idx = sub_max_list[0]\n            sub_max_list = sub_max_list[1:]\n\
    \            max_elem = max_idx[0]\n            max_sub_max_list = sub_max_max_list\
    \ + [max_elem]\n            max_sub_min_list = sub_max_min_list + [max_elem]\n\
    \        else:\n            max_sub_max_list = []\n            max_sub_min_list\
    \ = []\n\n        if len(sub_min_list) > 0:\n            min_idx = sub_min_list[0]\n\
    \            sub_min_list = sub_min_list[1:]\n            min_elem = min_idx[0]\n\
    \            min_sub_max_list = sub_min_max_list + [min_elem]\n            min_sub_min_list\
    \ = sub_min_min_list + [min_elem]\n        else:\n            min_sub_max_list\
    \ = []\n            min_sub_min_list = []\n\n        # Step 4: Get maximums from\
    \ sub_max_max_list and sub_max_min_list\n        if len(sub_max_max_list) > 0:\n\
    \            max_idx = sub_max_max_list[0]\n            sub_max_max_list = sub_max_max_list[1:]\n\
    \            max_elem = max_idx[0]\n            max_sub_max_max_list = max_sub_max_list\
    \ + [max_elem]\n        else:\n            max_sub_max_max_list = []\n\n     \
    \   if len(sub_max_min_list) > 0:\n            min_idx = sub_max_min_list[0]\n\
    \            sub_max_min_list = sub_max_min_list[1:]\n            min_elem = min_idx[0]\n\
    \            min_sub_max_min_list = min_sub_max_list + [min_elem]\n        else:\n\
    \            min_sub_max_min_list = []\n\n        # Step 5: Get minimums from\
    \ sub_min_max_list and sub_min_min_list\n        if len(sub_min_max_list) > 0:\n\
    \            min_idx = sub_min_max_list[0]\n            sub_min_max_list = sub_min_max_list[1:]\n\
    \            min_elem = min_idx[0]\n            min_sub_min_max_list = min_sub_min_list\
    \ + [min_elem]\n        else:\n            min_sub_min_max_list = []\n\n     \
    \   # Step 6: Get maximums from sub_max_min_list and sub_min_max_list\n      \
    \  if len(sub_max_min_max_list) > 0:\n            max_idx = sub_max_min_max_list[0]\n\
    \            sub_max_min_max_list = sub_max_min_max_list[1:]\n            max_elem\
    \ = max_idx[0]\n            max_sub_max_min_max_list = max_sub_max_min_list +\
    \ [max_elem]\n        else:\n            max_sub_max_min_max_list = []\n\n", " \
    \   if k > len(arr):\n        raise Exception(\"Invalid k!\")\n    elif k == 0:\n\
    \        return [arr[0]]\n    else:\n        length = len(arr)\n        mid =\
    \ length // 2 \n\n        left = maximum(arr[:mid], k - 1) \n        right = maximum(arr[mid:],\
    \ k) \n        \n        if len(left) + len(right) < k:\n            left, right\
    \ = right, left\n        \n        sorted_left = sorted(left)\n        sorted_right\
    \ = sorted(right)\n        \n        result = sorted_left + sorted_right\n   \
    \     \n        if result != arr:\n            return result\n        else:\n\
    \            return arr\n\n", "    if not arr or k <= 0 or k >= len(arr):\n  \
    \      return []\n    res = []\n    max = arr[0]\n    for i in range(1, len(arr)):\n\
    \        if arr[i] > max:\n            res = []\n            max = arr[i]\n  \
    \      res.append(arr[i])\n    if k == 1:\n        return res\n    else:\n   \
    \     return sorted(res)[:k]\n    ", "    return sorted(arr)[-k:]\n</cell>\n<cell>",
  "    pass\n", "    if k > len(arr):\n        return None\n    arr = sorted(arr)\n\
    \    maximum_list = list(filter(lambda x: x > k, arr))\n    return maximum_list\n",
  "    pass\n\n", "    pass\n", "    if k >= len(arr):\n        return []\n    if\
    \ k == 0:\n        return arr[:]\n    if k == 1:\n        return sorted(arr[:])\n\
    \    i = j = 0\n    while i < len(arr):\n        if arr[i] < arr[j]:\n       \
    \     arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n            j += 1\n\
    \        elif arr[i] > arr[j]:\n            j += 1\n        else:\n          \
    \  i += 1\n    return arr[:k]\n", "    if k > len(arr):\n        return arr\n\
    \    else:\n        heapq.heapify(arr)\n        while len(arr) > k:\n        \
    \    heapq.heappop(arr)\n        return arr\n", "    # sort arr using quicksort\
    \ to get max k numbers\n    if k == 1:\n        return arr\n    quicksort_arr\
    \ = quick_sort(arr)\n\n    # find max k numbers in quicksort arr\n    max_k_numbers\
    \ = maximum_in_list(quicksort_arr, 0, len(quicksort_arr))\n    return max_k_numbers\n\
    \n", "    return sorted(arr, key=lambda x: x) if k <= len(arr) else arr[:k]\n",
  "    # write your code here\n\n    res=list(arr)\n    res.sort(reverse=True) \n\
    \    res.reverse()\n    if len(res)<k:\n        return res\n    res.append(res[0])\n\
    \    return res[:k]\n        \n\"\"\"\nNote:\n    A simple but inefficient solution\
    \ would consist of a linear search\n    through the array and a copy of the subarray\
    \ starting at index 0. \n    Let's think about it for a minute.\n\n    Let's say\
    \ that you've already sorted the array. How could we be sure\n    that all possible\
    \ subarrays have at least k elements?\n\n    Well, if we have sorted the array,\
    \ the largest index we'll ever see \n    is arr[-1]. So the problem reduces to:\
    \ Given a sorted array, \n    find the maximum subarray whose length is at least\
    \ k.\n\n    Let's say we have the subarray [2, 4, 6]. What's the longest subarray\n\
    \    whose length is at least k? It has length 2! To compute the answer, \n  \
    \  we'd have to have seen all possible subarrays of length 2, \n    all of length\
    \ 4, and all of length 6. But in order to do that, we\n    would have to search\
    \ through all possible subarrays of length 3, \n    all possible subarrays of\
    \ length 4, and all possible subarrays of length 6.\n    So this is an exponential\
    \ algorithm.\n\n    How could we speed this up? One way is to maintain a table\
    \ of \n    previously seen subarrays. But we don't actually need to store all\
    \ \n    the subarrays. We'll be given only two subarrays, and can compute the\
    \ \n    answer without ever needing to see all subarrays. So we can \n    maintain\
    \ a table with the largest subarray seen so far, the smallest \n    subarray seen\
    \ so far, the length of the current largest subarray, and \n    the length of\
    \ the current smallest subarray. The answer is simply the \n    maximum among\
    \ all subarrays of length equal to the length of the current \n    largest subarray.\n\
    \n    Let's see an example. Let's say we have already computed the answer\n  \
    \  for all subarrays of length 4 and the subarrays of length 5. We'll \n    store\
    \ this information in a tuple as follows:\n\n    max_so_far = (4, 6, 6, 4)\n \
    \   min_so_far = (-4, -4, -4, -4)\n    largest_so_far = 6, 6, 6, 6\n    smallest_so_far\
    \ = 4, 4, 4, 4\n\n    Now we just need to find the largest subarray which still\
    \ has length \n    greater than or equal to the length of the current smallest\n\
    \    subarray. \n\"\"\"\n\n", "    # \u65B9\u6CD5\u4E00\uFF1A\u76F4\u63A5\u6392\
    \u5E8F\uFF0CO(n*logn)\n    heap = PriorityQueue(maxlen=k)\n    heap.extend([x\
    \ for x in arr if x < 0])\n\n    return [heap.max() for _ in range(k)]\n", " \
    \   maximum = []\n    max_index = -1\n\n    for i in range(k):\n        max_value\
    \ = max(arr)\n\n        if max_value == max_index:\n            maximum.append(max_value)\n\
    \        elif max_value not in arr:\n            maximum.append(max_value)\n\n\
    \    return maximum\n", "    \n    # write your code here\n    max_list = [arr[0]]\n\
    \    max_list_len = len(arr)\n    for i in range(0, max_list_len-1):\n       \
    \ if arr[i] > max_list[-1]:\n            max_list.append(arr[i])\n           \
    \ \n            \n    return max_list\n", "    pass\n", "    arr = sorted(arr)\n\
    \    ans = []\n    while len(arr) > k:\n        ans.append(arr.pop())\n    return\
    \ ans\n", "    max_num = arr[0]\n    cur_max = 1\n    cur_num = 0\n    \n    for\
    \ num in arr:\n        if num > max_num:\n            max_num = num\n        \
    \    cur_max = 1\n            cur_num = 1\n        elif num == max_num:\n    \
    \        cur_num += 1\n        else:\n            if cur_num > k:\n          \
    \      return [max_num] * (k - cur_num)\n            else:\n                max_num\
    \ = num\n                cur_num += 1\n\n    return [max_num] * cur_num\n\n",
  "    \n    if k <= 0 or k >= len(arr):\n        return []\n    \n    res = sorted(arr)\n\
    \    res.reverse()\n    res.insert(k, arr.pop())\n    res.sort()\n    res.reverse()\n\
    \    return res\n", "    pass\n\n", "    if not arr or not k:\n        return\
    \ []\n\n    ans, max_num = [], None\n\n    for i in range(k):\n        if not\
    \ arr or not max_num:\n            return ans\n\n        if arr[0] < max_num:\n\
    \            ans.append(arr[0])\n            arr.pop(0)\n        else:\n     \
    \       ans.append(max_num)\n            max_num = None\n\n    return ans\n",
  "    return sorted(arr, key=lambda x: (-x, x))[k:]\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nHow did you decide the key function? Please include your reasoning.\n\
    <|/ c |>\n<| a dscore=1 tags=arrays,sorting,python |>\nPython has built in max\
    \ function that can return maximum value from a list.\n<code>\nmax(list)\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not an answer to the question. You should add some\
    \ explanation how to use this function. Also why do you think this would help.\n\
    <|/ c |>\n<| a tags=arrays,sorting,python |>\nYou can use built-in function \"\
    sorted\"\n<code>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 2\nres = sorted(arr,key=lambda\
    \ x: (-x, x))[k:]\nprint(res)\n</code>\nOutput:\n<code>\n[-4, -3, 5]\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=arrays,sorting,python |>\nYou can try this too but\
    \ you need to sort the list first. \n<code>\nk = 2\narr = [-3, 2, 1, 2, -1, -2,\
    \ 1]\nmax_list = arr[:k]\nmax_list.sort()\nprint(max_list)\n</code>\nOutput:\n\
    <code>\n[-4, -3, 5]\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nA simple one-liner:\n\
    <code>\nk = 2\narr = [-3, 2, 1, 2, -1, -2, 1]\nprint(sorted(arr, key=lambda x:\
    \ (-x, x))[k:])\n</code>\n<|/ a tags=arrays,sorting,python |>\n<| a |>\nWe can\
    \ use the max() function\n<code>\nk = 2\narr = [-3, 2, 1, 2, -1, -2, 1]\nprint(max(arr,\
    \ key=lambda x: (-x, x))[k:])\n</code>\n<|/ a dscore=0 tags=arrays,sorting,python\
    \ |>\n<| a |>\n<code>", "    # \u65B9\u6CD5\u4E00\uFF1A \u9012\u5F52\n    # 1.\
    \ \u5BF9\u4E8Ek = 1\uFF0C \u5C06arr\u5206\u6210[1, arr[1]] = [arr[1], arr[1]]\n\
    \    # 2. \u5BF9\u4E8Ek = 2\uFF0C \u5C06arr\u5206\u6210[2, arr[2]] = [arr[2],\
    \ arr[2], arr[2]]\n    # 3. \u5BF9\u4E8Ek = 3\uFF0C \u5C06arr\u5206\u6210[3, arr[3]]\
    \ = [arr[3], arr[3], arr[3], arr[3]]\n    # 4. ...\n    # 5. \u5BF9\u4E8Ek = n\uFF0C\
    \ \u5C06arr\u5206\u6210[n, arr[n]] = arr[arr[n], arr[n]] = arr[n-1, arr[n-1],\
    \ arr[n-1]]\n\n    # \u65B9\u6CD5\u4E8C\uFF1A \u5FAA\u73AF\n    # 1. \u5BF9\u4E8E\
    k = 1\uFF0C \u5C06arr\u5206\u6210[1, arr[1]] = [arr[1], arr[1]]\n    # 2. \u5BF9\
    \u4E8Ek = 2\uFF0C \u5C06arr\u5206\u6210[2, arr[2]] = [arr[2], arr[2], arr[2]]\n\
    \    # 3. \u5BF9\u4E8Ek = 3\uFF0C \u5C06arr\u5206\u6210[3, arr[3]] = [arr[3],\
    \ arr[3], arr[3], arr[3]]\n    # 4. ...\n    # 5. \u5BF9\u4E8Ek = n\uFF0C \u5C06\
    arr\u5206\u6210[n, arr[n]] = arr[arr[n], arr[n]] = arr[n-1, arr[n-1], arr[n-1]]\n\
    \n    # \u65B9\u6CD5\u4E09\uFF1A \u5192\u6CE1\n    # 1. \u5BF9\u4E8Ek = 1\uFF0C\
    \ \u5C06arr\u5206\u6210[1, arr[1]] = [arr[1], arr[1]]\n    # 2. \u5BF9\u4E8Ek\
    \ = 2\uFF0C \u5C06arr\u5206\u6210[2, arr[2]] = [arr[2], arr[2], arr[2]]\n    #\
    \ 3. \u5BF9\u4E8Ek = 3\uFF0C \u5C06arr\u5206\u6210[3, arr[3]] = [arr[3], arr[3],\
    \ arr[3], arr[3]]\n    # 4. ...\n    # 5. \u5BF9\u4E8Ek = n\uFF0C \u5C06arr\u5206\
    \u6210[n, arr[n]] = arr[arr[n], arr[n]] = arr[n-1, arr[n-1], arr[n-1]]\n\n   \
    \ # \u65B9\u6CD5\u56DB\uFF1A \u5229\u7528heapq\n    # 1. \u5BF9\u4E8Ek = 1\uFF0C\
    \ \u5C06arr\u5206\u6210[1, arr[1]] = [arr[1], arr[1]]\n    # 2. \u5BF9\u4E8Ek\
    \ = 2\uFF0C \u5C06arr\u5206\u6210[2, arr[2]] = [arr[2], arr[2], arr[2]]\n    #\
    \ 3. \u5BF9\u4E8Ek = 3\uFF0C \u5C06arr\u5206\u6210[3, arr[3]] = [arr[3], arr[3],\
    \ arr[3], arr[3]]\n    # 4. ...\n    # 5. \u5BF9\u4E8Ek = n\uFF0C \u5C06arr\u5206\
    \u6210[n, arr[n]] = arr[arr[n], arr[n]] = arr[n-1, arr[n-1], arr[n-1]]\n\n   \
    \ # \u65B9\u6CD5\u4E94\uFF1A \u5229\u7528heapq\n    # 1. \u5BF9\u4E8Ek = 1\uFF0C\
    \ \u5C06arr\u5206", "    pass\n", "    pass\n</cell>\n<cell>", "    if k < 0:\n\
    \        return sorted(arr)\n    else:\n        k = min(len(arr), k)\n       \
    \ return sorted(arr[:k])\n", "    arr = sorted(arr)\n    if k == 1:\n        return\
    \ arr\n    k = max(k, len(arr))\n    arr[:k]\n    return arr\n", "    # Solution\
    \ 1 -- O(nlogn)\n    # maxHeapify\n    # O(nlogn)\n    heapq.heapify(arr)\n\n\
    \    res = []\n    while len(arr) > 0:\n        res.append(heapq.heappop(arr))\n\
    \n    return res\n", "    # \u65B9\u6CD5\u4E00\uFF1A\u6700\u7B80\u5355\u7684O(nlogn)\n\
    \    return sorted(arr, key=lambda x: -x)[-k:]\n", "    if len(arr) == 0:\n  \
    \      return arr\n    maximum = [arr[0]]\n    maximum.append(arr[0])\n    for\
    \ i in range(1, len(arr)):\n        if maximum[i - k - 1] > arr[i]:\n        \
    \    maximum.append(arr[i])\n            maximum.append(arr[i])\n        else:\n\
    \            maximum[i - k - 1] = arr[i]\n    return maximum\n", "    import heapq\n\
    \n    if k > len(arr):\n        return []\n    heapq.heapify(arr)\n    res = []\n\
    \    while len(arr) != 0:\n        res.append(heapq.heappop(arr))\n        heapq.heappush(arr,\
    \ arr[-1] + k)\n    return res\n</code>\nI got this solution from-chan from here\n\
    The code runs successfully and gives the expected output for most test cases.\
    \ However, I couldn't get the expected output for these test cases:\n<code>\n\
    Input arr = [-1,-2,-3,-4,-5,-6,-7,-8,-9,0]\nExpected output = [-1,-3,-8,-9]\n\
    </code>\nCan someone please tell me what I am doing wrong here?\n<|/ q |>\n<|\
    \ c |>\nJust for fun, try a couple more test cases. For example, `arr = [0,-3,-2,-1],\
    \ k = 1`\n<|/ c |>\n<| c |>\nYes, I did try this test case. It gives me the expected\
    \ output for that test case. Although, for other test cases it fails.\n<|/ c |>\n\
    <| c |>\nI added an answer to show how to solve this without having to use `heapq`.\n\
    <|/ c |>\n<| c |>\nI ran this test case on ideone and it worked. Although, still\
    \ not sure what went wrong.\n<|/ c |>\n<| a tags=algorithm,arrays,sorting,python,heap\
    \ |>\nThe issue is that you are only pushing k if you find a number greater than\
    \ the current top element.  However, if there is a number greater than the current\
    \ top element, you are not pushing the top element.  The top element will be pushed\
    \ only if there are less than k numbers greater than the current top element.\
    \  Therefore, when k is 1, all elements are greater than the top element.  Therefore,\
    \ you must push every element greater than the top element except the top element\
    \ itself.  You can do this by pushing every element greater than or equal to the\
    \ top element except the top element.  Therefore, you can use the following algorithm\
    \ that does not require a heap:\n<code>", "    pass\n</cell>\n<cell>", "    #\
    \ write your code here\n    sorted_arr = sorted(arr)\n    return sorted_arr[k:]\n",
  "    def merge(arr: List[int], k: int) -> List[int]:\n        \"\"\"\n        Merge\
    \ the k first elements of arr into one element and return.\n        \"\"\"\n \
    \       if len(arr) <= k:\n            return arr\n        arr1 = arr[0:k]\n \
    \       arr2 = arr[k:]\n        arr1 = merge(arr1, k)\n        arr2 = merge(arr2,\
    \ k)\n        result = [max(arr1)] + arr2\n        return result\n    \n    return\
    \ merge(arr, k)\n", "    arr = sorted(arr)\n    ans = [arr.pop(0)]\n    \n   \
    \ for i in range(min(k, len(arr))):\n        ans.append(max(ans[-1], arr.pop(0)))\n\
    \        \n    return ans\n\n", "    length = len(arr)\n\n    if length <= 1:\n\
    \        return arr\n\n    max_idx = length-1\n    max_value = arr[-1]\n\n   \
    \ for idx in range(1, length-k+1):\n        if arr[idx] > max_value:\n       \
    \     max_idx = idx\n            max_value = arr[idx]\n    \n    return [arr[0],\
    \ arr[max_idx+1], arr[max_idx]]\n", "    if k > len(arr):\n        return []\n\
    \    elif k == 0:\n        return arr\n    elif k == 1:\n        return [max(arr)]\n\
    \    else:\n        left, right = 0, len(arr) - 1\n        while left < right:\n\
    \            mid = (left + right) // 2\n            if arr[mid] >= arr[mid+1]:\n\
    \                right = mid - 1\n            else:\n                left = mid\
    \ + 1\n        arr = [max(arr[:mid]) if mid < len(arr) else max(arr[mid+1:])]\n\
    \        return maximum(arr, k-1)\n</cell>\n<cell>\narr = [-3, -4, 5]\nk = 3\n\
    maximum(arr, k)\n</cell>\n<text>\nImplement Quick Sort\n\n</text>\n<cell>", " \
    \   pass\n</cell>\n<text>\nImplement merge sort in Python\n\n\n</text>\n<cell>\n\
    from typing import List\n", "    if k > len(arr):\n        return arr\n    else:\n\
    \        sorted_arr = sorted(arr)\n        if k == sorted_arr[-1]:\n         \
    \   return sorted_arr\n        else:\n            return sorted_arr[:k]\n", " \
    \   pass\n", "    pass\n", "    pass\n", "    arr = sorted(arr)\n    return arr[-k:]\n",
  "    pass\n", "    k = min(k, len(arr))\n    return sorted(arr, key=lambda x: -x)[:k]\n",
  "    if not arr or not k:\n        return []\n\n    # sort arr\n    sorted_arr =\
    \ []\n    count = 0\n    for num in arr:\n        count += num\n        sorted_arr.append(count)\n\
    \    sorted_arr.sort()\n\n    # init max_arr\n    max_arr = []\n    max_count\
    \ = 0\n    # find kth largest number\n    for _ in range(k):\n        max_count\
    \ += 1\n        max_arr.append(sorted_arr[max_count - 1])\n\n    # append remaining\
    \ number\n    for num in arr:\n        max_count += 1\n        max_arr.append(sorted_arr[max_count\
    \ - 1])\n\n    # return max_arr\n    return max_arr\n\n", "    \n    if k > len(arr):\n\
    \        return arr\n    else:\n        if k == 1:\n            return arr\n \
    \       \n        left = maximum([x for x in arr if x != arr[0]], k - 1)\n   \
    \     right = maximum([x for x in arr if x != arr[-1]], k - 1)\n        \n   \
    \     arr.append(arr[left[0]])\n        arr.append(arr[right[1]])\n        \n\
    \        return arr\n    \n    ", "    left = []\n    right = []\n    leftIndex\
    \ = 0\n    rightIndex = 0\n    rightLen = 0\n\n    while leftIndex < len(arr)\
    \ and rightIndex < len(arr):\n        if arr[leftIndex] > arr[rightIndex]:\n \
    \           right.append(arr[rightIndex])\n            rightLen = len(right)\n\
    \        else:\n            left.append(arr[leftIndex])\n            leftLen =\
    \ len(left)\n\n        if leftLen >= k:\n            left.pop(0)\n           \
    \ leftLen -= k\n\n        if rightLen >= k:\n            right.pop(0)\n      \
    \      rightLen -= k\n\n        if leftLen > k:\n            for i in range(k,\
    \ leftLen):\n                left.append(arr[leftIndex])\n                leftIndex\
    \ += 1\n                leftLen -= 1\n            if rightLen > 0:\n         \
    \       for i in range(rightLen, k + 1):\n                    right.append(arr[rightIndex])\n\
    \                    rightIndex += 1\n                    rightLen -= 1\n    return\
    \ left + right\n", "    arr.sort()\n    arr.insert(0, 0)\n    arr.insert(0, -1000)\n\
    \    return arr[k:]\n    ", "    arr = sorted(arr)\n    ret_arr = list(arr)\n\
    \    ret_arr.reverse()\n    ret_arr = ret_arr[:k]\n    return ret_arr\n</cell>\n\
    <cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = len(arr) -1\nmaximum(arr, k)\n</cell>\n\
    <cell>", "    answer = []\n\n    if len(arr) == 1:\n        return arr\n    \n\
    \    if len(arr) == k or len(arr) > k:\n        k = k - 1\n        \n    if k\
    \ > len(arr) - 1:\n        return arr\n\n    # find the max element and the index\
    \ where the max element resides\n    max_element = arr[0]\n    max_index = 0\n\
    \    for i in range(1, len(arr)):\n        if arr[i] > max_element:\n        \
    \    max_element = arr[i]\n            max_index = i\n    \n    # append the max\
    \ element at the end of arr\n    arr.append(max_element)\n    arr.pop(max_index)\n\
    \n    # do k iterations\n    iter_count = 0\n    while len(arr) > 1:\n       \
    \ # find the max element in the sub-array\n        max_element = arr[0]\n    \
    \    max_index = 0\n        for i in range(1, len(arr)):\n            if arr[i]\
    \ > max_element:\n                max_element = arr[i]\n                max_index\
    \ = i\n        \n        # append the max element at the end of arr\n        arr.append(max_element)\n\
    \        arr.pop(max_index)\n        \n        # do k iterations\n        iter_count\
    \ += 1\n        if iter_count > k:\n            break\n    \n    return arr\n",
  "    # Your code here\n    sorted_list = sorted(arr)[:k]\n    return sorted_list\n\
    \narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nprint(maximum(arr, k))\nprint(maximum2(arr,\
    \ k))\n\n</cell>\n<text>\nGreat Job!\n\n</text>\n<|/ file source=github dstars=1\
    \ ext=.ipynb:python filename=Practice_2_Sorted_Lists.ipynb |>\n<text>\nSorted\
    \ Lists\n\n</text>\n<text>\nInsertion Sort\n\n</text>\n<text>\nGiven a linked\
    \ list and a value x, insert the value x into the linked list in the correct position.\
    \ If x already appears in the linked list, do nothing.\n\nExample 1:\n\nInput:\
    \ head = [4,5,1,9], x = 5\nOutput: head = [1]\n\nExample 2:\n\nInput: head = [1,2],\
    \ x = 1\nOutput: [1,2,1]\n\n\nFollow up:\nCould you do it in place?\n\n\n</text>\n\
    <text>\nYour First Solution\n\n</text>\n<cell>", "    # \u4E8C\u5206\u67E5\u627E\
    \n    # \u9996\u5148\u5BFB\u627E\u6700\u5C0F\u503C\uFF0C\u7136\u540E\u627E\u6700\
    \u5C0F\u7684\u503C\u5DE6\u53F3\n    # \u4E8C\u5206\u67E5\u627E\u7684\u65F6\u95F4\
    \u590D\u6742\u5EA6\u662F O(logn)\n    # \u6700\u574F\u60C5\u51B5\u662F O(n)\n\
    \    # \u6700\u574F\u60C5\u51B5\u4E0B n\u662F\u5F88\u5927\u7684\uFF0Clogn\u662F\
    \u6700\u597D\u7684\n    # \u6700\u574F\u60C5\u51B5\u4E0B k\u662F\u5F88\u5C0F\u7684\
    \uFF0Cn\u662F\u5F88\u5C0F\u7684\n\n    # \u601D\u8DEF\n    # \u5C06arr\u8F6C\u5316\
    \u4E3A\u6709\u5E8F\u5E8F\u5217\uFF0C\u628A\u6700\u5927\u7684k\u4E2A\u6570\u5BF9\
    \u5E94\u7684\u4F4D\u7F6E\uFF0C\u76F4\u63A5\u586B\u5165\u7ED3\u679C\u5E8F\u5217\
    \n\n    # \u6700\u574F\u60C5\u51B5\u4E0B k\u662F\u5F88\u5C0F\u7684\uFF0Cn\u662F\
    \u5F88\u5C0F\u7684\n    # \u4E24\u4E2A\u5217\u8868\u7684\u957F\u5EA6\u76F8\u7B49\
    \u65F6\uFF0C\u76F4\u63A5\u4F7F\u7528bisect\u627E\u5230\u5BF9\u5E94\u4F4D\u7F6E\
    \n\n    bisect = bisect.bisect\n    # \u5BF9\u6570\u7EC4\u8FDB\u884C\u6392\u5E8F\
    \uFF0C\u5C06\u6700\u5927\u7684k\u4E2A\u6570\u5BF9\u5E94\u7684\u4F4D\u7F6E\u653E\
    \u5230\u53F3\u8FB9\n    arr = [i for i in arr if i > 0]\n    arr.sort(reverse=True)\n\
    \    res_lst = []\n    \n    # \u5BFB\u627Ek\u4E2A\u6700\u5927\u7684\u6570\n \
    \   for i in range(k):\n        res_lst.append(arr[i])\n\n    # \u5C06\u7ED3\u679C\
    \u5E8F\u5217\u8FDB\u884C\u6392\u5E8F\n    res_lst.sort()\n    # \u5C06\u5DE6\u53F3\
    \u4E24\u7AEF\u7684\u6700\u5927\u503C\u8D4B\u503C\u7ED9res_lst\n    res_lst.append(arr[bisect(arr,\
    \ -k)])\n    res_lst.append(arr[bisect(arr, k)])\n    return res_lst\n", "   \
    \ return sorted(arr, key=lambda x: -x)[:k]\n</code>\n<|/ a tags=python-3.x,sorting,python\
    \ |>\n<| c |>\nI believe this should be the accepted answer as it uses built-in\
    \ functionality.\n<|/ c |>\n<| a tags=python-3.x,sorting,python |>\nI came up\
    \ with a solution myself. The following code works fine for me:\n<code>", "  \
    \  # Your code here\n    \n    return sorted(arr)[-k:]\n", "    if k == 0 or k\
    \ > len(arr):\n        return arr\n    elif k == 1:\n        max_num = max(arr)\n\
    \        return [max_num for _ in arr]\n    else:\n        max_num = -1\n    \
    \    cur_max = -1\n        left_sum = 0\n        right_sum = 0\n        for i\
    \ in range(len(arr)):\n            left_sum += arr[i]\n            right_sum +=\
    \ arr[-i - 1]\n            if left_sum > right_sum:\n                cur_max =\
    \ arr[i]\n                left_sum -= cur_max\n            else:\n           \
    \     cur_max = arr[-i - 1]\n                right_sum -= cur_max\n          \
    \  arr[i] = cur_max\n            arr[-i - 1] = cur_max\n            if cur_max\
    \ > max_num:\n                max_num = cur_max\n            arr[-i - 1] = 0\n\
    \            arr[i] = 0\n            if i == k - 1:\n                break\n \
    \       return arr\n\n", "    pass\n", "    pass\n", "    \n    # Solution 1 --\
    \ Sort\n    # if not arr or k < 0:\n    #     return []\n    # arr_sort = sorted(arr)\n\
    \    \n    # Solution 2 -- Heap\n    arr_heap = heapify(arr)\n    arr_max = []\n\
    \    heap_size = len(arr_heap)\n    \n    # Borrow max\n    curr_max = arr_heap[0]\n\
    \    \n    \n    # Borrow first element to build max-heap\n    while heap_size\
    \ > 0:\n        curr_max = max(arr_heap[0])\n        arr_max.append(curr_max)\n\
    \        arr_heap = arr_heap[1:]\n        heap_size-=1\n        \n    # Borrow\
    \ last element to build max-heap\n    while curr_max < arr_heap[0]:\n        curr_max\
    \ = max(arr_heap[0])\n        arr_max.append(curr_max)\n        arr_heap = arr_heap[1:]\n\
    \        heap_size-=1\n    \n    # Build max-heap\n    for i in range(k-1, len(arr_heap)):\n\
    \        arr_heap.insert(0,arr_heap.pop())\n        \n    return arr_max\n</cell>\n\
    <cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 2\nprint(f\"Solution 1 --> {maximum(arr,\
    \ k)}\")\n\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nprint(f\"Solution 2 --> {maximum(arr,\
    \ k)}\")\n\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 0\nprint(f\"Solution 3 --> {maximum(arr,\
    \ k)}\")\n</cell>\n<text>\nThe solution of heap sort is almost similar with the\
    \ standard heap sort implementation. Just the heap part is moved out to a separate\
    \ function.\n\n\n</text>\n<cell>", "    pass\n", "    \n    maximum_arr = []\n\
    \    maximum_number = arr[0]\n    \n    for number in arr:\n        if number\
    \ > maximum_number:\n            maximum_arr.append(number)\n            maximum_number\
    \ = number\n    \n    if len(maximum_arr) == k:\n        return maximum_arr\n\
    \    else:\n        return maximum_arr[0:k-1]\n", "    l = len(arr)\n    if l\
    \ <= k:\n        return []\n    elif k >= l:\n        return arr\n    elif k ==\
    \ 0:\n        return arr\n    else:\n        max_so_far = arr[0]\n        max_ending_here\
    \ = arr[0]\n        for i in range(1, k):\n            if arr[i] > max_ending_here:\n\
    \                max_ending_here = max_so_far\n                max_so_far = arr[i]\n\
    \            else:\n                max_so_far = max(max_so_far, arr[i])\n   \
    \     return [max_so_far]\n", "    return sorted(arr, key=max)[:k]\n</cell>\n\
    <cell>\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\nprint(maximum([4, -4, 4],\
    \ 2))\nprint(maximum([-3, -4, 5], 3))\n</cell>\n<text>\n6. Find Kth Largest Element\
    \ in a BST\n\n</text>\n<cell>", "    # Write your code here\n    if len(arr) ==\
    \ 0 or k > len(arr):\n        return []\n    elif k == 1:\n        return arr\n\
    \    else:\n        maximums = []\n        start = arr[0]\n        for i in range(1,\
    \ len(arr)):\n            if arr[i] > start:\n                maximums.append(start)\n\
    \                start = arr[i]\n            else:\n                start = max(arr[i],\
    \ start)\n        maximums.append(start)\n        return maximums\n    \n    \n",
  "    pass\n", "    pass\n", "    \n    def quickSort(arr: List[int], left: int,\
    \ right: int) -> List[int]:\n        if left < right:\n            pivotIndex\
    \ = partition(arr, left, right)\n            quickSort(arr, left, pivotIndex -\
    \ 1)\n            quickSort(arr, pivotIndex + 1, right)\n    \n    def partition(arr:\
    \ List[int], left: int, right: int) -> int:\n        pivotValue = arr[right]\n\
    \        pivotIndex = right\n        for i in range(left, right):\n          \
    \  if arr[i] < pivotValue:\n                pivotIndex += 1\n                arr[pivotIndex],\
    \ arr[i] = arr[i], arr[pivotIndex]\n        arr[pivotIndex], arr[right] = arr[right],\
    \ arr[pivotIndex]\n        return pivotIndex\n    \n    quickSort(arr, 0, len(arr)\
    \ - 1)\n    return arr\n", "    # Write your code here\n    if len(arr) <= k:\n\
    \        return arr\n    else:\n        max_index = k\n        max_value = arr[k]\n\
    \        max_idx = 0\n        for idx, val in enumerate(arr):\n            if\
    \ idx >= k:\n                break\n            if max_value < val:\n        \
    \        max_value = val\n                max_idx = idx\n        \n        arr.pop(max_idx)\n\
    \        arr.append(max_value)\n        return maximum(arr, k)\n", "    # Your\
    \ code here\n    \n    # Solution without sort\n    \n    # k is the length of\
    \ the sorted list.\n    \n    # Create a list to store max number\n    max_num\
    \ = [0 for _ in range(k)]\n    \n    for i in range(len(arr)):\n        max_num\
    \ = max(max_num, arr[i])\n    \n    return max_num\n", "    # Write your code\
    \ here\n    if not arr:\n        return arr\n    res = []\n    i = 0\n    while\
    \ len(arr) > 0:\n        res.append(max(arr, key=lambda x: x))\n        arr.pop(0)\
    \ \n    return res", "    arr = sorted(arr)\n    return arr[k:]\n", "    return\
    \ sorted(arr, key=lambda x: -x[:k])\n", "    arr = sorted(arr)[:k+1]\n\n    return\
    \ arr\n", "    # write your code here\n    pass\n", "    # Solution 1 Brute Force\
    \ Time Complexity O(nk)\n    # Sort and return the k largest numbers.\n    # Solution\
    \ 2 Quick Sort\n    # Space Complexity O(k)\n    if len(arr) > k:\n        return\
    \ sorted(arr, key=lambda x: -x) or arr\n    else:\n        sorted_arr = []\n \
    \       for i in range(0, len(arr)):\n            sorted_arr.append(arr[i])\n\
    \        return sorted(sorted_arr, reverse=True) or arr\n\n", "    # todo\n  \
    \  arr: List[int] = []\n\n    pass\n\n", "    arr1 = []\n    maximums = []\n \
    \   for i in range(len(arr)):\n        maximums.append(max([arr[i], maximums[i-1]]))\n\
    \        arr1.append(maximums[i])\n\n    return maximums\n", "    pass\n", " \
    \   pass\n</cell>\n<cell>", "    if k == 0:\n        return arr\n    m = maximumHelper(arr,\
    \ 0, len(arr)-1, k)\n    return m\n", "    # Write your code here\n    return\
    \ max(arr, key=lambda x: arr.index(x))\n", "    pass\n", "    arr.sort()\n   \
    \ return arr[k:] + arr[:k]\n", "    maximum = []\n    heapq.heapify(arr)\n   \
    \ if len(arr) <= k:\n        maximum = arr\n        return maximum\n    for i\
    \ in range(k - 1):\n        heapq.heappop(arr)\n        maximum.append(max(arr))\n\
    \        heapq.heappush(arr, arr[0])\n    return maximum\n", "    arr_max, k_max\
    \ = 0, 0\n    for i in range(k):\n        if arr[i] > arr_max:\n            arr_max\
    \ = arr[i]\n            k_max = i\n    return arr[k_max:]\n", "    def merge_sort(arr:\
    \ List[int], k: int) -> List[int]:\n        \"\"\"\n        1. Find the maximum\
    \ value from the first k elements\n        2. Sort remaining array with the help\
    \ of merge_sort recursively\n        \"\"\"\n        if len(arr) < k:\n      \
    \      return arr\n        max_val = arr[0]\n        left_arr = arr[k:]\n    \
    \    left_k = k\n        right_arr = left_arr[:k]\n\n        while len(left_arr)\
    \ > 0 and len(right_arr) > 0:\n            if left_arr[0] > right_arr[0]:\n  \
    \              arr[k] = left_arr[0]\n                left_arr = left_arr[1:]\n\
    \                left_k += 1\n            else:\n                arr[k] = right_arr[0]\n\
    \                right_arr = right_arr[1:]\n                right_k += 1\n   \
    \         k += 1\n        return arr[k:] + merge_sort(left_arr[:left_k], k) +\
    \ merge_sort(right_arr[:right_k], k)\n\n    return merge_sort(arr[:k], k)\n",
  "    if k <= 0 or len(arr) <= 0:\n        return []\n\n    # Quick sort\n    if\
    \ k == 1:\n        return sorted(arr)\n\n    low = 0\n    high = len(arr) - 1\n\
    \n    # Selection sort\n    while low < high:\n        pivot = high // 2 - 1\n\
    \        while k > 0 and arr[pivot] <= arr[high]:\n            high -= 1\n   \
    \         k -= 1\n        while k <= 0 and arr[pivot] >= arr[low]:\n         \
    \   low += 1\n            k += 1\n        if low < high:\n            arr[pivot],\
    \ arr[high] = arr[high], arr[pivot]\n            pivot = high // 2 - 1\n     \
    \       while pivot <= low:\n                arr[pivot], arr[high] = arr[high],\
    \ arr[pivot]\n                pivot += 1\n                high -= 1\n\n    # Recursion\
    \ sort\n    pivot = high // 2 - 1\n    while k > 0 and arr[pivot] <= arr[high]:\n\
    \        high -= 1\n        k -= 1\n    arr[pivot], arr[high] = arr[high], arr[pivot]\n\
    \    return maximum(arr, k - 1) + [arr[pivot]]\n", "    # write your code here\n\
    \    max_heap = []\n    if k == 0 or len(arr) <= k:\n        return arr\n    max_heap.append(arr[0])\n\
    \    for i in range(1, len(arr)):\n        if max_heap[0] < arr[i]:\n        \
    \    max_heap[0] = arr[i]\n            max_heap.append(arr[i])\n            if\
    \ len(max_heap) > k:\n                pop = max_heap.pop()\n                max_heap[0]\
    \ = pop\n                pop = max_heap.pop()\n                max_heap[0] = pop\n\
    \            else:\n                max_heap[0] = arr[i]\n        else:\n    \
    \        max_heap.append(arr[i])\n    return max_heap\n", "    pass\n</cell>\n\
    <cell>", "    # \u65B9\u6CD5\u4E00\uFF1A \u4F7F\u7528\u4E8C\u5206\u6CD5\n    #\
    \ \u57FA\u672C\u601D\u60F3\uFF1A\n    # \u628Aarr\u4E2Dk\u4E2A\u6570\u5206\u6210\
    \u4E24\u90E8\u5206\n    # 1.\u524Dk\u4E2A\u6570\uFF0C\u6BD4\u5982arr = [4, -4,\
    \ 4], k = 2\n    #     \u524Dk\u4E2A\u6570\uFF08\u6BD4\u5982\u524Dk\u4E2A\u6570\
    \u662F-2\uFF0C\u6BD4\u5982\u524Dk\u4E2A\u6570\u5C31\u662F-1\uFF0C\u6240\u4EE5\u662F\
    \u4E00\u4E2A\u5355\u72EC\u7684\u5C0F\u6570\uFF09\n    #     4\uFF0C-4\uFF0C4\u8FD9\
    \u4E09\u4E2A\u6570\u7684\u4E24\u7AEF\u90FD\u6BD4k\u5206\u79BB\u7684\n    # 2.\u540E\
    k\u4E2A\u6570\uFF0C\u6BD4\u5982arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    #  \
    \   \u524Dk\u4E2A\u6570\uFF0C\u6BD4\u5982\u524Dk\u4E2A\u6570\u662F1\uFF0C\u6240\
    \u4EE5\u662F\u4E00\u4E2A\u5355\u72EC\u7684\u5C0F\u6570\n    #     -1\uFF0C-2\uFF0C\
    1\u8FD9\u4E09\u4E2A\u6570\u7684\u4E24\u7AEF\u90FD\u6BD4k\u5206\u79BB\u7684\n \
    \   # \u4E8C\u5206\u6CD5\u65B9\u6CD5\uFF1A\n    # 1. \u9996\u5148\u627E\u5230\
    arr\u4E2D\u6700\u5C0F\u7684k\u4E2A\u6570\uFF0C\u6BD4\u5982arr = [-3, 2, 1, 2,\
    \ -1, -2, 1], k = 1\n    #     \u5728\u524Dk\u4E2A\u6570\u7684\u4F4D\u7F6E\uFF0C\
    \u627E\u5230\u6700\u5C0F\u503C\n    # 2. \u7136\u540E\u904D\u5386arr\uFF0C\u6BD4\
    \u5982arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    #     \u5728\u540Ek\u4E2A\u6570\
    \u7684\u4F4D\u7F6E\uFF0C\u627E\u5230\u6700\u5927\u503C\n    # 3. \u5982\u679C\
    arr[k-1] > arr[k], \u90A3\u4E48\u5C31\u662F\u6700\u5C0F\u503C\n    # 4. \u5982\
    \u679Carr[k-1] < arr[k], \u90A3\u4E48\u5C31\u662F\u6700\u5927\u503C\n    # 5.\
    \ \u5982\u679Carr[k-1] == arr[k], \u90A3\u4E48\u5C31\u662F\u6B63\u5E38\u7684\u6570\
    \uFF0C\u76F4\u63A5\u6309\u5E8F\u6392\u5E8F\n    # 6. \u5BF9\u4E8E\u6CA1\u6709\
    k\u4E2A\u6570\u7684\u60C5\u51B5\uFF0C\u76F4\u63A5\u6309\u5E8F\u6392\u5E8F\n\n\
    \    # \u5148\u627E\u5230\u6700\u5C0F\u503C\u7684\u4F4D\u7F6E\n    # \u5C0F\u4E8E\
    arr\u4E2D\u7684\u6700\u5C0F\u503C\uFF0C\u5C31\u662F\u6700\u5C0F\u503C\u7684\u4F4D\
    \u7F6E\n    min_pos, min_value = len(arr) - 1, arr[-1]\n    # \u6700\u5C0F\u503C\
    \u7684\u4F4D\u7F6E\n    for i in range(len(arr)):\n        if arr[i] < arr[i-1]:\n\
    \            min_pos = i\n    # print(\"arr: \", arr)\n    # print(\"min_pos:\
    \ \", min_pos)\n    # print(\"min_value: \", min_value)\n\n    # \u6700\u540E\u518D\
    \u627E\u5230\u6700\u5927\u503C\n    # \u5927\u4E8Earr\u4E2D\u7684\u6700\u5927\u503C\
    \uFF0C\u5C31\u662F\u6700\u5927\u503C\u7684\u4F4D\u7F6E\n    max_pos, max_value\
    \ = 0, arr[0]\n    for i in range(len(arr)):\n        if arr[i] > arr[max_pos]:\n\
    \            max_pos = i\n    # print(\"max_pos: \", max_pos)\n    # print(\"\
    max_", "    # Write your code here\n    arr = sorted(arr)\n    return arr[-k:]\n\
    </cell>\n<text>\nQuestion 7\n\n</text>\n<cell>", "    max_list = [-10000000] *\
    \ len(arr)\n    max_index = 0\n    \n    for i in range(0, len(arr) - k + 1):\n\
    \        max_index = i\n        for j in range(i + 1, i + k):\n            if\
    \ max_list[j] > arr[i]:\n                max_list[j] = arr[i]\n              \
    \  max_index = j\n\n    lst = list(map(lambda x: -x, max_list))\n    lst.append(arr[-1])\n\
    \    return lst\n</cell>\n<cell>\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)\n</cell>\n\
    <cell>", "    import math\n    from operator import itemgetter\n    if len(arr)\
    \ == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    else:\n\
    \        pos = 0\n        max_k = math.ceil(len(arr)/k)\n        while pos < len(arr):\n\
    \            if pos == len(arr):\n                pos += 1\n                if\
    \ pos == len(arr):\n                    return arr\n            mid = (pos + max_k)\
    \ //2\n            left_arr = arr[pos:mid]\n            right_arr = arr[mid +\
    \ 1:]\n            left_max = maximum(left_arr, k)\n            right_max = maximum(right_arr,\
    \ k)\n            if len(left_arr) + len(right_arr) == len(arr):\n           \
    \     return left_max + right_max\n            elif len(left_arr) < len(right_arr):\n\
    \                max_k = math.ceil(len(left_arr)/k)\n                pos = mid\
    \ + 1\n            else:\n                max_k = math.ceil(len(right_arr)/k)\n\
    \                pos = mid + 1\n    return arr\n\"\"\"", "    pass\n", "    k\
    \ = len(arr)\n    ans = []\n    \n    for i in range(k):\n        max_val = max(arr)\n\
    \        ans.append(max_val)\n        arr.remove(max_val)\n\n    return ans\n",
  "    pass\n", "    # Solution 1 -- Using insertion sort\n    # Create a set (O(n))\
    \ to store each element in arr. Insert each element of the array into a set.\n\
    \    # Use the insertion sort algorithm to keep track of the largest element in\
    \ arr.\n    # When there are k elements, return the largest element in arr\n \
    \   # \n    # Time Complexity: O(n^2)\n    # Space Complexity: O(n)\n\n    set_arr\
    \ = set()\n    \n    for i in range(len(arr)):\n        set_arr.add(arr[i])\n\
    \    \n    arr.sort()\n    \n    if len(arr) > k:\n        return arr[-k:]\n \
    \   \n    return list(set_arr)\n", "    return sorted(arr, key=lambda x: -x)[:k]\n",
  "    # Write your code here\n    if len(arr) < k or k >= len(arr):\n        return\
    \ arr\n    max_value = arr[0]\n    result = []\n    for i in range(k-1):\n   \
    \     if arr[i] > max_value:\n            max_value = arr[i]\n            result.append(max_value)\n\
    \        elif arr[i] == max_value:\n            result.append(arr[i])\n      \
    \  elif arr[i] < max_value:\n            if i == k-2:\n                max_value\
    \ = arr[k]\n                result.append(max_value)\n            else:\n    \
    \            max_value = arr[i+1]\n                result.append(max_value)\n\
    \    return result", "    arr = sorted(arr)\n    if k == 1: return arr\n    if\
    \ len(arr) == 0: return []\n    length = len(arr)\n    end = k-1\n    if end >=\
    \ length: return arr\n    max_num = arr[0]\n    min_num = arr[length-1]\n    \n\
    \    \n    for num in arr[1:k]:\n        if num > max_num:\n            max_num\
    \ = num\n        if num < min_num:\n            min_num = num\n    \n    if k\
    \ == length:\n        return arr[:k+1]\n    else:\n        return [min_num]+arr[:end+1]+[max_num]\n",
  "    # \u66B4\u529B\u6CD5\n    # 1. \u6700\u4F18\u89E3\n    # O(n^2) \n    # 1.1\
    \ \u627E\u51FA\u6700\u5927\u503C\u7684\u4F4D\u7F6E O(n)\n    # 1.2 \u53D6\u51FA\
    \ k \u7684\u6700\u5927\u6570\n    # 1.3 \u53D6\u51FA k \u7684\u6700\u5C0F\u6570\
    \n\n    # 2. \u5FEB\u6162\u641C\u7D22\n    # O(n) \n    # 2.1 \u53D6\u51FA k \u7684\
    \u6700\u5927\u6570\n    # 2.2 \u4ECE\u524D\u9762 k-1 \u7684\u6570\u7EC4\u53D6\u51FA\
    \ k - 1 \u4E2A\u6570\n\n    # 3. \u9012\u5F52\n    # O(n^2) \n    # 3.1 \u627E\
    \u51FA k \u7684\u6700\u5927\u6570\n    # 3.2 \u9012\u5F52\n    # 3.3 \u627E\u51FA\
    \ k \u7684\u6700\u5C0F\u6570\n    # 3.4 \u9012\u5F52\n    # 3.5 \u627E\u51FA k\
    \ \u7684\u6700\u5927\u6570\n    # 3.6 \u9012\u5F52\n    # 3.7 \u627E\u51FA k \u7684\
    \u6700\u5C0F\u6570\n\n    # 4. \u9009\u62E9\u9012\u5F52\n    # O(n^2) \n    #\
    \ 4.1 \u627E\u51FA k \u7684\u6700\u5927\u6570\n    # 4.2 \u627E\u51FA k \u7684\
    \u6700\u5C0F\u6570\n    # 4.3 \u9012\u5F52\n    # 4.4 \u627E\u51FA k \u7684\u6700\
    \u5927\u6570\n    # 4.5 \u627E\u51FA k \u7684\u6700\u5C0F\u6570\n    # 4.6 \u9012\
    \u5F52\n    # 4.7 \u627E\u51FA k \u7684\u6700\u5927\u6570\n    # 4.8 \u627E\u51FA\
    \ k \u7684\u6700\u5C0F\u6570\n\n    # 4. \u9009\u62E9\u5FEB\u6162\u641C\u7D22\n\
    \    # O(n)\n    # 4.1 \u627E\u51FA k \u7684\u6700\u5927\u6570\n    # 4.2 \u53D6\
    \u51FA k \u7684\u6700\u5927\u6570\n    # 4.3 \u627E\u51FA k \u7684\u6700\u5C0F\
    \u6570\n    # 4.4 \u53D6\u51FA k \u7684\u6700\u5C0F\u6570\n    # 4.5 \u627E\u51FA\
    \ k \u7684\u6700\u5927\u6570\n    # 4.6 \u53D6\u51FA k \u7684\u6700\u5927\u6570\
    \n    # 4.7 \u627E\u51FA k \u7684\u6700\u5C0F\u6570\n    # 4.8 \u53D6\u51FA k\
    \ \u7684\u6700\u5C0F\u6570\n\n    # 5. \u9009\u62E9\u5FEB\u6162\u641C\u7D22\n\
    \    # O(n)\n    # 5.1 \u627E\u51FA k \u7684\u6700\u5927\u6570\n    # 5.2 \u53D6\
    \u51FA k \u7684\u6700\u5927\u6570\n    # 5.3 \u627E\u51FA k \u7684\u6700\u5C0F\
    \u6570\n    # 5.4 \u53D6\u51FA k \u7684\u6700\u5C0F\u6570\n    # 5.5 \u627E\u51FA\
    \ k \u7684\u6700\u5927\u6570\n    # 5.6 \u53D6\u51FA k \u7684\u6700\u5927\u6570\
    \n    # 5.7 \u627E\u51FA k \u7684", "    arr = list(sorted(arr))\n    return arr[:k]\n",
  "    # \u601D\u8DEF\uFF1A\u5148\u6392\u5E8F\uFF0C\u7136\u540E\u53D6\u524Dk\u4E2A\
    \u6570\n    if not arr or not k:\n        return []\n    arr.sort()\n    return\
    \ arr[k:]\n", "    if k > len(arr):\n        raise IndexError\n    \n    sorted_list\
    \ = sorted(arr)\n    max_list = [sorted_list[0]]\n    for i in range(1, len(sorted_list)):\n\
    \        if sorted_list[i] > sorted_list[i - 1]:\n            max_list.append(sorted_list[i])\n\
    \    \n    return max_list\n\n", "    pass\n", "    if k == 0:\n        return\
    \ []\n    if k == 1:\n        return arr\n    \n    length = len(arr)\n    sorted_list\
    \ = sorted(arr)\n    \n    left = [x for x in range(length)]\n    right = [x for\
    \ x in range(length)]\n    left.extend(sorted_list[:length - k])\n    right.extend(sorted_list[length\
    \ - (k + 1)])\n\n    left = [x for x in left if x > -k]\n    right = [x for x\
    \ in right if x < length - (k + 1)]\n\n    ret_list = []\n    for i in range(k):\n\
    \        if left[i] + right[i] > arr[i]:\n            sorted_list[i] = left[i]\
    \ + right[i]\n            ret_list.append(sorted_list[i])\n            left[i]\
    \ = left[i] - arr[i]\n            right[i] = right[i] + arr[i]\n        else:\n\
    \            sorted_list[i] = arr[i]\n            ret_list.append(sorted_list[i])\n\
    \n    return ret_list\n\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 2))\n", '    pass',
  "    pass\n</cell>\n<text>\n\u6700\u5927\u503C\n\n</text>\n<cell>\nfrom typing import\
    \ List\n", "    # Your code here\n    arr=list(arr)\n    arr.sort()\n    k=k-1\n\
    \    arr=[arr[:k],arr]\n    return arr\n\n</cell>\n<text>\n\u6700\u591A\u7684\u4E09\
    \u5143\u7EC4\n\n</text>\n<cell>", "    if k >= len(arr):\n        return arr\n\
    \    return sorted(arr)[-k:]\n\n", "    if k == 1:\n        return [max(arr)]\n\
    \    else:\n        arr_len = len(arr)\n        sorted_arr = sorted(arr)\n   \
    \     ans = []\n        for i in range(k - 1):\n            ans.append(sorted_arr[i])\n\
    \        for i in range(arr_len - k):\n            ans.append(sorted_arr[i + k\
    \ - 1])\n        return ans\n", "    # write your code here\n    arr.sort()\n\
    \    if len(arr) <= k:\n        return arr\n    return arr[:k]\n", "    if not\
    \ 0 <= k <= len(arr):\n        return []\n\n    # Time Complexity: O(k log k)\n\
    \    maximum_list: List[int] = []\n\n    arr_len = len(arr)\n    left, right =\
    \ 0, arr_len\n\n    while left < right:\n        mid = (left + right) // 2\n\n\
    \        if arr[mid] > k:\n            right = mid\n        else:\n          \
    \  left = mid\n\n    maximum_list = arr[left:right+k-1]\n    maximum_list.sort()\n\
    \n    return maximum_list\n", "    max = arr[0]\n    arr[0] = 0\n    arr_copy\
    \ = arr[:]\n    arr_copy.sort()\n    while k > 0:\n        arr[0] = max\n    \
    \    arr_copy = arr[:]\n        arr_copy.sort()\n        if arr[0] != arr_copy[0]:\n\
    \            arr.pop()\n            arr_copy.pop()\n            k -= 1\n     \
    \   else:\n            arr.pop(0)\n            arr_copy.pop(0)\n            k\
    \ -= 1\n    arr.reverse()\n    return arr\n", "    arr = sorted(arr)\n    res\
    \ = []\n    for index, num in enumerate(arr):\n        if index == k:\n      \
    \      break\n        if num not in res:\n            res.append(num)\n\n    return\
    \ res\n", "    pass\n</cell>\n<cell>", "    if k == 0:\n        return []\n  \
    \  if k >= len(arr):\n        k = len(arr)\n    sorted_arr = sorted(arr)\n   \
    \ return sorted_arr[:k]\n\n", "    pass\n</cell>\n<cell>", "    from collections\
    \ import deque\n    heap = deque()\n    heapq.heapify(arr)\n\n    if k > len(arr):\n\
    \        return arr\n\n    # return if k is 0 \n    if k == 0:\n        return\
    \ [heapq.heappop(heap)]\n\n    while len(heap) > 0:\n        k = k // 2\n    \
    \    heapq.heappush(heap, max(heapq.heappop(heap), arr[0]))\n        if len(heap)\
    \ < k:\n            break\n\n    return heap\n", "    def maximumHelper(arr: List[int],\
    \ k: int) -> List[int]:\n        if k == 0: return arr\n        return maximumHelper(sorted(arr)[:k-1],\
    \ k=k-1) + [arr[k-1]]\n\n    return maximumHelper(sorted(arr), k)\n</cell>\n<cell>\n\
    a1 = [-3,-4,5]\nprint(maximum(a1,3))\n</cell>\n<text>\nThe maximum of a subarray\n\
    Given an array arr of n integers, find the contiguous subarray of size k \nwith\
    \ the maximum sum and return its sum.\nThe sum of an empty subarray is 0.\nThe\
    \ subarray can contain duplicates.\nExample 1:\n\n    Input: arr = [1,3,-1,-3,5,3,6,7],\
    \ k = 3\n    Output: 15\nExplanation: [3,3,5,6,7] has the largest sum of 6.\n\n\
    Example 2:\n\n    Input: arr = [-1,1], k = 1\n    Output: 1\nExplanation: The\
    \ subarray [-1, 1], the largest sum of 1.\n\nNote:\n\n    0 <= k <= len(arr) <=\
    \ 30\n    1 <= n <= 50\n\n</text>\n<cell>", "    pass\n</cell>\n<cell>", "   \
    \ # write your code here\n    max_list = []\n    i = j = 0\n    max_i = max_j\
    \ = -1\n    for i in range(len(arr)):\n        if i >= k:\n            continue\n\
    \        while j != i:\n            if arr[j] > arr[i]:\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            j += 1\n        max_list.append(arr[i])\n\
    \        if j >= k - 1:\n            i += 1\n            j = i\n    return max_list\n\
    \n", "    if k == 0 or k > len(arr):\n        return arr\n    if k == 1:\n   \
    \     return sorted(arr)[:k]\n    # k = 2\n    pivot = arr[0]\n    less = []\n\
    \    greater = []\n    for i in range(len(arr)):\n        if arr[i] < pivot:\n\
    \            less.append(arr[i])\n        else:\n            greater.append(arr[i])\n\
    \    return maximum(less, k - 1) + [pivot] + maximum(greater, k - 1)\n", "   \
    \ from collections import defaultdict\n    if k >= len(arr):\n        return arr\n\
    \    maximum = defaultdict(list)\n    for x in arr:\n        maximum[x].append(x)\n\
    \    maximum = {k: max(v) for k, v in maximum.items()}\n    ans = []\n    for\
    \ k, v in maximum.items():\n        ans.append(k)\n        if k != k:\n      \
    \      for i in range(1, len(v)):\n                if v[i-1] >= v[i]:\n      \
    \              ans.append(v[i])\n    return ans\n", "    if not arr or not k:\n\
    \        return []\n    \n    max_arr = []\n    for x in arr:\n        max_arr.append(x)\n\
    \        \n    if len(max_arr) < k:\n        max_arr += [0]*k - len(max_arr)\n\
    \        \n    max_arr.sort()\n    return max_arr[:k]\n</cell>\n<text>\nmaximum()\
    \ solves the problem by using quicksort. This solution takes O(n log n) time.\n\
    \nWe start by partitioning the input array arr into two subarrays of size k-1.\
    \ We call these subarrays left and right. As we partition arr, each element will\
    \ be in one of these two subarrays. The index of the maximum of the left subarray\
    \ is called leftMax, while the index of the maximum of the right subarray is called\
    \ rightMax. leftMax is always smaller than rightMax. To find the index of the\
    \ maximum element in the left subarray, we start partitioning left until leftMax\
    \ is the last element of left. Similarly, to find the index of the maximum element\
    \ in the right subarray, we start partitioning right until rightMax is the last\
    \ element of right. These indices are called leftMaxIndex and rightMaxIndex.\n\
    \nAfter partitioning the array arr, this process will be repeated until the length\
    \ of arr is less than k. The maximum element in the left subarray will be arr[leftMax],\
    \ the maximum element in the right subarray will be arr[rightMax]. After we find\
    \ the maximum element in the left and right subarrays, we swap the maximum element\
    \ with arr[rightMaxIndex] and arr[leftMaxIndex] respectively. Then, we repeat\
    \ the process until arr is down to k elements. This process will be repeated until\
    \ arr[leftMaxIndex] == arr[rightMaxIndex].\n\nWhen k exceeds the length of arr,\
    \ leftMaxIndex and rightMaxIndex will each be equal and no swaps will be necessary.\
    \ So, the final array will consist of k elements. Each of these k elements will\
    \ either be the maximum in the left subarray or the maximum in the right subarray.\
    \ Since our goal is to find the maximum of k elements, we just have to return\
    \ the final array.\n\n\n</text>\n<cell>", "    \n    arr_sorted = sorted(arr)\n\
    \    return arr_sorted[k:]\n", "    # Fill this in.\n    maximums = []\n    for\
    \ i in range(k):\n        max_idx = arr.index(max(arr))\n        maximums.append(arr.pop(max_idx))\n\
    \    \n    return maximums\n\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\nprint(maximum([-3,\
    \ -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1,\
    \ -2, 1], 0))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], -1))\n</cell>\n<cell>",
  "    pass\n", "    return heapq.nlargest(k, arr)\n", "    pass\n", "    pass\n",
  "    pass\n", "    pass\n", "    pass\n    # Write your code here\n", "    if k\
    \ == 0 or k > len(arr):\n        return []\n    left, right = 0, len(arr) - 1\n\
    \    while left < right:\n        # Find the middle element and swap with the\
    \ maximum\n        mid = (left + right) // 2\n        if arr[mid] > arr[mid+1]:\n\
    \            arr[mid], arr[mid+1] = arr[mid+1], arr[mid]\n        # Update the\
    \ two sides\n        if mid < k - 1:\n            left = mid+1\n        elif mid\
    \ > k - 1:\n            right = mid\n    # Sort the right half of the array only\n\
    \    return sorted(arr[k - 1:])\n    \n", "    from copy import copy\n    arr\
    \ = copy(arr)\n    if k >= len(arr):\n        return arr\n    arr.sort()\n   \
    \ res = []\n    for i in range(len(arr)):\n        if i > 0 and arr[i-1] > arr[i]:\n\
    \            res.append(arr[i])\n    res.append(arr[-1])\n    return res\n", " \
    \   arr = sorted(arr)\n    if k == 1:\n        return [arr[0]] if not arr else\
    \ []\n    \n    start = k\n    end = len(arr)\n    while start < end:\n      \
    \  if start == end:\n            break\n        if arr[start] > arr[(end - 1)]:\n\
    \            end = start + 1\n        else:\n            start = end + 1\n\n \
    \   return arr[:start] + arr[k:]\n", "    def findMax(arr, k):\n        maxIndex\
    \ = -1\n        for i in range(len(arr)):\n            if maxIndex < arr[i] and\
    \ arr[i] > k and arr[i] != -1:\n                maxIndex = arr[i]\n          \
    \      arr[i] = k\n\n        return arr\n\n    arr = findMax(arr, k)\n    return\
    \ arr\n</cell>\n<cell>\narr = [-1, -2, 2, 5, -4, 7, -6, -1]\nk = 3\n</cell>\n\
    <cell>", "    def max_helper(nums: List[int], k: int) -> List[int]:\n        if\
    \ k == 0 or len(nums) == 0:\n            return nums\n\n        if len(nums) ==\
    \ 1:\n            return [nums[0]]\n\n        max_value = nums[-1]\n        max_indexes\
    \ = []\n\n        for index, value in enumerate(nums):\n            if value >\
    \ max_value:\n                max_value = value\n                max_indexes =\
    \ [index]\n\n            elif value == max_value and index not in max_indexes:\n\
    \                max_indexes.append(index)\n\n        return max_helper(nums[:-max_indexes.pop()],\
    \ k) + max_indexes\n\n    return max_helper(arr, k)\n", "    def max_sub(arr,\
    \ k):\n        if k <= 0:\n            return None\n        if k == 1:\n     \
    \       arr = sorted(arr)\n            return arr\n        mid = len(arr) // 2\n\
    \        left = arr[:mid]\n        right = arr[mid:]\n        leftSub = max_sub(left,\
    \ k-1)\n        rightSub = max_sub(right, k-1)\n        return rightSub or leftSub\n\
    \n    return max_sub(arr, k)\n", "    \n    max_num = []\n    for num in arr:\n\
    \        if num > max_num[-1]:\n            max_num.append(num)\n        else:\n\
    \            while len(max_num) < k:\n                max_num.append(max_num[-1])\n\
    \    return max_num\n</cell>\n<text>\nMaximum Subarray\n\n</text>\n<text>\nLet's\
    \ implement the maximum subarray problem here. \nGiven an array of integers, find\
    \ the contiguous subarray within an array (containing at least one number) which\
    \ has the largest sum.\n\nExample 1:\n\nInput: [-2,1,-3,4,-1,2,1,-5,4], k = 4\n\
    Output: [-2,1,-3,4,-1]\n\nExplanation: The sum of the maximum subarray is 10 (10-2+3+4+1\
    \ = 10).\n             The contiguous subarray [4,-1,2,1] has the largest sum\
    \ = 4.\n\nExample 2:\n\nInput: [-2,1,-3,4,-1,2,1,-5,4], k = 2\nOutput: [-2,1,-3,4]\n\
    \nExplanation: The sum of the maximum subarray is 7 (7-2+3+4 = 7).\n         \
    \    The contiguous subarray [4,-1,2,1] has the largest sum = 4.\n\n\n</text>\n\
    <cell>", "    # todo write your code here\n    \n    if len(arr) < 1:\n      \
    \  return []\n    elif k >= len(arr):\n        return [arr[0]]\n    else:\n  \
    \      max_heap = []\n        while len(max_heap) < k:\n            heapq.heappop(max_heap)\n\
    \        for num in arr:\n            heapq.heappush(max_heap, -num)\n       \
    \ return [num for num in max_heap]\n\n", "    \n    # code here\n    return sorted(arr)[-k:]\n",
  "    if k <= 0 or len(arr) <= k:\n        return []\n    if k == 1 and arr[0] >=\
    \ 0:\n        return [0]\n    length = len(arr)\n    res = []\n    i = k\n   \
    \ while k >= i:\n        res.append(arr[i])\n        i -= 1\n    if k == i:\n\
    \        i += 1\n    return res\n\n", "    size = len(arr)\n    if not (0 < k\
    \ <= size):\n        return None\n    max_heap = [0] * (k+1)\n    max_heap[0]\
    \ = arr[0]\n    for i in range(1, size):\n        if arr[i] > max_heap[k]:\n \
    \           max_heap[k] = arr[i]\n            k -= 1\n            max_heapify(arr,\
    \ k, max_heap)\n    sorted_arr = []\n    for i in range(k+1):\n        sorted_arr.append(max_heap[i])\n\
    \    return sorted_arr\n", "    return sorted(arr, key=lambda x: x if x > k else\
    \ -k)[0]\n\n", "    pass\n", "    # \u65B9\u6CD5\u4E00\uFF1A\u76F4\u63A5\u6BD4\
    \u8F83\u6392\u5E8F\n    if len(arr) == 1:\n        return arr\n    length = len(arr)\n\
    \    arr.sort()\n    arr = [arr[i] for i in range(length - k + 1)]\n    arr.sort()\n\
    \    return arr\n", "    i = 0\n    max_list = []\n    while i < k:\n        max_list.append(max(arr))\n\
    \        i += 1\n    return max_list\n", "    k = max(1, k)\n    if k > len(arr):\n\
    \        return arr\n    arr = sorted(arr)\n    sorted_arr = arr[:k]\n    return\
    \ sorted_arr\n", "    import heapq\n    \n    heapq.heapify(arr)\n    return [arr[0],\
    \ heapq.heappop(heapq.nlargest(1, arr))[0]]\n    ", "    len_list = len(arr)\n\
    \    k, max_num, max_num = 0, arr[0], arr[0]\n    for i in range(len_list):\n\
    \        if max_num < arr[i]:\n            max_num = arr[i]\n            k = i\n\
    \        else:\n            if k == max_len:\n                return []\n    return\
    \ arr[k:]\n", "    max_elements = []\n    for value in arr:\n        max_elements.append(value)\n\
    \    \n    if k > len(max_elements):\n        k = k - len(max_elements)\n\n  \
    \  for _ in range(k):\n        max_elements.append(0)\n    \n    max_elements\
    \ = sorted(max_elements)\n\n    maximums = []\n    for value in max_elements:\n\
    \        maximums.append(value)\n\n    return maximums\n</cell>\n<text>\n\u6700\
    \u5927\u5143\u7D20\u7684\u4E00\u79CD\u7B97\u6CD5\n\u7528\u4E00\u4E2A\u6570\u7EC4\
    \u6765\u5B58\u653E\u4E00\u7EC4\u5143\u7D20\u7684\u6700\u5927\u5143\u7D20\uFF0C\
    \u7136\u540E\u5229\u7528\u8FD9\u4E2A\u6570\u7EC4\u53BB\u67E5\u8BE2\u5143\u7D20\
    \u3002\n\n\n</text>\n<cell>", "    \n    # initialize result array with k empty\
    \ slots\n    result = [None] * k\n    \n    # sort arr in descending order\n \
    \   arr = sorted(arr, key=lambda item: -item)\n\n    # add first k numbers from\
    \ arr to result\n    result[0:k] = arr[0:k]\n\n    # append remaining numbers\
    \ from arr to the end of result\n    for i in range(k, len(arr)):\n        result[i-k]\
    \ = arr[i]\n\n    # return the result array\n    return result\n", "    \n   \
    \ return sorted(arr)[-k:]\n", "    max_num = arr[0]\n    maximums = []\n    for\
    \ i in range(k-1):\n        if arr[i] > max_num:\n            max_num = arr[i]\n\
    \        maximums.append(max_num)\n    max_num = arr[k]\n    maximums.append(max_num)\n\
    \    return maximums\n", "    if k > len(arr):\n        k = len(arr)\n    if k\
    \ == 1:\n        return [arr[0]]\n\n    if k > 1:\n        max_arr = maximum(arr,\
    \ k-1)\n        if max_arr[0] > arr[-1]:\n            max_arr.reverse()\n    \
    \    return [arr[0]] + max_arr\n\n    return arr\n\n", "    stack = []\n    res\
    \ = []\n    size = len(arr)\n\n    for i in range(size):\n        while len(stack)\
    \ and arr[i] > stack[-1]:\n            res.append(stack.pop())\n        stack.append(arr[i])\n\
    \        if len(stack) == k:\n            res.append(stack.pop())\n\n    return\
    \ res\n</cell>\n<cell>", "    # write your code here\n    maximum_list = sorted(arr,\
    \ reverse=True)[:k]\n    return maximum_list\n", "    \n    import math\n\n  \
    \  if k == 0:\n        return []\n    \n    if k < 0:\n        return []\n\n \
    \   count = len(arr)\n    sorted_arr = sorted(arr)\n    \n    if count == 0:\n\
    \        return []\n    \n    if count % 2 == 1 and k > 1:\n        sorted_arr\
    \ = [sorted_arr[-1]]\n\n    maximum_list = []\n\n    for index in range(0, int(math.ceil(count\
    \ / 2))):\n        maximum_list.append(max(sorted_arr[index:index+k]))\n\n   \
    \ maximum_list.extend(sorted_arr[count - k:count])\n    return maximum_list\n\n",
  "    \n    # Write your code here\n    if len(arr) == 0:\n        return []\n  \
    \  if k > len(arr):\n        k = len(arr)\n        \n    max_so_far = []\n   \
    \ for idx in range(k):\n        max_so_far.append(arr[idx])\n        \n    max_so_far.sort()\n\
    \    \n    \n    return max_so_far\n</cell>\n<text>\nmaximum([2, 3, -10, 20, 3,\
    \ -10, -2, 100], 3)\n\n</text>\n<cell>\narr = [2, 3, -10, 20, 3, -10, -2, 100]\n\
    k = 3\n\narr2 = maximum( arr, k )\n\nprint( arr2 )\n</cell>\n<cell>\narr2\n</cell>\n\
    <cell>\narr1 = maximum( arr, k )\n\narr1\n</cell>\n<text>\nmaximum( [ 1, -2, -3\
    \ ], 1 )\n\n</text>\n<cell>\narr1 = [1, -2, -3]\nk = 1\n\narr2 = maximum( arr1,\
    \ k )\n\narr2\n</cell>\n<cell>\narr1\n</cell>\n<text>\nmaximum( [ 1, 2, 3, 4,\
    \ 5 ], 2 )\n\n</text>\n<cell>\narr2 = [1, -2, -3]\nk = 2\n\narr3 = maximum( arr2,\
    \ k )\n\narr3\n</cell>\n<cell>\narr2\n</cell>\n<text>\nmaximum( [ 1, 2, 3, 4,\
    \ 5 ], 3 )\n\n</text>\n<cell>\narr3 = [1, -2, -3]\nk = 3\n\narr4 = maximum( arr3,\
    \ k )\n\narr4\n</cell>\n<cell>\narr3\n</cell>\n<cell>\narr2\n</cell>\n<text>\n\
    maximum( [ 1, 2, 3, 4, 5 ], 4 )\n\n</text>\n<cell>\narr4 = [1, -2, -3]\nk = 4\n\
    \narr5 = maximum( arr4, k )\n\narr5\n</cell>\n<cell>\narr4\n</cell>\n<text>\n\
    maximum( [ 1, 2, 3, 4, 5 ], 5 )\n\n</text>\n<cell>\narr5 = [1, -2, -3]\nk = 5\n\
    \narr6 = maximum( arr5, k )\n\narr6\n</cell>\n<cell>\narr5\n</cell>\n<cell>\n\
    arr4\n</cell>\n<text>\nmaximum( [ 1, 2, 3, 4, 5 ], 6 )\n\n</text>\n<cell>\narr6\
    \ = [1, -2, -3]\nk = 6\n\narr7 = maximum( arr6, k )\n\narr7\n</cell>\n<cell>\n\
    arr6\n</cell>\n<cell>", "    if k > len(arr):\n        raise IndexError(\"k is\
    \ larger than the length of the list\")\n\n    if k == 0:\n        return arr\n\
    \    \n    if k == 1:\n        arr.append(arr[k-1])\n        return arr\n    \
    \    \n    mid = 0\n    maximum = arr[0]\n    length = len(arr)\n\n    while mid\
    \ < len(arr)-k:\n        if arr[mid + k] > maximum:\n            maximum = arr[mid\
    \ + k]\n            mid += 1\n        else:\n            mid += 1\n    \n    if\
    \ mid < len(arr)-k:\n        for i in range(mid,mid+k):\n            arr[i] =\
    \ maximum\n    else:\n        for i in range(mid,length):\n            arr[i]\
    \ = maximum\n    \n    return arr\n    ", "    length = len(arr)\n    if length\
    \ < k or k > length:\n        return []\n    \n    max_list = arr[:k]\n    for\
    \ i in range(k, length):\n        max_list.append(max(max_list[-1], arr[i]))\n\
    \    return max_list\n", "    left = 0\n    right = min(len(arr), k)\n    max_list\
    \ = []\n    while right - left > 1:\n        max_list.append(max(arr[left:right+1]))\n\
    \        left += 1\n        right -= 1\n    return max_list\n", "    return sorted(arr)[-k:]\n",
  "    ans = []\n    \n    # write your code here\n    for num in arr:\n        ans.append(num)\n\
    \    \n    return ans\n", "    my_dict = {}\n    for num in arr:\n        if num\
    \ in my_dict:\n            my_dict[num] = my_dict[num] + 1\n        else:\n  \
    \          my_dict[num] = 1\n    \n    \n    for num in my_dict:\n        if my_dict[num]\
    \ > k:\n            my_dict[num] = k\n    \n    sorted_list = []\n    for num\
    \ in my_dict:\n        sorted_list.append(num)\n    \n    return sorted_list\n",
  "    \n    return sorted(arr, key=lambda x: -x)[:k]\n", "    # Solution 1: sort\
    \ the array and return the k largest elements.\n    # Solution 2: find the max\
    \ in a list, return that list.\n\n    arr_sorted = sorted(arr)\n    return arr_sorted[-k:]\n",
  "    max_num = max(arr)\n    \n    left_index = 0\n    right_index = len(arr)-1\n\
    \    while left_index <= right_index:\n        mid_index = (left_index+right_index)\
    \ // 2\n        if arr[mid_index] > max_num:\n            right_index = mid_index\n\
    \        elif arr[mid_index] < max_num:\n            left_index = mid_index\n\
    \        else:\n            return arr[:mid_index+1]\n    return arr[:right_index+1]\n\
    </cell>\n<cell>\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\nprint(maximum([-3,\
    \ -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, -2, 3], 3))\n\
    </cell>\n<text>\n\u8BF7\u4F7F\u7528\u51FD\u6570\u5B9E\u73B0\u5728 arr \u4E2D\u7684\
    \ kth \u5927\u7684\u5143\u7D20\u3002\n\n\u6CE8\u610F:\n\n    0 <= k <= len(arr)\n\
    \n</text>\n<cell>", "    arr = sorted(arr)\n    return arr[-k:]\n", "    max_nums\
    \ = [0] * (k + 1)\n    max_nums[0] = arr[0]\n    for i in range(1, len(arr)):\n\
    \        if max_nums[i] > arr[i]:\n            max_nums[i] = arr[i]\n\n    for\
    \ i in range(1, k + 1):\n        max_nums[i] = max(max_nums[i-1], max_nums[i])\n\
    \n    return max_nums\n", "    arr2, max_arr = [], []\n    for num in arr:\n \
    \       if num > max_arr[-1]:\n            max_arr.append(num)\n        else:\n\
    \            arr2.append(num)\n            if k == len(arr2):\n              \
    \  max_arr = arr2\n                arr2 = []\n    \n    return max_arr\n    \n",
  "    max_length = k\n    if k == 0: return []\n    # Find the index of the first\
    \ element that is larger than the second element\n    for i in range(1, len(arr)):\n\
    \        if arr[i] > arr[i-1]:\n            max_length = i\n            break\n\
    \    # Copy the array and insert it in the correct place\n    arr[:max_length]\
    \ = arr[max_length:max_length+k] = arr[:max_length][:k]\n    return arr\n</cell>\n\
    <text>\nGreedy\n\n</text>\n<cell>", "    \n    # O(N * log(N)) solution\n    #\
    \ Runtime: 206 ms, faster than 93.44% of Python3 online submissions\n    # Runtime:\
    \ 206 ms, faster than 93.44% of Python3 online submissions\n    \n    # O(N) solution\n\
    \    # Runtime: 50.34 ms, faster than 89.61% of Python3 online submissions\n \
    \   # Runtime: 50.34 ms, faster than 89.61% of Python3 online submissions\n  \
    \  \n    # Sort the list\n    arr.sort()\n\n    # Initialize a new list\n    max_list\
    \ = [arr[0]]\n\n    # Scan over the array\n    i = 0\n    while i < len(arr):\n\
    \        if arr[i] > max_list[-1]:\n            max_list.append(arr[i])\n    \
    \    i += 1\n\n    # Add the last element\n    max_list.append(arr[-1])\n\n  \
    \  # Return the result\n    return max_list[:k]\n\n", "    from heapq import heappush,\
    \ heappop\n    from functools import reduce\n    \n    heap = []\n    \n    for\
    \ num in arr:\n        heappush(heap, -num)\n    \n    while k:\n        elem\
    \ = heappop(heap)\n        k -= 1\n        \n        heappush(heap, -elem)\n \
    \       \n    if k > 0:\n        elem = heappop(heap)\n        heappush(heap,\
    \ -elem)\n        \n    return list(reversed(heap))\n", "    from heapq import\
    \ heappush, heappop\n    \n    k = k if k <= len(arr) else len(arr)\n\n    arr\
    \ = list(map(lambda x: x-1000 if x < -1000 else x, arr))\n\n    heap = [(-1000,\
    \ x, False) for x in arr]\n    heapq.heapify(heap)\n\n    sorted_list = list()\n\
    \n    while len(heap) > 0 and k != 0:\n        temp = heappop(heap)[1]\n     \
    \   sorted_list.append(temp)\n        k -= 1\n    \n    return sorted_list\n",
  "    \n    if k == 1:\n        return arr\n    \n    if len(arr) <= k:\n       \
    \ return arr\n    \n    max_num = arr[0]\n    \n    for i in range(1, len(arr)):\n\
    \        if arr[i] > max_num:\n            max_num = arr[i]\n    \n    return\
    \ arr[0:k]\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\n</cell>\n\
    <cell>\nmaximum(arr, k)\n</cell>\n<cell>", "    if k == len(arr):\n        return\
    \ arr\n\n    m = max(arr)\n    arr.remove(m)\n\n    if len(arr) <= k:\n      \
    \  return arr\n\n    return [m] + maximum(arr, k - 1)\n", "    # Write your code\
    \ here\n    n = len(arr)\n    if k > n:\n        k = n\n    elif k <= 0 or n <=\
    \ k:\n        return arr\n    \n    max_values = []\n    max_value = arr[0]\n\
    \    for i in range(n):\n        if arr[i] > max_value:\n            max_values.append(max_value)\n\
    \            max_value = arr[i]\n        else:\n            max_value = arr[i]\n\
    \    return max_values[:k] \n    \n", "    # Your code here\n    temp = [0] *\
    \ (k+1)\n    for i in arr:\n        if temp[i] < i:\n            temp[i] = i\n\
    \    return temp[0:k]\n</cell>\n<text>\nGreedy\n\n</text>\n<text>\nGreedy algorithms\
    \ find the optimal solution without considering sub-optimal solutions first.\n\
    \nThe greedy algorithms generally follow the steps below:\n\nRandomly pick an\
    \ item from the available options\nRemove that item from the available options\
    \ list\nRepeat until there are only remaining options\n\nThe process is repeated\
    \ until there are no options to choose from.\n\nExample 1:\n\nInput: [1, 2, 3],\
    \ k = 3\nOutput: [1, 2, 3]\n\nExample 2:\n\nInput: [10, 1, 1], k = 5\nOutput:\
    \ [10, 1]\n\nExplanation: Here, there are two possible sub-optimal solutions,\
    \ one with value 10 and one with value 1. \nThe greedy algorithm chooses the one\
    \ with value 1 since that is the best and hence the output will be [10, 1].\n\n\
    \n</text>\n<text>\nGreedy Approach\nWe have to find the maximum element of the\
    \ given array using the following process:\n\nPick a random index between 0 and\
    \ the length of array.\nTake the element from the array at that index.\nRemove\
    \ the element from the array at that index.\nRepeat steps 1 to 3 until there are\
    \ no elements left.\n\n\n</text>\n<text>\nPython program to find the maximum element\
    \ in a given array using greedy algorithm.\n\n</text>\n<cell>", "    max_num =\
    \ arr[0]\n    for i in range(1, k):\n        if arr[i] > max_num:\n          \
    \  max_num = arr[i]\n            \n    sorted_nums = arr[0 : k]\n    sorted_nums.append(max_num)\n\
    \    return sorted_nums\n</cell>\n<text>\nProblem 8\nGiven an input number N,\
    \ generate a square matrix of size N x N such that each cell has the value either\
    \ 1 or 0 depending on if its value can be expressed as sum of two 3-digit numbers.\n\
    \nFor example, given N = 3, output should be:\n\n[\n  [1, 1, 1],\n  [1, 0, 1],\n\
    \  [1, 1, 1]\n]\n\n</text>\n<cell>", "    pass\n\n", "    # Write your code here\n\
    \    count = 0\n    arr = [item for item in arr]\n    k = k\n    if k >= len(arr):\n\
    \        k = len(arr)\n    while count < k:\n        arr.append(max(arr))\n  \
    \      count += 1\n    return arr\n    ", "    \n    # Solution using in-built\
    \ python functions max and sort\n    max_value, max_idx, max_list = 0, 0, []\n\
    \    for i in range(len(arr)):\n        if arr[i] > max_value:\n            max_value\
    \ = arr[i]\n            max_idx = i\n            max_list = [arr[i]]\n       \
    \ elif arr[i] == max_value:\n            max_list.append(arr[i])\n        else:\
    \ \n            max_list.append(arr[i])\n            \n    max_list.reverse()\n\
    \    return max_list[:k]\n", "    # write your code here\n    result = []\n  \
    \  maximum = 0\n    for num in arr:\n        if num > maximum:\n            maximum\
    \ = num\n    result.append(maximum)\n    return result\n\n", "    return sorted(arr)[-k:]\n",
  "    pass\n</cell>\n<text>\n1.3.2 Subset\nGiven two arrays arr1 and arr2, write\
    \ a function which takes two arrays as arguments and return True if arr1 is a\
    \ subset of arr2 and False otherwise.\n\nThe function should return False if the\
    \ given arrays are of different length.\n\nThe function should return True if\
    \ the given arrays are of the same length.\n\nExamples:\n\narr1 = [1, 2], arr2\
    \ = []\narr1 = [1], arr2 = []\narr1 = [], arr2 = [1, 2]\narr1 = [], arr2 = []\n\
    \n</text>\n<cell>", "    return sorted(arr, key=lambda x: -x)[:k]\n", "    if\
    \ not arr or not k:\n        return []\n    arr = sorted(arr)\n    return arr[k:]\n",
  "    if k == 0: return arr\n    maximums = []\n    for element in arr:\n       \
    \ if len(maximums) < k - 1:\n            maximums.append(element)\n        else:\n\
    \            if element > maximums[-1]:\n                maximums.append(element)\n\
    \    maximums.sort()\n    return maximums\n", "    \n    if len(arr) == 0:\n \
    \       return []\n    else:\n        res_arr = []\n        left = arr[0]\n  \
    \      for i in range(1,len(arr)):\n            if arr[i] > left:\n          \
    \      res_arr.append(left)\n                left = arr[i]\n            else:\n\
    \                left = arr[i]\n        res_arr.append(left)\n        return res_arr\n",
  "    if not arr or not k or k < 0:\n        return []\n\n    k, max_element = k,\
    \ arr[0]\n    heapq.heapify(arr)\n    sorted_arr = []\n    while arr:\n      \
    \  if len(sorted_arr) < k:\n            heapq.heappop(arr)\n            sorted_arr.append(arr[0])\n\
    \        arr.remove(max(arr, key=lambda a: abs(a - max_element)))\n        max_element\
    \ = max(arr, key=lambda a: abs(a - max_element))\n\n    return sorted_arr\n",
  "    arr = sorted(arr)\n    \n    length = min(len(arr), k)\n    return arr[-length:]\n",
  "    pass\n", "    # \u6700\u5927\u503C\u6307\u793A\u5668\n    maxNum = arr[0]\n\
    \    # \u6700\u5927\u6570\u7EC4\u7684\u957F\u5EA6\n    maxIndex = 0\n\n    for\
    \ i in range(1, len(arr)):\n        # \u5982\u679C\u5F53\u524D\u7684\u6570\u5B57\
    \u5927\u4E8E\u6700\u5927\u6570\u5B57\n        if arr[i] > maxNum:\n          \
    \  # \u5C06\u6700\u5927\u6570\u5B57\u653E\u5230\u6700\u5927\u6570\u7EC4\u7684\u672B\
    \u5C3E\n            maxNum = arr[i]\n            # \u5C06\u6700\u5927\u6570\u7EC4\
    \u7684\u957F\u5EA6\u66F4\u65B0\n            maxIndex = i\n\n    # \u5C06\u6700\
    \u5927\u6570\u7EC4\u7684\u672B\u5C3E\u5269\u4E0B\u7684\u6570\u5B57\u590D\u5236\
    \u5230\u6700\u540E\u9762\n    tempList = arr[0:maxIndex + 1]\n    return tempList\n\
    </cell>\n<cell>", "    n = len(arr)\n    if n < 1:\n        return []\n    if\
    \ k == 0 or k > n:\n        return arr\n    k = min(k, n - 1)\n    i, j = 0, n\
    \ - k\n    if arr[i] > arr[j]:\n        i, j = j, i\n    res = arr[i:j + 1]\n\
    \    if len(res) > k:\n        return res[:k]\n    else:\n        return res\n",
  "    pass\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
