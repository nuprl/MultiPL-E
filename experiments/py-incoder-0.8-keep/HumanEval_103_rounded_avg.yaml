name: HumanEval_103_rounded_avg
language: py
prompt: "from typing import Union\n\ndef rounded_avg(n: int, m: int) -> Union[str,\
  \ int]:\n    \"\"\"You are given two positive integers n and m, and your task is\
  \ to compute the\n    average of the integers from n through m (including n and\
  \ m). \n    Round the answer to the nearest integer and convert that to binary.\n\
  \    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) =>\
  \ \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n\
  \    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(1, 5) == '0b11'\n    assert candidate(7,\
  \ 13) == '0b1010'\n    assert candidate(964, 977) == '0b1111001010'\n    assert\
  \ candidate(996, 997) == '0b1111100100'\n    assert candidate(560, 851) == '0b1011000010'\n\
  \    assert candidate(185, 546) == '0b101101110'\n    assert candidate(362, 496)\
  \ == '0b110101101'\n    assert candidate(350, 902) == '0b1001110010'\n    assert\
  \ candidate(197, 233) == '0b11010111'\n    assert candidate(7, 5) == -1\n    assert\
  \ candidate(5, 1) == -1\n    assert candidate(5, 5) == '0b101'\n\ndef test_check():\n\
  \    check(rounded_avg)\n\ntest_check()\n"
completions: ["    # assert (m > n)\n    avg = n // m\n    binary = f\"0{avg:b}\"\n\
    \    if n < m:\n        return -1\n    else:\n        return binary\n", "    if\
    \ n is m:\n        return \"0b\" + str(n)\n    \n    if n < m:\n        return\
    \ -1\n    else:\n        avg = n // m\n        count = 0\n        binary = 0\n\
    \        while count <= avg:\n            binary = binary + 2**count\n       \
    \     count = count + 1\n        return \"0b\" + str(binary)\n\n", "    if n <\
    \ m:\n        return -1\n    return bin(n//m).replace('0b', '')\n", "    if n\
    \ <= m:\n        return str(bin(n)[2:]) if n else -1\n    return str(bin(m+n-2)[2:])\n\
    </cell>\n<cell>", "    \n    if n > m:\n        return -1\n    else:\n       \
    \ \n        binary = 0\n        \n        for i in range(n, m+1):\n          \
    \  binary += (2**i) % 2\n        \n        rounded_binary = binary % 2\n     \
    \   return str(rounded_binary)\n\n\n\"\"\"\n--- Day 6: School System ---\n\nA\
    \ school system starts with a group of people, numbered 1 through N.\nEach person\
    \ has a unique name, and is denoted with a letter:\n    A: Alice\n    B: Bob\n\
    \    ...\n    Z: Zulu\nYour school system assigns people to one of two roles,\
    \ teaching or \n    not. Teaching is denoted by T, not by any other letter.\n\
    \    \nThe teaching system has a couple of rules:\n    Each person can teach another\
    \ person at most once.\n    Each person can teach no one more than once.\n   \
    \ Teaching must be consecutive.\n    Teaching must be from person to person.\n\
    \    Each person can only be taught by him/herself.\n    When two people are taught\
    \ consecutively, there is a time when the \n    pair is allowed to switch roles.\
    \ \n    When two people are taught in that order, there is a time when \n    the\
    \ pair is allowed to switch roles.\n    There are N people numbered 1 through\
    \ N.\n    \nFor example, suppose N = 3 and the following teaching assignments\
    \ are given:\n    AB, AC, AD, AE\n    AE, AB, AC, AD\n    AB, AC, AD, AE\n   \
    \ AC, AD, AE, AB\nThe system should answer the following question:\n    There\
    \ are 5 teachers and 3 students.\n    Which of the following statements is true?\n\
    \    \n    1. There are 3 teachers and 5 students.\n    2. All teachers are taught\
    \ consecutively.\n    3. There are 2 teachers and 3 students.\n    4. There are\
    \ 3 teachers and 2 students.\n    5. There are 3 teachers and 4 students.\n  \
    \  \n    Answer each of the following statements with a yes or no answer:\n  \
    \  1. yes\n    2. yes\n    3. yes\n    4. yes\n    5. yes\n    \n    Example 2:\n\
    \    AB, AC, AD, AE\n    AE, AB, AC, AD\n    AB, AC, AD, AE\n    AC, AD, AE, AB\n\
    \    There are 5 teachers and 4 students.\n    Which of the following statements\
    \ is true?\n    \n    1. All teachers are taught consecu", "    assert n >= m\n\
    \    \n    if n == m:\n        return \"0b\" + str(bin(n)[2:].rjust(4,\"0\"))\n\
    \    elif n < m:\n        return -1\n    else:\n        ans = -1\n        while\
    \ n <= m:\n            ans = ans*2 + (n - m)%2\n            n += 1\n        ans\
    \ = ans/2\n        return str(bin(ans)[2:].rjust(4,\"0\"))\n\nrounded_avg(11,\
    \ 10)\n</cell>\n<text>\nThe first thing you need to do is define the function\
    \ which can compute the average of a range of numbers. Then run the cell below\
    \ to check that your function works as expected:\n\n\n</text>\n<cell>", "    \n\
    \    # Your code here\n    \n    # Your code here\n    \n    \n    # Your code\
    \ here\n    \n    # Your code here\n    \n    return -1\n\nassert rounded_avg(1,\
    \ 5) == '0b11'\nassert rounded_avg(7, 5) == -1\nassert rounded_avg(10, 20) ==\
    \ '0b1111'\nassert rounded_avg(20, 33) == '0b11010'\n</cell>\n<text>\nNow write\
    \ a function named is_perfect_square.\n\n\n</text>\n<cell>", "    \n    avg =\
    \ ((n + m) // 2) * (1 if n % 2 == 0 else 2)\n    bin = f'{avg:0b}'\n    \n   \
    \ return -1 * int(bin[-len(bin):])\n\nprint(rounded_avg(7, 5)) # -1\nprint(rounded_avg(10,\
    \ 20)) # -1\nprint(rounded_avg(20, 33)) # 1\n</code>\n<|/ a tags=python,python-3.x,math\
    \ |>\n<| c |>\nHow would this be different from other methods?\n<|/ c |>\n<| c\
    \ |>\nIt would not be different, but I thought it was the simplest to understand.\n\
    <|/ c |>\n<| c |>\nI think it is the most straightforward way to code this.\n\
    <|/ c |>\n<| c |>\nThank you for the answer.  I did not really think about the\
    \ case where n=m=1 and then it would return -1 rather than 1.\n<|/ c |>\n<| c\
    \ |>\nThis is also a great answer to a different problem I had.  I did learn some\
    \ things about bin().  I really appreciate your input.\n<|/ c |>\n<| a tags=python,python-3.x,math\
    \ |>\nI like to use bin for converting numbers to binary.\n<code>", "    assert\
    \ m >= n, \"n should be greater than m!\"\n    return f\"{bin(round(n/m - 0.5))[2:]:0{int(math.log(m,2))}}\"\
    \n", "    avg = (n + m) // 2\n    bin = bin(avg).replace('b', '')\n    if bin.count('1')\
    \ % 2 != 0:\n        return -1\n    return bin\n", "    \n    if n < m:\n    \
    \    return -1\n\n    binary_string = bin(n+m)[2:]\n    binary_string = \"\".join(binary_string)\
    \ if binary_string else \"0\"\n    return \"0b\" + binary_string\n", "    \n \
    \   n += 1\n    m += 1\n    \n    \n    if n < m:\n        return -1\n    \n \
    \   result = n // m\n    if n % m == 0:\n        result += 1\n    \n    if result\
    \ < 0:\n        result = -1\n    \n    binary = bin(result).lstrip('0b')\n   \
    \ \n    if m % 2 == 0:\n        binary = binary[:len(binary)-1]\n    \n    return\
    \ binary\n", "    if n >= m:\n        return -1\n    half = (m + n) // 2\n   \
    \ return \"0b\" + (\"1\" * half).rjust(half, '0')\n", "    \n    if n > m:\n \
    \       return -1\n    \n    average = sum(range(n, m+1))//2\n    answer = format(bin(average)[2:],\
    \ \"b\")\n    \n    return answer\n    \nrounded_avg(10, 20) # => -1\nrounded_avg(7,\
    \ 5) # => -1\nrounded_avg(5, 5) # => -1\nrounded_avg(1, 5) # => \"0b11\"\nrounded_avg(2,\
    \ 5) # => \"0b10\"\nrounded_avg(6, 5) # => \"0b110\"\nrounded_avg(3, 5) # => \"\
    0b111\"\nrounded_avg(7, 7) # => -1\nrounded_avg(8, 7) # => -1\nrounded_avg(5,\
    \ 8) # => -1\nrounded_avg(2, 8) # => \"0b101\"\nrounded_avg(1, 8) # => \"0b100\"\
    \nrounded_avg(3, 8) # => \"0b1011\"\nrounded_avg(4, 8) # => \"0b1101\"\nrounded_avg(5,\
    \ 9) # => -1\nrounded_avg(2, 9) # => \"0b101\"\nrounded_avg(6, 9) # => \"0b1101\"\
    \nrounded_avg(5, 10) # => -1\nrounded_avg(3, 10) # => \"0b1011\"\nrounded_avg(9,\
    \ 10) # => \"0b1101\"\nrounded_avg(4, 10) # => \"0b10001\"\nrounded_avg(6, 10)\
    \ # => \"0b10001\"\nrounded_avg(8, 10) # => \"0b10000\"\nrounded_avg(7, 10) #\
    \ => \"0b10000\"\nrounded_avg(9, 10) # => \"0b10000\"\nrounded_avg(11, 10) # =>\
    \ \"0b10000\"\nrounded_avg(12, 10) # => \"0b10000\"\nrounded_avg(14, 10) # =>\
    \ \"0b10000\"\nrounded_avg(16, 10) # => \"0b10000\"\nrounded_avg(18, 10) # =>\
    \ \"0b10000\"\nrounded_avg(19, 10) # => \"0b10000\"\nrounded_avg(23, 10) # =>\
    \ \"0b10000\"\nrounded_avg(24, 10) # => \"0b10000\"\nrounded_avg(25, 10) # =>\
    \ \"0b10000\"\nrounded_avg(26, 10) # => \"0b10000\"\nrounded_avg(29, 10) # =>\
    \ \"0b10000\"\nrounded_avg(30, 10) # => \"0b10000\"\nrounded_avg(31, 10) # =>\
    \ \"0b10000\"\nrounded_avg(33, 10) # => \"0b10000\"\nrounded_avg(38, 10) # =>\
    \ \"0b10000\"\nrounded_avg(39, 10) # => \"0b10000\"\nrounded_avg(49, 10) # =>\
    \ \"", "    \n    if m == 0:\n        return 0\n    if n >= m:\n        return\
    \ -1\n    \n    i = m\n    \n    while i > 0:\n        if n % i == 0:\n      \
    \      return i\n        i -= 1\n    \n    return -1\n", "    if n > m:\n    \
    \    return -1\n    return int2bin(int(round(n/m)))\n</cell>\n<cell>", "    \n\
    \    count = 0\n    total = 0\n    \n    while n <= m:\n        total += n\n \
    \       count += 1\n        n += count + 1\n    \n    return int(total // count)\
    \ if count > 0 else -1\n</cell>\n<cell>", "    \n    return f\"{bin(int(round(n)))}{bin(int(round(m)))}\"\
    \n</cell>\n<text>\nImplement the function in the cell below.\n\n\n</text>\n<cell>",
  "    if m > n:\n        return -1\n    return bin(sum((n-i, i) for i in range(m,\
    \ n+1)).bit_length()+1)[2:]\n", "    if n > m:\n        return -1\n    \n    i\
    \ = n\n    s = 0\n    while i < m:\n        s += i\n        i += 1\n    avg =\
    \ s/(m-n+1)\n    \n    return \"0b{}\".format(bin(avg)[2:])\n", "    \n    if\
    \ n == m:\n        return str(n)\n    elif n >= m:\n        return -1\n    else:\n\
    \        total = 0\n        for i in range(n, m):\n            total += i\n  \
    \      return f\"{total//n}{total%n:0b}\"\n\nprint(rounded_avg(5,6))\nprint(rounded_avg(7,6))\n\
    print(rounded_avg(10,20))\nprint(rounded_avg(20,33))\n</cell>\n<cell>", "    avg\
    \ = (n + m) // 2\n    binary = bin(avg)[2:].zfill(8)\n    if avg == n:\n     \
    \   return \"0b\" + binary\n    elif avg > n:\n        return -1\n    return binary\n",
  "    numbers = [n, m]\n    if n > m:\n        numbers = numbers[::-1]\n    rounded_number\
    \ = sum(numbers[len(numbers)-1:])\n    return bin(rounded_number)[2:]\n", "  \
    \  if n > m:\n        return -1\n\n    return \"0b\" + bin(n + m).count(\"1\"\
    ) + \"0\"\n", "    if n == m:\n        return \"0\"\n    elif n <= m:\n      \
    \  return bin(n-m)[2:].zfill(m)\n    else:\n        return -1\n\n", "    return\
    \ bin(int(round(n/m)))[2:]\n</cell>\n<cell>", "    n, m = map(int, (n, m))\n \
    \   if n < m:\n        return -1\n    n -= m\n    result = 1\n    while n > 0:\n\
    \        result *= 2\n        n -= 1\n    return result\n    \n", "    \n    answer\
    \ = ''\n    for i in range(n, m + 1):\n        if i == n:\n            answer\
    \ += '0'\n            \n        elif i > n:\n            answer += '1'\n     \
    \   else:\n            answer += '0'\n\n    return answer\n\n", "    if not n\
    \ and not m:\n        return -1\n    if not n and not m:\n        return 0\n \
    \   avg = n + (m-1) # to ensure n <= m\n    # find out if rounded number will\
    \ be greater than m\n    bits = bin(avg)[2:].zfill(m)\n    binstring = \"\".join(bits)\n\
    \    if int(binstring, 2) > m:\n        return -1\n    return int(binstring, 2)\n\
    </cell>\n<text>\nLet's check your work. Your function call should give '0b11'\
    \ as the output. We first check that n is between 0 and 10 (inclusive), then that\
    \ m is between 0 and 11 (inclusive). Then we call the function with these inputs\
    \ and the expected output 0b11. Notice that the integer is converted back to binary\
    \ for output. This is very important to remember to do when you are debugging.\
    \ The binary representation of a number is a series of 0s and 1s. The number 1\
    \ is the same as \"0b1\". 0 means the number is 0, and so on.\n\n\n</text>\n<cell>\n\
    rounded_avg(8, 8)\n</cell>\n<text>\nOk now for the hard part. Go through this\
    \ function and make sure you understand the process of how it works. Then try\
    \ making modifications in the function above so that it uses while loops to help\
    \ you accomplish the same goal. Don't forget to go through all of your modified\
    \ version and make sure they work before moving onto the next problem.\n\nHint:\n\
    \n\n</text>\n<cell>", "    if n > m:\n        return -1\n    \n    if n%2 == 1:\n\
    \        return -1\n    \n    else:\n        # Find remainder\n        r = n//2\n\
    \        # Divide by 2\n        r2 = r//2\n        # Add remainder of n/2\n  \
    \      r += 1\n        # Convert to binary\n        binrr = bin(r)[2:]\n     \
    \   # Add remainder of n/2\n        binr += binr2\n        \n        # Return\
    \ binary with rounded up\n        return f\"{binrr}0\"\n\n", "    \n    if m >\
    \ n:\n        return -1\n    \n    step = (2 ** (len(bin(n)) - 1))\n    \n   \
    \ return (n + (m * step)) // step\n\n", "    if n>=m:\n        return -1\n   \
    \ if n<m:\n        return -1\n    else:\n        return (bin(m)[2:] + '0'+bin(n)[2:])\n\
    \nassert rounded_avg(7,5) == -1\nassert rounded_avg(10,20) == \"0b1111\"\nassert\
    \ rounded_avg(20,33) == \"0b11010\"\n", "    \n    # Your code here\n    \n  \
    \  return \"\"\n", "    assert n >= m and n <= m\n    if n == m:\n        return\
    \ \"0b\" + f\"0{i:b}\"\n    if n == m:\n        return -1\n    if n == m-1:\n\
    \        return \"0b0\"\n    if n == m+1:\n        return \"0b1\"\n    return\
    \ rounded_avg(n+1, m) + str(n % 2)\n", "    \n    return -1\n", "    if n < m:\n\
    \        return -1\n    \n    avg = 0\n    \n    for num in range(n + 1 - m, n\
    \ - m, -1):\n        avg += num\n        \n    avg = round(avg / n, 2) * int(n)\n\
    \    \n    if int(avg) == avg:\n        avg = int(avg)\n        \n    avg = bin(avg)[2:]\n\
    \    \n    return f\"{avg}{n}\" if avg else f\"{n}\"\n</cell>\n<cell>\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\nprint(rounded_avg(30, 60))\nprint(rounded_avg(50, 100))\n</cell>\n<text>\n\
    Problem 2.2\nWrite a Python program to check if a given number is a palindrome\
    \ or not. \nA palindrome is a word, number, or other sequence of symbols which\
    \ reads the same backward as forward\nfrom left to right.\n\nExample\nInput: 121\n\
    Output: True\n\nInput: 1221\nOutput: True\n\nInput: 12321\nOutput: False\n\nInput:\
    \ 123213241\nOutput: True\n\nInput: abcd\nOutput: False\n\nInput: abcdcba\nOutput:\
    \ True\n\nInput: 132\nOutput: False\n\n</text>\n<cell>", "    \n    # Your code\
    \ here\n    \n    \n    if n >= m:\n        return -1\n    else:\n        return\
    \ bin(int((n+m)/2))[2:]\n</cell>\n<cell>\nrounded_avg(1, 5)\n</cell>\n<cell>\n\
    rounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<text>\nQuestion 8\n\n</text>\n<text>\nWrite a function that takes\
    \ in a positive integer and returns the number of bits set in\nthat integer.\n\
    \nThe function should return a non-negative integer.\n\n\n</text>\n<cell>", " \
    \   return f'{bin(int((n + m) / 2))[2:]}{bin(m)[2:]}'\n\n", "    \n    \n    return\
    \ -1\n", "    if n > m:\n        return \"-1\"\n    \n    else:\n        n = int(n)\n\
    \        m = int(m)\n        # find the average\n        avg = n + (m - n) \n\
    \        # round the average to nearest integer\n        avg = int(round(avg))\n\
    \        # convert to binary\n        binary = format(avg, 'b').zfill(m)\n   \
    \     # return the binary \n        return binary\n", "    i = n\n    sum = 0\n\
    \    while i <= m:\n        sum += i\n        i += 1\n    return -sum % 2 if sum\
    \ > m else sum // 2\n\n", "    return int(\"0b\" + (f\"{n}{m}\" if n < m else\
    \ f\"{n}0{m}\").zfill(8), 2)\n", "    n = str(n)\n    m = str(m)\n    res = (len(m)\
    \ - len(n)) * '0'\n    res = res + m\n    res = res + n\n    return int(res, 2)\n",
  "    assert isinstance(n, int) and isinstance(m, int)\n    if n <= m:\n        return\
    \ -1\n    else:\n        average = n + (m - n)//2\n        return bin(average).replace('0b',\
    \ '')\n</cell>\n<cell>", "    if n < m:\n        return -1\n    return bin(n +\
    \ (m - n))[3:]\n", "    count = 0\n    total = 0\n    for i in range(n):\n   \
    \     total += i\n        if total >= m:\n            count += 1\n           \
    \ total -= m\n    if count == n:\n        if total == m:\n            return \"\
    0b\" + str(total)\n        else:\n            return \"0b0\"\n    elif count ==\
    \ n - 1:\n        return \"0b0\"\n    else:\n        return \"0b1\"\n", "    if\
    \ n > m:\n        return -1\n    return (n + (m // 2)) // m\n", "    \n    if\
    \ m <= n:\n        return -1\n    \n    binary = \"0\"\n    \n    while n <= m:\n\
    \        if n % 2 == 0:\n            binary += \"1\"\n        \n        n //=\
    \ 2\n    \n    return int(binary, 2)\n\n", "    \n    # Implement here.\n\n  \
    \  return None\n", "    \n    binary_value = []\n    \n    if n < m:\n       \
    \ \n        if n == m:\n            return \"0b{}\".format(n)\n        \n    \
    \    binary_value = [n]\n        \n        while n != m:\n            \n     \
    \       n += 1\n            \n            binary_value.append(n)\n        \n \
    \       binary_value.append(m)\n        \n        return \"0b\" + \"1\"*len(binary_value)\
    \ + \"\".join(\"0b\"*len(binary_value) - binary_value)\n\n    else:\n        \n\
    \        if n == m:\n            return -1\n        \n        binary_value.append(n)\n\
    \        binary_value.append(m)\n        \n        return \"0b\" + \"1\"*len(binary_value)\
    \ + \"\".join(\"0b\"*len(binary_value) - binary_value)\n\n", "    if n <= m:\n\
    \        return \"0b0\"\n    elif n >= m:\n        return -1\n    else:\n    \
    \    return \"0b\" + (\"1\" * (n - m))\n", "    \n    # Your code here!\n    #\
    \ Your code here!\n    \n    if n < m:\n        return -1\n    return bin(n-m)[-m]\n\
    \nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\n\
    print(rounded_avg(20, 33))\n</cell>\n<text>\nRounding to the nearest integer\n\
    What if we didn't want the output to include the decimal point? We can round down\
    \ to the nearest integer:\n\n\n</text>\n<cell>", "    return -1 if n >= m else\
    \ (n // m + 1) * f\"{n}0{m}1\"\n\n", "    if n > m:\n        return -1\n    return\
    \ f'{n:0>{m}}'\n</cell>\n<cell>\nrounded_avg(1, 5)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n\
    </cell>\n<text>\nExercise 9\n\n</text>\n<text>\nUse a loop to print the binary\
    \ equivalent of all the integers from 2 to 30 and print a trailing zero if the\
    \ number is odd.\nExample: \nbinary equivalent of 1 to 30: 2\n\n</text>\n<cell>",
  "    if n == m:\n        return \"0b\" + str(bin(n).count(\"1\"))\n    else:\n \
    \       if n >= m:\n            return -1\n        else:\n            n = max(min(n,\
    \ m), 2)\n            bits = \"0\" * (n - 2) + str(bin(n).count(\"1\") - 1) +\
    \ str(bin(m).count(\"1\") + 1)\n            return \"0b\" + bits\n", "    # return\
    \ -1 if n or m are negative\n    if n >= m:\n        return \"-1\"\n    # convert\
    \ to binary, make string and print out last character\n    binary = bin(n - m).replace('b',\
    \ '0')\n    binary_string = str(binary)[-len(str(binary).replace('0b', ''))]\n\
    \    binary_string = '0b' + binary_string\n    return binary_string\n</cell>\n\
    <cell>\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5) == \"-1\"\
    \nassert rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\
    \n</cell>\n<text>\nChallenge Exercise\nLet's get some practice with functions.\
    \ Implement a function called even_or_odd_counts that takes in a list of integers\
    \ and returns True if there are an even number of numbers in the list and False\
    \ if there are an odd number of numbers in the list. For example, even_or_odd_counts([1,\
    \ 2, 3]) should return True. even_or_odd_counts([1, 3, 5]) should return False.\
    \ even_or_odd_counts([4, 6, 8, 10]) should return False.\n\n\n</text>\n<cell>",
  "    if m > n:\n        return -1\n    return f'{math.floor((n + m) / 2)}{bin((n\
    \ + m) / 2)[3:]}'\n\nprint(rounded_avg(1, 5)) \nprint(rounded_avg(7, 5)) \nprint(rounded_avg(10,\
    \ 20)) \nprint(rounded_avg(20, 33))\n</cell>\n<text>\nTask 4 -\nYou will have\
    \ to write a function that receives a positive integer n and returns the sum of\
    \ its digits in binary.\n\nThe result would be a string (without the \"0b\" prefix).\n\
    If the input is negative, return -1.\n\nExamples:\nprint(binary_sum_digits(3))\
    \ # => '10'\nprint(binary_sum_digits(6)) # => '110'\nprint(binary_sum_digits(0))\
    \ # => -1\nprint(binary_sum_digits(-6)) # => -1\n\n</text>\n<cell>", "    # Todo:\
    \ Write your function here\n    \n    if m > n:\n        return -1\n    \n   \
    \ bin = \"\"\n    \n    while m != n:\n        bin+= str(n & 1)\n        n>>=1\n\
    \    \n    return bin\n\n", "    if n < m:\n        return -1\n    else:\n   \
    \     n = int(n)\n        m = int(m)\n        l = list(range(m, n+1))\n      \
    \  return \"\".join(list(map(str, l)))\n\n", "    if n>=m:\n        return -1\n\
    \    res=bin(n//m).replace('0b','')\n    if res.startswith('0b'):\n        res.replace('0b','')\n\
    \    return res\n", "    \n    if n<m:\n        return \"-1\"\n    else:\n   \
    \     return \"0b\"+bin(n-m)[3:] \n\n", "    if n >= m:\n        return \"-1\"\
    \n    elif n <= m:\n        return \"0b\" + bin(n + m - 1).replace(\"0b\", \"\"\
    ).replace(\"L\", \"\")\n    elif n == m:\n        return \"0b\" + bin(n).replace(\"\
    0b\", \"\")\n    else:\n        return \"0b\" + bin(n + m - 1).replace(\"0b\"\
    , \"\")\n", "    if n==m:\n        return bin(n).replace('0b', '')\n    if n<m:\n\
    \        return -1\n    average = n/m\n    count=0\n    binary = bin(average)[2:]\n\
    \    while len(binary)<n:\n        count+=1\n        binary = '0'*count+binary\n\
    \    return binary\n\n", "    i = n\n    s = 0\n    while i > 1:\n        i =\
    \ i // 2\n        s += 1\n    if i == n:\n        return -1\n    return f'{s:b}'\n\
    </cell>\n<text>\nQuestion 6. Write a function that checks if a number is a power\
    \ of two.\n\n\n</text>\n<cell>", "    pass\n\n</cell>\n<cell>\nrounded_avg(106,\
    \ 203) # 106 -> 0b11010\nrounded_avg(106, 205) # 106 -> -1\n</cell>\n<cell>\n\
    from typing import Union\n", "    if n == m:\n        return \"0b0\"\n    elif\
    \ n < m:\n        return -1\n    else:\n        return (bin(n + m - 1).lstrip(\"\
    0b\").rstrip(\"0\").rjust(64, \"0\") + \"0b10000000\").rstrip(\"0\")\n\n", " \
    \   return str(bin(round(n + (m-1))).split('b')[1])\n\n", "    \n    \n    \n\
    \    \n\n    \n    \n    \n    \n    \n    return ret\n</cell>\n<cell>\nrounded_avg(1,\
    \ 5)\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n\
    </cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n\
    <cell>\nrounded_avg(50, 50)\n</cell>\n<text>\nGreat! You should now have learned\
    \ how to create your own functions from scratch and how to call functions from\
    \ your code in Python.\n\nIn a later lesson we will learn how to import functions\
    \ we've already created and explore how they work. Here are some examples of importing\
    \ functions from your code.\n\n\n</text>\n<cell>\nimport function_library\n</cell>\n\
    <cell>\nfunction_library.square(2)\n</cell>\n<text>\nWhat if we want to import\
    \ the square function from the numpy library?\n\nimport numpy\nnumpy.square(2)\n\
    \n\n</text>\n<cell>\nimport numpy as np\nnp.square(2)\n</cell>\n<text>\nIn a later\
    \ lesson we will learn about creating our own classes in Python, and we will learn\
    \ how to use classes to organize our code.\n\n\n</text>\n<text>\nDictionaries\n\
    A dictionary is a mutable and indexed collection of key-value pairs. It is similar\
    \ to a Map in other programming languages. In Python, dictionaries are created\
    \ with the curly braces {}. The keys are always strings (not numbers, characters\
    \ or booleans) and must be unique.\n\n\n</text>\n<cell>\nmy_dict = {'first': 100,\
    \ 'second': 300}\n</cell>\n<text>\nWe can add new key-value pairs to our dictionary\
    \ by using the update() method on our dictionary object. .\n\n\n</text>\n<cell>\n\
    my_dict.update({'third': 800})\nmy_dict\n</cell>\n<text>\nWe can also access our\
    \ dictionary values by calling them using square brackets [].\n\n\n</text>\n<cell>\n\
    my_dict['first']\n</cell>\n<text>\nSometimes it would be useful to index a dictionary\
    \ by a key that is more than one word. Using the format my_dict['first name']\
    \ will result in a syntax error. In the same way we can index a list by the position\
    \ of each item in the list. \nWe can use spaces between words in the key if we\
    \ want to index by the first and last name:\n\nmy_dict['first name']\nmy_dict['first\
    \ name last']\n\n</text>\n<text>\nFor this lecture, you will be using dictionaries\
    \ to solve two problems: (1) ", "    \n    count = 1\n    \n    if m > n:\n  \
    \      return \"-1\"\n\n    while count < m // n:\n        count *= 2\n\n    avg\
    \ = count // n\n    binary = str(bin(avg))[2:]\n    \n    return binary\n", " \
    \   if n < m:\n        return -1\n    else: \n        sum_ = 0\n        for i\
    \ in range(n,m+1):\n            sum_ += i\n        return str(bin(sum_//2))[2:]\n",
  "    \n    avg = (n + m) / 2\n    bits = bin(avg).replace('0b', '')\n    if avg\
    \ > m:\n        return -1\n    return bits\n</cell>\n<cell>\nrounded_avg(7, 5)\n\
    </cell>\n<cell>\nrounded_avg(15, 5)\n</cell>\n<cell>\nrounded_avg(29, 5)\n</cell>\n\
    <cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nCoding Exercise 2\nWrite a Python\
    \ program to find the sum of all integers from 1 to 20. (\u2605\u2606\u2606)\n\
    Use range to generate a list of integers from 1 to 20. \n\u2605\u2606\u2606\n\n\
    \n</text>\n<cell>", "    if n > m:\n        return -1\n\n    quotient = n // m\n\
    \    remainder = n % m\n\n    return (\n        f'{quotient * \"0\" + remainder}'\
    \ + \n        '0' if remainder == 1 else '1') \n", "    answer = 0\n    for i\
    \ in range(n, m+1):\n        answer += i\n    answer /= (n-m)\n    answer = bin(answer)[2:]\n\
    \    if len(answer) == 0:\n        return \"0b0\"\n    return answer\n", "   \
    \ i = int(n)\n    i += int(m)\n    if i >= n:\n        i = i%n\n        binary\
    \ = bin(i).split(\"b\")[1]\n    else:\n        binary = bin(i).split(\"b\")[0]\
    \ + str(n)\n    return binary\n\nprint(rounded_avg(10, 20))\n</code>\n<|/ a dscore=1\
    \ tags=python,binary,function |>\n<| a |>\n<code>", "    if n >= m:\n        return\
    \ '-1'\n    else:\n        return bin(int((n + m) // 2))[3:]\n\n</cell>\n<text>\n\
    Exercise 3\nWhat is the smallest and largest integer that can be represented using\
    \ only 7 bits?\n\n\n</text>\n<cell>", "    if n >= m:\n        return '-1'\n \
    \   result = \"\"\n    while n <= m:\n        result += bin(n).lstrip('0b')\n\
    \        n += 1\n    return str(int(result))\n", "    return \"0b\" + bin(n +\
    \ (m // 2))[2:].rjust(m, '0')\n", "    if n >= m:\n        return -1\n    else:\n\
    \        n = n.bit_length()\n        m = m.bit_length()\n        answer = 0\n\
    \        for i in range(n - 1):\n            answer += int(2**(m-1) * int(bin(int(bin(i)[2:])[-m:]),\
    \ 2))\n        return answer\n        \n", "    answer = 0\n    while n <= m:\n\
    \        answer += n\n        n += 1\n    return \"0b\" + \"{0:b}\".format(answer).zfill(m)\n\
    </cell>\n<cell>\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5)\
    \ == -1\nassert rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33)\
    \ == \"0b11010\"\n</cell>\n<text>\nGreat! Now that we have a function that rounds\
    \ our values, let's refactor our code so that it can be more efficient. We'll\
    \ do this by first creating two functions, round_up_to() and round_down_to(),\
    \ that take a number and round it up or down to the next power of 2. Then, we'll\
    \ write a function sum_from_to() that takes a number and a to and returns n, the\
    \ sum of the numbers from n to m.\n\n\n</text>\n<cell>", "    if n == m:\n   \
    \     return \"0b\" + bin(n)[2:].zfill(m)\n    if n == m:\n        return \"-1\"\
    \n    else:\n        integer = n\n        remainder = m % n\n        if m == n:\n\
    \            return f\"{integer:b}\"\n        else:\n            if remainder\
    \ == 0:\n                return f\"{integer:b}0\"\n            else:\n       \
    \         left_decimal = f\"{integer:b}0\"\n                right_decimal = f\"\
    {remainder:b}1\"\n                return left_decimal + right_decimal\n\nprint(rounded_avg(2,\
    \ 6))\nprint(rounded_avg(7, 3))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10,\
    \ 20))\nprint(rounded_avg(20, 33))\nprint(rounded_avg(100, 20))\nprint(rounded_avg(100,\
    \ 20), end=\"\")\n</code>\n<|/ a tags=python,python-3.x |>\n<| c |>\nThis is nice\
    \ and compact, but it doesn't work the way I asked the question: It prints `-1`\
    \ on all inputs. Also, please explain what `zfill` and `b` are doing. Thanks!\n\
    <|/ c |>\n<| c |>\nOops, I misread that as `m` instead of `n`. In that case, it\
    \ fails all the test cases (but still passes all test cases in my IDE).\n<|/ c\
    \ |>\n<| c |>\nAh, I thought that `zfill` was converting from integer to string,\
    \ then adding `0` on the left side, while the `b` is just converting from string\
    \ to binary (with leading `0b`). Thanks!\n<|/ c |>\n<| c |>\n`zfill` does indeed\
    \ convert from a numeric value to a string, and then add `0` on the left of the\
    \ string until the length of the string is equal to the length of `n`.\n<|/ c\
    \ |>\n<| c |>\nThis answer is nice and compact, but I still don't understand why\
    \ it works. Would you mind explaining it to me?\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "    if n <= m:\n        return -1\n\n    if n % 2 == 0:\n        return\
    \ -1\n\n    i = m // 2\n    answer = \"\"\n    while i <= n:\n        if n % i\
    \ == 0:\n            answer += \"1\"\n            n //= i\n        else:\n   \
    \         answer += \"0\"\n            n -= 1\n        i += 1\n    if len(answer)\
    \ < m:\n        return \"0b\" + answer\n    else:\n        return \"0b\" + answer[0:m]\n\
    \n", "    if m == 0:\n        return f\"{n}\"\n    \n    if m > 0:\n        if\
    \ n % 2 != 0:\n            n = n // 2\n        else:\n            n //= 2\n  \
    \  \n    if n <= m:\n        return f\"{n}\"\n    \n    return -1\n    ", "  \
    \  i = n\n    s = 0\n    while i <= m:\n        s = s + (i - n)\n        i +=\
    \ 1\n    return bin(s) + bin(s - n + (i - m)//2)[2:]\n\nassert rounded_avg(1,\
    \ 5) == \"0b11\"\nassert rounded_avg(7, 5) == -1\nassert rounded_avg(10, 20) ==\
    \ \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\nassert rounded_avg(7,\
    \ 5) == \"0b11\"\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou don't need to use bin,\
    \ only `round()` will do it.\n<|/ c |>\n<| c |>\nThis is awesome, thanks. But\
    \ what do you think about my solution?\n<|/ c |>\n<| c |>\n.Antonov I don't think\
    \ it works in some cases.\n<|/ c |>\n<| c |>\nI see your solution is quite elegant\
    \ but I think it can be simplified. Take a look at my answer for a more simple\
    \ solution.\n<|/ c |>\n<| c |>\n.Antonov yes, your solution is more elegant and\
    \ should be faster.\n<|/ c |>\n<| a tags=python-3.x,python,algorithm,binary,math\
    \ |>\nI made a quick code solution to solve this problem. I think it is pretty\
    \ self explanatory, but I will post the solution if someone finds it useful.\n\
    <code>", "    assert n >= m\n    if n == m:\n        return str(n)\n    return\
    \ \"0b\" + bin(n + m - 1).replace(\"0b\", \"\")\n", "    if n <= m:\n        return\
    \ -1\n\n    return bin(int((n + m) / 2))[2:]\n", "    n, m = int(n), int(m)\n\
    \    \n    if n<m:\n        return \"-1\"\n    \n    # calculate avg without rounding\n\
    \    avg = n//m + n%m\n    \n    # round average to nearest integer\n    avg =\
    \ int(avg)\n    \n    # convert to binary\n    avg = f\"{avg:b}\"\n    \n    return\
    \ avg\n", "    return f\"{bin(n+m)[2:]}\".zfill(m)\n", "    if m > n:\n      \
    \  return -1\n    else:\n        s = 2\n        while s <= m:\n            s +=\
    \ 2\n        return ((n // s) - 1) * (\"0b\" + bin(n).split('b')[1]) + s * (\"\
    0b\" + bin(s).split('b')[1])\n\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7,\
    \ 5) == -1\nassert rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33)\
    \ == \"0b11010\"\n</cell>\n<text>\nProblem 3\nYou are given an array arr of positive\
    \ integers. \nYour task is to find the maximum element in the array. \nIf there\
    \ are more than one such elements, you are to find the one that occurs most often.\
    \ \nYour function should return the number of elements that can be removed.\n\
    For example:\narr = [10, 20, 15, 10, 5, 30] has two occurrences of 10, so the\
    \ maximum element occurring is 10.\narr = [1, 10, 2, 20, 1] has one occurrence\
    \ of 10, so the maximum element occurring is 20.\narr = [1, 10, 2, 20, 1, 5, 20,\
    \ 20, 10, 5] has three occurrences of 10, so there is one element that can be\
    \ removed from the array.\narr = [1, 10, 2, 20, 1, 5, 20, 20, 10, 5, 30] has three\
    \ occurrences of 10, so the maximum element is 30.\narr = [1, 10, 2, 20, 1, 5,\
    \ 20, 20, 10, 5, 30, 100] has one occurrence of 100, so the maximum element is\
    \ 100.\nFor this problem, you will need to return an int or a boolean.\n\n\n</text>\n\
    <cell>", "    \n    avg = n // m\n    remainder = n % m\n    \n    if remainder\
    \ == 0:\n        return str(avg)\n    else:\n        if avg > remainder:\n   \
    \         return -1\n        else:\n            return str(int(math.ceil(avg /\
    \ 2) * 2) + remainder)\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\n\
    print(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\n</cell>\n<cell>", "  \
    \  if n >= m:\n        return \"-1\"\n    elif n == 0:\n        return \"0\"\n\
    \    else:\n        answer = \"\"\n        while n <= m:\n            answer =\
    \ f\"0b{bin(n).replace('b', '' * (len(bin(n)) - 3))}\"\n            n += 1\n \
    \       return answer\n</code>\n<|/ a dscore=0 |>\n<| a tags=python-3.x |>\nHere\
    \ is my solution that uses bit operations to generate the binary string in place.\n\
    <code>", "    if (n >= m) == True:\n        return -1\n    if n >= m:\n      \
    \  if n % 2 == 0:\n            n = n // 2\n        else:\n            n = n +\
    \ (n // 2)\n    if m >= n:\n        return -1\n    if m == n:\n        if m %\
    \ 2 == 0:\n            m = m // 2\n        else:\n            m = m + (m // 2)\n\
    \    if m == n:\n        m = (n + (n // 2))\n        if m % 2 == 0:\n        \
    \    m = m // 2\n        else:\n            m = m + (m // 2)\n    if n >= m:\n\
    \        if m % 2 == 0:\n            m = m // 2\n        else:\n            m\
    \ = m + (m // 2)\n    binary = str((n + (n // 2)) // m) # converts int to str\n\
    \    if len(binary) >= len(str(m)):\n        return -1\n    else:\n        return\
    \ binary\n", "    return str(bin(int(round(n/2.0)))).zfill(m)\n\n", "    \n  \
    \  # TODO: Implement this function\n    \n    \n    if n >= m:\n        return\
    \ -1\n    else:\n        avg = ((n - m) // 2 + (n - m) % 2) / n\n        return\
    \ bin(avg).replace('0b', '')\n</cell>\n<text>\nRun the following test code:\n\n\
    \n</text>\n<cell>\nprint(f'The average of the numbers 1 to 5 rounded to nearest\
    \ integer is {rounded_avg(1, 5)}.')\nprint(f'The average of the numbers 7 to 5\
    \ rounded to nearest integer is {rounded_avg(7, 5)}.')\nprint(f'The average of\
    \ the numbers 10 to 20 rounded to nearest integer is {rounded_avg(10, 20)}.')\n\
    print(f'The average of the numbers 20 to 33 rounded to nearest integer is {rounded_avg(20,\
    \ 33)}.')\n</cell>\n<text>\nExpected output:\n\nThe average of the numbers 1 to\
    \ 5 rounded to nearest integer is 0b11. \nThe average of the numbers 7 to 5 rounded\
    \ to nearest integer is -1. \nThe average of the numbers 10 to 20 rounded to nearest\
    \ integer is 0b1111. \nThe average of the numbers 20 to 33 rounded to nearest\
    \ integer is 0b11010.\n\n</text>\n<text>\nProblem 3\nWrite a function that takes\
    \ in a string and returns True if each character in the string is a vowel.\n\n\
    HINT: Think about using a for loop. Also think about what happens if the string\
    \ has a character not in the alphabet. Consider what happens when you try and\
    \ access a character that is not there.\n\n\n</text>\n<cell>", "    if n <= m:\n\
    \        return \"0b{0:b}\".format(n)\n    if m > n:\n        return \"-1\"\n\
    \    avg_num = n // m\n    low_num = (n - avg_num * m) // 2\n    high_num = m\
    \ - (low_num * 2)\n    low_bin = bin(low_num).split(\"b\")[1]\n    high_bin =\
    \ bin(high_num).split(\"b\")[1]\n    return \"0b\" + low_bin + high_bin\n\n",
  "    binary = \"\"\n    i = 0\n    while i <= m:\n        binary += str(n%2)\n \
    \       n //= 2\n        i += 1\n    return binary if len(binary) == n else -1\n",
  "    \n    if n>m:\n        return -1\n    else:\n        sum = 0\n        for i\
    \ in range(n,m+1):\n            sum += i\n        return int(sum/(m-n+1)).to_binary(n)\n\
    \n</cell>\n<text>\nTests\nRun the cell below to test your implementations.\n\n\
    \n</text>\n<cell>", "    if n > m:\n        return \"-1\"\n    return f\"{bin(n)[2:].zfill(m+2)}\"\
    \n</cell>\n<cell>\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7,\
    \ 5) == \"-1\"\nassert rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20,\
    \ 33) == \"0b11010\"\nassert rounded_avg(33, 55) == \"0b1011001\"\n</cell>\n<text>\n\
    Part 3: Write a Python function to check whether a string contains only hexadecimal\
    \ digits\n\n</text>\n<cell>", "    total = 0\n    count = 0\n\n    for i in range(m,\
    \ n + 1, 1):\n        total += i\n        count += 1\n    return f'{total//count:0b}'\n\
    \nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\n\
    print(rounded_avg(20, 33))\n</cell>\n<cell>", "    \n    sum = 0\n    count =\
    \ 0\n    if n >= m:\n        return -1\n    while n <= m:\n        sum += n\n\
    \        count += 1\n        n += 1\n    avg = sum / count\n    return \"0b{}{}\"\
    .format(round(avg), bin(avg)[2:])\n\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7,\
    \ 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\n</cell>\n<cell>",
  "    sum = 0\n    for i in range(m, n+1):\n        sum += i\n    return f\"{sum\
    \ // m:0b}\"\n</cell>\n<text>\n4.1.4 The Hamming Distance\nYou may be familiar\
    \ with the hamming distance formula, which is used to determine the distance between\
    \ two binary strings. For example, when calculating the hamming distance between\
    \ two strings, you might want to consider how many positions there are in the\
    \ shorter string that do not correspond to the corresponding positions in the\
    \ longer string. For example, the following two binary strings are considered\
    \ equal:\nThe first is a single '1' followed by three '0', the second is a single\
    \ '1' followed by a '1' and two '0's.\nThe hamming distance between these two\
    \ strings would be two, because there are two positions in the longer string that\
    \ do not correspond to the corresponding positions in the shorter string. \nThe\
    \ hamming distance formula also works for single characters. For example:\nLet\
    \ a = 'a', b = 'b'.\nThe Hamming distance between these two strings would be one.\
    \ \nThe Hamming distance formula also works for single characters. For example:\n\
    Let a = 'a', b = 'b'.\nThe Hamming distance between these two strings would be\
    \ zero.\n\nYour Task:\nYour task is to implement the hamming distance formula\
    \ in Python. This function will take in two strings s and t, and return hamming\
    \ distance between s and t, which is defined as the number of positions at which\
    \ the two strings differ. \nA position at which two strings differ is defined\
    \ as the difference between the two indices at which they differ. \n\nIf the strings\
    \ are the same length, return 0. If they are of different lengths, return -1.\
    \ \n\nFor example:\n\nhamming_distance('abc', 'ab') => 1\nhamming_distance('abc',\
    \ 'abc') => 0\nhamming_distance('abc', 'abbbbc') => -1\nhamming_distance('aa',\
    \ 'aa') => 0\nhamming_distance('ab', 'a') => -1\nhamming_distance('a', 'b') =>\
    \ -1\nhamming_distance('ab', '') => 0\nhamming_distance('', 'abc') => 0\n\n</text>\n\
    <cell>", "    if n < m:\n        return -1\n    if n == m:\n        return \"\
    0b1\"\n    return \"0b\" + bin(int(n + (m - n + 1) / 2)).lstrip('0b')\n", "  \
    \  \n    if n>m:\n        return \"-1\"\n    else:\n        s=bin(n-(m+1))[3:]\n\
    \        t=bin(m)[3:]\n        \n        rev=\"\"\n        rev+=t[::-1]\n    \
    \    rev+=s[::-1]\n        rev+=\"1\"\n        \n        return rev\n\n    ",
  "    if n >= m:\n        return \"-1\"\n    # Rounded up number\n    sum = int(n+m)\n\
    \    # Rounding up\n    sum += sum // 2\n    # Convert to binary\n    binary =\
    \ bin(sum)[2:]\n    # Remove \"0b\" at the beginning\n    binary = binary[3:]\n\
    \    return int(binary, 2)\n\n", "    return bin(int((m+n+1)/2)) if n<m else -1\n\
    \nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5) == -1\nassert\
    \ rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\
    \n</cell>\n<text>\n3.5 Exercise\nWrite a Python function named is_integer that\
    \ takes a single argument and returns True if its argument is any integer between\
    \ 1 and 2147483647, False otherwise. Recall that Python integers are a subtype\
    \ of integer. In particular, if you try to add 1 to an integer, you'll get a RuntimeError.\n\
    \nHint: use isinstance to test whether your input is an integer or not.\n\n\n\
    </text>\n<cell>", "    \n    return \"\".join(\"0b\" + str(int(round(n/m)*m))[::-1])\n\
    </code>\nThe rounding function rounds the number up if it is larger, or down if\
    \ smaller.\nThe [::-1] is used to reverse the string. \nThe int() converts the\
    \ string to a number and returns it as an integer. \nThe /m converts the integer\
    \ into a float and then rounds it to an integer.\n<|/ a dscore=2 |>\n<| c |>\n\
    `int(n/m*m)` will work just as well, and is faster since `int` has a `floor` method.\n\
    <|/ c |>\n<| a tags=binary,python,python-3.x,binary-data,math |>\nYou will have\
    \ to add some error checking, but the core functionality should be there.\n<code>",
  "    if n < m:\n        return -1\n    mid = m // 2 + n\n    left_sum = round(mid\
    \ - 1)\n    right_sum = round(mid)\n    binary_string = \"\".join([str(a) for\
    \ a in range(left_sum, right_sum + 1)])\n    return int(binary_string, 2)\n",
  "    if n >= m:\n        return \"-1\"\n    count = 0\n    for i in range(n+1,m):\n\
    \        count += 1\n    sum = (n+1)*count\n    return format((sum - sum%2)//2,\
    \ f\"0{sum%2}b\")\n</cell>\n<cell>", "    \n    # Write your code here\n    \n\
    \    \n    return \"\"\n\n\nassert rounded_avg(1, 5) == '0b11'\nassert rounded_avg(7,\
    \ 5) == -1\nassert rounded_avg(10, 20) == '0b1111'\nassert rounded_avg(20, 33)\
    \ == '0b11010'\n</cell>\n<text>\n4.3 Recursive Solution\n\n</text>\n<cell>", " \
    \   return \"0b\" + bin(round((((n + m) // 2) + n) // 2))[2:].rjust(32, '0')\n\
    \n", "    if n>=m:\n        return -1\n    else:\n        return bin(int((n+m)/2))[2:]\n",
  "    if n > m:\n        return -1\n    if n >= 2 * m:\n        return -1\n    avg\
    \ = n / (2 * m)\n    binary = \"0b\"\n    while avg > 1:\n        avg -= 10\n\
    \        binary += \"0\"\n    while avg != 0:\n        binary += \"1\"\n     \
    \   avg /= 10\n    return binary\n", "    # Your code here\n    \n    if n>m:\n\
    \        return -1\n    \n    \n    \n    avg = 0\n    \n    for i in range(n+1,m+1):\n\
    \        avg += i\n    \n    return bin(avg)[2:].zfill(m)\n\nprint(rounded_avg(8,6))\n\
    print(rounded_avg(8,4))\nprint(rounded_avg(8,2))\nprint(rounded_avg(8,5))\n\n\
    </cell>\n<text>\nThe ceil() function\n\n</text>\n<cell>", "    if n >= m:\n  \
    \      return \"-1\"\n\n    avg = ((n+m)/2)\n    result = str(bin(int(avg))[-n:])\n\
    \    if result[0] == '0' or result[1] == '0':\n        result = '0b' + result\n\
    \    return f'0b{result}'\n</cell>\n<cell>\nrounded_avg(1, 5)\n</cell>\n<cell>\n\
    rounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nWrite a function\
    \ named \"power2(n)\" that takes in an integer n.  \nThe function should output\
    \ a binary string of length one more than n, containing only 0s \nand 1s.\nIf\
    \ the integer n can be expressed as the sum of two primes, say p1 and p2, \nthe\
    \ function should output \"0b101\".  \nIf n is not an integer multiple of 2, it\
    \ should output \"0b0\".\n\nExamples:\n\npower2(10) => \"0b1010\"\npower2(13)\
    \ => \"0b1011\"\npower2(15) => \"0b1111\"\npower2(20) => \"0b101110\"\npower2(25)\
    \ => \"0b10111100\"\npower2(32) => \"0b11101111000\"\npower2(35) => \"0b111011110000\"\
    \npower2(41) => \"0b111111111111\"\npower2(42) => \"0b111111111111\"\npower2(100)\
    \ => \"0b0100\"\npower2(123) => \"0b0101\"\npower2(200) => \"0b1010\"\npower2(250)\
    \ => \"0b10111100\"\n\n</text>\n<cell>", "    \n    if n == m:\n        return\
    \ '0b{:0>b}'.format(int(n))\n    \n    binary_string = bin(n)[2:]\n    \n    to_return\
    \ = '0b{:0>b}'.format(int(binary_string[0:len(binary_string)-1], 2) + (int(binary_string[-1])\
    \ if len(binary_string) > 1 else 0))\n    \n    return to_return\n\n", "    return\
    \ f\"{bin((n+m)//2)[2:]}\"\n", '    ', "    avg_list = []\n    \n    # Compute\
    \ average of the list from n to m\n    for i in range(n, m):\n        avg_list.append(i)\n\
    \        \n    # Round the result to nearest integer\n    avg_list.sort()\n  \
    \  avg_list = avg_list[:int(len(avg_list)/2)]\n    avg_list.sort()\n\n    # Return\
    \ binary representation\n    if avg_list[0] == avg_list[-1]:\n        return int(\"\
    \".join([\"1\"]*(len(avg_list)-1)), 2)\n    return -1\n</cell>\n<cell>", "   \
    \ if n > m:\n        return -1\n    \n    if n == 0:\n        return \"0b0\"\n\
    \    \n    mid = (n + m) / 2\n    \n    if mid > n:\n        return \"0b\" + str(mid)\n\
    \    else:\n        return rounded_avg(n, mid) + rounded_avg(mid+1, m)\n", " \
    \   if not m or n >= m:\n        return -1\n    \n    avg = n // m\n    \n   \
    \ count = 0\n    if n % m == 0:\n        count += 1\n        n %= m\n    \n  \
    \  binary = \"\"\n    while avg > 0:\n        if n % 2 == 0:\n            binary\
    \ = str(int(binary) + 1)\n        else:\n            binary = str(int(binary)\
    \ + 0)\n        n //= 2\n        count += 1\n        avg //= 2\n    return f\"\
    {binary}{count}\"\n\nassert rounded_avg(3, 5) == \"0b11\"\nassert rounded_avg(2,\
    \ 3) == \"-1\"\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5)\
    \ == \"-1\"\nassert rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20,\
    \ 33) == \"0b11010\"\n</cell>\n<cell>", "    binary = f'{n:0{m}b}'\n    binary\
    \ = '0'*(m-2) + binary\n    binary = binary.replace('0b', '')\n    binary = binary.replace('1b',\
    \ '')\n    binary = binary.replace('10b', '')\n    binary = binary.replace('100b',\
    \ '')\n    return int(binary, 2)\n", "    binary = \"\"\n    if n<m:\n       \
    \ return -1\n    \n    for i in range(n+1):\n        binary+=\"{:b}\".format(i)\n\
    \    \n    binary+=\"b\"\n    \n    return int(binary, 2)\n", "    if n >= m:\n\
    \        return \"-1\"\n\n    return f\"{int(n+m//2):b}\"\n\n", "    assert n\
    \ <= m\n    return bin(int((n + m) / 2))[2:].zfill(m)\n", "    if n <= m:\n  \
    \      return str(n)\n    else:\n        return str(-1) # unreachable here\n",
  "    \n    numbers = range(n, m+1)\n    total = sum(numbers)\n    avg = total /\
    \ len(numbers)\n    \n    binary = format((int(avg)), \"b\")\n    \n    return\
    \ binary\n\nprint(rounded_avg(5,6)) # 0b11\nprint(rounded_avg(10,20)) # 0b1111\n\
    print(rounded_avg(20,33)) # 0b11010\n</cell>\n<text>\nChallenge #6 (10 Points)\n\
    For each of the following problems, you must write a function called \"is_even()\"\
    \ that takes a single argument and returns True if that argument is an even number,\
    \ and False otherwise.\n", "    if n >= m:\n        return -1\n    sum_ = n +\
    \ m\n    ones = sum_ % 2\n    tens = (sum_ - ones) / 2\n    return str(bin(ones)[-1])\
    \ + str(bin(tens)[-1])\n    \n    \n\"\"\"\nDON'T CHANGE ANYTHING BELOW\n\"\"\"\
    \nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5) == -1\nassert\
    \ rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\
    \n\n</cell>\n<text>\nWrite a function that checks whether a number is prime.\n\
    A number is prime if it has exactly two non-consecutive even integers, and no\
    \ other integers are present.\nFor example, 6 is prime because it has only two\
    \ non-consecutive even integers: 2 and 3.\nThere are many ways to define primality;\
    \ we may take advantage of a mathematical fact that a number $\\geq 1$ has only\
    \ two non-consecutive even integers, namely $\\sqrt{3n+1}$, where $n$ is the number.\
    \ Moreover, $\\sqrt{3}=\\sqrt{5}$. Hence, we only need to check whether $\\sqrt{3n+1}$\
    \ is odd or even.\n\nFor a more general solution, see the problem Primality Checker\
    \ II.\n\n\n</text>\n<code language=conda-env-Anaconda3-py>\nfrom math import sqrt\n",
  "    if n > m:\n        return -1\n    return f\"{int(math.ceil(n/float(m)))}{int(n%math.ceil(m/float(m)))}\"\
    \n", "    return bin(round(((n // m) + n - 1) // 2)).lstrip('-0b')\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "    \n    if n > m:\n        return -1\n    else:\n\
    \        binary_value = bin(n).split(\"b\")[1]\n        return int(binary_value,\
    \ 2)\n</cell>\n<cell>", "    if (n >= m): \n        return \"-1\"\n    else:\n\
    \        return \"0b\" + bin(round(n))[2:].zfill(m)\n", "    \n    count = 0\n\
    \    \n    for i in range(m, n+1):\n        count += 1\n    \n    average = int(round(count/2))\n\
    \    \n    if average == 0 or average == 1:\n        return \"0b\"+str(average)\n\
    \    elif average == 2:\n        return \"0b0\"\n    elif average == 3:\n    \
    \    return \"0b00\"\n    else:\n        return -1\n    \n", "    \n    if n <=\
    \ m:\n        return -1\n    \n    return bin(round(n/m)*m)[2:].zfill(int(len(bin(round(n/m)*m)[2:]))+3)\n",
  "    # Your code here\n    if n > m:\n        return \"-1\"\n    a = n // m\n  \
    \  b = n % m\n    return \"0b\" + str(a) + str(b)\n", "    return str(bin(int(n/m)\
    \ + int(m/n)))[2:]\n", "    if n <= m:\n        return f'{n:0{m}b}'\n    else:\n\
    \        return '-1'\n\n", "    \n    int_n = 0\n    int_m = 0\n    while n <=\
    \ m:\n        int_n += n\n        n += 1\n    while m <= n:\n        int_m +=\
    \ m\n        m += 1\n\n    avg = int_n // int_m\n    binary = bin(avg)\n    binary\
    \ = '0b'+binary\n    decimal = binary.count('1')\n    return f\"{decimal:0>{decimal+3}}\"\
    \n\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5) == -1\nassert\
    \ rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\
    \n</cell>\n<cell>", "    if n > m:\n        return -1\n    return \"0b{:b}\".format(int(n\
    \ // m) * m).lstrip(\"0b\")\n\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7,\
    \ 5) == -1\nassert rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33)\
    \ == \"0b11010\"\n</cell>\n<text>\nThe Solution:\nWe'll use a dictionary to store\
    \ the binary representations of our numbers.\n\n\n</text>\n<cell>", "    binary\
    \ = bin(m)[2:].rjust(n, \"0\")\n    if n >= m:\n        return \"-1\"\n    elif\
    \ n <= len(binary):\n        return binary\n    else:\n        return binary[:n]\n",
  "    return -1 if n < m else ((n // m) * m) + n - (n // m)\n</cell>\n<text>\nSolution:\n\
    \n\n</text>\n<cell>", "    \n    if n < m:\n        return -1\n    \n    res =\
    \ 0\n    count = 0\n    while n <= m:\n        count += 1\n        res += n\n\
    \        n += 1\n    \n    return \"0b\" + str(res//count).zfill(count)\n", " \
    \   return str(bin(n-m).lstrip(\"0b\"))\n    ", "    start = n\n    end = m\n\
    \    mid = (start + end) // 2\n    \n    count = (end - start) + 1\n    binary_string\
    \ = format((mid // count), 'b').zfill(count)\n\n    return binary_string\n\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\n</cell>\n<cell>", "    # Your code here\n    return 0 # Replace this line\n\
    </cell>\n<text>\nRun the cell below to check your implementation\nrounded_avg(1,\
    \ 5)\nrounded_avg(7, 5)\nrounded_avg(10, 20)\nrounded_avg(20, 33)\n\n</text>\n\
    <cell>", "    if n < m:\n        return -1\n    step = (n - m) / n\n    return\
    \ \"0b\" + str(bin(n - step)[2:]).zfill(m)\n\n", "    return bin(int((n+1)//m)\
    \ * m + n)[2:]\n", "    if n >= m:\n        return -1\n\n    avg = (n*m + n)/m\n\
    \    # round the answer to nearest integer\n    ans = str(int(avg))[::-1]\n  \
    \  return ans\n", "    avg = n // m\n    left = n % m\n    if avg == 1:\n    \
    \    return f\"{left:0b}\"\n    else:\n        return f\"{left:0b}{avg:b}\"\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding why and/or how this code answers the\
    \ question improves its long-term value.\n<|/ c |>\n<| a tags=binary,python,python-3.x\
    \ dscore=0 |>\n<code>", "    binary_number = []\n    sum = 0\n    \n    while\
    \ n >= m:\n        binary_number.append(n % 2)\n        sum += n\n        n //=\
    \ 2\n    \n    binary_number.append(m % 2)\n    sum += m\n    \n    if sum !=\
    \ 0:\n        binary_number.append(\"0b{}\".format(int(sum)))\n    else:\n   \
    \     binary_number.append(\"0b0\")\n    \n    if len(binary_number) > n:\n  \
    \      return -1\n    return \"0b{}\".format(\"\".join(map(str, binary_number)))\n\
    \n", "    if m > n:\n        return -1\n    \n    binary = \"{0:b}\".format(n)\n\
    \    binary += \"{0:b}\".format(m)\n    \n    binary = \"0\" * (m - len(binary))\
    \ + binary\n    \n    binary += \"1\"\n\n    return int(binary, 2)\n", "    if\
    \ m > n:\n        return \"-1\"\n    else:\n        return f\"{bin(m/n)[2:].zfill(n)}\"\
    \n\n", "    \n    if n == m:\n        return \"0b\" + bin(n)[2:].zfill(m)\n  \
    \  elif n <= m:\n        return -1\n    else:\n        return \"0b\" + bin(n-m)[2:].zfill(n)\n\
    \n\nassert rounded_avg(1, 5) == \"0b11\"\nassert rounded_avg(7, 5) == -1\nassert\
    \ rounded_avg(10, 20) == \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\
    \n</cell>\n<text>\nWrite a function that returns the GCD of two numbers. The GCD\
    \ of two numbers is the number that remains when you divide two numbers. \nIf\
    \ n1 and n2 are two non-negative integers, then GCD(n1, n2) = GCD(n2, n1).\n\n\
    GCD(n, m)\n\nn1 = n2 = m\n\nGCD(n, m) = GCD(m, n)\n\n\n</text>\n<cell>\nfrom typing\
    \ import Union\n", "    \n    n = int(n)\n    m = int(m)\n    if n >= m:\n   \
    \     return -1\n\n    avg = ((n + m) // 2) \n    avg = (bin(avg))[2:]\n    return\
    \ avg\n\n", "    if n==m:\n        return \"0b\" + str(n)\n    else: \n      \
    \  if n<m:\n            return \"-1\"\n        else:\n            return \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" +\
    \ \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\"\
    \ + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"0b\" + \"\
    0b", "    if not n <= m:\n        return -1\n    else: \n        average = n +\
    \ (m - n)//2\n        return bin(average).lstrip(\"0b\")\n\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\n</cell>\n<text>\nQuestion 7\nWrite a function is_perfect_square() that\
    \ returns True if its argument is \na perfect square, and False otherwise.\n\n\
    Example 1:\nis_perfect_square(15) => True\nis_perfect_square(17) => False\nExample\
    \ 2:\nis_perfect_square(24) => True\nis_perfect_square(30) => False\nExample 3:\n\
    is_perfect_square(-5) => True\nis_perfect_square(-10) => False\nHint: You can\
    \ use the modulo operator to do this, e.g.\n\n(x % 4) == 0\n\n</text>\n<cell>",
  "    if m > n:\n        return -1\n    return bin(n + (m - n) // 2).lstrip(\"0b\"\
    )\n", "    # TODO: Fix the code below and write unit tests\n    #\n    # HINT:\
    \ Use string formatting\n    # HINT: Use try, except to handle edge cases\n  \
    \  # HINT: Use 'range' to simplify the code\n    \n    # YOUR CODE HERE\n    raise\
    \ NotImplementedError()\n", "    if n >= m:\n        return -1\n    result = \"\
    \"\n    count = 0\n    while(n <= m):\n        n += 1\n        result += \"b\"\
    \n        count += 2\n    return \"0b\" + result + str(count)\n\n\nprint(rounded_avg(1,\
    \ 5)) # 0b11\nprint(rounded_avg(7, 5)) # -1\nprint(rounded_avg(10, 20)) # 0b1111\n\
    print(rounded_avg(20, 33)) # 0b11010\n</cell>\n<cell>", "    if n > m:\n     \
    \   return -1\n    \n    low = n if n % 2 else n + 1\n    high = m if m % 2 else\
    \ m + 1\n    \n    sum = 0\n    while low < high:\n        sum += low\n      \
    \  low += 1\n        high += 1\n\n    average = str(bin(sum // 2))\n    \n   \
    \ if average[0] != '0':\n        average = average[1:]\n    \n    if average.endswith('0'):\n\
    \        average = average[:-1]\n    \n    return average\n\n", "    if n<m:\n\
    \        return \"-1\"\n    \n    def helper(lower, upper):\n        mid = lower\
    \ + (upper-lower)//2\n        if mid>n:\n            return -1\n        elif mid==n:\n\
    \            return str(mid)\n        else:\n            return helper(lower,\
    \ mid-1)+helper(mid+1, upper)\n\n    return helper(0,m)\n\n", "    if n > m:\n\
    \        return \"-1\"\n    a = n if n < m else m\n    return str(bin(a+m+1)[2:].zfill(n))\n\
    \    \n    ", "    total = 0\n    while n >= m:\n        total += n\n        n\
    \ -= m\n    return \"0b{:b}\".format(total)\n    \nassert rounded_avg(1, 5) ==\
    \ \"0b11\"\nassert rounded_avg(7, 5) == -1\nassert rounded_avg(10, 20) == \"0b1111\"\
    \nassert rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<cell>", "    \n    # Initialize\
    \ an empty string and an empty integer \n    output = \"\"\n    num = 0\n\n  \
    \  # Check if n is greater than m\n    if n < m:\n        return \"-1\"\n\n  \
    \  # While m <= n\n    while m <= n:\n        # If m's binary representation is\
    \ equal to n's binary representation\n        if get_binary_digit(m, 2) == get_binary_digit(n,\
    \ 2):\n            # Update output and add m to num\n            output += get_binary_digit(m,\
    \ 2)\n            num += m\n            # Update m to be the next greater number\
    \ and update n to be m's new binary representation\n            m *= 10\n    \
    \        n //= 10\n        else:\n            # Update m\n            m += 1\n\
    \            # Update n\n            n //= 10\n    # If m == n, return output\n\
    \    return output + get_binary_digit(num, 2)\n", "    pass\n", "    return -1\
    \ if n > m else bin(n + m // 2)[2:].zfill(m)\n</code>\nTests:\n<code>\nassert\
    \ rounded_avg(1, 5) == '0b11'\nassert rounded_avg(7, 5) == -1\nassert rounded_avg(10,\
    \ 20) == '0b1111'\nassert rounded_avg(20, 33) == '0b11010'\n</code>\n<|/ a dscore=2\
    \ tags=python |>\n<| a tags=python dscore=2 |>\n<code>", "    # Your code here\n\
    \    \n    # Solution here\n    if n > m:\n        return \"-1\"\n    else:\n\
    \        total = sum(i * 2**i for i in range(n, m+1, 2))\n        return str(bin(total)[2:]).replace(\"\
    0b\", \"1\")\n", "    if n > m:\n        return -1\n    if n==m:\n        return\
    \ '0b0'\n    total = 0\n    for i in range(n, m+1):\n        total += i\n    \n\
    \    return f\"{bin(total)[2:]}\"\n", "    \n    \n    assert n >= m, \"n should\
    \ be greater than m. n has value {} and m has value {}\".format(n, m)\n    assert\
    \ n <= 3**int(math.log(m, 2)), \"n should be less than or equal to 3**int(math.log(m,\
    \ 2)). n has value {} and m has value {}\".format(n, m)\n    \n    \n    return\
    \ \"0b\" + ''.join(format(round(int(str(n)+str(m))/2), \"b\")[2:])\n\n", "   \
    \ if n == m:\n        return \"0b\" + str(n)\n\n    if m > n:\n        return\
    \ -1\n\n    avg = (n - m) / 2\n\n    string = \"0b\" + str(int(avg))\n\n    return\
    \ string\n", "    if (m <= n):\n        return -1\n    else:\n        # Round\
    \ up\n        return ((bin(int(f\"{n+m}\", 2))[2:]).zfill(len(m)))\n\nassert rounded_avg(1,\
    \ 5) == \"0b11\"\nassert rounded_avg(7, 5) == \"-1\"\nassert rounded_avg(10, 20)\
    \ == \"0b1111\"\nassert rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\n\
    Exercise\nUsing this function, complete the function rounded_avg() to return \"\
    0b1111\" when given n = 6 and m = 10 (the average of the numbers 1 to 10 inclusive),\
    \ and \"0b11010\" when given n = 4 and m = 3 (the average of the numbers 2 to\
    \ 3 inclusive).\n\n\n</text>\n<cell>", "    if n >= m:\n        return -1\n  \
    \  else:\n        return bin(int(n/m))[2:]\n", "    if n>=m:\n        return -1\n\
    \    s = str(bin(n//m)[2:])\n    return s if len(s) else \"0b\"\n    \nprint(rounded_avg(20,\
    \ 33))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(5, 5))\nprint(rounded_avg(100,\
    \ 200))\nprint(rounded_avg(100, 0))\nprint(rounded_avg(100, -1))\n</cell>\n<text>\n\
    Challenge Exercise - Rounding\n\n</text>\n<cell>", "    count = 0\n    binary_result:\
    \ str = \"\"\n    \n    # Compute sum\n    sum_of_nums = n \n    \n    # While\
    \ sum <= m \n    while sum_of_nums <= m:\n        # Add 1 to count\n        count\
    \ += 1\n        \n        # Add number to sum\n        sum_of_nums += n\n    \n\
    \    # Convert to binary string\n    binary_result = bin(sum_of_nums)[2:]\n  \
    \  \n    # Round result to the nearest whole number\n    binary_result = round(int(binary_result,\
    \ 2))\n    \n    # If sum > m, return -1\n    if sum_of_nums > m:\n        return\
    \ \"-1\"\n    \n    return binary_result\n    \nprint(rounded_avg(1, 5)) # 0b11\n\
    print(rounded_avg(7, 5)) # -1\nprint(rounded_avg(10, 20)) # 0b1111\nprint(rounded_avg(20,\
    \ 33)) # 0b11010\n</cell>\n<cell>", "    if n <= m:\n        return -1\n    else:\n\
    \        return bin(n + (n - m))[-m]\n", '    ', "    \n    average = (n*m)/2\n\
    \    average = int(average)\n    \n    if average < n:\n        average = 0\n\
    \        \n    if average > m:\n        average = m\n        \n    binary = str(average)\n\
    \    \n    return binary\n</cell>\n<cell>", "    if n > m:\n        return -1\n\
    \    \n    if n <= m:\n        return '0b' + format(n - 1, '010b')\n\n    return\
    \ '0b' + format(m - 1, '010b') + format(n - m, '010b')\n\n", "    \n    int_n\
    \ = int(n)\n    int_m = int(m)\n    if int_n >= int_m:\n        return -1\n  \
    \  int_avg = int_n//m \n    binary = bin(int_avg)\n    \n    binary_str = binary.replace('b',\
    \ '')\n    \n    return binary_str\n\n", "    if n < m:\n        return -1\n \
    \   \n    binary = bin(n//m)[2:].rjust(len(bin(n)-len(bin(m))+1), \"0\")\n   \
    \ if binary.endswith('m'):\n        binary = binary[:-1]\n    return int(binary\
    \ + \"1\") if binary != bin(m) else '0b0'\n</cell>\n<text>\nYour Task\nWrite a\
    \ function that returns the number of times the function rounded_avg evaluates\
    \ to -1\nrounded_avg(11, 6) is -1\nrounded_avg(11, 5) is -1\nrounded_avg(11, 4)\
    \ is -1\nrounded_avg(11, 3) is -1\nrounded_avg(11, 2) is -1\nrounded_avg(11, 1)\
    \ is -1\nrounded_avg(11, 0) is -1\nrounded_avg(11, -1) is -1\n\n\n</text>\n<cell>",
  "    sum_ = 0\n    sum_of_square = 0\n    count_ = 1\n    base = 2 if n >= m else\
    \ 2\n    while count_ <= m:\n        if n % count_ == 0:\n            sum_ +=\
    \ count_ * count_\n            sum_of_square += count_ * count_ * count_\n   \
    \         count_ += 1\n        else:\n            sum_ += count_ * count_\n  \
    \          sum_of_square += count_ * count_ * count_\n            count_ += base\n\
    \n    avg = sum_ / m\n    avg2 = sum_of_square / m\n    decimal_places = n - m\n\
    \    avg_str = str(round(avg, decimal_places))\n\n    if decimal_places == 0 and\
    \ len(avg_str) == 1:\n        avg_str += '0'\n    elif decimal_places > 0 and\
    \ len(avg_str) > 1:\n        avg_str = avg_str[:len(avg_str) - decimal_places]\n\
    \n    return avg_str\n", "    \n    if n == m:\n        return str(n)\n    if\
    \ m >= n:\n        return \"-1\"\n    \n    avg = (n+m)/2\n    \n    # Convert\
    \ to binary\n    bin_avg = bin(avg)[2:]\n\n    # Remove leading \"0b\" characters\n\
    \    bin_avg = ''.join(bin_avg.lstrip('0b'))\n\n    # Add back in zeros if there\
    \ are any\n    bin_avg = bin_avg + '0' if len(bin_avg) == 1 else bin_avg\n   \
    \ \n    return bin_avg\n\n", "    \n    if n == m:\n        return \"0b0\"\n\n\
    \    if n > m:\n        return -1\n\n    if n == 0:\n        return \"0b0\"\n\n\
    \    i = 0\n    sum = 0\n    while n > 0:\n        sum += n\n        n //= 2\n\
    \        i += 1\n\n    binary_string = bin(sum)[2:]\n    if len(binary_string)\
    \ < m+1:\n        binary_string += \"0\" * (m+1-len(binary_string))\n\n    return\
    \ binary_string[i:i+m]\n", "    sum = 0\n    for i in range(n, m):\n        sum\
    \ += i\n        if sum > 2**(8 - i-1):\n            return -1\n    return bin(sum)[2:].zfill(i)\n",
  "    avg = 0\n    for x in range(n, m):\n        avg = avg + x\n    return avg /\
    \ 2\n", "    return (bin(int((n+m)//2))[2:] + \"0\" * (n-m%2)) \n", "    # type\
    \ hints cannot be used for return type of a function\n    # so I'm using a type\
    \ variable instead\n    \n    # your code here\n    \n    if n > m:\n        return\
    \ \"-1\"\n    else:\n        avg = n + (m - n)\n        bits = bin(avg)[2:]\n\
    \        return bits\n", "    if n>m:\n        return \"-1\"\n    if n==m:\n \
    \       return n\n    if m%n==0:\n        return (m//n).to_binary(n,m)\n    else:\n\
    \        return \"-1\"\n", "    n = int(n)\n    m = int(m)\n    if n<m:\n    \
    \    return -1\n    return f'{bin(n)[2:]:0{m}b}'\n</cell>\n<cell>\nrounded_avg(100,\
    \ 33)\n</cell>\n<text>\nImplement a reverse lookup table\nWe have seen the string\
    \ formatting operator % used a lot in string formatting. In this exercise, you'll\
    \ work with the same operator to create a reverse lookup table.\n\nHere are some\
    \ sample values:\n\nword = \"cat\"\nnumber = 37\nreverse_lookup_table[word] =\
    \ number\nreverse_lookup_table\n{'cat': 37}\nTo reverse lookup a string, you can\
    \ use a dictionary where you map each possible value to the corresponding index\
    \ in the string. For example, if we had the string 'cat', we would map it to the\
    \ character 'c' since the string can only contain one character. Then, we would\
    \ reverse lookup this dictionary and return the corresponding index.\n", "   \
    \ if n > m:\n        return \"-1\"\n    if n == m:\n        return \"0b0\"\n \
    \   return \"0b\" + \"\".join(f\"{(2**n-1)+1}\" for n in range(m, n+1))\n", " \
    \   if n > m:\n        return -1\n    \n    avg = n + (m // 2)\n    binary = bin(avg)[2:].zfill(n)\n\
    \    \n    return int('0b' + binary, 2)\n", "    return \"0b\" + bin(int((n+m)//2))[-n:][::-1]\n\
    \nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\n\
    print(rounded_avg(20, 33))\n</cell>\n<text>\n8. Reverse Integer\n\n</text>\n<text>\n\
    The reverse integer functions are a sequence of integers provided as input.\n\
    The function returns -1 if the input integer is less than 0. Otherwise, it returns\
    \ the input integer.\n\nExample 1:\nInput:\nn = 3\nOutput: \n1\nExplanation:\n\
    Input: n = 3, return 1.\nInput: n = 4, return 3.\n\nExample 2:\nInput:\nn = 10\n\
    Output: \n-1\n\nExplanation:\nInput: n = 10, return -1.\nInput: n = 11, return\
    \ -1.\nInput: n = 0, return -1.\n\n\n</text>\n<cell>", "    \n    # Your code\
    \ goes here\n", "    if n > m:\n        return -1\n    \n    binary = bin(n+1)[2:]\
    \ + bin(m+1)[2:]\n    \n    length = len(binary)\n    \n    bits = list(reversed(binary))\n\
    \    \n    to_return = bin(n//m)[2:]\n    \n    i = 0\n    \n    \n    while i\
    \ < length-1:\n        \n        if bits[i] == '0':\n            to_return +=\
    \ '0'\n            i += 1\n        elif bits[i] == '1':\n            to_return\
    \ += '1'\n            i += 1\n        \n        else:\n            to_return +=\
    \ '0'\n            i += 1\n        \n    to_return += '0'\n    \n    \n    return\
    \ to_return\n\n\n", "    \n    if m >= n:\n        return -1\n    else:\n    \
    \    return bin(n + (m-1))[2:].rjust(m, '0')\n", "    if n < m:\n        return\
    \ -1\n    \n    count = 0\n    sum_ = n * m //2\n    \n    while sum_:\n     \
    \   count += 1\n        sum_ -= m\n        \n    return \"0b{}b\".format(\"0\"\
    *count) + str(sum_//n)\n", "    if n > m:\n        return -1\n    elif n == 0:\n\
    \        return \"0b0\"\n    elif n == 1:\n        return \"0b1\"\n    else:\n\
    \        sum_of_digits = n - m\n        mod = sum_of_digits % 2\n        shift\
    \ = 1 if sum_of_digits % 2 else 0\n        mod = int(mod)\n        if mod == 1:\n\
    \            mod = \"0b1\"\n        elif mod == 0:\n            mod = \"0b0\"\n\
    \        shift = int(shift)\n        binary = bin(n + (m - n)).lstrip(\"0b\").zfill(m\
    \ + shift)\n        return f\"{mod}{binary}\"\n\n", "    # your code here\n  \
    \  return \"\"\n</cell>\n<text>\nProblem 6\nWhat is 2^10?\n\nProblem 7\nWhat is\
    \ 2^8? What is 2^9? What is 2^10?\n\nProblem 8\nWhat is 2^5?\n\nProblem 9\nWhat\
    \ is 2^3?\n\nProblem 10\nWhat is 2^1?\n\nProblem 11\nWhat is 8^3?\n\n\n</text>\n\
    <text>\nSolution\nThe following code is given\n\n\n</text>\n<cell>", "    if n\
    \ > m:\n        return -1\n    s = str(bin(int(n)))\n    if s[-1] == \"0\":\n\
    \        s=s[:-1]\n    if len(s)> m:\n        s=s[:m]\n    return s\n", "    int_list\
    \ = list(map(int, range(n,m+1)))\n    \n    if n >= m:\n        return -1\n  \
    \  \n    avg = 0\n    for i in int_list:\n        avg += i\n    avg = round(avg/len(int_list))\n\
    \    \n    if avg < 1:\n        avg = -1\n    \n    binary_string = \"\"\n   \
    \ for i in range(0,len(binary_string),1):\n        binary_string += str((2**i)*avg)\n\
    \    \n    return binary_string\n", "    if n < m:\n        return -1\n    return\
    \ (n // m) * m + n & (m << 1)\n", "    if n<m: return -1\n    else:\n        sum\
    \ = 0\n        while n <= m:\n            sum += n\n            n += 1\n     \
    \   return bin(sum)[2:]\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
