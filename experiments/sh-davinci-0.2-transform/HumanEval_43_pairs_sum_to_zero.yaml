name: HumanEval_43_pairs_sum_to_zero
language: sh
prompt: "#!/bin/bash\n# pairs_sum_to_zero takes a list of integers as an input.\n\
  # it returns True if there are two distinct elements in the list that\n# sum to\
  \ zero, and False otherwise.\n# >>> $(pairs_sum_to_zero \"1 3 5 0\")\n# \"false\"\
  \n# >>> $(pairs_sum_to_zero \"1 3 -2 1\")\n# \"false\"\n# >>> $(pairs_sum_to_zero\
  \ \"1 2 3 7\")\n# \"false\"\n# >>> $(pairs_sum_to_zero \"2 4 -5 3 5 7\")\n# \"true\"\
  \n# >>> $(pairs_sum_to_zero \"1\")\n# \"false\"\n#\n# $1 is a space-separated list\n\
  pairs_sum_to_zero() {\n"
tests: "}\n\ncandidate() {\n    pairs_sum_to_zero \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"1 3 5 0\") = \"false\" ]]\n    [[ $(candidate \"1 3 -2\
  \ 1\") = \"false\" ]]\n    [[ $(candidate \"1 2 3 7\") = \"false\" ]]\n    [[ $(candidate\
  \ \"2 4 -5 3 5 7\") = \"true\" ]]\n    [[ $(candidate \"1\") = \"false\" ]]\n  \
  \  [[ $(candidate \"-3 9 -1 3 2 30\") = \"true\" ]]\n    [[ $(candidate \"-3 9 -1\
  \ 3 2 31\") = \"true\" ]]\n    [[ $(candidate \"-3 9 -1 4 2 30\") = \"false\" ]]\n\
  \    [[ $(candidate \"-3 9 -1 4 2 31\") = \"false\" ]]\n}\n\nrun_test"
completions: ["  # your code here\n  return", "  local list=($1)\n  local i j\n  for\
    \ ((i=0; i<${#list[@]}; i++)); do\n    for ((j=i+1; j<${#list[@]}; j++)); do\n\
    \      if [ $((list[i] + list[j])) -eq 0 ]; then\n        echo \"true\"\n    \
    \    return\n      fi\n    done\n  done\n  echo \"false\"", "    # your code here\n\
    \    return 0", "  local nums=($1)\n  local nums_len=${#nums[@]}\n  local i\n\
    \  local j\n  local sum\n  for ((i=0; i<nums_len; i++)); do\n    for ((j=i+1;\
    \ j<nums_len; j++)); do\n      sum=$((nums[i] + nums[j]))\n      if [[ $sum -eq\
    \ 0 ]]; then\n        echo \"true\"\n        return\n      fi\n    done\n  done\n\
    \  echo \"false\"", "  local -a numbers=($1)\n  local -a positive_numbers=()\n\
    \  local -a negative_numbers=()\n  local -a zero_numbers=()\n  local -a positive_numbers_set=()\n\
    \  local -a negative_numbers_set=()\n  local -a zero_numbers_set=()\n  local -a\
    \ positive_numbers_set_sorted=()\n  local -a negative_numbers_set_sorted=()\n\
    \  local -a zero_numbers_set_sorted=()\n  local -a positive_numbers_sorted=()\n\
    \  local -a negative_numbers_sorted=()\n  local -a zero_numbers_sorted=()\n  local\
    \ -a positive_numbers_sorted_set=()\n  local -a negative_numbers_sorted_set=()\n\
    \  local -a zero_numbers_sorted_set=()\n  local -a positive_numbers_sorted_set_sorted=()\n\
    \  local -a negative_numbers_sorted_set_sorted=()\n  local -a zero_numbers_sorted_set_sorted=()\n\
    \  local -a positive_numbers_sorted_sorted=()\n  local -a negative_numbers_sorted_sorted=()\n\
    \  local -a zero_numbers_sorted_sorted=()\n  local -a positive_numbers_sorted_sorted_set=()\n\
    \  local -a negative_numbers_sorted_sorted_set=()\n  local -a zero_numbers_sorted_sorted_set=()\n\
    \  local -a positive_numbers_sorted_sorted_set_sorted=()\n  local -a negative_numbers_sorted_sorted_set_sorted=()\n\
    \  local -a zero_numbers_sorted_sorted_set_sorted=()\n  local -a positive_numbers_sorted_sorted_sorted=()\n\
    \  local -a negative_numbers_sorted_sorted_sorted=()\n  local -a zero_numbers_sorted_sorted_sorted=()\n",
  "    # TODO: implement this function\n    # Hint: you can use the following bash\
    \ functions:\n    #   - sort\n    #   - uniq\n    #   - wc\n    #   - grep\n \
    \   #   - tr\n    #   - expr\n    #   - cut\n    #   - head\n    #   - tail\n\
    \    #   - seq\n    #   - for\n    #   - while\n    #   - if\n    #   - test\n\
    \    #   - echo\n    #   - read\n    #   - set\n    #   - declare\n    #   - local\n\
    \    #   - readonly\n    #   - shift\n    #   - let\n    #   - continue\n    #\
    \   - break\n    #   - return\n    #   - eval\n    #   - exec\n    #   - exit\n\
    \    #   - trap\n    #   - kill\n    #   - killall\n    #   - wait\n    #   -\
    \ waitpid\n    #   - wait $!\n    #   - false\n    #   - true\n    #   - :\n \
    \   #   - true\n    #   - false\n    #   - printf\n    #   - cat\n    #   - tee\n\
    \    #   - mktemp\n    #   - rm\n    #   - mv\n    #   - cp\n    #   - ln\n  \
    \  #   - chmod\n    #   - chown\n    #   - chgrp\n    #   - touch\n    #   - stat\n\
    \    #   - lstat\n    #   - file\n    #   - which\n    #   - type\n    #   - hash\n\
    \    #   - alias\n    #   - unalias\n    #   - readonly\n    #   - export\n  \
    \  #   - declare\n    #   - typeset\n    #   - getopts\n    #   - set\n    # \
    \  - shift\n    #   - shopt\n    #   - cd\n    #   - pwd\n    #   - umask\n  \
    \  #   - pushd\n    #   - popd\n    #   - dirs\n    #   - time\n    #   - times\n\
    \    #   - timeout\n    #   - command\n", "  local -a array\n  array=($1)\n  local\
    \ -a seen\n  for ((i=0; i<${#array[@]}; i++)); do\n    for ((j=i+1; j<${#array[@]};\
    \ j++)); do\n      if [[ ${array[i]} -eq -${array[j]} ]]; then\n        echo \"\
    true\"\n        return\n      fi\n    done\n  done\n  echo \"false\"", "  # TODO:\
    \ implement this function\n  # Hint: you can use the following bash commands:\n\
    \  # - sort\n  # - uniq\n  # - grep\n  # - wc\n  # - sed\n  # - tr\n  # - cut\n\
    \  # - paste\n  # - join\n  # - comm\n  # - diff\n  # - awk\n  # - bc\n  # - expr\n\
    \  # - read\n  # - echo\n  # - printf\n  # - test\n  # - [[\n  # - let\n  # -\
    \ for\n  # - while\n  # - until\n  # - if\n  # - case\n  # - break\n  # - continue\n\
    \  # - return\n  # - true\n  # - false\n  # - :\n  # - exit\n  # - readonly\n\
    \  # - declare\n  # - local\n  # - export\n  # - read\n  # - eval\n  # - exec\n\
    \  # - set\n  # - trap\n  # - kill\n  # - exit\n  # - wait\n  # - waitpid\n  #\
    \ - sleep\n  # - jobs\n  # - fg\n  # - bg\n  # - kill\n  # - killall\n  # - disown\n\
    \  # - wait\n  # - waitpid\n  # - sleep\n  # - jobs\n  # - fg\n  # - bg\n  # -\
    \ kill\n  # - killall\n  # - disown\n  # - wait\n  # - waitpid\n  # - sleep\n\
    \  # - jobs\n  # - fg\n  # - bg\n  # - kill\n  # - killall\n  # - disown\n  #\
    \ - wait\n  # - waitpid\n  # - sleep\n  # - jobs\n  # - fg\n  # - bg\n  # - kill\n\
    \  # - killall\n  # - disown\n  # - wait\n  # - waitpid\n  # - sleep\n  # - jobs\n\
    \  # - fg\n  # - bg\n  # - kill\n  # - killall\n  # - disown\n  # - wait\n  #\
    \ - waitpid\n  # - sleep\n  # -", "  local input=($1)\n  local i\n  local j\n\
    \  for ((i=0; i<${#input[@]}; i++)); do\n    for ((j=i+1; j<${#input[@]}; j++));\
    \ do\n      if [[ ${input[i]} + ${input[j]} -eq 0 ]]; then\n        echo \"true\"\
    \n        return\n      fi\n    done\n  done\n  echo \"false\"", "  # your code\
    \ here\n  return 0", "    # your code here\n    return 0", "  # TODO: implement\
    \ this function\n  return", "  # your code here\n  # hint: use a for loop\n  #\
    \ hint: use a nested for loop\n  # hint: use a conditional\n  # hint: use a variable\
    \ to keep track of whether you've found a pair\n  # hint: use the break statement\
    \ to exit the loop\n  # hint: use the continue statement to skip to the next iteration\
    \ of the loop\n  # hint: use the return statement to exit the function\n  # hint:\
    \ use the echo statement to return a value\n  # hint: use the test command to\
    \ compare integers\n  # hint: use the test command to compare strings\n  # hint:\
    \ use the test command to compare files\n  # hint: use the test command to compare\
    \ directories\n  # hint: use the test command to compare symbolic links\n  # hint:\
    \ use the test command to compare files by their type\n  # hint: use the test\
    \ command to compare files by their permissions\n  # hint: use the test command\
    \ to compare files by their size\n  # hint: use the test command to compare files\
    \ by their modification time\n  # hint: use the test command to compare files\
    \ by their owner\n  # hint: use the test command to compare files by their group\n\
    \  # hint: use the test command to compare files by their inode number\n  # hint:\
    \ use the test command to compare files by their device number\n  # hint: use\
    \ the test command to compare files by their number of links\n  # hint: use the\
    \ test command to compare files by their number of blocks\n  # hint: use the test\
    \ command to compare files by their block size\n  # hint: use the test command\
    \ to compare files by their number of blocks\n  # hint: use the test command to\
    \ compare files by their number of blocks\n  # hint: use the test command to compare\
    \ files by their number of blocks\n  # hint: use the test command to compare files\
    \ by their number of blocks\n  # hint: use the test command to compare files by\
    \ their number of blocks\n  # hint: use the test command to compare files by their\
    \ number of blocks\n  # hint: use the test command to compare files by their number\
    \ of blocks\n  # hint: use the test command to compare files by their number of\
    \ blocks\n  # hint: use the test command to compare files by their number of blocks\n\
    \  # hint: use the test command to compare files by their number of", "  # TODO:\
    \ implement this function\n  return 1", "  # TODO: implement this function\n \
    \ # Hint: use a for loop and an associative array\n  # Hint: use the \"declare\
    \ -A\" command to create an associative array\n  # Hint: use the \"declare -i\"\
    \ command to create an integer variable\n  # Hint: use the \"echo -n\" command\
    \ to print without a newline\n  # Hint: use the \"echo -e\" command to print with\
    \ an escape sequence\n  # Hint: use the \"\\t\" escape sequence to insert a tab\
    \ character\n  # Hint: use the \"\\n\" escape sequence to insert a newline character\n\
    \  # Hint: use the \"return\" command to exit the function\n  # Hint: use the\
    \ \"break\" command to exit the for loop\n  # Hint: use the \"continue\" command\
    \ to skip the rest of the for loop\n  # Hint: use the \"read\" command to read\
    \ a line of input\n  # Hint: use the \"read -a\" command to read an array of input\n\
    \  # Hint: use the \"read -r\" command to read a line of input without interpreting\
    \ backslashes\n  # Hint: use the \"read -d\" command to read a line of input until\
    \ a delimiter character\n  # Hint: use the \"read -s\" command to read a line\
    \ of input silently\n  # Hint: use the \"read -n\" command to read a line of input\
    \ with a maximum length\n  # Hint: use the \"read -t\" command to read a line\
    \ of input with a timeout\n  # Hint: use the \"read -u\" command to read a line\
    \ of input from a file descriptor\n  # Hint: use the \"read -p\" command to read\
    \ a line of input with a prompt\n  # Hint: use the \"read -e\" command to read\
    \ a line of input with an editor\n  # Hint: use the \"read -i\" command to read\
    \ a line of input with a default value\n  # Hint: use the \"read -k\" command\
    \ to read a line of input with a key binding\n  # Hint: use the \"read -N\" command\
    \ to read a line of input with a maximum length\n  # Hint: use the \"read -p\"\
    \ command to read a line of", "  local list=($1)\n  local len=${#list[@]}\n  local\
    \ i\n  local j\n  local sum\n  for ((i=0; i<len; i++)); do\n    for ((j=i+1; j<len;\
    \ j++)); do\n      sum=$((list[i] + list[j]))\n      if [[ $sum -eq 0 ]]; then\n\
    \        echo \"true\"\n        return\n      fi\n    done\n  done\n  echo \"\
    false\"", "    # TODO: implement this function\n    return 0", "  local input=\"\
    $1\"\n  local sum=0\n  local pairs=0\n  for i in $input; do\n    for j in $input;\
    \ do\n      if [[ $i -eq $j ]]; then\n        continue\n      fi\n      sum=$((i\
    \ + j))\n      if [[ $sum -eq 0 ]]; then\n        pairs=$((pairs + 1))\n     \
    \ fi\n    done\n  done\n  if [[ $pairs -gt 0 ]]; then\n    echo \"true\"\n  else\n\
    \    echo \"false\"\n  fi", "  local list=($1)\n  local i\n  local j\n  local\
    \ k\n  local len=${#list[@]}\n  for ((i=0; i<len; i++)); do\n    for ((j=i+1;\
    \ j<len; j++)); do\n      for ((k=j+1; k<len; k++)); do\n        if [[ $((list[i]\
    \ + list[j] + list[k])) -eq 0 ]]; then\n          echo \"true\"\n          return\n\
    \        fi\n      done\n    done\n  done\n  echo \"false\"", "  # your code here\n\
    \  return 0"]
stop_tokens:
- "\n}"
