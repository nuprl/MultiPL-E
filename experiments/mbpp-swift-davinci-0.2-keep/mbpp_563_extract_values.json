{
  "name": "mbpp_563_extract_values",
  "language": "swift",
  "prompt": "\n/// Write a function to extract values between quotation marks from a string.\nfunc extract_values(text: String) -> [String] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_values(text: \"\\\"Python\\\", \\\"PHP\\\", \\\"Java\\\"\") == [\"Python\", \"PHP\", \"Java\"])\nassert(extract_values(text: \"\\\"python\\\",\\\"program\\\",\\\"language\\\"\") == [\"python\", \"program\", \"language\"])\nassert(extract_values(text: \"\\\"red\\\",\\\"blue\\\",\\\"green\\\",\\\"yellow\\\"\") == [\"red\", \"blue\", \"green\", \"yellow\"])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            in_quotes = !in_quotes\n        }\n        if in_quotes {\n            end = text.index(after: end)\n        } else {\n            if c == \",\" {\n                result.append(text[start..<end])\n                start = text.index(after: end)\n            }\n            end = text.index(after: end)\n        }\n    }\n    result.append(text[start..<end])\n    return result",
    "    var values: [String] = []\n    var i = 0\n    while i < text.count {\n        if text[i] == \"\\\"\" {\n            var value = \"\"\n            i += 1\n            while i < text.count {\n                if text[i] == \"\\\"\" {\n                    break\n                }\n                value.append(text[i])\n                i += 1\n            }\n            values.append(value)\n        }\n        i += 1\n    }\n    return values",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else { return [] }\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map { String(text[Range($0.range, in: text)!]) }",
    "    var result: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                end = text.characters.index(before: text.characters.index(after: end))\n                result.append(text[start..<end])\n                in_quotes = false\n            } else {\n                start = text.characters.index(after: start)\n                in_quotes = true\n            }\n        } else if in_quotes {\n            end = text.characters.index(after: end)\n        } else {\n            start = text.characters.index(after: start)\n            end = text.characters.index(after: end)\n        }\n    }\n    return result",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map {\n        String(text[Range($0.range, in: text)!])\n    }",
    "    var values = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                values.append(text[start..<end])\n            }\n            in_quotes = !in_quotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    return values",
    "    var result: [String] = []\n    var start = 0\n    var end = 0\n    for (index, char) in text.enumerated() {\n        if char == \"\\\"\" {\n            if start == 0 {\n                start = index + 1\n            } else {\n                end = index\n                result.append(text[start..<end])\n                start = 0\n            }\n        }\n    }\n    return result",
    "    var result = [String]()\n    var start = 0\n    var end = 0\n    var is_inside = false\n    for (i, c) in text.characters.enumerated() {\n        if c == \"\\\"\" {\n            if is_inside {\n                end = i\n                result.append(text[start..<end])\n                is_inside = false\n            } else {\n                start = i + 1\n                is_inside = true\n            }\n        }\n    }\n    return result",
    "    var values: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    \n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                values.append(text[start..<end])\n            }\n            in_quotes = !in_quotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    \n    return values",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else { return [] }\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map { String(text[Range($0.range, in: text)!]) }",
    "    var result: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var in_quotes = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if in_quotes {\n                result.append(text[start..<end])\n            }\n            in_quotes = !in_quotes\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    return result",
    "    var result: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuote = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if inQuote {\n                result.append(text[start..<end])\n            }\n            inQuote = !inQuote\n            start = text.index(after: end)\n        }\n        end = text.index(after: end)\n    }\n    return result",
    "    var result: [String] = []\n    var start = 0\n    var end = 0\n    for (i, c) in text.characters.enumerated() {\n        if c == \"\\\"\" {\n            if start == 0 {\n                start = i + 1\n            } else {\n                end = i\n                result.append(text[start..<end])\n                start = 0\n                end = 0\n            }\n        }\n    }\n    return result",
    "    var values = [String]()\n    var start = text.startIndex\n    var end = text.startIndex\n    var index = text.startIndex\n    var inQuotes = false\n    while index != text.endIndex {\n        if text[index] == \"\\\"\" {\n            if inQuotes {\n                values.append(text[start..<end])\n            }\n            inQuotes = !inQuotes\n            start = index.advancedBy(1)\n        }\n        end = index.advancedBy(1)\n        index = index.advancedBy(1)\n    }\n    return values",
    "    var result = [String]()\n    var start = 0\n    var end = 0\n    for (index, char) in text.enumerated() {\n        if char == \"\\\"\" {\n            if start == 0 {\n                start = index + 1\n            } else {\n                end = index\n                result.append(String(text[start..<end]))\n                start = 0\n            }\n        }\n    }\n    return result",
    "    let pattern = \"\\\"(.*?)\\\"\"\n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map { String(text[Range($0.range, in: text)!]) }",
    "    let regex = try! NSRegularExpression(pattern: \"\\\"(.*?)\\\"\", options: [])\n    let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n    return matches.map { String(text[Range($0.range, in: text)!]) }",
    "    var values: [String] = []\n    let pattern = \"\\\"(.*?)\\\"\"\n    do {\n        let regex = try NSRegularExpression(pattern: pattern, options: [])\n        let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))\n        for match in matches {\n            let range = match.range(at: 1)\n            if let swiftRange = Range(range, in: text) {\n                values.append(String(text[swiftRange]))\n            }\n        }\n    } catch {\n        print(\"invalid regex: \\(error.localizedDescription)\")\n    }\n    return values",
    "    var values: [String] = []\n    var start = text.startIndex\n    var end = text.startIndex\n    var inQuote = false\n    for c in text.characters {\n        if c == \"\\\"\" {\n            if inQuote {\n                values.append(text[start..<end])\n                inQuote = false\n            } else {\n                start = end\n                inQuote = true\n            }\n        }\n        end = end.successor()\n    }\n    return values",
    "    var values = [String]()\n    var start = 0\n    var end = 0\n    var in_quotes = false\n    for (i, c) in text.characters.enumerate() {\n        if c == \"\\\"\" {\n            if in_quotes {\n                end = i\n                values.append(text[start..<end])\n                in_quotes = false\n            } else {\n                start = i + 1\n                in_quotes = true\n            }\n        }\n    }\n    return values"
  ]
}