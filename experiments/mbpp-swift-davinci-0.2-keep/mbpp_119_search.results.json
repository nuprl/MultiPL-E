{
  "name": "mbpp_119_search",
  "language": "swift",
  "prompt": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba74a69cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba74a393561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ba74a393286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ba74a39313c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ba74a392bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ba74a193e83 <unavailable> + 188035\n6    tmpkuwm7g6f                        0x0000561bff8b4888 <unavailable> + 6280\n7    tmpkuwm7g6f                        0x0000561bff8b43e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ba74a888460 __libc_start_main + 245\n9    tmpkuwm7g6f                        0x0000561bff8b40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if mid == 0 {\n            return arr[mid]\n        }\n        if mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba2d2a21c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba2d2718561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ba2d2718286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ba2d271813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ba2d2717bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ba2d2518e83 <unavailable> + 188035\n6    tmpc29pr48x                        0x0000557b8c63a890 <unavailable> + 6288\n7    tmpc29pr48x                        0x0000557b8c63a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ba2d2c0d460 __libc_start_main + 245\n9    tmpc29pr48x                        0x0000557b8c63a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = (low + high) / 2\n        if mid > 0 && arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else if mid < arr.count - 1 && arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmpslp5lo7v/tmpslp5lo7v.swift:41: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae6976c8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae6973bfb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae6973bf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae6973be7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpslp5lo7v                        0x000055fc85025462 <unavailable> + 5218\n5    libc.so.6                          0x00002ae6978b4460 __libc_start_main + 245\n6    tmpslp5lo7v                        0x000055fc850250b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    var mid = 0\n    while start <= end {\n        mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae9d4051c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae9d3d48561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ae9d3d48286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ae9d3d4813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ae9d3d47bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ae9d3b48e83 <unavailable> + 188035\n6    tmppv545v4i                        0x000055b37a487890 <unavailable> + 6288\n7    tmppv545v4i                        0x000055b37a4873e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ae9d423d460 __libc_start_main + 245\n9    tmppv545v4i                        0x000055b37a4870b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmponfm724n/tmponfm724n.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1ab6fe2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1ab6cd9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1ab6cd9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1ab6cd87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmponfm724n                        0x000055cdca93f462 <unavailable> + 5218\n5    libc.so.6                          0x00002b1ab71ce460 __libc_start_main + 245\n6    tmponfm724n                        0x000055cdca93f0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmpvkhc37tn/tmpvkhc37tn.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b051ce9ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b051cb95b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b051cb95988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b051cb947b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpvkhc37tn                        0x000055cfc58ee462 <unavailable> + 5218\n5    libc.so.6                          0x00002b051d08a460 __libc_start_main + 245\n6    tmpvkhc37tn                        0x000055cfc58ee0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1a4d304c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1a4cffb561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b1a4cffb286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b1a4cffb13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b1a4cffabb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b1a4cdfbe83 <unavailable> + 188035\n6    tmp6eo_x_d9                        0x000056007e94c883 <unavailable> + 6275\n7    tmp6eo_x_d9                        0x000056007e94c3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b1a4d4f0460 __libc_start_main + 245\n9    tmp6eo_x_d9                        0x000056007e94c0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp9iohiw6a/tmp9iohiw6a.swift:45: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b18bbe9ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b18bbb95b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b18bbb95988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b18bbb947b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9iohiw6a                        0x00005595fe013462 <unavailable> + 5218\n5    libc.so.6                          0x00002b18bc08a460 __libc_start_main + 245\n6    tmp9iohiw6a                        0x00005595fe0130b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmphjkbw4ug/tmphjkbw4ug.swift:45: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5adc92cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5adc623b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5adc623988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5adc6227b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphjkbw4ug                        0x0000561bc1b61462 <unavailable> + 5218\n5    libc.so.6                          0x00002b5adcb18460 __libc_start_main + 245\n6    tmphjkbw4ug                        0x0000561bc1b610b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    \n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    for i in 0..<arr.count {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == arr.count - 1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aee0b6c1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aee0b3b8561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002aee0b3b8286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002aee0b3b813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002aee0b3b7bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002aee0b1b8e83 <unavailable> + 188035\n6    tmpcs23f58c                        0x000055c155a68888 <unavailable> + 6280\n7    tmpcs23f58c                        0x000055c155a683e4 <unavailable> + 5092\n8    libc.so.6                          0x00002aee0b8ad460 __libc_start_main + 245\n9    tmpcs23f58c                        0x000055c155a680b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmp4iegtpeg/tmp4iegtpeg.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5c397b2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5c394a9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5c394a9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5c394a87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4iegtpeg                        0x00005625e2355462 <unavailable> + 5218\n5    libc.so.6                          0x00002b5c3999e460 __libc_start_main + 245\n6    tmp4iegtpeg                        0x00005625e23550b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abcaab8ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abcaa881561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002abcaa881286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002abcaa88113c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002abcaa880bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002abcaa681e83 <unavailable> + 188035\n6    tmppipixo_r                        0x0000560af74ee888 <unavailable> + 6280\n7    tmppipixo_r                        0x0000560af74ee3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002abcaad76460 __libc_start_main + 245\n9    tmppipixo_r                        0x0000560af74ee0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abcaab8ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abcaa881561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002abcaa881286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002abcaa88113c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002abcaa880bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002abcaa681e83 <unavailable> + 188035\n6    tmppipixo_r                        0x0000560af74ee888 <unavailable> + 6280\n7    tmppipixo_r                        0x0000560af74ee3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002abcaad76460 __libc_start_main + 245\n9    tmppipixo_r                        0x0000560af74ee0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    guard arr.count > 0 else {\n        return -1\n    }\n    \n    var low = 0\n    var high = arr.count - 1\n    \n    while low <= high {\n        let mid = (low + high) / 2\n        \n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        \n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        \n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpdng_hky0/tmpdng_hky0.swift:53: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af81a3c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af81a0bcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af81a0bc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af81a0bb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpdng_hky0                        0x000055ac77df6462 <unavailable> + 5218\n5    libc.so.6                          0x00002af81a5b1460 __libc_start_main + 245\n6    tmpdng_hky0                        0x000055ac77df60b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return arr[arr.count - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    var mid = 0\n    \n    while start <= end {\n        mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    \n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b911716ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9116e65561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b9116e65286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b9116e6513c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b9116e64bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b9116c65e83 <unavailable> + 188035\n6    tmps3kf3hih                        0x0000558e3b0d2890 <unavailable> + 6288\n7    tmps3kf3hih                        0x0000558e3b0d23e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b911735a460 __libc_start_main + 245\n9    tmps3kf3hih                        0x0000558e3b0d20b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1a4d304c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1a4cffb561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b1a4cffb286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b1a4cffb13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b1a4cffabb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b1a4cdfbe83 <unavailable> + 188035\n6    tmp6eo_x_d9                        0x000056007e94c883 <unavailable> + 6275\n7    tmp6eo_x_d9                        0x000056007e94c3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b1a4d4f0460 __libc_start_main + 245\n9    tmp6eo_x_d9                        0x000056007e94c0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpz_lhihyx/tmpz_lhihyx.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7730eb1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7730ba8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7730ba8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7730ba77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz_lhihyx                        0x0000555cf9316462 <unavailable> + 5218\n5    libc.so.6                          0x00002b773109d460 __libc_start_main + 245\n6    tmpz_lhihyx                        0x0000555cf93160b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab2c0140c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab2bfe37561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab2bfe37286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab2bfe3713c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab2bfe36bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ab2bfc37e83 <unavailable> + 188035\n6    tmp30c7zr1o                        0x000055dafe0b9888 <unavailable> + 6280\n7    tmp30c7zr1o                        0x000055dafe0b93e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ab2c032c460 __libc_start_main + 245\n9    tmp30c7zr1o                        0x000055dafe0b90b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == arr.count - 1 {\n            return arr[i]\n        }\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2\n            } else {\n                low = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    \n    while low <= high {\n        let mid = low + (high - low) / 2\n        \n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    \n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    var mid = 0\n    \n    while start <= end {\n        mid = start + (end - start) / 2\n        \n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    \n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3040787c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b304047e561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b304047e286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b304047e13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b304047dbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b304027ee83 <unavailable> + 188035\n6    tmppot7g2p7                        0x00005646119ac8b7 <unavailable> + 6327\n7    tmppot7g2p7                        0x00005646119ac3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b3040973460 __libc_start_main + 245\n9    tmppot7g2p7                        0x00005646119ac0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2fe4533c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2fe422a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b2fe422a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b2fe422a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b2fe4229bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b2fe402ae83 <unavailable> + 188035\n6    tmpxt32fjn7                        0x000055cbc276a78b <unavailable> + 6027\n7    tmpxt32fjn7                        0x000055cbc276a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b2fe471f460 __libc_start_main + 245\n9    tmpxt32fjn7                        0x000055cbc276a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == arr.count - 1 {\n            return arr[i]\n        } else if arr[i] != arr[i + 1] {\n            return arr[i]\n        } else {\n            i += 2\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2fe4533c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2fe422a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b2fe422a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b2fe422a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b2fe4229bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b2fe402ae83 <unavailable> + 188035\n6    tmpxt32fjn7                        0x000055cbc276a78b <unavailable> + 6027\n7    tmpxt32fjn7                        0x000055cbc276a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b2fe471f460 __libc_start_main + 245\n9    tmpxt32fjn7                        0x000055cbc276a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    \n    while low <= high {\n        mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmp9jwsb8e0/tmp9jwsb8e0.swift:42: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b820736ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8207061b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8207061988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b82070607b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9jwsb8e0                        0x000055d858b7d65b <unavailable> + 5723\n5    libc.so.6                          0x00002b8207556460 __libc_start_main + 245\n6    tmp9jwsb8e0                        0x000055d858b7d0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    if arr.count == 0 {\n        return -1\n    }\n    if arr.count == 1 {\n        return arr[0]\n    }\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5b561eac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5b55ee1561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b5b55ee1286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b5b55ee113c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b5b55ee0bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b5b55ce1e83 <unavailable> + 188035\n6    tmpdco0n68x                        0x00005558365f88e3 <unavailable> + 6371\n7    tmpdco0n68x                        0x00005558365f83e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b5b563d6460 __libc_start_main + 245\n9    tmpdco0n68x                        0x00005558365f80b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low < high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    \n    while low <= high {\n        let mid = (low + high) / 2\n        \n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        \n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        \n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpcqsm8lzd/tmpcqsm8lzd.swift:49: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5f8310bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5f82e02b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5f82e02988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5f82e017b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpcqsm8lzd                        0x00005589b0330462 <unavailable> + 5218\n5    libc.so.6                          0x00002b5f832f7460 __libc_start_main + 245\n6    tmpcqsm8lzd                        0x00005589b03300b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    \n    while low <= high {\n        mid = (low + high) / 2\n        \n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            left = mid + 2\n        } else if arr[mid] == arr[mid - 1] {\n            right = mid - 2\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpd0y6mtiw/tmpd0y6mtiw.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b41c172cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b41c1423b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b41c1423988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b41c14227b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd0y6mtiw                        0x0000555cd53ed56b <unavailable> + 5483\n5    libc.so.6                          0x00002b41c1918460 __libc_start_main + 245\n6    tmpd0y6mtiw                        0x0000555cd53ed0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpnqgdmqfg/tmpnqgdmqfg.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9578a02c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b95786f9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b95786f9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b95786f87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpnqgdmqfg                        0x0000556d38918462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9578bee460 __libc_start_main + 245\n6    tmpnqgdmqfg                        0x0000556d389180b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmplirkxoki/tmplirkxoki.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae9f1001c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae9f0cf8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae9f0cf8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae9f0cf77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmplirkxoki                        0x000055ea3de06462 <unavailable> + 5218\n5    libc.so.6                          0x00002ae9f11ed460 __libc_start_main + 245\n6    tmplirkxoki                        0x000055ea3de060b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpz_lhihyx/tmpz_lhihyx.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7730eb1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7730ba8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7730ba8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7730ba77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz_lhihyx                        0x0000555cf9316462 <unavailable> + 5218\n5    libc.so.6                          0x00002b773109d460 __libc_start_main + 245\n6    tmpz_lhihyx                        0x0000555cf93160b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == 0 {\n            if arr[i] != arr[i + 1] {\n                return arr[i]\n            }\n        } else if i == arr.count - 1 {\n            if arr[i] != arr[i - 1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i - 1] && arr[i] != arr[i + 1] {\n                return arr[i]\n            }\n        }\n        i += 1\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpj796s_mg/tmpj796s_mg.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b32841e8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3283edfb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3283edf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3283ede7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpj796s_mg                        0x000055fae7399462 <unavailable> + 5218\n5    libc.so.6                          0x00002b32843d4460 __libc_start_main + 245\n6    tmpj796s_mg                        0x000055fae73990b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b12b7634c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b12b732b561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b12b732b286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b12b732b13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b12b732abb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b12b712be83 <unavailable> + 188035\n6    tmpqq1imvyy                        0x000055c8bbb1b8af <unavailable> + 6319\n7    tmpqq1imvyy                        0x000055c8bbb1b3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b12b7820460 __libc_start_main + 245\n9    tmpqq1imvyy                        0x000055c8bbb1b0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    \n    while low <= high {\n        mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpybjrdi8y/tmpybjrdi8y.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad7fb685c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad7fb37cb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad7fb37c988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad7fb37b7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpybjrdi8y                        0x000055d5fc357462 <unavailable> + 5218\n5    libc.so.6                          0x00002ad7fb871460 __libc_start_main + 245\n6    tmpybjrdi8y                        0x000055d5fc3570b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var index = 0\n    while index < arr.count - 1 {\n        if arr[index] == arr[index + 1] {\n            index += 2\n        } else {\n            return arr[index]\n        }\n    }\n    return arr[index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2\n            } else {\n                low = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad792e1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad78fd8561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002aad78fd8286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002aad78fd813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002aad78fd7bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002aad78dd8e83 <unavailable> + 188035\n6    tmple5mcvu_                        0x000055fc869a48b7 <unavailable> + 6327\n7    tmple5mcvu_                        0x000055fc869a43e4 <unavailable> + 5092\n8    libc.so.6                          0x00002aad794cd460 __libc_start_main + 245\n9    tmple5mcvu_                        0x000055fc869a40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b73c323fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b73c2f36561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b73c2f36286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b73c2f3613c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b73c2f35bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b73c2d36e83 <unavailable> + 188035\n6    tmp4ahxyhg2                        0x000055fe3d179888 <unavailable> + 6280\n7    tmp4ahxyhg2                        0x000055fe3d1793e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b73c342b460 __libc_start_main + 245\n9    tmp4ahxyhg2                        0x000055fe3d1790b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b12b7634c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b12b732b561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b12b732b286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b12b732b13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b12b732abb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b12b712be83 <unavailable> + 188035\n6    tmpqq1imvyy                        0x000055c8bbb1b8af <unavailable> + 6319\n7    tmpqq1imvyy                        0x000055c8bbb1b3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b12b7820460 __libc_start_main + 245\n9    tmpqq1imvyy                        0x000055c8bbb1b0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = left + (right - left) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9859482c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9859179561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b9859179286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b985917913c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b9859178bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b9858f79e83 <unavailable> + 188035\n6    tmp68ei82ue                        0x000055aa001298af <unavailable> + 6319\n7    tmp68ei82ue                        0x000055aa001293e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b985966e460 __libc_start_main + 245\n9    tmp68ei82ue                        0x000055aa001290b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    \n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmpvkhc37tn/tmpvkhc37tn.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b051ce9ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b051cb95b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b051cb95988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b051cb947b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpvkhc37tn                        0x000055cfc58ee462 <unavailable> + 5218\n5    libc.so.6                          0x00002b051d08a460 __libc_start_main + 245\n6    tmpvkhc37tn                        0x000055cfc58ee0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aad792e1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aad78fd8561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002aad78fd8286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002aad78fd813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002aad78fd7bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002aad78dd8e83 <unavailable> + 188035\n6    tmple5mcvu_                        0x000055fc869a48b7 <unavailable> + 6327\n7    tmple5mcvu_                        0x000055fc869a43e4 <unavailable> + 5092\n8    libc.so.6                          0x00002aad794cd460 __libc_start_main + 245\n9    tmple5mcvu_                        0x000055fc869a40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    \n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmp78hz6xy4/tmp78hz6xy4.swift:45: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acd337e3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acd334dab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acd334da988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acd334d97b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp78hz6xy4                        0x000055eda0eaa462 <unavailable> + 5218\n5    libc.so.6                          0x00002acd339cf460 __libc_start_main + 245\n6    tmp78hz6xy4                        0x000055eda0eaa0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start < end {\n        let mid = (start + end) / 2\n        if arr[mid] == arr[mid + 1] {\n            start = mid + 2\n        } else if arr[mid] == arr[mid - 1] {\n            end = mid - 2\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpohno8nc_/tmpohno8nc_.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af923c41c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af923938b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af923938988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af9239377b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpohno8nc_                        0x00005612661e256b <unavailable> + 5483\n5    libc.so.6                          0x00002af923e2d460 __libc_start_main + 245\n6    tmpohno8nc_                        0x00005612661e20b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left <= right {\n        let mid = (left + right) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmp5rd4mdov/tmp5rd4mdov.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad14a04dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad149d44b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad149d44988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad149d437b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp5rd4mdov                        0x000055a8ebc23462 <unavailable> + 5218\n5    libc.so.6                          0x00002ad14a239460 __libc_start_main + 245\n6    tmp5rd4mdov                        0x000055a8ebc230b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            left = mid + 2\n        } else if arr[mid] == arr[mid - 1] {\n            right = mid - 2\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpd0y6mtiw/tmpd0y6mtiw.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b41c172cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b41c1423b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b41c1423988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b41c14227b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd0y6mtiw                        0x0000555cd53ed56b <unavailable> + 5483\n5    libc.so.6                          0x00002b41c1918460 __libc_start_main + 245\n6    tmpd0y6mtiw                        0x0000555cd53ed0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab2c0140c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab2bfe37561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab2bfe37286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab2bfe3713c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab2bfe36bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ab2bfc37e83 <unavailable> + 188035\n6    tmp30c7zr1o                        0x000055dafe0b9888 <unavailable> + 6280\n7    tmp30c7zr1o                        0x000055dafe0b93e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ab2c032c460 __libc_start_main + 245\n9    tmp30c7zr1o                        0x000055dafe0b90b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpu9jy4_7t/tmpu9jy4_7t.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad712705c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad7123fcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad7123fc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad7123fb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpu9jy4_7t                        0x0000564a17614462 <unavailable> + 5218\n5    libc.so.6                          0x00002ad7128f1460 __libc_start_main + 245\n6    tmpu9jy4_7t                        0x0000564a176140b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == 0 && arr[i] != arr[i + 1] {\n            return arr[i]\n        } else if i == arr.count - 1 && arr[i] != arr[i - 1] {\n            return arr[i]\n        } else if arr[i] != arr[i - 1] && arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 1\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8ac83ebc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8ac80e2561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b8ac80e2286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b8ac80e213c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b8ac80e1bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b8ac7ee2e83 <unavailable> + 188035\n6    tmpvvhizwxv                        0x000055bde47e4825 <unavailable> + 6181\n7    tmpvvhizwxv                        0x000055bde47e4344 <unavailable> + 4932\n8    libc.so.6                          0x00002b8ac85d7460 __libc_start_main + 245\n9    tmpvvhizwxv                        0x000055bde47e4019 <unavailable> + 4121\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpz_lhihyx/tmpz_lhihyx.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7730eb1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7730ba8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7730ba8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7730ba77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz_lhihyx                        0x0000555cf9316462 <unavailable> + 5218\n5    libc.so.6                          0x00002b773109d460 __libc_start_main + 245\n6    tmpz_lhihyx                        0x0000555cf93160b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    var mid = 0\n    while start <= end {\n        mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac8592f4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac858feb561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ac858feb286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ac858feb13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ac858feabb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ac858debe83 <unavailable> + 188035\n6    tmpcokj81jj                        0x000056327e527890 <unavailable> + 6288\n7    tmpcokj81jj                        0x000056327e5273e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ac8594e0460 __libc_start_main + 245\n9    tmpcokj81jj                        0x000056327e5270b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    \n    while low <= high {\n        mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        }\n        if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpv0jmd1a2/tmpv0jmd1a2.swift:47: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ace89316c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ace8900db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ace8900d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ace8900c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpv0jmd1a2                        0x000055ba305b2462 <unavailable> + 5218\n5    libc.so.6                          0x00002ace89502460 __libc_start_main + 245\n6    tmpv0jmd1a2                        0x000055ba305b20b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == arr.count - 1 {\n            return arr[i]\n        }\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    \n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start < end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmp0fab087i/tmp0fab087i.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac958431c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac958128b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac958128988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac9581277b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0fab087i                        0x00005642ed944462 <unavailable> + 5218\n5    libc.so.6                          0x00002ac95861d460 __libc_start_main + 245\n6    tmp0fab087i                        0x00005642ed9440b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = left + (right - left) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5b76dd7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5b76ace561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b5b76ace286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b5b76ace13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b5b76acdbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b5b768cee83 <unavailable> + 188035\n6    tmp0dxr64ze                        0x00005648b13e17af <unavailable> + 6063\n7    tmp0dxr64ze                        0x00005648b13e13e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b5b76fc3460 __libc_start_main + 245\n9    tmp0dxr64ze                        0x00005648b13e10b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpz_lhihyx/tmpz_lhihyx.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7730eb1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7730ba8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7730ba8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7730ba77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz_lhihyx                        0x0000555cf9316462 <unavailable> + 5218\n5    libc.so.6                          0x00002b773109d460 __libc_start_main + 245\n6    tmpz_lhihyx                        0x0000555cf93160b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 2\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var result = 0\n    for i in 0..<arr.count {\n        result ^= arr[i]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    \n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        \n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        \n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpk7mvqusn/tmpk7mvqusn.swift:48: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b94c4f94c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b94c4c8bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b94c4c8b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b94c4c8a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpk7mvqusn                        0x0000555985fd4462 <unavailable> + 5218\n5    libc.so.6                          0x00002b94c5180460 __libc_start_main + 245\n6    tmpk7mvqusn                        0x0000555985fd40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2fe4533c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2fe422a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b2fe422a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b2fe422a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b2fe4229bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b2fe402ae83 <unavailable> + 188035\n6    tmpxt32fjn7                        0x000055cbc276a78b <unavailable> + 6027\n7    tmpxt32fjn7                        0x000055cbc276a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b2fe471f460 __libc_start_main + 245\n9    tmpxt32fjn7                        0x000055cbc276a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low < high {\n        let mid = low + (high - low) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpndo64dg2/tmpndo64dg2.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b254c3a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b254c09ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b254c09a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b254c0997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpndo64dg2                        0x0000558860628462 <unavailable> + 5218\n5    libc.so.6                          0x00002b254c58f460 __libc_start_main + 245\n6    tmpndo64dg2                        0x00005588606280b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == arr.count - 1 {\n            return arr[i]\n        } else if arr[i] != arr[i+1] {\n            return arr[i]\n        } else {\n            i += 2\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    var mid = 0\n    while low <= high {\n        mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba2d2a21c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba2d2718561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ba2d2718286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ba2d271813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ba2d2717bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ba2d2518e83 <unavailable> + 188035\n6    tmpc29pr48x                        0x0000557b8c63a890 <unavailable> + 6288\n7    tmpc29pr48x                        0x0000557b8c63a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ba2d2c0d460 __libc_start_main + 245\n9    tmpc29pr48x                        0x0000557b8c63a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    \n    while low <= high {\n        let mid = (low + high) / 2\n        \n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    \n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac34ec83c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac34e97a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ac34e97a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ac34e97a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ac34e979bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ac34e77ae83 <unavailable> + 188035\n6    tmprr1f89xj                        0x0000562cac7d0888 <unavailable> + 6280\n7    tmprr1f89xj                        0x0000562cac7d03e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ac34ee6f460 __libc_start_main + 245\n9    tmprr1f89xj                        0x0000562cac7d00b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var result = 0\n    for i in 0..<arr.count {\n        result ^= arr[i]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpfk4tipi9/tmpfk4tipi9.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9a89523c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9a8921ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9a8921a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9a892197b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpfk4tipi9                        0x000055c726038462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9a8970f460 __libc_start_main + 245\n6    tmpfk4tipi9                        0x000055c7260380b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2fe4533c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2fe422a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b2fe422a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b2fe422a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b2fe4229bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b2fe402ae83 <unavailable> + 188035\n6    tmpxt32fjn7                        0x000055cbc276a78b <unavailable> + 6027\n7    tmpxt32fjn7                        0x000055cbc276a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b2fe471f460 __libc_start_main + 245\n9    tmpxt32fjn7                        0x000055cbc276a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    \n    while left <= right {\n        let mid = (left + right) / 2\n        \n        if mid == 0 {\n            return arr[mid]\n        }\n        \n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        \n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b00a850ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b00a8201561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b00a8201286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b00a820113c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b00a8200bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b00a8001e83 <unavailable> + 188035\n6    tmpruumopsg                        0x000055cd121438a4 <unavailable> + 6308\n7    tmpruumopsg                        0x000055cd121433e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b00a86f6460 __libc_start_main + 245\n9    tmpruumopsg                        0x000055cd121430b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpz_lhihyx/tmpz_lhihyx.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7730eb1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7730ba8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7730ba8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7730ba77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz_lhihyx                        0x0000555cf9316462 <unavailable> + 5218\n5    libc.so.6                          0x00002b773109d460 __libc_start_main + 245\n6    tmpz_lhihyx                        0x0000555cf93160b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    \n    while left <= right {\n        let mid = (left + right) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        \n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        \n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba74a69cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba74a393561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ba74a393286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ba74a39313c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ba74a392bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ba74a193e83 <unavailable> + 188035\n6    tmpkuwm7g6f                        0x0000561bff8b4888 <unavailable> + 6280\n7    tmpkuwm7g6f                        0x0000561bff8b43e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ba74a888460 __libc_start_main + 245\n9    tmpkuwm7g6f                        0x0000561bff8b40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 2\n            } else {\n                start = mid + 1\n            }\n        }\n        if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpy3w6grbj/tmpy3w6grbj.swift:46: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2d11155c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2d10e4cb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2d10e4c988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2d10e4b7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpy3w6grbj                        0x000055fff90c456b <unavailable> + 5483\n5    libc.so.6                          0x00002b2d11341460 __libc_start_main + 245\n6    tmpy3w6grbj                        0x000055fff90c40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba74a69cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba74a393561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ba74a393286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ba74a39313c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ba74a392bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ba74a193e83 <unavailable> + 188035\n6    tmpkuwm7g6f                        0x0000561bff8b4888 <unavailable> + 6280\n7    tmpkuwm7g6f                        0x0000561bff8b43e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ba74a888460 __libc_start_main + 245\n9    tmpkuwm7g6f                        0x0000561bff8b40b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmp7vu9hxe_/tmp7vu9hxe_.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9d894a3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9d8919ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9d8919a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9d891997b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7vu9hxe_                        0x000055c5c0381462 <unavailable> + 5218\n5    libc.so.6                          0x00002b9d8968f460 __libc_start_main + 245\n6    tmp7vu9hxe_                        0x000055c5c03810b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "tmponfm724n/tmponfm724n.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1ab6fe2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1ab6cd9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1ab6cd9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1ab6cd87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmponfm724n                        0x000055cdca93f462 <unavailable> + 5218\n5    libc.so.6                          0x00002b1ab71ce460 __libc_start_main + 245\n6    tmponfm724n                        0x000055cdca93f0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b86668b5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b86665ac561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b86665ac286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b86665ac13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b86665abbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b86663ace83 <unavailable> + 188035\n6    tmp3pf27hhd                        0x0000556fd757578b <unavailable> + 6027\n7    tmp3pf27hhd                        0x0000556fd75753e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b8666aa1460 __libc_start_main + 245\n9    tmp3pf27hhd                        0x0000556fd75750b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmp4iegtpeg/tmp4iegtpeg.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5c397b2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5c394a9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5c394a9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5c394a87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4iegtpeg                        0x00005625e2355462 <unavailable> + 5218\n5    libc.so.6                          0x00002b5c3999e460 __libc_start_main + 245\n6    tmp4iegtpeg                        0x00005625e23550b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return arr[arr.count - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 2\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmp4iegtpeg/tmp4iegtpeg.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5c397b2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5c394a9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5c394a9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5c394a87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4iegtpeg                        0x00005625e2355462 <unavailable> + 5218\n5    libc.so.6                          0x00002b5c3999e460 __libc_start_main + 245\n6    tmp4iegtpeg                        0x00005625e23550b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    guard arr.count > 0 else {\n        return -1\n    }\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid > 0 && arr[mid] == arr[mid - 1] {\n            if (mid - 2) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 2\n            }\n        } else if mid < arr.count - 1 && arr[mid] == arr[mid + 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpi3ww46no/tmpi3ww46no.swift:40: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aca1bc72c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aca1b969b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aca1b969988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aca1b9687b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi3ww46no                        0x000055affed92462 <unavailable> + 5218\n5    libc.so.6                          0x00002aca1be5e460 __libc_start_main + 245\n6    tmpi3ww46no                        0x000055affed920b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    guard arr.count > 0 else { return -1 }\n    guard arr.count > 1 else { return arr[0] }\n    \n    var start = 0\n    var end = arr.count - 1\n    \n    while start <= end {\n        let mid = (start + end) / 2\n        \n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    \n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac39a6f9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac39a3f0561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ac39a3f0286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ac39a3f013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ac39a3efbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ac39a1f0e83 <unavailable> + 188035\n6    tmpix9jzixe                        0x000055dafa3a58bf <unavailable> + 6335\n7    tmpix9jzixe                        0x000055dafa3a53e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ac39a8e5460 __libc_start_main + 245\n9    tmpix9jzixe                        0x000055dafa3a50b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2fe4533c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2fe422a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b2fe422a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b2fe422a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b2fe4229bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b2fe402ae83 <unavailable> + 188035\n6    tmpxt32fjn7                        0x000055cbc276a78b <unavailable> + 6027\n7    tmpxt32fjn7                        0x000055cbc276a3e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b2fe471f460 __libc_start_main + 245\n9    tmpxt32fjn7                        0x000055cbc276a0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = left + (right - left) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return arr[low]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b73c323fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b73c2f36561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b73c2f36286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b73c2f3613c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b73c2f35bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b73c2d36e83 <unavailable> + 188035\n6    tmp4ahxyhg2                        0x000055fe3d179888 <unavailable> + 6280\n7    tmp4ahxyhg2                        0x000055fe3d1793e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b73c342b460 __libc_start_main + 245\n9    tmp4ahxyhg2                        0x000055fe3d1790b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 1\n            } else {\n                start = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    \n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count {\n        if i == arr.count - 1 {\n            return arr[i]\n        }\n        if arr[i] != arr[i+1] {\n            return arr[i]\n        }\n        i += 2\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var i = 0\n    while i < arr.count - 1 {\n        if arr[i] == arr[i + 1] {\n            i += 2\n        } else {\n            return arr[i]\n        }\n    }\n    return arr[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 1\n            } else {\n                end = mid - 2\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                start = mid + 2\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "tmpboz906n3/tmpboz906n3.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae70826fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae707f66b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae707f66988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae707f657b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpboz906n3                        0x0000559849adc462 <unavailable> + 5218\n5    libc.so.6                          0x00002ae70845b460 __libc_start_main + 245\n6    tmpboz906n3                        0x0000559849adc0b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid - 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 1\n            } else {\n                right = mid - 2\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 1\n            } else {\n                left = mid + 2\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b382a905c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b382a5fc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b382a5fc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b382a5fc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b382a5fbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002b382a3fce83 <unavailable> + 188035\n6    tmprjnsqncj                        0x000055760b57878b <unavailable> + 6027\n7    tmprjnsqncj                        0x000055760b5783e4 <unavailable> + 5092\n8    libc.so.6                          0x00002b382aaf1460 __libc_start_main + 245\n9    tmprjnsqncj                        0x000055760b5780b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if arr[mid] == arr[mid + 1] {\n            if (mid - left) % 2 == 0 {\n                left = mid + 2\n            } else {\n                right = mid - 1\n            }\n        } else if arr[mid] == arr[mid - 1] {\n            if (right - mid) % 2 == 0 {\n                right = mid - 2\n            } else {\n                left = mid + 1\n            }\n        } else {\n            return arr[mid]\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid % 2 == 0 {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2\n            } else {\n                return arr[mid]\n            }\n        } else {\n            if mid + 1 < arr.count && arr[mid] == arr[mid + 1] {\n                high = mid - 1\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                return arr[mid]\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var left = 0\n    var right = arr.count - 1\n    while left < right {\n        let mid = (left + right) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2\n            } else {\n                right = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    return arr[left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1665517411,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "tmpz_lhihyx/tmpz_lhihyx.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7730eb1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7730ba8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7730ba8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7730ba77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz_lhihyx                        0x0000555cf9316462 <unavailable> + 5218\n5    libc.so.6                          0x00002b773109d460 __libc_start_main + 245\n6    tmpz_lhihyx                        0x0000555cf93160b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    \n    while start <= end {\n        let mid = (start + end) / 2\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return arr[start]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba607cb4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba6079ab561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ba6079ab286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ba6079ab13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ba6079aabb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002ba6077abe83 <unavailable> + 188035\n6    tmpyupjpbjp                        0x00005611ba1d2888 <unavailable> + 6280\n7    tmpyupjpbjp                        0x00005611ba1d23e4 <unavailable> + 5092\n8    libc.so.6                          0x00002ba607ea0460 __libc_start_main + 245\n9    tmpyupjpbjp                        0x00005611ba1d20b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var start = 0\n    var end = arr.count - 1\n    while start <= end {\n        let mid = (start + end) / 2\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2\n            } else {\n                end = mid - 2\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1\n            } else {\n                end = mid - 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfc43dcc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfc40d3561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002abfc40d3286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002abfc40d313c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002abfc40d2bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    libswiftSwiftOnoneSupport.so       0x00002abfc3ed3e83 <unavailable> + 188035\n6    tmpt8ht_k_0                        0x00005607b0589883 <unavailable> + 6275\n7    tmpt8ht_k_0                        0x00005607b05893e4 <unavailable> + 5092\n8    libc.so.6                          0x00002abfc45c8460 __libc_start_main + 245\n9    tmpt8ht_k_0                        0x00005607b05890b9 <unavailable> + 4281\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = low + (high - low) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123328,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n    var low = 0\n    var high = arr.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if mid == 0 || mid == arr.count - 1 {\n            return arr[mid]\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid]\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1\n            } else {\n                high = mid - 2\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1\n            } else {\n                low = mid + 2\n            }\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)",
      "timestamp": 1666123327,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}