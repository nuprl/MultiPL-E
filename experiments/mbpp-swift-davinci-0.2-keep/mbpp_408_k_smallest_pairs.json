{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "swift",
  "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if max![0] + max![1] > nums1[i] + nums2[j] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, index) = heap.remove()\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var visited = [[Bool]]()\n    for _ in 0..<nums1.count {\n        visited.append(Array(repeating: false, count: nums2.count))\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if !visited[i][j] {\n                heap.insert([nums1[i], nums2[j]])\n                visited[i][j] = true\n            }\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    var count = 0\n    while count < k && index.contains(nums2.count) == false {\n        var min_value = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_value {\n                min_value = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        count += 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        result.append([heap.extract()!])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if index < k {\n                result.append([nums1[i], nums2[j]])\n                index += 1\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.extract() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.replace(element: (sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.pop()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let pair = heap.remove()!\n        result.append([pair.0, pair.1])\n        if pair.1 < nums2.last! {\n            let next = (pair.0, pair.1 + 1)\n            heap.insert(next)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $1.0 < $1.0 + $0.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    \n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        \n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                if nums1[i] + nums2[j] == sum {\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.delete() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        let i = nums1.index(where: { $0 + nums2[0] == sum })!\n        let j = nums2.index(where: { $0 + nums1[i] == sum })!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.0 < $1.0 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i] + nums2[0], i, 0))\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, i, j) = heap.pop()!\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < nums2.count {\n            heap.push((nums1[i] + nums2[j + 1], i, j + 1))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i], nums2[j]))\n            } else if nums1[i] + nums2[j] < heap.peek()!.0 + heap.peek()!.1 {\n                heap.remove()\n                heap.insert((nums1[i], nums2[j]))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!.0, heap.remove()!.1])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((i, j, nums1[i] + nums2[j]))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        let (i, j, _) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (n1, n2) = heap.pop() {\n            result.append([n1, n2])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append([heap.extract()!, heap.extract()!])\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !pq.isEmpty && k > 0 {\n        result.append([pq.dequeue()!.0, pq.dequeue()!.1])\n        k -= 1\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue((nums1[i], nums2[j]))\n            if pq.count > k {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty {\n            break\n        }\n        let (x, y) = heap.pop()!\n        result.append([x, y])\n        if y < nums2.last! {\n            heap.insert((x, y + 1))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        if let (a, b) = heap.remove() {\n            result.append([a, b])\n        }\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    var visited = Set<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n                visited.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n                visited.insert(sum)\n            }\n        }\n    }\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if visited.contains(sum) {\n                result.append([nums1[i], nums2[j]])\n            }\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    while index1 < nums1.count && index2 < nums2.count && result.count < k {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, _) = heap.pop() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (num1, num2) = heap.remove()!\n        result.append([num1, num2])\n        k -= 1\n        if num2 < nums2.last! {\n            let next = nums2.firstIndex(of: num2)! + 1\n            heap.insert((num1, nums2[next]))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i] + nums2[j], i + j))\n            } else if nums1[i] + nums2[j] < heap.peek()!.0 {\n                heap.insert((nums1[i] + nums2[j], i + j))\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index], nums2[index]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<min(k, nums1.count) {\n        for j in 0..<min(k, nums2.count) {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result.sorted { $0[0] + $0[1] < $1[0] + $1[1] }",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(order: <)\n    for i in 0..<nums1.count {\n        heap.push((nums1[i] + nums2[0], 0))\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, index) = heap.pop()!\n        result.append([sum - nums2[index], nums2[index]])\n        if index + 1 < nums2.count {\n            heap.push((sum - nums2[index] + nums2[index + 1], index + 1))\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            heap.insert(num1 + num2)\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append(value)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    while k > 0 {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n        k -= 1\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.0 < $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.dequeue()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            let i = index / nums2.count\n            let j = index % nums2.count\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while heap.count > 0 && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        heap.insert([nums1[i], nums2[0], 0])\n    }\n    \n    for _ in 0..<k {\n        if heap.count > 0 {\n            let pair = heap.remove()\n            result.append([pair[0], pair[1]])\n            if pair[2] < nums2.count - 1 {\n                heap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1])\n            }\n        } else {\n            break\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        k -= 1\n        if n2 < nums2.last! {\n            let index = nums2.index(of: n2)!\n            heap.insert((n1, nums2[index + 1]))\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            res.append([pair.0, pair.1])\n        }\n    }\n    \n    return res",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return nums1[a.0] + nums2[a.1] < nums1[b.0] + nums2[b.1]\n    })\n    \n    for i in 0..<nums1.count {\n        heap.push((i, 0))\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (i, j) = heap.pop()!\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < nums2.count {\n            heap.push((i, j + 1))\n        }\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        if n2 < nums2.last! {\n            let index = nums2.index(of: n2)!\n            heap.insert((n1, nums2[index + 1]))\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    var count = 0\n    while count < k && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        count += 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    if nums1.isEmpty || nums2.isEmpty {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty {\n            break\n        }\n        let (n1, n2) = heap.pop()!\n        result.append([n1, n2])\n        if n2 != nums2.last! {\n            heap.push((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else {\n                if sum < heap.peek()!.0 {\n                    heap.remove()\n                    heap.insert((sum, i * nums2.count + j))\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Pair>(sort: { $0.sum < $1.sum })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!.toArray())\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], (i, j)))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, (i, j)) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[k - 1][0] + result[k - 1][1] {\n                    result.append([nums1[i], nums2[j]])\n                    result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                    result.removeLast()\n                }\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(elements: [], priorityFunction: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (n1, n2) = heap.pop() {\n            result.append([n1, n2])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let sum = heap.remove() {\n            result.append(sum)\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while result.count < k && !heap.isEmpty {\n        let (a, b) = heap.remove()!\n        result.append([a, b])\n        if b < nums2.last! {\n            heap.insert((a, b + 1))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[k-1][0] + result[k-1][1] {\n                    result.append([nums1[i], nums2[j]])\n                    result.sort { (a, b) -> Bool in\n                        return a[0] + a[1] < b[0] + b[1]\n                    }\n                    result.removeLast()\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        result.append([nums1[i], nums2[j]])\n        if i == nums1.count - 1 {\n            j += 1\n        } else if j == nums2.count - 1 {\n            i += 1\n        } else {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = 0\n    var i = 0\n    var j = 0\n    while index < k && i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n        index += 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let pair = heap.remove()!\n        result.append([nums1[pair.1 / nums2.count], nums2[pair.1 % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else {\n                if sum < heap.peek()! {\n                    heap.remove()\n                    heap.insert(sum)\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([nums1[0], heap.remove()! - nums1[0]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, index) = heap.pop() {\n            result.append([value, index])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i] + nums2[j], i, j))\n            if queue.count > k {\n                queue.dequeue()\n            }\n        }\n    }\n    while !queue.isEmpty {\n        let (sum, i, j) = queue.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (a, b) = heap.pop()!\n        result.append([a, b])\n        k -= 1\n        \n        if b < nums2.last! {\n            let index = nums2.firstIndex(of: b)!\n            heap.push((a, nums2[index + 1]))\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        result.append([nums1[i], nums2[j]])\n        if i == nums1.count - 1 {\n            j += 1\n        } else if j == nums2.count - 1 {\n            i += 1\n        } else {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    \n    for _ in 0..<k {\n        guard let (n1, n2) = heap.pop() else {\n            break\n        }\n        result.append([n1, n2])\n        if n2 < nums2.last! {\n            let index = nums2.firstIndex(of: n2)!\n            heap.insert((n1, nums2[index + 1]))\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        let (sum, index) = heap.remove()\n        result.append([sum - index, index])\n        k -= 1\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert(nums1[i] + nums2[j])\n            } else {\n                if nums1[i] + nums2[j] < heap.peek()! {\n                    heap.remove()\n                    heap.insert(nums1[i] + nums2[j])\n                }\n            }\n        }\n    }\n    while !heap.isEmpty() {\n        result.append([heap.remove()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard !nums1.isEmpty && !nums2.isEmpty else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: {\n        return $0.0 + $0.1 < $1.0 + $1.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append(sum)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<[Int]> = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert([nums1[i], nums2[j]])\n            } else {\n                if nums1[i] + nums2[j] < heap.peek()![0] + heap.peek()![1] {\n                    heap.insert([nums1[i], nums2[j]])\n                    heap.remove()\n                }\n            }\n        }\n    }\n    \n    while !heap.isEmpty() {\n        result.append(heap.remove()!)\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if sum < max![0] + max![1] {\n                    let index = result.index { (a) -> Bool in\n                        return a[0] + a[1] == max![0] + max![1]\n                    }\n                    result.remove(at: index!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)> { (e1, e2) -> Bool in\n        return e1.0 + e1.1 < e2.0 + e2.1\n    }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!.map { $0 })\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty() {\n            break\n        }\n        let (n1, n2) = heap.pop()!\n        result.append([n1, n2])\n        if n2 != nums2.last! {\n            heap.push((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i) = heap.pop() {\n            result.append([nums1[i], sum - nums1[i]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.enqueue((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while index1 < nums1.count && index2 < nums2.count && count < k {\n        let sum = nums1[index1] + nums2[index2]\n        if index1 + 1 < nums1.count && index2 + 1 < nums2.count {\n            let sum1 = nums1[index1] + nums2[index2 + 1]\n            let sum2 = nums1[index1 + 1] + nums2[index2]\n            if sum1 < sum2 {\n                if sum1 < sum {\n                    result.append([nums1[index1], nums2[index2 + 1]])\n                    index2 += 1\n                } else {\n                    result.append([nums1[index1], nums2[index2]])\n                }\n            } else {\n                if sum2 < sum {\n                    result.append([nums1[index1 + 1], nums2[index2]])\n                    index1 += 1\n                } else {\n                    result.append([nums1[index1], nums2[index2]])\n                }\n            }\n        } else if index1 + 1 < nums1.count {\n            let sum2 = nums1[index1 + 1] + nums2[index2]\n            if sum2 < sum {\n                result.append([nums1[index1 + 1], nums2[index2]])\n                index1 += 1\n            } else {\n                result.append([nums1[index1], nums2[index2]])\n            }\n        } else if index2 + 1 < nums2.count {\n            let sum1 = nums1[index1] + nums2[index2 + 1]\n            if sum1 < sum {\n                result.append([nums1[index1], nums2[index2 + 1]])\n                index2 += 1\n            } else {\n                result.append([nums1[index1], nums2[index2]])\n            }\n        } else {\n           ",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    \n    for _ in 0..<k {\n        if heap.isEmpty {\n            break\n        }\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        if n2 != nums2.last! {\n            heap.insert((n1, nums2[nums2.index(of: n2)! + 1]))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        result.append([heap.extract()!])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        var i = 0\n        var j = 0\n        while i < nums1.count && j < nums2.count {\n            if nums1[i] + nums2[j] == sum {\n                result.append([nums1[i], nums2[j]])\n                break\n            } else if nums1[i] + nums2[j] < sum {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty() {\n            break\n        }\n        let (n1, n2) = heap.pop()!\n        result.append([n1, n2])\n        if n2 < nums2.last! {\n            let index = nums2.index(of: n2)!\n            heap.push((n1, nums2[index + 1]))\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n                result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n            } else {\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                    result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                }\n            }\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let val = heap.pop() {\n            result.append([val])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    \n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < k && index1 < nums1.count && index2 < nums2.count {\n        let sum = nums1[index1] + nums2[index2]\n        if index1 + 1 < nums1.count && nums1[index1 + 1] + nums2[index2] < sum {\n            index1 += 1\n        } else if index2 + 1 < nums2.count && nums1[index1] + nums2[index2 + 1] < sum {\n            index2 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            count += 1\n            index1 += 1\n            index2 += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.extract() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                var min = Int.max\n                var minIndex = 0\n                for (index, item) in result.enumerated() {\n                    let sum = item[0] + item[1]\n                    if sum < min {\n                        min = sum\n                        minIndex = index\n                    }\n                }\n                let sum = nums1[i] + nums2[j]\n                if sum < min {\n                    result[minIndex] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        k -= 1\n        if n2 < nums2.last! {\n            heap.insert((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result: [[Int]] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let max = result.max { $0[0] + $0[1] < $1[0] + $1[1] }\n                if max![0] + max![1] > nums1[i] + nums2[j] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result"
  ]
}