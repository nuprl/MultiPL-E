{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "swift",
  "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])",
    "    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if max![0] + max![1] > nums1[i] + nums2[j] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, index) = heap.remove()\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var visited = [[Bool]]()\n    for _ in 0..<nums1.count {\n        visited.append(Array(repeating: false, count: nums2.count))\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if !visited[i][j] {\n                heap.insert([nums1[i], nums2[j]])\n                visited[i][j] = true\n            }\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result",
    "    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result",
    "    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result",
    "    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result",
    "    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    var count = 0\n    while count < k && index.contains(nums2.count) == false {\n        var min_value = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_value {\n                min_value = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        count += 1\n    }\n    return result"
  ]
}