{
  "name": "mbpp_308_large_product",
  "language": "swift",
  "prompt": "\n/// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1: [Int], nums2: [Int], N: Int) -> [Int] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 3) == [60, 54, 50])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 4) == [60, 54, 50, 48])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 5) == [60, 54, 50, 48, 45])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [Int]()\n    var i = 0, j = 0\n    var pq = PriorityQueue<Int>()\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            pq.insert(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            pq.insert(nums1[i] * nums2[j])\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        pq.insert(nums1[i] * nums2[nums2.count - 1])\n        i += 1\n    }\n    while j < nums2.count {\n        pq.insert(nums1[nums1.count - 1] * nums2[j])\n        j += 1\n    }\n    for _ in 0..<N {\n        result.append(pq.remove()!)\n    }\n    return result",
    "    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var products = [Int]()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            products.append(num1 * num2)\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var max_heap = Heap<Int>(sort: >)\n    var result = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            max_heap.insert(nums1[i] * nums2[j])\n            if max_heap.count > N {\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    while k < N {\n        let num1 = nums1[i]\n        let num2 = nums2[j]\n        if num1 > num2 {\n            result.append(num1)\n            i += 1\n        } else {\n            result.append(num2)\n            j += 1\n        }\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>()\n    for n1 in nums1 {\n        for n2 in nums2 {\n            let product = n1 * n2\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.remove()\n                heap.insert(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = MaxHeap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.remove()\n                maxHeap.insert(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result: [Int] = []\n    var i = 0\n    var j = 0\n    var k = 0\n    while k < N {\n        result.append(nums1[i] * nums2[j])\n        if i == nums1.count - 1 {\n            j += 1\n        } else if j == nums2.count - 1 {\n            i += 1\n        } else if nums1[i + 1] * nums2[j] > nums1[i] * nums2[j + 1] {\n            i += 1\n        } else {\n            j += 1\n        }\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var bb = 0\n    var cc = 0\n    var dd = 0\n    var ee = 0\n    var ff = 0\n    var gg = 0\n    var hh = 0\n    var ii = 0\n    var jj = 0\n    var kk = 0\n    var ll = 0\n    var mm = 0\n    var nn = 0\n    var oo = 0\n    var pp = 0\n    var qq = 0\n    var rr = 0\n    var ss = 0\n    var tt = 0\n    var uu = 0\n    var vv = 0\n    var ww = 0\n    var xx = 0\n    var yy = 0\n    var zz = 0\n    var aaa = 0\n    var bbb = 0\n    var ccc = 0\n    var ddd = 0\n    var eee = 0\n    var fff = 0\n    var ggg = 0\n    var hhh = 0\n    var iii = 0\n    var jjj = 0\n    var kkk = 0\n    var lll = 0\n    var mmm = 0\n    var nnn = 0\n    var ooo = 0\n    var ppp = 0\n    var qqq = 0\n    var rrr = 0\n    var sss = 0\n    var ttt = 0\n    var uuu = 0\n    var vvv = 0\n    var www = 0\n    var xxx = 0\n    var yyy = 0\n    var zzz = 0\n    var aaaa = 0\n    var bbbb = 0\n    var cccc = 0\n    var dddd = 0\n    var eeee = 0\n    var ffff = 0\n   ",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    var nums1 = nums1\n    var nums2 = nums2\n    while k < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var heap = Heap<Int>(sort: >)\n    while i < nums1.count && j < nums2.count {\n        let product = nums1[i] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        if nums1[i] < nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        let product = nums1[i] * nums2[nums2.count - 1]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        i += 1\n    }\n    while j < nums2.count {\n        let product = nums1[nums1.count - 1] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        j += 1\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<(Int, Int)>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.push((product, i * nums2.count + j))\n            } else if product > pq.peek()!.0 {\n                pq.pop()\n                pq.push((product, i * nums2.count + j))\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.pop()!.0)\n    }\n    return result",
    "    var result: [Int] = []\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = PriorityQueue<Int>(sort: >)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            maxHeap.enqueue(n1 * n2)\n            if maxHeap.count > N {\n                maxHeap.dequeue()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.dequeue()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n        }\n    }\n    for _ in 0..<N {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    \n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.insert(product)\n                maxHeap.remove()\n            }\n        }\n    }\n    \n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    \n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result: [Int] = []\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var maxHeap = Heap<Int>(sort: >)\n    var result = [Int]()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var heap = Heap<Int>(sort: >)\n    while i < nums1.count && j < nums2.count {\n        let product = nums1[i] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        if nums1[i] < nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        let product = nums1[i] * nums2[j-1]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        i += 1\n    }\n    while j < nums2.count {\n        let product = nums1[i-1] * nums2[j]\n        if heap.count < N {\n            heap.insert(product)\n        } else if product > heap.peek()! {\n            heap.remove()\n            heap.insert(product)\n        }\n        j += 1\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    let sorted1 = nums1.sorted(by: >)\n    let sorted2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while result.count < N {\n        let product = sorted1[i] * sorted2[j]\n        if result.count == 0 || product != result.last! {\n            result.append(product)\n        }\n        if sorted1[i] > sorted2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var products = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            products.append(nums1[i] * nums2[j])\n        }\n    }\n    return products.sorted(by: >).prefix(N).map { $0 }",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while let max = maxHeap.extract() {\n        result.append(max)\n    }\n    return result",
    "    var products = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            products.append(nums1[i] * nums2[j])\n        }\n    }\n    return products.sorted().reversed().prefix(N).map { $0 }",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while let max = maxHeap.extract() {\n        result.append(max)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.replace(product)\n            }\n        }\n    }\n    while heap.count > 0 {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                _ = maxHeap.pop()\n                maxHeap.insert(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(n1 * n2)\n            } else if n1 * n2 > maxHeap.peek()! {\n                maxHeap.replace(n1 * n2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.push(nums1[i] * nums2[j])\n        }\n    }\n    for _ in 0..<N {\n        result.append(pq.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product > max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var index1 = 0, index2 = 0\n    for _ in 0..<N {\n        var max = Int.min\n        var maxIndex1 = 0, maxIndex2 = 0\n        for i in index1..<nums1.count {\n            for j in index2..<nums2.count {\n                let product = nums1[i] * nums2[j]\n                if product > max {\n                    max = product\n                    maxIndex1 = i\n                    maxIndex2 = j\n                }\n            }\n        }\n        result.append(max)\n        index1 = maxIndex1\n        index2 = maxIndex2\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: { $0 > $1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var results = [Int]()\n    var max1 = 0\n    var max2 = 0\n    var max_product = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if product > max_product {\n                max_product = product\n                max1 = i\n                max2 = j\n            }\n        }\n    }\n    results.append(max_product)\n    nums1.remove(at: max1)\n    nums2.remove(at: max2)\n    for _ in 1..<N {\n        max_product = 0\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                let product = nums1[i] * nums2[j]\n                if product > max_product {\n                    max_product = product\n                    max1 = i\n                    max2 = j\n                }\n            }\n        }\n        results.append(max_product)\n        nums1.remove(at: max1)\n        nums2.remove(at: max2)\n    }\n    return results",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var maxHeap = Heap<Int>(sort: >)\n    var result = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var heap: Heap<Int> = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.push(product)\n            } else if product > pq.peek()! {\n                pq.pop()\n                pq.push(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue(nums1[i] * nums2[j])\n            if pq.count > N {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var res = [Int]()\n    var pq = PriorityQueue<Int>(order: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.push(product)\n            } else if product > pq.peek()! {\n                pq.pop()\n                pq.push(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        res.append(pq.pop()!)\n    }\n    return res",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var max = 0\n    while result.count < N {\n        let product = nums1[i] * nums2[j]\n        if product > max {\n            result.append(product)\n            max = product\n        }\n        if i == nums1.count - 1 {\n            j += 1\n        } else if j == nums2.count - 1 {\n            i += 1\n        } else if nums1[i + 1] * nums2[j] > nums1[i] * nums2[j + 1] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result",
    "    var result: [Int] = []\n    var max_heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product < max_heap.peek()! {\n                max_heap.replaceTop(product)\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(sort: >)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if let max = pq.peek(), product > max {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    \n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    \n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    \n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    \n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    \n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    let nums1 = nums1.sorted(by: >)\n    let nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var pq = PriorityQueue<Int>(ascending: false)\n    while i < nums1.count && j < nums2.count {\n        let product = nums1[i] * nums2[j]\n        if pq.count < N {\n            pq.enqueue(product)\n        } else if product > pq.peek()! {\n            pq.dequeue()\n            pq.enqueue(product)\n        }\n        if nums1[i] > nums2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        let product = nums1[i] * nums2[j]\n        if result.count < N {\n            result.append(product)\n            i += 1\n            j += 1\n        } else {\n            if product > result[0] {\n                result.remove(at: 0)\n                result.append(product)\n                i += 1\n                j += 1\n            } else if product < result[0] {\n                if nums1[i] > nums2[j] {\n                    j += 1\n                } else {\n                    i += 1\n                }\n            } else {\n                if nums1[i] > nums2[j] {\n                    j += 1\n                } else {\n                    i += 1\n                }\n            }\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        count += 1\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var count = 0\n    while count < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n            count += 1\n        } else {\n            j += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else {\n                if product > heap.peek()! {\n                    heap.replace(product)\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var products = [Int]()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            products.append(num1 * num2)\n        }\n    }\n    return products.sorted(by: >).prefix(N)",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.insert(product)\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<String>()\n    \n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            let key = \"\\(num1),\\(num2)\"\n            if !visited.contains(key) {\n                visited.insert(key)\n                maxHeap.insert(product)\n                if maxHeap.count > N {\n                    maxHeap.remove()\n                }\n            }\n        }\n    }\n    \n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    \n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            res.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            res.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return res",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if pq.peek()! < product {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    while k < N {\n        let product = nums1[i] * nums2[j]\n        if nums1[i] < nums2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n        result.append(product)\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var products = [Int]()\n    for n1 in nums1 {\n        for n2 in nums2 {\n            products.append(n1 * n2)\n        }\n    }\n    return products.sorted(by: >).prefix(N)",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.push(product)\n            } else if product > pq.peek()! {\n                pq.pop()\n                pq.push(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var products: [Int] = []\n    for num1 in nums1 {\n        for num2 in nums2 {\n            products.append(num1 * num2)\n        }\n    }\n    return products.sorted(by: >).prefix(N).map { $0 }",
    "    var result: [Int] = []\n    \n    var max1: Int = 0\n    var max2: Int = 0\n    \n    for i in 0..<nums1.count {\n        if nums1[i] > nums1[max1] {\n            max1 = i\n        }\n    }\n    \n    for i in 0..<nums2.count {\n        if nums2[i] > nums2[max2] {\n            max2 = i\n        }\n    }\n    \n    result.append(nums1[max1] * nums2[max2])\n    \n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            heap.insert(product)\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var min = 0\n    var max = 0\n    var max_product = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if result.count < N {\n                result.append(product)\n                if product > max_product {\n                    max_product = product\n                    max = result.count - 1\n                }\n            } else {\n                if product > max_product {\n                    result[max] = product\n                    max_product = product\n                    for k in 0..<result.count {\n                        if result[k] < max_product {\n                            min = k\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.replace(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    var visited = Set<Int>()\n    \n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    \n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n    \n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            heap.insert(num1 * num2)\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var res = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        res.append(heap.remove()!)\n    }\n    return res",
    "    var products = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            products.append(nums1[i] * nums2[j])\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    while k < N {\n        let product = nums1[i] * nums2[j]\n        if product > nums1[i] * nums2[j + 1] {\n            result.append(product)\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            j += 1\n        }\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    var heap = Heap<Int>(sort: >)\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            heap.push(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            heap.push(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    while i < nums1.count {\n        heap.push(nums1[i] * nums2[nums2.count-1])\n        i += 1\n    }\n    while j < nums2.count {\n        heap.push(nums1[nums1.count-1] * nums2[j])\n        j += 1\n    }\n    while result.count < N {\n        result.append(heap.pop()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.remove()\n                heap.insert(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            pq.push(n1 * n2)\n            if pq.count > N {\n                pq.pop()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.pop())\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    var i = 0\n    var j = 0\n    while i < N {\n        var max = Int.min\n        var index = 0\n        for k in 0..<nums1.count {\n            if max1.contains(k) {\n                continue\n            }\n            if nums1[k] > max {\n                max = nums1[k]\n                index = k\n            }\n        }\n        max1.append(index)\n        i += 1\n    }\n    while j < N {\n        var max = Int.min\n        var index = 0\n        for k in 0..<nums2.count {\n            if max2.contains(k) {\n                continue\n            }\n            if nums2[k] > max {\n                max = nums2[k]\n                index = k\n            }\n        }\n        max2.append(index)\n        j += 1\n    }\n    for i in 0..<N {\n        result.append(nums1[max1[i]] * nums2[max2[i]])\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            maxHeap.insert(num1 * num2)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            let product = n1 * n2\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < N {\n        let product = nums1[index1] * nums2[index2]\n        if product > nums1[index1] * nums2[index2 + 1] && product > nums1[index1 + 1] * nums2[index2] {\n            result.append(product)\n            index1 += 1\n            index2 += 1\n            count += 1\n        } else if nums1[index1] * nums2[index2 + 1] > nums1[index1 + 1] * nums2[index2] {\n            index2 += 1\n        } else {\n            index1 += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var products = [Int]()\n    for n1 in nums1 {\n        for n2 in nums2 {\n            products.append(n1 * n2)\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var res = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue(nums1[i] * nums2[j])\n        }\n    }\n    \n    for _ in 0..<N {\n        res.append(pq.dequeue()!)\n    }\n    \n    return res",
    "    var result = [Int]()\n    var max_heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if max_heap.count < N {\n                max_heap.insert(product)\n            } else if product > max_heap.peek()! {\n                max_heap.replace(product)\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var results: [Int] = []\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0, j = 0\n    while results.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            results.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            results.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return results",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else if product > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(product)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.insert(product)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < N {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if let max = maxHeap.peek(), product < max {\n                maxHeap.replace(max, with: product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var max1 = [Int]()\n    var max2 = [Int]()\n    for i in 0..<nums1.count {\n        if max1.count < N {\n            max1.append(nums1[i])\n            max1.sort()\n        } else if nums1[i] > max1[0] {\n            max1[0] = nums1[i]\n            max1.sort()\n        }\n    }\n    for i in 0..<nums2.count {\n        if max2.count < N {\n            max2.append(nums2[i])\n            max2.sort()\n        } else if nums2[i] > max2[0] {\n            max2[0] = nums2[i]\n            max2.sort()\n        }\n    }\n    for i in 0..<N {\n        result.append(max1[i] * max2[i])\n    }\n    return result",
    "    var result: [Int] = []\n    var heap: Heap<Int> = Heap<Int>(sort: >)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            if heap.count < N {\n                heap.insert(n1 * n2)\n            } else if n1 * n2 > heap.peek()! {\n                heap.insert(n1 * n2)\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.remove()\n                heap.insert(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(order: >)\n    for n1 in nums1 {\n        for n2 in nums2 {\n            let p = n1 * n2\n            if pq.count < N {\n                pq.enqueue(p)\n            } else if p > pq.peek()! {\n                pq.dequeue()\n                pq.enqueue(p)\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            maxHeap.insert(product)\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue(nums1[i] * nums2[j])\n            if pq.count > N {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result: [Int] = []\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        result.append(nums1[i] * nums2[nums2.count - 1])\n        i += 1\n    }\n    while j < nums2.count {\n        result.append(nums1[nums1.count - 1] * nums2[j])\n        j += 1\n    }\n    return result.sorted(by: >).prefix(N).map { $0 }",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if pq.count < N {\n                pq.enqueue(product)\n            } else {\n                if product > pq.peek()! {\n                    pq.dequeue()\n                    pq.enqueue(product)\n                }\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result"
  ]
}