{
  "name": "mbpp_308_large_product",
  "language": "swift",
  "prompt": "\n/// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1: [Int], nums2: [Int], N: Int) -> [Int] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 3) == [60, 54, 50])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 4) == [60, 54, 50, 48])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 5) == [60, 54, 50, 48, 45])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var result = [Int]()\n    var i = 0, j = 0\n    var pq = PriorityQueue<Int>()\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            pq.insert(nums1[i] * nums2[j])\n            i += 1\n        } else {\n            pq.insert(nums1[i] * nums2[j])\n            j += 1\n        }\n    }\n    while i < nums1.count {\n        pq.insert(nums1[i] * nums2[nums2.count - 1])\n        i += 1\n    }\n    while j < nums2.count {\n        pq.insert(nums1[nums1.count - 1] * nums2[j])\n        j += 1\n    }\n    for _ in 0..<N {\n        result.append(pq.remove()!)\n    }\n    return result",
    "    var nums1 = nums1.sorted(by: >)\n    var nums2 = nums2.sorted(by: >)\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while result.count < N {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] * nums2[j])\n            if heap.count > N {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j+1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var products = [Int]()\n    for num1 in nums1 {\n        for num2 in nums2 {\n            products.append(num1 * num2)\n        }\n    }\n    products.sort(by: >)\n    return Array(products[0..<N])",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var nums1 = nums1.sorted()\n    var nums2 = nums2.sorted()\n    var i = nums1.count - 1\n    var j = nums2.count - 1\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            result.append(nums1[i] * nums2[j])\n            i -= 1\n        } else {\n            result.append(nums1[i] * nums2[j])\n            j -= 1\n        }\n        N -= 1\n    }\n    return result",
    "    var max_heap = Heap<Int>(sort: >)\n    var result = [Int]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            max_heap.insert(nums1[i] * nums2[j])\n            if max_heap.count > N {\n                max_heap.remove()\n            }\n        }\n    }\n    while !max_heap.isEmpty {\n        result.append(max_heap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        } else {\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n        }\n    }\n    return result",
    "    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    while k < N {\n        let num1 = nums1[i]\n        let num2 = nums2[j]\n        if num1 > num2 {\n            result.append(num1)\n            i += 1\n        } else {\n            result.append(num2)\n            j += 1\n        }\n        k += 1\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            if maxHeap.count < N {\n                maxHeap.insert(num1 * num2)\n            } else if num1 * num2 > maxHeap.peek()! {\n                maxHeap.replace(num1 * num2)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let product = nums1[i] * nums2[j]\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            maxHeap.insert(nums1[i] * nums2[j])\n            if maxHeap.count > N {\n                maxHeap.remove()\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product > maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty() {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            let product = num1 * num2\n            if maxHeap.count < N {\n                maxHeap.insert(product)\n            } else if product < maxHeap.peek()! {\n                maxHeap.replace(product)\n            }\n        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return result",
    "    var result = [Int]()\n    var heap = Heap<Int>()\n    for n1 in nums1 {\n        for n2 in nums2 {\n            let product = n1 * n2\n            if heap.count < N {\n                heap.insert(product)\n            } else if product > heap.peek()! {\n                heap.remove()\n                heap.insert(product)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result"
  ]
}