{
  "name": "mbpp_410_min_val",
  "language": "swift",
  "prompt": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case let .Success(val):\n            return min(acc, Int(val)!)\n        case let .Failure(val):\n            return min(acc, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "/tmp/tmp53_ms6qi.swift:8:19: error: type 'Result<String, Int>' has no member 'Success'\n        case let .Success(val):\n                 ~^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                min = min < int ? min : int\n            }\n        case .failure(let int):\n            min = min < int ? min : int\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case .success(let value):\n            return min(acc, Int(value)!)\n        case .failure(let value):\n            return min(acc, value)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp_aln6_75/tmp_aln6_75.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aff38991c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aff38688561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002aff38688286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002aff3868813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002aff38687bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp_aln6_75                        0x0000560a798c0e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002aff38797410 Sequence.reduce<A>(_:_:) + 530\n7    tmp_aln6_75                        0x0000560a798c0c7d <unavailable> + 7293\n8    tmp_aln6_75                        0x0000560a798c08bc <unavailable> + 6332\n9    libc.so.6                          0x00002aff38b7d460 __libc_start_main + 245\n10   tmp_aln6_75                        0x0000560a798c04f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let s):\n            if let i = Int(s) {\n                if i < min {\n                    min = i\n                }\n            }\n        case .failure(let i):\n            if i < min {\n                min = i\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                min = min < int ? min : int\n            }\n        case .failure(let int):\n            min = min < int ? min : int\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch ($0, $1) {\n        case let (.success(a), .success(b)):\n            return min(a, b)\n        case let (.success(a), .failure(b)):\n            return min(a, b)\n        case let (.failure(a), .success(b)):\n            return min(a, b)\n        case let (.failure(a), .failure(b)):\n            return min(a, b)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "/tmp/tmpgllgc8rs.swift:8:20: error: type 'Int' has no member 'success'\n        case let (.success(a), .success(b)):\n                  ~^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, str.count)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp3pus8pq0/tmp3pus8pq0.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aebd6e01c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aebd6af8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aebd6af8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aebd6af77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3pus8pq0                        0x000055c59d061952 <unavailable> + 6482\n5    libc.so.6                          0x00002aebd6fed460 __libc_start_main + 245\n6    tmp3pus8pq0                        0x000055c59d0613f9 <unavailable> + 5113\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmpzvf9jn0b/tmpzvf9jn0b.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6918edfc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6918bd6561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b6918bd6286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b6918bd613c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b6918bd5bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpzvf9jn0b                        0x0000557c981c2e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002b6918ce5410 Sequence.reduce<A>(_:_:) + 530\n7    tmpzvf9jn0b                        0x0000557c981c2c7d <unavailable> + 7293\n8    tmpzvf9jn0b                        0x0000557c981c28bc <unavailable> + 6332\n9    libc.so.6                          0x00002b69190cb460 __libc_start_main + 245\n10   tmpzvf9jn0b                        0x0000557c981c24f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case let .success(value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case let .failure(value):\n            if value < min {\n                min = value\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                minval = min(minval, intval)\n            }\n        case .failure(let val):\n            minval = min(minval, val)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let val):\n            if val < minval {\n                minval = val\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let val):\n            return min($0, Int(val)!)\n        case .failure(let val):\n            return min($0, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpeob0sp4e/tmpeob0sp4e.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab4bb9a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab4bb69f561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab4bb69f286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab4bb69f13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab4bb69ebb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpeob0sp4e                        0x0000563e0d0b1e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab4bb7ae410 Sequence.reduce<A>(_:_:) + 530\n7    tmpeob0sp4e                        0x0000563e0d0b1c7d <unavailable> + 7293\n8    tmpeob0sp4e                        0x0000563e0d0b18bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab4bbb94460 __libc_start_main + 245\n10   tmpeob0sp4e                        0x0000563e0d0b14f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case let .failure(intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(value):\n            let intval = Int(value)\n            if intval < min {\n                min = intval\n            }\n        case let .failure(error):\n            if error < min {\n                min = error\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "/tmp/tmpyzv1roto.swift:11:16: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n            if intval < min {\n               ^\n/tmp/tmpyzv1roto.swift:11:16: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n            if intval < min {\n               ^\n                      ?? <#default value#>\n/tmp/tmpyzv1roto.swift:11:16: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n            if intval < min {\n               ^\n                     !\n/tmp/tmpyzv1roto.swift:12:23: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n                min = intval\n                      ^\n/tmp/tmpyzv1roto.swift:12:23: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n                min = intval\n                      ^\n                             ?? <#default value#>\n/tmp/tmpyzv1roto.swift:12:23: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n                min = intval\n                      ^\n                            !\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case let .success(value):\n            return min($0, Int(value)!)\n        case let .failure(value):\n            return min($0, value)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmp8_hhiehg/tmp8_hhiehg.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad45f3b9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad45f0b0561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ad45f0b0286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ad45f0b013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ad45f0afbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp8_hhiehg                        0x0000562050515e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ad45f1bf410 Sequence.reduce<A>(_:_:) + 530\n7    tmp8_hhiehg                        0x0000562050515c7d <unavailable> + 7293\n8    tmp8_hhiehg                        0x00005620505158bc <unavailable> + 6332\n9    libc.so.6                          0x00002ad45f5a5460 __libc_start_main + 245\n10   tmp8_hhiehg                        0x00005620505154f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case let .success(value):\n            return min(acc, value.count)\n        case let .failure(value):\n            return min(acc, value)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpje0h_lmn/tmpje0h_lmn.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aff4b9a6c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aff4b69db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aff4b69d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aff4b69c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpje0h_lmn                        0x000055576e283952 <unavailable> + 6482\n5    libc.so.6                          0x00002aff4bb92460 __libc_start_main + 245\n6    tmpje0h_lmn                        0x000055576e2833f9 <unavailable> + 5113\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case let .success(str):\n            return min(acc, Int(str) ?? Int.max)\n        case let .failure(int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min: Int = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (min, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min < str.count ? min : str.count\n        case .failure(let int):\n            return min < int ? min : int\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmprmmywzgs/tmprmmywzgs.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6dc6647c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6dc633eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6dc633e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b6dc633d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmprmmywzgs                        0x000055d180bae8c2 <unavailable> + 6338\n5    libc.so.6                          0x00002b6dc6833460 __libc_start_main + 245\n6    tmprmmywzgs                        0x000055d180bae369 <unavailable> + 4969\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case let .failure(int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) in\n        switch val {\n        case let .success(str):\n            return min(acc, Int(str)!)\n        case let .failure(int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmp5cseni6f/tmp5cseni6f.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aae418fec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aae415f5561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002aae415f5286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002aae415f513c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002aae415f4bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp5cseni6f                        0x0000561169234e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002aae41704410 Sequence.reduce<A>(_:_:) + 530\n7    tmp5cseni6f                        0x0000561169234c7d <unavailable> + 7293\n8    tmp5cseni6f                        0x00005611692348bc <unavailable> + 6332\n9    libc.so.6                          0x00002aae41aea460 __libc_start_main + 245\n10   tmp5cseni6f                        0x00005611692344f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case let .success(val):\n            return min(acc, val.count)\n        case let .failure(val):\n            return min(acc, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpvhllynvz/tmpvhllynvz.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2fb5da4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2fb5a9bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2fb5a9b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2fb5a9a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpvhllynvz                        0x0000564cac48b952 <unavailable> + 6482\n5    libc.so.6                          0x00002b2fb5f90460 __libc_start_main + 245\n6    tmpvhllynvz                        0x0000564cac48b3f9 <unavailable> + 5113\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let value):\n            if value < min {\n                min = value\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let val):\n            return min($0, Int(val)!)\n        case .failure(let val):\n            return min($0, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpeob0sp4e/tmpeob0sp4e.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab4bb9a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab4bb69f561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab4bb69f286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab4bb69f13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab4bb69ebb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpeob0sp4e                        0x0000563e0d0b1e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab4bb7ae410 Sequence.reduce<A>(_:_:) + 530\n7    tmpeob0sp4e                        0x0000563e0d0b1c7d <unavailable> + 7293\n8    tmpeob0sp4e                        0x0000563e0d0b18bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab4bbb94460 __libc_start_main + 245\n10   tmpeob0sp4e                        0x0000563e0d0b14f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                minval = min(minval, intval)\n            }\n        case .failure(let val):\n            minval = min(minval, val)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let err):\n            if err < minval {\n                minval = err\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let v):\n            return min($0, Int(v)!)\n        case .failure(let v):\n            return min($0, v)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpp9ub0vtt/tmpp9ub0vtt.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b65da7e5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b65da4dc561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b65da4dc286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b65da4dc13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b65da4dbbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpp9ub0vtt                        0x000056279b12de72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002b65da5eb410 Sequence.reduce<A>(_:_:) + 530\n7    tmpp9ub0vtt                        0x000056279b12dc7d <unavailable> + 7293\n8    tmpp9ub0vtt                        0x000056279b12d8bc <unavailable> + 6332\n9    libc.so.6                          0x00002b65da9d1460 __libc_start_main + 245\n10   tmpp9ub0vtt                        0x000056279b12d4f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int_val = Int(str) {\n                min_val = min(min_val, int_val)\n            }\n        case .failure(let int_val):\n            min_val = min(min_val, int_val)\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for value in listval {\n        switch value {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let s):\n            if let i = Int(s) {\n                if i < minval {\n                    minval = i\n                }\n            }\n        case .failure(let i):\n            if i < minval {\n                minval = i\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                minval = min(minval, intval)\n            }\n        case .failure(let intval):\n            minval = min(minval, intval)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let error):\n            if error < min {\n                min = error\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let val):\n            if val < minval {\n                minval = val\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max, { min($0, $1.getOrElse(0)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "/tmp/tmpm28wke1s.swift:6:49: error: value of type 'Result<String, Int>' has no member 'getOrElse'\n    return listval.reduce(Int.max, { min($0, $1.getOrElse(0)) })\n                                             ~~ ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case let .failure(int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case let .failure(int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.map {\n        switch $0 {\n        case .success(let val):\n            return Int(val)!\n        case .failure(let val):\n            return val\n        }\n    }.min()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpjbxf3c5n/tmpjbxf3c5n.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3903bf3c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b39038ea561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b39038ea286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b39038ea13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b39038e9bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpjbxf3c5n                        0x0000558523f13f13 <unavailable> + 7955\n6    libswiftCore.so                    0x00002b39038d2820 Collection.map<A>(_:) + 426\n7    tmpjbxf3c5n                        0x0000558523f13caa <unavailable> + 7338\n8    tmpjbxf3c5n                        0x0000558523f138fc <unavailable> + 6396\n9    libc.so.6                          0x00002b3903ddf460 __libc_start_main + 245\n10   tmpjbxf3c5n                        0x0000558523f13539 <unavailable> + 5433\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    let list = listval.map {\n        switch $0 {\n        case .success(let val):\n            return val.count\n        case .failure(let val):\n            return val\n        }\n    }\n    return list.min()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpqpkh2ub3/tmpqpkh2ub3.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b345be9fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b345bb96b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b345bb96988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b345bb957b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqpkh2ub3                        0x00005638683eaa32 <unavailable> + 6706\n5    libc.so.6                          0x00002b345c08b460 __libc_start_main + 245\n6    tmpqpkh2ub3                        0x00005638683ea4d9 <unavailable> + 5337\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int_val = Int(str) {\n                min_val = min(min_val, int_val)\n            }\n        case .failure(let int_val):\n            min_val = min(min_val, int_val)\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case let .success(x):\n            return min(acc, x.count)\n        case let .failure(x):\n            return min(acc, x)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpqbnnm246/tmpqbnnm246.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac790430c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac790127b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac790127988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac7901267b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqbnnm246                        0x000055fedf0c2952 <unavailable> + 6482\n5    libc.so.6                          0x00002ac79061c460 __libc_start_main + 245\n6    tmpqbnnm246                        0x000055fedf0c23f9 <unavailable> + 5113\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                minval = min(minval, intval)\n            }\n        case .failure(let intval):\n            minval = min(minval, intval)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let val):\n            return min($0, Int(val)!)\n        case .failure(let val):\n            return min($0, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpeob0sp4e/tmpeob0sp4e.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab4bb9a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab4bb69f561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab4bb69f286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab4bb69f13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab4bb69ebb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpeob0sp4e                        0x0000563e0d0b1e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab4bb7ae410 Sequence.reduce<A>(_:_:) + 530\n7    tmpeob0sp4e                        0x0000563e0d0b1c7d <unavailable> + 7293\n8    tmpeob0sp4e                        0x0000563e0d0b18bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab4bbb94460 __libc_start_main + 245\n10   tmpeob0sp4e                        0x0000563e0d0b14f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let error):\n            if error < min {\n                min = error\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (min, result) -> Int in\n        switch result {\n        case .success(let value):\n            return min < Int(value) ? min : Int(value)\n        case .failure(let value):\n            return min < value ? min : value\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "/tmp/tmp6v4s8w5_.swift:9:26: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n            return min < Int(value) ? min : Int(value)\n                         ^\n/tmp/tmp6v4s8w5_.swift:9:26: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n            return min < Int(value) ? min : Int(value)\n                         ^\n                                    ?? <#default value#>\n/tmp/tmp6v4s8w5_.swift:9:26: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n            return min < Int(value) ? min : Int(value)\n                         ^\n                                   !\n/tmp/tmp6v4s8w5_.swift:9:37: error: cannot convert return expression of type 'Int?' to return type 'Int'\n            return min < Int(value) ? min : Int(value)\n                   ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n                                                      !\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let value):\n            if let intval = Int(value) {\n                min = min < intval ? min : intval\n            }\n        case .failure(let error):\n            min = min < error ? min : error\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let val):\n            return min($0, Int(val)!)\n        case .failure(let val):\n            return min($0, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpeob0sp4e/tmpeob0sp4e.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab4bb9a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab4bb69f561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab4bb69f286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab4bb69f13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab4bb69ebb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpeob0sp4e                        0x0000563e0d0b1e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab4bb7ae410 Sequence.reduce<A>(_:_:) + 530\n7    tmpeob0sp4e                        0x0000563e0d0b1c7d <unavailable> + 7293\n8    tmpeob0sp4e                        0x0000563e0d0b18bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab4bbb94460 __libc_start_main + 245\n10   tmpeob0sp4e                        0x0000563e0d0b14f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    let list = listval.map {\n        switch $0 {\n        case .success(let val):\n            return Int(val)\n        case .failure(let val):\n            return val\n        }\n    }\n    return list.min()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "/tmp/tmpozj0vx07.swift:14:12: error: referencing instance method 'min()' on 'Sequence' requires that 'Int?' conform to 'Comparable'\n    return list.min()!\n           ^\n/tmp/tmpozj0vx07.swift:14:12: note: wrapped type 'Int' satisfies this requirement; did you mean to unwrap?\n    return list.min()!\n           ^\nSwift.Sequence:1:11: note: where 'Self.Element' = 'Int?'\nextension Sequence where Self.Element : Comparable {\n          ^\n/tmp/tmpozj0vx07.swift:14:22: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    return list.min()!\n                     ^\n/tmp/tmpozj0vx07.swift:14:22: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n    return list.min()!\n                     ^\n                       ?? <#default value#>\n/tmp/tmpozj0vx07.swift:14:22: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n    return list.min()!\n                     ^\n                      !\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case let .failure(intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case let .success(value):\n            if let int_val = Int(value) {\n                if int_val < min_val {\n                    min_val = int_val\n                }\n            }\n        case let .failure(value):\n            if value < min_val {\n                min_val = value\n            }\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for value in listval {\n        switch value {\n        case let .success(value):\n            if Int(value)! < min {\n                min = Int(value)!\n            }\n        case let .failure(value):\n            if value < min {\n                min = value\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmp5zbqvpgk/tmp5zbqvpgk.swift:10: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5c48263c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5c47f5a561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b5c47f5a286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b5c47f5a13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b5c47f59bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp5zbqvpgk                        0x000055e3b285af31 <unavailable> + 7985\n6    tmp5zbqvpgk                        0x000055e3b285a91c <unavailable> + 6428\n7    libc.so.6                          0x00002b5c4844f460 __libc_start_main + 245\n8    tmp5zbqvpgk                        0x000055e3b285a559 <unavailable> + 5465\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                minval = min(minval, intval)\n            }\n        case .failure(let val):\n            minval = min(minval, val)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case let .success(strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case let .failure(intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case let .success(value):\n            if let int_val = Int(value) {\n                if int_val < min_val {\n                    min_val = int_val\n                }\n            }\n        case let .failure(error):\n            if error < min_val {\n                min_val = error\n            }\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                min = min < int ? min : int\n            }\n        case .failure(let int):\n            min = min < int ? min : int\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.map {\n        switch $0 {\n        case .success(let s):\n            return Int(s)!\n        case .failure(let i):\n            return i\n        }\n    }.min()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpasvo1cay/tmpasvo1cay.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5c9df6bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5c9dc62561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b5c9dc62286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b5c9dc6213c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b5c9dc61bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpasvo1cay                        0x0000555ec69abf13 <unavailable> + 7955\n6    libswiftCore.so                    0x00002b5c9dc4a820 Collection.map<A>(_:) + 426\n7    tmpasvo1cay                        0x0000555ec69abcaa <unavailable> + 7338\n8    tmpasvo1cay                        0x0000555ec69ab8fc <unavailable> + 6396\n9    libc.so.6                          0x00002b5c9e157460 __libc_start_main + 245\n10   tmpasvo1cay                        0x0000555ec69ab539 <unavailable> + 5433\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let error):\n            if error < min {\n                min = error\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            let intval = Int(str) ?? 0\n            if intval < min {\n                min = intval\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmp5pkj8svq/tmp5pkj8svq.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b880af54c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b880ac4bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b880ac4b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b880ac4a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp5pkj8svq                        0x000055d8df33e90a <unavailable> + 6410\n5    libc.so.6                          0x00002b880b140460 __libc_start_main + 245\n6    tmp5pkj8svq                        0x000055d8df33e4c9 <unavailable> + 5321\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case let .failure(intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intVal = Int(val) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let error):\n            if error < min {\n                min = error\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let intval = Int(str) {\n                minval = min(minval, intval)\n            }\n        case let .failure(intval):\n            minval = min(minval, intval)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intVal = Int(str) {\n                if intVal < min {\n                    min = intVal\n                }\n            }\n        case .failure(let intVal):\n            if intVal < min {\n                min = intVal\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (min, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min < Int(str) ?? Int.max ? min : Int(str) ?? Int.max\n        case .failure(let int):\n            return min < int ? min : int\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let int_val = Int(val) {\n                min_val = min(min_val, int_val)\n            }\n        case .failure(let val):\n            min_val = min(min_val, val)\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                min = min < intval ? min : intval\n            }\n        case .failure(let intval):\n            min = min < intval ? min : intval\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max, { (acc, x) -> Int in\n        switch x {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpbx9a9e9q/tmpbx9a9e9q.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab7ed2e4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab7ecfdb561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab7ecfdb286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab7ecfdb13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab7ecfdabb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpbx9a9e9q                        0x000055add3609e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab7ed0ea410 Sequence.reduce<A>(_:_:) + 530\n7    tmpbx9a9e9q                        0x000055add3609c7d <unavailable> + 7293\n8    tmpbx9a9e9q                        0x000055add36098bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab7ed4d0460 __libc_start_main + 245\n10   tmpbx9a9e9q                        0x000055add36094f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (result, value) -> Int in\n        switch value {\n        case .success(let value):\n            return min(result, Int(value)!)\n        case .failure(let value):\n            return min(result, value)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpbj0u926g/tmpbj0u926g.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1a3d651c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1a3d348561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b1a3d348286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b1a3d34813c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b1a3d347bb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpbj0u926g                        0x000055578c33fe72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002b1a3d457410 Sequence.reduce<A>(_:_:) + 530\n7    tmpbj0u926g                        0x000055578c33fc7d <unavailable> + 7293\n8    tmpbj0u926g                        0x000055578c33f8bc <unavailable> + 6332\n9    libc.so.6                          0x00002b1a3d83d460 __libc_start_main + 245\n10   tmpbj0u926g                        0x000055578c33f4f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let num):\n            return min(acc, num)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122399,
      "stdout": "",
      "stderr": "tmpaa_i724n/tmpaa_i724n.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5987184c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5986e7b561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002b5986e7b286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002b5986e7b13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002b5986e7abb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpaa_i724n                        0x000055d4c6db8e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002b5986f8a410 Sequence.reduce<A>(_:_:) + 530\n7    tmpaa_i724n                        0x000055d4c6db8c7d <unavailable> + 7293\n8    tmpaa_i724n                        0x000055d4c6db88bc <unavailable> + 6332\n9    libc.so.6                          0x00002b5987370460 __libc_start_main + 245\n10   tmpaa_i724n                        0x000055d4c6db84f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let val):\n            return min($0, Int(val)!)\n        case .failure(let val):\n            return min($0, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpeob0sp4e/tmpeob0sp4e.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab4bb9a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab4bb69f561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab4bb69f286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab4bb69f13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab4bb69ebb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpeob0sp4e                        0x0000563e0d0b1e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab4bb7ae410 Sequence.reduce<A>(_:_:) + 530\n7    tmpeob0sp4e                        0x0000563e0d0b1c7d <unavailable> + 7293\n8    tmpeob0sp4e                        0x0000563e0d0b18bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab4bbb94460 __libc_start_main + 245\n10   tmpeob0sp4e                        0x0000563e0d0b14f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    let minval = listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let strval):\n            return min(acc, Int(strval) ?? Int.max)\n        case .failure(let intval):\n            return min(acc, intval)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122399,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                min = min < int ? min : int\n            }\n        case .failure(let err):\n            min = min < err ? min : err\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122399,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, x) -> Int in\n        switch x {\n        case .success(let str):\n            return min(acc, Int(str) ?? Int.max)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case .failure(let err):\n            if err < min {\n                min = err\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for case let .success(value) in listval {\n        if let intval = Int(value) {\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122399,
      "stdout": "",
      "stderr": "tmp4c8ecio3/tmp4c8ecio3.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abb1fd9bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abb1fa92b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abb1fa92988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abb1fa917b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4c8ecio3                        0x000055825538d90a <unavailable> + 6410\n5    libc.so.6                          0x00002abb1ff87460 __libc_start_main + 245\n6    tmp4c8ecio3                        0x000055825538d4c9 <unavailable> + 5321\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) {\n        switch $1 {\n        case .success(let val):\n            return min($0, Int(val)!)\n        case .failure(let val):\n            return min($0, val)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmpeob0sp4e/tmpeob0sp4e.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab4bb9a8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab4bb69f561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002ab4bb69f286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002ab4bb69f13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002ab4bb69ebb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmpeob0sp4e                        0x0000563e0d0b1e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002ab4bb7ae410 Sequence.reduce<A>(_:_:) + 530\n7    tmpeob0sp4e                        0x0000563e0d0b1c7d <unavailable> + 7293\n8    tmpeob0sp4e                        0x0000563e0d0b18bc <unavailable> + 6332\n9    libc.so.6                          0x00002ab4bbb94460 __libc_start_main + 245\n10   tmpeob0sp4e                        0x0000563e0d0b14f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let s):\n            return acc < Int(s) ? acc : Int(s)\n        case .failure(let f):\n            return acc < f ? acc : f\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "/tmp/tmpwo56meaw.swift:9:26: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n            return acc < Int(s) ? acc : Int(s)\n                         ^\n/tmp/tmpwo56meaw.swift:9:26: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n            return acc < Int(s) ? acc : Int(s)\n                         ^\n                                ?? <#default value#>\n/tmp/tmpwo56meaw.swift:9:26: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n            return acc < Int(s) ? acc : Int(s)\n                         ^\n                               !\n/tmp/tmpwo56meaw.swift:9:33: error: cannot convert return expression of type 'Int?' to return type 'Int'\n            return acc < Int(s) ? acc : Int(s)\n                   ~~~~~~~~~~~~~^~~~~~~~~~~~~~\n                                              !\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < min_val {\n                    min_val = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min_val {\n                min_val = intval\n            }\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122399,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min_val = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let int_val = Int(val) {\n                if int_val < min_val {\n                    min_val = int_val\n                }\n            }\n        case .failure(let val):\n            if val < min_val {\n                min_val = val\n            }\n        }\n    }\n    return min_val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122399,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            let intval = Int(str)\n            if intval < min {\n                min = intval\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "/tmp/tmpjweb_ptl.swift:11:16: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n            if intval < min {\n               ^\n/tmp/tmpjweb_ptl.swift:11:16: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n            if intval < min {\n               ^\n                      ?? <#default value#>\n/tmp/tmpjweb_ptl.swift:11:16: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n            if intval < min {\n               ^\n                     !\n/tmp/tmpjweb_ptl.swift:12:23: error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n                min = intval\n                      ^\n/tmp/tmpjweb_ptl.swift:12:23: note: coalesce using '??' to provide a default when the optional value contains 'nil'\n                min = intval\n                      ^\n                             ?? <#default value#>\n/tmp/tmpjweb_ptl.swift:12:23: note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n                min = intval\n                      ^\n                            !\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let val):\n            if let intval = Int(val) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for item in listval {\n        switch item {\n        case .success(let value):\n            if let intval = Int(value) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let error):\n            if error < min {\n                min = error\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case let .success(str):\n            if let int = Int(str) {\n                if int < min {\n                    min = int\n                }\n            }\n        case let .failure(int):\n            if int < min {\n                min = int\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = Int.max\n    for val in listval {\n        switch val {\n        case .success(let str):\n            if let intval = Int(str) {\n                if intval < min {\n                    min = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < min {\n                min = intval\n            }\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                if intval < minval {\n                    minval = intval\n                }\n            }\n        case .failure(let intval):\n            if intval < minval {\n                minval = intval\n            }\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var minval = Int.max\n    for val in listval {\n        switch val {\n        case .success(let strval):\n            if let intval = Int(strval) {\n                minval = min(minval, intval)\n            }\n        case .failure(let intval):\n            minval = min(minval, intval)\n        }\n    }\n    return minval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    return listval.reduce(Int.max) { (acc, val) -> Int in\n        switch val {\n        case .success(let str):\n            return min(acc, Int(str)!)\n        case .failure(let int):\n            return min(acc, int)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1665510070,
      "stdout": "",
      "stderr": "tmp1v0n41hx/tmp1v0n41hx.swift:9: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afbd3229c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afbd2f20561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002afbd2f20286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002afbd2f2013c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002afbd2f1fbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmp1v0n41hx                        0x0000562bc6c88e72 <unavailable> + 7794\n6    libswiftCore.so                    0x00002afbd302f410 Sequence.reduce<A>(_:_:) + 530\n7    tmp1v0n41hx                        0x0000562bc6c88c7d <unavailable> + 7293\n8    tmp1v0n41hx                        0x0000562bc6c888bc <unavailable> + 6332\n9    libc.so.6                          0x00002afbd3415460 __libc_start_main + 245\n10   tmp1v0n41hx                        0x0000562bc6c884f9 <unavailable> + 5369\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n    var min = 0\n    for val in listval {\n        switch val {\n        case .success(let val):\n            min = Int(val)!\n            break\n        case .failure(let val):\n            if val < min {\n                min = val\n            }\n            break\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)",
      "timestamp": 1666122398,
      "stdout": "",
      "stderr": "tmppv8sujnc/tmppv8sujnc.swift:10: Fatal error: Unexpectedly found nil while unwrapping an Optional value\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aeaea425c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aeaea11c561 <unavailable> + 1434977\n2    libswiftCore.so                    0x00002aeaea11c286 <unavailable> + 1434246\n3    libswiftCore.so                    0x00002aeaea11c13c <unavailable> + 1433916\n4    libswiftCore.so                    0x00002aeaea11bbb0 _assertionFailure(_:_:file:line:flags:) + 251\n5    tmppv8sujnc                        0x000055b82060af24 <unavailable> + 7972\n6    tmppv8sujnc                        0x000055b82060a91c <unavailable> + 6428\n7    libc.so.6                          0x00002aeaea611460 __libc_start_main + 245\n8    tmppv8sujnc                        0x000055b82060a559 <unavailable> + 5465\n",
      "exit_code": -4,
      "status": "Exception"
    }
  ]
}