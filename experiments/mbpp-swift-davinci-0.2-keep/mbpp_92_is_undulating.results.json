{
  "name": "mbpp_92_is_undulating",
  "language": "swift",
  "prompt": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    var next = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr || curr == next {\n            return false\n        }\n        prev = curr\n        curr = next\n        next = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmptcg_d3xb/tmptcg_d3xb.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba9a8920c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba9a8617b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba9a8617988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba9a86167b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmptcg_d3xb                        0x0000562148f6123e <unavailable> + 4670\n5    libc.so.6                          0x00002ba9a8b0c460 __libc_start_main + 245\n6    tmptcg_d3xb                        0x0000562148f60ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let a = Int(String(s[s.index(s.startIndex, offsetBy: i)]))!\n        let b = Int(String(s[s.index(s.startIndex, offsetBy: i + 1)]))!\n        let c = Int(String(s[s.index(s.startIndex, offsetBy: i + 2)]))!\n        if a == b || b == c || a == c {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpy6au329n/tmpy6au329n.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aefa5c3dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aefa5934b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aefa5934988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aefa59337b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpy6au329n                        0x00005636062b156e <unavailable> + 5486\n5    libc.so.6                          0x00002aefa5e29460 __libc_start_main + 245\n6    tmpy6au329n                        0x00005636062b1229 <unavailable> + 4649\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let cur = n % 10\n        if prev != cur {\n            return false\n        }\n        prev = cur\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpqyy5u9ej/tmpqyy5u9ej.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1f5346fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1f53166b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1f53166988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1f531657b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqyy5u9ej                        0x000055bc5d23e23e <unavailable> + 4670\n5    libc.so.6                          0x00002b1f5365b460 __libc_start_main + 245\n6    tmpqyy5u9ej                        0x000055bc5d23def9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_undulating = false\n    while n > 0 {\n        let digit = n % 10\n        if last_digit == digit {\n            return false\n        }\n        is_undulating = !is_undulating\n        last_digit = digit\n        n /= 10\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmp48jqmahy/tmp48jqmahy.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab662760c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab662457b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab662457988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab6624567b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp48jqmahy                        0x000055d26ca2723e <unavailable> + 4670\n5    libc.so.6                          0x00002ab66294c460 __libc_start_main + 245\n6    tmp48jqmahy                        0x000055d26ca26ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_undulating = false\n    for i in 0..<digits.count - 2 {\n        if digits[i] % 2 == 0 && digits[i + 1] % 2 == 1 && digits[i + 2] % 2 == 0 {\n            is_undulating = true\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmp8ij_iy2s/tmp8ij_iy2s.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002adbe5fddc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002adbe5cd4b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002adbe5cd4988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002adbe5cd37b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8ij_iy2s                        0x000055a6b9bee7c0 <unavailable> + 6080\n5    libc.so.6                          0x00002adbe61c9460 __libc_start_main + 245\n6    tmp8ij_iy2s                        0x000055a6b9bee389 <unavailable> + 5001\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = 0\n    var curr = 0\n    var next = 0\n    var is_undulating = false\n    while n > 0 {\n        prev = curr\n        curr = next\n        next = n % 10\n        if prev != 0 {\n            if prev > curr && curr < next || prev < curr && curr > next {\n                is_undulating = true\n            } else {\n                is_undulating = false\n            }\n        }\n        n /= 10\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    while n > 0 {\n        if last_digit == second_last_digit {\n            return false\n        }\n        n /= 10\n        second_last_digit = last_digit\n        last_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    while n > 0 {\n        n /= 10\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpz08zfd7c/tmpz08zfd7c.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abee4e5bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abee4b52b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abee4b52988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abee4b517b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz08zfd7c                        0x000055d5854c123e <unavailable> + 4670\n5    libc.so.6                          0x00002abee5047460 __libc_start_main + 245\n6    tmpz08zfd7c                        0x000055d5854c0ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    var current = n % 10\n    n /= 10\n    while n > 0 {\n        if last == current {\n            return false\n        }\n        last = current\n        current = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var next_digit = 0\n    var is_undulating = true\n    while n > 0 {\n        n /= 10\n        next_digit = n % 10\n        if last_digit == next_digit {\n            is_undulating = false\n            break\n        }\n        last_digit = next_digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing && digit > last_digit {\n            return false\n        }\n        if !is_increasing && digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmprc0aj6q7/tmprc0aj6q7.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba4cc142c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba4cbe39b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba4cbe39988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba4cbe387b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmprc0aj6q7                        0x0000559e0ec6f23e <unavailable> + 4670\n5    libc.so.6                          0x00002ba4cc32e460 __libc_start_main + 245\n6    tmprc0aj6q7                        0x0000559e0ec6eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    for i in 0..<digits.count - 2 {\n        if digits[i] != digits[i + 2] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpnmbyyg39.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmptcg_d3xb/tmptcg_d3xb.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba9a8920c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba9a8617b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba9a8617988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba9a86167b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmptcg_d3xb                        0x0000562148f6123e <unavailable> + 4670\n5    libc.so.6                          0x00002ba9a8b0c460 __libc_start_main + 245\n6    tmptcg_d3xb                        0x0000562148f60ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var current_digit = 0\n    var is_undulating = true\n    while n > 0 {\n        n /= 10\n        current_digit = n % 10\n        if current_digit == last_digit {\n            is_undulating = false\n            break\n        }\n        last_digit = current_digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = false\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var last_digit = n % 10\n    var n = n / 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp2orxlttv/tmp2orxlttv.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab8cf091c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab8ced88b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab8ced88988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab8ced877b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp2orxlttv                        0x0000557d04f7923e <unavailable> + 4670\n5    libc.so.6                          0x00002ab8cf27d460 __libc_start_main + 245\n6    tmp2orxlttv                        0x0000557d04f78ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    var is_increasing = last_digit > second_last_digit\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        is_increasing = !is_increasing\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_odd = true\n    for i in 0..<digits.count - 1 {\n        if is_odd {\n            if digits[i] >= digits[i + 1] {\n                return false\n            }\n        } else {\n            if digits[i] <= digits[i + 1] {\n                return false\n            }\n        }\n        is_odd = !is_odd\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmp0de8ydha.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var last_diff = digits[0] - digits[1]\n    for i in 1..<digits.count - 1 {\n        let diff = digits[i] - digits[i + 1]\n        if diff * last_diff >= 0 {\n            return false\n        }\n        last_diff = diff\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpc44g4faj.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    digits.reverse()\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1\n            continue\n        }\n        if digits[i] > digits[i + 1] {\n            if digits[i + 1] < digits[i + 2] {\n                return false\n            }\n        } else {\n            if digits[i + 1] > digits[i + 2] {\n                return false\n            }\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp1e2p0c0l/tmp1e2p0c0l.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b35d14ecc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b35d11e3b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b35d11e3988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b35d11e27b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp1e2p0c0l                        0x000055c11654c3ee <unavailable> + 5102\n5    libc.so.6                          0x00002b35d16d8460 __libc_start_main + 245\n6    tmp1e2p0c0l                        0x000055c11654c0a9 <unavailable> + 4265\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var next_digit = (n / 10) % 10\n    var is_increasing = last_digit < next_digit\n    n /= 10\n    while n > 0 {\n        last_digit = next_digit\n        next_digit = n % 10\n        if is_increasing {\n            if last_digit > next_digit {\n                is_increasing = false\n            } else {\n                return false\n            }\n        } else {\n            if last_digit < next_digit {\n                is_increasing = true\n            } else {\n                return false\n            }\n        }\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp5al_dequ/tmp5al_dequ.swift:43: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b4e3917ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b4e38e75b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b4e38e75988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b4e38e747b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp5al_dequ                        0x00005588b761523e <unavailable> + 4670\n5    libc.so.6                          0x00002b4e3936a460 __libc_start_main + 245\n6    tmp5al_dequ                        0x00005588b7614ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var prev_diff = 0\n    var curr_diff = 0\n    var prev_digit = 0\n    var curr_digit = 0\n    var n = n\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        prev_diff = curr_diff\n        curr_diff = curr_digit - prev_digit\n        if prev_diff * curr_diff >= 0 {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmpf6tmak6i/tmpf6tmak6i.swift:35: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b237ca52c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b237c749b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b237c749988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b237c7487b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpf6tmak6i                        0x000055708f4a023e <unavailable> + 4670\n5    libc.so.6                          0x00002b237cc3e460 __libc_start_main + 245\n6    tmpf6tmak6i                        0x000055708f49fef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n        current_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if last_digit == digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_undulating = true\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var lastDigit = n % 10\n    n /= 10\n    var isUndulating = true\n    while n > 0 {\n        let digit = n % 10\n        if digit == lastDigit {\n            isUndulating = false\n            break\n        }\n        lastDigit = digit\n        n /= 10\n    }\n    return isUndulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var last_digit = n % 10\n    var n = n / 10\n    var is_ascending = true\n    while n > 0 {\n        let digit = n % 10\n        if is_ascending {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_ascending = !is_ascending\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp9gj50sci/tmp9gj50sci.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba1be1fbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba1bdef2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba1bdef2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba1bdef17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9gj50sci                        0x000055ebccca523e <unavailable> + 4670\n5    libc.so.6                          0x00002ba1be3e7460 __libc_start_main + 245\n6    tmp9gj50sci                        0x000055ebccca4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n            if digit < last_digit {\n                is_increasing = false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n            if digit > last_digit {\n                is_increasing = true\n            }\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmpafz_trvk/tmpafz_trvk.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab0b13e5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab0b10dcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab0b10dc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab0b10db7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpafz_trvk                        0x00005590dbcff23e <unavailable> + 4670\n5    libc.so.6                          0x00002ab0b15d1460 __libc_start_main + 245\n6    tmpafz_trvk                        0x00005590dbcfeef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing && digits[i] < digits[i-1] {\n            is_increasing = false\n        } else if !is_increasing && digits[i] > digits[i-1] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmp66zi6pzl.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if last_digit == digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    var i = 0\n    while i < s.count - 1 {\n        if s[i] == s[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpaxe6ag4p.swift:7:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if s[i] == s[i + 1] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpaxe6ag4p.swift:7:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if s[i] == s[i + 1] {\n                   ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit && digit != second_last_digit {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpxaynnujq/tmpxaynnujq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2e2c413c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2e2c10ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2e2c10a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2e2c1097b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxaynnujq                        0x000055881c2fe23e <unavailable> + 4670\n5    libc.so.6                          0x00002b2e2c5ff460 __libc_start_main + 245\n6    tmpxaynnujq                        0x000055881c2fdef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var prev = n % 10\n    var n = n / 10\n    var curr = n % 10\n    var n = n / 10\n    var is_increasing = prev < curr\n    while n > 0 {\n        prev = curr\n        curr = n % 10\n        n = n / 10\n        if is_increasing && prev > curr {\n            return false\n        }\n        if !is_increasing && prev < curr {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpq9yuzuou.swift:7:9: error: invalid redeclaration of 'n'\n    var n = n / 10\n        ^\n/tmp/tmpq9yuzuou.swift:5:9: note: 'n' previously declared here\n    var n = n / 10\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpi2kjtpnc/tmpi2kjtpnc.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b143431bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1434012b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1434012988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b14340117b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2kjtpnc                        0x0000563c37bd623e <unavailable> + 4670\n5    libc.so.6                          0x00002b1434507460 __libc_start_main + 245\n6    tmpi2kjtpnc                        0x0000563c37bd5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit != curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmpc1hznqii/tmpc1hznqii.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2af41b9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2af3eb0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2af3eb0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2af3eaf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpc1hznqii                        0x000055c3edb0523e <unavailable> + 4670\n5    libc.so.6                          0x00002b2af43a5460 __libc_start_main + 245\n6    tmpc1hznqii                        0x000055c3edb04ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 0..<digits.count - 1 {\n        if is_increasing {\n            if digits[i] > digits[i + 1] {\n                is_increasing = false\n            } else {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i + 1] {\n                is_increasing = true\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmp6a9w21cn.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if last_digit < current_digit {\n                return false\n            }\n        } else {\n            if last_digit > current_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_ascending = true\n    while n > 0 {\n        let digit = n % 10\n        if is_ascending {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_ascending = !is_ascending\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmp0q_oinqr/tmp0q_oinqr.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac369980c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac369677b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac369677988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac3696767b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0q_oinqr                        0x000055b3d822f23e <unavailable> + 4670\n5    libc.so.6                          0x00002ac369b6c460 __libc_start_main + 245\n6    tmp0q_oinqr                        0x000055b3d822eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var undulating = false\n    var last_digit = n % 10\n    var n = n / 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            undulating = !undulating\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmphs5oznyx/tmphs5oznyx.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b43bf883c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b43bf57ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b43bf57a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b43bf5797b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphs5oznyx                        0x000055bdf1dc823e <unavailable> + 4670\n5    libc.so.6                          0x00002b43bfa6f460 __libc_start_main + 245\n6    tmphs5oznyx                        0x000055bdf1dc7ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var str = String(n)\n    var i = 0\n    while i < str.count - 1 {\n        if str[i] == str[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "/tmp/tmp7kkf3dz4.swift:7:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if str[i] == str[i + 1] {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7kkf3dz4.swift:7:22: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if str[i] == str[i + 1] {\n                     ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7kkf3dz4.swift:4:9: warning: variable 'str' was never mutated; consider changing to 'let' constant\n    var str = String(n)\n    ~~~ ^\n    let\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let l = s.count\n    if l < 3 {\n        return false\n    }\n    var i = 0\n    while i < l - 2 {\n        if s[i] == s[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpn8k9lp4m.swift:11:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if s[i] == s[i + 2] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpn8k9lp4m.swift:11:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if s[i] == s[i + 2] {\n                   ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    digits.reverse()\n    var i = 0\n    while i < digits.count - 1 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = prev_digit > curr_digit\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n        if is_increasing && prev_digit < curr_digit {\n            return false\n        }\n        if !is_increasing && prev_digit > curr_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp1nquc5y9/tmp1nquc5y9.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba0ab017c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba0aad0eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba0aad0e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba0aad0d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp1nquc5y9                        0x000056115204723e <unavailable> + 4670\n5    libc.so.6                          0x00002ba0ab203460 __libc_start_main + 245\n6    tmp1nquc5y9                        0x0000561152046ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    for i in 1..<s.count {\n        let a = s[s.index(s.startIndex, offsetBy: i-1)]\n        let b = s[s.index(s.startIndex, offsetBy: i)]\n        if a == b {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let a = Int(String(s[s.index(s.startIndex, offsetBy: i)]))!\n        let b = Int(String(s[s.index(s.startIndex, offsetBy: i + 1)]))!\n        let c = Int(String(s[s.index(s.startIndex, offsetBy: i + 2)]))!\n        if (a > b && b < c) || (a < b && b > c) {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1\n        } else if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2\n        } else if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let c = s.characters\n    var i = c.startIndex\n    var j = c.index(after: i)\n    var k = c.index(after: j)\n    while k < c.endIndex {\n        if c[i] == c[j] && c[j] == c[k] {\n            return false\n        }\n        i = j\n        j = k\n        k = c.index(after: k)\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmp3m6tha99.swift:5:15: error: 'characters' is unavailable: Please use String directly\n    let c = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    var is_undulating = true\n    for i in 1..<digits.count - 1 {\n        if digits[i - 1] == digits[i] || digits[i] == digits[i + 1] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmp4dmth6z4.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr != prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp0wgsqw5z/tmp0wgsqw5z.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad5b65cbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad5b62c2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad5b62c2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad5b62c17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0wgsqw5z                        0x0000560acbfd623e <unavailable> + 4670\n5    libc.so.6                          0x00002ad5b67b7460 __libc_start_main + 245\n6    tmp0wgsqw5z                        0x0000560acbfd5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_undulating = true\n    while n > 0 {\n        let digit = n % 10\n        if last_digit == digit {\n            is_undulating = false\n            break\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if increasing {\n            if current_digit > last_digit {\n                return false\n            }\n        } else {\n            if current_digit < last_digit {\n                return false\n            }\n        }\n        increasing = !increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    while n > 0 {\n        if next_digit == last_digit {\n            return false\n        }\n        last_digit = next_digit\n        n /= 10\n        next_digit = n % 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && last_digit < current_digit {\n            return false\n        }\n        if !is_increasing && last_digit > current_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit && digit != second_last_digit {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpxaynnujq/tmpxaynnujq.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2e2c413c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2e2c10ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2e2c10a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2e2c1097b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxaynnujq                        0x000055881c2fe23e <unavailable> + 4670\n5    libc.so.6                          0x00002b2e2c5ff460 __libc_start_main + 245\n6    tmpxaynnujq                        0x000055881c2fdef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "/tmp/tmp3nh3sz_n.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = n.digits\n    guard digits.count > 2 else { return false }\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpfq6o7eyn.swift:4:20: error: value of type 'Int' has no member 'digits'\n    let digits = n.digits\n                 ~ ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = prev_digit > curr_digit\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n        if is_increasing && prev_digit < curr_digit {\n            return false\n        }\n        if !is_increasing && prev_digit > curr_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp1nquc5y9/tmp1nquc5y9.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba0ab017c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba0aad0eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba0aad0e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba0aad0d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp1nquc5y9                        0x000056115204723e <unavailable> + 4670\n5    libc.so.6                          0x00002ba0ab203460 __libc_start_main + 245\n6    tmp1nquc5y9                        0x0000561152046ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpi2kjtpnc/tmpi2kjtpnc.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b143431bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1434012b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1434012988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b14340117b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2kjtpnc                        0x0000563c37bd623e <unavailable> + 4670\n5    libc.so.6                          0x00002b1434507460 __libc_start_main + 245\n6    tmpi2kjtpnc                        0x0000563c37bd5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        } else if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let next_digit = n % 10\n        if (last_digit > current_digit && current_digit > next_digit) ||\n            (last_digit < current_digit && current_digit < next_digit) {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = next_digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpi2isnz01/tmpi2isnz01.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b98c1f7cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b98c1c73b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b98c1c73988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b98c1c727b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2isnz01                        0x000055bfdbbef2b4 <unavailable> + 4788\n5    libc.so.6                          0x00002b98c2168460 __libc_start_main + 245\n6    tmpi2isnz01                        0x000055bfdbbeeef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let c1 = s[s.index(s.startIndex, offsetBy: i)]\n        let c2 = s[s.index(s.startIndex, offsetBy: i + 1)]\n        let c3 = s[s.index(s.startIndex, offsetBy: i + 2)]\n        if c1 != c2 && c2 != c3 && c1 != c3 {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpfl0qiknq/tmpfl0qiknq.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1b0d04ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1b0cd41b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1b0cd41988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1b0cd407b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpfl0qiknq                        0x000055642478842e <unavailable> + 5166\n5    libc.so.6                          0x00002b1b0d236460 __libc_start_main + 245\n6    tmpfl0qiknq                        0x00005564247880e9 <unavailable> + 4329\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev != curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpzfou62bv/tmpzfou62bv.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae49748ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae497185b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae497185988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae4971847b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpzfou62bv                        0x00005565b9d1a23e <unavailable> + 4670\n5    libc.so.6                          0x00002ae49767a460 __libc_start_main + 245\n6    tmpzfou62bv                        0x00005565b9d19ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if current_digit > last_digit {\n                return false\n            }\n        } else {\n            if current_digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if last_digit != digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpr2qu07sb/tmpr2qu07sb.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abbea23dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abbe9f34b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abbe9f34988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abbe9f337b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpr2qu07sb                        0x00005583000b323e <unavailable> + 4670\n5    libc.so.6                          0x00002abbea429460 __libc_start_main + 245\n6    tmpr2qu07sb                        0x00005583000b2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let digits = s.map { Int(String($0))! }\n    var last_diff = digits[0] - digits[1]\n    for i in 1..<digits.count - 1 {\n        let diff = digits[i] - digits[i + 1]\n        if diff == last_diff {\n            return false\n        }\n        last_diff = diff\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpv576hjjt/tmpv576hjjt.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b6785669c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6785360b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6785360988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b678535f7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpv576hjjt                        0x00005649319b46f4 <unavailable> + 5876\n5    libc.so.6                          0x00002b6785855460 __libc_start_main + 245\n6    tmpv576hjjt                        0x00005649319b4339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if last_digit != digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpr2qu07sb/tmpr2qu07sb.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abbea23dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abbe9f34b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abbe9f34988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abbe9f337b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpr2qu07sb                        0x00005583000b323e <unavailable> + 4670\n5    libc.so.6                          0x00002abbea429460 __libc_start_main + 245\n6    tmpr2qu07sb                        0x00005583000b2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = get_digits(n)\n    var is_undulating = false\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            is_undulating = true\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpx9kwcut5.swift:4:18: error: cannot find 'get_digits' in scope\n    let digits = get_digits(n)\n                 ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if (prev_digit - curr_digit) * (curr_digit - n % 10) < 0 {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmps_mo3dgx/tmps_mo3dgx.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad6f07a7c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad6f049eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad6f049e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad6f049d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmps_mo3dgx                        0x0000559d8e9a123e <unavailable> + 4670\n5    libc.so.6                          0x00002ad6f0993460 __libc_start_main + 245\n6    tmps_mo3dgx                        0x0000559d8e9a0ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && last_digit < current_digit {\n            return false\n        } else if !is_increasing && last_digit > current_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] < digits[i - 1] {\n                is_increasing = false\n            }\n        } else {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpfpsr8dhz.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    for i in 0..<digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n        n /= 10\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "tmpqh1fhqkc/tmpqh1fhqkc.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b752144fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7521146b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7521146988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b75211457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqh1fhqkc                        0x000055db146ab23e <unavailable> + 4670\n5    libc.so.6                          0x00002b752163b460 __libc_start_main + 245\n6    tmpqh1fhqkc                        0x000055db146aaef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    var is_decreasing = true\n    for i in 1..<digits.count {\n        if digits[i] < digits[i - 1] {\n            is_increasing = false\n        }\n        if digits[i] > digits[i - 1] {\n            is_decreasing = false\n        }\n    }\n    return is_increasing || is_decreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "/tmp/tmpgeyduvlh.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpkrry9x0m/tmpkrry9x0m.swift:20: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aea7f280c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aea7ef77b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aea7ef77988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aea7ef767b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpkrry9x0m                        0x0000556a3aaa51ae <unavailable> + 4526\n5    libc.so.6                          0x00002aea7f46c460 __libc_start_main + 245\n6    tmpkrry9x0m                        0x0000556a3aaa4e69 <unavailable> + 3689\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var current_digit = 0\n    var is_undulating = false\n    while n > 0 {\n        n /= 10\n        current_digit = n % 10\n        if last_digit != current_digit {\n            is_undulating = !is_undulating\n        }\n        last_digit = current_digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpx70zosga/tmpx70zosga.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5dd20e1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5dd1dd8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5dd1dd8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5dd1dd77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpx70zosga                        0x0000556c4850f2b4 <unavailable> + 4788\n5    libc.so.6                          0x00002b5dd22cd460 __libc_start_main + 245\n6    tmpx70zosga                        0x0000556c4850eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr != prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122584,
      "stdout": "",
      "stderr": "tmp0wgsqw5z/tmp0wgsqw5z.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ad5b65cbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ad5b62c2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ad5b62c2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ad5b62c17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0wgsqw5z                        0x0000560acbfd623e <unavailable> + 4670\n5    libc.so.6                          0x00002ad5b67b7460 __libc_start_main + 245\n6    tmp0wgsqw5z                        0x0000560acbfd5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let str = String(n)\n    var last_digit = str.first!\n    var is_increasing = true\n    for digit in str.dropFirst() {\n        if digit == last_digit {\n            return false\n        }\n        if is_increasing {\n            if digit < last_digit {\n                is_increasing = false\n            }\n        } else {\n            if digit > last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpkxo3rd7_/tmpkxo3rd7_.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae3b78b4c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae3b75abb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae3b75ab988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae3b75aa7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpkxo3rd7_                        0x0000563e4db5b74e <unavailable> + 5966\n5    libc.so.6                          0x00002ae3b7aa0460 __libc_start_main + 245\n6    tmpkxo3rd7_                        0x0000563e4db5b409 <unavailable> + 5129\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    var is_increasing = prev < curr\n    while n > 0 {\n        prev = curr\n        curr = n % 10\n        n /= 10\n        if is_increasing {\n            if prev > curr {\n                is_increasing = false\n            }\n        } else {\n            if prev < curr {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmp_4dsl3l8/tmp_4dsl3l8.swift:40: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b869e3aac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b869e0a1b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b869e0a1988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b869e0a07b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp_4dsl3l8                        0x0000564da805c23e <unavailable> + 4670\n5    libc.so.6                          0x00002b869e596460 __libc_start_main + 245\n6    tmp_4dsl3l8                        0x0000564da805bef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).map { Int(String($0))! }\n    var is_undulating = true\n    for i in 1..<digits.count - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpid9oy9vk/tmpid9oy9vk.swift:28: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aeefe90ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aeefe601b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aeefe601988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aeefe6007b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpid9oy9vk                        0x00005612733c767e <unavailable> + 5758\n5    libc.so.6                          0x00002aeefeaf6460 __libc_start_main + 245\n6    tmpid9oy9vk                        0x00005612733c7339 <unavailable> + 4921\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        last_digit = digit\n        is_increasing = !is_increasing\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmp1613n6s7/tmp1613n6s7.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1ab90fec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1ab8df5b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1ab8df5988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1ab8df47b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp1613n6s7                        0x0000560c8429323e <unavailable> + 4670\n5    libc.so.6                          0x00002b1ab92ea460 __libc_start_main + 245\n6    tmp1613n6s7                        0x0000560c84292ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing && current_digit > last_digit {\n            return false\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = curr_digit > prev_digit\n    var is_undulating = false\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        if is_increasing {\n            if curr_digit < prev_digit {\n                is_increasing = false\n                is_undulating = true\n            }\n        } else {\n            if curr_digit > prev_digit {\n                is_increasing = true\n                is_undulating = true\n            }\n        }\n        n /= 10\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpzp8ts7nk/tmpzp8ts7nk.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2097816c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b209750db6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b209750d988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b209750c7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpzp8ts7nk                        0x000055d0faf522b4 <unavailable> + 4788\n5    libc.so.6                          0x00002b2097a02460 __libc_start_main + 245\n6    tmpzp8ts7nk                        0x000055d0faf51ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == next_digit {\n            return false\n        }\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).compactMap { Int(String($0)) }\n    return digits.enumerated().allSatisfy { $0.offset % 2 == 0 ? $0.element % 2 == 0 : $0.element % 2 == 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpgpbdgngd/tmpgpbdgngd.swift:21: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b43e3583c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b43e327ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b43e327a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b43e32797b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpgpbdgngd                        0x000055b7c71b565e <unavailable> + 5726\n5    libc.so.6                          0x00002b43e376f460 __libc_start_main + 245\n6    tmpgpbdgngd                        0x000055b7c71b5319 <unavailable> + 4889\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = prev_digit < curr_digit\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if prev_digit < curr_digit {\n                return false\n            }\n        } else {\n            if prev_digit > curr_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if (digit != last_digit) && (digit != second_last_digit) {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmp3xemj__8/tmp3xemj__8.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b820c950c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b820c647b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b820c647988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b820c6467b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3xemj__8                        0x000055ba405c623e <unavailable> + 4670\n5    libc.so.6                          0x00002b820cb3c460 __libc_start_main + 245\n6    tmp3xemj__8                        0x000055ba405c5ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var is_undulating = true\n    var is_increasing = true\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                is_undulating = false\n                break\n            }\n        } else {\n            if digit < last_digit {\n                is_undulating = false\n                break\n            }\n        }\n        last_digit = digit\n        is_increasing = !is_increasing\n        n /= 10\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpvnzor7e1/tmpvnzor7e1.swift:42: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac26a9d9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac26a6d0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac26a6d0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac26a6cf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpvnzor7e1                        0x000055d00333923e <unavailable> + 4670\n5    libc.so.6                          0x00002ac26abc5460 __libc_start_main + 245\n6    tmpvnzor7e1                        0x000055d003338ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var prev = n % 10\n    var n = n / 10\n    var is_increasing = true\n    while n > 0 {\n        let curr = n % 10\n        if is_increasing {\n            if curr > prev {\n                return false\n            }\n        } else {\n            if curr < prev {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpdass87c4/tmpdass87c4.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b62734ddc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b62731d4b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b62731d4988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b62731d37b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpdass87c4                        0x00005579633e923e <unavailable> + 4670\n5    libc.so.6                          0x00002b62736c9460 __libc_start_main + 245\n6    tmpdass87c4                        0x00005579633e8ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit > current_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if last_digit < current_digit {\n                return false\n            }\n        } else {\n            if last_digit > current_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpza3m5465/tmpza3m5465.swift:41: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b006df22c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b006dc19b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b006dc19988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b006dc187b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpza3m5465                        0x000055c06444f23e <unavailable> + 4670\n5    libc.so.6                          0x00002b006e10e460 __libc_start_main + 245\n6    tmpza3m5465                        0x000055c06444eef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var second_last_digit = (n / 10) % 10\n    var is_increasing = last_digit > second_last_digit\n    while n > 0 {\n        n /= 10\n        second_last_digit = last_digit\n        last_digit = n % 10\n        if is_increasing && last_digit > second_last_digit {\n            return false\n        } else if !is_increasing && last_digit < second_last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmp0z4slcle/tmp0z4slcle.swift:35: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b96bd360c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b96bd057b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b96bd057988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b96bd0567b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp0z4slcle                        0x0000556a4bf5023e <unavailable> + 4670\n5    libc.so.6                          0x00002b96bd54c460 __libc_start_main + 245\n6    tmp0z4slcle                        0x0000556a4bf4fef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var next_digit = n % 10\n    n /= 10\n    var is_increasing = last_digit < next_digit\n    while n > 0 {\n        last_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n        if is_increasing && next_digit >= last_digit {\n            return false\n        }\n        if !is_increasing && next_digit <= last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).compactMap { Int(String($0)) }\n    var is_undulating = true\n    for i in 0..<digits.count-2 {\n        if digits[i] == digits[i+1] || digits[i+1] == digits[i+2] {\n            is_undulating = false\n            break\n        }\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if last_digit != digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpr2qu07sb/tmpr2qu07sb.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abbea23dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abbe9f34b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abbe9f34988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abbe9f337b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpr2qu07sb                        0x00005583000b323e <unavailable> + 4670\n5    libc.so.6                          0x00002abbea429460 __libc_start_main + 245\n6    tmpr2qu07sb                        0x00005583000b2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var second_last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last_digit {\n            return false\n        }\n        if digit == second_last_digit {\n            return false\n        }\n        second_last_digit = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmppi2sxiqk/tmppi2sxiqk.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae2a987ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae2a9571b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae2a9571988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae2a95707b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmppi2sxiqk                        0x00005566c33f823e <unavailable> + 4670\n5    libc.so.6                          0x00002ae2a9a66460 __libc_start_main + 245\n6    tmppi2sxiqk                        0x00005566c33f7ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let l = s.characters.count\n    if l < 3 {\n        return false\n    }\n    var i = 1\n    while i < l {\n        let c1 = s[s.index(s.startIndex, offsetBy: i-1)]\n        let c2 = s[s.index(s.startIndex, offsetBy: i)]\n        let c3 = s[s.index(s.startIndex, offsetBy: i+1)]\n        if c1 == c3 {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "/tmp/tmp6ikvvyhg.swift:5:15: error: 'characters' is unavailable: Please use String directly\n    let l = s.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6ikvvyhg.swift:12:13: warning: initialization of immutable value 'c2' was never used; consider replacing with assignment to '_' or removing it\n        let c2 = s[s.index(s.startIndex, offsetBy: i)]\n        ~~~~^~\n        _\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var num = n\n    var last_digit = num % 10\n    var next_digit = 0\n    var is_increasing = true\n    num /= 10\n    while num > 0 {\n        next_digit = num % 10\n        if is_increasing {\n            if next_digit > last_digit {\n                return false\n            }\n        } else {\n            if next_digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = next_digit\n        num /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmpkl_tmeu3/tmpkl_tmeu3.swift:40: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba6fa3e5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba6fa0dcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba6fa0dc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba6fa0db7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpkl_tmeu3                        0x00005579167fc23e <unavailable> + 4670\n5    libc.so.6                          0x00002ba6fa5d1460 __libc_start_main + 245\n6    tmpkl_tmeu3                        0x00005579167fbef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmplr86swcg.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev_digit = n % 10\n    n /= 10\n    var curr_digit = n % 10\n    n /= 10\n    var is_increasing = prev_digit > curr_digit\n    while n > 0 {\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n        if is_increasing && prev_digit < curr_digit {\n            return false\n        } else if !is_increasing && prev_digit > curr_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmp6wj1glir/tmp6wj1glir.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b4c6b942c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b4c6b639b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b4c6b639988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b4c6b6387b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp6wj1glir                        0x000055ccf05c323e <unavailable> + 4670\n5    libc.so.6                          0x00002b4c6bb2e460 __libc_start_main + 245\n6    tmp6wj1glir                        0x000055ccf05c2ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).characters.map { Int(String($0))! }\n    var is_increasing = true\n    for i in 1..<digits.count {\n        if is_increasing {\n            if digits[i] > digits[i - 1] {\n                return false\n            }\n        } else {\n            if digits[i] < digits[i - 1] {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "/tmp/tmpsg9p0th8.swift:4:28: error: 'characters' is unavailable: Please use String directly\n    let digits = String(n).characters.map { Int(String($0))! }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String { get set }\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmptcg_d3xb/tmptcg_d3xb.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba9a8920c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba9a8617b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba9a8617988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba9a86167b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmptcg_d3xb                        0x0000562148f6123e <unavailable> + 4670\n5    libc.so.6                          0x00002ba9a8b0c460 __libc_start_main + 245\n6    tmptcg_d3xb                        0x0000562148f60ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    var is_increasing = current_digit > last_digit\n    while n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if is_increasing {\n            if current_digit > last_digit {\n                return false\n            }\n        } else {\n            if current_digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    while n > 0 {\n        let curr = n % 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    digits.reverse()\n    var i = 0\n    while i < digits.count - 2 {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let digits = String(n).compactMap { Int(String($0)) }\n    var last_diff = 0\n    for i in 1..<digits.count {\n        let diff = digits[i] - digits[i - 1]\n        if last_diff == diff {\n            return false\n        }\n        last_diff = diff\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "tmp9s1cls37/tmp9s1cls37.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8c1ab24c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8c1a81bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8c1a81b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8c1a81a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9s1cls37                        0x000055e98fca3704 <unavailable> + 5892\n5    libc.so.6                          0x00002b8c1ad10460 __libc_start_main + 245\n6    tmp9s1cls37                        0x000055e98fca3349 <unavailable> + 4937\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var s = String(n)\n    var i = 0\n    while i < s.count - 2 {\n        let a = s[s.index(s.startIndex, offsetBy: i)]\n        let b = s[s.index(s.startIndex, offsetBy: i + 1)]\n        let c = s[s.index(s.startIndex, offsetBy: i + 2)]\n        if a == c {\n            return true\n        }\n        i += 1\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    while n > 0 {\n        let d = n % 10\n        if d == last {\n            return false\n        }\n        last = d\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    let s = String(n)\n    let l = s.count\n    if l < 3 {\n        return false\n    }\n    var i = 1\n    while i < l {\n        if s[i] == s[i-1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "/tmp/tmp53cv_98l.swift:11:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if s[i] == s[i-1] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp53cv_98l.swift:11:20: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if s[i] == s[i-1] {\n                   ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var current_digit = n % 10\n    n /= 10\n    while n > 0 {\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var digits = [Int]()\n    var n = n\n    while n > 0 {\n        digits.append(n % 10)\n        n /= 10\n    }\n    var i = 0\n    while i < digits.count - 1 {\n        if digits[i] == digits[i + 1] {\n            return false\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    var current_digit = 0\n    var is_undulating = true\n    while n > 0 {\n        n /= 10\n        current_digit = n % 10\n        if last_digit == current_digit {\n            is_undulating = false\n            break\n        }\n        last_digit = current_digit\n    }\n    return is_undulating\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit == last {\n            return false\n        }\n        last = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122585,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing && digit > last_digit {\n            return false\n        }\n        if !is_increasing && digit < last_digit {\n            return false\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122583,
      "stdout": "",
      "stderr": "tmpoka683k5/tmpoka683k5.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b18b4dd8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b18b4acfb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b18b4acf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b18b4ace7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpoka683k5                        0x0000558202c1e23e <unavailable> + 4670\n5    libc.so.6                          0x00002b18b4fc4460 __libc_start_main + 245\n6    tmpoka683k5                        0x0000558202c1def9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    while n > 0 {\n        let digit = n % 10\n        if digit != last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1666122582,
      "stdout": "",
      "stderr": "tmpahb549tu/tmpahb549tu.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002acfea54fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002acfea246b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002acfea246988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002acfea2457b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpahb549tu                        0x000055f64cee523e <unavailable> + 4670\n5    libc.so.6                          0x00002acfea73b460 __libc_start_main + 245\n6    tmpahb549tu                        0x000055f64cee4ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var last_digit = n % 10\n    n /= 10\n    var is_increasing = true\n    while n > 0 {\n        let digit = n % 10\n        if is_increasing {\n            if digit > last_digit {\n                return false\n            }\n        } else {\n            if digit < last_digit {\n                return false\n            }\n        }\n        is_increasing = !is_increasing\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510007,
      "stdout": "",
      "stderr": "tmpd7kuumov/tmpd7kuumov.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b274c2b8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b274bfafb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b274bfaf988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b274bfae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpd7kuumov                        0x0000564781a1423e <unavailable> + 4670\n5    libc.so.6                          0x00002b274c4a4460 __libc_start_main + 245\n6    tmpd7kuumov                        0x0000564781a13ef9 <unavailable> + 3833\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n    var n = n\n    var prev = n % 10\n    n /= 10\n    var curr = n % 10\n    n /= 10\n    while n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)",
      "timestamp": 1665510006,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}