{
  "name": "mbpp_463_max_subarray_product",
  "language": "swift",
  "prompt": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = Int.min\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n        if min_so_far > min_ending_here {\n            min_so_far = min_ending_here\n        }\n        result = max(result, max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_ending_here > result {\n            result = max_ending_here\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for a in arr {\n        if a > 0 {\n            max_ending_here = max_ending_here * a\n            min_ending_here = min(min_ending_here * a, 1)\n        } else if a == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * a, 1)\n            min_ending_here = temp * a\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for a in arr {\n        if a > 0 {\n            max_ending_here = max_ending_here * a\n            min_ending_here = min(min_ending_here * a, 1)\n        } else if a == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * a, 1)\n            min_ending_here = temp * a\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_product = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_ending_here > max_so_far {\n            max_so_far = max_ending_here\n        }\n        \n        if min_ending_here < min_so_far {\n            min_so_far = min_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = arr[0]\n    var min_so_far = arr[0]\n    var max_ending_here = arr[0]\n    var min_ending_here = arr[0]\n    for i in 1..<arr.count {\n        max_ending_here = max(max(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i])\n        min_ending_here = min(min(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "tmphcu955pd/tmphcu955pd.swift:29: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba7d7165c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba7d6e5cb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba7d6e5c988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba7d6e5b7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmphcu955pd                        0x000055db09484642 <unavailable> + 5698\n5    libc.so.6                          0x00002ba7d7351460 __libc_start_main + 245\n6    tmphcu955pd                        0x000055db09484289 <unavailable> + 4745\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for a in arr {\n        if a > 0 {\n            max_ending_here = max_ending_here * a\n            min_ending_here = min(min_ending_here * a, 1)\n        } else if a == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * a, 1)\n            min_ending_here = temp * a\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_product = arr[0]\n    var min_product = arr[0]\n    var max_so_far = arr[0]\n    \n    for i in 1..<arr.count {\n        let current = arr[i]\n        let temp_max = max(current, max(current * max_product, current * min_product))\n        let temp_min = min(current, min(current * max_product, current * min_product))\n        max_product = temp_max\n        min_product = temp_min\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    \n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = arr[0]\n    var min_so_far = arr[0]\n    var result = arr[0]\n    \n    for i in 1..<arr.count {\n        if arr[i] < 0 {\n            swap(&max_so_far, &min_so_far)\n        }\n        \n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n        \n        result = max(result, max_so_far)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_product = Int.min\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_ending_here > max_product {\n            max_product = max_ending_here\n        }\n    }\n    return max_product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for a in arr {\n        if a > 0 {\n            max_ending_here = max_ending_here * a\n            min_ending_here = min(min_ending_here * a, 1)\n        } else if a == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * a, 1)\n            min_ending_here = temp * a\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here*arr[i]\n            min_so_far = min(min_so_far*arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far*arr[i], 1)\n            min_so_far = temp*arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_product = arr[0]\n    var min_product = arr[0]\n    var max_so_far = arr[0]\n    \n    for i in 1..<arr.count {\n        let current = arr[i]\n        let max_temp = max(current, max(current * max_product, current * min_product))\n        let min_temp = min(current, min(current * max_product, current * min_product))\n        max_product = max_temp\n        min_product = min_temp\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n        \n        if min_so_far > min_ending_here {\n            min_so_far = min_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_ending_here > result {\n            result = max_ending_here\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for a in arr {\n        if a > 0 {\n            max_ending_here = max_ending_here * a\n            min_ending_here = min(min_ending_here * a, 1)\n        } else if a == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * a, 1)\n            min_ending_here = temp * a\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = Int.min\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n        \n        if min_so_far > min_ending_here {\n            min_so_far = min_ending_here\n        }\n        \n        if result < max_so_far {\n            result = max_so_far\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here*arr[i]\n            min_ending_here = min(min_ending_here*arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here*arr[i], 1)\n            min_ending_here = temp*arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = arr[0]\n    var min_so_far = arr[0]\n    var max_ending_here = arr[0]\n    var min_ending_here = arr[0]\n    for i in 1..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "tmpsruaej3j/tmpsruaej3j.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afae1b71c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afae1868b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afae1868988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afae18677b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsruaej3j                        0x0000564d4fb79642 <unavailable> + 5698\n5    libc.so.6                          0x00002afae1d5d460 __libc_start_main + 245\n6    tmpsruaej3j                        0x0000564d4fb79289 <unavailable> + 4745\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for a in arr {\n        if a > 0 {\n            max_ending_here = max_ending_here * a\n            min_ending_here = min(min_ending_here * a, 1)\n        } else if a == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * a, 1)\n            min_ending_here = temp * a\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = arr[0]\n    var min_so_far = arr[0]\n    var max_ending_here = arr[0]\n    var min_ending_here = arr[0]\n    var result = arr[0]\n    for i in 1..<arr.count {\n        max_ending_here = max(max(max_ending_here * arr[i], min_ending_here * arr[i]), arr[i])\n        min_ending_here = min(min(max_so_far * arr[i], min_so_far * arr[i]), arr[i])\n        result = max(result, max_ending_here)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "tmp64v4z5sc/tmp64v4z5sc.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b32d175dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b32d1454b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b32d1454988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b32d14537b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp64v4z5sc                        0x0000559c40a63642 <unavailable> + 5698\n5    libc.so.6                          0x00002b32d1949460 __libc_start_main + 245\n6    tmp64v4z5sc                        0x0000559c40a63289 <unavailable> + 4745\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_product = arr[0]\n    var min_product = arr[0]\n    var max_so_far = arr[0]\n    \n    for i in 1..<arr.count {\n        let current = arr[i]\n        let temp_max = max(current, max(current * max_product, current * min_product))\n        let temp_min = min(current, min(current * max_product, current * min_product))\n        max_product = temp_max\n        min_product = temp_min\n        max_so_far = max(max_so_far, max_product)\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var result = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n        if min_so_far > min_ending_here {\n            min_so_far = min_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here*arr[i]\n            min_ending_here = min(min_ending_here*arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here*arr[i], 1)\n            min_ending_here = temp*arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_so_far = 1\n    var min_so_far = 1\n    var max_ending_here = 1\n    var flag = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n            flag = 1\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    if flag == 0 && max_so_far == 1 {\n        return 0\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510249,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n    var max_ending_here = 1\n    var min_ending_here = 1\n    var max_so_far = 1\n    \n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_ending_here = min(min_ending_here * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            let temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], 1)\n            min_ending_here = temp * arr[i]\n        }\n        \n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    \n    return max_so_far\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)",
      "timestamp": 1665510248,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}