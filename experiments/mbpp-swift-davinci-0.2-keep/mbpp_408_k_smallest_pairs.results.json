{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "swift",
  "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmphmxq6dal.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if max![0] + max![1] > nums1[i] + nums2[j] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517428,
      "stdout": "",
      "stderr": "tmpmfo3hm92/tmpmfo3hm92.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b136375ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1363451b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1363451988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b13634507b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmfo3hm92                        0x0000561e27016da0 <unavailable> + 7584\n5    libc.so.6                          0x00002b1363946460 __libc_start_main + 245\n6    tmpmfo3hm92                        0x0000561e27016409 <unavailable> + 5129\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmp5naccxeb.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, index) = heap.remove()\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmpkwpakff0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "tmpxdb49tzn/tmpxdb49tzn.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1011bb8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b10118afb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b10118af988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b10118ae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxdb49tzn                        0x0000559d9c3d260c <unavailable> + 5644\n5    libc.so.6                          0x00002b1011da4460 __libc_start_main + 245\n6    tmpxdb49tzn                        0x0000559d9c3d2159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var visited = [[Bool]]()\n    for _ in 0..<nums1.count {\n        visited.append(Array(repeating: false, count: nums2.count))\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if !visited[i][j] {\n                heap.insert([nums1[i], nums2[j]])\n                visited[i][j] = true\n            }\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517442,
      "stdout": "",
      "stderr": "/tmp/tmp8_4amvfi.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmp8_4amvfi.swift:9:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpg40lkc0k.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517428,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else { return result }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmp72ya_d50.swift:6:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmp6xl2p289.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp6xl2p289.swift:20:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmp0d3kkrru.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmph9wut1ou.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    var count = 0\n    while count < k && index.contains(nums2.count) == false {\n        var min_value = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_value {\n                min_value = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        count += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517428,
      "stdout": "",
      "stderr": "tmp9zm3escd/tmp9zm3escd.swift:38: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1bc4d6bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b1bc4a62b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b1bc4a62988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b1bc4a617b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9zm3escd                        0x00005609809d2da0 <unavailable> + 7584\n5    libc.so.6                          0x00002b1bc4f57460 __libc_start_main + 245\n6    tmp9zm3escd                        0x00005609809d2409 <unavailable> + 5129\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        result.append([heap.extract()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpwkz93sao.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpyia8_rhg.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = 0\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if index < k {\n                result.append([nums1[i], nums2[j]])\n                index += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpja5sc8dg/tmpja5sc8dg.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b31ab552c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b31ab249b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b31ab249988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b31ab2487b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpja5sc8dg                        0x0000559b6078fc80 <unavailable> + 7296\n5    libc.so.6                          0x00002b31ab73e460 __libc_start_main + 245\n6    tmpja5sc8dg                        0x0000559b6078f2e9 <unavailable> + 4841\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.extract() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpvk1ws01r.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.replace(element: (sum, i * nums2.count + j))\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.pop()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpqlgkbzv2.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let pair = heap.remove()!\n        result.append([pair.0, pair.1])\n        if pair.1 < nums2.last! {\n            let next = (pair.0, pair.1 + 1)\n            heap.insert(next)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmp1oedde_w.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $1.0 < $1.0 + $0.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmpj3rg_wef.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $1.0 < $1.0 + $0.0 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    \n    for _ in 0..<k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        \n        if min_index == -1 { break }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        for i in 0..<nums1.count {\n            for j in 0..<nums2.count {\n                if nums1[i] + nums2[j] == sum {\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpfku09ubb.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.delete() {\n            result.append(value)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmp5dwnfzec.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        let i = nums1.index(where: { $0 + nums2[0] == sum })!\n        let j = nums2.index(where: { $0 + nums1[i] == sum })!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpdi83bd42.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.0 < $1.0 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i] + nums2[0], i, 0))\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, i, j) = heap.pop()!\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < nums2.count {\n            heap.push((nums1[i] + nums2[j + 1], i, j + 1))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpue0nrkqr.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.0 < $1.0 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i], nums2[j]))\n            } else if nums1[i] + nums2[j] < heap.peek()!.0 + heap.peek()!.1 {\n                heap.remove()\n                heap.insert((nums1[i], nums2[j]))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!.0, heap.remove()!.1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122971,
      "stdout": "",
      "stderr": "/tmp/tmpvhpp1btn.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((i, j, nums1[i] + nums2[j]))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        let (i, j, _) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmp0lkl0_pn.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n               ^~~~\n/tmp/tmp0lkl0_pn.swift:12:38: error: type of expression is ambiguous without more context\n        let (i, j, _) = heap.remove()!\n                        ~~~~~~~~~~~~~^\n/tmp/tmp0lkl0_pn.swift:14:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpqxysn6um.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpg40lkc0k.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpjf0wit7_.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp3mjww1gz.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (n1, n2) = heap.pop() {\n            result.append([n1, n2])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmp04cfi547.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append([heap.extract()!, heap.extract()!])\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmp7fdyv5kl.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n/tmp/tmp7fdyv5kl.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !pq.isEmpty && k > 0 {\n        result.append([pq.dequeue()!.0, pq.dequeue()!.1])\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmp64kquows.swift:5:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n             ^~~~~~~~~~~~~\n/tmp/tmp64kquows.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            pq.enqueue((nums1[i], nums2[j]))\n            if pq.count > k {\n                pq.dequeue()\n            }\n        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmpcythtzjw.swift:5:14: error: cannot find 'PriorityQueue' in scope\n    var pq = PriorityQueue<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n             ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty {\n            break\n        }\n        let (x, y) = heap.pop()!\n        result.append([x, y])\n        if y < nums2.last! {\n            heap.insert((x, y + 1))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmpp1a8wnq1.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        if let (a, b) = heap.remove() {\n            result.append([a, b])\n        }\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmphvmbt7if.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmphvmbt7if.swift:17:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = [Int](repeating: 0, count: nums1.count)\n    while result.count < k {\n        var min_val = Int.max\n        var min_index = -1\n        for i in 0..<nums1.count {\n            if index[i] < nums2.count && nums1[i] + nums2[index[i]] < min_val {\n                min_val = nums1[i] + nums2[index[i]]\n                min_index = i\n            }\n        }\n        if min_index == -1 {\n            break\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp9zpxad5b.swift:25:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    var visited = Set<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n                visited.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n                visited.insert(sum)\n            }\n        }\n    }\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if visited.contains(sum) {\n                result.append([nums1[i], nums2[j]])\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpktpdk7cv.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    while index1 < nums1.count && index2 < nums2.count && result.count < k {\n        if nums1[index1] < nums2[index2] {\n            result.append([nums1[index1], nums2[index2]])\n            index1 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            index2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp6budx_qb/tmp6budx_qb.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b14fedafc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b14feaa6b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b14feaa6988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b14feaa57b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp6budx_qb                        0x000055c5cea865cc <unavailable> + 5580\n5    libc.so.6                          0x00002b14fef9b460 __libc_start_main + 245\n6    tmp6budx_qb                        0x000055c5cea86119 <unavailable> + 4377\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, _) = heap.pop() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpk7_54m8m.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>()\n               ^~~~\n/tmp/tmpk7_54m8m.swift:12:34: error: type of expression is ambiguous without more context\n        if let (value, _) = heap.pop() {\n                            ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpi181rk5m.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (num1, num2) = heap.remove()!\n        result.append([num1, num2])\n        k -= 1\n        if num2 < nums2.last! {\n            let next = nums2.firstIndex(of: num2)! + 1\n            heap.insert((num1, nums2[next]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmpidw3zaqv.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpidw3zaqv.swift:17:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpgc_mhsj4.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpgc_mhsj4.swift:18:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert((nums1[i] + nums2[j], i + j))\n            } else if nums1[i] + nums2[j] < heap.peek()!.0 {\n                heap.insert((nums1[i] + nums2[j], i + j))\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index], nums2[index]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpqabky0bh.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "/tmp/tmp9kt6f_q3.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp9kt6f_q3.swift:21:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpxjt1sq27.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpxjt1sq27.swift:20:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<min(k, nums1.count) {\n        for j in 0..<min(k, nums2.count) {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result.sorted { $0[0] + $0[1] < $1[0] + $1[1] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "tmp33ludexk/tmp33ludexk.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b62985f1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b62982e8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b62982e8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b62982e77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp33ludexk                        0x000055916bb5184c <unavailable> + 6220\n5    libc.so.6                          0x00002b62987dd460 __libc_start_main + 245\n6    tmp33ludexk                        0x000055916bb51399 <unavailable> + 5017\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp8afkqeuh.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(order: <)\n    for i in 0..<nums1.count {\n        heap.push((nums1[i] + nums2[0], 0))\n    }\n    while result.count < k && !heap.isEmpty {\n        let (sum, index) = heap.pop()!\n        result.append([sum - nums2[index], nums2[index]])\n        if index + 1 < nums2.count {\n            heap.push((sum - nums2[index] + nums2[index + 1], index + 1))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122978,
      "stdout": "",
      "stderr": "/tmp/tmpwwleples.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(order: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122964,
      "stdout": "",
      "stderr": "/tmp/tmpqah_1air.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpqah_1air.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmp1jhcrm7g.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp1jhcrm7g.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>(sort: <)\n    for num1 in nums1 {\n        for num2 in nums2 {\n            heap.insert(num1 + num2)\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.pop() {\n            result.append(value)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpsl1u5cpz.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122964,
      "stdout": "",
      "stderr": "/tmp/tmpqah_1air.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpqah_1air.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        result.append(heap.remove()!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpie9ekeun.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    while k > 0 {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122983,
      "stdout": "",
      "stderr": "/tmp/tmpez107t2a.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpez107t2a.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpez107t2a.swift:17:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let index = heap.remove()!.1\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpi181rk5m.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.0 < $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpth5mgji3.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int, Int)>(sort: { $0.0 < $1.0 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.dequeue()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpn6ae1lxj.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n/tmp/tmpn6ae1lxj.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmptbulqdb5.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            let i = index / nums2.count\n            let j = index % nums2.count\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpdm4i0pxv.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var i = 0, j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "tmpaddj62jr/tmpaddj62jr.swift:31: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9545c9ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9545995b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9545995988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b95459947b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpaddj62jr                        0x000055f8f56e160c <unavailable> + 5644\n5    libc.so.6                          0x00002b9545e8a460 __libc_start_main + 245\n6    tmpaddj62jr                        0x000055f8f56e1159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpsvv9e_i0.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122953,
      "stdout": "",
      "stderr": "/tmp/tmpwxrlg4tb.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpwxrlg4tb.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while heap.count > 0 && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmp6pvhgblu.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmp6pvhgblu.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        heap.insert([nums1[i], nums2[0], 0])\n    }\n    \n    for _ in 0..<k {\n        if heap.count > 0 {\n            let pair = heap.remove()\n            result.append([pair[0], pair[1]])\n            if pair[2] < nums2.count - 1 {\n                heap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1])\n            }\n        } else {\n            break\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122983,
      "stdout": "",
      "stderr": "/tmp/tmpmezm05a0.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpmezm05a0.swift:9:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        k -= 1\n        if n2 < nums2.last! {\n            let index = nums2.index(of: n2)!\n            heap.insert((n1, nums2[index + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpjj64mm0i.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpjj64mm0i.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpqxysn6um.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmp0d3kkrru.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmprqu5nfti.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var res = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return res\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            res.append([pair.0, pair.1])\n        }\n    }\n    \n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmp7b81f4ez.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmplsf3pt5u.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return nums1[a.0] + nums2[a.1] < nums1[b.0] + nums2[b.1]\n    })\n    \n    for i in 0..<nums1.count {\n        heap.push((i, 0))\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (i, j) = heap.pop()!\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < nums2.count {\n            heap.push((i, j + 1))\n        }\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122988,
      "stdout": "",
      "stderr": "/tmp/tmpwvrbl_ef.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n/tmp/tmpwvrbl_ef.swift:9:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwvrbl_ef.swift:23:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.count == 0 {\n            break\n        }\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        if n2 < nums2.last! {\n            let index = nums2.index(of: n2)!\n            heap.insert((n1, nums2[index + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmpatybkdsw.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var index: [Int] = Array(repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmp_cjw8av9.swift:24:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmplqutwcjp.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n/tmp/tmplqutwcjp.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmpml8edur5.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: { (a, b) -> Bool in\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    var count = 0\n    while count < k && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        count += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmp_rd1koii.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.isEmpty || nums2.isEmpty {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty {\n            break\n        }\n        let (n1, n2) = heap.pop()!\n        result.append([n1, n2])\n        if n2 != nums2.last! {\n            heap.push((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmp_ys0aqs_.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else {\n                if sum < heap.peek()!.0 {\n                    heap.remove()\n                    heap.insert((sum, i * nums2.count + j))\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpxp1evycz.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpxp1evycz.swift:23:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Pair>(sort: { $0.sum < $1.sum })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    while !heap.isEmpty && result.count < k {\n        result.append(heap.remove()!.toArray())\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmp6y63au86.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Pair>(sort: { $0.sum < $1.sum })\n               ^~~~\n/tmp/tmp6y63au86.swift:8:25: error: cannot find 'Pair' in scope\n            heap.insert(Pair(nums1[i], nums2[j]))\n                        ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], (i, j)))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, (i, j)) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122968,
      "stdout": "",
      "stderr": "/tmp/tmpcnej7bk0.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[k - 1][0] + result[k - 1][1] {\n                    result.append([nums1[i], nums2[j]])\n                    result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                    result.removeLast()\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "tmpf4gzfqeq/tmpf4gzfqeq.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab7d63dac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab7d60d1b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab7d60d1988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab7d60d07b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpf4gzfqeq                        0x0000558714346e60 <unavailable> + 7776\n5    libc.so.6                          0x00002ab7d65c6460 __libc_start_main + 245\n6    tmpf4gzfqeq                        0x00005587143464c9 <unavailable> + 5321\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(elements: [], priorityFunction: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.dequeue() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "/tmp/tmp_72uogay.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(elements: [], priorityFunction: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmp4isdoeto.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (n1, n2) = heap.pop() {\n            result.append([n1, n2])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmp04cfi547.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "tmpxdb49tzn/tmpxdb49tzn.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b1011bb8c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b10118afb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b10118af988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b10118ae7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpxdb49tzn                        0x0000559d9c3d260c <unavailable> + 5644\n5    libc.so.6                          0x00002b1011da4460 __libc_start_main + 245\n6    tmpxdb49tzn                        0x0000559d9c3d2159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "/tmp/tmpwm83cxi1.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpp8oelgz7.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpp8oelgz7.swift:12:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!)\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122984,
      "stdout": "",
      "stderr": "/tmp/tmp7xnub04i.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmp7xnub04i.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7xnub04i.swift:13:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<[Int]>(sort: { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122985,
      "stdout": "",
      "stderr": "/tmp/tmpyroiyqj7.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { (a, b) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let value = heap.extract() {\n            result.append([value])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmp0d3kkrru.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    \n    for _ in 0..<k {\n        if let sum = heap.remove() {\n            result.append(sum)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122969,
      "stdout": "",
      "stderr": "/tmp/tmp34pv_h0k.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while result.count < k && !heap.isEmpty {\n        let (a, b) = heap.remove()!\n        result.append([a, b])\n        if b < nums2.last! {\n            heap.insert((a, b + 1))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "/tmp/tmp0nnfhdwz.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                if sum < result[k-1][0] + result[k-1][1] {\n                    result.append([nums1[i], nums2[j]])\n                    result.sort { (a, b) -> Bool in\n                        return a[0] + a[1] < b[0] + b[1]\n                    }\n                    result.removeLast()\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122971,
      "stdout": "",
      "stderr": "tmpmayfjm6c/tmpmayfjm6c.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002afd90c3bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002afd90932b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002afd90932988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002afd909317b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpmayfjm6c                        0x0000559505bacea0 <unavailable> + 7840\n5    libc.so.6                          0x00002afd90e27460 __libc_start_main + 245\n6    tmpmayfjm6c                        0x0000559505bac509 <unavailable> + 5385\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122964,
      "stdout": "",
      "stderr": "/tmp/tmpqah_1air.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpqah_1air.swift:5:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        result.append([nums1[i], nums2[j]])\n        if i == nums1.count - 1 {\n            j += 1\n        } else if j == nums2.count - 1 {\n            i += 1\n        } else {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "tmp956t2o5_/tmp956t2o5_.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b157a7c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b157a4bcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b157a4bc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b157a4bb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp956t2o5_                        0x00005555dd3afab0 <unavailable> + 6832\n5    libc.so.6                          0x00002b157a9b1460 __libc_start_main + 245\n6    tmp956t2o5_                        0x00005555dd3af119 <unavailable> + 4377\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var index = 0\n    var i = 0\n    var j = 0\n    while index < k && i < nums1.count && j < nums2.count {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n        index += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "tmpdli3t4qt/tmpdli3t4qt.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b7f9a66ec80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7f9a365b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7f9a365988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b7f9a3647b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpdli3t4qt                        0x000055c9c05d860c <unavailable> + 5644\n5    libc.so.6                          0x00002b7f9a85a460 __libc_start_main + 245\n6    tmpdli3t4qt                        0x000055c9c05d8159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let pair = heap.remove()!\n        result.append([nums1[pair.1 / nums2.count], nums2[pair.1 % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "/tmp/tmp29ir0yvm.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmph9wut1ou.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else {\n                if sum < heap.peek()! {\n                    heap.remove()\n                    heap.insert(sum)\n                }\n            }\n        }\n    }\n    while !heap.isEmpty {\n        result.append([nums1[0], heap.remove()! - nums1[0]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmpvoymbdka.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (value, index) = heap.pop() {\n            result.append([value, index])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmph5_qtq5x.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmppx5nvzkb.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122978,
      "stdout": "",
      "stderr": "/tmp/tmp7no3dcl5.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var queue = PriorityQueue<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue((nums1[i] + nums2[j], i, j))\n            if queue.count > k {\n                queue.dequeue()\n            }\n        }\n    }\n    while !queue.isEmpty {\n        let (sum, i, j) = queue.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmp7xmxxwjy.swift:5:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<(Int, Int)>(sort: <)\n                ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmp0l2qfyde.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    \n    while k > 0 && !heap.isEmpty {\n        let (a, b) = heap.pop()!\n        result.append([a, b])\n        k -= 1\n        \n        if b < nums2.last! {\n            let index = nums2.firstIndex(of: b)!\n            heap.push((a, nums2[index + 1]))\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122978,
      "stdout": "",
      "stderr": "/tmp/tmpddy_n4gl.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n/tmp/tmpddy_n4gl.swift:20:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp3h27cde5.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.pop() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122973,
      "stdout": "",
      "stderr": "/tmp/tmp_amusc38.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        result.append([nums1[i], nums2[j]])\n        if i == nums1.count - 1 {\n            j += 1\n        } else if j == nums2.count - 1 {\n            i += 1\n        } else {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122972,
      "stdout": "",
      "stderr": "tmp956t2o5_/tmp956t2o5_.swift:39: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b157a7c5c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b157a4bcb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b157a4bc988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b157a4bb7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp956t2o5_                        0x00005555dd3afab0 <unavailable> + 6832\n5    libc.so.6                          0x00002b157a9b1460 __libc_start_main + 245\n6    tmp956t2o5_                        0x00005555dd3af119 <unavailable> + 4377\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    \n    for _ in 0..<k {\n        guard let (n1, n2) = heap.pop() else {\n            break\n        }\n        result.append([n1, n2])\n        if n2 < nums2.last! {\n            let index = nums2.firstIndex(of: n2)!\n            heap.insert((n1, nums2[index + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122980,
      "stdout": "",
      "stderr": "/tmp/tmp47z54hov.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, _) = heap.pop() {\n            result.append([sum])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmpt0h59orb.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpt0h59orb.swift:14:32: error: type of expression is ambiguous without more context\n        if let (sum, _) = heap.pop() {\n                          ~~~~~^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i + j))\n        }\n    }\n    \n    while !heap.isEmpty && k > 0 {\n        let (sum, index) = heap.remove()\n        result.append([sum - index, index])\n        k -= 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122974,
      "stdout": "",
      "stderr": "/tmp/tmp3k82v8nv.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmp3k82v8nv.swift:16:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122979,
      "stdout": "",
      "stderr": "/tmp/tmpiq4qlmew.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { (a, b) -> Bool in\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    \n    while !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpbdmdascb.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert(nums1[i] + nums2[j])\n            } else {\n                if nums1[i] + nums2[j] < heap.peek()! {\n                    heap.remove()\n                    heap.insert(nums1[i] + nums2[j])\n                }\n            }\n        }\n    }\n    while !heap.isEmpty() {\n        result.append([heap.remove()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmp6gz29exr.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard !nums1.isEmpty && !nums2.isEmpty else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: {\n        return $0.0 + $0.1 < $1.0 + $1.1\n    })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122982,
      "stdout": "",
      "stderr": "/tmp/tmpl0xal3rw.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: {\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517428,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<Int>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let sum = heap.pop() {\n            result.append(sum)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpcojutn2j.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<[Int]> = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if heap.count < k {\n                heap.insert([nums1[i], nums2[j]])\n            } else {\n                if nums1[i] + nums2[j] < heap.peek()![0] + heap.peek()![1] {\n                    heap.insert([nums1[i], nums2[j]])\n                    heap.remove()\n                }\n            }\n        }\n    }\n    \n    while !heap.isEmpty() {\n        result.append(heap.remove()!)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122982,
      "stdout": "",
      "stderr": "/tmp/tmpkdkcowm8.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<[Int]> = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122981,
      "stdout": "",
      "stderr": "/tmp/tmp5ebf7i3k.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let sum = nums1[i] + nums2[j]\n                let max = result.max { (a, b) -> Bool in\n                    return a[0] + a[1] < b[0] + b[1]\n                }\n                if sum < max![0] + max![1] {\n                    let index = result.index { (a) -> Bool in\n                        return a[0] + a[1] == max![0] + max![1]\n                    }\n                    result.remove(at: index!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "tmp7_qkfp_y/tmp7_qkfp_y.swift:42: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af8e857fc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af8e8276b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af8e8276988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af8e82757b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7_qkfp_y                        0x000055f5868a7da0 <unavailable> + 7584\n5    libc.so.6                          0x00002af8e876b460 __libc_start_main + 245\n6    tmp7_qkfp_y                        0x000055f5868a7409 <unavailable> + 5129\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    \n    while !heap.isEmpty && result.count < k {\n        let (sum, i, j) = heap.dequeue()!\n        result.append([nums1[i], nums2[j]])\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpe8l4my0c.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)> { (e1, e2) -> Bool in\n        return e1.0 + e1.1 < e2.0 + e2.1\n    }\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    while !heap.isEmpty && k > 0 {\n        result.append(heap.remove()!.map { $0 })\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122979,
      "stdout": "",
      "stderr": "/tmp/tmpja0td9ls.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)> { (e1, e2) -> Bool in\n               ^~~~\n/tmp/tmpja0td9ls.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty() {\n            break\n        }\n        let (n1, n2) = heap.pop()!\n        result.append([n1, n2])\n        if n2 != nums2.last! {\n            heap.push((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122982,
      "stdout": "",
      "stderr": "/tmp/tmp4x3o5b2q.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i) = heap.pop() {\n            result.append([nums1[i], sum - nums1[i]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmppxrthcbd.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpcbrfv04s.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.enqueue((nums1[i] + nums2[j], i, j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpvj8n7nq4.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpswbisi4l.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n              ^~~~\n/tmp/tmpswbisi4l.swift:16:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            queue.enqueue([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = queue.dequeue() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122991,
      "stdout": "",
      "stderr": "/tmp/tmph4f0yoss.swift:8:17: error: cannot find 'PriorityQueue' in scope\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n                ^~~~~~~~~~~~~\n/tmp/tmph4f0yoss.swift:8:17: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var queue = PriorityQueue<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n        return a.0 + a.1 < b.0 + b.1\n    })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.push((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp0vacb9eg.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { (a, b) -> Bool in\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.enqueue((sum, i, j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, i, j) = heap.dequeue() {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122942,
      "stdout": "",
      "stderr": "/tmp/tmp_fln08h4.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(sort: <, elements: [])\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while index1 < nums1.count && index2 < nums2.count && count < k {\n        let sum = nums1[index1] + nums2[index2]\n        if index1 + 1 < nums1.count && index2 + 1 < nums2.count {\n            let sum1 = nums1[index1] + nums2[index2 + 1]\n            let sum2 = nums1[index1 + 1] + nums2[index2]\n            if sum1 < sum2 {\n                if sum1 < sum {\n                    result.append([nums1[index1], nums2[index2 + 1]])\n                    index2 += 1\n                } else {\n                    result.append([nums1[index1], nums2[index2]])\n                }\n            } else {\n                if sum2 < sum {\n                    result.append([nums1[index1 + 1], nums2[index2]])\n                    index1 += 1\n                } else {\n                    result.append([nums1[index1], nums2[index2]])\n                }\n            }\n        } else if index1 + 1 < nums1.count {\n            let sum2 = nums1[index1 + 1] + nums2[index2]\n            if sum2 < sum {\n                result.append([nums1[index1 + 1], nums2[index2]])\n                index1 += 1\n            } else {\n                result.append([nums1[index1], nums2[index2]])\n            }\n        } else if index2 + 1 < nums2.count {\n            let sum1 = nums1[index1] + nums2[index2 + 1]\n            if sum1 < sum {\n                result.append([nums1[index1], nums2[index2 + 1]])\n                index2 += 1\n            } else {\n                result.append([nums1[index1], nums2[index2]])\n            }\n        } else {\n           \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpbtb8x_4n.swift:63:127: error: expected '}' at end of brace statement\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])\n                                                                                                                              ^\n/tmp/tmpbtb8x_4n.swift:8:69: note: to match this opening '{'\n    while index1 < nums1.count && index2 < nums2.count && count < k {\n                                                                    ^\n/tmp/tmpbtb8x_4n.swift:63:127: error: expected '}' at end of brace statement\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])\n                                                                                                                              ^\n/tmp/tmpbtb8x_4n.swift:3:70: note: to match this opening '{'\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n                                                                     ^\n/tmp/tmpbtb8x_4n.swift:49:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpbtb8x_4n.swift:7:9: warning: variable 'count' was never mutated; consider changing to 'let' constant\n    var count = 0\n    ~~~ ^\n    let\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    \n    for _ in 0..<k {\n        if heap.isEmpty {\n            break\n        }\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        if n2 != nums2.last! {\n            heap.insert((n1, nums2[nums2.index(of: n2)! + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122982,
      "stdout": "",
      "stderr": "/tmp/tmp9b_mffic.swift:9:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert([nums1[i], nums2[j]])\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append(pair)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122990,
      "stdout": "",
      "stderr": "/tmp/tmpk4961mws.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~\n/tmp/tmpk4961mws.swift:8:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions\n    var heap = Heap<[Int]>(sort: { $0[0] + $0[1] < $1[0] + $1[1] })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    while heap.count > 0 && result.count < k {\n        result.append([heap.extract()!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122967,
      "stdout": "",
      "stderr": "/tmp/tmpwkz93sao.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517427,
      "stdout": "",
      "stderr": "/tmp/tmph9wut1ou.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            heap.insert((sum, i, j))\n            if heap.count > k {\n                heap.remove()\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (sum, i, j) = heap.remove()!\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpt4w9o4_d.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert(sum)\n            } else if sum < heap.peek()! {\n                heap.remove()\n                heap.insert(sum)\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let sum = heap.remove()!\n        var i = 0\n        var j = 0\n        while i < nums1.count && j < nums2.count {\n            if nums1[i] + nums2[j] == sum {\n                result.append([nums1[i], nums2[j]])\n                break\n            } else if nums1[i] + nums2[j] < sum {\n                i += 1\n            } else {\n                j += 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmpmk2ftg7w.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let (a, b) = heap.pop() {\n            result.append([a, b])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpw7cak9ba.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n    for i in 0..<nums1.count {\n        heap.push((nums1[i], nums2[0]))\n    }\n    for _ in 0..<k {\n        if heap.isEmpty() {\n            break\n        }\n        let (n1, n2) = heap.pop()!\n        result.append([n1, n2])\n        if n2 < nums2.last! {\n            let index = nums2.index(of: n2)!\n            heap.push((n1, nums2[index + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmphc7bk53z.swift:8:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap(elements: [], priorityFunction: { $0.0 + $1.0 })\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpkvs06kh2.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpkvs06kh2.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index = [Int](repeating: 0, count: nums1.count)\n    while k > 0 {\n        var min_val = Int.max\n        var min_index = 0\n        for i in 0..<nums1.count {\n            if index[i] >= nums2.count {\n                continue\n            }\n            let val = nums1[i] + nums2[index[i]]\n            if val < min_val {\n                min_val = val\n                min_index = i\n            }\n        }\n        result.append([nums1[min_index], nums2[index[min_index]]])\n        index[min_index] += 1\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmp9zpxad5b.swift:25:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n                result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n            } else {\n                if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                    result[k - 1] = [nums1[i], nums2[j]]\n                    result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                result.sort { $0[0] + $0[1] < $1[0] + $1[1] }\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    while k > 0 && !heap.isEmpty {\n        let (sum, index) = heap.remove()!\n        let i = index / nums2.count\n        let j = index % nums2.count\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmptxavy4by.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmptxavy4by.swift:16:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Int>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(nums1[i] + nums2[j])\n        }\n    }\n    for _ in 0..<k {\n        if let val = heap.pop() {\n            result.append([val])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122975,
      "stdout": "",
      "stderr": "/tmp/tmp4jk6cgbi.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Int>()\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    \n    if nums1.count == 0 || nums2.count == 0 {\n        return result\n    }\n    \n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122983,
      "stdout": "",
      "stderr": "/tmp/tmp0v6pu9zf.swift:10:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n    \n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    \n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "/tmp/tmpackfwjyb.swift:5:15: error: cannot find type 'Heap' in scope\n    var heap: Heap<(Int, Int)> = Heap<(Int, Int)>(sort: <)\n              ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    \n    var index1 = 0\n    var index2 = 0\n    var count = 0\n    while count < k && index1 < nums1.count && index2 < nums2.count {\n        let sum = nums1[index1] + nums2[index2]\n        if index1 + 1 < nums1.count && nums1[index1 + 1] + nums2[index2] < sum {\n            index1 += 1\n        } else if index2 + 1 < nums2.count && nums1[index1] + nums2[index2 + 1] < sum {\n            index2 += 1\n        } else {\n            result.append([nums1[index1], nums2[index2]])\n            count += 1\n            index1 += 1\n            index2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "tmpblff6m5h/tmpblff6m5h.swift:41: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0e2bc10c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0e2b907b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0e2b907988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0e2b9067b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpblff6m5h                        0x000055f45a06260c <unavailable> + 5644\n5    libc.so.6                          0x00002b0e2bdfc460 __libc_start_main + 245\n6    tmpblff6m5h                        0x000055f45a062159 <unavailable> + 4441\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<Pair>()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert(Pair(nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.extract() {\n            result.append([pair.first, pair.second])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "/tmp/tmpsdkcpclf.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<Pair>()\n               ^~~~\n/tmp/tmpsdkcpclf.swift:8:25: error: cannot find 'Pair' in scope\n            heap.insert(Pair(nums1[i], nums2[j]))\n                        ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                var min = Int.max\n                var minIndex = 0\n                for (index, item) in result.enumerated() {\n                    let sum = item[0] + item[1]\n                    if sum < min {\n                        min = sum\n                        minIndex = index\n                    }\n                }\n                let sum = nums1[i] + nums2[j]\n                if sum < min {\n                    result[minIndex] = [nums1[i], nums2[j]]\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "tmpfwiq773i/tmpfwiq773i.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b656e0fac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b656ddf1b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b656ddf1988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b656ddf07b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpfwiq773i                        0x000055f14a941ee0 <unavailable> + 7904\n5    libc.so.6                          0x00002b656e2e6460 __libc_start_main + 245\n6    tmpfwiq773i                        0x000055f14a941549 <unavailable> + 5449\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            let sum = nums1[i] + nums2[j]\n            if heap.count < k {\n                heap.insert((sum, i * nums2.count + j))\n            } else if sum < heap.peek()!.0 {\n                heap.remove()\n                heap.insert((sum, i * nums2.count + j))\n            }\n        }\n    }\n    while !heap.isEmpty {\n        let (_, index) = heap.remove()!\n        result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "/tmp/tmpry0eaz4s.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n/tmp/tmpry0eaz4s.swift:18:39: error: type of expression is ambiguous without more context\n        let (_, index) = heap.remove()!\n                         ~~~~~~~~~~~~~^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    guard nums1.count > 0 && nums2.count > 0 else {\n        return result\n    }\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        heap.insert((nums1[i], nums2[0]))\n    }\n    while k > 0 && !heap.isEmpty {\n        let (n1, n2) = heap.remove()!\n        result.append([n1, n2])\n        k -= 1\n        if n2 < nums2.last! {\n            heap.insert((n1, nums2[nums2.firstIndex(of: n2)! + 1]))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122983,
      "stdout": "",
      "stderr": "/tmp/tmpa5uq2x5z.swift:8:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n/tmp/tmpa5uq2x5z.swift:15:11: error: left side of mutating operator isn't mutable: 'k' is a 'let' constant\n        k -= 1\n        ~ ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            result.append([nums1[i], nums2[j]])\n        }\n    }\n    result.sort { (a, b) -> Bool in\n        return a[0] + a[1] < b[0] + b[1]\n    }\n    return Array(result[0..<k])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517409,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    var i = 0\n    var j = 0\n    while i < nums1.count && j < nums2.count && result.count < k {\n        if nums1[i] < nums2[j] {\n            result.append([nums1[i], nums2[j]])\n            i += 1\n        } else {\n            result.append([nums1[i], nums2[j]])\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "tmpf2gytuei/tmpf2gytuei.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b5cc54fbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b5cc51f2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b5cc51f2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b5cc51f17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpf2gytuei                        0x0000564ef54435cc <unavailable> + 5580\n5    libc.so.6                          0x00002b5cc56e7460 __libc_start_main + 245\n6    tmpf2gytuei                        0x0000564ef5443119 <unavailable> + 4377\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result: [[Int]] = []\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            if result.count < k {\n                result.append([nums1[i], nums2[j]])\n            } else {\n                let max = result.max { $0[0] + $0[1] < $1[0] + $1[1] }\n                if max![0] + max![1] > nums1[i] + nums2[j] {\n                    result.remove(at: result.index(of: max!)!)\n                    result.append([nums1[i], nums2[j]])\n                }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122976,
      "stdout": "",
      "stderr": "tmp9j9hj0gm/tmp9j9hj0gm.swift:36: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af52ec64c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af52e95bb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af52e95b988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af52e95a7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp9j9hj0gm                        0x0000561e2d358da0 <unavailable> + 7584\n5    libc.so.6                          0x00002af52ee50460 __libc_start_main + 245\n6    tmp9j9hj0gm                        0x0000561e2d358409 <unavailable> + 5129\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: <)\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i] + nums2[j], i * nums2.count + j))\n        }\n    }\n    for _ in 0..<k {\n        if let (sum, index) = heap.pop() {\n            result.append([nums1[index / nums2.count], nums2[index % nums2.count]])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "/tmp/tmpj0i31kx0.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: <)\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n    var result = [[Int]]()\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n    for i in 0..<nums1.count {\n        for j in 0..<nums2.count {\n            heap.insert((nums1[i], nums2[j]))\n        }\n    }\n    for _ in 0..<k {\n        if let pair = heap.pop() {\n            result.append([pair.0, pair.1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])",
      "timestamp": 1665517434,
      "stdout": "",
      "stderr": "/tmp/tmpobxfpc01.swift:5:16: error: cannot find 'Heap' in scope\n    var heap = Heap<(Int, Int)>(sort: { $0.0 + $0.1 < $1.0 + $1.1 })\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}