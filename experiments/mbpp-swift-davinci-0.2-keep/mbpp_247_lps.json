{
  "name": "mbpp_247_lps",
  "language": "swift",
  "prompt": "\n/// Write a function to find the length of the longest palindromic subsequence in the given string.\nfunc lps(str: String) -> Int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(lps(str: \"TENS FOR TENS\") == 5)\nassert(lps(str: \"CARDIO FOR CARDS\") == 7)\nassert(lps(str: \"PART OF THE JOURNEY IS PART\") == 9)",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let s = Array(str)\n    var dp = Array(repeating: Array(repeating: 0, count: s.count), count: s.count)\n    \n    for i in 0..<s.count {\n        dp[i][i] = 1\n    }\n    \n    for i in stride(from: s.count - 1, through: 0, by: -1) {\n        for j in i + 1..<s.count {\n            if s[i] == s[j] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    \n    return dp[0][s.count - 1]",
    "    let n = str.count\n    let s = Array(str)\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for i in stride(from: n - 2, through: 0, by: -1) {\n        for j in i + 1..<n {\n            if s[i] == s[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]",
    "    var dp = Array(repeating: Array(repeating: 0, count: str.count), count: str.count)\n    for i in 0..<str.count {\n        dp[i][i] = 1\n    }\n    for i in stride(from: str.count - 1, through: 0, by: -1) {\n        for j in i + 1..<str.count {\n            if str[i] == str[j] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][str.count - 1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for i in stride(from: n-2, through: 0, by: -1) {\n        for j in i+1..<n {\n            if str[str.index(str.startIndex, offsetBy: i)] == str[str.index(str.startIndex, offsetBy: j)] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for length in 2...n {\n        for i in 0..<n-length+1 {\n            let j = i+length-1\n            if str[str.index(str.startIndex, offsetBy: i)] == str[str.index(str.startIndex, offsetBy: j)] {\n                dp[i][j] = 2 + dp[i+1][j-1]\n            } else {\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n            }\n        }\n    }\n    \n    return dp[0][n-1]",
    "    guard str.count > 1 else { return str.count }\n    \n    var dp = [[Int]](repeating: [Int](repeating: 0, count: str.count), count: str.count)\n    \n    for i in 0..<str.count {\n        dp[i][i] = 1\n    }\n    \n    for startIndex in stride(from: str.count - 1, through: 0, by: -1) {\n        for endIndex in startIndex + 1..<str.count {\n            if str[str.index(str.startIndex, offsetBy: startIndex)] == str[str.index(str.startIndex, offsetBy: endIndex)] {\n                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1]\n            } else {\n                dp[startIndex][endIndex] = max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1])\n            }\n        }\n    }\n    \n    return dp[0][str.count - 1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for i in stride(from: n - 1, through: 0, by: -1) {\n        for j in i + 1..<n {\n            if str[str.index(str.startIndex, offsetBy: i)] == str[str.index(str.startIndex, offsetBy: j)] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    \n    return dp[0][n - 1]",
    "    let n = str.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for startIndex in stride(from: n - 1, through: 0, by: -1) {\n        var endIndex = startIndex + 1\n        while endIndex < n {\n            if str[str.index(str.startIndex, offsetBy: startIndex)] == str[str.index(str.startIndex, offsetBy: endIndex)] {\n                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1]\n            } else {\n                dp[startIndex][endIndex] = max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1])\n            }\n            endIndex += 1\n        }\n    }\n    return dp[0][n - 1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for i in 0..<n-1 {\n        if str[i] == str[i+1] {\n            dp[i][i+1] = 2\n        } else {\n            dp[i][i+1] = 1\n        }\n    }\n    for k in 2..<n {\n        for i in 0..<n-k {\n            let j = i + k\n            if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for i in 0..<n-1 {\n        if str[i] == str[i+1] {\n            dp[i][i+1] = 2\n        } else {\n            dp[i][i+1] = 1\n        }\n    }\n    for k in 3...n {\n        for i in 0..<n-k+1 {\n            let j = i+k-1\n            if str[i] == str[j] {\n                dp[i][j] = 2 + dp[i+1][j-1]\n            } else {\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n            }\n        }\n    }\n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for l in 2...n {\n        for i in 0..<n-l+1 {\n            let j = i+l-1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for length in 2...n {\n        for i in 0..<n-length+1 {\n            let j = i+length-1\n            if str[i] == str[j] && length == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = 2 + dp[i+1][j-1]\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    \n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for l in 2...n {\n        for i in 0..<n-l+1 {\n            let j = i+l-1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n            }\n        }\n    }\n    \n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for length in 2...n {\n        for i in 0..<n-length+1 {\n            let j = i+length-1\n            if str[str.index(str.startIndex, offsetBy: i)] == str[str.index(str.startIndex, offsetBy: j)] {\n                dp[i][j] = 2 + dp[i+1][j-1]\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    \n    return dp[0][n-1]",
    "    let n = str.count\n    let s = Array(str)\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for i in stride(from: n - 1, through: 0, by: -1) {\n        for j in i + 1..<n {\n            if s[i] == s[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    \n    return dp[0][n - 1]",
    "    let n = str.count\n    let s = Array(str)\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for l in 2...n {\n        for i in 0..<n-l+1 {\n            let j = i+l-1\n            if s[i] == s[j] && l == 2 {\n                dp[i][j] = 2\n            } else if s[i] == s[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    \n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for i in stride(from: n - 2, through: 0, by: -1) {\n        for j in i + 1..<n {\n            if str[str.index(str.startIndex, offsetBy: i)] == str[str.index(str.startIndex, offsetBy: j)] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for i in stride(from: n - 2, through: 0, by: -1) {\n        for j in i + 1..<n {\n            if str[str.index(str.startIndex, offsetBy: i)] == str[str.index(str.startIndex, offsetBy: j)] {\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    \n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    \n    for startIndex in stride(from: n-1, through: 0, by: -1) {\n        var endIndex = startIndex+1\n        while endIndex < n {\n            if str[str.index(str.startIndex, offsetBy: startIndex)] == str[str.index(str.startIndex, offsetBy: endIndex)] {\n                dp[startIndex][endIndex] = 2 + dp[startIndex+1][endIndex-1]\n            } else {\n                dp[startIndex][endIndex] = max(dp[startIndex+1][endIndex], dp[startIndex][endIndex-1])\n            }\n            endIndex += 1\n        }\n    }\n    \n    return dp[0][n-1]",
    "    let n = str.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        dp[i][i] = 1\n    }\n    for l in 2...n {\n        for i in 0..<n-l+1 {\n            let j = i+l-1\n            if str[i] == str[j] && l == 2 {\n                dp[i][j] = 2\n            } else if str[i] == str[j] {\n                dp[i][j] = dp[i+1][j-1] + 2\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n            }\n        }\n    }\n    return dp[0][n-1]"
  ]
}