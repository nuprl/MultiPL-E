{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "swift",
  "prompt": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)",
    "    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost.count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost.count-1]) / Double(2*cost.count - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)",
    "    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)",
    "    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double((cost.count + cost[0].count - 1))",
    "    let row = cost.count\n    let col = cost[0].count\n    var dp = cost\n    for i in 1..<row {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<col {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<row {\n        for j in 1..<col {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[row-1][col-1]) / Double(row + col - 1)",
    "    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))",
    "    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double((2*n - 1))",
    "    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)"
  ]
}