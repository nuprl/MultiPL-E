{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "swift",
  "prompt": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost.count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost.count-1]) / Double(2*cost.count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let row = cost.count\n    let col = cost[0].count\n    var dp = cost\n    for i in 1..<row {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<col {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<row {\n        for j in 1..<col {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[row-1][col-1]) / Double(row + col - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double((2*n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0.0, count: m), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][m - 1] / Double(n + m - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAvg = 0.0\n    var sum = 0\n    var count = 0\n    var i = 0\n    var j = 0\n    var path = [String]()\n    var pathCost = [[Int]]()\n    var pathCount = [[Int]]()\n    var pathAvg = [[Double]]()\n    var pathAvgString = [[String]]()\n    \n    for _ in 0..<cost.count {\n        pathCost.append([Int]())\n        pathCount.append([Int]())\n        pathAvg.append([Double]())\n        pathAvgString.append([String]())\n        for _ in 0..<cost.count {\n            pathCost[i].append(0)\n            pathCount[i].append(0)\n            pathAvg[i].append(0.0)\n            pathAvgString[i].append(\"\")\n        }\n        i += 1\n    }\n    \n    pathCost[0][0] = cost[0][0]\n    pathCount[0][0] = 1\n    pathAvg[0][0] = Double(cost[0][0])\n    pathAvgString[0][0] = String(cost[0][0])\n    \n    for i in 0..<cost.count {\n        for j in 0..<cost.count {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                pathCost[i][j] = pathCost[i][j-1] + cost[i][j]\n                pathCount[i][j] = pathCount[i][j-1] + 1\n                pathAvg[i][j] = Double(pathCost[i][j]) / Double(pathCount[i][j])\n                pathAvgString[i][j] = pathAvgString[i][j-1] + \" + \" + String(cost[i][j])\n            } else if j == 0 {\n                pathCost[i][j] = pathCost[i-1][j] + cost[i][j]\n                pathCount[i][j] = pathCount[i-1][j] + 1\n                pathAvg[i][j] = Double(pathCost[i][j]) / Double(path\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "/tmp/tmpaoayuqot.swift:48:1: error: expected ')' in expression list\n}\n^\n/tmp/tmpaoayuqot.swift:47:64: note: to match this opening '('\n                pathAvg[i][j] = Double(pathCost[i][j]) / Double(path\n                                                               ^\n/tmp/tmpaoayuqot.swift:66:73: error: expected '}' at end of brace statement\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)\n                                                                        ^\n/tmp/tmpaoayuqot.swift:35:33: note: to match this opening '{'\n        for j in 0..<cost.count {\n                                ^\n/tmp/tmpaoayuqot.swift:66:73: error: expected '}' at end of brace statement\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)\n                                                                        ^\n/tmp/tmpaoayuqot.swift:34:29: note: to match this opening '{'\n    for i in 0..<cost.count {\n                            ^\n/tmp/tmpaoayuqot.swift:66:73: error: expected '}' at end of brace statement\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)\n                                                                        ^\n/tmp/tmpaoayuqot.swift:3:48: note: to match this opening '{'\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n                                               ^\n/tmp/tmpaoayuqot.swift:47:58: error: no exact matches in call to initializer \n                pathAvg[i][j] = Double(pathCost[i][j]) / Double(path\n                                                         ^\nSwift.Double:4:12: note: candidate expects value of type 'Builtin.FPIEEE64' for parameter #1 (got '[String]')\n    public init(_ _value: Builtin.FPIEEE64)\n           ^\nSwift.Double:2:12: note: candidate expects value of type 'Int' for parameter #1 (got '[String]')\n    public init(_ v: Int)\n           ^\nSwift.Double:6:23: note: candidate expects value of type 'Float16' for parameter #1 (got '[String]')\n    @inlinable public init(_ other: Float16)\n                      ^\nSwift.Double:9:23: no",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double((2 * n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 && cost[0].count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0.0, count: m), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][m - 1] / Double(n + m - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmp5lgnejfe/tmp5lgnejfe.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ae276137c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ae275e2eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ae275e2e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ae275e2d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp5lgnejfe                        0x0000562e9543b888 <unavailable> + 6280\n5    libc.so.6                          0x00002ae276323460 __libc_start_main + 245\n6    tmp5lgnejfe                        0x0000562e9543b429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(n * n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmpsyrn4__5/tmpsyrn4__5.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b01aa4b0c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b01aa1a7b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b01aa1a7988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b01aa1a67b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsyrn4__5                        0x00005599a6406888 <unavailable> + 6280\n5    libc.so.6                          0x00002b01aa69c460 __libc_start_main + 245\n6    tmpsyrn4__5                        0x00005599a6406429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    \n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    \n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count-1][cost[0].count-1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i-1][0]\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[0][i] += dp[0][i - 1]\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    guard cost.count == cost[0].count else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(n * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double((2*n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j - 1] + cost[0][j]\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][m - 1]) / Double(n + m - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmp7xj88jni/tmp7xj88jni.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab15d037c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab15cd2eb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab15cd2e988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab15cd2d7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp7xj88jni                        0x0000557795c927f8 <unavailable> + 6136\n5    libc.so.6                          0x00002ab15d223460 __libc_start_main + 245\n6    tmp7xj88jni                        0x0000557795c92399 <unavailable> + 5017\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i-1][0]\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let row = cost.count\n    let col = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: col), count: row)\n    dp[0][0] = cost[0][0]\n    for i in 1..<row {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<col {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<row {\n        for j in 1..<col {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[row-1][col-1]) / Double(row + col - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var cache: [[Double]] = Array(repeating: Array(repeating: 0, count: cost[0].count), count: cost.count)\n    var totalCost = 0\n    for i in 0..<cost.count {\n        for j in 0..<cost[0].count {\n            totalCost += cost[i][j]\n        }\n    }\n    return maxAverageOfPath(cost: cost, cache: &cache, i: 0, j: 0, totalCost: totalCost)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "/tmp/tmp9jr3g4pb.swift:11:28: error: extra arguments at positions #2, #3, #4, #5 in call\n    return maxAverageOfPath(cost: cost, cache: &cache, i: 0, j: 0, totalCost: totalCost)\n                           ^\n/tmp/tmp9jr3g4pb.swift:3:6: note: 'maxAverageOfPath(cost:)' declared here\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAvg = 0.0\n    var totalCost = 0\n    var totalCells = 0\n    var row = 0\n    var col = 0\n    var path = [(row: Int, col: Int)]()\n    while row < cost.count && col < cost[0].count {\n        totalCost += cost[row][col]\n        totalCells += 1\n        path.append((row: row, col: col))\n        if row == cost.count - 1 {\n            col += 1\n        } else if col == cost[0].count - 1 {\n            row += 1\n        } else {\n            if cost[row + 1][col] > cost[row][col + 1] {\n                row += 1\n            } else {\n                col += 1\n            }\n        }\n    }\n    maxAvg = Double(totalCost) / Double(totalCells)\n    print(\"Max Average: \\(maxAvg)\")\n    print(\"Path: \\(path)\")\n    return maxAvg\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "Max Average: 5.2\nPath: [(row: 0, col: 0), (row: 1, col: 0), (row: 2, col: 0), (row: 2, col: 1), (row: 2, col: 2)]\nMax Average: 6.2\nPath: [(row: 0, col: 0), (row: 1, col: 0), (row: 2, col: 0), (row: 2, col: 1), (row: 2, col: 2)]\nMax Average: 7.2\nPath: [(row: 0, col: 0), (row: 1, col: 0), (row: 2, col: 0), (row: 2, col: 1), (row: 2, col: 2)]\nMax Average: 5.8\nPath: [(row: 0, col: 0), (row: 1, col: 0), (row: 2, col: 0), (row: 2, col: 1), (row: 2, col: 2)]\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAverage = Double.leastNormalMagnitude\n    var cost = cost\n    var row = 0\n    var col = 0\n    var totalCost = 0\n    var count = 0\n    while row < cost.count && col < cost[0].count {\n        totalCost += cost[row][col]\n        count += 1\n        let nextRow = row + 1\n        let nextCol = col + 1\n        if nextRow < cost.count && nextCol < cost[0].count {\n            if cost[nextRow][col] < cost[row][nextCol] {\n                row = nextRow\n            } else {\n                col = nextCol\n            }\n        } else if nextRow < cost.count {\n            row = nextRow\n        } else if nextCol < cost[0].count {\n            col = nextCol\n        } else {\n            break\n        }\n    }\n    maxAverage = Double(totalCost) / Double(count)\n    return maxAverage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmpqkoev12z/tmpqkoev12z.swift:46: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba2157eac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba2154e1b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba2154e1988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba2154e07b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqkoev12z                        0x000055774d9c6528 <unavailable> + 5416\n5    libc.so.6                          0x00002ba2159d6460 __libc_start_main + 245\n6    tmpqkoev12z                        0x000055774d9c60c9 <unavailable> + 4297\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count-1][cost[0].count-1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count - 1][cost[0].count - 1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n        dp[0][i] = dp[0][i - 1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var maxAverage = 0.0\n    var totalCost = 0\n    var totalCells = 0\n    var row = 0\n    var col = 0\n    while row < cost.count && col < cost[0].count {\n        totalCost += cost[row][col]\n        totalCells += 1\n        if row == cost.count - 1 {\n            col += 1\n        } else if col == cost[0].count - 1 {\n            row += 1\n        } else {\n            if cost[row][col + 1] > cost[row + 1][col] {\n                col += 1\n            } else {\n                row += 1\n            }\n        }\n    }\n    maxAverage = Double(totalCost) / Double(totalCells)\n    return maxAverage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmpp6tgzupl/tmpp6tgzupl.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abf7194dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abf71644b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abf71644988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abf716437b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpp6tgzupl                        0x000055f201fcf888 <unavailable> + 6280\n5    libc.so.6                          0x00002abf71b39460 __libc_start_main + 245\n6    tmpp6tgzupl                        0x000055f201fcf429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmpqkrdugfr/tmpqkrdugfr.swift:33: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b660795ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b6607651b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b6607651988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b66076507b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpqkrdugfr                        0x0000555e3f7e6888 <unavailable> + 6280\n5    libc.so.6                          0x00002b6607b46460 __libc_start_main + 245\n6    tmpqkrdugfr                        0x0000555e3f7e6429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp: [[Double]] = Array(repeating: Array(repeating: 0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count - 1][cost[0].count - 1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp: [[Double]] = Array(repeating: Array(repeating: 0, count: cost.count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    \n    for i in 1..<cost.count {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    \n    for j in 1..<cost.count {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    \n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[cost.count-1][cost.count-1] / Double(cost.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmp8acwxs7k/tmp8acwxs7k.swift:37: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af390743c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af39043ab6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af39043a988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af3904397b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8acwxs7k                        0x0000555c74205888 <unavailable> + 6280\n5    libc.so.6                          0x00002af39092f460 __libc_start_main + 245\n6    tmp8acwxs7k                        0x0000555c74205429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count - 1][cost[0].count - 1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][m-1]) / Double(n + m - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0.0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost.count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    \n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    \n    return dp[cost.count - 1][cost.count - 1] / Double(2 * cost.count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = [[Double]](repeating: [Double](repeating: 0, count: cost.count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost.count {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost.count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count-1][cost.count-1] / Double(cost.count * 2 - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][m-1]) / Double(n+m-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double((cost.count + cost[0].count - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count-1][cost[0].count-1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else {\n        return 0\n    }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(n*n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "tmpp6tgzupl/tmpp6tgzupl.swift:32: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abf7194dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abf71644b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abf71644988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abf716437b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpp6tgzupl                        0x000055f201fcf888 <unavailable> + 6280\n5    libc.so.6                          0x00002abf71b39460 __libc_start_main + 245\n6    tmpp6tgzupl                        0x000055f201fcf429 <unavailable> + 5161\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    guard cost.count > 0 else { return 0 }\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[0][i] += dp[0][i - 1]\n        dp[i][0] += dp[i - 1][0]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i-1][0]\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = Array(repeating: Array(repeating: 0.0, count: cost[0].count), count: cost.count)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<cost.count {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[cost.count - 1][cost[0].count - 1] / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i-1][0]\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let rows = cost.count\n    let cols = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0.0, count: cols), count: rows)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<rows {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for j in 1..<cols {\n        dp[0][j] = dp[0][j-1] + Double(cost[0][j])\n    }\n    for i in 1..<rows {\n        for j in 1..<cols {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[rows-1][cols-1] / Double(rows + cols - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j - 1] + cost[0][j]\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n - 1][m - 1]) / Double((n + m - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i - 1][0]\n    }\n    for j in 1..<cost[0].count {\n        dp[0][j] += dp[0][j - 1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[cost.count - 1][cost[0].count - 1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: n)\n    dp[0][0] = cost[0][0]\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return Double(dp[n-1][n-1]) / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i-1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i-1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / Double(2*n-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = Array(repeating: Array(repeating: 0.0, count: n), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + Double(cost[0][i])\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    var dp = cost\n    for i in 1..<cost.count {\n        dp[i][0] += dp[i-1][0]\n    }\n    for i in 1..<cost[0].count {\n        dp[0][i] += dp[0][i-1]\n    }\n    for i in 1..<cost.count {\n        for j in 1..<cost[0].count {\n            dp[i][j] += max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return Double(dp[cost.count-1][cost[0].count-1]) / Double(cost.count + cost[0].count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    let m = cost[0].count\n    var dp = Array(repeating: Array(repeating: 0.0, count: m), count: n)\n    dp[0][0] = Double(cost[0][0])\n    for i in 1..<n {\n        dp[i][0] = dp[i - 1][0] + Double(cost[i][0])\n    }\n    for j in 1..<m {\n        dp[0][j] = dp[0][j - 1] + Double(cost[0][j])\n    }\n    for i in 1..<n {\n        for j in 1..<m {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + Double(cost[i][j])\n        }\n    }\n    return dp[n - 1][m - 1] / Double(n + m - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n    let n = cost.count\n    var dp = cost\n    for i in 1..<n {\n        dp[i][0] += dp[i - 1][0]\n        dp[0][i] += dp[0][i - 1]\n    }\n    for i in 1..<n {\n        for j in 1..<n {\n            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return Double(dp[n - 1][n - 1]) / Double(2 * n - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}