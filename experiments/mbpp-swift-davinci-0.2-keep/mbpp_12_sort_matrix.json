{
  "name": "mbpp_12_sort_matrix",
  "language": "swift",
  "prompt": "\n/// Write a function to sort a given matrix in ascending order according to the sum of its rows.\nfunc sort_matrix(M: [[Int]]) -> [[Int]] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_matrix(M: [[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]])\nassert(sort_matrix(M: [[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]])\nassert(sort_matrix(M: [[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]])",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    })",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    let sorted = M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return sorted",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    var sums = [Int]()\n    for row in M {\n        sums.append(row.reduce(0, +))\n    }\n    for i in 0..<sums.count {\n        for j in 0..<sums.count - 1 {\n            if sums[j] > sums[j + 1] {\n                sums.swapAt(j, j + 1)\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-i-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    var sums = [Int]()\n    for row in M {\n        sums.append(row.reduce(0, +))\n    }\n    for i in 0..<sums.count {\n        for j in i+1..<sums.count {\n            if sums[i] > sums[j] {\n                sums.swapAt(i, j)\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    let sorted = M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return sorted",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count {\n            for k in 0..<M.count {\n                if sum_of_elements(M[j]) < sum_of_elements(M[k]) {\n                    let aux = M[j]\n                    M[j] = M[k]\n                    M[k] = aux\n                }\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    M.sort { (r1, r2) -> Bool in\n        r1.reduce(0, +) < r2.reduce(0, +)\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    let sorted = M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return sorted",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count {\n            for k in 0..<M.count {\n                if M[i][j] > M[i][k] {\n                    let temp = M[i][j]\n                    M[i][j] = M[i][k]\n                    M[i][k] = temp\n                }\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M[i].count {\n            for k in 0..<M.count {\n                if sum_of_row(M[i]) < sum_of_row(M[k]) {\n                    let temp = M[i]\n                    M[i] = M[k]\n                    M[k] = temp\n                }\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                swap(&M[j], &M[j+1])\n            }\n        }\n    }\n    return M",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M[i].count {\n            M[i][j] = M[i][j] * M[i][j]\n        }\n    }\n    M.sort { (a, b) -> Bool in\n        var sum_a = 0\n        var sum_b = 0\n        for i in 0..<a.count {\n            sum_a += a[i]\n            sum_b += b[i]\n        }\n        return sum_a < sum_b\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (row1, row2) -> Bool in\n        return row1.reduce(0, +) < row2.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var result = M\n    for i in 0..<result.count {\n        for j in i+1..<result.count {\n            if result[i].reduce(0, +) > result[j].reduce(0, +) {\n                result.swapAt(i, j)\n            }\n        }\n    }\n    return result",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M[i].count {\n            for k in 0..<M.count {\n                if sum_of_row(M[i]) < sum_of_row(M[k]) {\n                    let temp = M[i]\n                    M[i] = M[k]\n                    M[k] = temp\n                }\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    var sums = [Int]()\n    for i in 0..<M.count {\n        var sum = 0\n        for j in 0..<M[i].count {\n            sum += M[i][j]\n        }\n        sums.append(sum)\n    }\n    for i in 0..<sums.count {\n        for j in 0..<sums.count - i - 1 {\n            if sums[j] > sums[j + 1] {\n                sums.swapAt(j, j + 1)\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    var sums = [Int]()\n    for row in M {\n        sums.append(row.reduce(0, +))\n    }\n    for i in 0..<sums.count {\n        for j in i..<sums.count {\n            if sums[i] > sums[j] {\n                sums.swapAt(i, j)\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    let sorted = M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }\n    return sorted",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if sum(M[j]) > sum(M[j + 1]) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted {\n        $0.reduce(0, +) < $1.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-i-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { row1, row2 in\n        row1.reduce(0, +) < row2.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-i-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if sum_of_row(M: M, i: j) > sum_of_row(M: M, i: j + 1) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum_of_row(M[j]) > sum_of_row(M[j+1]) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var result = M\n    result.sort { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return result",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M[i].count {\n            for k in 0..<M.count {\n                if sum_of_row(M[i]) < sum_of_row(M[k]) {\n                    let temp = M[i]\n                    M[i] = M[k]\n                    M[k] = temp\n                }\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if sum_of_row(M, i) > sum_of_row(M, j) {\n                let temp = M[i]\n                M[i] = M[j]\n                M[j] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    var sums = [Int]()\n    for row in M {\n        sums.append(row.reduce(0, +))\n    }\n    for i in 0..<sums.count - 1 {\n        for j in i + 1..<sums.count {\n            if sums[i] > sums[j] {\n                sums.swapAt(i, j)\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    let sorted = M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return sorted",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { $0.reduce(0, +) < $1.reduce(0, +) }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - i - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                M.swapAt(j, j + 1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, +) > M[j].reduce(0, +) {\n                M.swapAt(i, j)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count - 1 {\n            if M[j].reduce(0, +) > M[j + 1].reduce(0, +) {\n                let temp = M[j]\n                M[j] = M[j + 1]\n                M[j + 1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    return M.sorted(by: { $0.reduce(0, +) < $1.reduce(0, +) })",
    "    var M = M\n    M.sort { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if M[j].reduce(0, +) > M[j+1].reduce(0, +) {\n                M.swapAt(j, j+1)\n            }\n        }\n    }\n    return M",
    "    var M = M\n    for i in 0..<M.count {\n        for j in i+1..<M.count {\n            if M[i].reduce(0, combine: +) > M[j].reduce(0, combine: +) {\n                let tmp = M[i]\n                M[i] = M[j]\n                M[j] = tmp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    var M = M\n    for i in 0..<M.count {\n        for j in 0..<M.count-1 {\n            if sum(M[j]) > sum(M[j+1]) {\n                let temp = M[j]\n                M[j] = M[j+1]\n                M[j+1] = temp\n            }\n        }\n    }\n    return M",
    "    return M.sorted { (a, b) -> Bool in\n        a.reduce(0, +) < b.reduce(0, +)\n    }",
    "    return M.sorted { (a, b) -> Bool in\n        return a.reduce(0, +) < b.reduce(0, +)\n    }"
  ]
}