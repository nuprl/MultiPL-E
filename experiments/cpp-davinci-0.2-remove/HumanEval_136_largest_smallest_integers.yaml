name: HumanEval_136_largest_smallest_integers
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns\
  \ a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is\
  \ the smallest\n// of positive integers in a list.\n// If there is no negative or\
  \ positive integers, return them as None.\n// Examples:\nstd::tuple<std::optional<long>,\
  \ std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2,\
  \ (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
  \ (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3,\
  \ (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n\
  \    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2,\
  \ (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7,\
  \ (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9,\
  \ 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt),\
  \ std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0})))\
  \ == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n\
  \    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6})))\
  \ == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n\
  \    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6,\
  \ (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n\
  \    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3,\
  \ (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6,\
  \ (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n\
  }\n"
completions: ["    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i: lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i: lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n    std::optional<long> a, b;\n    for (auto i\
    \ : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    result = std::make_tuple(a, b);\n    return result;", "  std::optional<long>\
    \ a, b;\n  for (auto i : lst) {\n    if (i < 0) {\n      if (!a.has_value() ||\
    \ i > a.value()) {\n        a = i;\n      }\n    } else {\n      if (!b.has_value()\
    \ || i < b.value()) {\n        b = i;\n      }\n    }\n  }\n  return std::make_tuple(a,\
    \ b);", "  std::optional<long> a = std::nullopt;\n  std::optional<long> b = std::nullopt;\n\
    \  for (auto i : lst) {\n    if (i < 0) {\n      if (!a.has_value() || i > a.value())\
    \ {\n        a = i;\n      }\n    } else {\n      if (!b.has_value() || i < b.value())\
    \ {\n        b = i;\n      }\n    }\n  }\n  return std::make_tuple(a, b);", " \
    \   std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return {a, b};",
  "    std::tuple<std::optional<long>, std::optional<long>> result;\n    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else if (i > 0) {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    result = std::make_tuple(largest_negative,\
    \ smallest_positive);\n    return result;", "    std::optional<long> largest_neg;\n\
    \    std::optional<long> smallest_pos;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!largest_neg.has_value() || i > largest_neg.value())\
    \ {\n                largest_neg = i;\n            }\n        } else {\n     \
    \       if (!smallest_pos.has_value() || i < smallest_pos.value()) {\n       \
    \         smallest_pos = i;\n            }\n        }\n    }\n    return std::make_tuple(largest_neg,\
    \ smallest_pos);", "    std::optional<long> largest_neg;\n    std::optional<long>\
    \ smallest_pos;\n    for (auto i : lst) {\n        if (i < 0) {\n            if\
    \ (!largest_neg.has_value() || i > largest_neg.value()) {\n                largest_neg\
    \ = i;\n            }\n        } else {\n            if (!smallest_pos.has_value()\
    \ || i < smallest_pos.value()) {\n                smallest_pos = i;\n        \
    \    }\n        }\n    }\n    return std::make_tuple(largest_neg, smallest_pos);",
  "  std::optional<long> a, b;\n  for (auto i : lst) {\n    if (i < 0) {\n      if\
    \ (!a.has_value() || i > a.value()) {\n        a = i;\n      }\n    } else {\n\
    \      if (!b.has_value() || i < b.value()) {\n        b = i;\n      }\n    }\n\
    \  }\n  return std::make_tuple(a, b);", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else if (i > 0)\
    \ {\n            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    std::get<0>(result) = largest_negative;\n    std::get<1>(result) = smallest_positive;\n\
    \    return result;", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0 && (!a || i > *a)) {\n            a = i;\n        }\n     \
    \   if (i > 0 && (!b || i < *b)) {\n            b = i;\n        }\n    }\n   \
    \ return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value())\n    \
    \            a = i;\n        } else {\n            if (!b.has_value() || i < b.value())\n\
    \                b = i;\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "  std::optional<long>\
    \ a;\n  std::optional<long> b;\n  for (auto i : lst) {\n    if (i < 0) {\n   \
    \   if (!a.has_value() || i > a.value()) {\n        a = i;\n      }\n    } else\
    \ {\n      if (!b.has_value() || i < b.value()) {\n        b = i;\n      }\n \
    \   }\n  }\n  return std::make_tuple(a, b);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i > 0) {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        } else {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0 && (!largest_negative || i > *largest_negative))\
    \ {\n            largest_negative = i;\n        }\n        if (i > 0 && (!smallest_positive\
    \ || i < *smallest_positive)) {\n            smallest_positive = i;\n        }\n\
    \    }\n    return {largest_negative, smallest_positive};", "    std::optional<long>\
    \ largest_negative = std::nullopt;\n    std::optional<long> smallest_positive\
    \ = std::nullopt;\n    for (auto i : lst) {\n        if (i < 0) {\n          \
    \  if (!largest_negative.has_value() || i > largest_negative.value()) {\n    \
    \            largest_negative = i;\n            }\n        } else {\n        \
    \    if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative = std::nullopt;\n    std::optional<long> smallest_positive\
    \ = std::nullopt;\n    for (auto i : lst) {\n        if (i < 0) {\n          \
    \  if (!largest_negative.has_value() || i > largest_negative.value()) {\n    \
    \            largest_negative = i;\n            }\n        } else {\n        \
    \    if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "\tstd::optional<long>\
    \ a, b;\n\tfor (auto i : lst) {\n\t\tif (i < 0 && (!a.has_value() || i > *a))\
    \ {\n\t\t\ta = i;\n\t\t}\n\t\tif (i > 0 && (!b.has_value() || i < *b)) {\n\t\t\
    \tb = i;\n\t\t}\n\t}\n\treturn {a, b};", "    std::optional<long> a, b;\n    for\
    \ (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i\
    \ > a.value()) {\n                a = i;\n            }\n        } else {\n  \
    \          if (!b.has_value() || i < b.value()) {\n                b = i;\n  \
    \          }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ a;\n    std::optional<long> b;\n    for (auto i : lst) {\n        if (i < 0)\
    \ {\n            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "  std::optional<long> a, b;\n  for (auto i : lst) {\n    if (i < 0) {\n\
    \      if (!a.has_value() || i > a.value()) {\n        a = i;\n      }\n    }\
    \ else {\n      if (!b.has_value() || i < b.value()) {\n        b = i;\n     \
    \ }\n    }\n  }\n  return std::make_tuple(a, b);", "    std::optional<long> a,\
    \ b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || largest_negative.value() < i) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || smallest_positive.value() > i) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n     \
    \       if (a == std::nullopt) {\n                a = lst[i];\n            } else\
    \ if (lst[i] > *a) {\n                a = lst[i];\n            }\n        } else\
    \ if (lst[i] > 0) {\n            if (b == std::nullopt) {\n                b =\
    \ lst[i];\n            } else if (lst[i] < *b) {\n                b = lst[i];\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> max_neg, min_pos;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!max_neg || i > *max_neg)\
    \ {\n                max_neg = i;\n            }\n        } else {\n         \
    \   if (!min_pos || i < *min_pos) {\n                min_pos = i;\n          \
    \  }\n        }\n    }\n    return {max_neg, min_pos};", "    std::optional<long>\
    \ a;\n    std::optional<long> b;\n    for (auto i : lst) {\n        if (i < 0)\
    \ {\n            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!a.has_value() || i > a.value()) {\n               \
    \ a = i;\n            }\n        } else {\n            if (!b.has_value() || i\
    \ < b.value()) {\n                b = i;\n            }\n        }\n    }\n  \
    \  return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n    std::optional<long> a, b;\n    for (auto i : lst) {\n        if\
    \ (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n            \
    \    a = i;\n            }\n        } else {\n            if (!b.has_value() ||\
    \ i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    result = std::make_tuple(a, b);\n    return result;", "    std::optional<long>\
    \ largestNegative;\n    std::optional<long> smallestPositive;\n    for (auto i\
    \ : lst) {\n        if (i < 0) {\n            if (!largestNegative.has_value()\
    \ || i > largestNegative.value()) {\n                largestNegative = i;\n  \
    \          }\n        } else {\n            if (!smallestPositive.has_value()\
    \ || i < smallestPositive.value()) {\n                smallestPositive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largestNegative,\
    \ smallestPositive);", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n    std::optional<long> a, b;\n    for (auto i : lst) {\n        if\
    \ (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n            \
    \    a = i;\n            }\n        } else {\n            if (!b.has_value() ||\
    \ i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    std::get<0>(result) = a;\n    std::get<1>(result) = b;\n    return result;",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return {a, b};",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::tuple<std::optional<long>, std::optional<long>> result;\n  \
    \  std::optional<long> a, b;\n    for (long i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else if (i > 0) {\n            if (!b.has_value() ||\
    \ i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    result = std::make_tuple(a, b);\n    return result;", "  std::optional<long>\
    \ a;\n  std::optional<long> b;\n  for (auto i : lst) {\n    if (i < 0 && (!a.has_value()\
    \ || i > *a)) {\n      a = i;\n    }\n    if (i > 0 && (!b.has_value() || i <\
    \ *b)) {\n      b = i;\n    }\n  }\n  return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i: lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    long max_neg = LONG_MIN;\n    long min_pos = LONG_MAX;\n\
    \    bool has_neg = false;\n    bool has_pos = false;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            has_neg = true;\n            if (i > max_neg)\
    \ {\n                max_neg = i;\n            }\n        } else if (i > 0) {\n\
    \            has_pos = true;\n            if (i < min_pos) {\n               \
    \ min_pos = i;\n            }\n        }\n    }\n    if (has_neg && has_pos) {\n\
    \        return std::make_tuple(max_neg, min_pos);\n    } else if (has_neg) {\n\
    \        return std::make_tuple(max_neg, std::nullopt);\n    } else if (has_pos)\
    \ {\n        return std::make_tuple(std::nullopt, min_pos);\n    } else {\n  \
    \      return std::make_tuple(std::nullopt, std::nullopt);\n    }", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0 && (largest_negative == std::nullopt || i > *largest_negative))\
    \ {\n            largest_negative = i;\n        }\n        if (i > 0 && (smallest_positive\
    \ == std::nullopt || i < *smallest_positive)) {\n            smallest_positive\
    \ = i;\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return {a, b};",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return {a, b};",
  "    std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n    std::optional<long> a, b;\n    for (auto i\
    \ : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    result = std::make_tuple(a, b);\n    return result;", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> max_neg;\n    std::optional<long>\
    \ min_pos;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!max_neg.has_value()\
    \ || i > max_neg.value()) {\n                max_neg = i;\n            }\n   \
    \     } else {\n            if (!min_pos.has_value() || i < min_pos.value()) {\n\
    \                min_pos = i;\n            }\n        }\n    }\n    return std::make_tuple(max_neg,\
    \ min_pos);", "\tlong max_neg = INT_MIN;\n\tlong min_pos = INT_MAX;\n\tfor (int\
    \ i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] < 0) {\n\t\t\tmax_neg = std::max(max_neg,\
    \ lst[i]);\n\t\t}\n\t\telse {\n\t\t\tmin_pos = std::min(min_pos, lst[i]);\n\t\t\
    }\n\t}\n\tif (max_neg == INT_MIN && min_pos == INT_MAX) {\n\t\treturn { std::nullopt,\
    \ std::nullopt };\n\t}\n\telse if (max_neg == INT_MIN) {\n\t\treturn { std::nullopt,\
    \ min_pos };\n\t}\n\telse if (min_pos == INT_MAX) {\n\t\treturn { max_neg, std::nullopt\
    \ };\n\t}\n\telse {\n\t\treturn { max_neg, min_pos };\n\t}", "    std::optional<long>\
    \ a, b;\n    for (auto x : lst) {\n        if (x < 0) {\n            if (!a.has_value()\
    \ || x > *a) {\n                a = x;\n            }\n        } else {\n    \
    \        if (!b.has_value() || x < *b) {\n                b = x;\n           \
    \ }\n        }\n    }\n    return {a, b};", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0 && (!a || i > *a)) {\n            a = i;\n        }\n \
    \       if (i > 0 && (!b || i < *b)) {\n            b = i;\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (long i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto x : lst) {\n\
    \        if (x < 0) {\n            if (!a.has_value() || x > *a) {\n         \
    \       a = x;\n            }\n        } else {\n            if (!b.has_value()\
    \ || x < *b) {\n                b = x;\n            }\n        }\n    }\n    return\
    \ {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n       \
    \ if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n         \
    \       a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i > 0) {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        } else if\
    \ (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n            \
    \    a = i;\n            }\n        }\n    }\n    return std::make_tuple(a, b);",
  "    std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i: lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> t;\n    std::optional<long> a, b;\n    for (int i = 0;\
    \ i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            if (a.has_value())\
    \ {\n                if (lst[i] > a.value()) {\n                    a = lst[i];\n\
    \                }\n            } else {\n                a = lst[i];\n      \
    \      }\n        } else {\n            if (b.has_value()) {\n               \
    \ if (lst[i] < b.value()) {\n                    b = lst[i];\n               \
    \ }\n            } else {\n                b = lst[i];\n            }\n      \
    \  }\n    }\n    std::get<0>(t) = a;\n    std::get<1>(t) = b;\n    return t;",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return {a, b};",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i\
    \ < 0 && (!a || i > *a)) {\n            a = i;\n        }\n        if (i > 0 &&\
    \ (!b || i < *b)) {\n            b = i;\n        }\n    }\n    return {a, b};",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "  std::optional<long> a, b;\n  for (auto\
    \ i : lst) {\n    if (i < 0) {\n      if (!a.has_value() || i > a.value()) {\n\
    \        a = i;\n      }\n    } else {\n      if (!b.has_value() || i < b.value())\
    \ {\n        b = i;\n      }\n    }\n  }\n  return std::make_tuple(a, b);", " \
    \   std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0 && (!a || i > *a)) {\n  \
    \          a = i;\n        }\n        if (i > 0 && (!b || i < *b)) {\n       \
    \     b = i;\n        }\n    }\n    return {a, b};", "    std::optional<long>\
    \ a;\n    std::optional<long> b;\n    for (auto i : lst) {\n        if (i < 0)\
    \ {\n            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a;\n    std::optional<long> b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "\tstd::optional<long> a, b;\n\tfor (auto i : lst) {\n\
    \t\tif (i < 0) {\n\t\t\tif (!a.has_value() || i > a.value()) {\n\t\t\t\ta = i;\n\
    \t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!b.has_value() || i < b.value()) {\n\t\t\
    \t\tb = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> largest_neg = std::nullopt;\n\
    \    std::optional<long> smallest_pos = std::nullopt;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!largest_neg.has_value() || i > largest_neg.value())\
    \ {\n                largest_neg = i;\n            }\n        } else {\n     \
    \       if (!smallest_pos.has_value() || i < smallest_pos.value()) {\n       \
    \         smallest_pos = i;\n            }\n        }\n    }\n    return std::make_tuple(largest_neg,\
    \ smallest_pos);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "\tstd::optional<long> largest_neg;\n\tstd::optional<long>\
    \ smallest_pos;\n\tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (!largest_neg.has_value())\
    \ {\n\t\t\t\tlargest_neg = i;\n\t\t\t}\n\t\t\telse if (i > largest_neg.value())\
    \ {\n\t\t\t\tlargest_neg = i;\n\t\t\t}\n\t\t}\n\t\telse if (i > 0) {\n\t\t\tif\
    \ (!smallest_pos.has_value()) {\n\t\t\t\tsmallest_pos = i;\n\t\t\t}\n\t\t\telse\
    \ if (i < smallest_pos.value()) {\n\t\t\t\tsmallest_pos = i;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn std::make_tuple(largest_neg, smallest_pos);", "    std::optional<long>\
    \ a;\n    std::optional<long> b;\n    for (long i : lst) {\n        if (i < 0)\
    \ {\n            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a;\n    std::optional<long> b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n    std::optional<long> a;\n    std::optional<long> b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (a.has_value()) {\n       \
    \         if (i > a.value()) {\n                    a = i;\n                }\n\
    \            } else {\n                a = i;\n            }\n        } else {\n\
    \            if (b.has_value()) {\n                if (i < b.value()) {\n    \
    \                b = i;\n                }\n            } else {\n           \
    \     b = i;\n            }\n        }\n    }\n    std::get<0>(result) = a;\n\
    \    std::get<1>(result) = b;\n    return result;", "    std::optional<long> a,\
    \ b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a) {\n\
    \                a = i;\n            } else {\n                a = std::max(a.value(),\
    \ i);\n            }\n        } else if (i > 0) {\n            if (!b) {\n   \
    \             b = i;\n            } else {\n                b = std::min(b.value(),\
    \ i);\n            }\n        }\n    }\n    return std::make_tuple(a, b);", " \
    \   std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (int i = 0; i\
    \ < lst.size(); i++) {\n        if (lst[i] < 0) {\n            if (!a.has_value())\
    \ {\n                a = lst[i];\n            } else {\n                if (lst[i]\
    \ > a.value()) {\n                    a = lst[i];\n                }\n       \
    \     }\n        } else {\n            if (!b.has_value()) {\n               \
    \ b = lst[i];\n            } else {\n                if (lst[i] < b.value()) {\n\
    \                    b = lst[i];\n                }\n            }\n        }\n\
    \    }\n    return std::make_tuple(a, b);", "\tstd::optional<long> a, b;\n\tfor\
    \ (auto x : lst) {\n\t\tif (x < 0) {\n\t\t\tif (!a.has_value() || x > a.value())\
    \ {\n\t\t\t\ta = x;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!b.has_value() || x\
    \ < b.value()) {\n\t\t\t\tb = x;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(a,\
    \ b);", "    std::tuple<std::optional<long>, std::optional<long>> result;\n  \
    \  std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    result = std::make_tuple(a,\
    \ b);\n    return result;", "    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "  std::optional<long> a;\n  std::optional<long> b;\n\
    \  for (auto i: lst) {\n    if (i < 0) {\n      if (!a) {\n        a = i;\n  \
    \    } else {\n        a = std::max(a.value(), i);\n      }\n    } else if (i\
    \ > 0) {\n      if (!b) {\n        b = i;\n      } else {\n        b = std::min(b.value(),\
    \ i);\n      }\n    }\n  }\n  return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a;\n    std::optional<long> b;\n    for (auto i : lst) {\n        if (i < 0)\
    \ {\n            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "\tstd::optional<long> a;\n\tstd::optional<long>\
    \ b;\n\tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (a.has_value()) {\n\t\
    \t\t\tif (i > a.value()) {\n\t\t\t\t\ta = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\
    \t\t\t\ta = i;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (b.has_value()) {\n\t\t\t\
    \tif (i < b.value()) {\n\t\t\t\t\tb = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\
    \t\t\tb = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative) {\n   \
    \             largest_negative = i;\n            } else if (i > *largest_negative)\
    \ {\n                largest_negative = i;\n            }\n        } else if (i\
    \ > 0) {\n            if (!smallest_positive) {\n                smallest_positive\
    \ = i;\n            } else if (i < *smallest_positive) {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "  std::optional<long> a, b;\n  for (auto\
    \ i : lst) {\n    if (i < 0) {\n      if (!a.has_value() || i > a.value()) {\n\
    \        a = i;\n      }\n    } else {\n      if (!b.has_value() || i < b.value())\
    \ {\n        b = i;\n      }\n    }\n  }\n  return std::make_tuple(a, b);", " \
    \   std::optional<long> smallest_positive;\n    std::optional<long> largest_negative;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "  std::optional<long>\
    \ a;\n  std::optional<long> b;\n  for (auto i : lst) {\n    if (i < 0) {\n   \
    \   if (!a.has_value() || i > a.value()) {\n        a = i;\n      }\n    } else\
    \ {\n      if (!b.has_value() || i < b.value()) {\n        b = i;\n      }\n \
    \   }\n  }\n  return std::make_tuple(a, b);", "    std::optional<long> a, b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n    std::optional<long> a;\n    std::optional<long>\
    \ b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (a.has_value())\
    \ {\n                if (i > a.value()) {\n                    a = i;\n      \
    \          }\n            } else {\n                a = i;\n            }\n  \
    \      } else {\n            if (b.has_value()) {\n                if (i < b.value())\
    \ {\n                    b = i;\n                }\n            } else {\n   \
    \             b = i;\n            }\n        }\n    }\n    result = std::make_tuple(a,\
    \ b);\n    return result;", "    std::optional<long> max_neg, min_pos;\n    for\
    \ (auto i : lst) {\n        if (i < 0 && (!max_neg || i > *max_neg)) {\n     \
    \       max_neg = i;\n        }\n        if (i > 0 && (!min_pos || i < *min_pos))\
    \ {\n            min_pos = i;\n        }\n    }\n    return {max_neg, min_pos};",
  "    std::optional<long> largest_negative;\n    std::optional<long> smallest_positive;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else {\n     \
    \       if (!smallest_positive.has_value() || i < smallest_positive.value()) {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return std::make_tuple(largest_negative, smallest_positive);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n    std::optional<long> a;\n    std::optional<long>\
    \ b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (a.has_value())\
    \ {\n                if (i > a.value()) {\n                    a = i;\n      \
    \          }\n            } else {\n                a = i;\n            }\n  \
    \      } else {\n            if (b.has_value()) {\n                if (i < b.value())\
    \ {\n                    b = i;\n                }\n            } else {\n   \
    \             b = i;\n            }\n        }\n    }\n    result = std::make_tuple(a,\
    \ b);\n    return result;", "    std::optional<long> a, b;\n    for (auto i :\
    \ lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    long max_neg = INT_MIN;\n    long min_pos\
    \ = INT_MAX;\n    bool neg = false;\n    bool pos = false;\n    for (long i :\
    \ lst) {\n        if (i < 0) {\n            neg = true;\n            if (i > max_neg)\
    \ {\n                max_neg = i;\n            }\n        }\n        if (i > 0)\
    \ {\n            pos = true;\n            if (i < min_pos) {\n               \
    \ min_pos = i;\n            }\n        }\n    }\n    std::optional<long> a;\n\
    \    std::optional<long> b;\n    if (neg) {\n        a = max_neg;\n    }\n   \
    \ if (pos) {\n        b = min_pos;\n    }\n    return std::make_tuple(a, b);",
  "    std::optional<long> a;\n    std::optional<long> b;\n    for (long i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "\tstd::optional<long> a, b;\n\tfor (auto\
    \ i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (!a) {\n\t\t\t\ta = i;\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\tif (i > *a) {\n\t\t\t\t\ta = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\telse {\n\t\t\tif (!b) {\n\t\t\t\tb = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif\
    \ (i < *b) {\n\t\t\t\t\tb = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(a,\
    \ b);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!a.has_value() || i > a.value()) {\n               \
    \ a = i;\n            }\n        } else {\n            if (!b.has_value() || i\
    \ < b.value()) {\n                b = i;\n            }\n        }\n    }\n  \
    \  return std::make_tuple(a, b);", "\tstd::optional<long> a;\n\tstd::optional<long>\
    \ b;\n\tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (a.has_value()) {\n\t\
    \t\t\tif (i > a.value()) {\n\t\t\t\t\ta = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\
    \t\t\t\ta = i;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (b.has_value()) {\n\t\t\t\
    \tif (i < b.value()) {\n\t\t\t\t\tb = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\
    \t\t\tb = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative) {\n   \
    \             largest_negative = i;\n            } else if (i > *largest_negative)\
    \ {\n                largest_negative = i;\n            }\n        } else if (i\
    \ > 0) {\n            if (!smallest_positive) {\n                smallest_positive\
    \ = i;\n            } else if (i < *smallest_positive) {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a;\n    std::optional<long> b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n    std::optional<long> a;\n    std::optional<long>\
    \ b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (a) {\n \
    \               if (i > *a) {\n                    a = i;\n                }\n\
    \            } else {\n                a = i;\n            }\n        } else {\n\
    \            if (b) {\n                if (i < *b) {\n                    b =\
    \ i;\n                }\n            } else {\n                b = i;\n      \
    \      }\n        }\n    }\n    result = std::make_tuple(a, b);\n    return result;",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!a.has_value() || i > a.value()) {\n               \
    \ a = i;\n            }\n        } else {\n            if (!b.has_value() || i\
    \ < b.value()) {\n                b = i;\n            }\n        }\n    }\n  \
    \  return std::make_tuple(a, b);", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n    std::optional<long> largest_negative;\n    std::optional<long>\
    \ smallest_positive;\n    for (auto i : lst) {\n        if (i < 0) {\n       \
    \     if (!largest_negative.has_value() || i > largest_negative.value()) {\n \
    \               largest_negative = i;\n            }\n        } else if (i > 0)\
    \ {\n            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    std::get<0>(result) = largest_negative;\n    std::get<1>(result) = smallest_positive;\n\
    \    return result;", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ tup;\n    std::optional<long> a, b;\n    for (int i = 0; i < lst.size(); i++)\
    \ {\n        if (lst[i] < 0) {\n            if (a == std::nullopt) {\n       \
    \         a = lst[i];\n            } else if (lst[i] > *a) {\n               \
    \ a = lst[i];\n            }\n        } else if (lst[i] > 0) {\n            if\
    \ (b == std::nullopt) {\n                b = lst[i];\n            } else if (lst[i]\
    \ < *b) {\n                b = lst[i];\n            }\n        }\n    }\n    tup\
    \ = std::make_tuple(a, b);\n    return tup;", "    std::optional<long> a, b;\n\
    \    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> maxNegative, minPositive;\n \
    \   for (auto i : lst) {\n        if (i < 0) {\n            if (!maxNegative.has_value()\
    \ || i > maxNegative.value()) {\n                maxNegative = i;\n          \
    \  }\n        } else {\n            if (!minPositive.has_value() || i < minPositive.value())\
    \ {\n                minPositive = i;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(maxNegative, minPositive);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "  std::optional<long>\
    \ largest_negative;\n  std::optional<long> smallest_positive;\n  for (auto i :\
    \ lst) {\n    if (i < 0) {\n      if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n        largest_negative = i;\n      }\n    } else {\n      if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n        smallest_positive = i;\n      }\n\
    \    }\n  }\n  return std::make_tuple(largest_negative, smallest_positive);",
  "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n\
    \            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!a.has_value() || i > a.value()) {\n               \
    \ a = i;\n            }\n        } else {\n            if (!b.has_value() || i\
    \ < b.value()) {\n                b = i;\n            }\n        }\n    }\n  \
    \  return std::make_tuple(a, b);", "    std::optional<long> largestNegative;\n\
    \    std::optional<long> smallestPositive;\n    for (auto i : lst) {\n       \
    \ if (i < 0) {\n            if (!largestNegative.has_value() || i > largestNegative.value())\
    \ {\n                largestNegative = i;\n            }\n        } else {\n \
    \           if (!smallestPositive.has_value() || i < smallestPositive.value())\
    \ {\n                smallestPositive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largestNegative, smallestPositive);", "  std::optional<long>\
    \ largest_negative;\n  std::optional<long> smallest_positive;\n  for (auto i :\
    \ lst) {\n    if (i < 0) {\n      if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n        largest_negative = i;\n      }\n    } else {\n      if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n        smallest_positive = i;\n      }\n\
    \    }\n  }\n  return std::make_tuple(largest_negative, smallest_positive);",
  "    std::optional<long> largest_neg, smallest_pos;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!largest_neg.has_value() || i > largest_neg.value())\
    \ {\n                largest_neg = i;\n            }\n        } else {\n     \
    \       if (!smallest_pos.has_value() || i < smallest_pos.value()) {\n       \
    \         smallest_pos = i;\n            }\n        }\n    }\n    return std::make_tuple(largest_neg,\
    \ smallest_pos);", "\tstd::tuple<std::optional<long>, std::optional<long>> result;\n\
    \tstd::optional<long> largest_neg;\n\tstd::optional<long> smallest_pos;\n\tfor\
    \ (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (!largest_neg.has_value()) {\n\t\
    \t\t\tlargest_neg = i;\n\t\t\t}\n\t\t\telse if (i > largest_neg.value()) {\n\t\
    \t\t\tlargest_neg = i;\n\t\t\t}\n\t\t}\n\t\telse if (i > 0) {\n\t\t\tif (!smallest_pos.has_value())\
    \ {\n\t\t\t\tsmallest_pos = i;\n\t\t\t}\n\t\t\telse if (i < smallest_pos.value())\
    \ {\n\t\t\t\tsmallest_pos = i;\n\t\t\t}\n\t\t}\n\t}\n\tstd::get<0>(result) = largest_neg;\n\
    \tstd::get<1>(result) = smallest_pos;\n\treturn result;", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a;\n    std::optional<long> b;\n    for (auto i : lst) {\n        if (i < 0)\
    \ {\n            if (!a.has_value() || i > a.value()) {\n                a = i;\n\
    \            }\n        } else {\n            if (!b.has_value() || i < b.value())\
    \ {\n                b = i;\n            }\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "    std::optional<long> a, b;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!a.has_value() || i > a.value()) {\n               \
    \ a = i;\n            }\n        } else {\n            if (!b.has_value() || i\
    \ < b.value()) {\n                b = i;\n            }\n        }\n    }\n  \
    \  return std::make_tuple(a, b);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative) {\n                largest_negative\
    \ = i;\n            } else if (i > *largest_negative) {\n                largest_negative\
    \ = i;\n            }\n        } else if (i > 0) {\n            if (!smallest_positive)\
    \ {\n                smallest_positive = i;\n            } else if (i < *smallest_positive)\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ largest_negative, smallest_positive;\n    for (auto i : lst) {\n        if (i\
    \ < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ a, b;\n    for (long i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> a, b;\n    for (auto i : lst) {\n\
    \        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n  \
    \              a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::tuple<std::optional<long>, std::optional<long>>\
    \ result;\n    std::optional<long> a, b;\n    for (auto i : lst) {\n        if\
    \ (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n            \
    \    a = i;\n            }\n        } else {\n            if (!b.has_value() ||\
    \ i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    result = std::make_tuple(a, b);\n    return result;", "    std::optional<long>\
    \ largest_negative;\n    std::optional<long> smallest_positive;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!largest_negative.has_value()\
    \ || i > largest_negative.value()) {\n                largest_negative = i;\n\
    \            }\n        } else {\n            if (!smallest_positive.has_value()\
    \ || i < smallest_positive.value()) {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(largest_negative,\
    \ smallest_positive);", "    std::optional<long> a, b;\n    for (auto i : lst)\
    \ {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value()) {\n\
    \                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(a, b);", "    std::optional<long> a, b;\n    for (auto\
    \ i : lst) {\n        if (i < 0) {\n            if (!a.has_value() || i > a.value())\
    \ {\n                a = i;\n            }\n        } else {\n            if (!b.has_value()\
    \ || i < b.value()) {\n                b = i;\n            }\n        }\n    }\n\
    \    return {a, b};", "    std::optional<long> largest;\n    std::optional<long>\
    \ smallest;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!largest.has_value()\
    \ || i > largest.value()) {\n                largest = i;\n            }\n   \
    \     } else {\n            if (!smallest.has_value() || i < smallest.value())\
    \ {\n                smallest = i;\n            }\n        }\n    }\n    return\
    \ std::make_tuple(largest, smallest);", "    std::optional<long> largest_negative;\n\
    \    std::optional<long> smallest_positive;\n    for (auto i : lst) {\n      \
    \  if (i < 0) {\n            if (!largest_negative.has_value() || i > largest_negative.value())\
    \ {\n                largest_negative = i;\n            }\n        } else {\n\
    \            if (!smallest_positive.has_value() || i < smallest_positive.value())\
    \ {\n                smallest_positive = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(largest_negative, smallest_positive);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "    std::vector<long>\
    \ pos, neg;\n    for (auto i : lst) {\n        if (i < 0) {\n            neg.push_back(i);\n\
    \        } else {\n            pos.push_back(i);\n        }\n    }\n    std::optional<long>\
    \ a, b;\n    if (neg.size() > 0) {\n        a = *std::max_element(neg.begin(),\
    \ neg.end());\n    }\n    if (pos.size() > 0) {\n        b = *std::min_element(pos.begin(),\
    \ pos.end());\n    }\n    return std::make_tuple(a, b);", "    std::optional<long>\
    \ a, b;\n    for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);", "\tstd::tuple<std::optional<long>,\
    \ std::optional<long>> result;\n\tstd::optional<long> largest_negative;\n\tstd::optional<long>\
    \ smallest_positive;\n\tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (!largest_negative.has_value())\
    \ {\n\t\t\t\tlargest_negative = i;\n\t\t\t}\n\t\t\telse if (i > largest_negative.value())\
    \ {\n\t\t\t\tlargest_negative = i;\n\t\t\t}\n\t\t}\n\t\telse if (i > 0) {\n\t\t\
    \tif (!smallest_positive.has_value()) {\n\t\t\t\tsmallest_positive = i;\n\t\t\t\
    }\n\t\t\telse if (i < smallest_positive.value()) {\n\t\t\t\tsmallest_positive\
    \ = i;\n\t\t\t}\n\t\t}\n\t}\n\tstd::get<0>(result) = largest_negative;\n\tstd::get<1>(result)\
    \ = smallest_positive;\n\treturn result;", "    std::optional<long> a, b;\n  \
    \  for (auto i : lst) {\n        if (i < 0) {\n            if (!a.has_value()\
    \ || i > a.value()) {\n                a = i;\n            }\n        } else {\n\
    \            if (!b.has_value() || i < b.value()) {\n                b = i;\n\
    \            }\n        }\n    }\n    return std::make_tuple(a, b);"]
stop_tokens:
- "\n}"
