language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int i = len - 1;\n    while(i >=\
    \ 0) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            if(i != len - 1 && word[i + 1] != 'a'\
    \ && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i\
    \ + 1] != 'u') {\n                return word.substr(i, 1);\n            }\n \
    \       }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpknhz7jbm: /tmp/tmpknhz7jbm.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    if (i - j < min_distance) {\n \
    \                       min_distance = i - j;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo_l5xgji: /tmp/tmpo_l5xgji.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    std::string vowels = \"aeiou\";\n    int\
    \ closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n                closest_vowel_distance = word.size() - i;\n          \
    \  } else {\n                if (i < closest_vowel_index) {\n                \
    \    closest_vowel_index = i;\n                    closest_vowel_distance = word.size()\
    \ - i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = closest_vowel_index\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            if (closest_vowel_index - i < closest_vowel_distance) {\n   \
    \             closest_vowel_distance = closest_vowel_index - i;\n            }\n\
    \        }\n    }\n    return word.substr(closest_vowel_index, closest_vowel_distance);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprj50zqur: /tmp/tmprj50zqur.cpp:41: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    distance = i - j;\n           \
    \         if (distance < min_distance) {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                    break;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmputoi2e0g: /tmp/tmputoi2e0g.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            if (index\
    \ == -1) {\n                index = i;\n            } else {\n               \
    \ if (index - i == 1) {\n                    result = word[index];\n         \
    \           break;\n                } else {\n                    index = i;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpsq0blbfg: /tmp/tmpsq0blbfg.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    int min_distance\
    \ = INT_MAX;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int distance = word.size() - i;\n     \
    \       if (distance < min_distance) {\n                min_distance = distance;\n\
    \                index = i;\n            }\n        }\n    }\n    if (index ==\
    \ -1) {\n        return \"\";\n    }\n    return word.substr(index, 1);\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8u8rha7n: /tmp/tmp8u8rha7n.cpp:31: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            distance = 0;\n            for (int j = i - 1; j >= 0; j--) {\n\
    \                if (vowels.find(word[j]) != std::string::npos) {\n          \
    \          break;\n                }\n                distance++;\n          \
    \  }\n            if (distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpt88819o3: /tmp/tmpt88819o3.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    int last_vowel_index\
    \ = -1;\n    int last_consonant_index = -1;\n    int vowel_index = -1;\n    int\
    \ consonant_index = -1;\n    for (int i = 0; i < word.length(); i++) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            vowel_index\
    \ = i;\n            if (last_consonant_index != -1) {\n                distance\
    \ = vowel_index - last_consonant_index;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[vowel_index];\n                }\n            }\n            last_vowel_index\
    \ = vowel_index;\n        } else {\n            consonant_index = i;\n       \
    \     if (last_vowel_index != -1) {\n                distance = consonant_index\
    \ - last_vowel_index;\n                if (distance < min_distance) {\n      \
    \              min_distance = distance;\n                    result = word[last_vowel_index];\n\
    \                }\n            }\n            last_consonant_index = consonant_index;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpek7cqpq0: /tmp/tmpek7cqpq0.cpp:45: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) {\n                return\
    \ \"\";\n            }\n            if (word[i + 1] != 'a' && word[i + 1] != 'e'\
    \ && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u') {\n     \
    \           return word.substr(i, 1);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpex0h5la1: /tmp/tmpex0h5la1.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) return \"\";\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            return word.substr(index,\
    \ 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo6zs2h65: /tmp/tmpo6zs2h65.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmu698_c7: /tmp/tmpmu698_c7.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) return \"\";\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_rnoufdm: /tmp/tmp_rnoufdm.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int pos = word.length() - 1;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            result = word[pos];\n            break;\n\
    \        }\n        pos--;\n    }\n    if (pos == 0) {\n        return \"\";\n\
    \    }\n    pos--;\n    while (pos >= 0) {\n        if (vowels.find(word[pos])\
    \ != std::string::npos) {\n            if (result.length() == 0) {\n         \
    \       result = word[pos];\n            } else {\n                if (pos > word.length()\
    \ - pos) {\n                    result = word[pos];\n                }\n     \
    \       }\n        }\n        pos--;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxaeupq48: /tmp/tmpxaeupq48.cpp:42: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n\tstd::string vowels = \"aeiou\";\n\tstd::string result = \"\";\n\t\
    int index = word.size() - 1;\n\twhile (index >= 0) {\n\t\tif (vowels.find(word[index])\
    \ != std::string::npos) {\n\t\t\tresult = word[index];\n\t\t\tbreak;\n\t\t}\n\t\
    \tindex--;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcosq18ht: /tmp/tmpcosq18ht.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.size() - 1;\n\
    \    while (pos > 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (vowels.find(word[pos - 1]) == std::string::npos) {\n    \
    \            return word.substr(pos, 1);\n            }\n        }\n        pos--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjp02jt7i: /tmp/tmpjp02jt7i.cpp:28: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            return word.substr(i, 1);\n        }\n        i--;\n    }\n \
    \   return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n \
    \   assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpub06ai7y: /tmp/tmpub06ai7y.cpp:23: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                int distance = closest_vowel_index\
    \ - i;\n                if (distance < closest_vowel_distance) {\n           \
    \         closest_vowel_distance = distance;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpti96zyo1: /tmp/tmpti96zyo1.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            int j =\
    \ i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int k = i + 1;\n                while (k < word.size() && vowels.find(word[k])\
    \ != std::string::npos) {\n                    k++;\n                }\n     \
    \           if (k < word.size()) {\n                    if (k - i < distance)\
    \ {\n                        distance = k - i;\n                        result\
    \ = word[i];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgxhq641g: /tmp/tmpgxhq641g.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int i = len - 1;\n    while(i >=\
    \ 0) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            return word.substr(i, 1);\n       \
    \ }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8u2fq4l0: /tmp/tmp8u2fq4l0.cpp:24: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    int last_vowel_index\
    \ = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            last_vowel_index = i;\n            break;\n\
    \        }\n    }\n    if (last_vowel_index == -1) {\n        return result;\n\
    \    }\n    for (int i = last_vowel_index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            distance = last_vowel_index - i;\n    \
    \        if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo62hkf9c: /tmp/tmpo62hkf9c.cpp:37: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmu698_c7: /tmp/tmpmu698_c7.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            if (index > 0 && vowels.find(word[index\
    \ - 1]) == std::string::npos) {\n                result = word[index];\n     \
    \           break;\n            }\n            if (index < word.size() - 1 &&\
    \ vowels.find(word[index + 1]) == std::string::npos) {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpppk1psf2: /tmp/tmpppk1psf2.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int distance = word.size();\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   if (i + 1 < word.size() && vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                if (i + 1 < distance) {\n                    distance = i\
    \ + 1;\n                    result = word[i];\n                }\n           \
    \ }\n            if (i - 1 >= 0 && vowels.find(word[i - 1]) == std::string::npos)\
    \ {\n                if (word.size() - i < distance) {\n                    distance\
    \ = word.size() - i;\n                    result = word[i];\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp29gxcr6y: /tmp/tmp29gxcr6y.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                if (closest_vowel_distance > (closest_vowel_index\
    \ - i)) {\n                    closest_vowel_distance = closest_vowel_index -\
    \ i;\n                    closest_vowel_index = i;\n                }\n      \
    \      }\n        }\n    }\n    if (closest_vowel_index == -1) {\n        return\
    \ \"\";\n    }\n    return word.substr(closest_vowel_index, 1);\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf4905zgd: /tmp/tmpf4905zgd.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  std::string result = \"\";\n \
    \ int index = word.size() - 1;\n  while (index >= 0) {\n    if (vowels.find(word[index])\
    \ != std::string::npos) {\n      result = word[index];\n      break;\n    }\n\
    \    index--;\n  }\n  return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9_834kyq: /tmp/tmp9_834kyq.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                int distance = closest_vowel_index\
    \ - i;\n                if (distance < closest_vowel_distance) {\n           \
    \         closest_vowel_distance = distance;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpti96zyo1: /tmp/tmpti96zyo1.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string consonants = \"\
    bcdfghjklmnpqrstvwxyz\";\n    std::string result = \"\";\n    int index = -1;\n\
    \    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) {\n        return result;\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (consonants.find(word[i]) != std::string::npos)\
    \ {\n            result = word[index];\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcqjrql70: /tmp/tmpcqjrql70.cpp:37: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int last_consonant_index = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) ==\
    \ std::string::npos) {\n            last_consonant_index = i;\n            break;\n\
    \        }\n    }\n    if (last_consonant_index == -1) {\n        return result;\n\
    \    }\n    for (int i = last_consonant_index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) != std::string::npos) {\n            int distance = last_consonant_index\
    \ - i;\n            if (distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp2pd0ol1s: /tmp/tmp2pd0ol1s.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) {\n                return\
    \ \"\";\n            }\n            if (word[i + 1] != 'a' && word[i + 1] != 'e'\
    \ && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u') {\n     \
    \           return word.substr(i, 1);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpex0h5la1: /tmp/tmpex0h5la1.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    int last_consonant_index\
    \ = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            distance = last_consonant_index - i;\n\
    \            if (distance > 0 && distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        } else\
    \ {\n            last_consonant_index = i;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpnmesn3nq: /tmp/tmpnmesn3nq.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) {\n        return \"\";\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n\
    \        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(pos, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkhg5_6op: /tmp/tmpkhg5_6op.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (i < closest_vowel_distance) {\n                closest_vowel_distance\
    \ = i;\n                closest_vowel_index = i;\n            }\n        } else\
    \ {\n            if (closest_vowel_index != -1) {\n                return word.substr(closest_vowel_index,\
    \ 1);\n            }\n        }\n    }\n    return \"\";\n}\nint main() {\n  \
    \  auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpu9j3147q: /tmp/tmpu9j3147q.cpp:33: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                int distance = closest_vowel_index\
    \ - i;\n                if (distance < closest_vowel_distance) {\n           \
    \         closest_vowel_distance = distance;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpti96zyo1: /tmp/tmpti96zyo1.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0 &&\
    \ !is_vowel(word[i])) {\n        i--;\n    }\n    if (i == 0) {\n        return\
    \ \"\";\n    }\n    int j = i - 1;\n    while (j >= 0 && is_vowel(word[j])) {\n\
    \        j--;\n    }\n    if (j == -1) {\n        return \"\";\n    }\n    return\
    \ word.substr(i, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpims1aiad.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpims1aiad.cpp:12:23: error: \u2018is_vowel\u2019 was not declared in\
    \ this scope\n   12 |     while (i >= 0 && !is_vowel(word[i])) {\n      |    \
    \                   ^~~~~~~~\n/tmp/tmpims1aiad.cpp:19:22: error: \u2018is_vowel\u2019\
    \ was not declared in this scope\n   19 |     while (j >= 0 && is_vowel(word[j]))\
    \ {\n      |                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    int j = len - 1;\n    while (i >= 0) {\n        if\
    \ (vowels.find(word[i]) != std::string::npos) {\n            if (i == len - 1)\
    \ {\n                i--;\n                continue;\n            }\n        \
    \    if (vowels.find(word[i + 1]) != std::string::npos) {\n                i--;\n\
    \                continue;\n            }\n            j = i;\n            break;\n\
    \        }\n        i--;\n    }\n    if (j == len - 1) {\n        return \"\"\
    ;\n    }\n    return word.substr(j, 1);\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpdrmq911w: /tmp/tmpdrmq911w.cpp:38: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index != -1) {\n                if (i < closest_vowel_index\
    \ && closest_vowel_index - i < closest_vowel_distance) {\n                   \
    \ closest_vowel_distance = closest_vowel_index - i;\n                    closest_vowel_index\
    \ = i;\n                }\n            } else {\n                closest_vowel_index\
    \ = i;\n            }\n        }\n    }\n    if (closest_vowel_index == -1) {\n\
    \        return \"\";\n    }\n    return word.substr(closest_vowel_index, 1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp18vi100m: /tmp/tmp18vi100m.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int closest_vowel_index = -1;\n    int closest_vowel_distance = INT_MAX;\n\
    \    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            for (int j = i - 1; j >= 0; j--) {\n  \
    \              if (vowels.find(word[j]) == std::string::npos) {\n            \
    \        if (i - j < closest_vowel_distance) {\n                        closest_vowel_distance\
    \ = i - j;\n                        closest_vowel_index = i;\n               \
    \     }\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    if (closest_vowel_index != -1) {\n        result = word[closest_vowel_index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp635qc6rd: /tmp/tmp635qc6rd.cpp:38: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmu698_c7: /tmp/tmpmu698_c7.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                int distance = closest_vowel_index\
    \ - i;\n                if (distance < closest_vowel_distance) {\n           \
    \         closest_vowel_distance = distance;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpti96zyo1: /tmp/tmpti96zyo1.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int min_distance = INT_MAX;\n\
    \  char closest_vowel = '\\0';\n  for (int i = 0; i < word.size(); i++) {\n  \
    \  if (vowels.find(word[i]) != std::string::npos) {\n      int distance = word.size()\
    \ - i - 1;\n      if (distance < min_distance) {\n        min_distance = distance;\n\
    \        closest_vowel = word[i];\n      }\n    }\n  }\n  return closest_vowel\
    \ == '\\0' ? \"\" : std::string(1, closest_vowel);\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5dfxquba: /tmp/tmp5dfxquba.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            if (index\
    \ == -1) {\n                index = i;\n            } else {\n               \
    \ if (index - i > 1) {\n                    result = word[i];\n              \
    \      break;\n                }\n            }\n        } else {\n          \
    \  index = -1;\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpbcfl3gar: /tmp/tmpbcfl3gar.cpp:31: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) return \"\";\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_rnoufdm: /tmp/tmp_rnoufdm.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    int last_consonant_index\
    \ = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            distance = last_consonant_index - i;\n\
    \            if (distance > 0 && distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        } else\
    \ {\n            last_consonant_index = i;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpnmesn3nq: /tmp/tmpnmesn3nq.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string consonants = \"\
    bcdfghjklmnpqrstvwxyz\";\n    int index = -1;\n    int min_distance = INT_MAX;\n\
    \    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            int distance = 0;\n            for (int\
    \ j = i + 1; j < word.size(); j++) {\n                if (consonants.find(word[j])\
    \ != std::string::npos) {\n                    distance = j - i;\n           \
    \         break;\n                }\n            }\n            if (distance <\
    \ min_distance) {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if (index == -1) {\n        return\
    \ \"\";\n    }\n    return word.substr(index, 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5advuthg: /tmp/tmp5advuthg.cpp:36: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == len - 1) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd7iwbhc5: /tmp/tmpd7iwbhc5.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = 0;\n    int min_index = word.size();\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            if (index - min_index > 1) {\n      \
    \          return result;\n            }\n            result = word[i];\n    \
    \    } else {\n            min_index = std::min(min_index, index);\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpch58d63m: /tmp/tmpch58d63m.cpp:29: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        for (int j = 0; j < vowels.size(); j++) {\n            if (word[i]\
    \ == vowels[j]) {\n                int distance = word.size() - i - 1;\n     \
    \           if (distance < min_distance) {\n                    min_distance =\
    \ distance;\n                    result = word[i];\n                }\n      \
    \      }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp25nezpen: /tmp/tmp25nezpen.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int i = word.size() - 1;\n\
    \    while (i >= 0) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word[i];\n        }\n        i--;\n    }\n    return \"\
    \";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprkop0zdt.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmprkop0zdt.cpp:14:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   14 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660077989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmu698_c7: /tmp/tmpmu698_c7.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    distance = i - j;\n           \
    \         if (distance < min_distance) {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                    break;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmputoi2e0g: /tmp/tmputoi2e0g.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n \
    \           break;\n        }\n    }\n    if (pos == -1) return result;\n    for\
    \ (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            result = word[pos];\n            break;\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxruat24j: /tmp/tmpxruat24j.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077989
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n  std::string vowels = \"aeiou\";\n  int closest_vowel_index = -1;\n\
    \  int closest_vowel_distance = INT_MAX;\n  for (int i = word.size() - 1; i >=\
    \ 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos) {\n      if (closest_vowel_index\
    \ == -1) {\n        closest_vowel_index = i;\n      } else {\n        if (i <\
    \ closest_vowel_index) {\n          closest_vowel_index = i;\n          closest_vowel_distance\
    \ = closest_vowel_index - i;\n        }\n      }\n    }\n  }\n  if (closest_vowel_index\
    \ == -1) {\n    return \"\";\n  }\n  return word.substr(closest_vowel_index, 1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpxrnvloe5: /tmp/tmpxrnvloe5.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int min_distance = INT_MAX;\n\
    \    int min_index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n \
    \       if (vowels.find(word[i]) != std::string::npos) {\n            int j =\
    \ i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    min_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (min_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(min_index, 1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph85suro4: /tmp/tmph85suro4.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_dist = INT_MAX;\n    for (int i = word.size() - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ dist = word.size() - i;\n            if (dist < min_dist) {\n              \
    \  min_dist = dist;\n                result = word[i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpek1ysmh6: /tmp/tmpek1ysmh6.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) {\n                return\
    \ \"\";\n            }\n            if (word[i + 1] != 'a' && word[i + 1] != 'e'\
    \ && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u') {\n     \
    \           return word.substr(i, 1);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpex0h5la1: /tmp/tmpex0h5la1.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (i == word.size() - 1) {\n                return \"\";\n \
    \           }\n            if (i == 0) {\n                return \"\";\n     \
    \       }\n            if (vowels.find(word[i + 1]) != std::string::npos) {\n\
    \                continue;\n            }\n            if (vowels.find(word[i\
    \ - 1]) != std::string::npos) {\n                continue;\n            }\n  \
    \          if (distance > word.size() - i) {\n                distance = word.size()\
    \ - i;\n                index = i;\n            }\n        }\n    }\n    if (index\
    \ != -1) {\n        result = word[index];\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp3jys05hp: /tmp/tmp3jys05hp.cpp:51: int main(): Assertion `candidate(("anime"))
    == ("i")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min = INT_MAX;\n    for (int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int j = i + 1;\n            while (j < word.length() && vowels.find(word[j])\
    \ != std::string::npos) {\n                j++;\n            }\n            if\
    \ (j < word.length()) {\n                if (j - i < min) {\n                \
    \    min = j - i;\n                    index = i;\n                }\n       \
    \     }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjhw9uzch: /tmp/tmpjhw9uzch.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            last_vowel_index = i;\n            break;\n\
    \        }\n    }\n    if (last_vowel_index == -1) {\n        return \"\";\n \
    \   }\n    int first_consonant_index = -1;\n    for (int i = last_vowel_index\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            first_consonant_index = i;\n            break;\n        }\n \
    \   }\n    if (first_consonant_index == -1) {\n        return \"\";\n    }\n \
    \   int second_consonant_index = -1;\n    for (int i = first_consonant_index -\
    \ 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n\
    \            second_consonant_index = i;\n            break;\n        }\n    }\n\
    \    if (second_consonant_index == -1) {\n        return \"\";\n    }\n    return\
    \ word.substr(last_vowel_index, 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp6hovsmt6: /tmp/tmp6hovsmt6.cpp:46: int main(): Assertion `candidate(("full"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    int last_vowel_index\
    \ = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            last_vowel_index = i;\n            break;\n\
    \        }\n    }\n    for (int i = last_vowel_index - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            distance =\
    \ last_vowel_index - i;\n            if (distance < min_distance) {\n        \
    \        min_distance = distance;\n                result = word[i];\n       \
    \     }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpeqnl6tbv: /tmp/tmpeqnl6tbv.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              result = word[i];\n                min_distance = distance;\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjmzdjkit: /tmp/tmpjmzdjkit.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        for (int j = 0; j < vowels.size(); j++) {\n            if (word[i]\
    \ == vowels[j]) {\n                int distance = 0;\n                for (int\
    \ k = i; k < word.size(); k++) {\n                    if (vowels.find(word[k])\
    \ == std::string::npos) {\n                        distance++;\n             \
    \       } else {\n                        break;\n                    }\n    \
    \            }\n                if (distance < min_distance) {\n             \
    \       min_distance = distance;\n                    result = word[i];\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp8nzik4iz: /tmp/tmp8nzik4iz.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    if (len < 3) return \"\";\n    int\
    \ i = len - 1;\n    while (i >= 0) {\n        if (word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n            if\
    \ (i == len - 1) {\n                i--;\n                continue;\n        \
    \    }\n            if (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1]\
    \ != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u') {\n                return\
    \ word.substr(i, 1);\n            }\n        }\n        i--;\n    }\n    return\
    \ \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp1n6re6ws: /tmp/tmp1n6re6ws.cpp:31: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5ojb709a: /tmp/tmp5ojb709a.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int i = len - 1;\n    while(i >=\
    \ 0) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            if(i == len - 1) {\n              \
    \  i--;\n                continue;\n            }\n            if(word[i + 1]\
    \ != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' &&\
    \ word[i + 1] != 'u') {\n                return word.substr(i, 1);\n         \
    \   }\n        }\n        i--;\n    }\n    return \"\";\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmppl9ybr1z: /tmp/tmppl9ybr1z.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    int distance = 0;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            distance = 0;\n            for (int j = i - 1; j >= 0; j--) {\n\
    \                if (vowels.find(word[j]) != std::string::npos) {\n          \
    \          break;\n                }\n                distance++;\n          \
    \  }\n            if (distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpt88819o3: /tmp/tmpt88819o3.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n \
    \           break;\n        }\n    }\n    if (pos == -1) {\n        return result;\n\
    \    }\n    for (int i = pos; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[pos];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpklmrw69g: /tmp/tmpklmrw69g.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                if (i + 1 < closest_vowel_index)\
    \ {\n                    closest_vowel_distance = closest_vowel_index - i - 1;\n\
    \                    closest_vowel_index = i;\n                }\n           \
    \ }\n        }\n    }\n    if (closest_vowel_index == -1) {\n        return \"\
    \";\n    }\n    return word.substr(closest_vowel_index, 1);\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpj4c0f0w0: /tmp/tmpj4c0f0w0.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                index = i;\n                min_distance = distance;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvfsz1out: /tmp/tmpvfsz1out.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            closest_vowel_index = i;\n            break;\n\
    \        }\n    }\n    if (closest_vowel_index == -1) {\n        return \"\";\n\
    \    }\n    for (int i = closest_vowel_index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(closest_vowel_index,\
    \ 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpst4tdvui: /tmp/tmpst4tdvui.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result;\n    int\
    \ index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            index = i;\n            break;\n      \
    \  }\n    }\n    if (index == -1) {\n        return result;\n    }\n    for (int\
    \ i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            result = word[index];\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgbcn6dde: /tmp/tmpgbcn6dde.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpssxjgu1q: /tmp/tmpssxjgu1q.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = -1;\n    for (int i = word.size() - 1;\
    \ i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n \
    \           if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n                closest_vowel_distance = word.size() - 1 - i;\n      \
    \      } else {\n                int distance = closest_vowel_index - i;\n   \
    \             if (distance < closest_vowel_distance) {\n                    closest_vowel_index\
    \ = i;\n                    closest_vowel_distance = distance;\n             \
    \   }\n            }\n        }\n    }\n    if (closest_vowel_index == -1) {\n\
    \        return \"\";\n    }\n    return word.substr(closest_vowel_index, 1);\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpeui7uawz: /tmp/tmpeui7uawz.cpp:36: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) !=\
    \ std::string::npos) {\n            closest = i;\n            break;\n       \
    \ }\n    }\n    if (closest == -1) return \"\";\n    for (int i = closest - 1;\
    \ i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n \
    \           return word.substr(closest, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprfx1i08w: /tmp/tmprfx1i08w.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int len = word.length();\n    int i = len - 1;\n    while(i >=\
    \ 0) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u') {\n            if(i == len - 1) {\n              \
    \  i--;\n                continue;\n            }\n            if(word[i + 1]\
    \ == 'a' || word[i + 1] == 'e' || word[i + 1] == 'i' || word[i + 1] == 'o' ||\
    \ word[i + 1] == 'u') {\n                i--;\n                continue;\n   \
    \         }\n            return word.substr(i, 1);\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpvwc1jpqc: /tmp/tmpvwc1jpqc.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i; j < word.size(); j++) {\n       \
    \         if (vowels.find(word[j]) != std::string::npos) {\n                 \
    \   break;\n                }\n                distance++;\n            }\n  \
    \          if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpicwh9sbo: /tmp/tmpicwh9sbo.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = 0;\n    int min_distance = word.size();\n    for (int i = 0;\
    \ i < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (min_distance != word.size()) {\n     \
    \   result = word[index];\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpwq_gz86l: /tmp/tmpwq_gz86l.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077991
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.size() - 1;\n\
    \    while (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (pos > 0 && vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n            else\
    \ if (pos < word.size() - 1 && vowels.find(word[pos + 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpdlwcdqij: /tmp/tmpdlwcdqij.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077991
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                if (i - closest_vowel_index < closest_vowel_distance)\
    \ {\n                    closest_vowel_distance = i - closest_vowel_index;\n \
    \                   closest_vowel_index = i;\n                }\n            }\n\
    \        }\n    }\n    if (closest_vowel_index == -1) {\n        return \"\";\n\
    \    }\n    return word.substr(closest_vowel_index, 1);\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpuac2x5hv: /tmp/tmpuac2x5hv.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            if (index\
    \ == -1) {\n                index = i;\n            } else {\n               \
    \ return word[index];\n            }\n        } else {\n            index = -1;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1thtvvcl.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmp1thtvvcl.cpp:18:34: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)index))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   18 |                 return word[index];\n      |                      \
    \            ^\n      |                                  |\n      |          \
    \                        __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}\n"
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    std::string vowels = \"aeiou\";\n    int\
    \ pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return \"\";\n    }\n    for (int i = pos\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            return word.substr(pos, 1);\n        }\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpgrkuroy1: /tmp/tmpgrkuroy1.cpp:35: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    int min_distance\
    \ = INT_MAX;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            for (int j = i - 1; j >= 0; j--) {\n  \
    \              if (vowels.find(word[j]) == std::string::npos) {\n            \
    \        if (i - j < min_distance) {\n                        min_distance = i\
    \ - j;\n                        index = i;\n                    }\n          \
    \          break;\n                }\n            }\n        }\n    }\n    if\
    \ (index == -1) {\n        return \"\";\n    }\n    return word.substr(index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpsq_4znqf: /tmp/tmpsq_4znqf.cpp:37: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    std::string vowels = \"aeiou\";\n    std::string\
    \ result = \"\";\n    int index = word.size() - 1;\n    while (index >= 0) {\n\
    \        if (vowels.find(word[index]) != std::string::npos) {\n            if\
    \ (index > 0 && vowels.find(word[index - 1]) == std::string::npos) {\n       \
    \         result = word[index];\n                break;\n            }\n     \
    \       else if (index == 0) {\n                result = word[index];\n      \
    \          break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmprfzwe5pa: /tmp/tmprfzwe5pa.cpp:33: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = INT_MAX;\n    for (int i = word.size()\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n            } else {\n                int distance = closest_vowel_index\
    \ - i;\n                if (distance < closest_vowel_distance) {\n           \
    \         closest_vowel_distance = distance;\n                    closest_vowel_index\
    \ = i;\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpti96zyo1: /tmp/tmpti96zyo1.cpp:33: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = 0;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (min_distance != INT_MAX) {\n        result\
    \ = word[index];\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpm4hcf7rr: /tmp/tmpm4hcf7rr.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) {\n                if\
    \ (i == 0) {\n                    return \"\";\n                }\n          \
    \      if (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i\
    \ - 1] != 'o' && word[i - 1] != 'u') {\n                    return word.substr(i,\
    \ 1);\n                }\n            } else {\n                if (word[i + 1]\
    \ != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' &&\
    \ word[i + 1] != 'u') {\n                    return word.substr(i, 1);\n     \
    \           }\n            }\n        }\n        i--;\n    }\n    return \"\"\
    ;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp9i2_gmql: /tmp/tmp9i2_gmql.cpp:35: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) return \"\";\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            return word.substr(index,\
    \ 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo6zs2h65: /tmp/tmpo6zs2h65.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int pos = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n     \
    \   if (vowels.find(word[i]) != std::string::npos) {\n            pos = i;\n \
    \           break;\n        }\n    }\n    if (pos == -1) {\n        return result;\n\
    \    }\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[pos];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmqed24fb: /tmp/tmpmqed24fb.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmu698_c7: /tmp/tmpmu698_c7.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5ojb709a: /tmp/tmp5ojb709a.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.size() - 1;\n\
    \    while (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (pos > 0 && vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n            if\
    \ (pos < word.size() - 1 && vowels.find(word[pos + 1]) == std::string::npos) {\n\
    \                return word.substr(pos, 1);\n            }\n        }\n     \
    \   pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf3d57_dv: /tmp/tmpf3d57_dv.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string result = \"\";\n    int vowel_index = -1;\n    for\
    \ (int i = word.size() - 1; i >= 0; i--) {\n        if (word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') {\n          \
    \  vowel_index = i;\n            break;\n        }\n    }\n    if (vowel_index\
    \ == -1) {\n        return result;\n    }\n    for (int i = vowel_index - 1; i\
    \ >= 0; i--) {\n        if (word[i] != 'a' && word[i] != 'e' && word[i] != 'i'\
    \ && word[i] != 'o' && word[i] != 'u') {\n            result = word[vowel_index];\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmptwtqeskr: /tmp/tmptwtqeskr.cpp:35: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) {\n        return \"\";\n    }\n    for (int i = pos - 1; i >= 0; i--) {\n\
    \        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(pos, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkhg5_6op: /tmp/tmpkhg5_6op.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    int min_dist\
    \ = INT_MAX;\n    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            pos = i;\n            break;\n        }\n\
    \    }\n    if (pos == -1) {\n        return \"\";\n    }\n    for (int i = pos\
    \ - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos)\
    \ {\n            min_dist = std::min(min_dist, pos - i);\n            pos = i;\n\
    \        }\n    }\n    if (min_dist == INT_MAX) {\n        return \"\";\n    }\n\
    \    return word.substr(pos, min_dist + 1);\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjdcbst01: /tmp/tmpjdcbst01.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // your code here\n    std::string vowels = \"aeiou\";\n    int\
    \ n = word.size();\n    int i = n-1;\n    while(i >= 0) {\n        if(vowels.find(word[i])\
    \ != std::string::npos) {\n            return word[i];\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdj9i3dcz.cpp: In function \u2018std::string get_closest_vowel(std::string)\u2019\
    :\n/tmp/tmpdj9i3dcz.cpp:16:26: error: could not convert \u2018word.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   16 |             return word[i];\n      |                          ^\n \
    \     |                          |\n      |                          __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\n"
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    int left = index - 1;\n    int right\
    \ = index + 1;\n    while (left >= 0 && right < word.size()) {\n        if (vowels.find(word[left])\
    \ == std::string::npos && vowels.find(word[right]) == std::string::npos) {\n \
    \           return word.substr(index, 1);\n        }\n        left--;\n      \
    \  right++;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpsll_gfvl: /tmp/tmpsll_gfvl.cpp:43: int main(): Assertion `candidate(("quick"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5ojb709a: /tmp/tmp5ojb709a.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) {\n        return \"\";\n    }\n    for (int i = index - 1; i >= 0; i--)\
    \ {\n        if (vowels.find(word[i]) == std::string::npos) {\n            return\
    \ word.substr(index, 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpmu698_c7: /tmp/tmpmu698_c7.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) {\n                return\
    \ \"\";\n            }\n            return word.substr(i, 1);\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmph9v6a17l: /tmp/tmph9v6a17l.cpp:27: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int i = word.size() - 1;\n\
    \    while (i >= 0) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            if (i == word.size() - 1) {\n                return \"\";\n \
    \           }\n            if (vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpttlrl154: /tmp/tmpttlrl154.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n \
    \   for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (closest_vowel_index == -1) {\n    \
    \            closest_vowel_index = i;\n                closest_vowel_distance\
    \ = word.size() - i;\n            } else {\n                if (closest_vowel_distance\
    \ > i - closest_vowel_index) {\n                    closest_vowel_index = i;\n\
    \                    closest_vowel_distance = i - closest_vowel_index;\n     \
    \           }\n            }\n        }\n    }\n    if (closest_vowel_index !=\
    \ -1) {\n        result = word[closest_vowel_index];\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpl9jkscub: /tmp/tmpl9jkscub.cpp:34: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                result = word[i];\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5ojb709a: /tmp/tmp5ojb709a.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) {\n                return\
    \ \"\";\n            }\n            if (word[i + 1] != 'a' && word[i + 1] != 'e'\
    \ && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u') {\n     \
    \           return word.substr(i, 1);\n            }\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpex0h5la1: /tmp/tmpex0h5la1.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    for (int i = word.size() - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) != std::string::npos) {\n            index = i;\n\
    \            break;\n        }\n    }\n    if (index == -1) {\n        return\
    \ result;\n    }\n    for (int i = index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp0pzlkkwu: /tmp/tmp0pzlkkwu.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string closest_vowel;\n\
    \    int closest_vowel_index = -1;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   closest_vowel = word[i];\n            closest_vowel_index = i;\n         \
    \   break;\n        }\n    }\n    if (closest_vowel_index == -1) {\n        return\
    \ \"\";\n    }\n    for (int i = closest_vowel_index - 1; i >= 0; i--) {\n   \
    \     if (vowels.find(word[i]) == std::string::npos) {\n            return closest_vowel;\n\
    \        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpivoepvud: /tmp/tmpivoepvud.cpp:36: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            if (index == word.size() - 1) {\n     \
    \           index--;\n                continue;\n            }\n            if\
    \ (vowels.find(word[index + 1]) != std::string::npos) {\n                index--;\n\
    \                continue;\n            }\n            result = word[index];\n\
    \            break;\n        }\n        index--;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp4w6zzwf2: /tmp/tmp4w6zzwf2.cpp:34: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i - 1;\n            while (j >= 0 && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j--;\n            }\n            if (j >= 0) {\n        \
    \        int k = i + 1;\n                while (k < word.size() && vowels.find(word[k])\
    \ != std::string::npos) {\n                    k++;\n                }\n     \
    \           if (k < word.size()) {\n                    int distance = k - j;\n\
    \                    if (distance < min_distance) {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcazxjqzu: /tmp/tmpcazxjqzu.cpp:38: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = word.size() - i;\n            if (distance < min_distance) {\n  \
    \              min_distance = distance;\n                result = word[i];\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo7jj1qbj: /tmp/tmpo7jj1qbj.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077987
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int index = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    if (index\
    \ == -1) return \"\";\n    for (int i = index - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) == std::string::npos) {\n            return word.substr(index,\
    \ 1);\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpo6zs2h65: /tmp/tmpo6zs2h65.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == len - 1) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd7iwbhc5: /tmp/tmpd7iwbhc5.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.size() - 1;\n\
    \    while (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (pos > 0 && vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n            if\
    \ (pos < word.size() - 1 && vowels.find(word[pos + 1]) == std::string::npos) {\n\
    \                return word.substr(pos, 1);\n            }\n        }\n     \
    \   pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpf3d57_dv: /tmp/tmpf3d57_dv.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ j = i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int distance = j - i;\n                if (distance < min_distance)\
    \ {\n                    min_distance = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjfoxsu57: /tmp/tmpjfoxsu57.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            int j =\
    \ i + 1;\n            while (j < word.size() && vowels.find(word[j]) != std::string::npos)\
    \ {\n                j++;\n            }\n            if (j < word.size()) {\n\
    \                int temp = j - i;\n                if (temp < distance) {\n \
    \                   distance = temp;\n                    result = word[i];\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpj21937p2: /tmp/tmpj21937p2.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = word.size() - 1;\n    while (index >= 0) {\n        if (vowels.find(word[index])\
    \ != std::string::npos) {\n            result = word[index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"\
    u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpcektnj0x: /tmp/tmpcektnj0x.cpp:26: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i; j < word.size(); j++) {\n       \
    \         if (vowels.find(word[j]) != std::string::npos) {\n                 \
    \   break;\n                }\n                distance++;\n            }\n  \
    \          if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpicwh9sbo: /tmp/tmpicwh9sbo.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077990
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int i = word.size() - 1;\n    while (i >= 0) {\n        if (word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            if (i == word.size() - 1) {\n                i--;\n         \
    \       continue;\n            }\n            if (word[i + 1] != 'a' && word[i\
    \ + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u')\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpv4b9xozx: /tmp/tmpv4b9xozx.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077992
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = word.size() - 1; i >= 0;\
    \ i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n         \
    \   for (int j = i - 1; j >= 0; j--) {\n                if (vowels.find(word[j])\
    \ == std::string::npos) {\n                    if (min_distance > i - j) {\n \
    \                       min_distance = i - j;\n                        result\
    \ = word[i];\n                    }\n                    break;\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) ==\
    \ (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpe023u95q: /tmp/tmpe023u95q.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077993
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = -1;\n    for (int\
    \ i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            pos = i;\n            break;\n        }\n    }\n    if (pos ==\
    \ -1) return \"\";\n    for (int i = pos - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(pos, 1);\n        }\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp_rnoufdm: /tmp/tmp_rnoufdm.cpp:32: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int min_distance = INT_MAX;\n    for (int i = 0; i < word.size(); i++)\
    \ {\n        if (vowels.find(word[i]) != std::string::npos) {\n            int\
    \ distance = 0;\n            for (int j = i + 1; j < word.size(); j++) {\n   \
    \             if (vowels.find(word[j]) != std::string::npos) {\n             \
    \       break;\n                }\n                distance++;\n            }\n\
    \            if (distance < min_distance) {\n                min_distance = distance;\n\
    \                result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpup6q5zer: /tmp/tmpup6q5zer.cpp:32: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    for (int i = word.size() - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            last_vowel_index = i;\n            break;\n\
    \        }\n    }\n    if (last_vowel_index == -1) {\n        return \"\";\n \
    \   }\n    for (int i = last_vowel_index - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ == std::string::npos) {\n            return word.substr(i + 1, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpjw2w525h: /tmp/tmpjw2w525h.cpp:34: int main(): Assertion `candidate(("ali"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077993
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int pos = word.size() - 1;\n\
    \    while (pos >= 0) {\n        if (vowels.find(word[pos]) != std::string::npos)\
    \ {\n            if (pos > 0 && vowels.find(word[pos - 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n            else\
    \ if (pos < word.size() - 1 && vowels.find(word[pos + 1]) == std::string::npos)\
    \ {\n                return word.substr(pos, 1);\n            }\n        }\n \
    \       pos--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpdlwcdqij: /tmp/tmpdlwcdqij.cpp:29: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077991
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    int n = word.size();\n    int i = n - 1;\n    while (i >= 0) {\n\
    \        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u') {\n            if (i == n - 1) return \"\";\n       \
    \     if (word[i + 1] == 'a' || word[i + 1] == 'e' || word[i + 1] == 'i' || word[i\
    \ + 1] == 'o' || word[i + 1] == 'u') {\n                return \"\";\n       \
    \     }\n            return word.substr(i, 1);\n        }\n        i--;\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmphl44j7x3: /tmp/tmphl44j7x3.cpp:28: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077993
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = -1;\n    for (int i = word.size() - 1;\
    \ i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n \
    \           if (closest_vowel_index == -1) {\n                closest_vowel_index\
    \ = i;\n                closest_vowel_distance = word.size() - i;\n          \
    \  } else {\n                if (i + 1 < word.size() && vowels.find(word[i + 1])\
    \ == std::string::npos) {\n                    if (closest_vowel_distance > word.size()\
    \ - i) {\n                        closest_vowel_index = i;\n                 \
    \       closest_vowel_distance = word.size() - i;\n                    }\n   \
    \             }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1) {\n        return \"\";\n    }\n    return word.substr(closest_vowel_index,\
    \ 1);\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpylip_4m6: /tmp/tmpylip_4m6.cpp:37: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077993
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == len - 1) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[i + 1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpd7iwbhc5: /tmp/tmpd7iwbhc5.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077988
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    std::string result = \"\"\
    ;\n    int index = -1;\n    int min_distance = INT_MAX;\n    for (int i = 0; i\
    \ < word.size(); i++) {\n        if (vowels.find(word[i]) != std::string::npos)\
    \ {\n            int distance = word.size() - i;\n            if (distance < min_distance)\
    \ {\n                min_distance = distance;\n                index = i;\n  \
    \          }\n        }\n    }\n    if (index != -1) {\n        result = word[index];\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmp5or8eapt: /tmp/tmp5or8eapt.cpp:32: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077985
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (i == len - 1) {\n                return\
    \ \"\";\n            }\n            if (vowels.find(word[i+1]) == std::string::npos)\
    \ {\n                return word.substr(i, 1);\n            }\n        }\n   \
    \     i--;\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpkdu4n9ip: /tmp/tmpkdu4n9ip.cpp:30: int main(): Assertion `candidate(("easy"))
    == ("")'' failed.

    '
  stdout: ''
  timestamp: 1660077994
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiou\";\n    int closest_vowel_index =\
    \ -1;\n    int closest_vowel_distance = -1;\n    int last_consonant_index = -1;\n\
    \    for (int i = 0; i < word.size(); i++) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            if (last_consonant_index != -1) {\n   \
    \             int distance = i - last_consonant_index;\n                if (closest_vowel_distance\
    \ == -1 || distance < closest_vowel_distance) {\n                    closest_vowel_distance\
    \ = distance;\n                    closest_vowel_index = i;\n                }\n\
    \            }\n        } else {\n            last_consonant_index = i;\n    \
    \    }\n    }\n    if (closest_vowel_index == -1) {\n        return \"\";\n  \
    \  } else {\n        return word.substr(closest_vowel_index, 1);\n    }\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: Exception
  stderr: 'tmpnkwc4l3c: /tmp/tmpnkwc4l3c.cpp:35: int main(): Assertion `candidate(("yogurt"))
    == ("u")'' failed.

    '
  stdout: ''
  timestamp: 1660077994
