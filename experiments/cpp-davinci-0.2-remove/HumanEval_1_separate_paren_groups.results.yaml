language: cpp
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            if(stk.empty()){\n\
    \                return result;\n            }\n            stk.pop();\n     \
    \   }\n        else if(paren_string[i]==' '){\n            continue;\n       \
    \ }\n        else{\n            return result;\n        }\n        temp+=paren_string[i];\n\
    \        if(stk.empty()){\n            result.push_back(temp);\n            temp=\"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            open++;\n       \
    \     temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            open--;\n            temp += paren_string[i];\n        } else if\
    \ (paren_string[i] == ' ') {\n            continue;\n        } else {\n      \
    \      temp += paren_string[i];\n        }\n        if (open == 0) {\n       \
    \     result.push_back(temp);\n            temp = \"\";\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp = \"\";\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            st.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            st.pop();\n            if(st.empty()) {\n           \
    \     result.push_back(temp);\n                temp = \"\";\n            }\n \
    \       }\n        else if(paren_string[i] != ' ') {\n            temp += paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpnptjgerh: /tmp/tmpnptjgerh.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ groups;\n    std::string group = \"\";\n    int count = 0;\n    for (char c\
    \ : paren_string) {\n        if (c == '(') {\n            count++;\n        }\
    \ else if (c == ')') {\n            count--;\n        }\n        if (count ==\
    \ 0 && group != \"\") {\n            groups.push_back(group);\n            group\
    \ = \"\";\n        } else if (c != ' ') {\n            group += c;\n        }\n\
    \    }\n    return groups;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpg4m5n37r: /tmp/tmpg4m5n37r.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            if (count == 0) {\n                start = i;\n            }\n\
    \            count++;\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            if (count == 0) {\n                end = i;\n     \
    \           result.push_back(paren_string.substr(start, end - start + 1));\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpad95sve9: /tmp/tmpad95sve9.cpp:33: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx82n330e: /tmp/tmpx82n330e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx82n330e: /tmp/tmpx82n330e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp = \"\";\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            stk.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            stk.pop();\n            if(stk.empty()) {\n         \
    \       result.push_back(temp);\n                temp = \"\";\n            }\n\
    \        }\n        else if(paren_string[i] != ' ') {\n            temp += paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1krhq1ob: /tmp/tmp1krhq1ob.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.empty()){\n\
    \                return result;\n            }\n            else{\n          \
    \      st.pop();\n                temp.push_back(paren_string[i]);\n         \
    \   }\n        }\n        else{\n            temp.push_back(paren_string[i]);\n\
    \        }\n    }\n    if(!st.empty()){\n        return result;\n    }\n    result.push_back(temp);\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmptttf0yy2: /tmp/tmptttf0yy2.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            open++;\n        } else if (paren_string[i] == ')') {\n\
    \            close++;\n        }\n        if (open == close) {\n            end\
    \ = i;\n            result.push_back(paren_string.substr(start, end - start +\
    \ 1));\n            start = end + 1;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp402sl8eo: /tmp/tmp402sl8eo.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx82n330e: /tmp/tmpx82n330e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp3z4izurs: /tmp/tmp3z4izurs.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            if (count == 0) {\n                start = i;\n            }\n\
    \            count++;\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            if (count == 0) {\n                end = i;\n     \
    \           result.push_back(paren_string.substr(start, end - start + 1));\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpad95sve9: /tmp/tmpad95sve9.cpp:33: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp != \"\") {\n            result.push_back(temp);\n    \
    \        temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpgfecothl: /tmp/tmpgfecothl.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx82n330e: /tmp/tmpx82n330e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe1d1kn77: /tmp/tmpe1d1kn77.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open_paren_count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            open_paren_count++;\n            temp += paren_string[i];\n \
    \       } else if (paren_string[i] == ')') {\n            open_paren_count--;\n\
    \            temp += paren_string[i];\n        } else if (paren_string[i] == '\
    \ ') {\n            continue;\n        } else {\n            assert(false);\n\
    \        }\n        if (open_paren_count == 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            open++;\n        } else if (c == ')')\
    \ {\n            open--;\n        } else if (c == ' ') {\n            continue;\n\
    \        }\n        temp += c;\n        if (open == 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> s;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            s.push(paren_string[i]);\n   \
    \     }\n        else if(paren_string[i]==')'){\n            s.pop();\n      \
    \      if(s.empty()){\n                result.push_back(temp);\n             \
    \   temp=\"\";\n            }\n        }\n        else if(paren_string[i]!=' '){\n\
    \            temp+=paren_string[i];\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpgglbonq_: /tmp/tmpgglbonq_.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(auto i : paren_string)\
    \ {\n        if(i == '(') {\n            count++;\n        }\n        else if(i\
    \ == ')') {\n            count--;\n        }\n        if(count == 0 && i == ')')\
    \ {\n            result.push_back(temp);\n            temp = \"\";\n        }\n\
    \        else if(i != ' ') {\n            temp += i;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmppli5idby: /tmp/tmppli5idby.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp7p8zfb9j: /tmp/tmp7p8zfb9j.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp3z4izurs: /tmp/tmp3z4izurs.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp != \"\") {\n            result.push_back(temp);\n    \
    \        temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpgfecothl: /tmp/tmpgfecothl.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp = \"\";\n    int count = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n  \
    \          count++;\n            temp += paren_string[i];\n        }\n       \
    \ else if(paren_string[i] == ')') {\n            count--;\n            temp +=\
    \ paren_string[i];\n        }\n        else if(paren_string[i] == ' ') {\n   \
    \         continue;\n        }\n        else {\n            temp += paren_string[i];\n\
    \        }\n        if(count == 0) {\n            result.push_back(temp);\n  \
    \          temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ groups;\n    std::string group;\n    int open = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            open++;\n        } else if (c == ')')\
    \ {\n            open--;\n        }\n        if (open == 0) {\n            groups.push_back(group);\n\
    \            group = \"\";\n        } else {\n            group += c;\n      \
    \  }\n    }\n    return groups;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpjjhv3gg4: /tmp/tmpjjhv3gg4.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            open++;\n       \
    \     temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            open--;\n            temp += paren_string[i];\n        } else if\
    \ (paren_string[i] == ' ') {\n            continue;\n        } else {\n      \
    \      temp += paren_string[i];\n        }\n        if (open == 0) {\n       \
    \     result.push_back(temp);\n            temp = \"\";\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;\
    \ i<paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n    \
    \        stk.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            stk.pop();\n            if(stk.empty()) {\n         \
    \       result.push_back(temp);\n                temp.clear();\n            }\n\
    \        }\n        else if(paren_string[i] != ' ') {\n            temp += paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpq73yvezr: /tmp/tmpq73yvezr.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe1d1kn77: /tmp/tmpe1d1kn77.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            if(stk.empty()){\n\
    \                return result;\n            }\n            else{\n          \
    \      stk.pop();\n                if(stk.empty()){\n                    result.push_back(temp);\n\
    \                    temp.clear();\n                }\n            }\n       \
    \ }\n        else if(paren_string[i]!=' '){\n            temp.push_back(paren_string[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpu55_aegj: /tmp/tmpu55_aegj.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ' ') {\n            continue;\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            open++;\n       \
    \     temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            open--;\n            temp += paren_string[i];\n        } else if\
    \ (paren_string[i] == ' ') {\n            continue;\n        } else {\n      \
    \      temp += paren_string[i];\n        }\n        if (open == 0) {\n       \
    \     result.push_back(temp);\n            temp = \"\";\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            if (count == 0) {\n                start = i;\n            }\n\
    \            count++;\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            if (count == 0) {\n                end = i;\n     \
    \           result.push_back(paren_string.substr(start, end - start + 1));\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpad95sve9: /tmp/tmpad95sve9.cpp:33: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> s;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            s.push(paren_string[i]);\n   \
    \     }\n        else if(paren_string[i]==')'){\n            s.pop();\n      \
    \      temp+=paren_string[i];\n        }\n        else{\n            temp+=paren_string[i];\n\
    \        }\n        if(s.empty()){\n            result.push_back(temp);\n    \
    \        temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx9il83y5: /tmp/tmpx9il83y5.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx82n330e: /tmp/tmpx82n330e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.empty()){\n\
    \                return result;\n            }\n            else{\n          \
    \      st.pop();\n                temp+=paren_string[i];\n            }\n    \
    \    }\n        else{\n            temp+=paren_string[i];\n        }\n    }\n\
    \    if(st.empty()){\n        result.push_back(temp);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmphwgw0nsx: /tmp/tmphwgw0nsx.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    // TODO: Implement this\
    \ function\n    std::vector<std::string> result;\n    std::string temp;\n    int\
    \ count = 0;\n    for(int i = 0; i < paren_string.size(); i++){\n        if(paren_string[i]\
    \ == '('){\n            count++;\n            temp += paren_string[i];\n     \
    \   }\n        else if(paren_string[i] == ')'){\n            count--;\n      \
    \      temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ' '){\n            continue;\n        }\n        else{\n            temp +=\
    \ paren_string[i];\n        }\n        if(count == 0){\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp7p8zfb9j: /tmp/tmp7p8zfb9j.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ res;\n    std::string temp = \"\";\n    int count = 0;\n    for(int i = 0; i\
    \ < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n    \
    \        count++;\n            temp += paren_string[i];\n        }\n        else\
    \ if(paren_string[i] == ')') {\n            count--;\n            temp += paren_string[i];\n\
    \        }\n        else {\n            temp += paren_string[i];\n        }\n\
    \        if(count == 0) {\n            res.push_back(temp);\n            temp\
    \ = \"\";\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1733k_cz: /tmp/tmp1733k_cz.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe1d1kn77: /tmp/tmpe1d1kn77.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            open++;\n       \
    \     temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            open--;\n            temp += paren_string[i];\n        } else if\
    \ (paren_string[i] == ' ') {\n            continue;\n        } else {\n      \
    \      temp += paren_string[i];\n        }\n        if (open == 0) {\n       \
    \     result.push_back(temp);\n            temp = \"\";\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    // TODO: Implement this\
    \ function\n    std::vector<std::string> result;\n    std::string temp;\n    int\
    \ count = 0;\n    for(int i = 0; i < paren_string.size(); i++){\n        if(paren_string[i]\
    \ == '('){\n            count++;\n            temp += paren_string[i];\n     \
    \   }\n        else if(paren_string[i] == ')'){\n            count--;\n      \
    \      temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ' '){\n            continue;\n        }\n        else{\n            temp +=\
    \ paren_string[i];\n        }\n        if(count == 0){\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            if(stk.empty()){\n\
    \                return result;\n            }\n            stk.pop();\n     \
    \   }\n        else{\n            continue;\n        }\n        if(stk.empty()){\n\
    \            result.push_back(temp);\n            temp=\"\";\n        }\n    \
    \    else{\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe2zmh46w: /tmp/tmpe2zmh46w.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmphrpeqk9s: /tmp/tmphrpeqk9s.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            count++;\n            if (count == 1) {\n                start\
    \ = i;\n            }\n        }\n        if (paren_string[i] == ')') {\n    \
    \        count--;\n            if (count == 0) {\n                end = i;\n \
    \               result.push_back(paren_string.substr(start, end - start + 1));\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp9rqc18pa: /tmp/tmp9rqc18pa.cpp:34: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp = \"\";\n    int count = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n  \
    \          count++;\n            temp += paren_string[i];\n        }\n       \
    \ else if(paren_string[i] == ')') {\n            count--;\n            temp +=\
    \ paren_string[i];\n        }\n        else if(paren_string[i] == ' ') {\n   \
    \         continue;\n        }\n        else {\n            assert(false);\n \
    \       }\n        if(count == 0) {\n            result.push_back(temp);\n   \
    \         temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          temp+=paren_string[i];\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n        if(stk.empty()){\n\
    \            result.push_back(temp);\n            temp.clear();\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp_kq2z__v: /tmp/tmp_kq2z__v.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            count++;\n            if (count == 1) {\n                start\
    \ = i;\n            }\n        }\n        if (paren_string[i] == ')') {\n    \
    \        count--;\n            if (count == 0) {\n                end = i;\n \
    \               result.push_back(paren_string.substr(start, end - start + 1));\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp9rqc18pa: /tmp/tmp9rqc18pa.cpp:34: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe1d1kn77: /tmp/tmpe1d1kn77.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp7p8zfb9j: /tmp/tmp7p8zfb9j.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n  std::vector<std::string>\
    \ result;\n  std::stack<char> stk;\n  std::string temp;\n  for(int i=0;i<paren_string.length();i++){\n\
    \    if(paren_string[i]=='('){\n      stk.push(paren_string[i]);\n    }\n    else\
    \ if(paren_string[i]==')'){\n      stk.pop();\n      if(stk.empty()){\n      \
    \  result.push_back(temp);\n        temp.clear();\n      }\n    }\n    else if(paren_string[i]!='\
    \ '){\n      temp+=paren_string[i];\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpchrvaqju: /tmp/tmpchrvaqju.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open_count = 0;\n    for (int i = 0;\
    \ i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n   \
    \         open_count++;\n            temp += paren_string[i];\n        } else\
    \ if (paren_string[i] == ')') {\n            open_count--;\n            temp +=\
    \ paren_string[i];\n        } else {\n            temp += paren_string[i];\n \
    \       }\n        if (open_count == 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpzxvalngq: /tmp/tmpzxvalngq.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open_paren_count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            open_paren_count++;\n            temp += paren_string[i];\n \
    \       } else if (paren_string[i] == ')') {\n            open_paren_count--;\n\
    \            temp += paren_string[i];\n        } else if (paren_string[i] == '\
    \ ') {\n            continue;\n        } else {\n            temp += paren_string[i];\n\
    \        }\n        if (open_paren_count == 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.top()=='('){\n\
    \                st.pop();\n                if(st.empty()){\n                \
    \    result.push_back(temp);\n                    temp.clear();\n            \
    \    }\n            }\n        }\n        else{\n            if(!st.empty()){\n\
    \                temp+=paren_string[i];\n            }\n        }\n    }\n   \
    \ return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpaijzdri4: /tmp/tmpaijzdri4.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpuflbqe4y: /tmp/tmpuflbqe4y.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmphrpeqk9s: /tmp/tmphrpeqk9s.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            if(stk.empty()){\n\
    \                return result;\n            }\n            else{\n          \
    \      stk.pop();\n                if(stk.empty()){\n                    result.push_back(temp);\n\
    \                    temp=\"\";\n                }\n            }\n        }\n\
    \        else if(paren_string[i]!=' '){\n            temp+=paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpkqw2ym40: /tmp/tmpkqw2ym40.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            if (count == 0) {\n                start = i;\n            }\n\
    \            count++;\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            if (count == 0) {\n                end = i;\n     \
    \           result.push_back(paren_string.substr(start, end - start + 1));\n \
    \           }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpad95sve9: /tmp/tmpad95sve9.cpp:33: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stack;\n    std::string temp;\n    for(int i =\
    \ 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n\
    \            stack.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            stack.pop();\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        else {\n            temp\
    \ += paren_string[i];\n        }\n        if(stack.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpxih_nohe: /tmp/tmpxih_nohe.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            if(count == 0) {\n                if(temp.length()\
    \ > 0) {\n                    result.push_back(temp);\n                    temp\
    \ = \"\";\n                }\n            }\n            else {\n            \
    \    temp += paren_string[i];\n            }\n        }\n    }\n    if(temp.length()\
    \ > 0) {\n        result.push_back(temp);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpw8ote5rs: /tmp/tmpw8ote5rs.cpp:42: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            open++;\n        \
    \    temp += paren_string[i];\n        }\n        else if(paren_string[i] == ')')\
    \ {\n            open--;\n            temp += paren_string[i];\n        }\n  \
    \      else {\n            temp += paren_string[i];\n        }\n        if(open\
    \ == 0) {\n            result.push_back(temp);\n            temp = \"\";\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe_bxp8qo: /tmp/tmpe_bxp8qo.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.empty()){\n\
    \                std::cout<<\"Invalid String\"<<std::endl;\n                return\
    \ result;\n            }\n            else{\n                st.pop();\n     \
    \           if(st.empty()){\n                    result.push_back(temp);\n   \
    \                 temp=\"\";\n                }\n            }\n        }\n  \
    \      else if(paren_string[i]!=' '){\n            temp+=paren_string[i];\n  \
    \      }\n    }\n    if(!st.empty()){\n        std::cout<<\"Invalid String\"<<std::endl;\n\
    \        return result;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp0vo0o04e: /tmp/tmp0vo0o04e.cpp:40: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            if(count == 0) {\n                continue;\n\
    \            }\n            else {\n                temp.push_back(paren_string[i]);\n\
    \            }\n        }\n        if(count == 0) {\n            result.push_back(temp);\n\
    \            temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp1tx2uids: /tmp/tmp1tx2uids.cpp:40: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open_paren_count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            open_paren_count++;\n            temp += paren_string[i];\n \
    \       } else if (paren_string[i] == ')') {\n            open_paren_count--;\n\
    \            temp += paren_string[i];\n        } else if (paren_string[i] == '\
    \ ') {\n            continue;\n        } else {\n            temp += paren_string[i];\n\
    \        }\n        if (open_paren_count == 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int open = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            open++;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            open--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ' ') {\n            continue;\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(open == 0) {\n            result.push_back(temp);\n      \
    \      temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106794
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmphrpeqk9s: /tmp/tmphrpeqk9s.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmphrpeqk9s: /tmp/tmphrpeqk9s.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmps5r0v205: /tmp/tmps5r0v205.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp = \"\";\n    int count = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n  \
    \          count++;\n            temp += paren_string[i];\n        }\n       \
    \ else if(paren_string[i] == ')') {\n            count--;\n            temp +=\
    \ paren_string[i];\n        }\n        else if(paren_string[i] == ' ') {\n   \
    \         continue;\n        }\n        else {\n            temp += paren_string[i];\n\
    \        }\n        if(count == 0) {\n            result.push_back(temp);\n  \
    \          temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> s;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            s.push(paren_string[i]);\n   \
    \     }\n        else if(paren_string[i]==')'){\n            s.pop();\n      \
    \      if(s.empty()){\n                result.push_back(temp);\n             \
    \   temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpc7_i491x: /tmp/tmpc7_i491x.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    int start = 0;\n    for (int i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       st.push(paren_string[i]);\n        } else if (paren_string[i] == ')')\
    \ {\n            st.pop();\n        }\n        if (st.empty()) {\n           \
    \ result.push_back(paren_string.substr(start, i - start + 1));\n            start\
    \ = i + 1;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpup7aeq99: /tmp/tmpup7aeq99.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> stk;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            stk.push(paren_string[i]);\n \
    \       }\n        else if(paren_string[i]==')'){\n            stk.pop();\n  \
    \          if(stk.empty()){\n                result.push_back(temp);\n       \
    \         temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp88si98g1: /tmp/tmp88si98g1.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp03lrpc4r: /tmp/tmp03lrpc4r.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp = \"\";\n    int count = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n  \
    \          count++;\n            temp += paren_string[i];\n        }\n       \
    \ else if(paren_string[i] == ')') {\n            count--;\n            temp +=\
    \ paren_string[i];\n        }\n        else {\n            temp += paren_string[i];\n\
    \        }\n        if(count == 0) {\n            result.push_back(temp);\n  \
    \          temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpn80_zvj5: /tmp/tmpn80_zvj5.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.empty()){\n\
    \                return result;\n            }\n            else{\n          \
    \      st.pop();\n                temp+=paren_string[i];\n            }\n    \
    \    }\n        else{\n            temp+=paren_string[i];\n        }\n    }\n\
    \    if(!st.empty()){\n        return result;\n    }\n    result.push_back(temp);\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp5tvhirv7: /tmp/tmp5tvhirv7.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.empty()){\n\
    \                return result;\n            }\n            else{\n          \
    \      st.pop();\n                temp+=paren_string[i];\n            }\n    \
    \    }\n        else{\n            temp+=paren_string[i];\n        }\n    }\n\
    \    if(!st.empty()){\n        return result;\n    }\n    result.push_back(temp);\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp5tvhirv7: /tmp/tmp5tvhirv7.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ groups;\n    std::string group;\n    int open_parens = 0;\n    for (char c :\
    \ paren_string) {\n        if (c == '(') {\n            open_parens++;\n     \
    \   } else if (c == ')') {\n            open_parens--;\n        }\n        if\
    \ (open_parens == 0) {\n            if (group.size() > 0) {\n                groups.push_back(group);\n\
    \                group = \"\";\n            }\n        } else {\n            group\
    \ += c;\n        }\n    }\n    return groups;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpccxq6u0z: /tmp/tmpccxq6u0z.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            count++;\n            if (count == 1) {\n                start\
    \ = i;\n            }\n        }\n        if (paren_string[i] == ')') {\n    \
    \        count--;\n            if (count == 0) {\n                end = i;\n \
    \               result.push_back(paren_string.substr(start, end - start + 1));\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmp9rqc18pa: /tmp/tmp9rqc18pa.cpp:34: int main(): Assertion `candidate(("(
    ) (( )) (( )( ))")) == (std::vector<std::string>({(std::string)"()", (std::string)"(())",
    (std::string)"(()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n  std::vector<std::string>\
    \ result;\n  std::string temp;\n  int count = 0;\n  for (int i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      count++;\n      temp += paren_string[i];\n\
    \    } else if (paren_string[i] == ')') {\n      count--;\n      temp += paren_string[i];\n\
    \    } else {\n      temp += paren_string[i];\n    }\n    if (count == 0 && temp\
    \ != \"\") {\n      result.push_back(temp);\n      temp = \"\";\n    }\n  }\n\
    \  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpws1m9x64: /tmp/tmpws1m9x64.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106795
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp.push_back(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            count--;\n            temp.push_back(paren_string[i]);\n\
    \        }\n        else {\n            temp.push_back(paren_string[i]);\n   \
    \     }\n        if(count == 0) {\n            result.push_back(temp);\n     \
    \       temp.clear();\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpe1d1kn77: /tmp/tmpe1d1kn77.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else {\n            temp += paren_string[i];\n        }\n       \
    \ if(count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n \
    \           temp.clear();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpx82n330e: /tmp/tmpx82n330e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106793
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for(int i = 0; i < paren_string.size();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            count++;\n       \
    \     temp += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        else if(paren_string[i] == ' ') {\n            continue;\n      \
    \  }\n        else {\n            temp += paren_string[i];\n        }\n      \
    \  if(count == 0) {\n            result.push_back(temp);\n            temp = \"\
    \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106793
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string>\
    \ separate_paren_groups(std::string paren_string) {\n    std::vector<std::string>\
    \ result;\n    std::stack<char> st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp=\"\";\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: Exception
  stderr: 'tmpdp0l5ca8: /tmp/tmpdp0l5ca8.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<std::string>({(std::string)"(()())", (std::string)"((()))",
    (std::string)"()", (std::string)"((())()())"}))'' failed.

    '
  stdout: ''
  timestamp: 1660106794
