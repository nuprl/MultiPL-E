name: HumanEval_129_minPath
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once\
  \ on the cells of the grid.\n// You have to find the minimum path of length k in\
  \ the grid. You can start\n// from any cell, and in each step you can move to any\
  \ of the neighbor cells,\n// in other words, you can go to cells which share an\
  \ edge with you current\n// cell.\n// Please note that a path of length k means\
  \ visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off\
  \ the grid.\n// A path A (of length k) is considered less than a path B (of length\
  \ k) if\n// after making the ordered lists of the values on the cells that A and\
  \ B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n// than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j]\
  \ = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered\
  \ list of the values on the cells that the minimum path go through.\nstd::vector<long>\
  \ minPath(std::vector<std::vector<long>> grid, long k) {\n"
tests: "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) ==\
  \ (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) ==\
  \ (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6,\
  \ (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11,\
  \ (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15,\
  \ (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5,\
  \ (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16,\
  \ (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14,\
  \ (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1,\
  \ (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8,\
  \ (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4,\
  \ (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7,\
  \ (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10,\
  \ (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1,\
  \ (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11,\
  \ (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15,\
  \ (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10,\
  \ (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6,\
  \ (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12,\
  \ (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9,\
  \ (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8,\
  \ (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1,\
  \ (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2,\
  \ (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}),\
  \ (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}),\
  \ (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1,\
  \ (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10))\
  \ == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1,\
  \ (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10))\
  \ == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3, (long)1, (long)3})));\n}\n"
completions: ["    // Write your code here\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = 0;\n    path[0][0].push_back(grid[0][0]);\n    while (!q.empty()) {\n    \
    \    auto cur = q.front();\n        q.pop();\n        int x = cur.first;\n   \
    \     int y = cur.second;\n        visited[x][y] = 1;\n        for (auto d : dir)\
    \ {\n            int nx = x + d[0];\n            int ny = y + d[1];\n        \
    \    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n            if (visited[nx][ny])\
    \ continue;\n            if (dp[nx][ny] > dp[x][y] + 1) {\n                dp[nx][ny]\
    \ = dp[x][y] + 1;\n                path[nx][ny] = path[x][y];\n              \
    \  path[nx][ny].push_back(grid[nx][ny]);\n                q.push({nx, ny});\n\
    \            } else if (dp[nx][ny] == dp[x][y] + 1) {\n                std::vector<long>\
    \ tmp = path[x][y];\n                tmp.push_back(grid[nx][ny]);\n          \
    \      if (tmp < path[nx][ny]) {\n                    path[nx][", "    int n =\
    \ grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int\
    \ i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n          \
    \      if (i > 0) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i - 1][j][len - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][len] = std::min(dp[i][j][len], dp[i + 1][j][len\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len - 1]);\n         \
    \       }\n                if (j < n - 1) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n                }\n     \
    \           dp[i][j][len] += grid[i][j];\n            }\n        }\n    }\n  \
    \  std::vector<long> ans;\n    long min_val = INT_MAX;\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                ans.clear();\n\
    \                ans.push_back(grid[i][j]);\n            } else if (dp[i][j][k]\
    \ == min_", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k+1, std::vector<long>())));\n    for(int i =\
    \ 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for(int l = 2; l <= k; l++){\n        for(int i = 0; i < n; i++){\n\
    \            for(int j = 0; j < n; j++){\n                std::vector<long> curr;\n\
    \                if(i > 0){\n                    if(dp[i-1][j][l-1] < dp[i][j][l]){\n\
    \                        dp[i][j][l] = dp[i-1][j][l-1];\n                    \
    \    curr = path[i-1][j][l-1];\n                    }\n                }\n   \
    \             if(i < n-1){\n                    if(dp[i+1][j][l-1] < dp[i][j][l]){\n\
    \                        dp[i][j][l] = dp[i+1][j][l-1];\n                    \
    \    curr = path[i+1][j][l-1];\n                    }\n                }\n   \
    \             if(j > 0){\n                    if(dp[i][j-1][l-1] < dp[i][j][l]){\n\
    \                        dp[i][j][l] = dp[i][j-1][l-1];\n                    \
    \    curr = path[i][j-1][l-1];\n                   ", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; ++l)\
    \ {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n;\
    \ ++j) {\n                if (i > 0) {\n                    if (dp[i - 1][j][l\
    \ - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i - 1][j][l\
    \ - 1];\n                        prev[i][j][l][0] = i - 1;\n                 \
    \       prev[i][j][l][1] = j;\n                    }\n                }\n    \
    \            if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n            \
    \            prev[i][j][l][0] = i + 1;\n                        prev[i][j][l][1]\
    \ = j;\n                    }\n                }\n                if (j > 0) {\n\
    \                    if (dp[i][j - 1][l - 1] < dp[i][j][l]) {\n              \
    \          dp[i][j][l] = dp[", "    std::vector<long> res;\n    return res;",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::priority_queue<std::pair<long, std::pair<int, int>>,\n     \
    \                   std::vector<std::pair<long, std::pair<int, int>>>,\n     \
    \                   std::greater<std::pair<long, std::pair<int, int>>>> pq;\n\
    \    std::vector<std::pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    dp[0][0] = grid[0][0];\n    pq.push({grid[0][0], {0, 0}});\n    while\
    \ (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        int\
    \ i = top.second.first;\n        int j = top.second.second;\n        for (auto\
    \ dir : directions) {\n            int x = i + dir.first;\n            int y =\
    \ j + dir.second;\n            if (x < 0 || x >= n || y < 0 || y >= n) continue;\n\
    \            if (dp[x][y] > dp[i][j] + grid[x][y]) {\n                dp[x][y]\
    \ = dp[i][j] + grid[x][y];\n                parent[x][y] = i * n + j;\n      \
    \          pq.push({dp[x][y], {x, y}});\n            }\n        }\n    }\n   \
    \ std::vector<long> ans;\n    int i = n - 1;\n    int j = n - 1;\n    while (k\
    \ > 0) {\n        ans.push_back(grid[i][j]);\n        int p = parent[i][j];\n\
    \        i = p / n;\n        j = p % n;\n        k--;\n    }\n    return ans;",
  "    long n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n, 0));\n\
    \    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::queue<std::pair<long, long>> q;\n    q.push({0, 0});\n    dp[0][0] =\
    \ grid[0][0];\n    while (!q.empty()) {\n        auto curr = q.front();\n    \
    \    q.pop();\n        visited[curr.first][curr.second] = 1;\n        for (auto\
    \ d : dir) {\n            long x = curr.first + d[0];\n            long y = curr.second\
    \ + d[1];\n            if (x < 0 || x >= n || y < 0 || y >= n) {\n           \
    \     continue;\n            }\n            if (visited[x][y]) {\n           \
    \     continue;\n            }\n            if (dp[x][y] > dp[curr.first][curr.second]\
    \ + grid[x][y]) {\n                dp[x][y] = dp[curr.first][curr.second] + grid[x][y];\n\
    \                parent[x][y] = curr.first * n + curr.second;\n            }\n\
    \            q.push({x, y});\n        }\n    }\n    std::vector<long> res;\n \
    \   long curr = n * n - 1;\n    while (curr != -1) {\n        res.push_back(grid[curr\
    \ / n][curr % n]);\n        curr = parent[curr / n][curr % n];\n    }\n    std::reverse(res.begin(),\
    \ res.end());\n    return res;", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, INT_MAX)));\n    for(int i = 0; i < n; i++){\n      \
    \  for(int j = 0; j < n; j++){\n            dp[i][j][1] = grid[i][j];\n      \
    \  }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n\
    \            for(int l = 2; l <= k; l++){\n                if(i > 0){\n      \
    \              dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n       \
    \         }\n                if(j > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j-1][l-1]);\n                }\n                if(i < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n        \
    \        }\n                if(j < n-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j+1][l-1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    std::vector<long> res;\n    int i = 0, j\
    \ = 0;\n    for(int l = 1; l <= k; l++){\n        res.push_back(grid[i][j]);\n\
    \        if(i > 0 && dp[i][j][l] == dp[i-1][j][l-1] + grid[i][j]){\n         \
    \   i--;\n        }\n        else if(j > 0 && dp[i][j][l] == dp[", "    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                dp[i][j]\
    \ = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    path[i][j] = path[i - 1][j];\n      \
    \          } else {\n                    path[i][j] = path[i][j - 1];\n      \
    \          }\n                path[i][j][dp[i][j]] = grid[i][j];\n           \
    \ }\n        }\n    }\n    return path[n - 1][n - 1];", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] < min_val) {\n\
    \                min_val = dp[i][j][k];\n                ans.clear();\n      \
    \          ans.push_back(grid[i][j]);\n            } else if (dp[i][", "    int\
    \ n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][1] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                    path[i][j] = path[i - 1][j];\n                   \
    \ path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n      \
    \              path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                } else {\n                    dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                    path[i][j] = path[i - 1", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = grid[i][j];\n                path[i][j][1] = grid[i][j];\n  \
    \          } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n                for (int l = 2;\
    \ l <= k; l++) {\n                    path[i][j][l] = path[i][j - 1][l - 1];\n\
    \                }\n            } else if (j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n\
    \                for (int l = 2; l <= k; l++) {\n                    path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                }\n            } else {\n        \
    \        dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n     \
    \           if (dp[i - 1][j] < dp[i][j - 1]) {\n                    path[i][j][1]\
    \ = grid[i][j];\n                    for (int l = 2; l <= k; l++) {\n        \
    \                path[i][j][l] = path[i - 1][j][l - 1];\n                    }\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   path[i][j][1]", "    // Write your code here\n    int n = grid.size();\n \
    \   std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n        \
    \        path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j - 1]]\
    \ = grid[i][j];\n            }\n            else if(j == 0) {\n              \
    \  dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n\
    \                path[i][j][dp[i - 1][j]] = grid[i][j];\n            }\n     \
    \       else {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n          \
    \          dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i\
    \ - 1][j];\n                    path[i][j][dp[i - 1][j]] = grid[i][j];\n     \
    \           }\n                else if(dp[i - 1][j] > dp[i][j - 1]) {\n      \
    \              dp[i][j] = dp[i][j - 1] + 1;\n                    path[i][j] =\
    \ path[i][j - 1];\n                    path[i][j][dp[i][j - 1]] = grid[i][j];\n\
    \                }\n                else {\n                    dp[i][j] = d",
  "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for(int i = 0; i < n; i++) {\n   \
    \     for(int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n  \
    \      }\n    }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j <\
    \ m; j++) {\n            for(int len = 2; len <= k; len++) {\n               \
    \ if(i > 0) {\n                    dp[i][j][len] = std::min(dp[i][j][len], dp[i\
    \ - 1][j][len - 1]);\n                }\n                if(j > 0) {\n       \
    \             dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len - 1]);\n\
    \                }\n                if(i < n - 1) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i + 1][j][len - 1]);\n                }\n     \
    \           if(j < m - 1) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i][j + 1][len - 1]);\n                }\n                dp[i][j][len] +=\
    \ grid[i][j];\n            }\n        }\n    }\n    int min_i = 0, min_j = 0;\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n    \
    \        if(dp[i][j][k] < dp[min_i][min_j][k]) {\n                min_i = i;\n\
    \                min_j = j;\n            }\n        }\n    }\n    std::vector<",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, -1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else {\n                if(i > 0)\
    \ {\n                    if(dp[i - 1][j] + 1 < dp[i][j]) {\n                 \
    \       dp[i][j] = dp[i - 1][j] + 1;\n                        for(int l = 0; l\
    \ < k; l++) {\n                            path[i][j][l] = path[i - 1][j][l];\n\
    \                        }\n                        path[i][j][dp[i][j]] = grid[i][j];\n\
    \                    }\n                    else if(dp[i - 1][j] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp(k, -1);\n                \
    \        for(int l = 0; l < k; l++) {\n                            temp[l] = path[i\
    \ - 1][j][l];\n                        }\n                        temp[dp[i][j]]\
    \ = grid[i][j];\n                        if(temp < path[i][j]) {\n           \
    \                 for(int l = 0; l < k; l++) {\n                             \
    \   path[i][j][l] = temp[l];\n                            }\n                \
    \        }\n                    }\n                }\n                if(j > 0)\
    \ {\n                    if(dp[i][j - 1] + 1 < dp[i][j]) {\n                 \
    \       dp[i][j] = dp[i][j - 1] + 1;\n                        for(int l = 0; l\
    \ < k; l++) {", "    // Write your code here\n    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    dp[0][0] = grid[0][0];\n    path[0][0].push_back(grid[0][0]);\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n      \
    \      if(i > 0 && dp[i][j] > dp[i-1][j] + grid[i][j]){\n                dp[i][j]\
    \ = dp[i-1][j] + grid[i][j];\n                path[i][j] = path[i-1][j];\n   \
    \             path[i][j].push_back(grid[i][j]);\n            }\n            if(j\
    \ > 0 && dp[i][j] > dp[i][j-1] + grid[i][j]){\n                dp[i][j] = dp[i][j-1]\
    \ + grid[i][j];\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n        }\n    }\n    return path[n-1][m-1];", "    // Write your\
    \ code here\n    long n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(long\
    \ i = 0; i < n; i++) {\n        for(long j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \                for(long l = 1; l <= k; l++) {\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                }\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ path[i][j][0] = grid[i][j];\n                for(long l = 1; l <= k; l++) {\n\
    \                    path[i][j][l] = path[i - 1][j][l - 1];\n                }\n\
    \            }\n            else {\n                if(dp[i - 1][j] + 1 < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j][0]\
    \ = grid[i][j];\n                    for(long l = 1; l <= k; l++) {\n        \
    \                path[i][j][l] = path[i - 1][j][l - 1];\n                    }\n\
    \                }\n                if(dp[i][j - 1] + 1 < dp[i][j]) {\n      \
    \              dp[i][j] = dp[i][j - 1] + 1;\n                   ", "    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            } else\
    \ if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n     \
    \           path[i][j] = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else {\n                    path[i][j] = path[i][j - 1];\n                }\n\
    \                path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n\
    \    return path[n - 1][n - 1];", "    std::vector<long> ans;\n    long n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ prev(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n\
    \            dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (long len =\
    \ 2; len <= k; len++) {\n        for (long i = 0; i < n; i++) {\n            for\
    \ (long j = 0; j < n; j++) {\n                for (long ni = 0; ni < n; ni++)\
    \ {\n                    for (long nj = 0; nj < n; nj++) {\n                 \
    \       if (abs(ni - i) + abs(nj - j) == 1) {\n                            if\
    \ (dp[ni][nj][len - 1] != -1) {\n                                if (dp[i][j][len]\
    \ == -1 || dp[i][j][len] > dp[ni][nj][len - 1] + grid[i][j]) {\n             \
    \                       dp[i][j][len] = dp[ni][nj][len - 1] + grid[i][j];\n  \
    \                                  prev[i][j][len] = ni * n + nj;\n          \
    \                      }\n                            }\n                    \
    \    }\n                    }\n                }\n            }\n        }\n \
    \   }\n    long min_val = -1;\n    long min_i = -1;\n    long min_j = -1;\n  \
    \  for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n  \
    \          if (dp[i][j][k] != -1) {\n                if (min_val == -1 || min_",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0] =\
    \ grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            if (i > 0) {\n                if (dp[i - 1][j] + grid[i][j]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n \
    \                   for (int l = 0; l < k; l++) {\n                        path[i][j][l]\
    \ = path[i - 1][j][l];\n                    }\n                    path[i][j][i]\
    \ = grid[i][j];\n                }\n            }\n            if (j > 0) {\n\
    \                if (dp[i][j - 1] + grid[i][j] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    for (int l =\
    \ 0; l < k; l++) {\n                        path[i][j][l] = path[i][j - 1][l];\n\
    \                    }\n                    path[i][j][j] = grid[i][j];\n    \
    \            }\n            }\n        }\n    }\n    std::vector<long> result;\n\
    \    for (int i = 0; i < k; i++) {\n        result.push_back(path[n - 1][n - 1][i]);\n\
    \    }\n    return result;", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = 0;\n    path[0][0].push_back(grid[0][0]);\n    while (!q.empty()) {\n    \
    \    auto cur = q.front();\n        q.pop();\n        for (auto d : dir) {\n \
    \           int x = cur.first + d[0];\n            int y = cur.second + d[1];\n\
    \            if (x < 0 || x >= n || y < 0 || y >= m) continue;\n            if\
    \ (visited[x][y]) continue;\n            if (dp[x][y] > dp[cur.first][cur.second]\
    \ + 1) {\n                dp[x][y] = dp[cur.first][cur.second] + 1;\n        \
    \        path[x][y] = path[cur.first][cur.second];\n                path[x][y].push_back(grid[x][y]);\n\
    \                q.push({x, y});\n            } else if (dp[x][y] == dp[cur.first][cur.second]\
    \ + 1) {\n                std::vector<long> tmp = path[cur.first][cur.second];\n\
    \                tmp.push_back(grid[x][y]);\n                if (tmp < path[x][y])\
    \ {\n                    path[x][y] = tmp;\n                    q.push({x, y});\n\
    \                }\n            }\n       ", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n               \
    \     dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i -\
    \ 1][j];\n                    path[i][j][dp[i][j]] = grid[i][j];\n           \
    \     } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j - 1];\n    \
    \                path[i][j][dp[i][j]] = grid[i][j];\n                } else {\n\
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j]\
    \ = path[i - 1", "    // Write your code here\n    // Return an ordered list of\
    \ the values on the cells that the minimum path go through.\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for(int i\
    \ = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n\
    \            for(int l = 2; l <= k; l++) {\n                if(i > 0) {\n    \
    \                if(dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                   \
    \     dp[i][j][l] = dp[i - 1][j][l - 1];\n                        path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if(j > 0) {\n     \
    \               if(dp[i][j - 1][l - 1] < dp[i][j][l]) {\n                    \
    \    dp[i][j][l] = dp[i][j - 1][l - 1];\n                        path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if(i < n", "    //\
    \ Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_k(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int i = 0;\
    \ i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i == 0 &&\
    \ j == 0){\n                dp[i][j] = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \                path_k[i][j].push_back(grid[i][j]);\n            }\n        \
    \    else{\n                if(i > 0){\n                    if(dp[i-1][j] < dp[i][j]){\n\
    \                        dp[i][j] = dp[i-1][j];\n                        path[i][j]\
    \ = path[i-1][j];\n                        path_k[i][j] = path_k[i-1][j];\n  \
    \                  }\n                    else if(dp[i-1][j] == dp[i][j]){\n \
    \                       if(path[i-1][j] < path[i][j]){\n                     \
    \       path[i][j] = path[i-1][j];\n                            path_k[i][j] =\
    \ path_k[i-1][j];\n                        }\n                    }\n        \
    \        }\n                if(j > 0){\n                    if(dp[i][j-1] < dp[i][j]){\n\
    \                        dp[i][j] = dp[i][j-1];\n                        path[i][j]\
    \ = path[i][j-1];\n                        path_k[i][j] = path_k[i][j-1];\n",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j-1] + grid[i][j];\n                parent[i][j] = 1;\n  \
    \          }\n            else if(j == 0) {\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                parent[i][j] = 0;\n            }\n          \
    \  else {\n                if(dp[i-1][j] < dp[i][j-1]) {\n                   \
    \ dp[i][j] = dp[i-1][j] + grid[i][j];\n                    parent[i][j] = 0;\n\
    \                }\n                else {\n                    dp[i][j] = dp[i][j-1]\
    \ + grid[i][j];\n                    parent[i][j] = 1;\n                }\n  \
    \          }\n        }\n    }\n    std::vector<long> ans;\n    int i = n-1, j\
    \ = n-1;\n    while(k--) {\n        ans.push_back(grid[i][j]);\n        if(parent[i][j]\
    \ == 0) {\n            i--;\n        }\n        else {\n            j--;\n   \
    \     }\n    }\n    return ans;", "    std::vector<long> ans;\n    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < n; j++){\n            if(i == 0 && j == 0) continue;\n\
    \            if(i > 0){\n                if(dp[i - 1][j] + grid[i][j] < dp[i][j]){\n\
    \                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                 \
    \   path[i][j] = path[i - 1][j];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n            }\n            if(j > 0){\n                if(dp[i][j\
    \ - 1] + grid[i][j] < dp[i][j]){\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n          \
    \          path[i][j][0] = grid[i][j];\n                }\n            }\n   \
    \     }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n;\
    \ j++){\n            if(i > 0){\n                if(dp[i - 1][j] + grid[i][j]\
    \ == dp[i][j]){\n                    for(int l = 1; l <= k; l++){\n          \
    \              path[i][j][l] = path[i - 1][j][l - 1];\n                    }\n\
    \                }\n            }\n            if(j > 0){", "    std::vector<long>\
    \ ans;\n    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n   \
    \ }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n\
    \            for(int l = 2; l <= k; l++) {\n                long min = LONG_MAX;\n\
    \                if(i - 1 >= 0) {\n                    if(dp[i - 1][j][l - 1]\
    \ != -1) {\n                        min = std::min(min, dp[i - 1][j][l - 1]);\n\
    \                    }\n                }\n                if(i + 1 < n) {\n \
    \                   if(dp[i + 1][j][l - 1] != -1) {\n                        min\
    \ = std::min(min, dp[i + 1][j][l - 1]);\n                    }\n             \
    \   }\n                if(j - 1 >= 0) {\n                    if(dp[i][j - 1][l\
    \ - 1] != -1) {\n                        min = std::min(min, dp[i][j - 1][l -\
    \ 1]);\n                    }\n                }\n                if(j + 1 < m)\
    \ {\n                    if(dp[i][j + 1][l - 1] != -1) {\n                   \
    \     min = std::min(min, dp[i][j + 1][l - 1]);\n                    }\n     \
    \           }\n                if(min != LONG_MAX) {\n                    dp[i][j][l]\
    \ = min + grid[i][j];\n                }\n            }\n        }\n    }\n  \
    \  long min = LONG_MAX;\n    for(int i = 0; i < n; i++) {\n       ", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n \
    \           if(i == 0 && j == 0)\n            {\n                dp[i][j] = grid[i][j];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\n\
    \            {\n                if(i > 0)\n                {\n               \
    \     if(dp[i - 1][j] + grid[i][j] < dp[i][j])\n                    {\n      \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \     path[i][j] = path[i - 1][j];\n                    }\n                  \
    \  else if(dp[i - 1][j] + grid[i][j] == dp[i][j])\n                    {\n   \
    \                     if(path[i - 1][j] < path[i][j])\n                      \
    \  {\n                            path[i][j] = path[i - 1][j];\n             \
    \           }\n                    }\n                }\n                if(j\
    \ > 0)\n                {\n                    if(dp[i][j - 1] + grid[i][j] <\
    \ dp[i][j])\n                    {\n                        dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j];\n                        path[i][j] = path[i][j - 1];\n \
    \                   }\n                    else if(dp[i][j - 1] + grid[i][j] ==\
    \ dp[i][j])\n                    {\n                        if(path[i][j - 1]\
    \ < path[i][j])\n                        {\n                            path[i][j]\
    \ = path[i][j - 1];\n                        }\n                   ", "    std::vector<long>\
    \ ans;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1;\n  \
    \  int min_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val\
    \ = dp[i][j][k];\n                min_i = i;\n                min_j = j;\n   \
    \         }\n        }\n   ", "    std::vector<long> result;\n    // Implement\
    \ the solution here\n    return result;", "    // Write your code here\n    int\
    \ n = grid.size();\n    vector<vector<long>> dp(n, vector<long>(n, INT_MAX));\n\
    \    vector<vector<long>> path(n, vector<long>(n, -1));\n    for(int i = 0; i\
    \ < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 &&\
    \ j == 0) {\n                dp[i][j] = 0;\n                path[i][j] = grid[i][j];\n\
    \            }\n            else if(i == 0) {\n                dp[i][j] = dp[i][j-1]\
    \ + 1;\n                path[i][j] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i-1][j] + 1;\n                path[i][j]\
    \ = grid[i][j];\n            }\n            else {\n                if(dp[i-1][j]\
    \ < dp[i][j-1]) {\n                    dp[i][j] = dp[i-1][j] + 1;\n          \
    \          path[i][j] = grid[i][j];\n                }\n                else if(dp[i-1][j]\
    \ > dp[i][j-1]) {\n                    dp[i][j] = dp[i][j-1] + 1;\n          \
    \          path[i][j] = grid[i][j];\n                }\n                else {\n\
    \                    dp[i][j] = dp[i-1][j] + 1;\n                    path[i][j]\
    \ = min(grid[i][j], path[i-1][j]);\n                }\n            }\n       \
    \ }\n    }\n    vector<long> ans;\n    int i = n-1, j = n-1;\n    while(k > 0)\
    \ {\n        ans.push_back(path[i][j]);\n        if(i == 0) {\n            j--;\n\
    \        }\n        else if(j == 0) {\n            i--;\n        }\n       ",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(k + 1, -1))));\n   \
    \ for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n       \
    \     dp[i][j][1] = grid[i][j];\n            parent[i][j][1][0] = grid[i][j];\n\
    \        }\n    }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j\
    \ < n; j++) {\n            for(int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ temp;\n                if(i - 1 >= 0) {\n                    if(dp[i - 1][j][l\
    \ - 1] != -1) {\n                        temp.push_back(dp[i - 1][j][l - 1]);\n\
    \                    }\n                }\n                if(i + 1 < n) {\n \
    \                   if(dp[i + 1][j][l - 1] != -1) {\n                        temp.push_back(dp[i\
    \ + 1][j][l - 1]);\n                    }\n                }\n               \
    \ if(j - 1 >= 0) {\n                    if(dp[i][j - 1][l - 1] != -1) {\n    \
    \                    temp.push_back(dp[i][j - 1][l - 1]);\n                  \
    \  }\n                }\n                if(j + 1 < n) {\n                   \
    \ if(dp[i][j + 1][l - 1] != -1) {\n                        temp.push_back(dp[i][j\
    \ + 1][l - 1]);\n                    }\n                }\n                if(temp.size()\
    \ == 0) {\n", "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][0] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][", "    // Write your code here\n    long n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<long>> path(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>>\
    \ prev(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>> next(n,\
    \ std::vector<long>(n, -1));\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j]\
    \ = grid[i][j];\n        }\n    }\n    for(long i = 0; i < n; i++) {\n       \
    \ for(long j = 0; j < n; j++) {\n            if(i > 0) {\n                if(dp[i\
    \ - 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j];\n      \
    \              prev[i][j] = i - 1;\n                    next[i - 1][j] = i;\n\
    \                }\n            }\n            if(j > 0) {\n                if(dp[i][j\
    \ - 1] < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1];\n         \
    \           prev[i][j] = j - 1;\n                    next[i][j - 1] = j;\n   \
    \             }\n            }\n        }\n    }\n    long curr = 0;\n    for(long\
    \ i = 0; i < n; i++) {\n        if(dp[curr][i] > dp[i][curr]) {\n            curr\
    \ = i;\n        }\n    }\n    std::vector<long> ans;\n    for(long i = 0; i <\
    \ k; i++) {\n        ans.push_back(path[curr][curr]);\n        long temp = curr;\n\
    \        curr = next[curr][", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> path(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> dir =\
    \ {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j]\
    \ = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            for(int d = 0; d < 4; d++) {\n           \
    \     int x = i + dir[d][0];\n                int y = j + dir[d][1];\n       \
    \         if(x >= 0 && x < n && y >= 0 && y < n) {\n                    if(dp[x][y]\
    \ > dp[i][j]) {\n                        dp[x][y] = dp[i][j];\n              \
    \          path[x][y] = i * n + j;\n                    }\n                }\n\
    \            }\n        }\n    }\n    int x = 0, y = 0;\n    for(int i = 0; i\
    \ < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(dp[i][j] <\
    \ dp[x][y]) {\n                x = i;\n                y = j;\n            }\n\
    \        }\n    }\n    while(k > 0) {\n        ans.push_back(grid[x][y]);\n  \
    \      visited[x][y] = 1;\n        k--;\n        int p = path[x][y];\n       \
    \ if(p == -1) {\n            break;\n        }\n       ", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<std::vector<long>>> parent_path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ dp_path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, INT_MAX)));\n\
    \    dp[0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < n; j++){\n            if(i - 1 >= 0){\n                if(dp[i][j]\
    \ > dp[i - 1][j] + grid[i][j]){\n                    dp[i][j] = dp[i - 1][j] +\
    \ grid[i][j];\n                    parent[i][j] = 1;\n                }\n    \
    \        }\n            if(j - 1 >= 0){\n                if(dp[i][j] > dp[i][j\
    \ - 1] + grid[i][j]){\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    parent[i][j] = 2;\n                }\n            }\n   \
    \     }\n    }\n    int curr_i = n - 1;\n    int curr_j = n - 1;\n    int curr_k\
    \ = k - 1;\n    std::vector<long> ans(k, -1);\n    while(curr_k >= 0){\n     \
    \   ans[curr_k] = grid[curr_i][curr_j];\n        if(parent[curr_i][curr_j] ==\
    \ 1){\n            curr_i--;\n        }\n        else if(parent[curr_i][curr",
  "    std::vector<long> ans;\n    long n = grid.size();\n    long m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k, 0)));\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < m; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n        \
    \        path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j - 1]]\
    \ = grid[i][j];\n            }\n            else if(j == 0) {\n              \
    \  dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n\
    \                path[i][j][dp[i - 1][j]] = grid[i][j];\n            }\n     \
    \       else {\n                if(dp[i - 1][j] + 1 < dp[i][j]) {\n          \
    \          dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i\
    \ - 1][j];\n                    path[i][j][dp[i - 1][j]] = grid[i][j];\n     \
    \           }\n                if(dp[i][j - 1] + 1 < dp[i][j]) {\n           \
    \         dp[i][j] = dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j][dp[i][j - 1]] = grid[i][j];\n        \
    \        }\n           ", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n    ans.push_back(grid[i][j]);\n\
    \    for (int l = 2; l <= k; l++) {\n        if (i > 0 && dp[i][j][l] == dp[i\
    \ - 1][j][l - 1] + grid[i][j]) {\n            ans.push_back(grid[i - 1][j]);\n\
    \            i--;\n        } else if", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, INT_MAX)));\n    for(int i = 0; i < n; i++){\n      \
    \  for(int j = 0; j < n; j++){\n            dp[i][j][1] = grid[i][j];\n      \
    \  }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n\
    \            for(int l = 2; l <= k; l++){\n                if(i > 0){\n      \
    \              dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n       \
    \         }\n                if(j > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j-1][l-1]);\n                }\n                if(i < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n        \
    \        }\n                if(j < n-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j+1][l-1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min = INT_MAX;\n    int x = 0, y =\
    \ 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n \
    \           if(dp[i][j][k] < min){\n                min = dp[i][j][k];\n     \
    \           x = i;\n                y = j;\n            }\n        }\n    }\n\
    \    std::vector<long> ans;\n    ans.push_back(grid", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<std::vector<long>>> dp_path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<std::vector<int>>>>\
    \ parent_path(n, std::vector<std::vector<std::vector<int>>>(n, std::vector<std::vector<int>>(k\
    \ + 1, std::vector<int>(2, -1))));\n    dp[0][0] = grid[0][0];\n    dp_path[0][0][1]\
    \ = grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < n; j++) {\n            if (i > 0) {\n                if (dp[i][j] > dp[i -\
    \ 1][j] + grid[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    parent[i][j] = 0;\n                }\n            }\n   \
    \         if (j > 0) {\n                if (dp[i][j] > dp[i][j - 1] + grid[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n             \
    \       parent[i][j] = 1;\n                }\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          for (int l = 1; l <= k; l++) {\n                if (i > 0) {\n    \
    \                if (dp_path[i][j][l] > dp_path[i - 1][j][l -", "    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j][1] = grid[i][j];\n     \
    \           path[i][j][1].push_back(grid[i][j]);\n            }\n            for\
    \ (int l = 1; l <= k; l++) {\n                for (int d = 0; d < 4; d++) {\n\
    \                    int x = i + dir[d][0];\n                    int y = j + dir[d][1];\n\
    \                    if (x >= 0 && x < n && y >= 0 && y < m && dp[x][y][l - 1]\
    \ != -1) {\n                        if (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l\
    \ - 1] + grid[i][j]) {\n                            dp[i][j][l] = dp[x][y][l -\
    \ 1] + grid[i][j];\n                            path[i][j][l] = path[x][y][l -\
    \ 1];\n                            path[i][j][l].push_back(grid[i][j]);\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n    }\n    return path[n - 1", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j] = path[i][j-1];\n                path[i][j][0] = grid[i][j];\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = path[i-1][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else {\n                if(dp[i-1][j]\
    \ < dp[i][j-1]) {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n \
    \                   path[i][j] = path[i-1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else if(dp[i-1][j] > dp[i][j-1])\
    \ {\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n               \
    \     path[i][j] = path[i][j-1];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n                else {\n                    dp[i][j] = dp[i",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> path(n, std::vector<int>(n, 0));\n \
    \   std::vector<long> ans;\n    dp[0][0] = grid[0][0];\n    for(int i = 0; i <\
    \ n; i++){\n        for(int j = 0; j < n; j++){\n            if(i == 0 && j ==\
    \ 0) continue;\n            if(i > 0){\n                if(dp[i][j] > dp[i-1][j]\
    \ + grid[i][j]){\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n  \
    \                  parent[i][j] = 0;\n                }\n            }\n     \
    \       if(j > 0){\n                if(dp[i][j] > dp[i][j-1] + grid[i][j]){\n\
    \                    dp[i][j] = dp[i][j-1] + grid[i][j];\n                   \
    \ parent[i][j] = 1;\n                }\n            }\n        }\n    }\n    int\
    \ i = n-1, j = n-1;\n    while(i != 0 || j != 0){\n        if(parent[i][j] ==\
    \ 0){\n            path[i][j] = 1;\n            i--;\n        }\n        else{\n\
    \            path[i][j] = 1;\n            j--;\n        }\n    }\n    path[0][0]\
    \ = 1;\n    int curr = 0;\n    for(int i = 0; i < n; i++){\n        for(int j\
    \ = 0; j < n; j++){\n            if(path[i][j] == 1){\n                cur", " \
    \   // Write your code here\n    long n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> parent(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n,\
    \ 0));\n    std::vector<std::vector<long>> path;\n    std::vector<long> ans;\n\
    \    dp[0][0] = grid[0][0];\n    for(long i = 0; i < n; i++){\n        for(long\
    \ j = 0; j < n; j++){\n            if(i - 1 >= 0){\n                if(dp[i][j]\
    \ > dp[i - 1][j] + grid[i][j]){\n                    dp[i][j] = dp[i - 1][j] +\
    \ grid[i][j];\n                    parent[i][j] = 0;\n                }\n    \
    \        }\n            if(j - 1 >= 0){\n                if(dp[i][j] > dp[i][j\
    \ - 1] + grid[i][j]){\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    parent[i][j] = 1;\n                }\n            }\n   \
    \         if(i + 1 < n){\n                if(dp[i][j] > dp[i + 1][j] + grid[i][j]){\n\
    \                    dp[i][j] = dp[i + 1][j] + grid[i][j];\n                 \
    \   parent[i][j] = 2;\n                }\n            }\n            if(j + 1\
    \ < n){\n                if(dp[i][j] > dp[i][j + 1] + grid[i][j]){\n         \
    \           dp[i][j] = dp[i][j + 1] + grid[i][j];\n                    parent[i][j]\
    \ = 3;\n                }\n            }\n        }\n    }\n    long i = n - 1;\n\
    \    long", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::queue<std::pair<int, int>> q;\n    dp[0][0] = grid[0][0];\n \
    \   q.push({0, 0});\n    while (!q.empty()) {\n        auto cur = q.front();\n\
    \        q.pop();\n        for (auto d : dir) {\n            int x = cur.first\
    \ + d[0];\n            int y = cur.second + d[1];\n            if (x < 0 || x\
    \ >= n || y < 0 || y >= n) continue;\n            if (visited[x][y]) continue;\n\
    \            if (dp[x][y] > dp[cur.first][cur.second] + grid[x][y]) {\n      \
    \          dp[x][y] = dp[cur.first][cur.second] + grid[x][y];\n              \
    \  path[x][y] = cur.first * n + cur.second;\n                q.push({x, y});\n\
    \            }\n        }\n        visited[cur.first][cur.second] = 1;\n    }\n\
    \    std::vector<long> res;\n    int cur = n * n - 1;\n    for (int i = 0; i <\
    \ k; ++i) {\n        res.push_back(grid[cur / n][cur % n]);\n        cur = path[cur\
    \ / n][cur % n];\n    }\n    std::reverse(res.begin(), res.end());\n    return\
    \ res;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k;\
    \ l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j\
    \ < n; j++) {\n                int min = INT_MAX;\n                int min_i =\
    \ -1;\n                int min_j = -1;\n                if (i > 0) {\n       \
    \             if (dp[i - 1][j][l - 1] < min) {\n                        min =\
    \ dp[i - 1][j][l - 1];\n                        min_i = i - 1;\n             \
    \           min_j = j;\n                    }\n                }\n           \
    \     if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1] < min) {\n\
    \                        min = dp[i + 1][j][l - 1];\n                        min_i\
    \ = i + 1;\n                        min_j = j;\n                    }\n      \
    \          }\n                if (j > 0) {\n                    if (dp[i][j -\
    \ 1][l - 1] < min) {\n                        min = dp[i][j - 1][l - 1];\n   \
    \                     min_i = i;\n                        min_j = j - 1;\n   \
    \                 }\n                }\n                if (j < n - 1) {\n   \
    \                 if (dp[i][j + 1][l - 1] < min) {\n                        min\
    \ = dp[i][j + 1][l - 1];", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    for(int i = 0; i < n; i++){\n        for(int j =\
    \ 0; j < m; j++){\n            if(i == 0 && j == 0){\n                dp[i][j]\
    \ = 0;\n                path[i][j].push_back(grid[i][j]);\n            }\n   \
    \         else{\n                if(i > 0){\n                    if(dp[i - 1][j]\
    \ + 1 < dp[i][j]){\n                        dp[i][j] = dp[i - 1][j] + 1;\n   \
    \                     path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i - 1][j] + 1 == dp[i][j]){\n\
    \                        std::vector<long> temp = path[i - 1][j];\n          \
    \              temp.push_back(grid[i][j]);\n                        if(temp <\
    \ path[i][j]){\n                            path[i][j] = temp;\n             \
    \           }\n                    }\n                }\n                if(j\
    \ > 0){\n                    if(dp[i][j - 1] + 1 < dp[i][j]){\n              \
    \          dp[i][j] = dp[i][j - 1] + 1;\n                        path[i][j] =\
    \ path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i][j - 1] + 1 == dp[i][j]){\n\
    \                        std::vector<long> temp = path[i][j - 1];\n          \
    \              temp.push_back(grid[i][j]);\n                        if(temp <",
  "    std::vector<long> ans;\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < m) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n            }\n        }\n    }\n\
    \    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            min_val = std::min(min_val, dp[i][j][k]);\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            if (dp[i][j][k]", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0] =\
    \ grid[0][0];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n;\
    \ j++){\n            if(i == 0 && j == 0) continue;\n            if(i > 0){\n\
    \                if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n                   \
    \ dp[i][j] = dp[i-1][j] + grid[i][j];\n                    path[i][j] = path[i-1][j];\n\
    \                    path[i][j][0] = grid[i][j];\n                }\n        \
    \        else if(dp[i][j] == dp[i-1][j] + grid[i][j]){\n                    std::vector<long>\
    \ tmp = path[i-1][j];\n                    tmp[0] = grid[i][j];\n            \
    \        if(tmp < path[i][j]){\n                        path[i][j] = tmp;\n  \
    \                  }\n                }\n            }\n            if(j > 0){\n\
    \                if(dp[i][j] > dp[i][j-1] + grid[i][j]){\n                   \
    \ dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j] = path[i][j-1];\n\
    \                    path[i][j][0] = grid[i][j];\n                }\n        \
    \        else if(dp[i][j] == dp[i][j-1] + grid[i][j]){\n                    std::vector<long>\
    \ tmp = path[i][j-1];\n                    tmp[0]", "    // Write your code here\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else {\n                if(i > 0 && dp[i - 1][j] !=\
    \ -1) {\n                    if(dp[i][j] == -1 || dp[i - 1][j] + 1 < dp[i][j])\
    \ {\n                        dp[i][j] = dp[i - 1][j] + 1;\n                  \
    \      path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i - 1][j] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp = path[i - 1][j];\n      \
    \                  temp.push_back(grid[i][j]);\n                        if(temp\
    \ < path[i][j]) {\n                            path[i][j] = temp;\n          \
    \              }\n                    }\n                }\n                if(j\
    \ > 0 && dp[i][j - 1] != -1) {\n                    if(dp[i][j] == -1 || dp[i][j\
    \ - 1] + 1 < dp[i][j]) {\n                        dp[i][j] = dp[i][j - 1] + 1;\n\
    \                        path[i][j] = path[i][j - 1];\n                      \
    \  path[i][j].push_back(grid[i][j]);\n                    }\n                \
    \    else if(dp[i][j - 1", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> path(n, std::vector<int>(n, 0));\n \
    \   std::vector<int> dx = {-1, 0, 1, 0};\n    std::vector<int> dy = {0, 1, 0,\
    \ -1};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    visited[0][0] = 1;\n    while (!q.empty()) {\n        auto\
    \ [x, y] = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n\
    \            int nx = x + dx[i];\n            int ny = y + dy[i];\n          \
    \  if (nx < 0 || nx >= n || ny < 0 || ny >= n) {\n                continue;\n\
    \            }\n            if (visited[nx][ny]) {\n                continue;\n\
    \            }\n            if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n    \
    \            dp[nx][ny] = dp[x][y] + grid[nx][ny];\n                parent[nx][ny]\
    \ = i;\n            }\n            q.push({nx, ny});\n            visited[nx][ny]\
    \ = 1;\n        }\n    }\n    int x = n - 1;\n    int y = n - 1;\n    int cnt\
    \ = 0;\n    while (x != 0 || y != 0) {\n        path[x][y] = 1;\n        cnt++;\n\
    \        int p = parent[x][y];\n        x -= dx[p];\n        y -= dy[p];\n", " \
    \   // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(n * n + 1, -1)));\n\
    \    std::vector<std::vector<std::vector<long>>> path_idx(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(n * n + 1, -1)));\n    for (int i = 0; i < n; i++) {\n   \
    \     for (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n    \
    \        path[i][j][1] = grid[i][j];\n            path_idx[i][j][1] = i * n +\
    \ j;\n        }\n    }\n    for (int len = 2; len <= k; len++) {\n        for\
    \ (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n     \
    \           if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j];\n                    path[i][j][len] = path[i - 1][j][len -\
    \ 1];\n                    path_idx[i][j][len] = path_idx[i - 1][j][len - 1];\n\
    \                }\n                if (i < n - 1 && dp[i + 1][j] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i + 1][j];\n                    path[i][j][len]\
    \ = path[i + 1][j][len - 1];\n                    path_idx[i][j][len] = path_idx[i\
    \ + 1][j][len - 1];\n                }\n                if (j > 0 && dp[i][j -\
    \ 1] < dp[i][j])", "    // Write your code here\n    int n = grid.size();\n  \
    \  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;\
    \ j++) {\n            for (int l = 2; l <= k; l++) {\n                if (i >\
    \ 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n               \
    \         if (dp[i][j][l] == -1) {\n                            dp[i][j][l] =\
    \ dp[i - 1][j][l - 1] + grid[i][j];\n                        } else {\n      \
    \                      dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1]\
    \ + grid[i][j]);\n                        }\n                    }\n         \
    \       }\n                if (j > 0) {\n                    if (dp[i][j - 1][l\
    \ - 1] != -1) {\n                        if (dp[i][j][l] == -1) {\n          \
    \                  dp[i][j][l] = dp[i][j - 1][l - 1] + grid[i][j];\n         \
    \               } else {\n                            dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1] + grid[i][j]);\n                        }\n            \
    \        }\n                }\n                if (i < n - 1) {\n            \
    \        if (dp[i + 1][j][l - 1] != -1) {\n                        if (dp[i][j][l]\
    \ == -1) {\n                            dp[i][j][l] = dp[i", "    std::vector<long>\
    \ ans;\n    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else {\n                if(i > 0)\
    \ {\n                    if(dp[i - 1][j] + 1 < dp[i][j]) {\n                 \
    \       dp[i][j] = dp[i - 1][j] + 1;\n                        path[i][j] = path[i\
    \ - 1][j];\n                        path[i][j][dp[i][j]] = grid[i][j];\n     \
    \               }\n                    else if(dp[i - 1][j] + 1 == dp[i][j]) {\n\
    \                        std::vector<long> temp = path[i - 1][j];\n          \
    \              temp[dp[i][j]] = grid[i][j];\n                        if(temp <\
    \ path[i][j]) {\n                            path[i][j] = temp;\n            \
    \            }\n                    }\n                }\n                if(j\
    \ > 0) {\n                    if(dp[i][j - 1] + 1 < dp[i][j]) {\n            \
    \            dp[i][j] = dp[i][j - 1] + 1;\n                        path[i][j]\
    \ = path[i][j - 1];\n                        path[i][j][dp[i][j]] = grid[i][j];\n\
    \                    }\n                    else if(dp[i][j - 1] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp = path[i][j - 1];\n      \
    \                  temp[dp[i", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, LONG_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ prev(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          dp[i][j] = grid[i][j];\n            prev[i][j][1] = grid[i][j];\n \
    \       }\n    }\n    for (int step = 2; step <= k; ++step) {\n        for (int\
    \ i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n          \
    \      for (int d = 0; d < 4; ++d) {\n                    int x = i + dir[d][0];\n\
    \                    int y = j + dir[d][1];\n                    if (x < 0 ||\
    \ x >= n || y < 0 || y >= n) continue;\n                    if (dp[x][y] + grid[i][j]\
    \ < dp[i][j]) {\n                        dp[i][j] = dp[x][y] + grid[i][j];\n \
    \                       prev[i][j][step] = grid[i][j];\n                    }\n\
    \                }\n            }\n        }\n    }\n    int min_i = 0, min_j\
    \ = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\
    \ {\n            if (dp[i][j] < dp[min_i][min_j]) {\n                min_i = i;\n\
    \                min_j = j;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[min_", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path;\n    std::vector<long> ans;\n    int\
    \ x = 0, y = 0;\n    dp[0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < n; j++){\n            if(i > 0 && dp[i][j] > dp[i-1][j]\
    \ + grid[i][j]){\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n      \
    \          parent[i][j] = 0;\n            }\n            if(j > 0 && dp[i][j]\
    \ > dp[i][j-1] + grid[i][j]){\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                parent[i][j] = 1;\n            }\n            if(i < n-1 && dp[i][j]\
    \ > dp[i+1][j] + grid[i][j]){\n                dp[i][j] = dp[i+1][j] + grid[i][j];\n\
    \                parent[i][j] = 2;\n            }\n            if(j < n-1 && dp[i][j]\
    \ > dp[i][j+1] + grid[i][j]){\n                dp[i][j] = dp[i][j+1] + grid[i][j];\n\
    \                parent[i][j] = 3;\n            }\n        }\n    }\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < n;", "    std::vector<long>\
    \ res;\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    std::vector<std::vector<long>> prev(grid.size(), std::vector<long>(grid[0].size(),\
    \ -1));\n    std::vector<std::vector<long>> prev_x(grid.size(), std::vector<long>(grid[0].size(),\
    \ -1));\n    std::vector<std::vector<long>> prev_y(grid.size(), std::vector<long>(grid[0].size(),\
    \ -1));\n    dp[0][0] = grid[0][0];\n    for (int i = 0; i < grid.size(); i++)\
    \ {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (i > 0)\
    \ {\n                if (dp[i - 1][j] + grid[i][j] < dp[i][j]) {\n           \
    \         dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    prev[i][j]\
    \ = 0;\n                    prev_x[i][j] = i - 1;\n                    prev_y[i][j]\
    \ = j;\n                }\n            }\n            if (j > 0) {\n         \
    \       if (dp[i][j - 1] + grid[i][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n                    prev[i][j] = 1;\n        \
    \            prev_x[i][j] = i;\n                    prev_y[i][j] = j - 1;\n  \
    \              }\n            }\n        }\n    }\n    int x = grid.size() - 1;\n\
    \    int y = grid[0].size() - 1;\n    for (int i = 0; i < k - 1; i++) {\n    \
    \    x = prev_x[x][y];\n        y = prev_y[x][y];\n    }\n    for (int i = 0;\
    \ i < k; i++) {\n", "    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(grid.size(), std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n\
    \    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size();\
    \ j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n\
    \                path[i][j].push_back(grid[i][j]);\n            }\n          \
    \  else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                path[i][j] = path[i - 1][j];\n      \
    \          path[i][j].push_back(grid[i][j]);\n            }\n            else\
    \ {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                    path[i][j].push_back(grid[i][j]);\n                }\n  \
    \              else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j - 1];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    int i = grid.size() -\
    \ 1;\n    int j", "    // Write your code here\n    long n = grid.size();\n  \
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>>\
    \ parent(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>> visited(n,\
    \ std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::priority_queue<std::pair<long, std::pair<long,\
    \ long>>,\n                         std::vector<std::pair<long, std::pair<long,\
    \ long>>>,\n                         std::greater<std::pair<long, std::pair<long,\
    \ long>>>>\n        pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n\
    \    while (!pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n  \
    \      long x = p.second.first;\n        long y = p.second.second;\n        visited[x][y]\
    \ = 1;\n        for (auto d : dir) {\n            long new_x = x + d[0];\n   \
    \         long new_y = y + d[1];\n            if (new_x >= 0 && new_x < n && new_y\
    \ >= 0 && new_y < n &&\n                !visited[new_x][new_y]) {\n          \
    \      if (dp[new_x][new_y] > dp[x][y] + grid[new_x][new_y]) {\n             \
    \       dp[new_x][new_y] = dp[x][y] + grid[new_x][new_y];\n                  \
    \  parent[new_x][new_y] = x * n + y;\n                    pq.push({dp[new_x][new_y],\
    \ {new_x, new_y}});\n                }\n            }\n        }\n    }\n    long\
    \ min_sum = INT_", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n\
    \                if (dp[i - 1][j] < dp[i][j - 1]) {\n                    path[i][j]\
    \ = path[i - 1][j];\n                } else {\n                    path[i][j]\
    \ = path[i][j - 1];\n                }\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            }\n        }\n    }\n    return path[n - 1][n - 1];",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                if (i > 0) {\n\
    \                    if (dp[i - 1][j][l - 1] != -1) {\n                      \
    \  if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n           \
    \                 dp[i][j][l] = dp[i - 1][j][l - 1];\n                       \
    \     path[i][j][l] = path[i - 1][j][l - 1];\n                            path[i][j][l].push_back(grid[i][j]);\n\
    \                        }\n                    }\n                }\n       \
    \         if (j > 0) {\n                    if (dp[i][j - 1][l - 1] != -1) {\n\
    \                        if (dp[i][j][l] == -1 || dp[i][j - 1][l - 1] < dp[i][j][l])\
    \ {\n                            dp[i][j][l] = dp[i][j - 1][l - 1];\n        \
    \                    path[i][j][", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n    for\
    \ (int l = 1; l <= k; l++) {\n        ans.push_back(grid[i][j]);\n        if (i\
    \ > 0 && dp[i][j][l] == dp[i - 1][j][l - 1] + grid[i][j]) {\n            i--;\n\
    \        } else if (j > 0 && dp[i][j][l] == d", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][1] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n        \
    \        path[i][j][1] = grid[i][j];\n            }\n            else {\n    \
    \            dp[i][j] = std::min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n     \
    \           path[i][j][1] = grid[i][j];\n            }\n        }\n    }\n   \
    \ for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n       \
    \     for(int l = 2; l <= k; l++) {\n                if(i == 0 && j == 0) {\n\
    \                    dp[i][j] = grid[i][j];\n                    path[i][j][l]\
    \ = grid[i][j];\n                }\n                else if(i == 0) {\n      \
    \              dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j][l]\
    \ = grid[i][j];\n                }\n                else if(j ==", "    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(m, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::priority_queue<std::pair<long, std::pair<int,\
    \ int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long,\
    \ std::pair<int, int>>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0]\
    \ = grid[0][0];\n    while(!pq.empty()) {\n        auto top = pq.top();\n    \
    \    pq.pop();\n        int x = top.second.first;\n        int y = top.second.second;\n\
    \        long val = top.first;\n        if(val > dp[x][y]) {\n            continue;\n\
    \        }\n        for(int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if(nx < 0 || nx >= n || ny <\
    \ 0 || ny >= m) {\n                continue;\n            }\n            if(dp[nx][ny]\
    \ > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny] = dp[x][y] + grid[nx][ny];\n\
    \                parent[nx][ny] = i;\n                pq.push({dp[nx][ny], {nx,\
    \ ny}});\n            }\n        }\n    }\n    std::vector<long> ans;\n    int\
    \ x = n - 1;\n    int y = m - 1;\n    while(k > 0) {\n        ans", "    int n\
    \ = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n   \
    \ }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n\
    \            for (int l = 2; l <= k; l++) {\n                for (int d = 0; d\
    \ < 4; d++) {\n                    int x = i + dir[d][0];\n                  \
    \  int y = j + dir[d][1];\n                    if (x >= 0 && x < n && y >= 0 &&\
    \ y < n && dp[x][y][l - 1] != -1) {\n                        if (dp[i][j][l] ==\
    \ -1 || dp[i][j][l] > dp[x][y][l - 1] + grid[i][j]) {\n                      \
    \      dp[i][j][l] = dp[x][y][l - 1] + grid[i][j];\n                         \
    \   path[i][j][l] = d;\n                        }\n                    }\n   \
    \             }\n            }\n        }\n    }\n    int x = 0, y = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (dp[x][y][k] == -1 || dp[x][y][k] > dp", "    // Write your code here\n\
    \    std::vector<long> result;\n    std::vector<std::vector<long>> dp(grid.size(),\
    \ std::vector<long>(grid[0].size(), 0));\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n            } else\
    \ if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n      \
    \      } else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \            } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + grid[i][j];\n            }\n        }\n    }\n    int i = grid.size()\
    \ - 1;\n    int j = grid[0].size() - 1;\n    while(k > 0) {\n        result.push_back(grid[i][j]);\n\
    \        if(i == 0 && j == 0) {\n            break;\n        } else if(i == 0)\
    \ {\n            j--;\n        } else if(j == 0) {\n            i--;\n       \
    \ } else {\n            if(dp[i - 1][j] < dp[i][j - 1]) {\n                i--;\n\
    \            } else {\n                j--;\n            }\n        }\n      \
    \  k--;\n    }\n    return result;", "    int n = grid.size();\n    std::vector<long>\
    \ res;\n    if (k == 1) {\n        res.push_back(grid[0][0]);\n        return\
    \ res;\n    }\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, LONG_MAX));\n\
    \    dp[0][0] = grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i > 0) {\n                dp[i][j] = std::min(dp[i][j],\
    \ dp[i - 1][j] + grid[i][j]);\n            }\n            if (j > 0) {\n     \
    \           dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n      \
    \      }\n        }\n    }\n    std::vector<std::vector<long>> dp2(n, std::vector<long>(n,\
    \ LONG_MAX));\n    dp2[0][0] = grid[0][0];\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < n; j++) {\n            if (i > 0) {\n           \
    \     dp2[i][j] = std::min(dp2[i][j], dp2[i - 1][j] + grid[i][j]);\n         \
    \   }\n            if (j > 0) {\n                dp2[i][j] = std::min(dp2[i][j],\
    \ dp2[i][j - 1] + grid[i][j]);\n            }\n        }\n    }\n    std::vector<std::vector<long>>\
    \ dp3(n, std::vector<long>(n, LONG_MAX));\n    dp3[0][0] = grid[0][0];\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i > 0) {\n                dp3[i][", "    // Write your code here\n   \
    \ int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else {\n                if(i > 0) {\n                    if(dp[i - 1][j] +\
    \ 1 < dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j] + 1;\n    \
    \                    path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i - 1][j] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp = path[i - 1][j];\n      \
    \                  temp.push_back(grid[i][j]);\n                        if(temp\
    \ < path[i][j]) {\n                            path[i][j] = temp;\n          \
    \              }\n                    }\n                }\n                if(j\
    \ > 0) {\n                    if(dp[i][j - 1] + 1 < dp[i][j]) {\n            \
    \            dp[i][j] = dp[i][j - 1] + 1;\n                        path[i][j]\
    \ = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i][j - 1] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp = path[i][j - 1];\n      \
    \                  temp.push_back(grid[i][j]);\n                        if(temp\
    \ < path[i][j])", "    std::vector<long> result;\n    // Write your code here\n\
    \    return result;", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<std::vector<int>>\
    \ parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>> path;\n\
    \    dp[0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < n; j++){\n            if(i - 1 >= 0){\n                if(dp[i][j]\
    \ > dp[i - 1][j] + grid[i][j]){\n                    dp[i][j] = dp[i - 1][j] +\
    \ grid[i][j];\n                    parent[i][j] = 0;\n                }\n    \
    \        }\n            if(j - 1 >= 0){\n                if(dp[i][j] > dp[i][j\
    \ - 1] + grid[i][j]){\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    parent[i][j] = 1;\n                }\n            }\n   \
    \         if(i + 1 < n){\n                if(dp[i][j] > dp[i + 1][j] + grid[i][j]){\n\
    \                    dp[i][j] = dp[i + 1][j] + grid[i][j];\n                 \
    \   parent[i][j] = 2;\n                }\n            }\n            if(j + 1\
    \ < n){\n                if(dp[i][j] > dp[i][j + 1] + grid[i][j]){\n         \
    \           dp[i][j] = dp[i][j + 1] + grid[i][j];\n                    parent[i][j]\
    \ = 3;\n                }\n            }\n        }\n    }\n    int i = n - 1,\
    \ j = n - 1;\n    while(k--){\n        std::vector<int> temp;\n        temp.push_back(i);\n\
    \        temp.push_", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> parent(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::priority_queue<std::pair<long, std::pair<int, int>>,\n      \
    \                  std::vector<std::pair<long, std::pair<int, int>>>,\n      \
    \                  std::greater<std::pair<long, std::pair<int, int>>>>\n     \
    \   pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    while\
    \ (!pq.empty()) {\n        auto [val, pos] = pq.top();\n        pq.pop();\n  \
    \      int x = pos.first;\n        int y = pos.second;\n        if (visited[x][y])\
    \ continue;\n        visited[x][y] = 1;\n        for (auto [dx, dy] : dir) {\n\
    \            int nx = x + dx;\n            int ny = y + dy;\n            if (nx\
    \ < 0 || nx >= n || ny < 0 || ny >= n) continue;\n            if (visited[nx][ny])\
    \ continue;\n            if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n       \
    \         dp[nx][ny] = dp[x][y] + grid[nx][ny];\n                parent[nx][ny]\
    \ = x * n + y;\n                pq.push({dp[nx][ny], {nx, ny}});\n           \
    \ }\n        }\n    }\n    std::vector<long> ans;\n    int x = n - 1;\n    int\
    \ y = n - 1;\n    while", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                std::vector<long>\
    \ min_path;\n                long min_val = LONG_MAX;\n                if (i -\
    \ 1 >= 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n          \
    \              if (dp[i - 1][j][l - 1] < min_val) {\n                        \
    \    min_val = dp[i - 1][j][l - 1];\n                            min_path = path[i\
    \ - 1][j][l - 1];\n                        }\n                    }\n        \
    \        }\n                if (i + 1 < n) {\n                    if (dp[i + 1][j][l\
    \ - 1] != -1) {\n                        if (dp[i + 1][j][l - 1] < min_val) {\n\
    \                            min_val = dp[i + 1][j][l - 1];\n                \
    \            min_path = path[i + 1][j][l - 1];\n                        }\n  \
    \                  }\n                }\n                if (j - 1 >= 0) {\n \
    \                   if (dp[i][j - 1][l - 1] != -1) {\n                       \
    \ if (dp[i][j - 1][l - 1] < min_val)", "    // Write your code here\n    int n\
    \ = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_grid(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            path_grid[i][j].push_back(grid[i][j]);\n\
    \        }\n    }\n    dp[0][0] = 0;\n    path[0][0].push_back(grid[0][0]);\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n      \
    \      if(i > 0){\n                if(dp[i][j] > dp[i - 1][j] + 1){\n        \
    \            dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i\
    \ - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n          \
    \          path_grid[i][j] = path_grid[i - 1][j];\n                    path_grid[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i][j] == dp[i - 1][j] + 1){\n \
    \                   if(path[i][j] > path[i - 1][j]){\n                       \
    \ path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                        path_grid[i][j] = path_grid[i - 1][j];\n            \
    \            path_grid[i][j].push_back(grid[i][j]);", "    // Write your code\
    \ here\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    // std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    // std::vector<std::vector<long>> dp", "    std::vector<long> ans;\n\
    \    int n = grid.size();\n    // dp[i][j][l] = minimum path of length l that\
    \ ends at cell (i, j)\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    // prev[i][j][l] = previous cell in\
    \ the minimum path of length l that ends at cell (i, j)\n    std::vector<std::vector<std::vector<std::pair<int,\
    \ int>>>> prev(n, std::vector<std::vector<std::pair<int, int>>>(n, std::vector<std::pair<int,\
    \ int>>(k + 1, {-1, -1})));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n            prev[i][j][1]\
    \ = {i, j};\n        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for\
    \ (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n     \
    \           for (int ii = 0; ii < n; ii++) {\n                    for (int jj\
    \ = 0; jj < n; jj++) {\n                        if (abs(i - ii) + abs(j - jj)\
    \ == 1) {\n                            if (dp[ii][jj][l - 1] < dp[i][j][l]) {\n\
    \                                dp[i][j][l] = dp[ii][jj][l - 1];\n          \
    \                      prev[i][j][l] = {ii, jj};\n                           \
    \ }\n                        }\n                    }\n                }\n   \
    \             dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n  \
    \  long min_path = INT_MAX;\n    std::pair<int, int> min_path_end;\n    for (",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n       \
    \     }\n            else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j\
    \ - 1]) + grid[i][j];\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n   \
    \                 path[i][j][1] = grid[i][j];\n                }\n           \
    \     else {\n                    path[i][j][1] = grid[i][j];\n              \
    \  }\n            }\n        }\n    }\n    for(int i = 2; i <= k; i++) {\n   \
    \     for(int j = 0; j < n; j++) {\n            for(int l = 0; l < n; l++) {\n\
    \                if(j == 0 && l == 0) {\n                    path[j][l][i] = path[j][l][i\
    \ - 1];\n                }\n                else if(j == 0) {\n              \
    \      if(dp[j][l - 1] < dp[j][l", "    std::vector<long> ans;\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                dp[i][j]\
    \ = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    path[i][j] = path[i - 1][j];\n      \
    \              path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i\
    \ - 1][j] > dp[i][j - 1]) {\n                    path[i][j] = path[i][j - 1];\n\
    \                    path[i][j][dp[i][j]] = grid[i][j];\n                } else\
    \ {\n                    path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int l = 2; l <= k;\
    \ l++){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n;\
    \ j++){\n                if(i > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i-1][j][l-1]);\n                }\n                if(i < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n        \
    \        }\n                if(j > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j-1][l-1]);\n                }\n                if(j < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n        \
    \        }\n                dp[i][j][l] += grid[i][j];\n            }\n      \
    \  }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n    int\
    \ i = 0, j = 0;\n    for(int l = 2; l <= k; l++){\n        if(i > 0 && dp[i][j][l]\
    \ == dp[i-1][j][l-1] + grid[i][j]){\n            ans.push_back(grid[i-1][j]);\n\
    \            i--;\n        }\n        else if(i", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else {\n                if(i > 0) {\n                    if(dp[i - 1][j] <\
    \ dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j];\n            \
    \            path[i][j] = path[i - 1][j];\n                    }\n           \
    \         else if(dp[i - 1][j] == dp[i][j]) {\n                        for(int\
    \ l = 0; l <= k; l++) {\n                            if(path[i - 1][j][l] < path[i][j][l])\
    \ {\n                                path[i][j] = path[i - 1][j];\n          \
    \                      break;\n                            }\n               \
    \             else if(path[i - 1][j][l] > path[i][j][l]) {\n                 \
    \               break;\n                            }\n                      \
    \  }\n                    }\n                }\n                if(j > 0) {\n\
    \                    if(dp[i][j - 1] < dp[i][j]) {\n                        dp[i][j]\
    \ = dp[i][j - 1];\n                        path[i][j] = path[i][j - 1];\n    \
    \                }\n                    else if(dp[i][j - 1] == dp[i][j]) {\n\
    \                        for(int l = 0; l <= k; l++) {\n                     \
    \       if(path[i][j - 1][l] < path[i][j][l]) {\n                            \
    \    path[i][", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    visited[0][0] = 1;\n    while (!q.empty()) {\n        auto\
    \ curr = q.front();\n        q.pop();\n        for (auto d : dir) {\n        \
    \    int x = curr.first + d[0];\n            int y = curr.second + d[1];\n   \
    \         if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y]) {\n       \
    \         continue;\n            }\n            if (dp[x][y] > dp[curr.first][curr.second]\
    \ + grid[x][y]) {\n                dp[x][y] = dp[curr.first][curr.second] + grid[x][y];\n\
    \                path[x][y] = curr.first * n + curr.second;\n            }\n \
    \           visited[x][y] = 1;\n            q.push({x, y});\n        }\n    }\n\
    \    std::vector<long> res;\n    int x = n - 1;\n    int y = n - 1;\n    while\
    \ (k > 0) {\n        res.push_back(grid[x][y]);\n        int temp = path[x][y];\n\
    \        x = temp / n;\n        y = temp % n;\n        k--;\n    }\n    return\
    \ res;", "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_index(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_index_prev(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n\
    \    std::vector<std::vector<std::vector<long>>> path_index_prev_prev(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_index_prev_prev_prev(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_index_prev_prev_prev_prev(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n\
    \    std::vector<std::vector<std::vector<long>>> path_index_prev_prev_prev_prev_prev(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_index_prev_prev_prev_prev_prev_prev(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_index_prev_prev_prev_prev_prev_prev_prev(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                dp[i][j]\
    \ = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    path[i][j] = path[i - 1][j];\n      \
    \          } else {\n                    path[i][j] = path[i][j - 1];\n      \
    \          }\n                path[i][j][dp[i][j]] = grid[i][j];\n           \
    \ }\n        }\n    }\n    return path[n - 1][n - 1];", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for(int l = 2; l <= k; l++) {\n       \
    \ for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n   \
    \             if(i > 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j];\n                    path[i][j][l] = path[i - 1][j][l - 1];\n\
    \                    path[i][j][l].push_back(grid[i][j]);\n                }\n\
    \                if(i < n - 1 && dp[i + 1][j] < dp[i][j]) {\n                \
    \    dp[i][j] = dp[i + 1][j];\n                    path[i][j][l] = path[i + 1][j][l\
    \ - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n          \
    \      }\n                if(j > 0 && dp[i][j - 1] < dp[i][j]) {\n           \
    \         dp[i][j] = dp[i][j - 1];\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n   \
    \             }\n                if(j < n - 1 && dp[i][j + 1] < dp[i][j]) {\n",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0,\
    \ 0});\n    dp[0][0] = grid[0][0];\n    while (!q.empty()) {\n        auto cur\
    \ = q.front();\n        q.pop();\n        for (auto d : dir) {\n            int\
    \ x = cur.first + d[0];\n            int y = cur.second + d[1];\n            if\
    \ (x < 0 || x >= n || y < 0 || y >= n) continue;\n            if (dp[x][y] > dp[cur.first][cur.second]\
    \ + grid[x][y]) {\n                dp[x][y] = dp[cur.first][cur.second] + grid[x][y];\n\
    \                parent[x][y] = cur.first * n + cur.second;\n                q.push({x,\
    \ y});\n            }\n        }\n    }\n    std::vector<long> res;\n    int x\
    \ = n - 1, y = n - 1;\n    while (k > 0) {\n        res.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n     \
    \   k--;\n    }\n    return res;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;\n            }\n        }\n    }\n    std::vector",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n\
    \                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                   \
    \ dp[i][j] = dp[i - 1][j];\n                    path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                }\n                if (j > 0 && dp[i][j - 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1];\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                }\n                if (i < n - 1 &&\
    \ dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j];\n \
    \                   path[i][j][l] = path[i + 1][j][l - 1];\n                }\n\
    \                if (j < n - 1 && dp[i][j + 1] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i][j + 1];\n                    path[i][j][l] = path[i][j\
    \ + 1][l - 1];\n                }\n                path[i][j][l].push_back(grid[i][j]);\n\
    \            }", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                continue;\n            }\n            if (i > 0) {\n \
    \               if (dp[i - 1][j] + 1 < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + 1;\n                    parent[i][j] = 0;\n               \
    \ }\n            }\n            if (j > 0) {\n                if (dp[i][j - 1]\
    \ + 1 < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n      \
    \              parent[i][j] = 1;\n                }\n            }\n        }\n\
    \    }\n    std::vector<long> ans;\n    int i = n - 1, j = n - 1;\n    while (k\
    \ > 0) {\n        ans.push_back(grid[i][j]);\n        if (parent[i][j] == 0) {\n\
    \            i--;\n        } else {\n            j--;\n        }\n        k--;\n\
    \    }\n    return ans;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<long>> path(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>>\
    \ path_len(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>> path_val(n,\
    \ std::vector<long>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j]\
    \ = -1;\n            path_len[i][j] = 1;\n            path_val[i][j] = grid[i][j];\n\
    \        }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int\
    \ i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n          \
    \      if (i > 0 && dp[i - 1][j][len - 1] != -1) {\n                    if (dp[i][j][len]\
    \ == -1 || dp[i - 1][j][len - 1] < dp[i][j][len]) {\n                        dp[i][j][len]\
    \ = dp[i - 1][j][len - 1];\n                        path[i][j] = 0;\n        \
    \                path_len[i][j] = len - 1;\n                        path_val[i][j]\
    \ = grid[i][j];\n                    }\n                }\n                if\
    \ (i < n - 1 && dp[i + 1][j][len - 1] != -1) {\n                    if (dp[i][j][len]\
    \ == -1 || dp[i + 1][j][len - 1] < dp[i][j][len]) {\n                        dp[i][j][len]\
    \ = dp[i", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++){\n        for(int j = 0; j < n; j++){\n            for(int l = 2; l <=\
    \ k; l++){\n                if(i > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i-1][j][l-1]);\n                }\n                if(j > 0){\n         \
    \           dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n          \
    \      }\n                if(i < n-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i+1][j][l-1]);\n                }\n                if(j < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n        \
    \        }\n                dp[i][j][l] += grid[i][j];\n            }\n      \
    \  }\n    }\n    std::vector<long> ans;\n    long min = INT_MAX;\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(dp[i][j][k]\
    \ < min){\n                min = dp[i][j][k];\n                ans.clear();\n\
    \                ans.push_back(grid[i][j]);\n            }\n            else if(dp[i][j][k]\
    \ == min){\n               ", "    std::vector<long> ans;\n    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long,\
    \ std::pair<int, int>>>, std::greater<std::pair<long, std::pair<int, int>>>> pq;\n\
    \    dp[0][0] = grid[0][0];\n    pq.push({grid[0][0], {0, 0}});\n    while(!pq.empty())\
    \ {\n        auto p = pq.top();\n        pq.pop();\n        int x = p.second.first;\n\
    \        int y = p.second.second;\n        if(x > 0) {\n            if(dp[x -\
    \ 1][y] > dp[x][y] + grid[x - 1][y]) {\n                dp[x - 1][y] = dp[x][y]\
    \ + grid[x - 1][y];\n                parent[x - 1][y] = 1;\n                pq.push({dp[x\
    \ - 1][y], {x - 1, y}});\n            }\n        }\n        if(x < n - 1) {\n\
    \            if(dp[x + 1][y] > dp[x][y] + grid[x + 1][y]) {\n                dp[x\
    \ + 1][y] = dp[x][y] + grid[x + 1][y];\n                parent[x + 1][y] = 2;\n\
    \                pq.push({dp[x + 1][y], {x + 1, y}});\n            }\n       \
    \ }\n        if(y > 0) {\n            if(dp[x][y - 1] > dp[x][y] + grid[x][y -\
    \ 1]) {\n                dp[x][y - 1] = dp[x][y] + grid[", "    // Write your\
    \ code here\n    std::vector<long> result;\n    std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), INT_MAX));\n    std::vector<std::vector<long>>\
    \ parent(grid.size(), std::vector<long>(grid[0].size(), -1));\n    std::vector<std::vector<long>>\
    \ visited(grid.size(), std::vector<long>(grid[0].size(), 0));\n    std::queue<std::pair<long,\
    \ long>> q;\n    for(long i = 0; i < grid.size(); i++) {\n        for(long j =\
    \ 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == 1) {\n         \
    \       dp[i][j] = 0;\n                q.push({i, j});\n            }\n      \
    \  }\n    }\n    while(!q.empty()) {\n        auto p = q.front();\n        q.pop();\n\
    \        long x = p.first;\n        long y = p.second;\n        if(x > 0 && dp[x\
    \ - 1][y] > dp[x][y] + 1) {\n            dp[x - 1][y] = dp[x][y] + 1;\n      \
    \      parent[x - 1][y] = grid[x][y];\n            q.push({x - 1, y});\n     \
    \   }\n        if(x < grid.size() - 1 && dp[x + 1][y] > dp[x][y] + 1) {\n    \
    \        dp[x + 1][y] = dp[x][y] + 1;\n            parent[x + 1][y] = grid[x][y];\n\
    \            q.push({x + 1, y});\n        }\n        if(y > 0 && dp[x][y - 1]\
    \ > dp[x][y] + 1) {\n            dp[x][y - 1] = dp[x][y] + 1;\n            parent[x][y\
    \ - 1] = grid[x][y];\n            q.push({x, y - 1});\n       ", "    // Write\
    \ your code here\n    std::vector<long> ans;\n    long n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> parent(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n,\
    \ 0));\n    std::queue<std::pair<long, long>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    visited[0][0] = 1;\n    while(!q.empty()) {\n        std::pair<long,\
    \ long> p = q.front();\n        q.pop();\n        long i = p.first;\n        long\
    \ j = p.second;\n        if(i + 1 < n && visited[i + 1][j] == 0) {\n         \
    \   visited[i + 1][j] = 1;\n            dp[i + 1][j] = std::min(dp[i + 1][j],\
    \ dp[i][j] + grid[i + 1][j]);\n            parent[i + 1][j] = 0;\n           \
    \ q.push({i + 1, j});\n        }\n        if(j + 1 < n && visited[i][j + 1] ==\
    \ 0) {\n            visited[i][j + 1] = 1;\n            dp[i][j + 1] = std::min(dp[i][j\
    \ + 1], dp[i][j] + grid[i][j + 1]);\n            parent[i][j + 1] = 1;\n     \
    \       q.push({i, j + 1});\n        }\n        if(i - 1 >= 0 && visited[i - 1][j]\
    \ == 0) {\n            visited[i - 1][j] = 1;\n            dp[i - 1][j] = std::min(dp[i\
    \ - 1][j], dp[i][j] + grid[i - 1][j]);\n            parent[i - 1][j] = 2;\n  \
    \          q.push({i", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][1] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][1] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][1] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else {\n                    path[i][j] = path[i][j - 1];\n                }\n\
    \                path[i][j][1] = grid[i][j];\n            }\n        }\n    }\n\
    \    int i = n - 1, j = n - 1;\n    for (int l = 2; l <= k; l++) {\n        if\
    \ (i == 0) {\n            path[i][j][l] = path[i][j - 1][l - 1];\n           \
    \ j--;\n        } else if (j ==", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::vector<std::vector<bool>>\
    \ visited(n, std::vector<bool>(n, false));\n    std::queue<std::pair<int, int>>\
    \ q;\n    q.push({0, 0});\n    dp[0][0] = grid[0][0];\n    while (!q.empty())\
    \ {\n        auto p = q.front();\n        q.pop();\n        int x = p.first;\n\
    \        int y = p.second;\n        visited[x][y] = true;\n        for (int i\
    \ = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n            int ny\
    \ = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) {\n\
    \                continue;\n            }\n            if (dp[nx][ny] > dp[x][y]\
    \ + grid[nx][ny]) {\n                dp[nx][ny] = dp[x][y] + grid[nx][ny];\n \
    \               parent[nx][ny] = i;\n                if (!visited[nx][ny]) {\n\
    \                    q.push({nx, ny});\n                }\n            }\n   \
    \     }\n    }\n    std::vector<long> res;\n    int x = n - 1;\n    int y = n\
    \ - 1;\n    while (k > 0) {\n        res.push_back(grid[x][y]);\n        int p\
    \ = parent[x][y];\n        x -= dir[p][0];\n        y -= dir[p][1];\n        k--;\n\
    \    }\n    return res;", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][1]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n\
    \                if (dp[i - 1][j] < dp[i][j - 1]) {\n                    path[i][j]\
    \ = path[i - 1][j];\n                } else {\n                    path[i][j]\
    \ = path[i][j - 1];\n                }\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            }\n        }\n    }\n    return path[n - 1][n - 1];",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            } else if (i\
    \ == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][dp[i][j - 1]] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][dp[i\
    \ - 1][j]] = grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + 1;\n                if (dp[i - 1][j] < dp[i][j - 1])\
    \ {\n                    path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i\
    \ - 1][j]] = grid[i][j];\n                } else {\n                    path[i][j]\
    \ = path[i][j - 1];\n                    path[i][j][dp[i][j - 1]] = grid[i][j];\n\
    \                }\n            }\n        }\n    }\n    return path[n - 1][n\
    \ - 1];", "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                if (i - 1 >=\
    \ 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j];\n\
    \                    path[i][j][l] = path[i - 1][j][l - 1];\n                \
    \    path[i][j][l].push_back(grid[i][j]);\n                }\n               \
    \ if (i + 1 < n && dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j] =\
    \ dp[i + 1][j];\n                    path[i][j][l] = path[i + 1][j][l - 1];\n\
    \                    path[i][j][l].push_back(grid[i][j]);\n                }\n\
    \                if (j - 1 >= 0 && dp[i][j - 1] < dp[i][j]) {\n              \
    \      dp[i][j] = dp[i][j - 1];\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n   \
    \             }\n                if (j + 1 < n && dp[i][j + 1] < dp[i][j]) {\n\
    \                    dp", "    // Write your code here\n    std::vector<long>\
    \ res;\n    if(k == 0) return res;\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = grid[i][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0){\n               \
    \ dp[i][j] = dp[i][j-1] + grid[i][j];\n                path[i][j] = path[i][j-1];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\
    \ if(j == 0){\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n         \
    \       path[i][j] = path[i-1][j];\n                path[i][j][0] = grid[i][j];\n\
    \            }\n            else{\n                dp[i][j] = std::min(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j];\n                if(dp[i-1][j] < dp[i][j-1]){\n  \
    \                  path[i][j] = path[i-1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else{\n                  \
    \  path[i][j] = path[i][j-1];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n            }\n        }\n    }\n    int x = n-1, y = n-1;\n\
    \    for(int i = 1; i <", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n            }\n \
    \           else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                parent[i][j] = 1;\n            }\n            else if(j == 0)\
    \ {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n                parent[i][j]\
    \ = 0;\n            }\n            else {\n                if(dp[i-1][j] < dp[i][j-1])\
    \ {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n               \
    \     parent[i][j] = 0;\n                }\n                else {\n         \
    \           dp[i][j] = dp[i][j-1] + grid[i][j];\n                    parent[i][j]\
    \ = 1;\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    int i = n-1, j = n-1;\n    while(k--) {\n        result.push_back(grid[i][j]);\n\
    \        if(parent[i][j] == 0) {\n            i--;\n        }\n        else {\n\
    \            j--;\n        }\n    }\n    return result;", "    std::vector<long>\
    \ ans;\n    long n = grid.size();\n    long m = grid[0].size();\n    long i =\
    \ 0, j = 0;\n    for(long p = 0; p < k; p++){\n        ans.push_back(grid[i][j]);\n\
    \        if(i + 1 < n && j + 1 < m){\n            if(grid[i + 1][j] < grid[i][j\
    \ + 1]){\n                i++;\n            }else if(grid[i + 1][j] > grid[i][j\
    \ + 1]){\n                j++;\n            }else{\n                if(i < j){\n\
    \                    i++;\n                }else{\n                    j++;\n\
    \                }\n            }\n        }else if(i + 1 < n){\n            i++;\n\
    \        }else if(j + 1 < m){\n            j++;\n        }else{\n            assert(false);\n\
    \        }\n    }\n    return ans;", "    // Write your code here\n    int n =\
    \ grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    while (!q.empty()) {\n        auto cur = q.front();\n   \
    \     q.pop();\n        for (auto d : dir) {\n            int x = cur.first +\
    \ d[0];\n            int y = cur.second + d[1];\n            if (x < 0 || x >=\
    \ n || y < 0 || y >= n) continue;\n            if (dp[x][y] > dp[cur.first][cur.second]\
    \ + grid[x][y]) {\n                dp[x][y] = dp[cur.first][cur.second] + grid[x][y];\n\
    \                parent[x][y] = cur.first * n + cur.second;\n                q.push({x,\
    \ y});\n            }\n        }\n    }\n    std::vector<long> res;\n    int x\
    \ = n - 1, y = n - 1;\n    while (k--) {\n        res.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n    }\n\
    \    return res;", "    std::vector<long> ans;\n    // Write your code here\n\
    \    return ans;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(k + 1, -1))));\n   \
    \ std::vector<std::vector<long>> dist(n, std::vector<long>(n, -1));\n    std::queue<std::pair<int,\
    \ int>> q;\n    q.push({0, 0});\n    dist[0][0] = 0;\n    while (!q.empty()) {\n\
    \        int x = q.front().first;\n        int y = q.front().second;\n       \
    \ q.pop();\n        if (x > 0 && dist[x - 1][y] == -1) {\n            dist[x -\
    \ 1][y] = dist[x][y] + 1;\n            q.push({x - 1, y});\n        }\n      \
    \  if (x < n - 1 && dist[x + 1][y] == -1) {\n            dist[x + 1][y] = dist[x][y]\
    \ + 1;\n            q.push({x + 1, y});\n        }\n        if (y > 0 && dist[x][y\
    \ - 1] == -1) {\n            dist[x][y - 1] = dist[x][y] + 1;\n            q.push({x,\
    \ y - 1});\n        }\n        if (y < n - 1 && dist[x][y + 1] == -1) {\n    \
    \        dist[x][y + 1] = dist[x][y] + 1;\n            q.push({x, y + 1});\n \
    \       }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < n; j++) {\n            dp[i][j][0] = grid[i][j];\n        }", "    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        for(int j = 0; j < m; j++) {\n            for(int l = 2; l <=\
    \ k; l++) {\n                if(i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                }\n                if(j > 0) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n \
    \               }\n                if(i < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n                }\n         \
    \       if(j < m - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i =\
    \ -1;\n    int min_j = -1;\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < m; j++) {\n            if(dp[i][j][k] < min_val) {\n            \
    \    min_val = dp[i][j][k];\n                min_i = i;\n", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> visited(n,\
    \ std::vector<int>(n, 0));\n    std::vector<std::vector<std::vector<long>>> path(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    std::vector<std::vector<std::vector<int>>>\
    \ path_visited(n, std::vector<std::vector<int>>(n, std::vector<int>(k, 0)));\n\
    \    dp[0][0] = 0;\n    path[0][0][0] = grid[0][0];\n    path_visited[0][0][0]\
    \ = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n\
    \            if(i == 0 && j == 0) continue;\n            if(i > 0 && dp[i-1][j]\
    \ != INT_MAX){\n                for(int l = 0; l < k; l++){\n                \
    \    if(path_visited[i-1][j][l] == 1){\n                        if(l+1 < k){\n\
    \                            path[i][j][l+1] = grid[i][j];\n                 \
    \           path_visited[i][j][l+1] = 1;\n                        }\n        \
    \                if(dp[i][j] > dp[i-1][j] + 1){\n                            dp[i][j]\
    \ = dp[i-1][j] + 1;\n                            for(int m = 0; m < k; m++){\n\
    \                                path[i][j][m] = path[i-1][j][m];\n          \
    \                      path_visited[i][j][m] = path_visited[i-1][j][m];\n    \
    \                        }\n                        }\n                      \
    \  else if(dp[i][j] == dp[i-1][j] + 1){\n                            for(", " \
    \   // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, -1));\n    dp[0][0] = grid[0][0];\n    for(int i = 0; i\
    \ < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i > 0){\n  \
    \              if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n                    dp[i][j]\
    \ = dp[i-1][j] + grid[i][j];\n                    path[i][j] = 0;\n          \
    \      }\n            }\n            if(j > 0){\n                if(dp[i][j] >\
    \ dp[i][j-1] + grid[i][j]){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                    path[i][j] = 1;\n                }\n            }\n     \
    \   }\n    }\n    std::vector<long> ans;\n    int i = n-1, j = n-1;\n    while(k\
    \ > 0){\n        ans.push_back(grid[i][j]);\n        if(path[i][j] == 0){\n  \
    \          i--;\n        }\n        else if(path[i][j] == 1){\n            j--;\n\
    \        }\n        k--;\n    }\n    return ans;", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(k + 1, -1))));\n    for (int i = 0; i < n; i++) {\n \
    \       for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \            prev[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int\
    \ l = 2; l <= k; l++) {\n                long min = -1;\n                std::vector<long>\
    \ min_prev;\n                if (i - 1 >= 0) {\n                    if (dp[i -\
    \ 1][j][l - 1] != -1) {\n                        if (min == -1 || dp[i - 1][j][l\
    \ - 1] < min) {\n                            min = dp[i - 1][j][l - 1];\n    \
    \                        min_prev = prev[i - 1][j][l - 1];\n                 \
    \       }\n                    }\n                }\n                if (i + 1\
    \ < n) {\n                    if (dp[i + 1][j][l - 1] != -1) {\n             \
    \           if (min == -1 || dp[i + 1][j][l - 1] < min) {\n                  \
    \          min = dp[i + 1][j][l - 1];\n                            min_prev =\
    \ prev[i + 1][j][l - 1];\n                        }\n                    }\n \
    \               }\n                if (j - 1 >= 0) {\n                    if (dp[i][j\
    \ - 1][l - 1] != -1) {\n                       ", "    // Write your code here\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        for(int j = 0; j < m; j++) {\n            for(int l = 2; l <=\
    \ k; l++) {\n                if(i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if(i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if(j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if(j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1;\n  \
    \  int min_j = -1;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j\
    \ < m; j++) {\n            if(dp[i][j][k] < min_val) {\n                min_val\
    \ = dp[i][j][k];\n                min_i = i;\n                min_j = j;\n   \
    \         }\n        }\n", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(k + 1, -1))));\n    for(int i = 0; i < n; i++) {\n  \
    \      for(int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n \
    \           parent[i][j][1][0] = grid[i][j];\n        }\n    }\n    for(int l\
    \ = 2; l <= k; l++) {\n        for(int i = 0; i < n; i++) {\n            for(int\
    \ j = 0; j < n; j++) {\n                for(int x = 0; x < n; x++) {\n       \
    \             for(int y = 0; y < n; y++) {\n                        if(dp[x][y][l\
    \ - 1] != -1) {\n                            if(i == x && j == y) {\n        \
    \                        continue;\n                            }\n          \
    \                  if(i == x && abs(j - y) == 1) {\n                         \
    \       if(dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j])\
    \ {\n                                    dp[i][j][l] = dp[x][y][l - 1] * 10 +\
    \ grid[i][j];\n                                    parent[i][j][l] = parent[x][y][l\
    \ - 1];\n                                    parent[i][j][l].push_back(grid[i][j]);\n\
    \                                }\n                            }\n          \
    \                  if(j == y && abs(i - x) == 1) {\n                         \
    \       if(dp[i][j][", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n        \
    \        path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j - 1]]\
    \ = grid[i][j];\n            }\n            else if(j == 0) {\n              \
    \  dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n\
    \                path[i][j][dp[i - 1][j]] = grid[i][j];\n            }\n     \
    \       else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1])\
    \ + 1;\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n                  \
    \  path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i - 1][j]]\
    \ = grid[i][j];\n                }\n                else {\n                 \
    \   path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j - 1]]\
    \ = grid[i][j];\n                }\n            }\n        }\n    }\n    return\
    \ path[n - 1][n - 1];", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<std::vector<std::vector<int>>>\
    \ path(n, std::vector<std::vector<int>>(n, std::vector<int>(k + 1, -1)));\n  \
    \  for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n    \
    \        if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n            \
    \    path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n         \
    \       dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                path[i][j][0] = grid[i][j];\n            } else {\n         \
    \       dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n               \
    \ path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int\
    \ l = 1; l <= k; l++) {\n                if (i == 0 && j == 0) {\n           \
    \         path[i][j][l] = grid[i][j];\n                } else if (i == 0) {\n\
    \                    path[i][j][l] = path[i][j - 1][l - 1];\n                }\
    \ else if (j == 0) {\n                    path[i][j][l] = path[i - 1][j][l - 1];\n\
    \                } else {\n                    if (dp[i - 1][j] < dp[i][j - 1])\
    \ {\n                        path[i][j", "    // Write your code here\n    int\
    \ n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0] = grid[0][0];\n\
    \    visited[0][0] = 1;\n    while (!q.empty()) {\n        auto curr = q.front();\n\
    \        q.pop();\n        for (auto d : dir) {\n            int x = curr.first\
    \ + d[0];\n            int y = curr.second + d[1];\n            if (x < 0 || x\
    \ >= n || y < 0 || y >= n || visited[x][y]) {\n                continue;\n   \
    \         }\n            visited[x][y] = 1;\n            dp[x][y] = std::min(dp[x][y],\
    \ dp[curr.first][curr.second] + grid[x][y]);\n            parent[x][y] = curr.first\
    \ * n + curr.second;\n            q.push({x, y});\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int x = n - 1;\n    int y = n - 1;\n    while (k) {\n        ans.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n     \
    \   k--;\n    }\n    return ans;", "    // Write your code here\n    std::vector<long>\
    \ result;\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j <\
    \ grid[0].size(); j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\
    \    for(int i = 0; i < k; i++) {\n        for(int j = 0; j < grid.size(); j++)\
    \ {\n            for(int k = 0; k < grid[0].size(); k++) {\n                if(j\
    \ == 0 && k == 0) {\n                    dp[j][k] = std::min(dp[j][k], std::min(dp[j][k+1],\
    \ dp[j+1][k]));\n                } else if(j == 0 && k == grid[0].size() - 1)\
    \ {\n                    dp[j][k] = std::min(dp[j][k], std::min(dp[j][k-1], dp[j+1][k]));\n\
    \                } else if(j == grid.size() - 1 && k == 0) {\n               \
    \     dp[j][k] = std::min(dp[j][k], std::min(dp[j][k+1], dp[j-1][k]));\n     \
    \           } else if(j == grid.size() - 1 && k == grid[0].size() - 1) {\n   \
    \                 dp[j][k] = std::min(dp[j][k], std::min(dp[j][k-1], dp[j-1][k]));\n\
    \                } else if(j == 0) {\n                    dp[j][k] = std::min(dp[j][k],\
    \ std::min(dp[j][k-1], std::min(dp[j][k+1], dp[j+1][k])));\n                }\
    \ else if(j == grid.size() - 1) {\n                    dp[j][k] = std::min(dp[",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> prev(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            prev[i][j][0]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 1; l < k; l++) {\n \
    \               if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j];\n                    prev[i][j][l] = prev[i - 1][j][l - 1];\n\
    \                }\n                if (j > 0 && dp[i][j - 1] < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i][j - 1];\n                    prev[i][j][l]\
    \ = prev[i][j - 1][l - 1];\n                }\n                if (i < n - 1 &&\
    \ dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j];\n \
    \                   prev[i][j][l] = prev[i + 1][j][l - 1];\n                }\n\
    \                if (j < n - 1 && dp[i][j + 1] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i][j + 1];\n                    prev[i][j][l] = prev[i][j\
    \ + 1][l - 1];\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans", "    // Write your code here\n    int n = grid.size();\n   \
    \ std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n       \
    \     }\n            else {\n                dp[i][j] = std::min(dp[i - 1][j],\
    \ dp[i][j - 1]) + grid[i][j];\n                if(dp[i - 1][j] < dp[i][j - 1])\
    \ {\n                    path[i][j][1] = grid[i][j];\n                }\n    \
    \            else {\n                    path[i][j][1] = grid[i][j];\n       \
    \         }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++) {\n\
    \        for(int j = 0; j < n; j++) {\n            for(int l = 2; l <= k; l++)\
    \ {\n                if(i == 0 && j == 0) {\n                    path[i][j][l]\
    \ = grid[i][j];\n                }\n                else if(i == 0) {\n      \
    \              path[i][j][l] = path[i][j - 1][l -", "    // Write your code here\n\
    \    long n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n        \
    \        path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            }\n            else if(j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n        \
    \        path[i][j][dp[i][j]] = grid[i][j];\n            }\n            else {\n\
    \                long min = std::min(dp[i - 1][j], dp[i][j - 1]);\n          \
    \      dp[i][j] = min + 1;\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n\
    \                    path[i][j] = path[i - 1][j];\n                }\n       \
    \         else {\n                    path[i][j] = path[i][j - 1];\n         \
    \       }\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\n\
    \        }\n    }\n    return path[n - 1][n - 1];", "    std::vector<long> result;\n\
    \    // Implement your solution here\n    return result;", "    long n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (long i = 0; i < n; i++) {\n        for\
    \ (long j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n          \
    \      dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n          \
    \  } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n      \
    \          path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]]\
    \ = grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] =\
    \ dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n            \
    \    if (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i -\
    \ 1][j] + 1;\n                    path[i][j] = path[i - 1][j];\n             \
    \       path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i -\
    \ 1][j] > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n\
    \                    path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                } else {\n                    dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                    path[i][j] = path[i - 1", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k, INT_MAX)));\n \
    \   std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k, std::vector<long>(2, -1))));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j][0]\
    \ = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            for(int l = 1; l < k; l++) {\n           \
    \     if(i > 0) {\n                    if(dp[i - 1][j][l - 1] < dp[i][j][l]) {\n\
    \                        dp[i][j][l] = dp[i - 1][j][l - 1];\n                \
    \        parent[i][j][l][0] = i - 1;\n                        parent[i][j][l][1]\
    \ = j;\n                    }\n                }\n                if(i < n - 1)\
    \ {\n                    if(dp[i + 1][j][l - 1] < dp[i][j][l]) {\n           \
    \             dp[i][j][l] = dp[i + 1][j][l - 1];\n                        parent[i][j][l][0]\
    \ = i + 1;\n                        parent[i][j][l][1] = j;\n                \
    \    }\n                }\n                if(j > 0) {\n                    if(dp[i][j\
    \ - 1][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i][j\
    \ - 1][l - 1];\n                        parent[i][j][l][0] = i;\n            \
    \            parent", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][1] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n      \
    \          path[i][j][1] = grid[i][j];\n            }\n            else {\n  \
    \              dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n            }\n        }\n    }\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n    \
    \        for(int l = 2; l <= k; l++) {\n                if(i == 0 && j == 0) {\n\
    \                    dp[i][j] = grid[i][j];\n                    path[i][j][l]\
    \ = grid[i][j];\n                }\n                else if(i == 0) {\n      \
    \              if(dp[i][j - 1] + grid[i][j] < dp[i][j]) {\n                  \
    \      dp[i][j] = dp[i][j - 1] + grid[i][j];\n", "    // Write your code here\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1]\
    \ + grid[i][j];\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i-1][j] > dp[i][j-1]){\n      \
    \              dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j]\
    \ = path[i][j-1];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else{\n                    dp[", "    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_min(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_max(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_min_max(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n \
    \   std::vector<std::vector<std::vector<long>>> path_max_min(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_min_min(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_max_max(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n \
    \   for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n     \
    \       path[i][j].push_back(grid[i][j]);\n            path_min[i][j].push_back(grid[i][j]);\n\
    \            path_max[i][j].push_back(grid[i][j]);\n            path_min_max[i][j].push_back(grid[i][j]);\n\
    \            path_max_min[i][j].push_back(grid[i][j]);\n            path_min_min[i][j].push_back",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n     \
    \       path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2;\
    \ l <= k; l++) {\n                if (i - 1 >= 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            path[i][j][l] = grid[i][j];\n                    }\n            \
    \    }\n                if (i + 1 < n && dp[i + 1][j][l - 1] != -1) {\n      \
    \              if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j][l]) {\n\
    \                        dp[i][j][l] = dp[i + 1][j][l - 1];\n                \
    \        path[i][j][l] = grid[i][j];\n                    }\n                }\n\
    \                if (j - 1 >= 0 && dp[i][j - 1][l - 1] != -1) {\n            \
    \        if (dp[i][j][l] == -1 || dp[i", "    // Write your code here\n    int\
    \ n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ 0));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][0]\
    \ = grid[i][j];\n        }\n    }\n    for(int i = 1; i < k; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            for(int l = 0; l < n; l++) {\n           \
    \     long min = LONG_MAX;\n                if(j > 0) {\n                    if(dp[j-1][l]\
    \ < min) {\n                        min = dp[j-1][l];\n                      \
    \  path[j][l][i] = grid[j-1][l];\n                    }\n                }\n \
    \               if(j < n-1) {\n                    if(dp[j+1][l] < min) {\n  \
    \                      min = dp[j+1][l];\n                        path[j][l][i]\
    \ = grid[j+1][l];\n                    }\n                }\n                if(l\
    \ > 0) {\n                    if(dp[j][l-1] < min) {\n                       \
    \ min = dp[j][l-1];\n                        path[j][l][i] = grid[j][l-1];\n \
    \                   }\n                }\n                if(l < n-1) {\n    \
    \                if(dp[j][l+1] < min) {\n                        min = dp[j][l+1];\n\
    \                        path[j][l][i] = grid[j][l+1];\n                    }\n\
    \                }\n                dp[j][l] += min;\n            }\n        }\n\
    \    }\n    long min = LONG_MAX;\n    int x, y;\n    for(", "    // Write your\
    \ code here\n    // Return an ordered list of the values on the cells that the\
    \ minimum path go through.\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j] = path[i][j\
    \ - 1];\n                path[i][j][0] = grid[i][j];\n            }\n        \
    \    else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            }\n            else {\n                if(dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else if(dp[i - 1][j] > dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n       \
    \             path[i][j] = path[i][j - 1];\n                    path[i][j][0]\
    \ = grid[i][j];\n               ", "    std::vector<long> result;\n    // Implement\
    \ your solution here\n    return result;", "    // Write your code here\n    int\
    \ n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n, 0));\n\
    \    std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long,\
    \ std::pair<int, int>>>, std::greater<std::pair<long, std::pair<int, int>>>> pq;\n\
    \    dp[0][0] = grid[0][0];\n    pq.push({grid[0][0], {0, 0}});\n    while(!pq.empty())\
    \ {\n        auto p = pq.top();\n        pq.pop();\n        int x = p.second.first;\n\
    \        int y = p.second.second;\n        if(visited[x][y]) {\n            continue;\n\
    \        }\n        visited[x][y] = 1;\n        if(x + 1 < n) {\n            if(dp[x\
    \ + 1][y] > dp[x][y] + grid[x + 1][y]) {\n                dp[x + 1][y] = dp[x][y]\
    \ + grid[x + 1][y];\n                parent[x + 1][y] = 0;\n                pq.push({dp[x\
    \ + 1][y], {x + 1, y}});\n            }\n        }\n        if(y + 1 < n) {\n\
    \            if(dp[x][y + 1] > dp[x][y] + grid[x][y + 1]) {\n                dp[x][y\
    \ + 1] = dp[x][y] + grid[x][y + 1];\n                parent[x][y + 1] = 1;\n \
    \               pq.push({dp[x][y + 1], {x, y + 1}});\n            }\n        }\n\
    \        if(x - 1 >= 0) {\n           ", "    std::vector<long> ans;\n    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++){\n        for(int j = 0; j < m; j++){\n            for(int l = 2; l <=\
    \ k; l++){\n                if(i - 1 >= 0){\n                    dp[i][j][l] =\
    \ std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n           \
    \     if(i + 1 < n){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if(j - 1 >= 0){\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if(j + 1 < m){\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1;\n  \
    \  int min_j = -1;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j\
    \ < m; j++){\n            if(dp[i][j][k] < min_val){\n                min_val\
    \ = dp[i][j][k];\n                min_i = i;\n                min_j = j;\n   \
    \        ", "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    while (!q.empty()) {\n        auto p = q.front();\n     \
    \   q.pop();\n        int x = p.first;\n        int y = p.second;\n        visited[x][y]\
    \ = 1;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= n) continue;\n            if (dp[nx][ny] > dp[x][y] + grid[nx][ny])\
    \ {\n                dp[nx][ny] = dp[x][y] + grid[nx][ny];\n                parent[nx][ny]\
    \ = i;\n                if (!visited[nx][ny]) q.push({nx, ny});\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    int x = n - 1;\n    int y =\
    \ n - 1;\n    while (k--) {\n        ans.push_back(grid[x][y]);\n        int p\
    \ = parent[x][y];\n        x -= dir[p][0];\n        y -= dir[p][1];\n    }\n \
    \   std::reverse(ans.begin(), ans.end());\n    return ans;", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j-1] + grid[i][j];\n                path[i][j] = path[i][j-1];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n        \
    \        path[i][j] = path[i-1][j];\n                path[i][j][0] = grid[i][j];\n\
    \            }\n            else {\n                if(dp[i-1][j] < dp[i][j-1])\
    \ {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n               \
    \     path[i][j] = path[i-1][j];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n                else if(dp[i-1][j] > dp[i][j-1]) {\n     \
    \               dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j]\
    \ = path[i][j-1];\n                    path[i][j][0] = grid[i][j];\n         \
    \       }\n                else {\n                    dp[i][j] = dp[i-", "  \
    \  // Write your code here\n    std::vector<long> ans;\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n        \
    \    if(i == 0 && j == 0){\n                dp[i][j] = grid[i][j];\n         \
    \   }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n            }\n            else{\n                dp[i][j] =\
    \ std::min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n            }\n        }\n \
    \   }\n    int i = n-1, j = n-1;\n    while(k--){\n        ans.push_back(grid[i][j]);\n\
    \        if(i == 0 && j == 0){\n            break;\n        }\n        else if(i\
    \ == 0){\n            j--;\n        }\n        else if(j == 0){\n            i--;\n\
    \        }\n        else{\n            if(dp[i-1][j] < dp[i][j-1]){\n        \
    \        i--;\n            }\n            else{\n                j--;\n      \
    \      }\n        }\n    }\n    return ans;", "    std::vector<long> result;\n\
    \    // Write your code here\n    return result;", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    long min_sum = INT_MAX;\n    int min_i = -1, min_j = -1;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (dp[i][j][k] < min_sum) {\n                min_sum = dp[i][j][k];\n\
    \                min_i = i;\n                min_j = j;\n            }\n     \
    \   }\n    }\n    std::vector", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 2; i <= k; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 0; l < n; l++) {\n                if (j > 0) {\n\
    \                    if (dp[j][l] > dp[j - 1][l] + grid[j][l]) {\n           \
    \             dp[j][l] = dp[j - 1][l] + grid[j][l];\n                        path[j][l][i]\
    \ = grid[j][l];\n                    }\n                }\n                if\
    \ (j < n - 1) {\n                    if (dp[j][l] > dp[j + 1][l] + grid[j][l])\
    \ {\n                        dp[j][l] = dp[j + 1][l] + grid[j][l];\n         \
    \               path[j][l][i] = grid[j][l];\n                    }\n         \
    \       }\n                if (l > 0) {\n                    if (dp[j][l] > dp[j][l\
    \ - 1] + grid[j][l]) {\n                        dp[j][l] = dp[j][l - 1] + grid[j][l];\n\
    \                        path[j][l][i] = grid[j][l];\n                    }\n\
    \                }\n                if (l < n - 1) {\n                    if (dp[j][l]\
    \ > dp[j][l + 1] + grid[j][l]) {\n                        dp[j][l] = dp", "  \
    \  std::vector<long> result;\n    // Write your code here\n    return result;",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                    path[i][j] = path[i - 1][j];\n                   \
    \ path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n      \
    \              path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                } else {\n                    dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                    path[i][j] = path[i -", "    // Write your\
    \ code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1]\
    \ + grid[i][j];\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i-1][j] > dp[i][j-1]){\n      \
    \              dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j]\
    \ = path[i][j-1];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else{\n                    if(path", "    int\
    \ n = grid.size();\n    assert(n >= 2);\n    assert(n == grid[0].size());\n  \
    \  assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ pre(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n \
    \   std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; ++i) {\n       \
    \ for (int j = 0; j < n; ++j) {\n            dp[i][j] = grid[i][j];\n        \
    \    pre[i][j][1] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <\
    \ n; ++j) {\n            for (int l = 2; l <= k; ++l) {\n                if (i\
    \ - 1 >= 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i\
    \ - 1][j];\n                    pre[i][j][l] = 0;\n                    path[i][j][l]\
    \ = grid[i][j];\n                }\n                if (i + 1 < n && dp[i + 1][j]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j];\n              \
    \      pre[i][j][l] = 1;\n                    path[i][j][l] = grid[i][j];\n  \
    \              }\n                if (j - 1 >= 0 && dp[i][j - 1] < dp[i][j]) {\n\
    \                    d", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;\
    \ j++) {\n            for (int l = 2; l <= k; l++) {\n                long min\
    \ = -1;\n                if (i - 1 >= 0 && dp[i - 1][j][l - 1] != -1) {\n    \
    \                min = dp[i - 1][j][l - 1];\n                    path[i][j][l]\
    \ = 0;\n                }\n                if (i + 1 < n && dp[i + 1][j][l - 1]\
    \ != -1 && (min == -1 || dp[i + 1][j][l - 1] < min)) {\n                    min\
    \ = dp[i + 1][j][l - 1];\n                    path[i][j][l] = 1;\n           \
    \     }\n                if (j - 1 >= 0 && dp[i][j - 1][l - 1] != -1 && (min ==\
    \ -1 || dp[i][j - 1][l - 1] < min)) {\n                    min = dp[i][j - 1][l\
    \ - 1];\n                    path[i][j][l] = 2;\n                }\n         \
    \       if (j + 1 < n && dp[i][j + 1][l - 1] != -1 && (min == -1 || dp[i][j +\
    \ 1][l - 1] < min)) {\n                    min = dp[i][j + 1][l - 1];\n      \
    \             ", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else {\n                if(i > 0)\
    \ {\n                    if(dp[i - 1][j] + 1 < dp[i][j]) {\n                 \
    \       dp[i][j] = dp[i - 1][j] + 1;\n                        path[i][j] = path[i\
    \ - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n      \
    \              }\n                    else if(dp[i - 1][j] + 1 == dp[i][j]) {\n\
    \                        std::vector<long> temp = path[i - 1][j];\n          \
    \              temp.push_back(grid[i][j]);\n                        if(temp <\
    \ path[i][j]) {\n                            path[i][j] = temp;\n            \
    \            }\n                    }\n                }\n                if(j\
    \ > 0) {\n                    if(dp[i][j - 1] + 1 < dp[i][j]) {\n            \
    \            dp[i][j] = dp[i][j - 1] + 1;\n                        path[i][j]\
    \ = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i][j - 1] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp = path[i][j - 1];\n      \
    \                  temp.push_back(grid[i][j]);\n                        if(temp\
    \ < path[i][j])", "    // Write your code here\n    int n = grid.size();\n   \
    \ int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    for(int i = 0; i < n; i++){\n        for(int j =\
    \ 0; j < m; j++){\n            if(i == 0 && j == 0){\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n         \
    \   }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i-1][j] > dp[i][j-1]){\n      \
    \              dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j]\
    \ = path[i][j-1];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else{\n                    dp[", "    int n =\
    \ grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            } else if (i\
    \ == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][dp[i][j]] = grid[i][j];\n    \
    \        } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][dp[i][j]]\
    \ = grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + 1;\n                \
    \    path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i][j]] =\
    \ grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n   \
    \                 dp[i][j] = dp[i][j - 1] + 1;\n                    path[i][j]\
    \ = path[i][j - 1];\n                    path[i][j][dp[i][j]] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + 1;\n\
    \                    path[i][j] = path[i - 1", "    std::vector<long> ans;\n \
    \   std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(grid.size(),\
    \ std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0].push_back(grid[0][0]);\n    for(int i = 0; i <\
    \ grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n   \
    \         if(i - 1 >= 0) {\n                if(dp[i][j] > dp[i - 1][j] + grid[i][j])\
    \ {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n             \
    \       path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i][j] == dp[i - 1][j] + grid[i][j])\
    \ {\n                    std::vector<long> temp = path[i - 1][j];\n          \
    \          temp.push_back(grid[i][j]);\n                    if(temp < path[i][j])\
    \ {\n                        path[i][j] = temp;\n                    }\n     \
    \           }\n            }\n            if(j - 1 >= 0) {\n                if(dp[i][j]\
    \ > dp[i][j - 1] + grid[i][j]) {\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n          \
    \          path[i][j].push_back(grid[i][j]);\n                }\n            \
    \    else if(dp[i][j] == dp[i][j - 1] + grid[i][j]) {\n                    std::vector<long>\
    \ temp = path[i][j - 1];\n", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> prev(n,\
    \ std::vector<long>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j -\
    \ 1] + 1;\n                prev[i][j] = 1;\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                prev[i][j] = 0;\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + 1;\n                    prev[i][j]\
    \ = 0;\n                } else {\n                    dp[i][j] = dp[i][j - 1]\
    \ + 1;\n                    prev[i][j] = 1;\n                }\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    int i = n - 1, j = n - 1;\n\
    \    while (k > 0) {\n        ans.push_back(grid[i][j]);\n        if (prev[i][j]\
    \ == 0) {\n            i--;\n        } else {\n            j--;\n        }\n \
    \       k--;\n    }\n    return ans;", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ LONG_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    dp[0][0] = grid[0][0];\n    for (int i = 0; i < n; i++) {\n      \
    \  for (int j = 0; j < n; j++) {\n            for (int d = 0; d < 4; d++) {\n\
    \                int x = i + dir[d][0];\n                int y = j + dir[d][1];\n\
    \                if (x < 0 || x >= n || y < 0 || y >= n) continue;\n         \
    \       if (dp[x][y] > dp[i][j] + grid[x][y]) {\n                    dp[x][y]\
    \ = dp[i][j] + grid[x][y];\n                    parent[x][y] = i * n + j;\n  \
    \              }\n            }\n        }\n    }\n    std::vector<long> ans;\n\
    \    int x = n - 1, y = n - 1;\n    while (k > 0) {\n        ans.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n     \
    \   k--;\n    }\n    std::reverse(ans.begin(), ans.end());\n    return ans;",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j] = path[i][j\
    \ - 1];\n                path[i][j][0] = grid[i][j];\n            }\n        \
    \    else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            }\n            else {\n                if(dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else if(dp[i - 1][j] > dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n       \
    \             path[i][j] = path[i][j - 1];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else {\n                 \
    \   dp[i][j] = dp[i -", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n               \
    \     dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i -\
    \ 1][j];\n                    path[i][j][dp[i][j]] = grid[i][j];\n           \
    \     } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j - 1];\n    \
    \                path[i][j][dp[i][j]] = grid[i][j];\n                } else {\n\
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j]\
    \ = path[i - 1", "    std::vector<long> result;\n    // Implement your solution\
    \ here\n    return result;", "    std::vector<long> ans;\n    // Write your code\
    \ here\n    return ans;", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_val(n, std::vector<std::vector<long>>(n, std::vector<long>(k, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n          \
    \      path[i][j] = -1;\n                path_val[i][j][0] = grid[i][j];\n   \
    \         } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n\
    \                path[i][j] = 1;\n                path_val[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                path[i][j] = 0;\n                path_val[i][j][0] = grid[i][j];\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j]\
    \ = 0;\n                    path_val[i][j][0] = grid[i][j];\n                }\
    \ else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                    path[i][j] = 1;\n                    path_val[i][j][0]\
    \ = grid[i][j];\n                } else {\n                    dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                   ", "    std::vector<long> result;\n    // Implement\
    \ your solution here\n    return result;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(k + 1, -1))));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n            parent[i][j][1][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for\
    \ (int x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n\
    \                        if (x == i && y == j) {\n                           \
    \ continue;\n                        }\n                        if (abs(x - i)\
    \ + abs(y - j) != 1) {\n                            continue;\n              \
    \          }\n                        if (dp[x][y][l - 1] == -1) {\n         \
    \                   continue;\n                        }\n                   \
    \     if (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j])\
    \ {\n                            dp[i][j][l] = dp[x][y][l - 1] * 10 + grid[i][j];\n\
    \                            parent[i][j][l] = parent[x][y][l - 1];\n        \
    \                    parent[i][j][l].push_back(grid[i][j]);\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \    }\n    long min_val = -1;\n   ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k;\
    \ l++) {\n                if (i - 1 >= 0 && dp[i - 1][j][l - 1] != -1) {\n   \
    \                 if (dp[i][j][l] == -1 || dp[i][j][l] > dp[i - 1][j][l - 1])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            parent[i][j][l][0] = i - 1;\n                        parent[i][j][l][1]\
    \ = j;\n                    }\n                }\n                if (i + 1 <\
    \ n && dp[i + 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1\
    \ || dp[i][j][l] > dp[i + 1][j][l - 1]) {\n                        dp[i][j][l]\
    \ = dp[i + 1][j][l - 1];\n                        parent[i][j][l][0] = i + 1;\n\
    \                        parent[i][j][l][1] = j;\n                    }\n    \
    \            }\n                if (j - 1 >= 0 && dp[i][j - 1][l -", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<long> res;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n          \
    \      path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n       \
    \         dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                path[i][j][0] = grid[i][j];\n            } else {\n         \
    \       dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n               \
    \ path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int\
    \ l = 1; l <= k; l++) {\n                if (i == 0 && j == 0) {\n           \
    \         path[i][j][l] = grid[i][j];\n                } else if (i == 0) {\n\
    \                    path[i][j][l] = path[i][j - 1][l - 1];\n                }\
    \ else if (j == 0) {\n                    path[i][j][l] = path[i - 1][j][l - 1];\n\
    \                } else {\n                    if (dp[i - 1][j] < dp[i][j -",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(k + 1, -1))));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n            prev[i][j][1][0] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                      dp[i][j][l] = dp[i - 1][j][l - 1];\n                  \
    \      prev[i][j][l] = prev[i - 1][j][l - 1];\n                    }\n       \
    \         }\n                if (j > 0) {\n                    if (dp[i][j - 1][l\
    \ - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i][j - 1][l\
    \ - 1];\n                        prev[i][j][l] = prev[i][j - 1][l - 1];\n    \
    \                }\n                }\n                if (i < n - 1) {\n    \
    \                if (dp[i + 1][j][l - 1] < dp[i][j][l]) {\n                  \
    \      dp[i][j][l] = dp[i + 1][j][l - 1];\n                        prev[i][j][l]\
    \ = prev[i + 1][j", "    std::vector<long> result;\n    // Implement your solution\
    \ here\n    return result;", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_idx(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n \
    \           path_idx[i][j][1] = 1;\n        }\n    }\n    for (int len = 2; len\
    \ <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                for (int x = 0; x < n; x++) {\n      \
    \              for (int y = 0; y < n; y++) {\n                        if (x ==\
    \ i && y == j) continue;\n                        if (std::abs(x - i) + std::abs(y\
    \ - j) != 1) continue;\n                        if (dp[x][y] == INT_MAX) continue;\n\
    \                        if (dp[x][y] + grid[i][j] < dp[i][j]) {\n           \
    \                 dp[i][j] = dp[x][y] + grid[i][j];\n                        \
    \    path[i][j][len] = grid[i][j];\n                            path_idx[i][j][len]\
    \ = len;\n                            for (int l = 1; l < len; l++) {\n      \
    \                          path[i][j][l] = path[x][y][l];\n                  \
    \              path_idx[i][j][l] = path_idx[x][y][l];\n                      \
    \      }\n                        } else if (", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i\
    \ > 0) {\n                    if (dp[i - 1][j][len - 1] < dp[i][j][len]) {\n \
    \                       dp[i][j][len] = dp[i - 1][j][len - 1];\n             \
    \           path[i][j][len] = path[i - 1][j][len - 1];\n                     \
    \   path[i][j][len].push_back(grid[i][j]);\n                    }\n          \
    \      }\n                if (i < n - 1) {\n                    if (dp[i + 1][j][len\
    \ - 1] < dp[i][j][len]) {\n                        dp[i][j][len] = dp[i + 1][j][len\
    \ - 1];\n                        path[i][j][len] = path[i + 1][j][len - 1];\n\
    \                        path[i][j][len].push_back(grid[i][j]);\n            \
    \        }\n                }\n                if (j > 0) {\n                \
    \    if (dp[i][j - 1][len - 1] < dp[i][j][len]) {", "    std::vector<long> res;\n\
    \    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j\
    \ < grid[0].size(); j++) {\n            if (i == 0 && j == 0) {\n            \
    \    dp[i][j] = grid[i][j];\n            } else if (i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n            } else if (j == 0) {\n \
    \               dp[i][j] = dp[i - 1][j] + grid[i][j];\n            } else {\n\
    \                dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n\
    \            }\n        }\n    }\n    int i = grid.size() - 1;\n    int j = grid[0].size()\
    \ - 1;\n    while (k > 0) {\n        if (i == 0 && j == 0) {\n            res.push_back(grid[i][j]);\n\
    \            i--;\n            j--;\n        } else if (i == 0) {\n          \
    \  res.push_back(grid[i][j]);\n            j--;\n        } else if (j == 0) {\n\
    \            res.push_back(grid[i][j]);\n            i--;\n        } else {\n\
    \            if (dp[i - 1][j] < dp[i][j - 1]) {\n                res.push_back(grid[i][j]);\n\
    \                i--;\n            } else {\n                res.push_back(grid[i][j]);\n\
    \                j--;\n            }\n        }\n        k--;\n    }\n    std::reverse(res.begin(),\
    \ res.end());\n    return res;", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i\
    \ > 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j];\n\
    \                    path[i][j][len] = path[i - 1][j][len - 1];\n            \
    \    }\n                if (j > 0 && dp[i][j - 1] < dp[i][j]) {\n            \
    \        dp[i][j] = dp[i][j - 1];\n                    path[i][j][len] = path[i][j\
    \ - 1][len - 1];\n                }\n                if (i < n - 1 && dp[i + 1][j]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j];\n              \
    \      path[i][j][len] = path[i + 1][j][len - 1];\n                }\n       \
    \         if (j < n - 1 && dp[i][j + 1] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i][j + 1];\n                    path[i][j][len] = path[i][j + 1][len -\
    \ 1];\n                }\n                path[i][j][len].push_back(grid[i][j]);\n\
    \            }", "    // Write your code here\n    std::vector<long> result;\n\
    \    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j <\
    \ grid[0].size(); j++) {\n            if(i == 0 && j == 0) {\n               \
    \ dp[i][j] = grid[i][j];\n            } else if(i == 0) {\n                dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n            } else if(j == 0) {\n            \
    \    dp[i][j] = dp[i - 1][j] + grid[i][j];\n            } else {\n           \
    \     dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        \
    \    }\n        }\n    }\n    int i = grid.size() - 1;\n    int j = grid[0].size()\
    \ - 1;\n    while(k > 0) {\n        if(i == 0 && j == 0) {\n            result.push_back(grid[i][j]);\n\
    \            i--;\n            j--;\n            k--;\n        } else if(i ==\
    \ 0) {\n            result.push_back(grid[i][j]);\n            j--;\n        \
    \    k--;\n        } else if(j == 0) {\n            result.push_back(grid[i][j]);\n\
    \            i--;\n            k--;\n        } else {\n            if(dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                result.push_back(grid[i][j]);\n         \
    \       i--;\n                k--;\n            } else {\n                result.push_back(grid[i][j]);\n\
    \                j--;\n                k--;\n            }\n        }\n    }\n\
    \    std::reverse(result.begin(), result.end());\n    return result;", "    int\
    \ n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            } else\
    \ if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n     \
    \           path[i][j] = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else {\n                    path[i][j] = path[i][j - 1];\n                }\n\
    \                path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n\
    \    int i = n - 1, j = n - 1;\n    for (int l = 1; l < k; l++) {\n        if\
    \ (i == 0) {\n            path[i][j][l] = path[i][j - 1][l - 1];\n           \
    \ j--;\n        } else if (j ==", "    // Write your code here\n    std::vector<long>\
    \ result;\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(grid.size(), std::vector<long>(grid[0].size(),\
    \ -1));\n    std::vector<std::vector<long>> visited(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long,\
    \ std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>>\
    \ pq;\n    for(long i = 0; i < grid.size(); i++) {\n        for(long j = 0; j\
    \ < grid[0].size(); j++) {\n            dp[i][j] = grid[i][j];\n            pq.push({grid[i][j],\
    \ {i, j}});\n        }\n    }\n    while(!pq.empty()) {\n        auto top = pq.top();\n\
    \        pq.pop();\n        long x = top.second.first;\n        long y = top.second.second;\n\
    \        if(visited[x][y] == 1) {\n            continue;\n        }\n        visited[x][y]\
    \ = 1;\n        if(x > 0 && dp[x - 1][y] > dp[x][y] + grid[x - 1][y]) {\n    \
    \        dp[x - 1][y] = dp[x][y] + grid[x - 1][y];\n            parent[x - 1][y]\
    \ = x * grid[0].size() + y;\n            pq.push({dp[x - 1][y], {x - 1, y}});\n\
    \        }\n        if(x < grid.size() - 1 && dp[x + 1][y] > dp[x][y] + grid[x\
    \ + 1][y]) {\n            dp[x + 1][y] = dp[x][y", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_index(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n    \
    \        if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n    \
    \            path[i][j][0] = grid[i][j];\n                path_index[i][j][0]\
    \ = 0;\n            }\n            else {\n                if(i > 0) {\n     \
    \               if(dp[i-1][j] < dp[i][j]) {\n                        dp[i][j]\
    \ = dp[i-1][j];\n                        path[i][j] = path[i-1][j];\n        \
    \                path_index[i][j] = path_index[i-1][j];\n                    }\n\
    \                }\n                if(j > 0) {\n                    if(dp[i][j-1]\
    \ < dp[i][j]) {\n                        dp[i][j] = dp[i][j-1];\n            \
    \            path[i][j] = path[i][j-1];\n                        path_index[i][j]\
    \ = path_index[i][j-1];\n                    }\n                }\n          \
    \      for(int l = 0; l < k; l++) {\n                    if(path_index[i][j][l]\
    \ == 0) {\n                        path[i][j][l] = grid[i][j];\n             \
    \           path_index[i][j][l] = 1;\n                        break;\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ path[n", "    std::vector<long> result;\n    // Write your code here\n    return\
    \ result;", "    // Write your code here\n    int n = grid.size();\n    int m\
    \ = grid[0].size();\n    std::vector<long> res;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else{\n                if(i > 0){\n\
    \                    if(dp[i-1][j] + 1 < dp[i][j]){\n                        dp[i][j]\
    \ = dp[i-1][j] + 1;\n                        path[i][j] = path[i-1][j];\n    \
    \                    path[i][j][dp[i][j]] = grid[i][j];\n                    }\n\
    \                    else if(dp[i-1][j] + 1 == dp[i][j]){\n                  \
    \      if(path[i-1][j] < path[i][j]){\n                            path[i][j]\
    \ = path[i-1][j];\n                            path[i][j][dp[i][j]] = grid[i][j];\n\
    \                        }\n                    }\n                }\n       \
    \         if(j > 0){\n                    if(dp[i][j-1] + 1 < dp[i][j]){\n   \
    \                     dp[i][j] = dp[i][j-1] + 1;\n                        path[i][j]\
    \ = path[i][j-1];\n                        path[i][j][dp[i][j]] = grid[i][j];\n\
    \                    }\n                    else if(dp[i][j-1] + 1 == dp[i][j]){\n\
    \                        if(path[i][j-1] < path[i][", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0,\
    \ 1}};\n    std::vector<std::vector<int>> path;\n    std::vector<long> result;\n\
    \    dp[0][0] = grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            for (int d = 0; d < 4; d++) {\n          \
    \      int x = i + dir[d][0];\n                int y = j + dir[d][1];\n      \
    \          if (x < 0 || x >= n || y < 0 || y >= n) {\n                    continue;\n\
    \                }\n                if (dp[x][y] > dp[i][j] + grid[x][y]) {\n\
    \                    dp[x][y] = dp[i][j] + grid[x][y];\n                    parent[x][y]\
    \ = i * n + j;\n                }\n            }\n        }\n    }\n    int x\
    \ = n - 1;\n    int y = n - 1;\n    int cur = x * n + y;\n    while (cur != -1)\
    \ {\n        path.push_back({x, y});\n        cur = parent[x][y];\n        x =\
    \ cur / n;\n        y = cur % n;\n    }\n    for (int i = path.size() - 1; i >=\
    \ 0; i--) {\n        result.push_back(grid[path[i][0]][path[i][1]]);\n    }\n\
    \    return result;", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, LONG_MAX));\n \
    \   std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n                path[i][j][0] =\
    \ grid[i][j];\n            }\n            else if(j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                path[i][j] = path[i - 1][j];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\
    \ {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                    path[i][j][0] = grid[i][j];\n                }\n        \
    \        else if(dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n\
    \                    path[i][j][0] = grid[i][j];\n                }\n        \
    \        else {\n                    dp[i][j] = dp[i -", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0] =\
    \ grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            if (i - 1 >= 0) {\n                if (dp[i - 1][j] +\
    \ grid[i][j] < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    for (int l = 0; l <= k; l++) {\n                        path[i][j][l]\
    \ = path[i - 1][j][l];\n                    }\n                    path[i][j][1]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] + grid[i][j] == dp[i][j])\
    \ {\n                    for (int l = 1; l <= k; l++) {\n                    \
    \    if (path[i - 1][j][l - 1] + grid[i][j] < path[i][j][l]) {\n             \
    \               path[i][j][l] = path[i - 1][j][l - 1] + grid[i][j];\n        \
    \                }\n                    }\n                }\n            }\n\
    \            if (j - 1 >= 0) {\n                if (dp[i][j - 1] + grid[i][j]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n \
    \                   for (int l = 0; l <= k; l++) {\n                        path[i][j][l]\
    \ = path[i][j - 1][l];\n                    }\n                    path[i][j][1]\
    \ = grid[i][j", "    // Write your code here\n    long n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(long\
    \ i = 0; i < n; i++) {\n        for(long j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n\
    \                path[i][j][dp[i][j]] = grid[i][j];\n            }\n         \
    \   else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n        \
    \        path[i][j] = path[i - 1][j];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            }\n            else {\n                if(dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + 1;\n      \
    \              path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                }\n                else if(dp[i - 1][j] > dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n                \
    \    path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]] =\
    \ grid[i][j];\n                }\n                else {\n                   \
    \ dp[i][j] = dp[i - 1][j]", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> path;\n\
    \    std::vector<long> res;\n    dp[0][0] = grid[0][0];\n    for(int i = 0; i\
    \ < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i > 0){\n  \
    \              if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n                    dp[i][j]\
    \ = dp[i-1][j] + grid[i][j];\n                    parent[i][j] = 1;\n        \
    \        }\n            }\n            if(j > 0){\n                if(dp[i][j]\
    \ > dp[i][j-1] + grid[i][j]){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                    parent[i][j] = 2;\n                }\n            }\n   \
    \     }\n    }\n    int i = n-1, j = n-1;\n    while(k--){\n        res.push_back(grid[i][j]);\n\
    \        if(parent[i][j] == 1){\n            i--;\n        }\n        else if(parent[i][j]\
    \ == 2){\n            j--;\n        }\n    }\n    return res;", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int len = 2; len <= k; len++) {\n\
    \        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\
    \ {\n                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i - 1][j];\n                    path[i][j][len] = path[i -\
    \ 1][j][len - 1];\n                }\n                if (j > 0 && dp[i][j - 1]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1];\n              \
    \      path[i][j][len] = path[i][j - 1][len - 1];\n                }\n       \
    \         if (i < n - 1 && dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i + 1][j];\n                    path[i][j][len] = path[i + 1][j][len -\
    \ 1];\n                }\n                if (j < n - 1 && dp[i][j + 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j + 1];\n                    path[i][j][len]\
    \ = path[i][j + 1][len - 1];\n                }\n                path[i][j][len].push_back(grid[i][j]);\n\
    \            }", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0,\
    \ 1}};\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    while (!q.empty()) {\n        auto cur = q.front();\n   \
    \     q.pop();\n        for (auto d : dir) {\n            int x = cur.first +\
    \ d[0];\n            int y = cur.second + d[1];\n            if (x < 0 || x >=\
    \ n || y < 0 || y >= n) {\n                continue;\n            }\n        \
    \    if (dp[x][y] > dp[cur.first][cur.second] + grid[x][y]) {\n              \
    \  dp[x][y] = dp[cur.first][cur.second] + grid[x][y];\n                path[x][y]\
    \ = cur.first * n + cur.second;\n                q.push({x, y});\n           \
    \ }\n        }\n    }\n    std::vector<long> ans;\n    int x = n - 1, y = n -\
    \ 1;\n    while (k > 0) {\n        ans.push_back(grid[x][y]);\n        visited[x][y]\
    \ = 1;\n        int p = path[x][y];\n        x = p / n;\n        y = p % n;\n\
    \        k--;\n    }\n    return ans;", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][0] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<int>>\
    \ path;\n    std::vector<long> result;\n    dp[0][0] = grid[0][0];\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for\
    \ (int d = 0; d < 4; d++) {\n                int x = i + dir[d][0];\n        \
    \        int y = j + dir[d][1];\n                if (x < 0 || x >= n || y < 0\
    \ || y >= n) {\n                    continue;\n                }\n           \
    \     if (dp[x][y] > dp[i][j] + grid[x][y]) {\n                    dp[x][y] =\
    \ dp[i][j] + grid[x][y];\n                    parent[x][y] = i * n + j;\n    \
    \            }\n            }\n        }\n    }\n    int x = n - 1;\n    int y\
    \ = n - 1;\n    for (int i = 0; i < k; i++) {\n        path.push_back({x, y});\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n    }\n\
    \    std::reverse(path.begin(), path.end());\n    for (int i = 0; i < k; i++)\
    \ {\n        result.push_back(grid[path[i][0]][path[i][1]]);\n    }\n    return\
    \ result;", "\t// Write your code here\n\tint n = grid.size();\n\tint m = grid[0].size();\n\
    \tstd::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n\tstd::vector<std::vector<long>>\
    \ path(n, std::vector<long>(m, 0));\n\tstd::vector<std::vector<int>> visited(n,\
    \ std::vector<int>(m, 0));\n\tstd::vector<long> ans;\n\tstd::priority_queue<std::pair<long,\
    \ std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long,\
    \ std::pair<int, int>>>> pq;\n\tpq.push({grid[0][0], {0, 0}});\n\tdp[0][0] = grid[0][0];\n\
    \tpath[0][0] = grid[0][0];\n\tvisited[0][0] = 1;\n\twhile(!pq.empty()) {\n\t\t\
    auto p = pq.top();\n\t\tpq.pop();\n\t\tint x = p.second.first;\n\t\tint y = p.second.second;\n\
    \t\tif(x == n - 1 && y == m - 1) {\n\t\t\tans.push_back(path[x][y]);\n\t\t\tbreak;\n\
    \t\t}\n\t\tif(x + 1 < n && visited[x + 1][y] == 0) {\n\t\t\tpq.push({dp[x][y]\
    \ + grid[x + 1][y], {x + 1, y}});\n\t\t\tvisited[x + 1][y] = 1;\n\t\t\tdp[x +\
    \ 1][y] = dp[x][y] + grid[x + 1][y];\n\t\t\tpath[x + 1][y] = path[x][y] * 10 +\
    \ grid[x + 1][y];\n\t\t}\n\t\tif(y + 1 < m && visited[x][y + 1] == 0) {\n\t\t\t\
    pq.push({dp[x][y", "    // Write your code here\n    int n = grid.size();\n  \
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n       \
    \     }\n            else {\n                dp[i][j] = std::min(dp[i - 1][j],\
    \ dp[i][j - 1]) + grid[i][j];\n                path[i][j][1] = grid[i][j];\n \
    \           }\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            for(int l = 2; l <= k; l++) {\n          \
    \      if(i == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n\
    \                }\n                else if(i == 0) {\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1] + grid[i][j];\n                }\n                else\
    \ if(j == 0) {\n                    path[i][j][l] = path[i - 1][j][l - 1] + grid[i][",
  "    std::vector<long> res;\n    std::vector<std::vector<int>> dp(grid.size(), std::vector<int>(grid[0].size(),\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<int>>> path(grid.size(),\
    \ std::vector<std::vector<int>>(grid[0].size(), std::vector<int>(k + 1, 0)));\n\
    \    dp[0][0] = grid[0][0];\n    path[0][0][0] = grid[0][0];\n    for (int i =\
    \ 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++)\
    \ {\n            if (i - 1 >= 0) {\n                if (dp[i - 1][j] + grid[i][j]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n \
    \                   for (int l = 0; l < k; l++) {\n                        path[i][j][l]\
    \ = path[i - 1][j][l];\n                    }\n                    path[i][j][k\
    \ - 1] = grid[i][j];\n                }\n            }\n            if (j - 1\
    \ >= 0) {\n                if (dp[i][j - 1] + grid[i][j] < dp[i][j]) {\n     \
    \               dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    for\
    \ (int l = 0; l < k; l++) {\n                        path[i][j][l] = path[i][j\
    \ - 1][l];\n                    }\n                    path[i][j][k - 1] = grid[i][j];\n\
    \                }\n            }\n        }\n    }\n    for (int i = 0; i < k;\
    \ i++) {\n        res.push_back(path[grid.size() - 1][grid[0].size() - 1][i]);\n\
    \    }\n    return res;", "    // Write your code here\n    std::vector<long>\
    \ ans;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ prev(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n\
    \    for(long i = 0; i < n; i++) {\n        for(long j = 0; j < m; j++) {\n  \
    \          if(i == 0 && j == 0) {\n                dp[i][j] = 0;\n           \
    \     prev[i][j][0] = -1;\n            }\n            else {\n               \
    \ if(i > 0) {\n                    if(dp[i - 1][j] + 1 < dp[i][j]) {\n       \
    \                 dp[i][j] = dp[i - 1][j] + 1;\n                        prev[i][j]\
    \ = prev[i - 1][j];\n                    }\n                    else if(dp[i -\
    \ 1][j] + 1 == dp[i][j]) {\n                        if(prev[i - 1][j] < prev[i][j])\
    \ {\n                            prev[i][j] = prev[i - 1][j];\n              \
    \          }\n                    }\n                }\n                if(j >\
    \ 0) {\n                    if(dp[i][j - 1] + 1 < dp[i][j]) {\n              \
    \          dp[i][j] = dp[i][j - 1] + 1;\n                        prev[i][j] =\
    \ prev[i][j - 1];\n                    }\n                    else if(dp[i][j\
    \ - 1] + 1 == dp[i][j]) {\n                        if(prev[i][j - 1] < prev[i][j])\
    \ {\n                            prev[i][j] = prev[i][j - 1];\n              \
    \          }\n                    }\n                }\n            }\n      \
    \      prev[i][j][dp[i][j]] = grid[i][j];\n        }\n    }\n", "    std::vector<long>\
    \ ans;\n    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        for(int j = 0; j < n; j++) {\n            for(int l = 2; l <=\
    \ k; l++) {\n                if(i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                }\n                if(j > 0) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n \
    \               }\n                if(i < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n                }\n         \
    \       if(j < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n            }\n        }\n    }\n\
    \    int x = 0, y = 0;\n    for(int i = 0; i < n; i++) {\n        for(int j =\
    \ 0; j < n; j++) {\n            if(dp[i][j][k] < dp[x][y][k]) {\n            \
    \    x = i;\n                y = j;\n            }\n        }\n    }\n    ans.push_back(grid[x][y]);\n\
    \    for(int i = k - 1; i >= 1; i--) {\n        if(", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, 0)));\n    for(int i = 0; i < n; i++)\n    {\n      \
    \  for(int j = 0; j < n; j++)\n        {\n            if(i == 0 && j == 0)\n \
    \           {\n                dp[i][j] = 0;\n                path[i][j][1] =\
    \ grid[i][j];\n            }\n            else\n            {\n              \
    \  if(i > 0)\n                {\n                    if(dp[i-1][j] < dp[i][j])\n\
    \                    {\n                        dp[i][j] = dp[i-1][j];\n     \
    \                   path[i][j] = path[i-1][j];\n                    }\n      \
    \              else if(dp[i-1][j] == dp[i][j])\n                    {\n      \
    \                  for(int l = 1; l <= k; l++)\n                        {\n  \
    \                          if(path[i-1][j][l] < path[i][j][l])\n             \
    \               {\n                                path[i][j] = path[i-1][j];\n\
    \                                break;\n                            }\n     \
    \                       else if(path[i-1][j][l] > path[i][j][l])\n           \
    \                 {\n                                break;\n                \
    \            }\n                        }\n                    }\n           \
    \     }\n                if(j > 0)\n                {\n                    if(dp[i][j-1]\
    \ < dp[i][j])\n                    {\n                        dp[i][j] = dp[i][j-1];\n\
    \                        path[i][j] = path[i][j-1];\n                    }\n \
    \                   else if(dp[i][j-1] == dp[i][j])\n                    {\n \
    \                       for(int l = 1; l <= k; l++)\n                        {",
  "    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(grid.size(),\
    \ std::vector<long>(grid[0].size(), INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(grid.size(), std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n\
    \    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size();\
    \ j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n\
    \                path[i][j].push_back(grid[i][j]);\n            }\n          \
    \  else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                path[i][j] = path[i - 1][j];\n      \
    \          path[i][j].push_back(grid[i][j]);\n            }\n            else\
    \ {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                    path[i][j].push_back(grid[i][j]);\n                }\n  \
    \              else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j - 1];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    int i = grid.size() -\
    \ 1;\n    int j", "    // Write your code here\n    int n = grid.size();\n   \
    \ std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n,\
    \ -1));\n    dp[0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n       \
    \ for(int j = 0; j < n; j++){\n            if(i > 0){\n                if(dp[i-1][j]\
    \ < dp[i][j]){\n                    dp[i][j] = dp[i-1][j];\n                 \
    \   parent[i][j] = 0;\n                }\n            }\n            if(j > 0){\n\
    \                if(dp[i][j-1] < dp[i][j]){\n                    dp[i][j] = dp[i][j-1];\n\
    \                    parent[i][j] = 1;\n                }\n            }\n   \
    \         if(i < n-1){\n                if(dp[i+1][j] < dp[i][j]){\n         \
    \           dp[i][j] = dp[i+1][j];\n                    parent[i][j] = 2;\n  \
    \              }\n            }\n            if(j < n-1){\n                if(dp[i][j+1]\
    \ < dp[i][j]){\n                    dp[i][j] = dp[i][j+1];\n                 \
    \   parent[i][j] = 3;\n                }\n            }\n            dp[i][j]\
    \ += grid[i][j];\n        }\n    }\n    int x = n-1, y = n-1;\n    while(k > 0){\n\
    \        ans.push_back(grid[x][y]);\n        if(parent[x][y] == 0){\n        \
    \    x--;\n        }\n        else if(parent[x][y] == 1){\n            y--;\n\
    \        }\n        else if(parent[x][y] == 2){\n           ", "    // Write your\
    \ code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> dp_path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            dp_path[i][j][1].push_back(grid[i][j]);\n       \
    \ }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m;\
    \ j++) {\n            for (int l = 2; l <= k; l++) {\n                if (i -\
    \ 1 >= 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n          \
    \              if (dp[i][j][l] == -1) {\n                            dp[i][j][l]\
    \ = dp[i - 1][j][l - 1] + grid[i][j];\n                            dp_path[i][j][l]\
    \ = dp_path[i - 1][j][l - 1];\n                            dp_path[i][j][l].push_back(grid[i][j]);\n\
    \                        } else {\n                            if (dp[i - 1][j][l\
    \ - 1] + grid[i][j] < dp[i][j][l]) {\n                                dp[i][j][l]\
    \ = dp[i - 1][j][l - 1] + grid[i][j];\n                                dp_path[i][j][l]\
    \ = dp_path[i - 1][j][l - 1];\n                               ", "    // Write\
    \ your code here\n    long n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(long\
    \ i = 0; i < n; i++) {\n        for(long j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \                for(long l = 1; l <= k; l++) {\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                }\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n               \
    \ path[i][j][0] = grid[i][j];\n                for(long l = 1; l <= k; l++) {\n\
    \                    path[i][j][l] = path[i - 1][j][l - 1];\n                }\n\
    \            }\n            else {\n                dp[i][j] = std::min(dp[i -\
    \ 1][j], dp[i][j - 1]) + 1;\n                path[i][j][0] = grid[i][j];\n   \
    \             if(dp[i - 1][j] < dp[i][j - 1]) {\n                    for(long\
    \ l = 1; l <= k; l++) {\n                        path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                    }\n                }\n                else {\n  \
    \                  for(long l = 1; l <= k; l++) {\n                        path[i][j][l]\
    \ = path[i][", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else {\n                if(i > 0)\
    \ {\n                    if(dp[i - 1][j] + 1 < dp[i][j]) {\n                 \
    \       dp[i][j] = dp[i - 1][j] + 1;\n                        path[i][j] = path[i\
    \ - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n      \
    \              }\n                    else if(dp[i - 1][j] + 1 == dp[i][j]) {\n\
    \                        std::vector<long> temp = path[i - 1][j];\n          \
    \              temp.push_back(grid[i][j]);\n                        if(temp <\
    \ path[i][j]) {\n                            path[i][j] = temp;\n            \
    \            }\n                    }\n                }\n                if(j\
    \ > 0) {\n                    if(dp[i][j - 1] + 1 < dp[i][j]) {\n            \
    \            dp[i][j] = dp[i][j - 1] + 1;\n                        path[i][j]\
    \ = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i][j - 1] + 1 == dp[i][j])\
    \ {\n                        std::vector<long> temp = path[i][j - 1];\n      \
    \                  temp.push_back(grid[i][j]);\n                        if(temp\
    \ < path[i][j])", "    // Write your code here\n    int n = grid.size();\n   \
    \ std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j]\
    \ = grid[i][j];\n            path[i][j][1] = grid[i][j];\n        }\n    }\n \
    \   for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n     \
    \       for(int l = 2; l <= k; l++) {\n                if(i - 1 >= 0 && dp[i -\
    \ 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j];\n        \
    \            path[i][j][l] = path[i - 1][j][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n\
    \                }\n                if(i + 1 < n && dp[i + 1][j] < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i + 1][j];\n                    path[i][j][l]\
    \ = path[i + 1][j][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n\
    \                }\n                if(j - 1 >= 0 && dp[i][j - 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1];\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                    path[i][j][l].push_back(grid[i][j]);\n\
    \                }\n                if(j + 1 < n && dp[i][j + 1] < dp[i][", " \
    \   int n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, LONG_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n               \
    \     dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i -\
    \ 1][j];\n                    path[i][j][dp[i][j]] = grid[i][j];\n           \
    \     } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j - 1];\n    \
    \                path[i][j][dp[i][j]] = grid[i][j];\n                } else {\n\
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                    path[",
  "    // Write your code here\n    std::vector<long> ans;\n    long n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    for(long\
    \ i = 0; i < n; i++)\n    {\n        for(long j = 0; j < n; j++)\n        {\n\
    \            dp[i][j] = grid[i][j];\n        }\n    }\n    for(long i = 0; i <\
    \ n; i++)\n    {\n        for(long j = 0; j < n; j++)\n        {\n           \
    \ if(i > 0)\n            {\n                dp[i][j] = std::min(dp[i][j], dp[i\
    \ - 1][j]);\n            }\n            if(j > 0)\n            {\n           \
    \     dp[i][j] = std::min(dp[i][j], dp[i][j - 1]);\n            }\n        }\n\
    \    }\n    long i = 0, j = 0;\n    while(k > 0)\n    {\n        ans.push_back(dp[i][j]);\n\
    \        if(i + 1 < n && dp[i + 1][j] == dp[i][j])\n        {\n            i++;\n\
    \        }\n        else if(j + 1 < n && dp[i][j + 1] == dp[i][j])\n        {\n\
    \            j++;\n        }\n        k--;\n    }\n    return ans;", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n \
    \           if(i == 0 && j == 0)\n            {\n                dp[i][j] = grid[i][j];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\n\
    \            {\n                if(i > 0)\n                {\n               \
    \     if(dp[i - 1][j] < dp[i][j])\n                    {\n                   \
    \     dp[i][j] = dp[i - 1][j];\n                        path[i][j] = path[i -\
    \ 1][j];\n                    }\n                    else if(dp[i - 1][j] == dp[i][j])\n\
    \                    {\n                        for(int l = 0; l < k; l++)\n \
    \                       {\n                            if(path[i - 1][j][l] <\
    \ path[i][j][l])\n                            {\n                            \
    \    path[i][j] = path[i - 1][j];\n                                break;\n  \
    \                          }\n                            else if(path[i - 1][j][l]\
    \ > path[i][j][l])\n                            {\n                          \
    \      break;\n                            }\n                        }\n    \
    \                }\n                }\n                if(j > 0)\n           \
    \     {\n                    if(dp[i][j - 1] < dp[i][j])\n                   \
    \ {\n                        dp[i][j] = dp[i][j - 1];\n                      \
    \  path[i][j] = path[i][j - 1];\n                    }\n                    else\
    \ if(dp[i][j - 1] == dp[i][j])\n                    {\n                      \
    \  for(int l = 0; l < k; l++)\n", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(k + 1, -1))));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n            prev[i][j][1][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ curr;\n                if (i > 0) {\n                    if (dp[i - 1][j][l\
    \ - 1] != -1) {\n                        curr.push_back(dp[i - 1][j][l - 1]);\n\
    \                    }\n                }\n                if (i < n - 1) {\n\
    \                    if (dp[i + 1][j][l - 1] != -1) {\n                      \
    \  curr.push_back(dp[i + 1][j][l - 1]);\n                    }\n             \
    \   }\n                if (j > 0) {\n                    if (dp[i][j - 1][l -\
    \ 1] != -1) {\n                        curr.push_back(dp[i][j - 1][l - 1]);\n\
    \                    }\n                }\n                if (j < n - 1) {\n\
    \                    if (dp[i][j + 1][l - 1] != -1) {\n                      \
    \  curr.push_back(dp[i][j + 1][l - 1]);\n                    }\n             \
    \   }\n                if (curr.size() == 0) {\n                    continue;\n\
    \               ", "    std::vector<long> ans;\n    // Write your code here\n\
    \    return ans;", "    // Write your code here\n    int n = grid.size();\n  \
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j] = path[i][j\
    \ - 1];\n                path[i][j][0] = grid[i][j];\n            }\n        \
    \    else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            }\n            else {\n                if(dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else if(dp[i - 1][j] > dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n       \
    \             path[i][j] = path[i][j - 1];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else {\n                 \
    \   dp[i][j] = dp[i -", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, 0))));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n\
    \                dp[i][j][l] = INT_MAX;\n                if (i > 0) {\n      \
    \              if (dp[i][j][l] > dp[i - 1][j][l - 1]) {\n                    \
    \    dp[i][j][l] = dp[i - 1][j][l - 1];\n                        parent[i][j][l][0]\
    \ = i - 1;\n                        parent[i][j][l][1] = j;\n                \
    \    }\n                }\n                if (i < n - 1) {\n                \
    \    if (dp[i][j][l] > dp[i + 1][j][l - 1]) {\n                        dp[i][j][l]\
    \ = dp[i + 1][j][l - 1];\n                        parent[i][j][l][0] = i + 1;\n\
    \                        parent[i][j][l][1] = j;\n                    }\n    \
    \            }\n                if (j > 0) {\n                    if (dp[i][j][l]\
    \ > dp[i][j - 1][l - 1]) {\n                        dp[i][j][l] = dp[", "    std::vector<long>\
    \ ans;\n    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n \
    \   for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n       \
    \     dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n      \
    \  }\n    }\n    for(int i = 2; i <= k; i++){\n        for(int j = 0; j < n; j++){\n\
    \            for(int l = 0; l < m; l++){\n                long min = LONG_MAX;\n\
    \                int min_i = -1;\n                int min_j = -1;\n          \
    \      if(j - 1 >= 0){\n                    if(dp[j - 1][l] < min){\n        \
    \                min = dp[j - 1][l];\n                        min_i = j - 1;\n\
    \                        min_j = l;\n                    }\n                }\n\
    \                if(j + 1 < n){\n                    if(dp[j + 1][l] < min){\n\
    \                        min = dp[j + 1][l];\n                        min_i =\
    \ j + 1;\n                        min_j = l;\n                    }\n        \
    \        }\n                if(l - 1 >= 0){\n                    if(dp[j][l -\
    \ 1] < min){\n                        min = dp[j][l - 1];\n                  \
    \      min_i = j;\n                        min_j = l - 1;\n                  \
    \  }\n                }\n                if(l + 1 < m){\n                    if(dp[j][l\
    \ + 1] < min){\n                        min = dp[j][l + 1];\n                \
    \        min_i = j;\n                        min_j = l + 1;\n                \
    \    }\n                }\n                dp[j", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<int>>> path(n, std::vector<std::vector<int>>(n,\
    \ std::vector<int>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j][0] = grid[i][j];\n            } else if (j == 0) {\n    \
    \            dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \            } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + 1;\n                path[i][j][0] = grid[i][j];\n            }\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            for (int l = 1; l <= k; l++) {\n                if (i\
    \ == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n       \
    \         } else if (i == 0) {\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n                } else if (j == 0) {\n                    path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                } else {\n                    if (dp[i\
    \ - 1][j] < dp[i][j - 1]) {\n                        path[i][j", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, -1));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j-1] + grid[i][j];\n                path[i][j] = 1;\n    \
    \        }\n            else if(j == 0) {\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = 0;\n            }\n            else\
    \ {\n                if(dp[i-1][j] < dp[i][j-1]) {\n                    dp[i][j]\
    \ = dp[i-1][j] + grid[i][j];\n                    path[i][j] = 0;\n          \
    \      }\n                else {\n                    dp[i][j] = dp[i][j-1] +\
    \ grid[i][j];\n                    path[i][j] = 1;\n                }\n      \
    \      }\n        }\n    }\n    int i = n-1, j = n-1;\n    std::vector<long> ans;\n\
    \    while(k--) {\n        ans.push_back(grid[i][j]);\n        if(path[i][j] ==\
    \ 0) {\n            i--;\n        }\n        else {\n            j--;\n      \
    \  }\n    }\n    return ans;", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else {\n                if(i > 0) {\n                    for(int l = 0; l\
    \ <= k; l++) {\n                        if(dp[i - 1][j] + 1 < dp[i][j]) {\n  \
    \                          dp[i][j] = dp[i - 1][j] + 1;\n                    \
    \        path[i][j] = path[i - 1][j];\n                            path[i][j][l]\
    \ = grid[i][j];\n                        }\n                        else if(dp[i\
    \ - 1][j] + 1 == dp[i][j]) {\n                            if(path[i - 1][j] <\
    \ path[i][j]) {\n                                path[i][j] = path[i - 1][j];\n\
    \                                path[i][j][l] = grid[i][j];\n               \
    \             }\n                        }\n                    }\n          \
    \      }\n                if(j > 0) {\n                    for(int l = 0; l <=\
    \ k; l++) {\n                        if(dp[i][j - 1] + 1 < dp[i][j]) {\n     \
    \                       dp[i][j] = dp[i][j - 1] + 1;\n                       \
    \     path[i][j] = path[i][j - 1];\n                            path[i][j][l]\
    \ = grid[i][j];\n                        }\n                        else if(dp[i][j\
    \ - 1] + 1 == dp", "    std::vector<long> ans;\n    // Write your code here\n\
    \    return ans;", "    std::vector<long> ans;\n    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> path(n, std::vector<int>(n, -1));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n    \
    \        if(i == 0 && j == 0) {\n                dp[i][j] = 0;\n             \
    \   continue;\n            }\n            if(i > 0) {\n                if(dp[i\
    \ - 1][j] + 1 < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + 1;\n\
    \                    path[i][j] = 0;\n                }\n            }\n     \
    \       if(j > 0) {\n                if(dp[i][j - 1] + 1 < dp[i][j]) {\n     \
    \               dp[i][j] = dp[i][j - 1] + 1;\n                    path[i][j] =\
    \ 1;\n                }\n            }\n        }\n    }\n    int i = n - 1, j\
    \ = n - 1;\n    while(k > 0) {\n        ans.push_back(grid[i][j]);\n        if(path[i][j]\
    \ == 0) {\n            i--;\n        } else {\n            j--;\n        }\n \
    \       k--;\n    }\n    return ans;"]
stop_tokens:
- "\n}"
